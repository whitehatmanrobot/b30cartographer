\x39f\x3bd\x3bf\x3bc\x3b1\x3c4\x3b5\x3c0\x3ce\x3bd\x3c5\x3bc\x3bf",
      //cn,???a 
      L"\x63\x6e\x2c\x38c\x3bd\x3bf\x3bc\x3b1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x408,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40b,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Ryhmn jsenyys 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x52\x79\x68\x6d\xe4\x6e\x20\x6a\xe4\x73\x65\x6e\x79\x79\x73",
      //memberOf,Jsenyys 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4a\xe4\x73\x65\x6e\x79\x79\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40b,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nimi 
      L"\x63\x6e\x2c\x4e\x69\x6d\x69",
      //dc,Nimi 
      L"\x64\x63\x2c\x4e\x69\x6d\x69",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40b,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Ryhmn jsenyys 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x52\x79\x68\x6d\xe4\x6e\x20\x6a\xe4\x73\x65\x6e\x79\x79\x73",
      //memberOf,Jsenyys 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4a\xe4\x73\x65\x6e\x79\x79\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40b,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Adhsion au groupe 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x41\x64\x68\xe9\x73\x69\x6f\x6e\x20\x61\x75\x20\x67\x72\x6f\x75\x70\x65",
      //memberOf,Membre de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x65\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"user-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse de page Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x57\x65\x62",
      //wWWHomePage,Adresse de page Vb 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x56\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"group-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse de page Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x57\x65\x62",
      //wWWHomePage,Adresse de page Vb 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x56\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nom 
      L"\x63\x6e\x2c\x4e\x6f\x6d",
      //dc,Nom 
      L"\x64\x63\x2c\x4e\x6f\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Adhsion au groupe 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x41\x64\x68\xe9\x73\x69\x6f\x6e\x20\x61\x75\x20\x67\x72\x6f\x75\x70\x65",
      //memberOf,Membre de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x65\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"contact-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adresse de page Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x57\x65\x62",
      //wWWHomePage,Adresse de page Vb 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x56\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMediaReady,Papier disponible 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x52\x65\x61\x64\x79\x2c\x50\x61\x70\x69\x65\x72\x20\x64\x69\x73\x70\x6f\x6e\x69\x62\x6c\x65",
      //printMediaReady,Papier disponible 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x52\x65\x61\x64\x79\x2c\x50\x61\x70\x69\x65\x72\x20\x64\x69\x73\x70\x6f\x6e\x69\x62\x6c\x65\xa0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printShareName,Nom de partage 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x20\x64\x65\x20\x70\x61\x72\x74\x61\x67\x65",
      //printShareName,Nom du partage 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x20\x64\x75\x20\x70\x61\x72\x74\x61\x67\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //serverName,Nom du serveur 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x20\x64\x75\x20\x73\x65\x72\x76\x65\x75\x72",
      //serverName,Nom de serveur 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x20\x64\x65\x20\x73\x65\x72\x76\x65\x75\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //url,Adresse de page Web 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x57\x65\x62",
      //url,Adresse de page Vb 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x73\x65\x20\x64\x65\x20\x70\x61\x67\x65\x20\x56\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"subnet-Display",
      L"classDisplayName",
      //Sous-rseau 
      L"\x53\x6f\x75\x73\x2d\x72\xe9\x73\x65\x61\x75",
      //Sous-rseau 
      L"\x53\x6f\x75\x73\x2d\x72\xe9\x73\x65\x61\x75\xa0",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"organizationalUnit-Display",
      L"classDisplayName",
      //Unit d'organisation 
      L"\x55\x6e\x69\x74\xe9\x20\x64\x27\x6f\x72\x67\x61\x6e\x69\x73\x61\x74\x69\x6f\x6e",
      //Unit d'organisation 
      L"\x55\x6e\x69\x74\xe9\x20\x64\x27\x6f\x72\x67\x61\x6e\x69\x73\x61\x74\x69\x6f\x6e\xa0",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"volume-Display",
      L"attributeDisplayNames",
      //keywords,Mots-cls 
      L"\x6b\x65\x79\x77\x6f\x72\x64\x73\x2c\x4d\x6f\x74\x73\x2d\x63\x6c\xe9\x73",
      //keywords,Mots cls 
      L"\x6b\x65\x79\x77\x6f\x72\x64\x73\x2c\x4d\x6f\x74\x73\x20\x63\x6c\xe9\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"volume-Display",
      L"classDisplayName",
      //Dossier partag 
      L"\x44\x6f\x73\x73\x69\x65\x72\x20\x70\x61\x72\x74\x61\x67\xe9",
      //Dossier partag 
      L"\x44\x6f\x73\x73\x69\x65\x72\x20\x70\x61\x72\x74\x61\x67\xe9\xa0",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40c,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"IntellimirrorGroup-Display",
      L"classDisplayName",
      //IntelliMirror Group 
      L"\x49\x6e\x74\x65\x6c\x6c\x69\x4d\x69\x72\x72\x6f\x72\x20\x47\x72\x6f\x75\x70",
      //????? IntelliMirror 
      L"\x5e7\x5d1\x5d5\x5e6\x5ea\x20\x49\x6e\x74\x65\x6c\x6c\x69\x4d\x69\x72\x72\x6f\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"IntellimirrorSCP-Display",
      L"classDisplayName",
      //IntelliMirror Service 
      L"\x49\x6e\x74\x65\x6c\x6c\x69\x4d\x69\x72\x72\x6f\x72\x20\x53\x65\x72\x76\x69\x63\x65",
      //????? IntelliMirror 
      L"\x5e9\x5d9\x5e8\x5d5\x5ea\x20\x49\x6e\x74\x65\x6c\x6c\x69\x4d\x69\x72\x72\x6f\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //assistant,???? 
      L"\x61\x73\x73\x69\x73\x74\x61\x6e\x74\x2c\x5e2\x5d5\x5d6\x5e8",
      //assistant,????? 
      L"\x61\x73\x73\x69\x73\x74\x61\x6e\x74\x2c\x5de\x5e1\x5d9\x5d9\x5e2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //c,????? ????? 
      L"\x63\x2c\x5e7\x5d9\x5e6\x5d5\x5e8\x20\x5de\x5d3\x5d9\x5e0\x5d4",
      //c,???? ????? ???? 
      L"\x63\x2c\x5e8\x5d0\x5e9\x5d9\x20\x5ea\x5d9\x5d1\x5d5\x5ea\x20\x5d4\x5d0\x5e8\x5e5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //co,????? 
      L"\x63\x6f\x2c\x5de\x5d3\x5d9\x5e0\x5d4",
      //co,??? 
      L"\x63\x6f\x2c\x5d0\x5e8\x5e5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //comment,???? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5d4\x5e2\x5e8\x5d4",
      //comment,????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5d4\x5e2\x5e8\x5d5\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //directReports,?????? ?????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x5db\x5e4\x5d5\x5e4\x5d9\x5dd\x20\x5d9\x5e9\x5d9\x5e8\x5d5\x5ea",
      //directReports,????? ???? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x5d3\x5d9\x5d5\x5d5\x5d7\x20\x5d9\x5e9\x5d9\x5e8",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //distinguishedName,?? ?????? ?? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x5e9\x5dc\x20\x58\x35\x30\x30",
      //distinguishedName,?? ?????? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //division,????? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x5d7\x5d8\x5d9\x5d1\x5d4",
      //division,????? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x5de\x5d7\x5dc\x5e7\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //employeeID,???? ???? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x5de\x5d6\x5d4\x5d4\x20\x5e2\x5d5\x5d1\x5d3",
      //employeeID,????? ???? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x5d6\x5d9\x5d4\x5d5\x5d9\x20\x5e2\x5d5\x5d1\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //generationQualifier,????? ?? ??? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x5e1\x5d9\x5d5\x5de\x5ea\x20\x5e9\x5dc\x20\x5d3\x5d5\x5e8",
      //generationQualifier,????? ???? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x5e1\x5d9\x5d5\x5de\x5ea\x20\x5d4\x5d3\x5d5\x5e8",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //homeDirectory,????? ????? 
      L"\x68\x6f\x6d\x65\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x2c\x5ea\x5d9\x5e7\x5d9\x5d4\x20\x5e8\x5d0\x5e9\x5d9\x5ea",
      //homeDirectory,?????? ???? 
      L"\x68\x6f\x6d\x65\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x2c\x5ea\x5d9\x5e7\x5d9\x5d9\x5ea\x20\x5d4\x5d1\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //homeDrive,???? ???? 
      L"\x68\x6f\x6d\x65\x44\x72\x69\x76\x65\x2c\x5db\x5d5\x5e0\x5df\x20\x5e8\x5d0\x5e9\x5d9",
      //homeDrive,???? ???? 
      L"\x68\x6f\x6d\x65\x44\x72\x69\x76\x65\x2c\x5db\x5d5\x5e0\x5df\x20\x5d4\x5d1\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //homePostalAddress,????? ???? 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d1\x5d1\x5d9\x5ea",
      //homePostalAddress,????? ???? 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d4\x5d1\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,???? ISDN ???????? (?????)? 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x49\x53\x44\x4e\x20\x5d1\x5d9\x5e0\x5dc\x5d0\x5d5\x5de\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //internationalISDNNumber,???? ISDN ???????? (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x49\x53\x44\x4e\x20\x5d1\x5d9\x5e0\x5dc\x5d0\x5d5\x5de\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //mail,????? ???? ???????? 
      L"\x6d\x61\x69\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x20\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9",
      //mail,????? ????-???????? 
      L"\x6d\x61\x69\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x2d\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,????? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x5d7\x5d1\x5e8\x5d5\x5ea\x20\x5d1\x5e7\x5d1\x5d5\x5e6\x5d4",
      //memberOf,??? ?- 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x5d7\x5d1\x5e8\x20\x5d1\x2d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //mobile,???? ???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e0\x5d9\x5d9\x5d3",
      //mobile,???? ????? ???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5e0\x5d9\x5d9\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,???? ??? (?????)? 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e4\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherFacsimileTelephoneNumber,???? ??? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e4\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,???? ????? ???? (?????)? 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5d1\x5d1\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherHomePhone,???? ????? ???? (?????) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5d1\x5d1\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,???? ????? IP (?????)? 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x49\x50\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200e",
      //otherIpPhone,???? ????? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x49\x50\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,????? ???? ???????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x20\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherMailbox,????? ????-???????? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x2d\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,???? ???? (?????)? 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e0\x5d9\x5d9\x5d3\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherMobile,???? ????? ???? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5e0\x5d9\x5d9\x5d3\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,???? ??????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d0\x5d9\x5ea\x5d5\x5e8\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherPager,???? ??????? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d6\x5d9\x5de\x5d5\x5e0\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,???? ????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherTelephone,???? ????? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //pager,???? ??????? 
      L"\x70\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d0\x5d9\x5ea\x5d5\x5e8\x5d9\x5ea",
      //pager,???? ??????? 
      L"\x70\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d6\x5d9\x5de\x5d5\x5e0\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,????? ???? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5de\x5e9\x5e8\x5d3",
      //physicalDeliveryOfficeName,????? ????? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5d4\x5de\x5e9\x5e8\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,?? ????? ?(???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5db\x5e0\x5d9\x5e1\x5d4\x20\x200e\x28\x5d8\x5e8\x5d5\x5dd\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,?? ?????? (???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5dc\x5db\x5e0\x5d9\x5e1\x5d4\x20\x28\x5dc\x5e4\x5e0\x5d9\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //streetAddress,????? ???? 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5e8\x5d7\x5d5\x5d1",
      //streetAddress,???? 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x5e8\x5d7\x5d5\x5d1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,???? ???? (?????)? 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //telexNumber,???? ???? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //title,???? ????? 
      L"\x74\x69\x74\x6c\x65\x2c\x5ea\x5d5\x5d0\x5e8\x20\x5ea\x5e4\x5e7\x5d9\x5d3",
      //title,????? 
      L"\x74\x69\x74\x6c\x65\x2c\x5ea\x5e4\x5e7\x5d9\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //url,????? ?? ??????? (?????)? 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //url,????? ?? ??????? (?????) 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //displayName,?? ????? 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5ea\x5e6\x5d5\x5d2\x5d4",
      //displayName,?? ?????? 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5dc\x5ea\x5e6\x5d5\x5d2\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //userWorkstations,????? ????? ?????? ????? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x5ea\x5d7\x5e0\x5d5\x5ea\x20\x5e2\x5d1\x5d5\x5d3\x5d4\x20\x5dc\x5d1\x5d9\x5e6\x5d5\x5e2\x20\x5db\x5e0\x5d9\x5e1\x5d4",
      //userWorkstations,????? ????? ?????? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\x5ea\x5d7\x5e0\x5d5\x5ea\x20\x5e2\x5d1\x5d5\x5d3\x5d4\x20\x5dc\x5db\x5e0\x5d9\x5e1\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"user-Display",
      L"attributeDisplayNames",
      //userPrincipalName,?? ????? 
      L"\x75\x73\x65\x72\x50\x72\x69\x6e\x63\x69\x70\x61\x6c\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5db\x5e0\x5d9\x5e1\x5d4",
      //userPrincipalName,?? ?????? 
      L"\x75\x73\x65\x72\x50\x72\x69\x6e\x63\x69\x70\x61\x6c\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5dc\x5db\x5e0\x5d9\x5e1\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //c,????? ????? 
      L"\x63\x2c\x5e7\x5d9\x5e6\x5d5\x5e8\x20\x5de\x5d3\x5d9\x5e0\x5d4",
      //c,???? ????? ???? 
      L"\x63\x2c\x5e8\x5d0\x5e9\x5d9\x20\x5ea\x5d9\x5d1\x5d5\x5ea\x20\x5d4\x5d0\x5e8\x5e5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //distinguishedName,?? ?????? ?? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x5e9\x5dc\x20\x58\x35\x30\x30",
      //distinguishedName,?? ?????? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //managedBy,?????? ??-??? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d5\x5d4\x5dc\x5ea\x20\x5e2\x5dc\x2d\x5d9\x5d3\x5d9",
      //managedBy,???? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d4\x5dc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,????? ???? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5de\x5e9\x5e8\x5d3",
      //physicalDeliveryOfficeName,????? ????? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5d4\x5de\x5e9\x5e8\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,?? ?????? (???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5e7\x5d1\x5d5\x5e6\x5d4\x200e\x20\x28\x5d8\x5e8\x5d5\x5dd\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,?? ????? (???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5e7\x5d1\x5d5\x5e6\x5d4\x20\x28\x5dc\x5e4\x5e0\x5d9\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"group-Display",
      L"attributeDisplayNames",
      //url,????? ?? ??????? (?????)? 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //url,????? ?? ??????? (?????) 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?? 
      L"\x63\x6e\x2c\x5e9\x5dd",
      //dc,?? 
      L"\x64\x63\x2c\x5e9\x5dd",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //assistant,???? 
      L"\x61\x73\x73\x69\x73\x74\x61\x6e\x74\x2c\x5e2\x5d5\x5d6\x5e8",
      //assistant,????? 
      L"\x61\x73\x73\x69\x73\x74\x61\x6e\x74\x2c\x5de\x5e1\x5d9\x5d9\x5e2",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //c,????? ????? 
      L"\x63\x2c\x5e7\x5d9\x5e6\x5d5\x5e8\x20\x5de\x5d3\x5d9\x5e0\x5d4",
      //c,???? ????? ???? 
      L"\x63\x2c\x5e8\x5d0\x5e9\x5d9\x20\x5ea\x5d9\x5d1\x5d5\x5ea\x20\x5d4\x5d0\x5e8\x5e5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //co,????? 
      L"\x63\x6f\x2c\x5de\x5d3\x5d9\x5e0\x5d4",
      //co,??? 
      L"\x63\x6f\x2c\x5d0\x5e8\x5e5",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //comment,???? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5d4\x5e2\x5e8\x5d4",
      //comment,????? 
      L"\x63\x6f\x6d\x6d\x65\x6e\x74\x2c\x5d4\x5e2\x5e8\x5d5\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //directReports,?????? ?????? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x5db\x5e4\x5d5\x5e4\x5d9\x5dd\x20\x5d9\x5e9\x5d9\x5e8\x5d5\x5ea",
      //directReports,????? ???? 
      L"\x64\x69\x72\x65\x63\x74\x52\x65\x70\x6f\x72\x74\x73\x2c\x5d3\x5d9\x5d5\x5d5\x5d7\x20\x5d9\x5e9\x5d9\x5e8",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //displayName,?? ????? 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5ea\x5e6\x5d5\x5d2\x5d4",
      //displayName,?? ?????? 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5dc\x5ea\x5e6\x5d5\x5d2\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //distinguishedName,?? ?????? ?? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x5e9\x5dc\x20\x58\x35\x30\x30",
      //distinguishedName,?? ?????? X500 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d9\x5d9\x5d7\x5d5\x5d3\x5d9\x20\x58\x35\x30\x30",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //division,????? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x5d7\x5d8\x5d9\x5d1\x5d4",
      //division,????? 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x5de\x5d7\x5dc\x5e7\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //employeeID,???? ???? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x5de\x5d6\x5d4\x5d4\x20\x5e2\x5d5\x5d1\x5d3",
      //employeeID,????? ???? 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x5d6\x5d9\x5d4\x5d5\x5d9\x20\x5e2\x5d5\x5d1\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //generationQualifier,????? ?? ??? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x5e1\x5d9\x5d5\x5de\x5ea\x20\x5e9\x5dc\x20\x5d3\x5d5\x5e8",
      //generationQualifier,????? ???? 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x5e1\x5d9\x5d5\x5de\x5ea\x20\x5d4\x5d3\x5d5\x5e8",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //homePostalAddress,????? ???? 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d1\x5d1\x5d9\x5ea",
      //homePostalAddress,????? ???? 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d4\x5d1\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,???? ISDN ???????? (?????)? 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x49\x53\x44\x4e\x20\x5d1\x5d9\x5e0\x5dc\x5d0\x5d5\x5de\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //internationalISDNNumber,???? ISDN ???????? (?????) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x49\x53\x44\x4e\x20\x5d1\x5d9\x5e0\x5dc\x5d0\x5d5\x5de\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //mail,????? ???? ???????? 
      L"\x6d\x61\x69\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x20\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9",
      //mail,????? ????-???????? 
      L"\x6d\x61\x69\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x2d\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,????? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x5d7\x5d1\x5e8\x5d5\x5ea\x20\x5d1\x5e7\x5d1\x5d5\x5e6\x5d4",
      //memberOf,??? ?- 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x5d7\x5d1\x5e8\x20\x5d1\x2d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //mobile,???? ???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e0\x5d9\x5d9\x5d3",
      //mobile,???? ????? ???? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5e0\x5d9\x5d9\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,???? ??? (?????)? 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e4\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherFacsimileTelephoneNumber,???? ??? (?????) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e4\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,???? ????? ???? (?????)? 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5d1\x5d1\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherHomePhone,???? ????? ???? (?????) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5d1\x5d1\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,???? ????? IP (?????)? 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x49\x50\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200e",
      //otherIpPhone,???? ????? IP (?????) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x49\x50\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,????? ???? ???????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x20\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherMailbox,????? ????-???????? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5d5\x5d0\x5e8\x2d\x5d0\x5dc\x5e7\x5d8\x5e8\x5d5\x5e0\x5d9\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,???? ???? (?????)? 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5e0\x5d9\x5d9\x5d3\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherMobile,???? ????? ???? (?????) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x5e0\x5d9\x5d9\x5d3\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,???? ??????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d0\x5d9\x5ea\x5d5\x5e8\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherPager,???? ??????? (?????) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d6\x5d9\x5de\x5d5\x5e0\x5d9\x5ea\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,???? ????? (?????)? 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //otherTelephone,???? ????? (?????) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e4\x5d5\x5df\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //pager,???? ??????? 
      L"\x70\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d0\x5d9\x5ea\x5d5\x5e8\x5d9\x5ea",
      //pager,???? ??????? 
      L"\x70\x61\x67\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d6\x5d9\x5de\x5d5\x5e0\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,????? ???? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5de\x5e9\x5e8\x5d3",
      //physicalDeliveryOfficeName,????? ????? 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x5de\x5d9\x5e7\x5d5\x5dd\x20\x5d4\x5de\x5e9\x5e8\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //streetAddress,????? ???? 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5e8\x5d7\x5d5\x5d1",
      //streetAddress,???? 
      L"\x73\x74\x72\x65\x65\x74\x41\x64\x64\x72\x65\x73\x73\x2c\x5e8\x5d7\x5d5\x5d1",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,???? ???? (?????)? 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //telexNumber,???? ???? (?????) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x5de\x5e1\x5e4\x5e8\x20\x5d8\x5dc\x5e7\x5e1\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //title,???? ????? 
      L"\x74\x69\x74\x6c\x65\x2c\x5ea\x5d5\x5d0\x5e8\x20\x5ea\x5e4\x5e7\x5d9\x5d3",
      //title,????? 
      L"\x74\x69\x74\x6c\x65\x2c\x5ea\x5e4\x5e7\x5d9\x5d3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,????? ?? ??????? (?????)? 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29\x200f",
      //url,????? ?? ??????? (?????) 
      L"\x75\x72\x6c\x2c\x5db\x5ea\x5d5\x5d1\x5ea\x20\x5d3\x5e3\x20\x5d0\x5d9\x5e0\x5d8\x5e8\x5e0\x5d8\x20\x28\x5d0\x5d7\x5e8\x5d9\x5dd\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"computer-Display",
      L"attributeDisplayNames",
      //managedBy,?????? ??-??? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d5\x5d4\x5dc\x5ea\x20\x5e2\x5dc\x2d\x5d9\x5d3\x5d9",
      //managedBy,???? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d4\x5dc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,?? ???? ?(???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5de\x5d7\x5e9\x5d1\x20\x200e\x28\x5d8\x5e8\x5d5\x5dd\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,?? ???? (???? Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5de\x5d7\x5e9\x5d1\x20\x28\x5dc\x5e4\x5e0\x5d9\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //cn,?? ????? ?????? 
      L"\x63\x6e\x2c\x5e9\x5dd\x20\x5e9\x5d9\x5e8\x5d5\x5ea\x20\x5e1\x5e4\x5e8\x5d9\x5d5\x5ea",
      //cn,?? ????? ?????? 
      L"\x63\x6e\x2c\x5e9\x5dd\x20\x5e9\x5d9\x5e8\x5d5\x5ea\x20\x5e1\x5e4\x5e8\x5d9\x5d9\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //description,???? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x5d4\x5e2\x5e8\x5d4",
      //description,????? 
      L"\x64\x65\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x2c\x5d4\x5e2\x5e8\x5d5\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //driverName,??? 
      L"\x64\x72\x69\x76\x65\x72\x4e\x61\x6d\x65\x2c\x5d3\x5d2\x5dd",
      //driverName,???? 
      L"\x64\x72\x69\x76\x65\x72\x4e\x61\x6d\x65\x2c\x5de\x5d5\x5d3\x5dc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printLanguage,??? ????? 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x5e9\x5e4\x5ea\x20\x5de\x5d3\x5e4\x5e1\x5ea",
      //printLanguage,??? ?????? 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x5e9\x5e4\x5ea\x20\x5d4\x5de\x5d3\x5e4\x5e1\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMaxResolutionSupported,???????? ???????? 
      L"\x70\x72\x69\x6e\x74\x4d\x61\x78\x52\x65\x73\x6f\x6c\x75\x74\x69\x6f\x6e\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x5e8\x5d6\x5d5\x5dc\x5d5\x5e6\x5d9\x5d4\x20\x5de\x5e7\x5e1\x5d9\x5de\x5dc\x5d9\x5ea",
      //printMaxResolutionSupported,???????? ????? 
      L"\x70\x72\x69\x6e\x74\x4d\x61\x78\x52\x65\x73\x6f\x6c\x75\x74\x69\x6f\x6e\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x5e8\x5d6\x5d5\x5dc\x5d5\x5e6\x5d9\x5d4\x20\x5de\x5e8\x5d1\x5d9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printPagesPerMinute,???? ???? 
      L"\x70\x72\x69\x6e\x74\x50\x61\x67\x65\x73\x50\x65\x72\x4d\x69\x6e\x75\x74\x65\x2c\x5d3\x5e4\x5d9\x5dd\x20\x5dc\x5d3\x5e7\x5d4",
      //printPagesPerMinute,???? ???? 
      L"\x70\x72\x69\x6e\x74\x50\x61\x67\x65\x73\x50\x65\x72\x4d\x69\x6e\x75\x74\x65\x2c\x5d3\x5e4\x5d9\x5dd\x20\x5d1\x5d3\x5e7\x5d4",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printShareName,?? ????? 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5e9\x5d9\x5ea\x5d5\x5e3",
      //printShareName,?? ????? 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5de\x5e9\x5d5\x5ea\x5e3",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //serverName,?? ??? 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5e9\x5e8\x5ea",
      //serverName,?? ???? 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x5e9\x5dd\x20\x5d4\x5e9\x5e8\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //versionNumber,????? ??????? 
      L"\x76\x65\x72\x73\x69\x6f\x6e\x4e\x75\x6d\x62\x65\x72\x2c\x5d2\x5d9\x5e8\x5e1\x5ea\x20\x5d0\x5d5\x5d1\x5d9\x5d9\x5e7\x5d8",
      //versionNumber,????? ???????? 
      L"\x76\x65\x72\x73\x69\x6f\x6e\x4e\x75\x6d\x62\x65\x72\x2c\x5d2\x5d9\x5e8\x5e1\x5ea\x20\x5d4\x5d0\x5d5\x5d1\x5d9\x5d9\x5e7\x5d8",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"nTDSConnection-Display",
      L"classDisplayName",
      //??????? 
      L"\x5d4\x5ea\x5e7\x5e9\x5e8\x5d5\x5ea",
      //????? 
      L"\x5d7\x5d9\x5d1\x5d5\x5e8",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"nTFRSReplicaSet-Display",
      L"classDisplayName",
      //????? ?????? ???????? ?? FRS 
      L"\x5e7\x5d1\x5d5\x5e6\x5ea\x20\x5e2\x5d5\x5ea\x5e7\x5d9\x5dd\x20\x5de\x5e9\x5d5\x5db\x5e4\x5dc\x5d9\x5dd\x20\x5e9\x5dc\x20\x46\x52\x53",
      //???? ?????? ???????? ?? FRS 
      L"\x5e2\x5e8\x5db\x5ea\x20\x5e2\x5d5\x5ea\x5e7\x5d9\x5dd\x20\x5de\x5e9\x5d5\x5db\x5e4\x5dc\x5d9\x5dd\x20\x5e9\x5dc\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"subnet-Display",
      L"classDisplayName",
      //??? ???? 
      L"\x5e8\x5e9\x5ea\x20\x5de\x5e9\x5e0\x5d4",
      //??? ????? Subnet 
      L"\x5e8\x5e9\x5ea\x20\x5de\x5e9\x5e0\x5d9\x5ea\x20\x53\x75\x62\x6e\x65\x74",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"siteLink-Display",
      L"classDisplayName",
      //????? ?????? 
      L"\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5dc\x5d0\x5ea\x5e8\x5d9\x5dd",
      //????? ???? 
      L"\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5dc\x5d0\x5ea\x5e8",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"siteLinkBridge-Display",
      L"classDisplayName",
      //??? ????? ?????? 
      L"\x5d2\x5e9\x5e8\x20\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5dc\x5d0\x5ea\x5e8\x5d9\x5dd",
      //??? ????? ???? 
      L"\x5d2\x5e9\x5e8\x20\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5dc\x5d0\x5ea\x5e8",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"interSiteTransport-Display",
      L"classDisplayName",
      //?????? ???? ????? 
      L"\x5ea\x5e2\x5d1\x5d5\x5e8\x5d4\x20\x5d1\x5ea\x5d5\x5da\x20\x5d0\x5ea\x5e8\x5d9\x5dd",
      //?????? ???-????? 
      L"\x5ea\x5e2\x5d1\x5d5\x5e8\x5d4\x20\x5d1\x5d9\x5df\x2d\x5d0\x5ea\x5e8\x5d9\x5dd",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"licensingSiteSettings-Display",
      L"classDisplayName",
      //?????? ??? ????? 
      L"\x5d4\x5d2\x5d3\x5e8\x5d5\x5ea\x20\x5d0\x5ea\x5e8\x20\x5e8\x5d9\x5e9\x5d5\x5d9",
      //????? ??????? ??? 
      L"\x5e8\x5e9\x5d9\x5d5\x5df\x20\x5dc\x5d4\x5d2\x5d3\x5e8\x5d5\x5ea\x20\x5d0\x5ea\x5e8",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"nTFRSSubscriptions-Display",
      L"classDisplayName",
      //????? FRS 
      L"\x5de\x5e0\x5d5\x5d9\x5d9\x20\x46\x52\x53",
      //?????? ?-FRS 
      L"\x5de\x5e0\x5d5\x5d9\x5d9\x5dd\x20\x5dc\x2d\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"organizationalUnit-Display",
      L"attributeDisplayNames",
      //managedBy,?????? ??-??? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d5\x5d4\x5dc\x5ea\x20\x5e2\x5dc\x2d\x5d9\x5d3\x5d9",
      //managedBy,???? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d4\x5dc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"volume-Display",
      L"attributeDisplayNames",
      //managedBy,?????? ??-??? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d5\x5d4\x5dc\x5ea\x20\x5e2\x5dc\x2d\x5d9\x5d3\x5d9",
      //managedBy,???? 
      L"\x6d\x61\x6e\x61\x67\x65\x64\x42\x79\x2c\x5de\x5e0\x5d4\x5dc",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"volume-Display",
      L"attributeDisplayNames",
      //uNCName,???? ??? 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x5e0\x5ea\x5d9\x5d1\x20\x5e8\x5e9\x5ea",
      //uNCName,???? ???? 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x5e0\x5ea\x5d9\x5d1\x20\x5d4\x5e8\x5e9\x5ea",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"volume-Display",
      L"classDisplayName",
      //????? ?????? 
      L"\x5ea\x5d9\x5e7\x5d9\x5d4\x20\x5de\x5e9\x5d5\x5ea\x5e4\x5ea",
      //?????? ?????? 
      L"\x5ea\x5d9\x5e7\x5d9\x5d9\x5d4\x20\x5de\x5e9\x5d5\x5ea\x5e4\x5ea",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //MSMQ Enterprise 
      L"\x4d\x53\x4d\x51\x20\x45\x6e\x74\x65\x72\x70\x72\x69\x73\x65",
      //????? MSMQ 
      L"\x5d0\x5e8\x5d2\x5d5\x5df\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"mSMQMigratedUser-Display",
      L"classDisplayName",
      //????? ?????? ?? MSMQ 
      L"\x5de\x5e9\x5ea\x5de\x5e9\x20\x5de\x5e9\x5d5\x5d3\x5e8\x5d2\x20\x5e9\x5dc\x20\x4d\x53\x4d\x51",
      //????? ?????? ?-MSMQ 
      L"\x5de\x5e9\x5ea\x5de\x5e9\x20\x5de\x5e9\x5d5\x5d3\x5e8\x5d2\x20\x5d1\x2d\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"mSMQSiteLink-Display",
      L"classDisplayName",
      //????? ?????? MSMQ 
      L"\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5dc\x5e0\x5d9\x5ea\x5d5\x5d1\x20\x4d\x53\x4d\x51",
      //????? ???? MSMQ 
      L"\x5e7\x5d9\x5e9\x5d5\x5e8\x20\x5de\x5e0\x5ea\x5d1\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"remoteStorageServicePoint-Display",
      L"adminContextMenu",
      //0,&???...,RsAdmin.msc 
      L"\x30\x2c\x26\x5e0\x5d4\x5dc\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      //0,&?????...,RsAdmin.msc 
      L"\x30\x2c\x26\x5e0\x5d9\x5d4\x5d5\x5dc\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"remoteStorageServicePoint-Display",
      L"classDisplayName",
      //????? ????? ????? 
      L"\x5e9\x5d9\x5e8\x5d5\x5ea\x20\x5d0\x5d7\x5e1\x5d5\x5df\x20\x5de\x5e8\x5d5\x5d7\x5e7",
      //????? ?????? ????? 
      L"\x5e9\x5d9\x5e8\x5d5\x5ea\x20\x5d0\x5d9\x5d7\x5e1\x5d5\x5df\x20\x5de\x5e8\x5d5\x5d7\x5e7",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //???? ???? ?? ?????? ???? ????? 
      L"\x5d2\x5d5\x5e8\x5dd\x20\x5de\x5db\x5d9\x5dc\x20\x5e9\x5dc\x20\x5ea\x5e2\x5d1\x5d5\x5e8\x5d4\x20\x5d1\x5ea\x5d5\x5da\x20\x5d0\x5ea\x5e8\x5d9\x5dd",
      //???? ???? ?? ?????? ???-????? 
      L"\x5d2\x5d5\x5e8\x5dd\x20\x5de\x5db\x5d9\x5dc\x20\x5e9\x5dc\x20\x5de\x5e2\x5d1\x5d5\x5e8\x5d4\x20\x5d1\x5d9\x5df\x2d\x5d0\x5ea\x5e8\x5d9\x5dd",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"subnetContainer-Display",
      L"classDisplayName",
      //???? ???? ?? ????? ???? 
      L"\x5d2\x5d5\x5e8\x5dd\x20\x5de\x5db\x5d9\x5dc\x20\x5e9\x5dc\x20\x5e8\x5e9\x5ea\x5d5\x5ea\x20\x5de\x5e9\x5e0\x5d4",
      //???? ???? ?? ????? ???? (Subnets) 
      L"\x5d2\x5d5\x5e8\x5dd\x20\x5de\x5db\x5d9\x5dc\x20\x5e9\x5dc\x20\x5e8\x5e9\x5ea\x5d5\x5ea\x20\x5de\x5e9\x5e0\x5d4\x20\x28\x53\x75\x62\x6e\x65\x74\x73\x29",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"queryPolicy-Display",
      L"classDisplayName",
      //??????? ??????? 
      L"\x5de\x5d3\x5d9\x5e0\x5d9\x5d5\x5ea\x20\x5e9\x5d0\x5d9\x5dc\x5ea\x5d5\x5ea",
      //??????? ?????? 
      L"\x5de\x5d3\x5d9\x5e0\x5d9\x5d5\x5ea\x20\x5e9\x5d0\x5d9\x5dc\x5ea\x5d4",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //???? ????? ??? 
      L"\x5de\x5e0\x5d4\x5dc\x20\x5d0\x5d1\x5d8\x5d7\x5ea\x20\x5d7\x5d5\x5e5",
      //??? ??????? ???? 
      L"\x5e7\x5e8\x5df\x20\x5d1\x5d8\x5d7\x5d5\x5e0\x5d5\x5ea\x20\x5d6\x5e8\x5d9\x5dd",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40d,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"user-Display",
      L"attributeDisplayNames",
      //l,Vros 
      L"\x6c\x2c\x56\xe1\x72\x6f\x73",
      //l,Telepls 
      L"\x6c\x2c\x54\x65\x6c\x65\x70\xfc\x6c\xe9\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"user-Display",
      L"attributeDisplayNames",
      //mail,Elektronikus levlcm 
      L"\x6d\x61\x69\x6c\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x6b\x75\x73\x20\x6c\x65\x76\xe9\x6c\x63\xed\x6d",
      //mail,E-mail cm 
      L"\x6d\x61\x69\x6c\x2c\x45\x2d\x6d\x61\x69\x6c\x20\x63\xed\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Csoporttagsg 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x73\x6f\x70\x6f\x72\x74\x74\x61\x67\x73\xe1\x67",
      //memberOf,A kvetkezo tagja 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x41\x20\x6b\xf6\x76\x65\x74\x6b\x65\x7a\x151\x20\x74\x61\x67\x6a\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"group-Display",
      L"attributeDisplayNames",
      //l,Vros 
      L"\x6c\x2c\x56\xe1\x72\x6f\x73",
      //l,Telepls 
      L"\x6c\x2c\x54\x65\x6c\x65\x70\xfc\x6c\xe9\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,Windows 2000 elotti csoportnv 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x65\x6c\x151\x74\x74\x69\x20\x63\x73\x6f\x70\x6f\x72\x74\x6e\xe9\x76",
      //samAccountName,Csoportnv (Windows 2000 elotti rendszer) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x43\x73\x6f\x70\x6f\x72\x74\x6e\xe9\x76\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x65\x6c\x151\x74\x74\x69\x20\x72\x65\x6e\x64\x73\x7a\x65\x72\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nv 
      L"\x63\x6e\x2c\x4e\xe9\x76",
      //dc,Nv 
      L"\x64\x63\x2c\x4e\xe9\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"contact-Display",
      L"attributeDisplayNames",
      //l,Vros 
      L"\x6c\x2c\x56\xe1\x72\x6f\x73",
      //l,Telepls 
      L"\x6c\x2c\x54\x65\x6c\x65\x70\xfc\x6c\xe9\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"contact-Display",
      L"attributeDisplayNames",
      //mail,Elektronikus levlcm 
      L"\x6d\x61\x69\x6c\x2c\x45\x6c\x65\x6b\x74\x72\x6f\x6e\x69\x6b\x75\x73\x20\x6c\x65\x76\xe9\x6c\x63\xed\x6d",
      //mail,E-mail cm 
      L"\x6d\x61\x69\x6c\x2c\x45\x2d\x6d\x61\x69\x6c\x20\x63\xed\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Csoporttagsg 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x73\x6f\x70\x6f\x72\x74\x74\x61\x67\x73\xe1\x67",
      //memberOf,A kvetkezo tagja 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x41\x20\x6b\xf6\x76\x65\x74\x6b\x65\x7a\x151\x20\x74\x61\x67\x6a\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"serviceAdministrationPoint-Display",
      L"classDisplayName",
      //Szolgltats 
      L"\x53\x7a\x6f\x6c\x67\xe1\x6c\x74\x61\x74\xe1\x73",
      //Active Directory szolgltats 
      L"\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x20\x73\x7a\x6f\x6c\x67\xe1\x6c\x74\x61\x74\xe1\x73",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Windows 2000 elotti szmtgpnv 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x65\x6c\x151\x74\x74\x69\x20\x73\x7a\xe1\x6d\xed\x74\xf3\x67\xe9\x70\x6e\xe9\x76",
      //samAccountName,Szmtgpnv (Windows 2000 elotti rendszer) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x53\x7a\xe1\x6d\xed\x74\xf3\x67\xe9\x70\x6e\xe9\x76\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x65\x6c\x151\x74\x74\x69\x20\x72\x65\x6e\x64\x73\x7a\x65\x72\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"trustedDomain-Display",
      L"classDisplayName",
      //Meghatalmazott tartomny 
      L"\x4d\x65\x67\x68\x61\x74\x61\x6c\x6d\x61\x7a\x6f\x74\x74\x20\x74\x61\x72\x74\x6f\x6d\xe1\x6e\x79",
      //Megbzhat tartomny 
      L"\x4d\x65\x67\x62\xed\x7a\x68\x61\x74\xf3\x20\x74\x61\x72\x74\x6f\x6d\xe1\x6e\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //Helykzi tvitelek trolja 
      L"\x48\x65\x6c\x79\x6b\xf6\x7a\x69\x20\xe1\x74\x76\x69\x74\x65\x6c\x65\x6b\x20\x74\xe1\x72\x6f\x6c\xf3\x6a\x61",
      //Helyek kztti tvitel trolja 
      L"\x48\x65\x6c\x79\x65\x6b\x20\x6b\xf6\x7a\xf6\x74\x74\x69\x20\xe1\x74\x76\x69\x74\x65\x6c\x20\x74\xe1\x72\x6f\x6c\xf3\x6a\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"queryPolicy-Display",
      L"classDisplayName",
      //Lekrdezsi hzirend 
      L"\x4c\x65\x6b\xe9\x72\x64\x65\x7a\xe9\x73\x69\x20\x68\xe1\x7a\x69\x72\x65\x6e\x64",
      //Lekrdezsek hzirendje 
      L"\x4c\x65\x6b\xe9\x72\x64\x65\x7a\xe9\x73\x65\x6b\x20\x68\xe1\x7a\x69\x72\x65\x6e\x64\x6a\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Klso szereplo 
      L"\x4b\xfc\x6c\x73\x151\x20\x73\x7a\x65\x72\x65\x70\x6c\x151",
      //Idegen biztonsgi egyszerunv 
      L"\x49\x64\x65\x67\x65\x6e\x20\x62\x69\x7a\x74\x6f\x6e\x73\xe1\x67\x69\x20\x65\x67\x79\x73\x7a\x65\x72\x171\x6e\xe9\x76",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"pKICertificateTemplate-Display",
      L"classDisplayName",
      //Bizonytvnysablon 
      L"\x42\x69\x7a\x6f\x6e\x79\xed\x74\x76\xe1\x6e\x79\x73\x61\x62\x6c\x6f\x6e",
      //Tanstvnysablon 
      L"\x54\x61\x6e\xfa\x73\xed\x74\x76\xe1\x6e\x79\x73\x61\x62\x6c\x6f\x6e",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x40e,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"user-Display",
      L"attributeDisplayNames",
      //ipPhone,Numero telefonico IP  
      L"\x69\x70\x50\x68\x6f\x6e\x65\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x69\x63\x6f\x20\x49\x50\x20",
      //ipPhone,Numero telefonico IP 
      L"\x69\x70\x50\x68\x6f\x6e\x65\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x69\x63\x6f\x20\x49\x50",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"user-Display",
      L"attributeDisplayNames",
      //primaryInternationalISDNNumber,Numero ISDN internazionale  
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x7a\x69\x6f\x6e\x61\x6c\x65\x20",
      //primaryInternationalISDNNumber,Numero ISDN internazionale 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x7a\x69\x6f\x6e\x61\x6c\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nome utente 
      L"\x63\x6e\x2c\x4e\x6f\x6d\x65\x20\x75\x74\x65\x6e\x74\x65",
      //dc,Nome utente 
      L"\x64\x63\x2c\x4e\x6f\x6d\x65\x20\x75\x74\x65\x6e\x74\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"contact-Display",
      L"attributeDisplayNames",
      //ipPhone,Numero telefonico IP  
      L"\x69\x70\x50\x68\x6f\x6e\x65\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x69\x63\x6f\x20\x49\x50\x20",
      //ipPhone,Numero telefonico IP 
      L"\x69\x70\x50\x68\x6f\x6e\x65\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x69\x63\x6f\x20\x49\x50",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"contact-Display",
      L"attributeDisplayNames",
      //primaryInternationalISDNNumber,Numero ISDN internazionale  
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x7a\x69\x6f\x6e\x61\x6c\x65\x20",
      //primaryInternationalISDNNumber,Numero ISDN internazionale 
      L"\x70\x72\x69\x6d\x61\x72\x79\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x4e\x75\x6d\x65\x72\x6f\x20\x49\x53\x44\x4e\x20\x69\x6e\x74\x65\x72\x6e\x61\x7a\x69\x6f\x6e\x61\x6c\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"serviceAdministrationPoint-Display",
      L"classDisplayName",
      //Servizio 
      L"\x53\x65\x72\x76\x69\x7a\x69\x6f",
      //Servizio Active Directory 
      L"\x53\x65\x72\x76\x69\x7a\x69\x6f\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Valore principale protezione esterna 
      L"\x56\x61\x6c\x6f\x72\x65\x20\x70\x72\x69\x6e\x63\x69\x70\x61\x6c\x65\x20\x70\x72\x6f\x74\x65\x7a\x69\x6f\x6e\x65\x20\x65\x73\x74\x65\x72\x6e\x61",
      //Responsabili esterni protezione 
      L"\x52\x65\x73\x70\x6f\x6e\x73\x61\x62\x69\x6c\x69\x20\x65\x73\x74\x65\x72\x6e\x69\x20\x70\x72\x6f\x74\x65\x7a\x69\x6f\x6e\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"pKICertificateTemplate-Display",
      L"classDisplayName",
      //Modello certificato 
      L"\x4d\x6f\x64\x65\x6c\x6c\x6f\x20\x63\x65\x72\x74\x69\x66\x69\x63\x61\x74\x6f",
      //Modello di certificato 
      L"\x4d\x6f\x64\x65\x6c\x6c\x6f\x20\x64\x69\x20\x63\x65\x72\x74\x69\x66\x69\x63\x61\x74\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x410,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,???? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x30b0\x30eb\x30fc\x30d7\x20\x30e1\x30f3\x30d0\x30b7\x30c3\x30d7",
      //memberOf,???????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x6240\x5c5e\x3059\x308b\x30b0\x30eb\x30fc\x30d7",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"user-Display",
      L"attributeDisplayNames",
      //mobile,???????? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x30e2\x30d0\x30a4\x30eb\x96fb\x8a71\x756a\x53f7",
      //mobile,?????? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x643a\x5e2f\x96fb\x8a71\x756a\x53f7",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,???????? (???) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x30e2\x30d0\x30a4\x30eb\x96fb\x8a71\x756a\x53f7\x20\x28\x305d\x306e\x4ed6\x29",
      //otherMobile,?????? (???) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x643a\x5e2f\x96fb\x8a71\x756a\x53f7\x20\x28\x305d\x306e\x4ed6\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?? 
      L"\x63\x6e\x2c\x540d\x524d",
      //dc,?? 
      L"\x64\x63\x2c\x540d\x524d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,???? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x30b0\x30eb\x30fc\x30d7\x20\x30e1\x30f3\x30d0\x30b7\x30c3\x30d7",
      //memberOf,???????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x6240\x5c5e\x3059\x308b\x30b0\x30eb\x30fc\x30d7",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"contact-Display",
      L"attributeDisplayNames",
      //mobile,???????? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x30e2\x30d0\x30a4\x30eb\x96fb\x8a71\x756a\x53f7",
      //mobile,?????? 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x643a\x5e2f\x96fb\x8a71\x756a\x53f7",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,???????? (???) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x30e2\x30d0\x30a4\x30eb\x96fb\x8a71\x756a\x53f7\x20\x28\x305d\x306e\x4ed6\x29",
      //otherMobile,?????? (???) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x643a\x5e2f\x96fb\x8a71\x756a\x53f7\x20\x28\x305d\x306e\x4ed6\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //MSMQ ??????? 
      L"\x4d\x53\x4d\x51\x20\x30a8\x30f3\x30bf\x30d7\x30e9\x30a4\x30ba",
      //MSMQ ???????? 
      L"\x4d\x53\x4d\x51\x20\x30a8\x30f3\x30bf\x30fc\x30d7\x30e9\x30a4\x30ba",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x411,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //givenName,??(? ??) 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984\x28\xc131\x20\xc5c6\xc74c\x29",
      //givenName,?? 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,?? ISDN ?? (??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\xad6d\xc81c\x20\x49\x53\x44\x4e\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //internationalISDNNumber,?? ISDN ??(??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\xad6d\xc81c\x20\x49\x53\x44\x4e\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,?? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xadf8\xb8f9\x20\xb4f1\xb85d",
      //memberOf,?? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xc18c\xc18d\x20\xadf8\xb8f9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\xd329\xc2a4\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherFacsimileTelephoneNumber,?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\xd329\xc2a4\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP ?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\xc804\xd654\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherIpPhone,IP ?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\xc804\xd654\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,?? ?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\xc804\xc790\x20\xba54\xc77c\x20\xc8fc\xc18c\x20\x28\xae30\xd0c0\x29",
      //otherMailbox,?? ?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\xc804\xc790\x20\xba54\xc77c\x20\xc8fc\xc18c\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,??? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\xd734\xb300\xd3f0\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherMobile,??? ??(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\xd734\xb300\xd3f0\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,??? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\xd638\xcd9c\xae30\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherPager,??? ??(??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\xd638\xcd9c\xae30\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\xc804\xd654\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherTelephone,?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\xc804\xd654\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //personalTitle,?? 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xd638\xce6d",
      //personalTitle,?? 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xc9c1\xd568",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,??? ?? (??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\xd154\xb809\xc2a4\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //telexNumber,??? ??(??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\xd154\xb809\xc2a4\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //url,? ??? ?? (??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x20\x28\xae30\xd0c0\x29",
      //url,? ??? ??(??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"user-Display",
      L"attributeDisplayNames",
      //userWorkstations,??? ?????? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\xb85c\xadf8\xc628\x20\xc6cc\xd06c\xc2a4\xd14c\xc774\xc158",
      //userWorkstations,?????? ??? 
      L"\x75\x73\x65\x72\x57\x6f\x72\x6b\x73\x74\x61\x74\x69\x6f\x6e\x73\x2c\xc6cc\xd06c\xc2a4\xd14c\xc774\xc158\x20\xb85c\xadf8\xc628",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"group-Display",
      L"attributeDisplayNames",
      //url,? ??? ?? (??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x20\x28\xae30\xd0c0\x29",
      //url,? ??? ??(??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?? 
      L"\x63\x6e\x2c\xc774\xb984",
      //dc,?? 
      L"\x64\x63\x2c\xc774\xb984",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //givenName,??(? ??) 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984\x28\xc131\x20\xc5c6\xc74c\x29",
      //givenName,?? 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\xc774\xb984",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,?? ISDN ?? (??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\xad6d\xc81c\x20\x49\x53\x44\x4e\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //internationalISDNNumber,?? ISDN ??(??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\xad6d\xc81c\x20\x49\x53\x44\x4e\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,?? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xadf8\xb8f9\x20\xb4f1\xb85d",
      //memberOf,?? ?? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xc18c\xc18d\x20\xadf8\xb8f9",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\xd329\xc2a4\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherFacsimileTelephoneNumber,?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\xd329\xc2a4\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,? ?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\xc9d1\x20\xc804\xd654\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherHomePhone,? ?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\xc9d1\x20\xc804\xd654\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP ?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\xc804\xd654\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherIpPhone,IP ?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\xc804\xd654\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,?? ?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\xc804\xc790\x20\xba54\xc77c\x20\xc8fc\xc18c\x20\x28\xae30\xd0c0\x29",
      //otherMailbox,?? ?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\xc804\xc790\x20\xba54\xc77c\x20\xc8fc\xc18c\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,??? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\xd734\xb300\xd3f0\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherMobile,??? ??(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\xd734\xb300\xd3f0\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,??? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\xd638\xcd9c\xae30\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherPager,??? ??(??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\xd638\xcd9c\xae30\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,?? ?? (??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\xc804\xd654\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //otherTelephone,?? ??(??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\xc804\xd654\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //personalTitle,?? 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xd638\xce6d",
      //personalTitle,?? 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xc9c1\xd568",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,??? ?? (??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\xd154\xb809\xc2a4\x20\xbc88\xd638\x20\x28\xae30\xd0c0\x29",
      //telexNumber,??? ??(??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\xd154\xb809\xc2a4\x20\xbc88\xd638\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,? ??? ?? (??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x20\x28\xae30\xd0c0\x29",
      //url,? ??? ??(??) 
      L"\x75\x72\x6c\x2c\xc6f9\x20\xd398\xc774\xc9c0\x20\xc8fc\xc18c\x28\xae30\xd0c0\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"organizationalUnit-Display",
      L"classDisplayName",
      //?? ?? 
      L"\xc870\xc9c1\x20\xb2e8\xc704",
      //?? ?? ?? 
      L"\xc870\xc9c1\x20\xad6c\xc131\x20\xb2e8\xc704",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"pKICertificateTemplate-Display",
      L"classDisplayName",
      //??? ?? 
      L"\xc778\xc99d\xc11c\x20\xc591\xc2dd",
      //??? ??? 
      L"\xc778\xc99d\xc11c\x20\xd15c\xd50c\xb9bf",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x412,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //c,Land (afkorting) 
      L"\x63\x2c\x4c\x61\x6e\x64\x20\x28\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67\x29",
      //c,Landafkorting 
      L"\x63\x2c\x4c\x61\x6e\x64\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //distinguishedName,Distinguished name (X500) 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x44\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x20\x6e\x61\x6d\x65\x20\x28\x58\x35\x30\x30\x29",
      //distinguishedName,X500 DN-naam 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x44\x4e\x2d\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //division,Divisie 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x73\x69\x65",
      //division,Afdeling 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x41\x66\x64\x65\x6c\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //employeeID,Werknemer-ID 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x57\x65\x72\x6b\x6e\x65\x6d\x65\x72\x2d\x49\x44",
      //employeeID,Medewerkers-id 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x4d\x65\x64\x65\x77\x65\x72\x6b\x65\x72\x73\x2d\x69\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //generationQualifier,Naamachtervoegsel 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x4e\x61\x61\x6d\x61\x63\x68\x74\x65\x72\x76\x6f\x65\x67\x73\x65\x6c",
      //generationQualifier,Generatieachtervoegsel 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x47\x65\x6e\x65\x72\x61\x74\x69\x65\x61\x63\x68\x74\x65\x72\x76\x6f\x65\x67\x73\x65\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //homePhone,Telefoonnummer (priv) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x70\x72\x69\x76\xe9\x29",
      //homePhone,Telefoon (thuis) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x20\x28\x74\x68\x75\x69\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //homePostalAddress,Adres (priv) 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x20\x28\x70\x72\x69\x76\xe9\x29",
      //homePostalAddress,Thuisadres 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x54\x68\x75\x69\x73\x61\x64\x72\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Internationaal ISDN-nummer (overig) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x61\x6c\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //internationalISDNNumber,Internationaal ISDN-nummer (overige) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x61\x6c\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //l,Woonplaats 
      L"\x6c\x2c\x57\x6f\x6f\x6e\x70\x6c\x61\x61\x74\x73",
      //l,Plaats 
      L"\x6c\x2c\x50\x6c\x61\x61\x74\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Groepslidmaatschap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x6f\x65\x70\x73\x6c\x69\x64\x6d\x61\x61\x74\x73\x63\x68\x61\x70",
      //memberOf,Lid van 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4c\x69\x64\x20\x76\x61\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //middleName,Tweede voornaam 
      L"\x6d\x69\x64\x64\x6c\x65\x4e\x61\x6d\x65\x2c\x54\x77\x65\x65\x64\x65\x20\x76\x6f\x6f\x72\x6e\x61\x61\x6d",
      //middleName,Middelste naam 
      L"\x6d\x69\x64\x64\x6c\x65\x4e\x61\x6d\x65\x2c\x4d\x69\x64\x64\x65\x6c\x73\x74\x65\x20\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //mobile,Nummer van mobiele telefoon 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x6d\x6f\x62\x69\x65\x6c\x65\x20\x74\x65\x6c\x65\x66\x6f\x6f\x6e",
      //mobile,Mobiel nummer 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x65\x6c\x20\x6e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //info,Opmerkingen 
      L"\x69\x6e\x66\x6f\x2c\x4f\x70\x6d\x65\x72\x6b\x69\x6e\x67\x65\x6e",
      //info,Notities 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x69\x74\x69\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,Faxnummer (overig) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherFacsimileTelephoneNumber,Faxnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Telefoonnummer priv (overig) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x70\x72\x69\x76\xe9\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherHomePhone,Telefoonnummer thuis (overige) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x74\x68\x75\x69\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP-telefoonnummer (overig) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x2d\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherIpPhone,IP-telefoonnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x2d\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,E-mailadres (overig) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x61\x64\x72\x65\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherMailbox,E-mailadres (overige) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x61\x64\x72\x65\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,Nummer van mobiele telefoon (overig) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x6d\x6f\x62\x69\x65\x6c\x65\x20\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherMobile,Mobiel nummer (overige) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x65\x6c\x20\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,Nummer van pieper (overig) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x70\x69\x65\x70\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherPager,Pagernummer (overige) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x50\x61\x67\x65\x72\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefoonnummer zakelijk (overig) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x7a\x61\x6b\x65\x6c\x69\x6a\x6b\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherTelephone,Telefoonnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //pager,Nummer van pager 
      L"\x70\x61\x67\x65\x72\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x70\x61\x67\x65\x72",
      //pager,Pagernummer 
      L"\x70\x61\x67\x65\x72\x2c\x50\x61\x67\x65\x72\x6e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //personalTitle,Functie 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65",
      //personalTitle,titel 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x74\x69\x74\x65\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,Aanmeldingsnaam (pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x41\x61\x6e\x6d\x65\x6c\x64\x69\x6e\x67\x73\x6e\x61\x61\x6d\x20\x28\x70\x72\xe9\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Aanmeldingsnaam (van voor Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x41\x61\x6e\x6d\x65\x6c\x64\x69\x6e\x67\x73\x6e\x61\x61\x6d\x20\x28\x76\x61\x6e\x20\x76\x6f\x6f\x72\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,Telexnummer (overig) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //telexNumber,Telexnummer (overige) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //title,Functie  
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65\x20",
      //title,Functie 
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //url,Adres van webpagina (overig) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //url,Adres van website (overige) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //displayName,Weergavenaam 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x57\x65\x65\x72\x67\x61\x76\x65\x6e\x61\x61\x6d",
      //displayName,Weergegeven naam 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x57\x65\x65\x72\x67\x65\x67\x65\x76\x65\x6e\x20\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"user-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adres van webpagina 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61",
      //wWWHomePage,Adres van website 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //c,Land (afkorting) 
      L"\x63\x2c\x4c\x61\x6e\x64\x20\x28\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67\x29",
      //c,Landafkorting 
      L"\x63\x2c\x4c\x61\x6e\x64\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //distinguishedName,Distinguished name (X500) 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x44\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x20\x6e\x61\x6d\x65\x20\x28\x58\x35\x30\x30\x29",
      //distinguishedName,X500 DN-naam 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x44\x4e\x2d\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //l,Woonplaats 
      L"\x6c\x2c\x57\x6f\x6f\x6e\x70\x6c\x61\x61\x74\x73",
      //l,Plaats 
      L"\x6c\x2c\x50\x6c\x61\x61\x74\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //info,Opmerkingen 
      L"\x69\x6e\x66\x6f\x2c\x4f\x70\x6d\x65\x72\x6b\x69\x6e\x67\x65\x6e",
      //info,Notities 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x69\x74\x69\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,Groepsnaam (pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x47\x72\x6f\x65\x70\x73\x6e\x61\x61\x6d\x20\x28\x70\x72\xe9\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Groepsnaam (pre-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x47\x72\x6f\x65\x70\x73\x6e\x61\x61\x6d\x20\x28\x70\x72\x65\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //url,Adres van webpagina (overig) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //url,Adres van website (overige) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"group-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adres van webpagina 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61",
      //wWWHomePage,Adres van website 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Naam 
      L"\x63\x6e\x2c\x4e\x61\x61\x6d",
      //dc,Naam 
      L"\x64\x63\x2c\x4e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //c,Land (afkorting) 
      L"\x63\x2c\x4c\x61\x6e\x64\x20\x28\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67\x29",
      //c,Landafkorting 
      L"\x63\x2c\x4c\x61\x6e\x64\x61\x66\x6b\x6f\x72\x74\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //displayName,Weergavenaam 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x57\x65\x65\x72\x67\x61\x76\x65\x6e\x61\x61\x6d",
      //displayName,Weergegeven naam 
      L"\x64\x69\x73\x70\x6c\x61\x79\x4e\x61\x6d\x65\x2c\x57\x65\x65\x72\x67\x65\x67\x65\x76\x65\x6e\x20\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //distinguishedName,Distinguished name (X500) 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x44\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x20\x6e\x61\x6d\x65\x20\x28\x58\x35\x30\x30\x29",
      //distinguishedName,X500 DN-naam 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x44\x4e\x2d\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //division,Divisie 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x73\x69\x65",
      //division,Afdeling 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x41\x66\x64\x65\x6c\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //employeeID,Werknemer-ID 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x57\x65\x72\x6b\x6e\x65\x6d\x65\x72\x2d\x49\x44",
      //employeeID,Medewerkers-id 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x4d\x65\x64\x65\x77\x65\x72\x6b\x65\x72\x73\x2d\x69\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //generationQualifier,Naamachtervoegsel 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x4e\x61\x61\x6d\x61\x63\x68\x74\x65\x72\x76\x6f\x65\x67\x73\x65\x6c",
      //generationQualifier,Generatieachtervoegsel 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x47\x65\x6e\x65\x72\x61\x74\x69\x65\x61\x63\x68\x74\x65\x72\x76\x6f\x65\x67\x73\x65\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //homePhone,Telefoonnummer (priv) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x70\x72\x69\x76\xe9\x29",
      //homePhone,Telefoon (thuis) 
      L"\x68\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x20\x28\x74\x68\x75\x69\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //homePostalAddress,Adres (priv) 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x41\x64\x72\x65\x73\x20\x28\x70\x72\x69\x76\xe9\x29",
      //homePostalAddress,Thuisadres 
      L"\x68\x6f\x6d\x65\x50\x6f\x73\x74\x61\x6c\x41\x64\x64\x72\x65\x73\x73\x2c\x54\x68\x75\x69\x73\x61\x64\x72\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //info,Opmerkingen 
      L"\x69\x6e\x66\x6f\x2c\x4f\x70\x6d\x65\x72\x6b\x69\x6e\x67\x65\x6e",
      //info,Notities 
      L"\x69\x6e\x66\x6f\x2c\x4e\x6f\x74\x69\x74\x69\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,Internationaal ISDN-nummer (overig) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x61\x6c\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //internationalISDNNumber,Internationaal ISDN-nummer (overige) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x61\x6c\x20\x49\x53\x44\x4e\x2d\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //l,Woonplaats 
      L"\x6c\x2c\x57\x6f\x6f\x6e\x70\x6c\x61\x61\x74\x73",
      //l,Plaats 
      L"\x6c\x2c\x50\x6c\x61\x61\x74\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Groepslidmaatschap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x6f\x65\x70\x73\x6c\x69\x64\x6d\x61\x61\x74\x73\x63\x68\x61\x70",
      //memberOf,Lid van 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4c\x69\x64\x20\x76\x61\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //middleName,Tweede voornaam 
      L"\x6d\x69\x64\x64\x6c\x65\x4e\x61\x6d\x65\x2c\x54\x77\x65\x65\x64\x65\x20\x76\x6f\x6f\x72\x6e\x61\x61\x6d",
      //middleName,Middelste naam 
      L"\x6d\x69\x64\x64\x6c\x65\x4e\x61\x6d\x65\x2c\x4d\x69\x64\x64\x65\x6c\x73\x74\x65\x20\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //mobile,Nummer van mobiele telefoon 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x6d\x6f\x62\x69\x65\x6c\x65\x20\x74\x65\x6c\x65\x66\x6f\x6f\x6e",
      //mobile,Mobiel nummer 
      L"\x6d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x65\x6c\x20\x6e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,Faxnummer (overig) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherFacsimileTelephoneNumber,Faxnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x46\x61\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Telefoonnummer priv (overig) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x70\x72\x69\x76\xe9\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherHomePhone,Telefoonnummer thuis (overige) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x74\x68\x75\x69\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP-telefoonnummer (overig) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x2d\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherIpPhone,IP-telefoonnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x2d\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,E-mailadres (overig) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x61\x64\x72\x65\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherMailbox,E-mailadres (overige) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x2d\x6d\x61\x69\x6c\x61\x64\x72\x65\x73\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,Nummer van mobiele telefoon (overig) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x6d\x6f\x62\x69\x65\x6c\x65\x20\x74\x65\x6c\x65\x66\x6f\x6f\x6e\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherMobile,Mobiel nummer (overige) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x4d\x6f\x62\x69\x65\x6c\x20\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,Nummer van pieper (overig) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x70\x69\x65\x70\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherPager,Pagernummer (overige) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x50\x61\x67\x65\x72\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefoonnummer zakelijk (overig) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x7a\x61\x6b\x65\x6c\x69\x6a\x6b\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //otherTelephone,Telefoonnummer (overige) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //pager,Nummer van pager 
      L"\x70\x61\x67\x65\x72\x2c\x4e\x75\x6d\x6d\x65\x72\x20\x76\x61\x6e\x20\x70\x61\x67\x65\x72",
      //pager,Pagernummer 
      L"\x70\x61\x67\x65\x72\x2c\x50\x61\x67\x65\x72\x6e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //personalTitle,Functie 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65",
      //personalTitle,titel 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x74\x69\x74\x65\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,Telexnummer (overig) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //telexNumber,Telexnummer (overige) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x78\x6e\x75\x6d\x6d\x65\x72\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //title,Functie  
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65\x20",
      //title,Functie 
      L"\x74\x69\x74\x6c\x65\x2c\x46\x75\x6e\x63\x74\x69\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,Adres van webpagina (overig) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61\x20\x28\x6f\x76\x65\x72\x69\x67\x29",
      //url,Adres van website (overige) 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65\x20\x28\x6f\x76\x65\x72\x69\x67\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"contact-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Adres van webpagina 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61",
      //wWWHomePage,Adres van website 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"computer-Display",
      L"attributeDisplayNames",
      //operatingSystemVersion,Versie van besturingssysteem 
      L"\x6f\x70\x65\x72\x61\x74\x69\x6e\x67\x53\x79\x73\x74\x65\x6d\x56\x65\x72\x73\x69\x6f\x6e\x2c\x56\x65\x72\x73\x69\x65\x20\x76\x61\x6e\x20\x62\x65\x73\x74\x75\x72\x69\x6e\x67\x73\x73\x79\x73\x74\x65\x65\x6d",
      //operatingSystemVersion,Operating System Version 
      L"\x6f\x70\x65\x72\x61\x74\x69\x6e\x67\x53\x79\x73\x74\x65\x6d\x56\x65\x72\x73\x69\x6f\x6e\x2c\x4f\x70\x65\x72\x61\x74\x69\x6e\x67\x20\x53\x79\x73\x74\x65\x6d\x20\x56\x65\x72\x73\x69\x6f\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Computernaam (pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x43\x6f\x6d\x70\x75\x74\x65\x72\x6e\x61\x61\x6d\x20\x28\x70\x72\xe9\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Computernaam (pre-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x43\x6f\x6d\x70\x75\x74\x65\x72\x6e\x61\x61\x6d\x20\x28\x70\x72\x65\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //cn,Naam van directory-service 
      L"\x63\x6e\x2c\x4e\x61\x61\x6d\x20\x76\x61\x6e\x20\x64\x69\x72\x65\x63\x74\x6f\x72\x79\x2d\x73\x65\x72\x76\x69\x63\x65",
      //cn,Naam van adreslijstservice 
      L"\x63\x6e\x2c\x4e\x61\x61\x6d\x20\x76\x61\x6e\x20\x61\x64\x72\x65\x73\x6c\x69\x6a\x73\x74\x73\x65\x72\x76\x69\x63\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //assetNumber,Inventarisnummer 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x76\x65\x6e\x74\x61\x72\x69\x73\x6e\x75\x6d\x6d\x65\x72",
      //assetNumber,Eigenschapsnummer 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x45\x69\x67\x65\x6e\x73\x63\x68\x61\x70\x73\x6e\x75\x6d\x6d\x65\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //driverName,Model 
      L"\x64\x72\x69\x76\x65\x72\x4e\x61\x6d\x65\x2c\x4d\x6f\x64\x65\x6c",
      //driverName,model 
      L"\x64\x72\x69\x76\x65\x72\x4e\x61\x6d\x65\x2c\x6d\x6f\x64\x65\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printBinNames,Invoerladen 
      L"\x70\x72\x69\x6e\x74\x42\x69\x6e\x4e\x61\x6d\x65\x73\x2c\x49\x6e\x76\x6f\x65\x72\x6c\x61\x64\x65\x6e",
      //printBinNames,Invoerlade 
      L"\x70\x72\x69\x6e\x74\x42\x69\x6e\x4e\x61\x6d\x65\x73\x2c\x49\x6e\x76\x6f\x65\x72\x6c\x61\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printCollate,Ondersteuning voor sorteren 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x69\x6e\x67\x20\x76\x6f\x6f\x72\x20\x73\x6f\x72\x74\x65\x72\x65\x6e",
      //printCollate,Ondersteunt sorteren 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x74\x20\x73\x6f\x72\x74\x65\x72\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printColor,Ondersteuning voor kleurafdrukken 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x69\x6e\x67\x20\x76\x6f\x6f\x72\x20\x6b\x6c\x65\x75\x72\x61\x66\x64\x72\x75\x6b\x6b\x65\x6e",
      //printColor,Ondersteunt afdrukken in kleur 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x74\x20\x61\x66\x64\x72\x75\x6b\x6b\x65\x6e\x20\x69\x6e\x20\x6b\x6c\x65\x75\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printDuplexSupported,Ondersteuning voor dubbelzijdig afdrukken 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x69\x6e\x67\x20\x76\x6f\x6f\x72\x20\x64\x75\x62\x62\x65\x6c\x7a\x69\x6a\x64\x69\x67\x20\x61\x66\x64\x72\x75\x6b\x6b\x65\x6e",
      //printDuplexSupported,Ondersteunt dubbelzijdig afdrukken 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x74\x20\x64\x75\x62\x62\x65\x6c\x7a\x69\x6a\x64\x69\x67\x20\x61\x66\x64\x72\x75\x6b\x6b\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMaxResolutionSupported,Maximumresolutie 
      L"\x70\x72\x69\x6e\x74\x4d\x61\x78\x52\x65\x73\x6f\x6c\x75\x74\x69\x6f\x6e\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4d\x61\x78\x69\x6d\x75\x6d\x72\x65\x73\x6f\x6c\x75\x74\x69\x65",
      //printMaxResolutionSupported,Maximale resolutie 
      L"\x70\x72\x69\x6e\x74\x4d\x61\x78\x52\x65\x73\x6f\x6c\x75\x74\x69\x6f\x6e\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4d\x61\x78\x69\x6d\x61\x6c\x65\x20\x72\x65\x73\x6f\x6c\x75\x74\x69\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMediaSupported,Ondersteunde papiertypen 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x64\x65\x20\x70\x61\x70\x69\x65\x72\x74\x79\x70\x65\x6e",
      //printMediaSupported,Ondersteunde papiersoorten 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x64\x65\x20\x70\x61\x70\x69\x65\x72\x73\x6f\x6f\x72\x74\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printOwner,Naam van eigenaar 
      L"\x70\x72\x69\x6e\x74\x4f\x77\x6e\x65\x72\x2c\x4e\x61\x61\x6d\x20\x76\x61\x6e\x20\x65\x69\x67\x65\x6e\x61\x61\x72",
      //printOwner,Naam eigenaar 
      L"\x70\x72\x69\x6e\x74\x4f\x77\x6e\x65\x72\x2c\x4e\x61\x61\x6d\x20\x65\x69\x67\x65\x6e\x61\x61\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printRateUnit,Eenheid van snelheid 
      L"\x70\x72\x69\x6e\x74\x52\x61\x74\x65\x55\x6e\x69\x74\x2c\x45\x65\x6e\x68\x65\x69\x64\x20\x76\x61\x6e\x20\x73\x6e\x65\x6c\x68\x65\x69\x64",
      //printRateUnit,Snelheidseenheden 
      L"\x70\x72\x69\x6e\x74\x52\x61\x74\x65\x55\x6e\x69\x74\x2c\x53\x6e\x65\x6c\x68\x65\x69\x64\x73\x65\x65\x6e\x68\x65\x64\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printShareName,Sharenaam 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x53\x68\x61\x72\x65\x6e\x61\x61\x6d",
      //printShareName,Share-naam 
      L"\x70\x72\x69\x6e\x74\x53\x68\x61\x72\x65\x4e\x61\x6d\x65\x2c\x53\x68\x61\x72\x65\x2d\x6e\x61\x61\x6d",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printStaplingSupported,Ondersteuning voor nieten 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x69\x6e\x67\x20\x76\x6f\x6f\x72\x20\x6e\x69\x65\x74\x65\x6e",
      //printStaplingSupported,Ondersteunt nieten 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x4f\x6e\x64\x65\x72\x73\x74\x65\x75\x6e\x74\x20\x6e\x69\x65\x74\x65\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //url,Adres van webpagina 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x70\x61\x67\x69\x6e\x61",
      //url,Adres van website 
      L"\x75\x72\x6c\x2c\x41\x64\x72\x65\x73\x20\x76\x61\x6e\x20\x77\x65\x62\x73\x69\x74\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"site-Display",
      L"classDisplayName",
      //Site 
      L"\x53\x69\x74\x65",
      //Website 
      L"\x57\x65\x62\x73\x69\x74\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"siteLink-Display",
      L"classDisplayName",
      //Site-koppeling 
      L"\x53\x69\x74\x65\x2d\x6b\x6f\x70\x70\x65\x6c\x69\x6e\x67",
      //Koppeling naar site 
      L"\x4b\x6f\x70\x70\x65\x6c\x69\x6e\x67\x20\x6e\x61\x61\x72\x20\x73\x69\x74\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"siteLinkBridge-Display",
      L"classDisplayName",
      //Site-koppelingsbrug 
      L"\x53\x69\x74\x65\x2d\x6b\x6f\x70\x70\x65\x6c\x69\x6e\x67\x73\x62\x72\x75\x67",
      //Sitekoppelingsbrug 
      L"\x53\x69\x74\x65\x6b\x6f\x70\x70\x65\x6c\x69\x6e\x67\x73\x62\x72\x75\x67",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"interSiteTransport-Display",
      L"classDisplayName",
      //Intersite-transport 
      L"\x49\x6e\x74\x65\x72\x73\x69\x74\x65\x2d\x74\x72\x61\x6e\x73\x70\x6f\x72\x74",
      //Intersitetransport 
      L"\x49\x6e\x74\x65\x72\x73\x69\x74\x65\x74\x72\x61\x6e\x73\x70\x6f\x72\x74",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"organizationalUnit-Display",
      L"classDisplayName",
      //Organisatie-eenheid 
      L"\x4f\x72\x67\x61\x6e\x69\x73\x61\x74\x69\x65\x2d\x65\x65\x6e\x68\x65\x69\x64",
      //Afdeling 
      L"\x41\x66\x64\x65\x6c\x69\x6e\x67",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"mSMQMigratedUser-Display",
      L"classDisplayName",
      //Gebruiker met MSMQ-upgrade 
      L"\x47\x65\x62\x72\x75\x69\x6b\x65\x72\x20\x6d\x65\x74\x20\x4d\x53\x4d\x51\x2d\x75\x70\x67\x72\x61\x64\x65",
      //Bijgewerkte MSMQ-gebruiker 
      L"\x42\x69\x6a\x67\x65\x77\x65\x72\x6b\x74\x65\x20\x4d\x53\x4d\x51\x2d\x67\x65\x62\x72\x75\x69\x6b\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"mSMQSiteLink-Display",
      L"classDisplayName",
      //MSMQ-routeringskoppeling 
      L"\x4d\x53\x4d\x51\x2d\x72\x6f\x75\x74\x65\x72\x69\x6e\x67\x73\x6b\x6f\x70\x70\x65\x6c\x69\x6e\x67",
      //Koppeling van MSMQ-routering 
      L"\x4b\x6f\x70\x70\x65\x6c\x69\x6e\x67\x20\x76\x61\x6e\x20\x4d\x53\x4d\x51\x2d\x72\x6f\x75\x74\x65\x72\x69\x6e\x67",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"sitesContainer-Display",
      L"classDisplayName",
      //Container voor sites 
      L"\x43\x6f\x6e\x74\x61\x69\x6e\x65\x72\x20\x76\x6f\x6f\x72\x20\x73\x69\x74\x65\x73",
      //Sitecontainer 
      L"\x53\x69\x74\x65\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //Container voor intersite-transporten 
      L"\x43\x6f\x6e\x74\x61\x69\x6e\x65\x72\x20\x76\x6f\x6f\x72\x20\x69\x6e\x74\x65\x72\x73\x69\x74\x65\x2d\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x65\x6e",
      //Intersite-transportcontainer 
      L"\x49\x6e\x74\x65\x72\x73\x69\x74\x65\x2d\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"subnetContainer-Display",
      L"classDisplayName",
      //Container voor subnetten 
      L"\x43\x6f\x6e\x74\x61\x69\x6e\x65\x72\x20\x76\x6f\x6f\x72\x20\x73\x75\x62\x6e\x65\x74\x74\x65\x6e",
      //Subnetcontainer 
      L"\x53\x75\x62\x6e\x65\x74\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"serversContainer-Display",
      L"classDisplayName",
      //Container voor servers 
      L"\x43\x6f\x6e\x74\x61\x69\x6e\x65\x72\x20\x76\x6f\x6f\x72\x20\x73\x65\x72\x76\x65\x72\x73",
      //Servercontainer 
      L"\x53\x65\x72\x76\x65\x72\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"queryPolicy-Display",
      L"classDisplayName",
      //Querybeleid 
      L"\x51\x75\x65\x72\x79\x62\x65\x6c\x65\x69\x64",
      //Query-beleid 
      L"\x51\x75\x65\x72\x79\x2d\x62\x65\x6c\x65\x69\x64",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x413,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppemedlemskap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x70",
      //memberOf,Medlem av 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x61\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefon, arbeid (andre) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x2c\x20\x61\x72\x62\x65\x69\x64\x20\x28\x61\x6e\x64\x72\x65\x29",
      //otherTelephone,Telefonnummer (andre) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x61\x6e\x64\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Navn 
      L"\x63\x6e\x2c\x4e\x61\x76\x6e",
      //dc,Navn 
      L"\x64\x63\x2c\x4e\x61\x76\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppemedlemskap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x65\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x70",
      //memberOf,Medlem av 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x61\x76",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,Telefon, arbeid (andre) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x2c\x20\x61\x72\x62\x65\x69\x64\x20\x28\x61\x6e\x64\x72\x65\x29",
      //otherTelephone,Telefonnummer (andre) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x6e\x75\x6d\x6d\x65\x72\x20\x28\x61\x6e\x64\x72\x65\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x414,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Czlonkostwo grupy 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x7a\x142\x6f\x6e\x6b\x6f\x73\x74\x77\x6f\x20\x67\x72\x75\x70\x79",
      //memberOf,Czlonek grupy 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x7a\x142\x6f\x6e\x65\x6b\x20\x67\x72\x75\x70\x79",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nazwa 
      L"\x63\x6e\x2c\x4e\x61\x7a\x77\x61",
      //dc,Nazwa 
      L"\x64\x63\x2c\x4e\x61\x7a\x77\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Czlonkostwo grupy 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x7a\x142\x6f\x6e\x6b\x6f\x73\x74\x77\x6f\x20\x67\x72\x75\x70\x79",
      //memberOf,Czlonek grupy 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x43\x7a\x142\x6f\x6e\x65\x6b\x20\x67\x72\x75\x70\x79",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"mSMQSiteLink-Display",
      L"classDisplayName",
      //Lacze listy wysylkowej uslugi MSMQ 
      L"\x141\x105\x63\x7a\x65\x20\x6c\x69\x73\x74\x79\x20\x77\x79\x73\x79\x142\x6b\x6f\x77\x65\x6a\x20\x75\x73\x142\x75\x67\x69\x20\x4d\x53\x4d\x51",
      //Lacze routingu uslugi MSMQ 
      L"\x141\x105\x63\x7a\x65\x20\x72\x6f\x75\x74\x69\x6e\x67\x75\x20\x75\x73\x142\x75\x67\x69\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"sitesContainer-Display",
      L"classDisplayName",
      //Kontener witryn 
      L"\x4b\x6f\x6e\x74\x65\x6e\x65\x72\x20\x77\x69\x74\x72\x79\x6e",
      //Kontener lokacji 
      L"\x4b\x6f\x6e\x74\x65\x6e\x65\x72\x20\x6c\x6f\x6b\x61\x63\x6a\x69",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"interSiteTransportContainer-Display",
      L"classDisplayName",
      //Kontener transportu miedzy witrynami 
      L"\x4b\x6f\x6e\x74\x65\x6e\x65\x72\x20\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x75\x20\x6d\x69\x119\x64\x7a\x79\x20\x77\x69\x74\x72\x79\x6e\x61\x6d\x69",
      //Kontener transportu miedzylokacyjnego 
      L"\x4b\x6f\x6e\x74\x65\x6e\x65\x72\x20\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x75\x20\x6d\x69\x119\x64\x7a\x79\x6c\x6f\x6b\x61\x63\x79\x6a\x6e\x65\x67\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x415,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //c,Abreviatura do pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\x74\x75\x72\x61\x20\x64\x6f\x20\x70\x61\xed\x73",
      //c,Abreviao de pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\xe7\xe3\x6f\x20\x64\x65\x20\x70\x61\xed\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //employeeID,Identificao do empregado 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x64\x65\x6e\x74\x69\x66\x69\x63\x61\xe7\xe3\x6f\x20\x64\x6f\x20\x65\x6d\x70\x72\x65\x67\x61\x64\x6f",
      //employeeID,Cdigo do Funcionrio 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x43\xf3\x64\x69\x67\x6f\x20\x64\x6f\x20\x46\x75\x6e\x63\x69\x6f\x6e\xe1\x72\x69\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //generationQualifier,Sufixo geracional 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x53\x75\x66\x69\x78\x6f\x20\x67\x65\x72\x61\x63\x69\x6f\x6e\x61\x6c",
      //generationQualifier,Sufixo generativo 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x53\x75\x66\x69\x78\x6f\x20\x67\x65\x6e\x65\x72\x61\x74\x69\x76\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //givenName,Prenome 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x50\x72\x65\x6e\x6f\x6d\x65",
      //givenName,Nome 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //mail,Endereo de correio eletrnico 
      L"\x6d\x61\x69\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x63\x6f\x72\x72\x65\x69\x6f\x20\x65\x6c\x65\x74\x72\xf4\x6e\x69\x63\x6f",
      //mail,End. de email 
      L"\x6d\x61\x69\x6c\x2c\x45\x6e\x64\x2e\x20\x64\x65\x20\x65\x6d\x61\x69\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Participao no grupo 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x61\x72\x74\x69\x63\x69\x70\x61\xe7\xe3\x6f\x20\x6e\x6f\x20\x67\x72\x75\x70\x6f",
      //memberOf,Participante de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x61\x72\x74\x69\x63\x69\x70\x61\x6e\x74\x65\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Nmero de telefone residencial (outros) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x72\x65\x73\x69\x64\x65\x6e\x63\x69\x61\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherHomePhone,Nmero de telefone de casa (outros) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x64\x65\x20\x63\x61\x73\x61\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,Telefone IP (outros) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x65\x20\x49\x50\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherIpPhone,Nmero do telefone IP (outros) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x49\x50\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,Endereo de correio eletrnico (outros) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x63\x6f\x72\x72\x65\x69\x6f\x20\x65\x6c\x65\x74\x72\xf4\x6e\x69\x63\x6f\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherMailbox,Endereo de email (outros) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x65\x6d\x61\x69\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,Nmero de telefone (outros) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherTelephone,N de telefone (outros) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x4e\xba\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Endereo comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      //physicalDeliveryOfficeName,End. comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x2e\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //st,UF 
      L"\x73\x74\x2c\x55\x46",
      //st,Estado/provncia 
      L"\x73\x74\x2c\x45\x73\x74\x61\x64\x6f\x2f\x70\x72\x6f\x76\xed\x6e\x63\x69\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //telephoneNumber,Nmero do telefone 
      L"\x74\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65",
      //telephoneNumber,Telefone 
      L"\x74\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //url,Endereo de pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //url,Endereo da pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x61\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"user-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Endereo de pgina da Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62",
      //wWWHomePage,Endereo na Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x6e\x61\x20\x57\x65\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"group-Display",
      L"attributeDisplayNames",
      //c,Abreviatura do pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\x74\x75\x72\x61\x20\x64\x6f\x20\x70\x61\xed\x73",
      //c,Abreviao de pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\xe7\xe3\x6f\x20\x64\x65\x20\x70\x61\xed\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"group-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Endereo comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      //physicalDeliveryOfficeName,End. comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x2e\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"group-Display",
      L"attributeDisplayNames",
      //url,Endereo de pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //url,Endereo da pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x61\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"group-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Endereo de pgina da Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62",
      //wWWHomePage,Endereo na Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x6e\x61\x20\x57\x65\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nome 
      L"\x63\x6e\x2c\x4e\x6f\x6d\x65",
      //dc,Nome 
      L"\x64\x63\x2c\x4e\x6f\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //c,Abreviatura do pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\x74\x75\x72\x61\x20\x64\x6f\x20\x70\x61\xed\x73",
      //c,Abreviao de pas 
      L"\x63\x2c\x41\x62\x72\x65\x76\x69\x61\xe7\xe3\x6f\x20\x64\x65\x20\x70\x61\xed\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //employeeID,Identificao do empregado 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x49\x64\x65\x6e\x74\x69\x66\x69\x63\x61\xe7\xe3\x6f\x20\x64\x6f\x20\x65\x6d\x70\x72\x65\x67\x61\x64\x6f",
      //employeeID,Cdigo do Funcionrio 
      L"\x65\x6d\x70\x6c\x6f\x79\x65\x65\x49\x44\x2c\x43\xf3\x64\x69\x67\x6f\x20\x64\x6f\x20\x46\x75\x6e\x63\x69\x6f\x6e\xe1\x72\x69\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //generationQualifier,Sufixo geracional 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x53\x75\x66\x69\x78\x6f\x20\x67\x65\x72\x61\x63\x69\x6f\x6e\x61\x6c",
      //generationQualifier,Sufixo generativo 
      L"\x67\x65\x6e\x65\x72\x61\x74\x69\x6f\x6e\x51\x75\x61\x6c\x69\x66\x69\x65\x72\x2c\x53\x75\x66\x69\x78\x6f\x20\x67\x65\x6e\x65\x72\x61\x74\x69\x76\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //givenName,Prenome 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x50\x72\x65\x6e\x6f\x6d\x65",
      //givenName,Nome 
      L"\x67\x69\x76\x65\x6e\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //mail,Endereo de correio eletrnico 
      L"\x6d\x61\x69\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x63\x6f\x72\x72\x65\x69\x6f\x20\x65\x6c\x65\x74\x72\xf4\x6e\x69\x63\x6f",
      //mail,End. de email 
      L"\x6d\x61\x69\x6c\x2c\x45\x6e\x64\x2e\x20\x64\x65\x20\x65\x6d\x61\x69\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Participao no grupo 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x61\x72\x74\x69\x63\x69\x70\x61\xe7\xe3\x6f\x20\x6e\x6f\x20\x67\x72\x75\x70\x6f",
      //memberOf,Participante de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x61\x72\x74\x69\x63\x69\x70\x61\x6e\x74\x65\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Nmero de telefone residencial (outros) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x72\x65\x73\x69\x64\x65\x6e\x63\x69\x61\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherHomePhone,Nmero de telefone de casa (outros) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x64\x65\x20\x63\x61\x73\x61\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,Telefone IP (outros) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x65\x20\x49\x50\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherIpPhone,Nmero do telefone IP (outros) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x49\x50\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,Endereo de correio eletrnico (outros) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x63\x6f\x72\x72\x65\x69\x6f\x20\x65\x6c\x65\x74\x72\xf4\x6e\x69\x63\x6f\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherMailbox,Endereo de email (outros) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x65\x6d\x61\x69\x6c\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,Nmero de telefone (outros) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //otherTelephone,N de telefone (outros) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x4e\xba\x20\x64\x65\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //physicalDeliveryOfficeName,Endereo comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      //physicalDeliveryOfficeName,End. comercial 
      L"\x70\x68\x79\x73\x69\x63\x61\x6c\x44\x65\x6c\x69\x76\x65\x72\x79\x4f\x66\x66\x69\x63\x65\x4e\x61\x6d\x65\x2c\x45\x6e\x64\x2e\x20\x63\x6f\x6d\x65\x72\x63\x69\x61\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //st,UF 
      L"\x73\x74\x2c\x55\x46",
      //st,Estado/provncia 
      L"\x73\x74\x2c\x45\x73\x74\x61\x64\x6f\x2f\x70\x72\x6f\x76\xed\x6e\x63\x69\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //telephoneNumber,Nmero do telefone 
      L"\x74\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x74\x65\x6c\x65\x66\x6f\x6e\x65",
      //telephoneNumber,Telefone 
      L"\x74\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x54\x65\x6c\x65\x66\x6f\x6e\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,Endereo de pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      //url,Endereo da pgina da Web (outros) 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x61\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62\x20\x28\x6f\x75\x74\x72\x6f\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"contact-Display",
      L"attributeDisplayNames",
      //wWWHomePage,Endereo de pgina da Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62",
      //wWWHomePage,Endereo na Web 
      L"\x77\x57\x57\x48\x6f\x6d\x65\x50\x61\x67\x65\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x6e\x61\x20\x57\x65\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"computer-Display",
      L"attributeDisplayNames",
      //operatingSystemVersion,Verso do sistema operacional 
      L"\x6f\x70\x65\x72\x61\x74\x69\x6e\x67\x53\x79\x73\x74\x65\x6d\x56\x65\x72\x73\x69\x6f\x6e\x2c\x56\x65\x72\x73\xe3\x6f\x20\x64\x6f\x20\x73\x69\x73\x74\x65\x6d\x61\x20\x6f\x70\x65\x72\x61\x63\x69\x6f\x6e\x61\x6c",
      //operatingSystemVersion,Verso do sist. operacional 
      L"\x6f\x70\x65\x72\x61\x74\x69\x6e\x67\x53\x79\x73\x74\x65\x6d\x56\x65\x72\x73\x69\x6f\x6e\x2c\x56\x65\x72\x73\xe3\x6f\x20\x64\x6f\x20\x73\x69\x73\x74\x2e\x20\x6f\x70\x65\x72\x61\x63\x69\x6f\x6e\x61\x6c",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Nome do computador (anterior ao Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x65\x20\x64\x6f\x20\x63\x6f\x6d\x70\x75\x74\x61\x64\x6f\x72\x20\x28\x61\x6e\x74\x65\x72\x69\x6f\x72\x20\x61\x6f\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nome comput. (pr-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x65\x20\x63\x6f\x6d\x70\x75\x74\x2e\x20\x28\x70\x72\xe9\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //assetNumber,Nmero do ativo 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x61\x74\x69\x76\x6f",
      //assetNumber,Nmero do recurso 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x6f\x20\x72\x65\x63\x75\x72\x73\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printCollate,Fornece suporte a intercalao 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x46\x6f\x72\x6e\x65\x63\x65\x20\x73\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x69\x6e\x74\x65\x72\x63\x61\x6c\x61\xe7\xe3\x6f",
      //printCollate,Suporte a emulao 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6c\x61\x74\x65\x2c\x53\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x65\x6d\x75\x6c\x61\xe7\xe3\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printColor,Fornece suporte a impresso colorida 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x46\x6f\x72\x6e\x65\x63\x65\x20\x73\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x69\x6d\x70\x72\x65\x73\x73\xe3\x6f\x20\x63\x6f\x6c\x6f\x72\x69\x64\x61",
      //printColor,Suporte a impresso a cores 
      L"\x70\x72\x69\x6e\x74\x43\x6f\x6c\x6f\x72\x2c\x53\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x69\x6d\x70\x72\x65\x73\x73\xe3\x6f\x20\x61\x20\x63\x6f\x72\x65\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printDuplexSupported,Fornece suporte a impresso dos dois lados 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x46\x6f\x72\x6e\x65\x63\x65\x20\x73\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x69\x6d\x70\x72\x65\x73\x73\xe3\x6f\x20\x64\x6f\x73\x20\x64\x6f\x69\x73\x20\x6c\x61\x64\x6f\x73",
      //printDuplexSupported,Suporte a impresso frente e verso 
      L"\x70\x72\x69\x6e\x74\x44\x75\x70\x6c\x65\x78\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x53\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x69\x6d\x70\x72\x65\x73\x73\xe3\x6f\x20\x66\x72\x65\x6e\x74\x65\x20\x65\x20\x76\x65\x72\x73\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printLanguage,Linguagem de impresso 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x4c\x69\x6e\x67\x75\x61\x67\x65\x6d\x20\x64\x65\x20\x69\x6d\x70\x72\x65\x73\x73\xe3\x6f",
      //printLanguage,Idioma da impressora 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x49\x64\x69\x6f\x6d\x61\x20\x64\x61\x20\x69\x6d\x70\x72\x65\x73\x73\x6f\x72\x61",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printMediaSupported,Tipos de papel para os quais h suporte 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x54\x69\x70\x6f\x73\x20\x64\x65\x20\x70\x61\x70\x65\x6c\x20\x70\x61\x72\x61\x20\x6f\x73\x20\x71\x75\x61\x69\x73\x20\x68\xe1\x20\x73\x75\x70\x6f\x72\x74\x65",
      //printMediaSupported,Tipos de papel permitidos 
      L"\x70\x72\x69\x6e\x74\x4d\x65\x64\x69\x61\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x54\x69\x70\x6f\x73\x20\x64\x65\x20\x70\x61\x70\x65\x6c\x20\x70\x65\x72\x6d\x69\x74\x69\x64\x6f\x73",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printStaplingSupported,Fornece suporte a grampeamento 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x46\x6f\x72\x6e\x65\x63\x65\x20\x73\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x67\x72\x61\x6d\x70\x65\x61\x6d\x65\x6e\x74\x6f",
      //printStaplingSupported,Suporte a grampeamento 
      L"\x70\x72\x69\x6e\x74\x53\x74\x61\x70\x6c\x69\x6e\x67\x53\x75\x70\x70\x6f\x72\x74\x65\x64\x2c\x53\x75\x70\x6f\x72\x74\x65\x20\x61\x20\x67\x72\x61\x6d\x70\x65\x61\x6d\x65\x6e\x74\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //url,Endereo de pgina da Web 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x64\x65\x20\x70\xe1\x67\x69\x6e\x61\x20\x64\x61\x20\x57\x65\x62",
      //url,Endereo na Web 
      L"\x75\x72\x6c\x2c\x45\x6e\x64\x65\x72\x65\xe7\x6f\x20\x6e\x61\x20\x57\x65\x62",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTDSDSA-Display",
      L"classDisplayName",
      //Configuraes do controlador de domnio 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x6f\x20\x63\x6f\x6e\x74\x72\x6f\x6c\x61\x64\x6f\x72\x20\x64\x65\x20\x64\x6f\x6d\xed\x6e\x69\x6f",
      //Configuraes do controlador do domnio 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x6f\x20\x63\x6f\x6e\x74\x72\x6f\x6c\x61\x64\x6f\x72\x20\x64\x6f\x20\x64\x6f\x6d\xed\x6e\x69\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTFRSSettings-Display",
      L"classDisplayName",
      //Configuraes do servio de duplicao de arquivos 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x64\x75\x70\x6c\x69\x63\x61\xe7\xe3\x6f\x20\x64\x65\x20\x61\x72\x71\x75\x69\x76\x6f\x73",
      //Configuraes FRS 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTFRSReplicaSet-Display",
      L"classDisplayName",
      //Conjunto de rplicas do servio de duplicao de arquivos 
      L"\x43\x6f\x6e\x6a\x75\x6e\x74\x6f\x20\x64\x65\x20\x72\xe9\x70\x6c\x69\x63\x61\x73\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x64\x75\x70\x6c\x69\x63\x61\xe7\xe3\x6f\x20\x64\x65\x20\x61\x72\x71\x75\x69\x76\x6f\x73",
      //Conjunto de rplicas FRS 
      L"\x43\x6f\x6e\x6a\x75\x6e\x74\x6f\x20\x64\x65\x20\x72\xe9\x70\x6c\x69\x63\x61\x73\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"siteLink-Display",
      L"classDisplayName",
      //Link do site 
      L"\x4c\x69\x6e\x6b\x20\x64\x6f\x20\x73\x69\x74\x65",
      //Link de site 
      L"\x4c\x69\x6e\x6b\x20\x64\x65\x20\x73\x69\x74\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"siteLinkBridge-Display",
      L"classDisplayName",
      //Ponte de links do site 
      L"\x50\x6f\x6e\x74\x65\x20\x64\x65\x20\x6c\x69\x6e\x6b\x73\x20\x64\x6f\x20\x73\x69\x74\x65",
      //Ponte de link de site 
      L"\x50\x6f\x6e\x74\x65\x20\x64\x65\x20\x6c\x69\x6e\x6b\x20\x64\x65\x20\x73\x69\x74\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"licensingSiteSettings-Display",
      L"classDisplayName",
      //Configuraes do site de licenciamento 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x6f\x20\x73\x69\x74\x65\x20\x64\x65\x20\x6c\x69\x63\x65\x6e\x63\x69\x61\x6d\x65\x6e\x74\x6f",
      //Configuraes de site de licenciamento 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x65\x20\x73\x69\x74\x65\x20\x64\x65\x20\x6c\x69\x63\x65\x6e\x63\x69\x61\x6d\x65\x6e\x74\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTDSSiteSettings-Display",
      L"classDisplayName",
      //Configuraes do site 
      L"\x43\x6f\x6e\x66\x69\x67\x75\x72\x61\xe7\xf5\x65\x73\x20\x64\x6f\x20\x73\x69\x74\x65",
      //Definies de site 
      L"\x44\x65\x66\x69\x6e\x69\xe7\xf5\x65\x73\x20\x64\x65\x20\x73\x69\x74\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTFRSMember-Display",
      L"classDisplayName",
      //Participante do servio de replicao de arquivos 
      L"\x50\x61\x72\x74\x69\x63\x69\x70\x61\x6e\x74\x65\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x72\x65\x70\x6c\x69\x63\x61\xe7\xe3\x6f\x20\x64\x65\x20\x61\x72\x71\x75\x69\x76\x6f\x73",
      //Membro FRS 
      L"\x4d\x65\x6d\x62\x72\x6f\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTFRSSubscriber-Display",
      L"classDisplayName",
      //Assinante do servio de duplicao de arquivos 
      L"\x41\x73\x73\x69\x6e\x61\x6e\x74\x65\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x64\x75\x70\x6c\x69\x63\x61\xe7\xe3\x6f\x20\x64\x65\x20\x61\x72\x71\x75\x69\x76\x6f\x73",
      //Assinante FRS 
      L"\x41\x73\x73\x69\x6e\x61\x6e\x74\x65\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTFRSSubscriptions-Display",
      L"classDisplayName",
      //Assinaturas do servio de duplicao de arquivos 
      L"\x41\x73\x73\x69\x6e\x61\x74\x75\x72\x61\x73\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x64\x75\x70\x6c\x69\x63\x61\xe7\xe3\x6f\x20\x64\x65\x20\x61\x72\x71\x75\x69\x76\x6f\x73",
      //Assinaturas FRS 
      L"\x41\x73\x73\x69\x6e\x61\x74\x75\x72\x61\x73\x20\x46\x52\x53",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"rpcContainer-Display",
      L"classDisplayName",
      //Servios de chamada a procedimentos remotos 
      L"\x53\x65\x72\x76\x69\xe7\x6f\x73\x20\x64\x65\x20\x63\x68\x61\x6d\x61\x64\x61\x20\x61\x20\x70\x72\x6f\x63\x65\x64\x69\x6d\x65\x6e\x74\x6f\x73\x20\x72\x65\x6d\x6f\x74\x6f\x73",
      //Servios de chamada de procedimento remoto 
      L"\x53\x65\x72\x76\x69\xe7\x6f\x73\x20\x64\x65\x20\x63\x68\x61\x6d\x61\x64\x61\x20\x64\x65\x20\x70\x72\x6f\x63\x65\x64\x69\x6d\x65\x6e\x74\x6f\x20\x72\x65\x6d\x6f\x74\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"mSMQEnterpriseSettings-Display",
      L"classDisplayName",
      //Empreendimento MSMQ 
      L"\x45\x6d\x70\x72\x65\x65\x6e\x64\x69\x6d\x65\x6e\x74\x6f\x20\x4d\x53\x4d\x51",
      //MSMQ corporativa 
      L"\x4d\x53\x4d\x51\x20\x63\x6f\x72\x70\x6f\x72\x61\x74\x69\x76\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"mSMQMigratedUser-Display",
      L"classDisplayName",
      //Usurio atualizado MSMQ 
      L"\x55\x73\x75\xe1\x72\x69\x6f\x20\x61\x74\x75\x61\x6c\x69\x7a\x61\x64\x6f\x20\x4d\x53\x4d\x51",
      //Usurio atualizado do MSMQ 
      L"\x55\x73\x75\xe1\x72\x69\x6f\x20\x61\x74\x75\x61\x6c\x69\x7a\x61\x64\x6f\x20\x64\x6f\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"mSMQSiteLink-Display",
      L"classDisplayName",
      //Link de roteamento MSMQ 
      L"\x4c\x69\x6e\x6b\x20\x64\x65\x20\x72\x6f\x74\x65\x61\x6d\x65\x6e\x74\x6f\x20\x4d\x53\x4d\x51",
      //Link de roteamento do servio de enfileiramento de mensagens da Microsoft 
      L"\x4c\x69\x6e\x6b\x20\x64\x65\x20\x72\x6f\x74\x65\x61\x6d\x65\x6e\x74\x6f\x20\x64\x6f\x20\x73\x65\x72\x76\x69\xe7\x6f\x20\x64\x65\x20\x65\x6e\x66\x69\x6c\x65\x69\x72\x61\x6d\x65\x6e\x74\x6f\x20\x64\x65\x20\x6d\x65\x6e\x73\x61\x67\x65\x6e\x73\x20\x64\x61\x20\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"nTDSService-Display",
      L"classDisplayName",
      //Servio Active Directory 
      L"\x53\x65\x72\x76\x69\xe7\x6f\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      //Servio do Active Directory 
      L"\x53\x65\x72\x76\x69\xe7\x6f\x20\x64\x6f\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Principal segurana externa 
      L"\x50\x72\x69\x6e\x63\x69\x70\x61\x6c\x20\x73\x65\x67\x75\x72\x61\x6e\xe7\x61\x20\x65\x78\x74\x65\x72\x6e\x61",
      //Objeto de segurana externo 
      L"\x4f\x62\x6a\x65\x74\x6f\x20\x64\x65\x20\x73\x65\x67\x75\x72\x61\x6e\xe7\x61\x20\x65\x78\x74\x65\x72\x6e\x6f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x416,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"user-Display",
      L"attributeDisplayNames",
      //department,????????? 
      L"\x64\x65\x70\x61\x72\x74\x6d\x65\x6e\x74\x2c\x41e\x442\x434\x435\x43b\x435\x43d\x438\x435",
      //department,????? 
      L"\x64\x65\x70\x61\x72\x74\x6d\x65\x6e\x74\x2c\x41e\x442\x434\x435\x43b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,???????? ? ??????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x427\x43b\x435\x43d\x441\x442\x432\x43e\x20\x432\x20\x433\x440\x443\x43f\x43f\x430\x445",
      //memberOf,???? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x427\x43b\x435\x43d\x20\x433\x440\x443\x43f\x43f\x44b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?????? ??? 
      L"\x63\x6e\x2c\x41f\x43e\x43b\x43d\x43e\x435\x20\x438\x43c\x44f",
      //dc,?????? ??? 
      L"\x64\x63\x2c\x41f\x43e\x43b\x43d\x43e\x435\x20\x438\x43c\x44f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"contact-Display",
      L"attributeDisplayNames",
      //department,????????? 
      L"\x64\x65\x70\x61\x72\x74\x6d\x65\x6e\x74\x2c\x41e\x442\x434\x435\x43b\x435\x43d\x438\x435",
      //department,????? 
      L"\x64\x65\x70\x61\x72\x74\x6d\x65\x6e\x74\x2c\x41e\x442\x434\x435\x43b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,???????? ? ??????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x427\x43b\x435\x43d\x441\x442\x432\x43e\x20\x432\x20\x433\x440\x443\x43f\x43f\x430\x445",
      //memberOf,???? ?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x427\x43b\x435\x43d\x20\x433\x440\x443\x43f\x43f\x44b",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"nTDSService-Display",
      L"classDisplayName",
      //?????? ????????? Active Directory 
      L"\x421\x43b\x443\x436\x431\x430\x20\x43a\x430\x442\x430\x43b\x43e\x433\x43e\x432\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      //?????? Active Directory 
      L"\x421\x43b\x443\x436\x431\x430\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x419,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"user-Display",
      L"attributeDisplayNames",
      //division,Division 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x73\x69\x6f\x6e",
      //division,Avdelning 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x41\x76\x64\x65\x6c\x6e\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppmedlemskap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x70",
      //memberOf,Medlem i 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x69",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Namn 
      L"\x63\x6e\x2c\x4e\x61\x6d\x6e",
      //dc,Namn 
      L"\x64\x63\x2c\x4e\x61\x6d\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"contact-Display",
      L"attributeDisplayNames",
      //division,Division 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x44\x69\x76\x69\x73\x69\x6f\x6e",
      //division,Avdelning 
      L"\x64\x69\x76\x69\x73\x69\x6f\x6e\x2c\x41\x76\x64\x65\x6c\x6e\x69\x6e\x67",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Gruppmedlemskap 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x70\x6d\x65\x64\x6c\x65\x6d\x73\x6b\x61\x70",
      //memberOf,Medlem i 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x64\x6c\x65\x6d\x20\x69",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"computer-Display",
      L"classDisplayName",
      //Dator 
      L"\x44\x61\x74\x6f\x72",
      //computer 
      L"\x63\x6f\x6d\x70\x75\x74\x65\x72",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x41d,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Grup yeligi 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x20\xdc\x79\x65\x6c\x69\x11f\x69",
      //memberOf,yesi olunan gruplar 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xdc\x79\x65\x73\x69\x20\x6f\x6c\x75\x6e\x61\x6e\x20\x67\x72\x75\x70\x6c\x61\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"user-Display",
      L"attributeDisplayNames",
      //personalTitle,nvan 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xdc\x6e\x76\x61\x6e",
      //personalTitle,Unvan 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x55\x6e\x76\x61\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Adi 
      L"\x63\x6e\x2c\x41\x64\x131",
      //dc,Adi 
      L"\x64\x63\x2c\x41\x64\x131",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Grup yeligi 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x75\x70\x20\xdc\x79\x65\x6c\x69\x11f\x69",
      //memberOf,yesi olunan gruplar 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\xdc\x79\x65\x73\x69\x20\x6f\x6c\x75\x6e\x61\x6e\x20\x67\x72\x75\x70\x6c\x61\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"contact-Display",
      L"attributeDisplayNames",
      //personalTitle,nvan 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\xdc\x6e\x76\x61\x6e",
      //personalTitle,Unvan 
      L"\x70\x65\x72\x73\x6f\x6e\x61\x6c\x54\x69\x74\x6c\x65\x2c\x55\x6e\x76\x61\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"serviceAdministrationPoint-Display",
      L"classDisplayName",
      //Hizmet 
      L"\x48\x69\x7a\x6d\x65\x74",
      //Active Directory Hizmeti 
      L"\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x20\x48\x69\x7a\x6d\x65\x74\x69",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Yabanci Gvenlik Ilkesi 
      L"\x59\x61\x62\x61\x6e\x63\x131\x20\x47\xfc\x76\x65\x6e\x6c\x69\x6b\x20\x130\x6c\x6b\x65\x73\x69",
      //Yabanci Gvenlik Sorumlusu 
      L"\x59\x61\x62\x61\x6e\x63\x131\x20\x47\xfc\x76\x65\x6e\x6c\x69\x6b\x20\x53\x6f\x72\x75\x6d\x6c\x75\x73\x75",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x41f,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x7279\x5f02\x540d\x79f0",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x522b\x540d\x79f0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,??? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x7ec4\x6210\x5458",
      //memberOf,?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x6210\x5458\x8eab\x4efd\x5c5e\x4e8e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,???? (??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4f20\x771f\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherFacsimileTelephoneNumber,????(??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4f20\x771f\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5bb6\x5ead\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherHomePhone,??????(??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5bb6\x5ead\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP ???? (??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherIpPhone,IP ????(??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMailbox,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x7535\x5b50\x90ae\x4ef6\x5730\x5740\x20\x28\x5176\x5b83\x29",
      //otherMailbox,??????(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x7535\x5b50\x90ae\x4ef6\x5730\x5740\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherMobile,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x79fb\x52a8\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherMobile,??????(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x79fb\x52a8\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherPager,???? (??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x547c\x673a\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherPager,????(??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x547c\x673a\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //otherTelephone,???? (??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherTelephone,????(??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,??? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x767b\x5f55\x540d\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      //samAccountName,???(Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x767b\x5f55\x540d\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //telexNumber,???? (??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x7535\x62a5\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //telexNumber,????(??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x7535\x62a5\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"user-Display",
      L"attributeDisplayNames",
      //url,???? (??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x20\x28\x5176\x5b83\x29",
      //url,????(??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"group-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x7279\x5f02\x540d\x79f0",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x522b\x540d\x79f0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,?? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x7ec4\x540d\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      //samAccountName,??(Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x7ec4\x540d\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"group-Display",
      L"attributeDisplayNames",
      //url,???? (??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x20\x28\x5176\x5b83\x29",
      //url,????(??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,?? 
      L"\x63\x6e\x2c\x540d\x79f0",
      //dc,?? 
      L"\x64\x63\x2c\x540d\x79f0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x7279\x5f02\x540d\x79f0",
      //distinguishedName,X500 ???? 
      L"\x64\x69\x73\x74\x69\x6e\x67\x75\x69\x73\x68\x65\x64\x4e\x61\x6d\x65\x2c\x58\x35\x30\x30\x20\x8fa8\x522b\x540d\x79f0",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber,?? ISDN ?? (??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x56fd\x9645\x20\x49\x53\x44\x4e\x20\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //internationalISDNNumber,?? ISDN ??(??) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x56fd\x9645\x20\x49\x53\x44\x4e\x20\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,??? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x7ec4\x6210\x5458",
      //memberOf,?????? 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x6210\x5458\x8eab\x4efd\x5c5e\x4e8e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherFacsimileTelephoneNumber,???? (??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4f20\x771f\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherFacsimileTelephoneNumber,????(??) 
      L"\x6f\x74\x68\x65\x72\x46\x61\x63\x73\x69\x6d\x69\x6c\x65\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x4e\x75\x6d\x62\x65\x72\x2c\x4f20\x771f\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherHomePhone,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5bb6\x5ead\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherHomePhone,??????(??) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x5bb6\x5ead\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherIpPhone,IP ???? (??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherIpPhone,IP ????(??) 
      L"\x6f\x74\x68\x65\x72\x49\x70\x50\x68\x6f\x6e\x65\x2c\x49\x50\x20\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMailbox,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x7535\x5b50\x90ae\x4ef6\x5730\x5740\x20\x28\x5176\x5b83\x29",
      //otherMailbox,??????(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x61\x69\x6c\x62\x6f\x78\x2c\x7535\x5b50\x90ae\x4ef6\x5730\x5740\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherMobile,?????? (??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x79fb\x52a8\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherMobile,??????(??) 
      L"\x6f\x74\x68\x65\x72\x4d\x6f\x62\x69\x6c\x65\x2c\x79fb\x52a8\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherPager,???? (??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x547c\x673a\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherPager,????(??) 
      L"\x6f\x74\x68\x65\x72\x50\x61\x67\x65\x72\x2c\x547c\x673a\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //otherTelephone,???? (??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x7535\x8bdd\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //otherTelephone,????(??) 
      L"\x6f\x74\x68\x65\x72\x54\x65\x6c\x65\x70\x68\x6f\x6e\x65\x2c\x7535\x8bdd\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //telexNumber,???? (??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x7535\x62a5\x53f7\x7801\x20\x28\x5176\x5b83\x29",
      //telexNumber,????(??) 
      L"\x74\x65\x6c\x65\x78\x4e\x75\x6d\x62\x65\x72\x2c\x7535\x62a5\x53f7\x7801\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"attributeDisplayNames",
      //url,???? (??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x20\x28\x5176\x5b83\x29",
      //url,????(??) 
      L"\x75\x72\x6c\x2c\x7f51\x9875\x5730\x5740\x28\x5176\x5b83\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"contact-Display",
      L"classDisplayName",
      //??? 
      L"\x8054\x7edc\x4eba",
      //??? 
      L"\x8054\x7cfb\x4eba",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,???? (Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x8ba1\x7b97\x673a\x540d\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      //samAccountName,????(Windows 2000 ????) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x8ba1\x7b97\x673a\x540d\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x4ee5\x524d\x7248\x672c\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //contactName,??? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x8054\x7edc\x4eba",
      //contactName,??? 
      L"\x63\x6f\x6e\x74\x61\x63\x74\x4e\x61\x6d\x65\x2c\x8054\x7cfb\x4eba",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"pKICertificateTemplate-Display",
      L"classDisplayName",
      //???? 
      L"\x8bc1\x4e66\x6478\x677f",
      //???? 
      L"\x8bc1\x4e66\x6a21\x677f",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x804,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Membro do grupo 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x6f\x20\x64\x6f\x20\x67\x72\x75\x70\x6f",
      //memberOf,Membro de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x6f\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nome 
      L"\x63\x6e\x2c\x4e\x6f\x6d\x65",
      //dc,Nome 
      L"\x64\x63\x2c\x4e\x6f\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Membro do grupo 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x6f\x20\x64\x6f\x20\x67\x72\x75\x70\x6f",
      //memberOf,Membro de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x72\x6f\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"site-Display",
      L"classDisplayName",
      //Site 
      L"\x53\x69\x74\x65",
      //Local 
      L"\x4c\x6f\x63\x61\x6c",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"queryPolicy-Display",
      L"classDisplayName",
      //Poltica de consultas 
      L"\x50\x6f\x6c\xed\x74\x69\x63\x61\x20\x64\x65\x20\x63\x6f\x6e\x73\x75\x6c\x74\x61\x73",
      //Poltica de consulta 
      L"\x50\x6f\x6c\xed\x74\x69\x63\x61\x20\x64\x65\x20\x63\x6f\x6e\x73\x75\x6c\x74\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x816,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Pertenencia a grupos 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x65\x72\x74\x65\x6e\x65\x6e\x63\x69\x61\x20\x61\x20\x67\x72\x75\x70\x6f\x73",
      //memberOf,Miembro de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x69\x65\x6d\x62\x72\x6f\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"user-Display",
      L"attributeDisplayNames",
      //samAccountName,Nombre de inicio de sesin (pre-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x20\x69\x6e\x69\x63\x69\x6f\x20\x64\x65\x20\x73\x65\x73\x69\xf3\x6e\x20\x28\x70\x72\x65\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nombre de inicio de sesin (anterior a Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x20\x69\x6e\x69\x63\x69\x6f\x20\x64\x65\x20\x73\x65\x73\x69\xf3\x6e\x20\x28\x61\x6e\x74\x65\x72\x69\x6f\x72\x20\x61\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"group-Display",
      L"attributeDisplayNames",
      //samAccountName,Nombre del grupo (pre-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x6c\x20\x67\x72\x75\x70\x6f\x20\x28\x70\x72\x65\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nombre del grupo (anterior a Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x6c\x20\x67\x72\x75\x70\x6f\x20\x28\x61\x6e\x74\x65\x72\x69\x6f\x72\x20\x61\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Nombre 
      L"\x63\x6e\x2c\x4e\x6f\x6d\x62\x72\x65",
      //dc,Nombre 
      L"\x64\x63\x2c\x4e\x6f\x6d\x62\x72\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Pertenencia a grupos 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x50\x65\x72\x74\x65\x6e\x65\x6e\x63\x69\x61\x20\x61\x20\x67\x72\x75\x70\x6f\x73",
      //memberOf,Miembro de 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x69\x65\x6d\x62\x72\x6f\x20\x64\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"computer-Display",
      L"attributeDisplayNames",
      //samAccountName,Nombre de equipo (pre-Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x20\x65\x71\x75\x69\x70\x6f\x20\x28\x70\x72\x65\x2d\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      //samAccountName,Nombre del equipo (anterior a Windows 2000) 
      L"\x73\x61\x6d\x41\x63\x63\x6f\x75\x6e\x74\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x6c\x20\x65\x71\x75\x69\x70\x6f\x20\x28\x61\x6e\x74\x65\x72\x69\x6f\x72\x20\x61\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //assetNumber,Nmero de activo 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x61\x63\x74\x69\x76\x6f",
      //assetNumber,Nmero de inventario 
      L"\x61\x73\x73\x65\x74\x4e\x75\x6d\x62\x65\x72\x2c\x4e\xfa\x6d\x65\x72\x6f\x20\x64\x65\x20\x69\x6e\x76\x65\x6e\x74\x61\x72\x69\x6f",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //printLanguage,Lenguaje de la impresora 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x4c\x65\x6e\x67\x75\x61\x6a\x65\x20\x64\x65\x20\x6c\x61\x20\x69\x6d\x70\x72\x65\x73\x6f\x72\x61",
      //printLanguage,Idioma de impresin 
      L"\x70\x72\x69\x6e\x74\x4c\x61\x6e\x67\x75\x61\x67\x65\x2c\x49\x64\x69\x6f\x6d\x61\x20\x64\x65\x20\x69\x6d\x70\x72\x65\x73\x69\xf3\x6e",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"printQueue-Display",
      L"attributeDisplayNames",
      //serverName,Nombre de servidor 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x20\x73\x65\x72\x76\x69\x64\x6f\x72",
      //serverName,Nombre del servidor 
      L"\x73\x65\x72\x76\x65\x72\x4e\x61\x6d\x65\x2c\x4e\x6f\x6d\x62\x72\x65\x20\x64\x65\x6c\x20\x73\x65\x72\x76\x69\x64\x6f\x72",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"trustedDomain-Display",
      L"classDisplayName",
      //Dominio en que se confa 
      L"\x44\x6f\x6d\x69\x6e\x69\x6f\x20\x65\x6e\x20\x71\x75\x65\x20\x73\x65\x20\x63\x6f\x6e\x66\xed\x61",
      //Dominio de confianza 
      L"\x44\x6f\x6d\x69\x6e\x69\x6f\x20\x64\x65\x20\x63\x6f\x6e\x66\x69\x61\x6e\x7a\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"volume-Display",
      L"attributeDisplayNames",
      //uNCName,Ruta de red 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x52\x75\x74\x61\x20\x64\x65\x20\x72\x65\x64",
      //uNCName,Ruta de acceso a la red 
      L"\x75\x4e\x43\x4e\x61\x6d\x65\x2c\x52\x75\x74\x61\x20\x64\x65\x20\x61\x63\x63\x65\x73\x6f\x20\x61\x20\x6c\x61\x20\x72\x65\x64",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"mSMQQueue-Display",
      L"classDisplayName",
      //Cola MSMQ 
      L"\x43\x6f\x6c\x61\x20\x4d\x53\x4d\x51",
      //Cola de MSMQ 
      L"\x43\x6f\x6c\x61\x20\x64\x65\x20\x4d\x53\x4d\x51",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"remoteStorageServicePoint-Display",
      L"adminContextMenu",
      //0,Ad&ministrar...,RsAdmin.msc 
      L"\x30\x2c\x41\x64\x26\x6d\x69\x6e\x69\x73\x74\x72\x61\x72\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      //0,&Administrar...,RsAdmin.msc 
      L"\x30\x2c\x26\x41\x64\x6d\x69\x6e\x69\x73\x74\x72\x61\x72\x2e\x2e\x2e\x2c\x52\x73\x41\x64\x6d\x69\x6e\x2e\x6d\x73\x63",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"nTDSService-Display",
      L"classDisplayName",
      //Servicio de Active Directory 
      L"\x53\x65\x72\x76\x69\x63\x69\x6f\x20\x64\x65\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      //Servicios de Active Directory 
      L"\x53\x65\x72\x76\x69\x63\x69\x6f\x73\x20\x64\x65\x20\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"foreignSecurityPrincipal-Display",
      L"classDisplayName",
      //Principal de seguridad externa 
      L"\x50\x72\x69\x6e\x63\x69\x70\x61\x6c\x20\x64\x65\x20\x73\x65\x67\x75\x72\x69\x64\x61\x64\x20\x65\x78\x74\x65\x72\x6e\x61",
      //Entidad principal de seguridad externa 
      L"\x45\x6e\x74\x69\x64\x61\x64\x20\x70\x72\x69\x6e\x63\x69\x70\x61\x6c\x20\x64\x65\x20\x73\x65\x67\x75\x72\x69\x64\x61\x64\x20\x65\x78\x74\x65\x72\x6e\x61",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0xc0a,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"user-Display",
      L"attributeDisplayNames",
      //internationalISDNNumber, International ISDN Number (Others) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x20\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x20\x49\x53\x44\x4e\x20\x4e\x75\x6d\x62\x65\x72\x20\x28\x4f\x74\x68\x65\x72\x73\x29",
      //internationalISDNNumber,International ISDN Number (Others) 
      L"\x69\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x49\x53\x44\x4e\x4e\x75\x6d\x62\x65\x72\x2c\x49\x6e\x74\x65\x72\x6e\x61\x74\x69\x6f\x6e\x61\x6c\x20\x49\x53\x44\x4e\x20\x4e\x75\x6d\x62\x65\x72\x20\x28\x4f\x74\x68\x65\x72\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"user-Display",
      L"attributeDisplayNames",
      //memberOf,Group Membership 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x6f\x75\x70\x20\x4d\x65\x6d\x62\x65\x72\x73\x68\x69\x70",
      //memberOf,Member Of 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x65\x72\x20\x4f\x66",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"user-Display",
      L"attributeDisplayNames",
      //otherHomePhone,Home Phone (Others) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x48\x6f\x6d\x65\x20\x50\x68\x6f\x6e\x65\x20\x28\x4f\x74\x68\x65\x72\x73\x29",
      //otherHomePhone,Home Phone Number (Others) 
      L"\x6f\x74\x68\x65\x72\x48\x6f\x6d\x65\x50\x68\x6f\x6e\x65\x2c\x48\x6f\x6d\x65\x20\x50\x68\x6f\x6e\x65\x20\x4e\x75\x6d\x62\x65\x72\x20\x28\x4f\x74\x68\x65\x72\x73\x29",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"domainDNS-Display",
      L"attributeDisplayNames",
      //cn,Name 
      L"\x63\x6e\x2c\x4e\x61\x6d\x65",
      //dc,Name 
      L"\x64\x63\x2c\x4e\x61\x6d\x65",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"contact-Display",
      L"attributeDisplayNames",
      //memberOf,Group Membership 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x47\x72\x6f\x75\x70\x20\x4d\x65\x6d\x62\x65\x72\x73\x68\x69\x70",
      //memberOf,Member Of 
      L"\x6d\x65\x6d\x62\x65\x72\x4f\x66\x2c\x4d\x65\x6d\x62\x65\x72\x20\x4f\x66",
      REPLACE_W2K_MULTIPLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"nTDSService-Display",
      L"classDisplayName",
      //Service 
      L"\x53\x65\x72\x76\x69\x63\x65",
      //Active Directory Service 
      L"\x41\x63\x74\x69\x76\x65\x20\x44\x69\x72\x65\x63\x74\x6f\x72\x79\x20\x53\x65\x72\x76\x69\x63\x65",
      REPLACE_W2K_SINGLE_VALUE
   );

   addChange
   (  guids[0],
      0x409,
      L"pKICertificateTemplate-Display",
      L"iconPath",
      //0,capesnpn.dll,-227 
      L"\x30\x2c\x63\x61\x70\x65\x73\x6e\x70\x6e\x2e\x64\x6c\x6c\x2c\x2d\x32\x32\x37",
      //0,certtmpl.dll,-144 
      L"\x30\x2c\x63\x65\x72\x74\x74\x6d\x70\x6c\x2e\x64\x6c\x6c\x2c\x2d\x31\x34\x34",
      REPLACE_W2K_SINGLE_VALUE
   );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\repair.hpp ===
// Class with the repair phase
// Copyright (c) 2001 Microsoft Corporation
// Jun 2001 lucios

#ifndef REPAIR_HPP
#define REPAIR_HPP

#include  "AnalysisResults.hpp"
#include  "dspecup.hpp"

// USED IN runCsvOrLdif
enum csvOrLdif {LDIF,CSV};
enum importExport {IMPORT,EXPORT};

class CSVDSReader;
struct sChangeList;


class Repair
{
public:
   Repair
   (
      const CSVDSReader& csvReader409_,
      const CSVDSReader& csvReaderIntl_,
      const String& domain,
      const String& rootContainerDn_,
      AnalysisResults& res,
      const String& ldiffName_,
      const String& csvName_,
      const String& saveName_,
      const String& logPath_,
      const String& completeDcName_,
      void *caleeStruct_=NULL,
      progressFunction stepIt_=NULL,
      progressFunction totalSteps_=NULL
   );
   

   HRESULT run();

private:
   AnalysisResults& results;
   const CSVDSReader&   csvReader409;
   const CSVDSReader&   csvReaderIntl;
   const String         domain;
   const String         rootContainerDn;
   const String         ldiffName;
   const String         csvName;
   const String         saveName;
   const String         logPath;
   const String         completeDcName;

   String               csvLog;
   String               ldifLog;

   void                 *caleeStruct;
   progressFunction     stepIt;
   progressFunction     totalSteps;


   long csvBuildStep;
   long ldiffBuildStep;
   long csvRunStep;
   long ldiffRunStep;
   long ldiffSaveStep;
   long csvActions;
   long ldiffActions;

   
   HRESULT buildSaveLdif();
   HRESULT buildChangeLdif();

   HRESULT
   makeObjectsCsv(HANDLE file,ObjectIdList &objects);

   HRESULT
   makeObjectsLdif(HANDLE file,ObjectIdList &objects);

   HRESULT buildCsv();


   HRESULT 
   runCsvOrLdif(
                   csvOrLdif whichExe,
                   importExport inOut,
                   const String& file,
                   const String& extraOptions=L"",
                   const String& logFileArg=L""
                );


   HRESULT
   getLdifExportedObject (
                          const long locale,
                          const String &object,
                          String &objectLines
                         );
   
   void setProgress();


};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\prebuild\prebuild.cpp ===
#include "headers.hxx"
#include "..\CSVDSReader.hpp"
#include "..\constants.hpp"
#include "..\global.hpp"
#include <winnls.h>


///////////// Basic Functions ///////////////

// included so that sizeof(guids) works properlly
#include "..\guids.inc"


// used for parameter checking in wmain
bool fileExists(const wchar_t *fileName,const wchar_t *mode=L"r")
{
    FILE *f=_wfopen(fileName,mode);
    if(f==NULL) return false;
    fclose(f);
    return true;
}

// used for parameter checking in wmain
#define BREAK_IF_MISSING(hr,fileName) \
    if(!fileExists(fileName.c_str())) \
    { \
        hr=E_FAIL; \
        wprintf(L"\n File Missing: %s.\n",fileName.c_str()); \
        break; \
    } \


// used for parameter checking in wmain
#define BREAK_IF_MISSING_OR_READONLY(hr,fileName) \
    BREAK_IF_MISSING(hr,fileName) \
    if(!fileExists(fileName.c_str(),L"a+")) \
    { \
        hr=E_FAIL; \
        wprintf(L"\n Read Only: %s.\n",fileName.c_str()); \
        break; \
    } \

// converts outStr to AnsiString and writes to fileOut
// Fails if conversion or writing fails
HRESULT writeStringAsAnsi(HANDLE fileOut,const String& outStr)
{
    AnsiString ansiStr;
    String::ConvertResult res=outStr.convert(ansiStr);
    if(res!=String::CONVERT_SUCCESSFUL)
    {
        ASSERT(res==String::CONVERT_SUCCESSFUL);
        error=L"Ansi conversion failed";
        return E_FAIL;
    }
    return FS::Write(fileOut,ansiStr);
}

// converts outStr to AnsiString and writes to fileOut
// Fails if conversion or writing fails
HRESULT printStringAsAnsi(const String& outStr)
{
    AnsiString ansiStr;
    String::ConvertResult res=outStr.convert(ansiStr);
    if(res!=String::CONVERT_SUCCESSFUL)
    {
        ASSERT(res==String::CONVERT_SUCCESSFUL);
        error=L"Ansi conversion failed";
        return E_FAIL;
    }
    return printf(ansiStr.c_str());
}


// performs a-b, keys in a but not in b go to out
template <class T,class Y,class less,class allocator>
void mapKeyDifference
(
    const map <T,Y,less,allocator> &a,
    const map <T,Y,less,allocator> &b,
    map <T,Y,less,allocator> &out
)
{
    out.clear();

    map <T,Y,less,allocator>::const_iterator cur=a.begin(),end=a.end();
    while(cur!=end)
    {
        if(b.find(cur->first)==b.end())
        {
            out[cur->first]=cur->second;
        }
        cur++;
    }
}

// true if all keys in a are in b and a.size()=b.size()
template <class T,class Y,class less,class allocator>
bool mapKeyEqual
(
    const map <T,Y,less,allocator> &a,
    const map <T,Y,less,allocator> &b
)
{
    if (a.size()!=b.size()) return false;

    map <T,Y,less,allocator>::const_iterator cur=a.begin(),end=a.end();
    while(cur!=end)
    {
        if(b.find(cur->first)==b.end())
        {
            return false;
        }
        cur++;
    }
    return true;
}

// performs a ^ b, keys in both a and in b go to out
template <class T,class Y,class less,class allocator>
void mapKeyIntersection
(
    const map <T,Y,less,allocator> &a,
    const map <T,Y,less,allocator> &b,
    map <T,Y,less,allocator> &out
)
{
    out.clear();

    map <T,Y,less,allocator>::const_iterator cur=a.begin(),end=a.end();
    while(cur!=end)
    {
        if(b.find(cur->first)!=b.end())
        {
            out[cur->first]=cur->second;
        }
        cur++;
    }
}

String escape(const String &str)
{
   LOG_FUNCTION(escape);
   String dest;
   wchar_t strNum[7];
   const wchar_t *csr=str.c_str();
   while(*csr!=0)
   {
      wsprintf(strNum,L"\\x%x",*csr);
      dest+=String(strNum);
      csr++;
   }
   return dest;
}

HRESULT
parseGUID
(
    const String& str,
    long *ordinal,
    GUID *guid
)
{
    wchar_t *stop;
    HRESULT hr=S_OK;
    do
    {
        if (str.size()==0 || str[str.size()-1]!='}') 
        {
            hr=E_FAIL;
            break;
        }
        String strAux=str.substr(0,str.size()-1);
        const wchar_t *strGuid=strAux.c_str();
        *ordinal=wcstol(strGuid,&stop,10);
        if(*stop!=L',' || *(stop+1)!=L'{' || stop==strGuid) 
        {
            hr=E_FAIL;
            break;
        }
        if(UuidFromString(stop+2,guid)!=RPC_S_OK) 
        {
            hr=E_FAIL;
            break;
        }
    } while(0);

    return hr;
}

bool isGuid(const String &str)
{
    long ordinal;
    GUID guid;
    return SUCCEEDED(parseGUID(str,&ordinal,&guid));
}

String makeGuidString(long ordinal,GUID guid)
{
    String ret;
    wchar_t *wRet;
    if(UuidToString(&guid,&wRet)!=RPC_S_OK) throw new bad_alloc;
    ret=String::format(L"%1!d!,{%2}",ordinal,wRet);
    RpcStringFree(&wRet);
    return ret;
}
///////////// Basic Functions End ///////////////



///////////////////////////////////////////////////


// Return the differences and commonalities between the
// properties in oldCsv and newCsv. Uses csvName to specify
// the csv in error messages.
// Failure cases:
//    no common properties
//    properties in oldCsv not in newCsv
HRESULT getPropertyChanges
(
    const CSVDSReader &oldCsv,
    const CSVDSReader &newCsv,
    mapOfPositions    &commonProperties,
    mapOfPositions    &newProperties,
    const wchar_t     *csvName
)
{
    const mapOfPositions &oldProps=oldCsv.getProperties();
    const mapOfPositions &newProps=newCsv.getProperties();
    
    mapKeyIntersection(oldProps,newProps,commonProperties);

    if(commonProperties.size()==0)
    {
        error=String::format(L"No comon %1!s! properties!",csvName);
        return E_FAIL;
    }
    mapOfPositions deletedProps;
    mapKeyDifference(oldProps,newProps,deletedProps);
    
    if(deletedProps.size()!=0)
    {
        error=String::format
              ( 
                L"Properties only in the old %1!s! are not supported, since"
                L"there is no operation to delete a property. there are %2!d!"
                L"properties like this and \"%3!s!\" is the first property.",
                csvName,deletedProps.size(),
                deletedProps.begin()->first
              );
        return E_FAIL;
    }
    mapKeyDifference(newProps,oldProps,newProperties);
    if(newProperties.size()==0)
    {
        wprintf(L"No new %s properties.\n",csvName);
        return S_OK;
    }
    return S_OK;
}




// Adds to commonProperties the commonProperties between oldDcpromo
// and newDcpromo. and to new properties the properties in oldDcPromo
// not in newDcpromo
// Failure cases:
//    dcpromo's common properties are not the same as 409's
//    dcpromo's new properties are not the same as 409's
HRESULT getAllPropertyChanges
(
    const CSVDSReader &oldDcpromo,
    const CSVDSReader &newDcpromo,
    const CSVDSReader &old409,
    const CSVDSReader &new409,
    mapOfPositions    &commonProperties,
    mapOfPositions    &newProperties
)
{
    HRESULT hr=S_OK;
    do
    {
        hr=getPropertyChanges(
                                  oldDcpromo,
                                  newDcpromo,
                                  commonProperties,
                                  newProperties,
                                  L"dcpromo"
                              );
        BREAK_ON_FAILED_HRESULT(hr);
        
        mapOfPositions prop409New,prop409Common;
        hr=getPropertyChanges(
                                  old409,
                                  new409,
                                  prop409Common,
                                  prop409New,
                                  L"409" 
                              );
        BREAK_ON_FAILED_HRESULT(hr);

        if(!mapKeyEqual(prop409New,newProperties))
        {
            error=L"409 and dcpromo new properties are not the same.";
            hr=E_FAIL;
            break;
        }
        
        if(!mapKeyEqual(prop409Common,commonProperties))
        {
            error=L"409 and dcpromo common properties are not the same.";
            hr=E_FAIL;
            break;
        }
    } while (0);
    
    return hr;
}


// Writes the very begining of a computer generated 
// file header to fileOut
HRESULT writeHeader(const HANDLE fileOut)
{
    char* header;
    header ="// This file is generated by preBuild.exe\r\n"
            "// Copyright (c) 2001 Microsoft Corporation\r\n"
            "// Nov 2001 lucios\r\n"
            "\r\n"
            "#include \"headers.hxx\"\r\n"
            "#include \"constants.hpp\"\r\n"
            "\r\n";

    return  FS::Write(fileOut,AnsiString(header));
}

// Writes the nsetLocaleDependentChangesN function declaration to fileOut,
// where N is the guidNumber.
HRESULT writeChangesHeader(const HANDLE fileOut,int guidNumber)
{            
    String locDepStr=String::format
                             (
                                 "\r\nvoid setChanges%1!d!()\r\n{\r\n",
                                   guidNumber
                             );
    return writeStringAsAnsi(fileOut,locDepStr);
}

// Add an entry for the object/locale to fileOut.
HRESULT writeChange
(
    HANDLE          fileOut,
    long            locale,
    const String    &object,
    const String    &property,
    const String    &arg1,
    const String    &arg2,
    const String    &operation,
    int             guidNumber
)
{
    String entry=String::format
    (   
        L"\r\n"
        L"    addChange\r\n"
        L"    (\r\n"  
        L"        guids[%1!d!],\r\n"
        L"        0x%2!x!,\r\n"
        L"        L\"%3\",\r\n"
        L"        L\"%4\",\r\n"
        L"        //%5\r\n"
        L"        L\"%6\",\r\n"
        L"        //%7\n"
        L"        L\"%8\",\r\n"
        L"        %9\r\n"
        L"    );\r\n\r\n",
        guidNumber,
        locale,
        object.c_str(),
        property.c_str(),
        arg1.c_str(),
        escape(arg1).c_str(),
        arg2.c_str(),
        escape(arg2).c_str(),
        operation.c_str()
    );
    return writeStringAsAnsi(fileOut,entry);
}



HRESULT dealWithSingleValue
(
    HANDLE              fileOut,
    long                locale,
    const String        &object,
    const String        &property,
    const StringList    &valuesOld,
    const StringList    &valuesNew,
    int                 guidNumber
)
{
    // both sizes 0 is ok.
    if (valuesOld.size()==0 && valuesNew.size()==0) return S_OK;

    if (valuesOld.size()!=1 && valuesNew.size()!=1) 
    {
        // In the future we might want to add ADD_VALUE and REMOVE_VALUE
        // operations, for now we just want to be flagged.
        error = String::format
                (
                    L"Error in locale %1!x!, object %2,"
                    L"property %3.Number of values should be 1,1 "
                    L"instead of %4,%5.",
                    locale,
                    object.c_str(),
                    property.c_str(),
                    valuesOld.size(),
                    valuesNew.size()
                );
        return E_FAIL;
    }

    // Now we know we have a single value in each
    if(*valuesOld.begin()!=*valuesNew.begin())
    {
        return
        (
            writeChange
            (
                fileOut,
                locale,
                object,
                property,
                *valuesOld.begin(),
                *valuesNew.begin(),
                L"REPLACE_W2K_SINGLE_VALUE",
                guidNumber
            )
        );
    }

    return S_OK;
}



// These are values in the form "root,rest"
// if a value has the same root but a different rest we need to add
// a REPLACE_MULTIPLE_VALUE_OPERATION
// rotts in new that are not in old and roots in old that are not in new
// should be printed for manual inclusion since we don't know how to deal
// with them.

typedef map< 
                String,
                String,
                less<String>,
                Burnslib::Heap::Allocator<String> 
           > rootToRest;

HRESULT dealWithMultipleValue
(
    HANDLE              fileOut,
    long                locale,
    const String        &object,
    const String        &property,
    const StringList    &valuesOld,
    const StringList    &valuesNew,
    int                 guidNumber
)
{
    HRESULT hr=S_OK;
    rootToRest newRoots, oldRoots;
    
    do
    {
        if(valuesOld.size()!=valuesNew.size())
        {
                error=  String::format
                (
                    L"Error in locale %1!x!, object %2,"
                    L"property %3. Old has %4 values and new has %5. "
                    L"They should have the same number of values.",
                    locale,
                    object.c_str(),
                    property.c_str(),
                    valuesOld.size(),
                    valuesNew.size()
                );
                hr=E_FAIL;
                break;
        }
        // first lets add all roots and rests in maps
        // Starting by the old values...
        StringList::const_iterator csr,end;
        for(csr=valuesOld.begin(),end=valuesOld.end();csr!=end;csr++)
        {
            const String& value=*csr;
            long pos=value.find(L',');
            if(pos==String::npos) continue;
            String root=value.substr(0,pos);
            String rest=value.substr(pos+1);
            oldRoots[root]=rest;
        }
        BREAK_ON_FAILED_HRESULT(hr);

        //...And then the new values
        for(csr=valuesNew.begin(),end=valuesNew.end();csr!=end;csr++)
        {
            const String& value=*csr;
            long pos=value.find(L',');
            if(pos==String::npos) continue;
            String root=value.substr(0,pos);
            String rest=value.substr(pos+1);
            newRoots[root]=rest;
        }
        BREAK_ON_FAILED_HRESULT(hr);

        // now lets check all the values in one that are not in the other...
        rootToRest::iterator csrRoot=oldRoots.begin(),endRoot=oldRoots.end();
        rootToRest oldRootsNotInNew;
        for(;csrRoot!=endRoot;csrRoot++)
        {
            if(newRoots.find(csrRoot->first)==newRoots.end())
            {
                oldRootsNotInNew[csrRoot->first]=csrRoot->second;
            }
        }
        BREAK_ON_FAILED_HRESULT(hr);

        // ..and the values in other that are not in one, and...
        rootToRest newRootsNotInOld;
        csrRoot=newRoots.begin(),endRoot=newRoots.end();
        for(;csrRoot!=endRoot;csrRoot++)
        {
            if(oldRoots.find(csrRoot->first)==oldRoots.end())
            {
                newRootsNotInOld[csrRoot->first]=csrRoot->second;
            }
        }
        BREAK_ON_FAILED_HRESULT(hr);

        // ..if we have such values we need to investigate it further
        if(!oldRootsNotInNew.empty() || !newRootsNotInOld.empty())
        {
            // if we have exactly one "old value" not in "new" and one 
            // "new value" not in "old" we are going to assume that the
            // "old value" should be replaced by the "new value"...
            if(oldRootsNotInNew.size()==1 && newRootsNotInOld.size()==1)
            {
                String arg1=String::format
                            (
                                L"%1,%2",
                                oldRootsNotInNew.begin()->first.c_str(),
                                oldRootsNotInNew.begin()->second.c_str()
                            );
                String arg2=String::format
                            (
                                L"%1,%2",
                                newRootsNotInOld.begin()->first.c_str(),
                                newRootsNotInOld.begin()->second.c_str()
                            );
                
                String outStr=String::format
                (
                    L"\nAssuming change from:\"%1\" to \"%2\"  for "
                    L"locale %3!lx!, object %4 and property %5.\n",
                    arg1.c_str(),
                    arg2.c_str(),
                    locale,
                    object.c_str(),
                    property.c_str()
                );
                
                // We are ignoring the result returned here.
                printStringAsAnsi(outStr);

                hr=writeChange
                (
                    fileOut,
                    locale,
                    object,
                    property,
                    arg1,
                    arg2,
                    L"REPLACE_W2K_MULTIPLE_VALUE",
                    guidNumber
                ); 
                BREAK_ON_FAILED_HRESULT(hr);
            }
            else // ...otherwise we flag it as an error.
            {
                error=  String::format
                (
                    L"Error in locale %1!x!, object %2,"
                    L"property %3. There are %4 old values with the pre comma "
                    L"string not present in the new values and %5 new values "
                    L"with the pre comma string not present in the old values."
                    L"Without a common root it is not possible to know what "
                    L"replacement to make.",
                    object.c_str(),
                    property.c_str(),
                    newRootsNotInOld.size(),
                    oldRootsNotInNew.size()
                );
                hr=E_FAIL;
                break;
            }
        }
        
        //Now we detect changes for common root values
        csrRoot=newRoots.begin(),endRoot=newRoots.end();
        for(;csrRoot!=endRoot;csrRoot++)
        {
            const String& newRoot=csrRoot->first;
            const String& newRest=csrRoot->second;
            // if the new root is in old and the value changed
            if(
                oldRoots.find(newRoot)!=oldRoots.end() &&
                newRest!=oldRoots[newRoot]
              )
            {
                hr=writeChange
                (
                    fileOut,
                    locale,
                    object,
                    property,
                    String::format(L"%1,%2",newRoot.c_str(),
                                    oldRoots[newRoot].c_str()).c_str(),
                    String::format(L"%1,%2",newRoot.c_str(),
                                    newRest.c_str()).c_str(),
                    L"REPLACE_W2K_MULTIPLE_VALUE",
                    guidNumber
                ); 
                BREAK_ON_FAILED_HRESULT(hr);
            }
        }
        BREAK_ON_FAILED_HRESULT(hr);

    } while (0);
    return hr;
}


// if any value in valuesOld or valuesNew does not ressemble a GUID, fails
// since, in order to call this function, we've already checked that at least
// one in valuesOld or valuesNew ressembles a GUID.
// if x,{xxx} is y,{xxx} fails
// if x,{xxx} is x,{yyy} in the new csv REPLACE_GUID
// all {guids} in old not in new(not replaced) REMOVE_GUID
// all {guids} in new not in old(not replaced) ADD_GUID
typedef map< 
                GUID,
                long,
                GUIDLess<GUID>,
                Burnslib::Heap::Allocator<long> 
           > guidToOrd;

typedef map< 
                long,
                GUID,
                less<long>,
                Burnslib::Heap::Allocator<GUID> 
            > ordToGuid;

HRESULT dealWithGuids
(
    HANDLE              fileOut,
    long                locale,
    const String        &object,
    const String        &property,
    const StringList    &valuesOld,
    const StringList    &valuesNew,
    int                 guidNumber
)
{

    HRESULT hr=S_OK;
    do
    {
        guidToOrd guidToOrdNew;
        guidToOrd guidToOrdOld;
        ordToGuid ordToGuidOld;
        guidToOrd replacements;
        GUID oldGuid;long oldOrd;
        GUID guid;long ordinal;

        // First lets add the guids and ordinals to auxilliary maps
        // starting with the old values...
        StringList::const_iterator cur,end;
        cur=valuesOld.begin();end=valuesOld.end();
        for(;cur!=end;cur++)
        {
            const String &guidValue=*cur;
            hr=parseGUID(guidValue,&ordinal,&guid);
            if(FAILED(hr)) 
            {
                error=  String::format
                        (
                            L"Error in locale %1!x!, object %2,"
                            L"property %3. Failed to parse old guid: %4",
                            locale,
                            object.c_str(),
                            property.c_str(),
                            guidValue.c_str()
                        );
                break;
            }

            guidToOrdOld[guid]=ordinal;
            ordToGuidOld[ordinal]=guid;
        }
        BREAK_ON_FAILED_HRESULT(hr);

        // ...and then the new values.
        cur=valuesNew.begin();end=valuesNew.end();
        for(;cur!=end;cur++)
        {
            const String &guidValue=*cur;
            hr=parseGUID(guidValue,&ordinal,&guid);
            if(FAILED(hr)) 
            {
                error=  String::format
                        (
                            L"Error in locale %1!x!, object %2,"
                            L"property %3. Failed to parse new guid: %4",
                            locale,
                            object.c_str(),
                            property.c_str(),
                            guidValue.c_str()
                        );
                break;
            }

            guidToOrdNew[guid]=ordinal;
        }
        BREAK_ON_FAILED_HRESULT(hr);

        // Lets treat replacements and additions first
        guidToOrd::iterator csr,endCsr;
        csr=guidToOrdNew.begin();
        endCsr=guidToOrdNew.end();

        for(;csr!=endCsr;csr++)
        {
            GUID newGuid=csr->first;
            long newOrd=csr->second;

            // this flag is used not to add a replacement
            bool newGuidWasReplaced=false; 

            //... if ordinal is in old...
            if( ordToGuidOld.find(newOrd)!=ordToGuidOld.end() )
            {
                GUID oldGuid=ordToGuidOld[newOrd];
                 // ...with a different GUID, this means a replacement.
                if(oldGuid!=newGuid)
                {
                    hr=writeChange
                    (
                        fileOut,
                        locale,
                        object,
                        property,
                        makeGuidString(newOrd,oldGuid),
                        makeGuidString(newOrd,newGuid),
                        L"REPLACE_GUID",
                        guidNumber
                    );
                    BREAK_ON_FAILED_HRESULT(hr);
                    replacements[oldGuid]=newOrd;
                    newGuidWasReplaced=true;
                }
                // we have no else because if both the ordinal and guid
                // are the same there is nothing to do.
            }

            // if new guid is also in old...
            if( guidToOrdOld.find(newGuid)!=guidToOrdOld.end() )
            {
                long oldOrd=guidToOrdOld[newGuid];
                //...with a different ordinal we have a situation we are not
                // prepared to deal with for now
                if(oldOrd!=newOrd)
                {
                    error=  String::format
                    (
                        L"Error in locale %1!x!, object %2,"
                        L"property %3. Guid:%4 has different ordinals in "
                        L"new and old (ordinal=%5!d!) csv files.",
                        locale,
                        object.c_str(),
                        property.c_str(),
                        makeGuidString(newOrd,newGuid).c_str(),
                        oldOrd
                    );
                    break;


                }
                // we have no else because if both the ordinal and guid
                // are the same there is nothing to do.
            }
            else
            {
                if(!newGuidWasReplaced)
                {
                    hr=writeChange
                    (
                        fileOut,
                        locale,
                        object,
                        property,
                        makeGuidString(newOrd,newGuid),
                        "",
                        L"ADD_GUID",
                        guidNumber
                    );
                    BREAK_ON_FAILED_HRESULT(hr);
                }
            }
        }
        BREAK_ON_FAILED_HRESULT(hr);
        

        // Now let's check for guids only in the old
        csr=guidToOrdOld.begin(),endCsr=guidToOrdOld.end();
        for(;csr!=endCsr;csr++)
        {
            oldGuid=csr->first;
            oldOrd=csr->second;
            // if oldGuid is not in new and has not already been replaced
            if(
                guidToOrdNew.find(oldGuid)==guidToOrdNew.end() &&
                replacements.find(oldGuid)==replacements.end()
              )
            {
                hr=writeChange
                (
                    fileOut,
                    locale,
                    object,
                    property,
                    makeGuidString(oldOrd,oldGuid).c_str(),
                    L"",
                    L"REMOVE_GUID",
                    guidNumber
                );
                BREAK_ON_FAILED_HRESULT(hr);
            }
        }
        BREAK_ON_FAILED_HRESULT(hr);
    } while(0);

    return hr;
}


BOOL
MyIsNLSDefinedString
(
    const String& str,
    wchar_t *badChar
)
{
    BOOL ret=IsNLSDefinedString
    (
        COMPARE_STRING,
        0,
        NULL,
        str.c_str(),
        str.length()
    );
    if(ret==FALSE)
    {
        wchar_t s[2]={0};
        for(long t=0;t<str.length();t++)
        {
            s[0]=str[t];
            ret=IsNLSDefinedString(COMPARE_STRING,0,NULL,s,1);

            if(ret==FALSE)
            {
                *badChar=str[t];
                return FALSE;
            }
        }
        // Some character in the for must return before this point
        ASSERT(ret!=FALSE);
    }
    return TRUE;
}
HRESULT 
checkValues
(
    long locale,
    const String &object,
    const mapOfProperties &values
)
{
    HRESULT hr=S_OK;
    do
    {
        mapOfProperties::const_iterator csr,end;
        for(csr=values.begin(),end=values.end();csr!=end;csr++)
        {
            StringList::const_iterator csrVal=csr->second.begin();
            StringList::const_iterator endVal=csr->second.end();
            for(;csrVal!=endVal;csrVal++)
            {
                wchar_t badChar;
                if( MyIsNLSDefinedString(*csrVal,&badChar) == FALSE )
                {
                    String outStr=String::format
                    (
                        L"\nNon unicode char %1!x! in string:\"%2\" for "
                        L"locale %3!lx!, object %4 and property %5.\n",
                        badChar,
                        csrVal->c_str(),
                        locale,
                        object.c_str(),
                        csr->first.c_str()
                    );
                    
                    // We are ignoring the result returned here.
                    printStringAsAnsi(outStr);
                        
                    hr=E_FAIL;
                    break;
                }
            }
            BREAK_ON_FAILED_HRESULT(hr);
        }
        BREAK_ON_FAILED_HRESULT(hr);
    } while(0);
    
    hr=S_OK;
    // for now we always return true but we will make this
    // a critical error when this checking makes to the AD
    return hr;
}


// Reads synchronally csvOld and csvNew adding the necessary changes.
// Objects only in csvOld will cause failure
// For objects only in csvNew call addNewObject to add an ADD_OBJECT entry.
// For each common object betweem csvOld and csvNew:
// For each object property belonging to newProperties and with a non 
// empty value add call addAllCsvValues to add an ADD_CSV_VALUES entry.
// for each property in the object belonging to commonProperties
//      valuesOld = value of the property in oldCsv
//      valuesNew = value of the property in newCsv
//      if valuesNew and valuesOld are empty skip this value
//      if either first value of valuesNew or valuesOld ressembles a GUID
// call dealWithGuid to add ADD_GUID/REPLACE_GUID/DELETE_GUID as necessary and
// and skip to next.
//      if both valuesNew.size and valuesOld.size <= 1 call dealWithSingleValue
// to add REPLACE_SINGLE_VALUE as necessary and skip to next
//      dealWithMultipleValue to add REPLACE_MULTIPLE_VALUE as necessary and 
// skip to next.
HRESULT addChanges
(
    HANDLE                  fileOut,
    const CSVDSReader       &csvOld,
    const CSVDSReader       &csvNew,
    const mapOfPositions    &commonProperties,
    const mapOfPositions    &newProperties,
    int                     guidNumber,
    const wchar_t           *csvName
)
{
    HRESULT hr=S_OK;

    do
    {

        // Here we start readding both csv files
        hr=csvOld.initializeGetNext();
        BREAK_ON_FAILED_HRESULT(hr);
        hr=csvNew.initializeGetNext();
        BREAK_ON_FAILED_HRESULT(hr);

        // The loop bellow will sequentially read objects 
        // in both csv's making sure the same objects are read.
        bool flagEOF=false;
        do
        {
            mapOfProperties oldValues,newValues;
            long locOld=0,locNew=0;
            String objOld,objNew;

            hr=csvOld.getNextObject(locOld,objOld,oldValues);
            BREAK_ON_FAILED_HRESULT(hr);
            if(hr==S_FALSE) {flagEOF=true;hr=S_OK;}

            hr=checkValues(locOld,objOld,oldValues);
            BREAK_ON_FAILED_HRESULT(hr);

            hr=csvNew.getNextObject(locNew,objNew,newValues);
            BREAK_ON_FAILED_HRESULT(hr);

            // While we don't find the object from the old csv
            // in the new  csv we add entries for the new objects found
            while(hr!=S_FALSE && (locNew!=locOld || objNew!=objOld) )
            {
                hr= writeChange
                    (
                        fileOut,
                        locNew,
                        objNew,
                        L"",
                        L"",
                        L"",
                        L"ADD_OBJECT",
                        guidNumber
                    );

                BREAK_ON_FAILED_HRESULT(hr);

                hr=checkValues(locNew,objNew,newValues);
                BREAK_ON_FAILED_HRESULT(hr);

                hr=csvNew.getNextObject(locNew,objNew,newValues);
                BREAK_ON_FAILED_HRESULT(hr);
            } 

            BREAK_ON_FAILED_HRESULT(hr);
            
            if(hr==S_FALSE) {flagEOF=true;hr=S_OK;}

            hr=checkValues(locNew,objNew,newValues);
            BREAK_ON_FAILED_HRESULT(hr);

            // This means that we searched the whole new csv file and didn't 
            // find the object we've read from the old csv file.
            if(locNew!=locOld || objNew!=objOld)
            {
                error=String::format
                      ( 
                        L"Error:%1!d!,%2 was only in the old %3 csv file.",
                        locOld,objOld.c_str(),
                        csvName
                      );
                hr=E_FAIL;
                break;
            }
            
            // From this point on we know the object is 
            // the same in old and new csv files

            // This happens if we have a blank line at the end of the files
            if(locNew==0) break;

            // now let's check the differences in the common properties
            mapOfPositions::const_iterator cur=newProperties.begin();
            mapOfPositions::const_iterator end=newProperties.end();
            for(;cur!=end;cur++)
            {
                const String& property=cur->first;
                const StringList &valuesNew=newValues[property];
                if(!valuesNew.empty())
                {
                    // We only want to use ADD_ALL_CSV_VALUES if it 
                    // is not a guid. It will probably be the same as
                    // ADD_ALL_CSV_VALUES for most cases but it is 
                    // better policy to keep all guid additions
                    // with an ADD_GUID change.
                    if( isGuid(*valuesNew.begin()) )
                    {
                        // We know we don't have old values because this is a 
                        // new property
                        StringList emptyValues;
                        hr= dealWithGuids
                        (
                            fileOut,
                            locNew,
                            objNew,
                            property,
                            emptyValues,
                            valuesNew,
                            guidNumber
                        );
                        BREAK_ON_FAILED_HRESULT(hr);
                    }
                    else
                    {
                        hr= writeChange
                            (
                                fileOut,
                                locNew,
                                objNew,
                                property,
                                L"",
                                L"",
                                L"ADD_ALL_CSV_VALUES",
                                guidNumber
                            );
                        BREAK_ON_FAILED_HRESULT(hr);
                    }
                }
                
            }
            BREAK_ON_FAILED_HRESULT(hr);

            // now let's check the differences in the common properties
            cur=commonProperties.begin();
            end=commonProperties.end();
            for(;cur!=end;cur++)
            {
                const String& property=cur->first;
                const StringList &valuesOld=oldValues[property];
                const StringList &valuesNew=newValues[property];
                
                if (valuesOld.empty() && valuesNew.empty()) continue;
                
                // The or bellows means either value being guid we want
                // to deal with them in dealWithGuids. Inside it, all non
                // guids would trigger an error.
                if ( 
                        ( !valuesOld.empty() && isGuid(*valuesOld.begin()) ) ||
                        ( !valuesNew.empty() && isGuid(*valuesNew.begin()) )
                   ) 
                {
                    hr= dealWithGuids
                        (
                            fileOut,
                            locNew,
                            objNew,
                            property,
                            valuesOld,
                            valuesNew,
                            guidNumber
                        );
                    BREAK_ON_FAILED_HRESULT(hr);
                    continue;
                }
                // Now we know that we don't have a guid change

                if(valuesNew.size()<=1 && valuesOld.size()<=1)
                {
                    hr= dealWithSingleValue
                        (
                            fileOut,
                            locNew,
                            objNew,
                            property,
                            valuesOld,
                            valuesNew,
                            guidNumber
                        );
                    BREAK_ON_FAILED_HRESULT(hr);
                    continue;
                }
                // Now we know that we don't have GUIDS or single values

                hr= dealWithMultipleValue
                    (
                        fileOut,
                        locNew,
                        objNew,
                        property,
                        valuesOld,
                        valuesNew,
                        guidNumber
                    );
                BREAK_ON_FAILED_HRESULT(hr);
            }
            BREAK_ON_FAILED_HRESULT(hr);

        } while (flagEOF==false);
        BREAK_ON_FAILED_HRESULT(hr);

    } while(0);

    return hr;
}

// Writes the whole SetChanges function with the locales 
// from dcpromo and 409.
// Calls writeChangesHeader and then addChanges twice, one
// for each csv pair. Finally, calls FS::Write(fileOut,L"\n}");.
HRESULT addAllChanges
(
    HANDLE                  fileOut,
    const CSVDSReader       &oldDcpromo,
    const CSVDSReader       &newDcpromo,
    const CSVDSReader       &old409,
    const CSVDSReader       &new409,
    const mapOfPositions    &commonProperties,
    const mapOfPositions    &newProperties,
    int                     guidNumber
)
{
    HRESULT hr=S_OK;
    do
    {
        hr=writeChangesHeader(fileOut,guidNumber);
        BREAK_ON_FAILED_HRESULT(hr);

        hr=addChanges
           (
                fileOut,
                old409,
                new409,
                commonProperties,
                newProperties,
                guidNumber,
                L"409"
           );
        BREAK_ON_FAILED_HRESULT(hr);        
        
        hr=addChanges
           (
               fileOut,
               oldDcpromo,
               newDcpromo,
               commonProperties,
               newProperties,
               guidNumber,
               L"dcpromo"
           );
        BREAK_ON_FAILED_HRESULT(hr);


        
        hr =  writeStringAsAnsi(fileOut,L"\r\n}");
        BREAK_ON_FAILED_HRESULT(hr);
    } while(0);

    return hr;
}



// writes setChangesNNN.cpp. Sets up by caling getAllPropertyChanges, calls
// writeHeader and then addAllChanges
// Creates the CSVReader objects corresponding to the 4 first parameters
// to pass to writeGlobalChanges and writeGlobalChanges.
// guidNumber is repassed to addAllChanges
HRESULT writeChanges
(
    const String &oldDcpromoName,
    const String &newDcpromoName,
    const String &old409Name,
    const String &new409Name,
    const String &changesCpp,
    int   guidNumber
)
{
    HRESULT hr=S_OK;
    HANDLE fChanges = INVALID_HANDLE_VALUE;

    hr=FS::CreateFile
    (
        changesCpp.c_str(),
        fChanges,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        CREATE_ALWAYS
    );


    do
    {

        if (FAILED(hr))
        {
            wprintf(L"Could not create changes file: %s.",changesCpp.c_str());
            break;
        }

        do
        {
            CSVDSReader oldDcpromo;
            hr=oldDcpromo.read(oldDcpromoName.c_str(),LOCALEIDS);
            BREAK_ON_FAILED_HRESULT(hr);

            CSVDSReader newDcpromo;
            hr=newDcpromo.read(newDcpromoName.c_str(),LOCALEIDS);
            BREAK_ON_FAILED_HRESULT(hr);

            CSVDSReader old409;
            hr=old409.read(old409Name.c_str(),LOCALE409);
            BREAK_ON_FAILED_HRESULT(hr);

            CSVDSReader new409;
            hr=new409.read(new409Name.c_str(),LOCALE409);
            BREAK_ON_FAILED_HRESULT(hr);

            mapOfPositions commonProperties,newProperties;
            hr=getAllPropertyChanges
               (
                    oldDcpromo,
                    newDcpromo,
                    old409,
                    new409,
                    commonProperties,
                    newProperties
               );
            BREAK_ON_FAILED_HRESULT(hr);

            hr=writeHeader(fChanges);
            BREAK_ON_FAILED_HRESULT(hr);

            hr=addAllChanges
               (
                    fChanges,
                    oldDcpromo,
                    newDcpromo,
                    old409,
                    new409,
                    commonProperties,
                    newProperties,
                    guidNumber
               );
            BREAK_ON_FAILED_HRESULT(hr);


        } while(0);

        CloseHandle(fChanges);
    } while(0);
    
    return hr;
}

HRESULT writeGuid(HANDLE fOut,const GUID &guid)
{
    return
    (
        writeStringAsAnsi
        (
            fOut,
            String::format
            (
                "   {0x%1!x!,0x%2!x!,0x%3!x!,{0x%4!x!,0x%5!x!,0x%6!x!,"
                "0x%7!x!,0x%8!x!,0x%9!x!,0x%10!x!,0x%11!x!}},\r\n",
                guid.Data1,guid.Data2,guid.Data3,
                guid.Data4[0],guid.Data4[1],guid.Data4[2],guid.Data4[3],
                guid.Data4[4],guid.Data4[5],guid.Data4[6],guid.Data4[7]
            ).c_str()
        )
    );
}

HRESULT writeGuids(const String& guidsInc,const GUID &newGuid)
{
    HRESULT hr=S_OK;
    HANDLE fOut= INVALID_HANDLE_VALUE;

    hr=FS::CreateFile
    (
        guidsInc.c_str(),
        fOut,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        CREATE_ALWAYS
    );


    do
    {

        if (FAILED(hr))
        {
            wprintf(L"Could not create changes file: %s.",guidsInc.c_str());
            break;
        }

        do
        {
            int sizeGuids=sizeof(guids)/sizeof(*guids);
            hr=FS::Write
               (    
                    fOut,
                    AnsiString
                    (
                        "// This file is generated by preBuild.exe\r\n"
                        "// Copyright (c) 2001 Microsoft Corporation\r\n"
                        "// Nov 2001 lucios\r\n\r\n\r\n"
                        "GUID guids[]=\r\n"
                        "{\r\n"
                    )
               );
            BREAK_ON_FAILED_HRESULT(hr);

            for(int ix=0;ix<sizeGuids;ix++)
            {
                hr=writeGuid(fOut,guids[ix]);
                BREAK_ON_FAILED_HRESULT(hr);
            }
            BREAK_ON_FAILED_HRESULT(hr);
            
            hr=writeGuid(fOut,newGuid);
            BREAK_ON_FAILED_HRESULT(hr);
            
            hr=FS::Write(fOut,AnsiString("};\r\n"));
            BREAK_ON_FAILED_HRESULT(hr);
        } while(0);
        CloseHandle(fOut);
        BREAK_ON_FAILED_HRESULT(hr);
    } while(0);
    return hr;
}

HRESULT writeSetChanges(const String& setChanges)
{
    HRESULT hr=S_OK;
    HANDLE fOut= INVALID_HANDLE_VALUE;

    hr=FS::CreateFile
    (
        setChanges.c_str(),
        fOut,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        CREATE_ALWAYS
    );


    do
    {

        if (FAILED(hr))
        {
            wprintf(L"Could not create setChanges file: %s.",setChanges.c_str());
            break;
        }

        do
        {
            int sizeGuids=sizeof(guids)/sizeof(*guids);
            hr=FS::Write
               (    
                    fOut,
                    AnsiString
                    (
                        "// This file is generated by preBuild.exe\r\n"
                        "// Copyright (c) 2001 Microsoft Corporation\r\n"
                        "// Nov 2001 lucios\r\n\r\n\n"
                        "#include \"headers.hxx\"\r\n\r\n"
                    )
               );
            BREAK_ON_FAILED_HRESULT(hr);

            for(int ix=0;ix<sizeGuids+1;ix++)
            {
                hr=writeStringAsAnsi
                    (
                        fOut,
                        String::format("void setChanges%1!d!();\r\n",ix)
                    );
                BREAK_ON_FAILED_HRESULT(hr);
            }
            BREAK_ON_FAILED_HRESULT(hr);
            
            hr=FS::Write(fOut,AnsiString("\nvoid setChanges()\r\n{\r\n"));
            BREAK_ON_FAILED_HRESULT(hr);

            for(int ix=0;ix<sizeGuids+1;ix++)
            {
                hr=writeStringAsAnsi
                   (
                        fOut,
                        String::format("    setChanges%1!d!();\r\n",ix)
                   );
            }
            BREAK_ON_FAILED_HRESULT(hr);

            hr=FS::Write(fOut,AnsiString("}\r\n"));
            BREAK_ON_FAILED_HRESULT(hr);

        } while(0);
        CloseHandle(fOut);
        BREAK_ON_FAILED_HRESULT(hr);
    } while(0);
    return hr;
}

HRESULT writeSources(const String& sources,const String& changesCpp)
{
    HRESULT hr=S_OK;
    
    AnsiString ansiStr;
    String::ConvertResult res=changesCpp.convert(ansiStr);
    if(res!=String::CONVERT_SUCCESSFUL)
    {
        ASSERT(res==String::CONVERT_SUCCESSFUL);
        error=L"Ansi conversion failed";
        return E_FAIL;
    }
    FILE *fOut=_wfopen(sources.c_str(),L"a+");

    do
    {
        if (fOut==NULL)
        {
            wprintf(L"Could not create sources file: %s.",sources.c_str());
            break;
        }

        do
        {
            
            fprintf(fOut,"    %s         \\\r\n" ,ansiStr.c_str());
            BREAK_ON_FAILED_HRESULT(hr);
        } while(0);
        fclose(fOut);
        BREAK_ON_FAILED_HRESULT(hr);
    } while(0);
    return hr;
}

///////////////////////////////////////////////////
// entry point
void __cdecl wmain(int argc,wchar_t *argv[])
{
    HRESULT hr=S_OK;
    do
    {
        if(argc!=7)
        {
            error=L"\nThis program generates a new set of changes to be "
                L"used in dcpromo.lib by comparing the new and previous"
                L" csv files. Usage:\n\n\"preBuild.exe GUID oldDcpromo "
                L"newDcpromo old409 new409 targetFolder\"\n\n"
                L"GUID is the identifier for this set of changes, for example:\n"
                L"8B53221B-EA3C-4638-8D00-7C1BE42B2873\n\n"
                L"oldDcpromo is the previous dcpromo.csv\n"
                L"newDcpromo is the new dcpromo.csv\n"
                L"old409 is the previous 409.csv\n"
                L"new409 is the new 409.csv\n\n"
                L"targetFolder is the sources file for dcpromo.lib,"
                L" where guids.inc,setChanges.cpp, and " 
                L"changes.NNN.cpp will be generated and where the sources "
                L"file for the display specifier upgrade library is. "
                L"An entry like: \"changes.NNN.cpp    \\\" will be added "
                L"at the end of targetFolder\\sources.\n\n";
            hr=E_FAIL;
            break;
        }
    
    
        String guidStr=argv[1],oldDcpromo=argv[2],newDcpromo=argv[3],old409=argv[4];
        String new409=argv[5],targetFolder=argv[6];
        String sources=targetFolder + L"\\sources";
        String guidsInc=targetFolder + L"\\guids.inc";
        String setChanges=targetFolder + L"\\setChanges.cpp";
    
        GUID guid={0};
    
        if(UuidFromString((wchar_t*)guidStr.c_str(),&guid)!=RPC_S_OK)
        {
            error=String::format(L"\n Invalid GUID:%s.\n",guidStr.c_str());
            break;
        }
    
        BREAK_IF_MISSING(hr,oldDcpromo);
        BREAK_IF_MISSING(hr,newDcpromo);
        BREAK_IF_MISSING(hr,old409);
        BREAK_IF_MISSING(hr,new409);
        BREAK_IF_MISSING_OR_READONLY(hr,guidsInc);
        BREAK_IF_MISSING_OR_READONLY(hr,sources);
        BREAK_IF_MISSING_OR_READONLY(hr,setChanges);

        int sizeGuids=sizeof(guids)/sizeof(*guids);
        for(int t=0;t<sizeGuids;t++)
        {
            if (guids[t]==guid)
            {
                hr=E_FAIL;
                error=String::format("The guid you entered (%s) is already present\n");
                break;
            }
            String shouldExist = targetFolder + 
                String::format(L"\\changes%1!03d!.cpp",t);
            BREAK_IF_MISSING(hr,shouldExist);
        }
        BREAK_ON_FAILED_HRESULT(hr);

        String changesCppOnly =  String::format(L"changes%1!03d!.cpp",t);
        String changesCpp = targetFolder + L"\\" + changesCppOnly;

        if( fileExists(changesCpp.c_str()) )
        {
            hr=E_FAIL;
            error=String::format(L"Change file already exists: %1.",changesCpp.c_str());
            break;
        }
        hr=writeChanges
           (
                oldDcpromo,
                newDcpromo,
                old409,
                new409,
                changesCpp,
                sizeGuids
           );

        hr=writeGuids(guidsInc,guid);
        BREAK_ON_FAILED_HRESULT(hr);

        hr=writeSetChanges(setChanges);
        BREAK_ON_FAILED_HRESULT(hr);

        hr=writeSources(sources,changesCppOnly);
        BREAK_ON_FAILED_HRESULT(hr);


    } while(0);

    if(FAILED(hr)) wprintf(L"\nFailure code: %lx\n",hr);
    else wprintf(L"\nSuccess. Don't forget to bcz this project and targetFolder.\n");
    if(!error.empty()) wprintf(String::format("\n%1\n",error.c_str()).c_str());
}

///////////////////////////////////////////////////////////////////
// Function: cchLoadHrMsg
//
// Given an HRESULT error,
// it loads the string for the error. It returns the # of characters returned
int cchLoadHrMsg( HRESULT hr, String &message )
{
   if(hr == S_OK) return 0;

   wchar_t *msgPtr = NULL;

   // Try from the system table
   int cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                           NULL, 
                           hr,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)&msgPtr, 
                           0, 
                           NULL);


   if (!cch) 
   { 
      //try ads errors
      static HMODULE g_adsMod = 0;
      if (0 == g_adsMod)
      {
      g_adsMod = GetModuleHandle (L"activeds.dll");
      }

      cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, 
                        g_adsMod, 
                        hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPWSTR)&msgPtr, 
                        0, 
                        NULL);
   }

   if (!cch)
   {
      // Try NTSTATUS error codes

      hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(hr));

      cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                           NULL, 
                           hr,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)&msgPtr, 
                           0, 
                           NULL);
   }

   message.erase();

   if(cch!=0)
   {
      if(msgPtr==NULL) 
      {
         cch=0;
      }
      else
      {
         message=msgPtr;
         ::LocalFree(msgPtr);
      } 
   } 
   
   return cch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\prebuild\w2kreplacements.cpp ===
#include "headers.hxx"
#include "..\CSVDSReader.hpp"
#include "..\constants.hpp"
#include "..\global.hpp"
#include <winnls.h>



String escape(const wchar_t *str)
{
   LOG_FUNCTION(escape);
   String dest;
   wchar_t strNum[5];

   while(*str!=0)
   {
      wsprintf(strNum,L"\\x%x",*str);
      dest+=String(strNum);
      str++;
   }
   return dest;
}



String issues;

bool
isPropertyInChangeList
(
   String, //property,
   const objectChanges &//changes
)
{
   /*objectChanges::const_iterator begin,end;
   begin=changes.begin();
   end=changes.end();
   while(begin!=end)
   {
      changeList::const_iterator beginChanges,endChanges;
      beginChanges=begin->second.begin();
      endChanges=begin->second.end();
      while(beginChanges!=endChanges)
      {
         if (property.icompare(beginChanges->property)==0) return true;
         beginChanges++;
      }
      begin++;
   }*/
   return false;
}

bool
isObjectPropertyInChangeList
(
   String object,
   String property,
   const objectChanges &changes
)
{
   objectChanges::const_iterator begin,end;
   begin=changes.begin();
   end=changes.end();
   while(begin!=end)
   {
      changeList::const_iterator beginChanges,endChanges;
      beginChanges=begin->second.begin();
      endChanges=begin->second.end();
      while(beginChanges!=endChanges)
      {
         if (
               property.icompare(beginChanges->property)==0 &&
               object.icompare(beginChanges->object)==0
            ) 
         {
            return true;
         }
         beginChanges++;
      }
      begin++;
   }
   return false;
}



HRESULT
getCommonProperties
(
   const mapOfPositions& pp1,
   const mapOfPositions& pp2,
   StringList &commonProperties
)
{
   LOG_FUNCTION(getCommonProperties);

   HRESULT hr=S_OK;
   do
   {

      if(pp1.size()!=0)
      {
         mapOfPositions::const_iterator begin=pp1.begin(),end=pp1.end();
         while(begin!=end)
         {
            if(pp2.find(begin->first)==pp2.end())
            {
               error=L"The property:" + begin->first +
                     L" was found only in Old. \r\n" +
                     L"This program does not take into account" +
                     L" the removal of properties from Old to New.\r\n"
                     L"You should pass the Old csv file as the"
                     L" first command line argument.";

               hr=E_FAIL;
               break;
            }
            begin++;
         }
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if(pp2.size()!=0)
      {
         mapOfPositions::const_iterator begin=pp2.begin(),end=pp2.end();
         while(begin!=end)
         {
            if(pp1.find(begin->first)==pp1.end())
            {
			   //bugbug - No Longer possible
               /*if (!isPropertyInChangeList(begin->first,changes))
               {
                  issues +=
                     L"The property:" + begin->first +
                     L" was found only in New but is not a global" 
                     L" change. \r\nThis program does not generate entries" 
                     L" for properties only in New.\r\n\r\n\r\n";
               }*/
            }
            else
            {
               commonProperties.push_back(begin->first);
            }
            begin++;
         }
         BREAK_ON_FAILED_HRESULT(hr);
      }
   } while (0);

   return hr;
}



HRESULT
addReplace
(
   const enum TYPE_OF_CHANGE  type,
   const long                 locale,
   const String               &object,
   const String               &property,
   const String               &valueOld,
   const String               &valueNew,
   const HANDLE               fileOut
)
{
   LOG_FUNCTION(addReplace);
   ASSERT(
            type==REPLACE_W2K_MULTIPLE_VALUE || 
            type==REPLACE_W2K_SINGLE_VALUE
         );

   
   HRESULT hr=S_OK;

   do
   {
      String entry;
      entry=String::format
            (
                 L"\r\n"
                 L"\r\n"
                 L"   addChange\r\n"
                 L"   (\r\n"
                 L"      0x%1!x!,\r\n"
                 L"      L\"%2\",\r\n"
                 L"      L\"%3\",\r\n"
                 L"      //%4 \r\n"
                 L"      L\"%5\",\r\n"
                 L"      //%6 \r\n"
                 L"      L\"%7\",\r\n"
                 L"      %8\r\n"
                 L"   );",
                 locale,                              //1
                 object.c_str(),                      //2
                 property.c_str(),                    //3
                 valueOld.c_str(),                    //4
                 escape(valueOld.c_str()).c_str(),    //5
                 valueNew.c_str(),                     //6
                 escape(valueNew.c_str()).c_str(),     //7
                 (type==REPLACE_W2K_SINGLE_VALUE) ?   //8
                  L"REPLACE_Old_SINGLE_VALUE":
                  L"REPLACE_Old_MULTIPLE_VALUE"
            );

      

      AnsiString ansiEntry;
      String::ConvertResult res=entry.convert(ansiEntry);
      if(res!=String::CONVERT_SUCCESSFUL)
      {
            error=L"Ansi conversion failure";
            hr=E_FAIL;
            break;
      }

      hr = FS::Write(fileOut,ansiEntry);
   } while(0);
   return hr;
}


bool
findI
(
   const StringList &list,
   const String &value
)
{
   LOG_FUNCTION(findI);
   for
   (
      StringList::const_iterator current=list.begin(),end=list.end();
      current!=end;
      current++
   )
   {
      //if(current->icompare(value)==0)
      if(*current==value)
      {
         return true;
      }
   }
   return false;
}

bool
findIPartial
(
   const StringList &list,
   const String &value,
   String &valueFound
)
{
   LOG_FUNCTION(findIPartial);
   for
   (
      StringList::const_iterator current=list.begin(),end=list.end();
      current!=end;
      current++
   )
   {
      if(value.size()<=current->size())
      {
         //if(value.icompare( current->substr(0,value.size()) )==0)
         if( value == current->substr(0,value.size()) )
         {
            valueFound=*current;
            return true;
         }
      }
   }
   return false;
}



HRESULT
dealWithMultipleValues
(
   const long locale,
   const String& object,
   const String& property,
   const StringList &valuesNew,
   const StringList &valuesOld,
   const HANDLE fileOut
)
{
   LOG_FUNCTION(dealWithMultipleValues);

   StringList::const_iterator bgOld=valuesOld.begin();
   StringList::const_iterator endOld=valuesOld.end();
   HRESULT hr=S_OK;
   do
   {
      while(bgOld!=endOld)
      {
         if (!findI(valuesNew,*bgOld))
         {
            // The value was not found in New
            // The beginning of the value should be found

            String beforeComma,valueFound;
            size_t pos=bgOld->find(L',');
            if(pos==String::npos || pos==0)
            {
               error=String::format
                     (
                        L"(%1!x!,%2,%3) should have comma after 1st position",
                        locale,
                        object.c_str(),
                        property.c_str()
                     );
               hr=E_FAIL;
               break;
            }
            // pos+1 will include the comma
            beforeComma=bgOld->substr(0,pos+1);

            if(
                  beforeComma.icompare(L"cn,")==0 && 
                  object.icompare(L"domainDNS-Display")==0 && 
                  property.icompare(L"attributeDisplayNames")==0
              )
            {
            // We are opening this exception since
            // this is the only value that had its beforeComma
            // part changed.
               beforeComma=L"dc,";
            }

            if(!findIPartial(valuesNew,beforeComma,valueFound))
            {
               error=String::format
                     (
                        L"(%1!x!,%2,%3) Value %4 is not in New",
                        locale,
                        object.c_str(),
                        property.c_str(),
                        beforeComma.c_str()
                     );
               hr=E_FAIL;
               break;
            }
            hr=addReplace
            (
               REPLACE_W2K_MULTIPLE_VALUE,
               locale,
               object.c_str(),
               property.c_str(),
               *bgOld,
               valueFound,
               fileOut
            );
            BREAK_ON_FAILED_HRESULT(hr);
         }
         bgOld++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   } while(0);

   return hr;

}


// the function bellow is auxiliary in testing
// how well csvreader performs its tasks of 
// reading properties. It dumps csvName to fileOut
HRESULT
dumpCsv
(
    const String &csvName,
    const long *locales,
    const HANDLE fileOut
)
{
   LOG_FUNCTION(dumpCsv);
   HRESULT hr=S_OK;

   do
   {
      CSVDSReader csv;
      hr=csv.read(csvName.c_str(),locales);
      BREAK_ON_FAILED_HRESULT(hr);

      const mapOfPositions& pp1=csv.getProperties();

      // First we dump all the properties
      mapOfPositions::iterator begin=pp1.begin();
      mapOfPositions::iterator end=pp1.end();
      mapOfProperties prop;
      StringList emptyList;
      while(begin!=end)
      {
         hr=FS::Write(fileOut,begin->first);
         BREAK_ON_FAILED_HRESULT(hr);
         hr=FS::Write(fileOut,L",");
         BREAK_ON_FAILED_HRESULT(hr);
         prop[begin->first]=emptyList;
         begin++;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   
      hr=FS::Write(fileOut,L"\r\n");
      BREAK_ON_FAILED_HRESULT(hr);

      bool flagEOF=false;

      // Now we will enumerate all csv lines
      hr=csv.initializeGetNext();
      BREAK_ON_FAILED_HRESULT(hr);

      do
      {

         long loc;
         String obj;
   
         hr=csv.getNextObject(loc,obj,prop);
         BREAK_ON_FAILED_HRESULT(hr);

         if(hr==S_FALSE) flagEOF=true;
         if(loc==0) continue;

         // now we enumerate each Value set from a property
         mapOfProperties::iterator begin=prop.begin();
         mapOfProperties::iterator end=prop.end();
         mapOfProperties::iterator last=prop.end();
         last--;
         
         while(begin!=end)
         {

            if(begin->second.size()!=0)
            {
               StringList::iterator curValue=begin->second.begin();
               StringList::iterator endValue=begin->second.end();
               StringList::iterator lastValue=endValue;
               lastValue--;

               if( 
                     begin->second.size()>1 || 
                     begin->second.begin()->find(L',')!=String::npos
                 )
               {
                  hr=FS::Write(fileOut,L"\"");
                  BREAK_ON_FAILED_HRESULT(hr);   
               }

               while(curValue!=endValue)
               {

                  hr=FS::Write(fileOut,*curValue);
                  BREAK_ON_FAILED_HRESULT(hr);


                  if(curValue!=lastValue)
                  {
                     hr=FS::Write(fileOut,L";");
                     BREAK_ON_FAILED_HRESULT(hr);   
                  }
                  
               
                  curValue++;
               }
               BREAK_ON_FAILED_HRESULT(hr);

               if( 
                     begin->second.size()>1 || 
                     begin->second.begin()->find(L',')!=String::npos
                 )
               {
                  hr=FS::Write(fileOut,L"\"");
                  BREAK_ON_FAILED_HRESULT(hr);
               }

            }

            if(begin!=last)
            {
               hr=FS::Write(fileOut,L",");
               BREAK_ON_FAILED_HRESULT(hr);
            }

            begin++;
         }
         BREAK_ON_FAILED_HRESULT(hr);

         hr=FS::Write(fileOut,L"\r\n");
         BREAK_ON_FAILED_HRESULT(hr);
   
      } while(!flagEOF);

   } while(0);

   return hr;

}


// Compare the Old and New csv files to check for
// differences in their common properties that will generate
// REPLACE_Old entries in fileOut. locales has the set of locales
// expected to be present in both the csv files.
HRESULT
generateChanges
(
   const String &csvOldName,
   const String &csvNewName,
   const long *locales,
   const HANDLE fileOut
)
{
   LOG_FUNCTION(generateChanges);
   HRESULT hr=S_OK;

   // bugbug No Longer Necessary
   // Let's add the new objects in a StringList
   // to later use findI to skip csv lines with
   // new objects
   StringList newNewObjects;
   for(long t=0;*NEW_WHISTLER_OBJECTS[t]!=0;t++)
   {
      newNewObjects.push_back(NEW_WHISTLER_OBJECTS[t]);
   }


   do
   {
      CSVDSReader csvOld;
      hr=csvOld.read(csvOldName.c_str(),locales);
      BREAK_ON_FAILED_HRESULT(hr);

      CSVDSReader csvNew;
      hr=csvNew.read(csvNewName.c_str(),locales);
      BREAK_ON_FAILED_HRESULT(hr);

      // Now we get the common properties as a StringList

      const mapOfPositions& pp1=csvOld.getProperties();
      const mapOfPositions& pp2=csvNew.getProperties();
      
      StringList commonProperties;

	  // bugbug. Get uncommon too and write them as 
	  // global ADD_ALL_CSV_VALUES changes
      hr=getCommonProperties
         (
            pp1,
            pp2,
            commonProperties
         );
      BREAK_ON_FAILED_HRESULT(hr);

      
      // Here we start readding both csv files
      hr=csvOld.initializeGetNext();
      BREAK_ON_FAILED_HRESULT(hr);
      hr=csvNew.initializeGetNext();
      BREAK_ON_FAILED_HRESULT(hr);

      // The loop bellow will sequentially read objects 
      // in both csv's making sure the same objects are read.
      bool flagEOF=false;
      do
      {
         mapOfProperties propOld,propNew;
         long locOld,locNew;
         String objOld,objNew;
         
         hr=csvOld.getNextObject(locOld,objOld,propOld);
         if(objOld==L"remoteStorageServicePoint-Display")
         {
            flagEOF=flagEOF;
         }
         LOG(locOld);
         LOG(objOld);
         BREAK_ON_FAILED_HRESULT(hr);
         if(hr==S_FALSE) flagEOF=true;
         
         // The loop bellow skips csv lines with new objects.
         do
         {
			//bugbug instead of skipping add locale dependent NEW_OBJECT
			//changes. It will require no parameters since it will use
			//the latest csv. The loop goes untill the objects are the same
			//or the new has ended. If the old has ended, clear its object 
			// to go on with the new
            hr=csvNew.getNextObject(locNew,objNew,propNew);
            BREAK_ON_FAILED_HRESULT(hr);
         } while(hr!=S_FALSE && findI(newNewObjects,objNew));
		 
		 //bugbug if the new has ended

         BREAK_ON_FAILED_HRESULT(hr);
         if(hr==S_FALSE) flagEOF=true;

         if(locNew==0 && locOld==0) continue; 
         // This means blank lines on both csvs. 
         // Blank lines would be common only in the end of
         // the file, but I don't care for them in the middle as long as they are
         // in the same number in both the New and Old csvs.
         // If we have blank lines in only one of the files, the if 
         // bellow will flag it as any other assynchronous result


         if( (objOld != objNew) || (locOld != locNew) )
         {
            error=String::format
                  (
                     "(%1,%2!x!) should be the same as (%3,%4!x!).",
                     objOld.c_str(),
                     locOld,
                     objNew.c_str(),
                     locNew
                  );
            hr=E_FAIL;
            break;
         }


         // now let's check the differences in the common properties
         StringList::iterator curCommon=commonProperties.begin();
         StringList::iterator endCommon=commonProperties.end();
         for(;curCommon!=endCommon;curCommon++)
         {
            //bugbug no longer possible
			/*
            if (isObjectPropertyInChangeList(objOld,*curCommon,changes) )
            {  // It is already taken care of by a global change
               continue;
            }*/

            const StringList &valuesOld=propOld[*curCommon];
            const StringList &valuesNew=propNew[*curCommon];

            long Oldlen=valuesOld.size();
            long Newlen=valuesNew.size();

            if (Oldlen!=Newlen)
            {
               error=String::format
                     (
                        L"(%1!x!,%2,%3) should have the same Old(%4!d!) "
                        L"and New(%5!d!) number of values",
                        locOld,
                        objOld.c_str(),
                        curCommon->c_str(),
                        Oldlen,
                        Newlen
                     );
               hr=E_FAIL;
               break;
            }

            if(Oldlen==1) // and, therefore, Newlen==1
            {
               if( valuesNew.begin()->icompare(*valuesOld.begin()) != 0 )
               {
                  hr=addReplace
                  (
                     REPLACE_W2K_SINGLE_VALUE,
                     locOld,
                     objOld.c_str(),
                     curCommon->c_str(),
                     *valuesOld.begin(),
                     *valuesNew.begin(),
                     fileOut
                  );
                  BREAK_ON_FAILED_HRESULT(hr);
               }
            }
            else if(Oldlen > 1)
            {
               hr=dealWithMultipleValues
                  (
                     locOld,
                     objOld.c_str(),
                     curCommon->c_str(),
                     valuesNew,
                     valuesOld,
                     fileOut
                  );
               BREAK_ON_FAILED_HRESULT(hr);
            } // else both are 0 and replacements are not needed
         }
         BREAK_ON_FAILED_HRESULT(hr);
      } while(!flagEOF);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while(0);
   return hr;
}

void chk()
{

	HRESULT hr=S_OK;
	HANDLE file=NULL;
	String errors;

	do
	{

		hr=FS::CreateFile("c:\\public\\dcpromoOld.csv",
				   file,
				   GENERIC_READ);
		if(FAILED(hr)) break;

		int countLine=0;

		bool flagEof=false;
		while(!flagEof)
		{
			String line;
			hr=ReadLine(file,line);
			if(hr==EOF_HRESULT)
			{
				hr=S_OK;
				flagEof=true;
			}

			if(line.empty()) continue;

			if(IsNLSDefinedString(COMPARE_STRING,0,NULL,line.c_str(),line.length())==FALSE)
			{
				errors+=String::format(L"line:%1!d! ", countLine+1);
				wchar_t str[2];
				str[1]=0;
				
				for(int countColumn=0;countColumn<line.length();countColumn++)
				{
					str[0]=line[countColumn];
					if(IsNLSDefinedString(COMPARE_STRING,0,NULL,str,wcslen(str))==FALSE)
					{
						errors+=String::format(L"(0x%1!x! at %2!d!)",str[0],countColumn+1);
					}
				}
				errors+=L".\n";
			}
			countLine++;

		}
	}
	while(0);

    if(file!=NULL) CloseHandle(file);
	MessageBox(NULL,errors.c_str(),L"errors",MB_OK);

}

#include <rpcdce.h>


void printGUID(const GUID& g)
{
	printf("{%x,%x,%x,{%x,%x,%x,%x,%x,%x,%x,%x}}\n",g.Data1,g.Data2,g.Data3,
		g.Data4[0],g.Data4[1],g.Data4[2],g.Data4[3],g.Data4[4],g.Data4[5],
		g.Data4[6],g.Data4[7]);
	wchar_t *str;
	if(UuidToString((UUID*)&g,&str)==RPC_S_OK)
	{
		wprintf(L" %s\n\n",str);
		RpcStringFree(&str);
	}
}

void __cdecl main( void )
{
   GUID g1={0,0,1,0,1,2,3,4,5,6,7};
   printGUID(g1);
   if(UuidFromString(L"baddb31b-b428-4103-ae78-3bba5541a20d",&g1)==RPC_S_OK)
   {
		printGUID(g1);
   }
   else
   {
	   printf("UUID string is not valid");
   }
}

/*
void __cdecl main(int argc,char *argv[])
{
	if(argc!=7)
	{
		printf("\nThis program generates a new set of changes to be "
			   "used in dcpromo.lib by comparing the new and previous"
			   " csv files. Usage:\n\n\"preBuild.exe GUID oldDcpromo "
			   "newDcpromo old409 new409 targetFolder\"\n\n"
			   "GUID is the identifier for this set of changes, for example:\n"
			   "{0x4444C516,0xF43A,0x4c12,0x9C,0x4B,0xB5,0xC0,0x64,0x94,"
			   "0x1D,0x61}\n\n"
			   "oldDcpromo is the previous dcpromo.csv\n"
			   "newDcpromo is the new dcpromo.csv\n"
			   "old409 is the previous 409.csv\n"
			   "new409 is the new 409.csv\n\n"
			   "targetFolder is the sources file for dcpromo.lib,"
			   " where guids.cpp, and " 
			   "changes.NNN.cpp will be generated and where the sources "
			   "file for the display specifier upgrade library is. "
			   "An entry like: \"changes.NNN.cpp	\\\" will be added "
			   "at the end targetFolder\\sources.\n\n");

	}
	else printf(argv[1]);
}
*/

/*

int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE,  //hPrevInstance
   LPSTR,      //lpszCmdLine
   int         //nCmdShow
)
{
   LOG_FUNCTION(WinMain);
   chk();
   return 0;

   hResourceModuleHandle=hInstance;
   
   int argv;
   LPWSTR *argc=CommandLineToArgvW(GetCommandLine(),&argv);

   String usage;
   usage =  L"Usage: OldRepl folder outputFile\r\n"
            L"Example: obj\\i386\\OldRepl .\\ ..\\setReplacements.cpp\r\n"
            L"folder must have four files: \r\n"
            L"    win2k.dcpromo.csv\r\n"
            L"    whistler.dcpromo.csv\r\n"
            L"    win2k.409.csv\r\n"
            L"    whistler.409.csv\r\n"
            L" Don't forget to checkout the output file if\r\n"
            L" it is under source control.\r\n";


   if(argv!=3)
   {
      MessageBox(NULL,usage.c_str(),L"Two arguments required.",MB_OK);
      return 0;
   }

   
   String path = FS::NormalizePath(argc[1]);
   String outFileName = FS::NormalizePath(argc[2]);
   String dcpromoNew = path+L"whistler.dcpromo.csv";
   String dcpromoOld = path+L"win2k.dcpromo.csv";
   String csv409New = path+L"whistler.409.csv";
   String csv409Old = path+L"win2k.409.csv";

   if( 
         !FS::FileExists(dcpromoNew)    ||
         !FS::FileExists(dcpromoOld)   ||
         !FS::FileExists(csv409New)     ||
         !FS::FileExists(csv409Old)
     )
   {
      MessageBox(NULL,usage.c_str(),L"Some file doesn't exist",MB_OK);
      return 0;
   }
   
   

   HANDLE outFile=INVALID_HANDLE_VALUE;
   HRESULT hr=S_OK;
   hr=FS::CreateFile(   outFileName,
                        outFile,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        CREATE_ALWAYS);

   if FAILED(hr)
   {
      MessageBox(NULL,L"Problems to create output file",L"Error",MB_OK);
      LOG_HRESULT(hr);
      return hr;
   }

   do
   {

      AnsiString header;
      header = "// This file is generated by OldRepl.exe\r\n"
               "// Copyright (c) 2001 Microsoft Corporation\r\n"
               "// Jun 2001 lucios\r\n"
               "\r\n"
               "#include \"headers.hxx\"\r\n"
               "#include \"constants.hpp\"\r\n"
               "\r\n"
               "void setReplacementChanges()\r\n"
               "{";

      hr =  FS::Write(outFile,header);
      BREAK_ON_FAILED_HRESULT(hr);


      hr=generateChanges
         (
            dcpromoOld,
            dcpromoNew,
            LOCALEIDS,
            outFile
         );
      BREAK_ON_FAILED_HRESULT(hr);
      hr=generateChanges
         (
            csv409Old,
            csv409New,
            LOCALE409,
            outFile
         );
      BREAK_ON_FAILED_HRESULT(hr);

      AnsiString tail="\r\n}\r\n";

      hr =  FS::Write(outFile,tail);
      BREAK_ON_FAILED_HRESULT(hr);
      //hr=dumpCsv(dcpromoOld,LOCALEIDS,outFile);
      //hr=dumpCsv(csv409Old,LOCALE409,outFile);
      //BREAK_ON_FAILED_HRESULT(hr);

   } while(0);


   CloseHandle(outFile);

   if(FAILED(hr))
   {
      MessageBox(NULL,error.c_str(),L"Error",MB_OK);
   }
   else
   {
      MessageBox(NULL,L"Generation Successful",L"Success",MB_OK);
   }
   return 1;

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\amanuensis.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class Amanuensis, records a log of the analysis phase
//
// 8 Mar 2001 sburns



#ifndef AMANUENSIS_HPP_INCLUDED
#define AMANUENSIS_HPP_INCLUDED



// a.man.u.en.sis [ah mannyoo ehnsiss] (plural a.man.u.en.ses [ah mannyoo ehn
// seez]) noun 1.scribe: somebody employed by an individual to write from his
// or her dictation or to copy manuscripts 2.writers assistant: a writers
// assistant with research and secretarial duties
// 
// [Early 17th century. From Latin, formed from a manu, literally, by hand
// (in the phrase servus a manu enslaved servant with secretarial duties).]



class Amanuensis
{
   public:


   
   explicit
   Amanuensis(int outputInterval = 5);



   void
   AddEntry(const String& entry);



   void
   AddErrorEntry(HRESULT hr, int stringResId);



   void
   AddErrorEntry(HRESULT hr, const String& entry);
   


   void
   Flush();

//    String
//    GetLog() const;   

//    HRESULT
//    SaveLogFile(const String& logFilePath) const;
// 
// 
// 
   


   private:

   StringList           entries;       
   int                  outputInterval;
   StringList::iterator lastOutput;    

   
   
   // not implemented: no copying allowed. You can't copy the copyist. Ha!
   // I crack myself up.

   Amanuensis(const Amanuensis&);
   const Amanuensis& operator=(const Amanuensis&);
};



#endif   // AMANUENSIS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\amanuensisa.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class Amanuensis, records a log of the analysis phase
//
// 8 Mar 2001 sburns



#include "headers.hxx"
#include <iostream>
#include "Amanuensis.hpp"
#include "resource.h"




Amanuensis::Amanuensis(int outputInterval_)
   :
   outputInterval(outputInterval_)
{
   LOG_CTOR(Amanuensis);

   lastOutput = entries.begin();
}



void
Amanuensis::AddEntry(const String& entry)
{
   LOG_FUNCTION2(Amanuensis::AddEntry, entry);

   // empty entries are ok, these are treated as newlines.

   // insert the new entry at the end of the list.
   
   StringList::iterator last =
      entries.insert(entries.end(), entry + L"\r\n");

   if (outputInterval && !(entries.size() % outputInterval))
   {
      Flush();
   }
}



void
Amanuensis::AddErrorEntry(HRESULT hr, int stringResId)
{
   LOG_FUNCTION(Amanuensis::AddErrorEntry);
   ASSERT(FAILED(hr));
   ASSERT(stringResId);

   AddErrorEntry(hr, String::load(stringResId));
}
   


void
Amanuensis::AddErrorEntry(HRESULT hr, const String& message)
{
   LOG_FUNCTION(Amanuensis::AddErrorEntry);
   ASSERT(FAILED(hr));
   ASSERT(!message.empty());

   AddEntry(
      String::format(
         IDS_ERROR_ENTRY,
         message.c_str(),
         GetErrorMessage(hr).c_str()));
}



void
Amanuensis::Flush()
{
   LOG_FUNCTION(Amanuensis::Flush);

   // output all entries since the last entry that we output.

   while (lastOutput != entries.end())
   {
      AnsiString ansi;
      lastOutput->convert(ansi);

      // CODEWORK: here we're just dumping to the console, but we might want
      // an abstraction of the output...
      
      std::cout << ansi;
      ++lastOutput;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\analyst.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// class Analyst: analyzes the display specifiers, logs the findings, and
// compiles a set of corrective actions.
//
// 9 Mar 2001 sburns



#include "headers.hxx"
#include "resource.h"
#include "AdsiHelpers.hpp"
#include "Analyst.hpp"
#include "Amanuensis.hpp"
#include "Repairer.hpp"
#include "ChangedObjectHandlerList.hpp"
#include "ChangedObjectHandler.hpp"



Analyst::Analyst(
   const String& targetDomainControllerName,
   Amanuensis&   amanuensis_,
   Repairer&     repairer_)
   :
   targetDcName(targetDomainControllerName),
   ldapPrefix(),
   rootDse(0),
   
   // alias the objects

   amanuensis(amanuensis_),
   repairer(repairer_)
{
   LOG_CTOR(Analyst);
   ASSERT(!targetDcName.empty());

}



// basic idea: if the error is critical and analysis should not continue, set
// hr to a failure value, and break out, propagating the error backward.  If
// the error is non-critical and analysis should continue, log the error, skip
// the current operation, and set hr to S_FALSE.

HRESULT
AssessErrorSeverity(HRESULT hrIn)
{
   HRESULT hr = hrIn;
   
   if (SUCCEEDED(hr))
   {
      return hr;
   }
   
   switch (hr)
   {
      case 0:
      {
      }
      
      // CODEWORK: we need to define what errors are critical...
      
      default:
      {
         // do nothing

         break;
      }
   }

   return hr;
}
   


HRESULT
Analyst::AnalyzeDisplaySpecifiers()
{
   LOG_FUNCTION(Analyst::AnalyzeDisplaySpecifiers);

   HRESULT hr = S_OK;

   do
   {
      Computer targetDc(targetDcName);
      hr = targetDc.Refresh();

      if (FAILED(hr))
      {
         amanuensis.AddErrorEntry(
            hr,
            String::format(
               IDS_CANT_TARGET_MACHINE,
               targetDcName.c_str()));
         break;
      }

      if (!targetDc.IsDomainController())
      {
         amanuensis.AddEntry(
            String::format(
               IDS_TARGET_IS_NOT_DC,
               targetDcName.c_str()));
         break;
      }

      String dcName = targetDc.GetActivePhysicalFullDnsName();
      ldapPrefix = L"LDAP://" + dcName + L"/";
         
      //
      // Find the DN of the configuration container.
      // 

      // Bind to the rootDSE object.  We will keep this binding handle
      // open for the duration of the analysis and repair phases in order
      // to keep a server session open.  If we decide to pass creds to the
      // AdsiOpenObject call in a later revision, then by keeping the
      // session open we will not need to pass the password to subsequent
      // AdsiOpenObject calls.
      
      hr = AdsiOpenObject<IADs>(ldapPrefix + L"RootDSE", rootDse);
      if (FAILED(hr))
      {
         amanuensis.AddErrorEntry(
            hr,
            String::format(
               IDS_UNABLE_TO_CONNECT_TO_DC,
               dcName.c_str()));
         break;      
      }
            
      // read the configuration naming context.

      _variant_t variant;
      hr =
         rootDse->Get(
            AutoBstr(LDAP_OPATT_CONFIG_NAMING_CONTEXT_W),
            &variant);
      if (FAILED(hr))
      {
         LOG(L"can't read config NC");
         
         amanuensis.AddErrorEntry(
            hr,
            IDS_UNABLE_TO_READ_DIRECTORY_INFO);
         break;   
      }

      String configNc = V_BSTR(&variant);

      LOG(configNc);
      ASSERT(!configNc.empty());      

      //
      // Here we go...
      //
      
      hr = AnalyzeDisplaySpecifierContainers(configNc);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
Analyst::AnalyzeDisplaySpecifierContainers(const String& configurationDn)
{
   LOG_FUNCTION2(Analyst::AnalyzeDisplaySpecifierContainers, configurationDn);
   ASSERT(!configurationDn.empty());

   HRESULT hr = S_OK;
   
   static const int LOCALEIDS[] =
   {
      // a list of all the non-english locale IDs that we support

      0x401,
      0x404,
      0x405,
      0x406,
      0x407,
      0x408,
      0x40b,
      0x40c,
      0x40d,
      0x40e,
      0x410,
      0x411,
      0x412,
      0x413,
      0x414,
      0x415,
      0x416,
      0x419,
      0x41d,
      0x41f,
      0x804,
      0x816,
      0xc0a,
      0
   };

   // compose the LDAP path of the display specifiers container

   String rootContainerDn = L"CN=DisplaySpecifiers," + configurationDn;

   for (
      int i = 0;
         (i < sizeof(LOCALEIDS) / sizeof(int))
      && LOCALEIDS[i];
      ++i)
   {
      hr = AnalyzeDisplaySpecifierContainer(LOCALEIDS[i], rootContainerDn);
      BREAK_ON_FAILED_HRESULT(hr);
   }

   LOG_HRESULT(hr);

   return hr;
}
      


HRESULT
Analyst::AnalyzeDisplaySpecifierContainer(
   int           localeId,
   const String& rootContainerDn)
{
   LOG_FUNCTION2(
      Analyst::AnalyzeDisplaySpecifierContainer,
      rootContainerDn);
   ASSERT(!rootContainerDn.empty());
   ASSERT(localeId);

   HRESULT hr = S_OK;

   do
   {
      String childContainerDn =
            ldapPrefix
         +  String::format(L"CN=%1!3x!,", localeId) + rootContainerDn;

      // Attempt to bind to the container.
         
      SmartInterface<IADs> iads(0);
      hr = AdsiOpenObject<IADs>(childContainerDn, iads);
      if (hr == E_ADS_UNKNOWN_OBJECT)
      {
         // The container object does not exist.  This is possible because
         // the user has manually removed the container, or because it
         // was never created due to an aboted post-dcpromo import of the
         // display specifiers when the forest root dc was first promoted.

         repairer.AddCreateContainerWorkItem(localeId);
         hr = S_OK;
         break;
      }

      BREAK_ON_FAILED_HRESULT(hr);      

      // At this point, the bind succeeded, so the child container exists.
      // So now we want to examine objects in that container.

      hr =
         AnalyzeDisplaySpecifierObjects(
            localeId,
            childContainerDn);
   }
   while (0);

   LOG_HRESULT(hr);

   hr = AssessErrorSeverity(hr);
   
   return hr;
}



HRESULT
Analyst::AnalyzeDisplaySpecifierObjects(
   int           localeId,
   const String& containerDn)
{
   LOG_FUNCTION2(Analyst::AnalyzeDisplaySpecifierObjects, containerDn);
   ASSERT(localeId);
   ASSERT(!containerDn.empty());

   HRESULT hr = S_OK;

   do
   {
      // Part 1: deal with new objects added in Whistler

      hr = AnalyzeAddedObjects(localeId, containerDn);
      hr = AssessErrorSeverity(hr);
      BREAK_ON_FAILED_HRESULT(hr);

      // Part 2: deal with objects that have changed from Win2k to Whistler

      hr = AnalyzeChangedObjects(localeId, containerDn);
      hr = AssessErrorSeverity(hr);      
      BREAK_ON_FAILED_HRESULT(hr);
                  
      // Part 3: deal with objects that have been deleted in whistler

      // This part is easy: there are no deletions.
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



bool
RepairWasRunPreviously()
{
   LOG_FUNCTION(RepairWasRunPreviously);

   bool result = false;
   
   // CODEWORK: need to complete

   LOG_BOOL(result);
   
   return result;
}



HRESULT
Analyst::AnalyzeAddedObjects(
   int           localeId,
   const String& containerDn)
{
   LOG_FUNCTION2(Analyst::AnalyzeAddedObjects, containerDn);
   ASSERT(localeId);
   ASSERT(!containerDn.empty());

   HRESULT hr = S_OK;

   do
   {
      static const String ADDED_OBJECTS[] =
      {
         L"msMQ-Custom-Recipient-Display",
         L"msMQ-Group-Display",
         L"msCOM-PartitionSet-Display",
         L"msCOM-Partition-Display",
         L"lostAndFound-Display",
         L"inetOrgPerson-Display",
         L"",
      };

      for (
         int i = 0;
            i < (sizeof(ADDED_OBJECTS) / sizeof(String))
         && !ADDED_OBJECTS[i].empty();
         ++i)
      {
         String objectName = ADDED_OBJECTS[i];
         
         String objectPath =
            ldapPrefix +  L"CN=" + objectName + L"," + containerDn;

         SmartInterface<IADs> iads(0);
         hr = AdsiOpenObject<IADs>(objectPath, iads);
         if (hr == E_ADS_UNKNOWN_OBJECT)
         {
            // The object does not exist. This is what we expect. We want
            // to add the object in the repair phase.

            repairer.AddCreateObjectWorkItem(localeId, objectName);
            hr = S_OK;
            continue;
         }
         else if (SUCCEEDED(hr))
         {
            // The object already exists. Well, that's not expected, unless
            // we've already run the tool.

            if (!RepairWasRunPreviously())
            {
               // we didn't create the object.  If the user did, they did
               // it manually, and we don't support that.
               
               // cause the existing object to be deleted

               repairer.AddDeleteObjectWorkItem(localeId, objectName);

               // cause a new, replacement object to be created.
               
               repairer.AddCreateObjectWorkItem(localeId, objectName);
               hr = S_OK;
               continue;
            }
         }
         else
         {
            ASSERT(FAILED(hr));

            LOG(L"Unexpected error attempting to bind to " + objectName);

            amanuensis.AddErrorEntry(
               hr,
               String::format(
                  IDS_ERROR_BINDING_TO_OBJECT,
                  objectName.c_str(),
                  objectPath.c_str()));
 
            // move on to the next object
            
            hr = S_FALSE;
            continue;
         }
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
   
   LOG_HRESULT(hr);

   return hr;
}
         


HRESULT
Analyst::AnalyzeChangedObjects(
   int           localeId,
   const String& containerDn)
{
   LOG_FUNCTION2(Analyst::AnalyzeChangedObjects, containerDn);
   ASSERT(localeId);
   ASSERT(!containerDn.empty());

   HRESULT hr = S_OK;

   static const ChangedObjectHandlerList handlers;
   
   for (
      ChangedObjectHandlerList::iterator i = handlers.begin();
      i != handlers.end();
      ++i)
   {
      hr = AnalyzeChangedObject(localeId, containerDn, **i);
      hr = AssessErrorSeverity(hr);
            
      BREAK_ON_FAILED_HRESULT(hr);
   }

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
Analyst::AnalyzeChangedObject(
   int                           localeId,
   const String&                 containerDn,
   const ChangedObjectHandler&   changeHandler)
{
   LOG_FUNCTION2(Analyst::AnalyzeChangedObject, changeHandler.GetObjectName());
   ASSERT(localeId);
   ASSERT(!containerDn.empty());

   HRESULT hr = S_OK;

   do
   {
      String objectName = changeHandler.GetObjectName();
         
      String objectPath =
         ldapPrefix +  L"CN=" + objectName + L"," + containerDn;

      SmartInterface<IADs> iads(0);
      hr = AdsiOpenObject<IADs>(objectPath, iads);
      if (hr == E_ADS_UNKNOWN_OBJECT)
      {
         // The object does not exist.  This is possible because the user has
         // manually removed the container, or because it was never created
         // due to an aboted post-dcpromo import of the display specifiers
         // when the forest root dc was first promoted.

         // Add a work item to create the missing object
         
         repairer.AddCreateObjectWorkItem(localeId, objectName);
         hr = S_OK;
         break;
      }

      if (FAILED(hr))
      {
         // any other error is quittin' time.

         break;
      }

      // At this point, the display specifier object exists.  Determine if
      // if has been touched since its creation.

      // Compare usnCreated to usnChanged
      
      _variant_t variant;
      hr = iads->Get(AutoBstr(L"usnCreated"), &variant);
      if (FAILED(hr))
      {
         LOG(L"Error reading usnCreated");
         break;
      }


      
      // CODEWORK: need to complete this


      

      hr = changeHandler.HandleChange(
         localeId,
         containerDn,
         iads,
         amanuensis,
         repairer);
         
      
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\changedobjecthandlerlist.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// class ChangedObjectHandlerList
//
// 14 Mar 2001 sburns



#include "headers.hxx"
#include "ChangedObjectHandlerList.hpp"
#include "DsUiDefaultSettingsChangeHandler.hpp"



ChangedObjectHandlerList::ChangedObjectHandlerList()
{
   LOG_CTOR(ChangedObjectHandlerList);

   push_back(new DsUiDefaultSettingsChangeHandler);
   
   // push_back(new UserDisplayChangeHandler());
   // push_back(new DomainDnsDisplayChangeHandler());
   // push_back(new ComputerDisplayChangeHandler());
   // push_back(new OrganizationalUnitDisplayChangeHandler());
   // push_back(new ContainerDisplayChangeHandler());
   // push_back(new DefaultDisplayChangeHandler());
   // push_back(new NtdsServiceDisplayChangeHandler());
   // push_back(new PkiCertificateTemplateDisplayChangeHandler());
}



ChangedObjectHandlerList::~ChangedObjectHandlerList()
{
   LOG_DTOR(ChangedObjectHandlerList);

   for (
      iterator i = begin();
      i != end();
      ++i)
   {
      // i is the "pointer" to the pointer, so deref i first
      
      delete *i;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\changedobjecthandler.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// class ChangedObjectHandler
//
// 14 Mar 2001 sburns



#ifndef CHANGEDOBJECTHANDLER_HPP_INCLUDED
#define CHANGEDOBJECTHANDLER_HPP_INCLUDED



#include "Amanuensis.hpp"
#include "Repairer.hpp"



// An abstract base class for types that deal with the differences in handling
// the display specifier object changes.
// 
// Concrete instances of this class are used by the Analyst class to deal with
// differences in the individual display specifer objects.  Thus, Analyst and
// ChangedObjectHandler form a variation of the Template Method pattern from
// Gamma, et al. Design Patterns. pp. 325-330 ISBN: 0-201-63361-2

class ChangedObjectHandler
{
   public:


   // lucios: 
   // Removed to solve link error
   // Either remove it or define it would work
   // virtual
   // ~ChangedObjectHandler() = 0;


   
   virtual 
   String
   GetObjectName() const = 0;


   
   virtual
   HRESULT
   HandleChange(
      int                  localeId,
      const String&        containerDn,
      SmartInterface<IADs> iads,
      Amanuensis&          amanuensis,
      Repairer&            repairer) const = 0;
};



#endif   // CHANGEDOBJECTHANDLER_HPP_INCLUDED



      // L"user-Display",
      // L"domainDNS-Display",
      // L"computer-Display",
      // L"organizationalUnit-Display",
      // L"container-Display",
      // L"default-Display",
      // L"nTDSService-Display",
      // L"pKICertificateTemplate-Display",
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\analyst.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// class Analyst: analyzes the display specifiers, logs the findings, and
// compiles a set of corrective actions.
//
// 9 Mar 2001 sburns



#ifndef ANALYST_HPP_INCLUDED
#define ANALYST_HPP_INCLUDED



class Amanuensis;
class Repairer;
class ChangedObjectHandler;



class Analyst
{
   public:



   Analyst(
      const String& targetDomainControllerName,
      Amanuensis&   amanuensis,
      Repairer&     repairer);



   HRESULT
   AnalyzeDisplaySpecifiers();


   
   private:



   HRESULT
   AnalyzeAddedObjects(
      int           localeId,
      const String& containerDn);



   HRESULT
   AnalyzeChangedObjects(
      int           localeId,
      const String& containerDn);
      

      
   HRESULT
   AnalyzeChangedObject(
      int                           localeId,
      const String&                 containerDn,
      const ChangedObjectHandler&   changeHandler);
      

   
   HRESULT
   AnalyzeDisplaySpecifierContainers(const String& configurationDn);


   
   HRESULT
   AnalyzeDisplaySpecifierContainer(
      int           localeId,
      const String& rootContainerDn);


      
   HRESULT
   AnalyzeDisplaySpecifierObjects(
      int           localeId,
      const String& containerDn);


      
   String               targetDcName;
   String               ldapPrefix;
   SmartInterface<IADs> rootDse;
   Amanuensis&          amanuensis;
   Repairer&            repairer;
   
   

   // not implemented: no copying allowed.

   Analyst(const Analyst&);
   const Analyst& operator=(const Analyst&);
};



#endif   // ANALYST_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\changedobjecthandlerlist.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// class ChangedObjectHandlerList
//
// 14 Mar 2001 sburns



#ifndef CHANGEDOBJECTHANDLERLIST_HPP_INCLUDED
#define CHANGEDOBJECTHANDLERLIST_HPP_INCLUDED



class ChangedObjectHandler;



// A fixed collection of instances of ChangedObjectHandler that has the
// same public interface as std::list

class ChangedObjectHandlerList
   :
   public std::list<ChangedObjectHandler*>
{
   public:

   ChangedObjectHandlerList();

   ~ChangedObjectHandlerList();


   
   // CODEWORK: it would be interesting to see if we can cause the interface to
   // be read-only by overriding push_back, pop_front, etc...

   
   
   private:

   // not implemented: no copying allowed

   ChangedObjectHandlerList(const ChangedObjectHandlerList&);
   const ChangedObjectHandlerList& operator=(const ChangedObjectHandlerList&);
};



#endif   // CHANGEDOBJECTHANDLERLIST_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\dsuidefaultsettingschangehandler.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class DsUiDefaultSettingsChangeHandler, handler for changes to instances
// of the DS-UI-Default-Settings object.
//
// 14 Mar 2001 sburns



#include "headers.hxx"
#include "DsUiDefaultSettingsChangeHandler.hpp"



DsUiDefaultSettingsChangeHandler::DsUiDefaultSettingsChangeHandler()
{
   LOG_CTOR(DsUiDefaultSettingsChangeHandler);
}



DsUiDefaultSettingsChangeHandler::~DsUiDefaultSettingsChangeHandler()
{
   LOG_DTOR(DsUiDefaultSettingsChangeHandler);
}



String
DsUiDefaultSettingsChangeHandler::GetObjectName() const
{
   static String objName(L"DS-UI-Default-Settings");
   
   return objName;
}



HRESULT
DsUiDefaultSettingsChangeHandler::HandleChange(
   int                  localeId,
   const String&        containerDn,
   SmartInterface<IADs> iads,
   Amanuensis&          /* amanuensis */ ,
   Repairer&            /* repairer */ ) const
{
   LOG_FUNCTION2(DsUiDefaultSettingsChangeHandler::HandleChange, containerDn);
   ASSERT(localeId);
   ASSERT(!containerDn.empty());
   ASSERT(iads);
         
   HRESULT hr = S_OK;

   // CODEWORK:  Needs finishing
   
   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\resource.h ===
#define IDS_APP_TITLE                     1501
#define IDS_CANT_TARGET_MACHINE           1502
#define IDS_DCPROMO_CSV_FILE_MISSING      1503
#define IDS_ERROR_LOOKING_FOR_CSV_FILE    1504
#define IDS_TARGET_IS_NOT_DC              1505
#define IDS_UNABLE_TO_CONNECT_TO_DC       1506
#define IDS_UNABLE_TO_READ_DIRECTORY_INFO 1507
#define IDS_ERROR_BINDING_TO_OBJECT       1508
#define IDS_ERROR_ENTRY                   1509
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\dspecup.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
// 
// 1 Mar 2001 sburns



#include "headers.hxx"
#include "resource.h"
#include "AdsiHelpers.hpp"
#include "Repairer.hpp"
#include "Amanuensis.hpp"
#include "Analyst.hpp"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available

// don't change this: it is also the name of a mutex that the ui
// uses to determine if it is already running.

const wchar_t* RUNTIME_NAME = L"dspecup";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;

Popup popup(IDS_APP_TITLE, false);

// this is the mutex that indicates the program is running.

HANDLE appRunningMutex = INVALID_HANDLE_VALUE;



// these are the valid exit codes returned as the process exit code

enum ExitCode
{
   // the operation failed.

   EXIT_CODE_UNSUCCESSFUL = 0,

   // the operation succeeded

   EXIT_CODE_SUCCESSFUL = 1,
};



// returns true if the parameter was extracted. If so, it is removed from
// args

bool
ExtractParameter(
   ArgMap&        args,
   const String&  parameterName,
   String&        parameterValue)
{
   LOG_FUNCTION2(ExtractParameter, parameterName);
   ASSERT(!parameterName.empty());

   parameterValue.erase();
   bool result = false;
   
   ArgMap::iterator itr = args.find(parameterName);
   if (itr != args.end())
   {
      parameterValue = itr->second;
      args.erase(itr);
      result = true;
   }

   LOG_BOOL(result);
   LOG(parameterValue);

   return result;
}
      
      

// Returns false if the command line is malformed.

bool
ParseCommandLine(
   String& targetMachine,
   String& csvFilename)
{
   LOG_FUNCTION(ParseCommandLine);

   targetMachine.erase();
   csvFilename.erase();
   
   bool result = true;
   
   ArgMap args;
   MapCommandLineArgs(args);
   
   // check for target domain controller parameter

   static const String TARGETDC(L"dc");
   ExtractParameter(args, TARGETDC, targetMachine);

   // check for csv filename parameter

   static const String CSVFILE(L"csv");
   ExtractParameter(args, CSVFILE, csvFilename);

   // anything left over gets you command line help, (one arg will always
   // remain: the name of the exe)

   if (args.size() > 1)
   {
      LOG(L"Unrecognized command line options specified");

      result = false;
   }

   LOG_BOOL(result);
   LOG(targetMachine);
   LOG(csvFilename);

   return result;
}



HRESULT
FindCsvFile(const String& targetPath, String& csvFilePath)
{
   LOG_FUNCTION(CheckPreconditions);

   csvFilePath.erase();
   
   HRESULT hr = S_OK;

   do
   {
      // look for dcpromo.csv file in system or current directory
      
      if (targetPath.empty())
      {
         // no preference given, so check the default of
         // %windir%\system32\mui\dispspec\dcpromo.csv and
         // .\dcpromo.csv

         static const String csvname(L"dcpromo.csv");
         
         String sys32dir = Win::GetSystemDirectory();
         String csvPath  = sys32dir + L"\\mui\\dispspec\\" + csvname;

         if (FS::FileExists(csvPath))
         {
            csvFilePath = csvPath;
            break;
         }
      
         csvPath = L".\\" + csvname;
         if (FS::FileExists(csvPath))
         {
            csvFilePath = csvPath;
            break;
         }
      }
      else
      {
         if (FS::FileExists(targetPath))
         {
            csvFilePath = targetPath;
            break;
         }
      }

      // not found.

      hr = S_FALSE;
   }
   while (0);

   LOG_HRESULT(hr);
   LOG(csvFilePath);
   
   return hr;      
}



HRESULT
Start()
{
   LOG_FUNCTION(Start);

   HRESULT hr = S_OK;
   
   do
   {
      //
      // parse the command line options
      //
      
      String targetDomainControllerName;
      String csvFilename;
      ParseCommandLine(
         targetDomainControllerName,
         csvFilename);

      //
      // find the dcpromo.csv file to use
      //
   
      hr = FindCsvFile(csvFilename, csvFilename);
      if (FAILED(hr))
      {
         // encountered an error looking for the csv file
         
         popup.Error(
            Win::GetDesktopWindow(),
            hr,
            IDS_ERROR_LOOKING_FOR_CSV_FILE);
         break;   
      }
      
      if (hr == S_FALSE)
      {
         // no error looking, just not found.
         
         popup.Error(
            Win::GetDesktopWindow(),
            IDS_DCPROMO_CSV_FILE_MISSING);
         break;   
      }

      //
      // Determine the target domain controller
      //

      if (targetDomainControllerName.empty())
      {
         // no target specified, default to the current machine
   
         targetDomainControllerName =
            Win::GetComputerNameEx(ComputerNameDnsFullyQualified);
   
         if (targetDomainControllerName.empty())
         {
            // no DNS name?  that's not right...
   
            LOG(L"no default DNS computer name found.  Using netbios name.");
   
            targetDomainControllerName = Win::GetComputerNameEx(ComputerNameNetBIOS);
         }
      }

      //
      // Analysis Phase
      //

      // First we need a Repairer object to keep track of the changes we
      // will make during the Repair Phase.

      Repairer
         repairer(
            csvFilename
            // might also need domain NC,
            // might also need targetMachine full name
            );

      // Then we need a scribe to record the analysis.
      
      Amanuensis amanuensis;

      // Then we need an Analyst to figure out what's broken and how to
      // fix it.

      Analyst analyst(targetDomainControllerName, amanuensis, repairer);
            
      hr = analyst.AnalyzeDisplaySpecifiers();
      BREAK_ON_FAILED_HRESULT(hr);

      //
      // Repair Phase
      //

      // CODEWORK: get user confirmation to apply repairs
      
      hr = repairer.BuildRepairFiles();
      BREAK_ON_FAILED_HRESULT(hr);

      hr = repairer.ApplyRepairs();
      BREAK_ON_FAILED_HRESULT(hr);            
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}
         


int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE   /* hPrevInstance */ ,
   PSTR        /* lpszCmdLine */ ,
   int         /* nCmdShow */)
{
   hResourceModuleHandle = hInstance;

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;

   HRESULT hr = Win::CreateMutex(0, true, RUNTIME_NAME, appRunningMutex);
   if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
   {
      // The application is already running

      // CODEWORK: use FindWindowEx and BringWindowToTop,
      // SetForegroundWindow to transfer focus
      // to the other instance?


   }
   else
   {
      hr = ::CoInitialize(0);
      ASSERT(SUCCEEDED(hr));

      hr = Start();
      if (SUCCEEDED(hr))
      {
         exitCode = EXIT_CODE_SUCCESSFUL;
      }
   }

   return static_cast<int>(exitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\dsuidefaultsettingschangehandler.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class DsUiDefaultSettingsChangeHandler, handler for changes to instances
// of the DS-UI-Default-Settings object.
//
// 14 Mar 2001 sburns



#ifndef DSUIDEFAULTSETTINGSCHANGEHANDLER_HPP_INCLUDED
#define DSUIDEFAULTSETTINGSCHANGEHANDLER_HPP_INCLUDED



#include "ChangedObjectHandler.hpp"



class DsUiDefaultSettingsChangeHandler
   :
   public ChangedObjectHandler
{
   public:



   DsUiDefaultSettingsChangeHandler();

   ~DsUiDefaultSettingsChangeHandler();
   

   
   // Returns "DS-UI-Default-Settings"
   
   String
   GetObjectName() const;



   HRESULT
   HandleChange(
      int                  localeId,
      const String&        containerDn,
      SmartInterface<IADs> iads,
      Amanuensis&          amanuensis,
      Repairer&            repairer) const;

      

   private:

   // not implemented: no copying allowed

   DsUiDefaultSettingsChangeHandler(const DsUiDefaultSettingsChangeHandler&);
   const DsUiDefaultSettingsChangeHandler
   operator=(const DsUiDefaultSettingsChangeHandler&);   
};
      
      
   

#endif   // DSUIDEFAULTSETTINGSCHANGEHANDLER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\test\test.cpp ===
#include "headers.hxx"
#include "..\dspecup.hpp"
#include <windows.h>




void stepIt(long arg, void *vTotal)
{
   long *total=(long *)vTotal;
   printf("\r"             "\r%ld",(*total)+=arg);
}

void totalSteps(long arg, void *vTotal)
{
   long *total=(long *)vTotal;
   *total=0;
   printf("\n%ld\n",arg);
}


void __cdecl wmain(int argc,wchar_t *argv[])
{
   char *usage;
   usage="\nYou should pass one or more guids to specify the operation(s).\n "
         "Ex: test.exe 4444c516-f43a-4c12-9c4b-b5c064941d61 ffa5ee3c-1405-476d"
		 "-b344-7ad37d69cc25\n";

   if(argc<2) {printf(usage);return;}

   GUID guid;
   long total=0;

   HRESULT hr=S_OK;
   
   wchar_t curDir[MAX_PATH+1];
   GetCurrentDirectory(MAX_PATH,curDir);

   PWSTR errorMsg=NULL;
   do
   {
      for(int cont=1;cont<argc;cont++)
      {
        if(UuidFromString(argv[cont],&guid)!=RPC_S_OK) {printf(usage);return;}
        hr=UpgradeDisplaySpecifiers
        (
            curDir,
			&guid,
            false,
            &errorMsg,
            &total,
            stepIt,
            totalSteps
        );
        if(FAILED(hr)) break;
      }
   } while(0);

   if(FAILED(hr))
   {
      
      if(errorMsg!=NULL)
      {
         wprintf(L"%s\n",errorMsg);
         LocalFree(errorMsg);
      }
      
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\analisyspage.cpp ===
#include "headers.hxx"
#include "AnalysisPage.hpp"
#include "resource.h"
#include "common.hpp"
#include "AnalysisResults.hpp"
#include "CSVDSReader.hpp"
#include "Analysis.hpp"
#include "global.hpp"
#include "constants.hpp"



AnalysisPage::AnalysisPage
              (
                  const CSVDSReader& csvReader409_,
                  const CSVDSReader& csvReaderIntl_,
                  const String& ldapPrefix_,
                  const String& rootContainerDn_,
                  AnalysisResults& res,
                  const String& reportName_
              )
   :
   csvReader409(csvReader409_),
   csvReaderIntl(csvReaderIntl_),
   ldapPrefix(ldapPrefix_),
   rootContainerDn(rootContainerDn_),
   results(res),
   reportName(reportName_),
   WizardPage
   (
      IDD_ANALYSIS,
      IDS_ANALYSIS_PAGE_TITLE,
      IDS_ANALYSIS_PAGE_SUBTITLE,
      true
   )
{
   LOG_CTOR(AnalysisPage);
}

AnalysisPage::~AnalysisPage()
{
   LOG_DTOR(AnalysisPage);
}


long WINAPI startAnalysis(long arg)
{
   LOG_FUNCTION(startAnalysis);
   AnalysisPage *page=(AnalysisPage *)arg;
   Analysis analysis(
                        page->csvReader409,
                        page->csvReaderIntl,
                        page->ldapPrefix,
                        page->rootContainerDn,
                        page->results,
                        &page->reportName,
                        page
                    );

   // CoInitialize must be called per thread
   HRESULT hr = ::CoInitialize(0);
   ASSERT(SUCCEEDED(hr));

   hrError=analysis.run();

   CoUninitialize();

   page->FinishProgress();
   return 0;
}


// WizardPage overrides

bool
AnalysisPage::OnSetActive()
{
   LOG_FUNCTION(AnalysisPage::OnSetActive);
   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), 0);

   pos=0;

   HANDLE hA=CreateThread( 
                           NULL,0,
                           (LPTHREAD_START_ROUTINE) startAnalysis,
                           this,
                           0, 0 
                         );
   CloseHandle(hA);
   return true;
}



void
AnalysisPage::OnInit()
{
   LOG_FUNCTION(AnalysisPage::OnInit);
   HWND prog=GetDlgItem(hwnd,IDC_PROGRESS_ANALYSIS);


   // calculate the # of locales
   for(long t=0;LOCALEIDS[t]!=0;t++)
   {
      //empty
   }
   
   SendMessage(prog,PBM_SETRANGE,0,MAKELPARAM(0,t)); 
};


bool
AnalysisPage::OnWizBack()
{
   LOG_FUNCTION(AnalysisPage::OnWizBack);
   GetWizard().SetNextPageID(hwnd,IDD_WELCOME);
   return true;
}

bool
AnalysisPage::OnWizNext()
{
   LOG_FUNCTION(AnalysisPage::OnWizNext);
   if (FAILED(hrError))
   {
      GetWizard().SetNextPageID(hwnd,IDD_FINISH);
   }
   else
   {
      GetWizard().SetNextPageID(hwnd,IDD_UPDATES_REQUIRED);
   }
   return true;
}


void AnalysisPage::StepProgress()
{
   LOG_FUNCTION(AnalysisPage::StepProgress);
   HWND prog=GetDlgItem(hwnd,IDC_PROGRESS_ANALYSIS);
   SendMessage(prog,PBM_SETPOS,pos++,0);
}

void AnalysisPage::FinishProgress()
{
   LOG_FUNCTION(AnalysisPage::FinishProgress);
   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd),PSWIZB_NEXT);

   String result;
   if (FAILED(hrError))
   {
      result=String::format(IDS_IDC_ANALYSIS_RESULT_INCOMPLETE);
      error=String::format(IDS_ANALYSIS_ERROR,error.c_str());
   }
   else
   {
      result=String::format(IDS_IDC_ANALYSIS_RESULT_COMPLETE);
   }
   
   Win::SetDlgItemText(hwnd,IDC_ANALYSIS_RESULT,result);

   HWND text=GetDlgItem(hwnd,IDC_ANALYSIS_RESULT);
   Win::ShowWindow(text,SW_SHOW);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\repairer.cpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class Repairer
//
// keeps a list of the localeIds to be extracted from the dcpromo.csv file,
// and a list of operations to be represented in an LDIF file.
//
// 7 Mar 2001 sburns



#include "headers.hxx"
#include "Repairer.hpp"



// // // make sure that the ldif operations are executed in advance of the csv
// // // operations.  this is so the object creates will not conflict with object
// // // deletes




Repairer::Repairer(
   const String& dcpromoCsvFilePath_)
   :
   dcpromoCsvFilePath(dcpromoCsvFilePath_)
{
   LOG_CTOR(Repairer);
   ASSERT(!dcpromoCsvFilePath.empty());

}



bool
Repairer::IsLocaleInObjectsToCreateTable(int localeId) const
{
   LOG_FUNCTION2(
      Repairer::IsLocaleInObjectsToCreateTable,
      String::format(L"%1!d!", localeId));
   ASSERT(localeId);   

   bool result = false;

   for (
      LocaleIdObjectNamePairList::iterator i = objectsToCreate.begin();
      i != objectsToCreate.end();
      ++i)
   {
      if (i->first == localeId)
      {
         result = true;
         break;
      }
   }

   LOG_BOOL(result);

   return result;
}
      

   
void
Repairer::AddCreateContainerWorkItem(int localeId)
{
   LOG_FUNCTION2(
      Repairer::AddCreateContainerWorkItem,
      String::format(L"%1!d!", localeId));
   ASSERT(localeId);

   do
   {
      LocaleIdList::iterator i =
         std::find(
            containersToCreate.begin(),
            containersToCreate.end(),
            localeId);

      if (i != containersToCreate.end())
      {
         // The locale should not already be in the list, since each locale
         // container is evaluated only once.
      
         LOG(L"locale already in list");
         ASSERT(false);
         break;
      }
         
      if (IsLocaleInObjectsToCreateTable(localeId))
      {
         // We don't expect any entries for this locale to be present in the
         // objects-to-create list, because the containers are evaluated first.

         LOG(L"objects for locale already in object list");
         ASSERT(false);

         // CODEWORK: we should handle this situation anyway, just for
         // robustness' sake. To deal with it, all entires in the objects-
         // to-create list for this locale id should be removed.
         
         break;
      }

      containersToCreate.push_back(localeId);
   }
   while (0);
}

            

void
Repairer::AddCreateObjectWorkItem(
   int            localeId,
   const String&  displaySpecifierObjectName)
{
   LOG_FUNCTION2(
      Repairer::AddCreateObjectWorkItem,
      String::format(
         L"%1!d! %2", localeId, displaySpecifierObjectName.c_str()));
   ASSERT(localeId);
   ASSERT(!displaySpecifierObjectName.empty());
   
   do
   {
      LocaleIdList::iterator i =
         std::find(
            containersToCreate.begin(),
            containersToCreate.end(),
            localeId);

      if (i != containersToCreate.end())
      {
         // The locale is already in the containers-to-create list, which
         // we don't expect, since if the container does not exist, we should
         // not be evaluating which objects should be created in that container.

         ASSERT(false);

         // do nothing, as the object will be created as part of the container
         // creation.

         break;
      }

      LocaleIdObjectNamePair p(localeId, displaySpecifierObjectName);
      LocaleIdObjectNamePairList::iterator j =
         std::find(
            objectsToCreate.begin(),
            objectsToCreate.end(),
            p);
                        
      if (j != objectsToCreate.end())
      {
         // The object is already in the list.  We don't expect this, since
         // each object should be evaluated only once per locale.

         ASSERT(false);

         // do nothing, if the object is already present, then fine.

         break;
      }

      objectsToCreate.push_back(p);
   }
   while (0);
}

void
Repairer::AddDeleteObjectWorkItem(
                        int            localeId,
                        const String&  displaySpecifierObjectName)
{
   //CODEWORK: 
   //lucios: Inserted to remove link error
   localeId++;
   String x=displaySpecifierObjectName;
}



HRESULT  
Repairer::BuildRepairFiles()
{
   LOG_FUNCTION(Repairer::BuildRepairFiles);

   HRESULT hr = S_OK;
   
// CODEWORK   
//    csv file:
//    
//    create a (temp) file
//    copy out the first line of the dcpromo.csv file (the column labels)
//    for each localeid in the list
//       copy out all of the lines in the dcpromo.csv file for that locale
//    for each <localeid, objectname> entry
//       copy out that line from the dcpromo.csv file
// 
//    ldif file:

   LOG_HRESULT(hr);
   
   return hr;
}



HRESULT
Repairer::ApplyRepairs()
{
   LOG_FUNCTION(Repairer::ApplyRepairs);

   HRESULT hr = S_OK;

   // CODEWORK: needs finishing
   
   LOG_HRESULT(hr);

   return hr;
}



// could have gone with a architecture like:
// 
// repairer.workQueue.Add(new CreateContainerWorkItem(localeId));
// 
// but while that certainly seems more OO, more "extensible" because new work
// item types could be derived. Upon further thought, it seems like a worse
// solution to me, since there are them lots of trivial classes involved, and
// the coordination of those classes becomes a real nuisance. Once all the
// work items are collected, who's responsible for translating them into the
// csv/ldif files?  It would have to be an additional manager class.  The
// extensibility turns out to be an illusion, since adding a new work item
// type requires modifying the manager class.  So the added complexity buys
// nothing.
// 
// The other design choice was whether to make the Repairer a "static class"
// -- my name for a class that is really a namespace, which instead of members
// uses static data that is hidden in a single translation unit as though it
// were private class data. This is a technique that makes the private data
// truly secret, as there is no mention of the data in the header declaration
// for the class at all. It also is a nice way to implement the Singleton
// pattern: there are no instances, and therefore no need to worry about
// constructors, destructors, assignment, stack or heap allocation, no
// "GetInstance" methods, and no lifetime issues.
// 
// The technique gives a slightly nicer syntax as:
// 
// Repairer::AddCreateContainerWorkItem(localeId)
// 
// as opposed to
// 
// Repairer::GetInstance()->AddCreateContainerWorkItem(localeId);
// 
// I decided to go with a real, fully-contained object implementation, instead
// of a singleton, thinking that maybe someday multiple instances could be
// repairing multiple forests at once.  Not likely, but why not?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\previoussource\repairer.hpp ===
// Active Directory Display Specifier Upgrade Tool
// 
// Copyright (c) 2001 Microsoft Corporation
//
// class Repairer, represents "work items" to perform to repair display
// specifier objects.
//
// 7 Mar 2001 sburns



#ifndef REPAIRER_HPP_INCLUDED
#define REPAIRER_HPP_INCLUDED



class Repairer
{
   public:



   explicit   
   Repairer(
      const String& dcpromoCsvFilePath);


   
   void
   AddCreateContainerWorkItem(int localeId);


   
   void
   AddCreateObjectWorkItem(
      int            localeId,
      const String&  displaySpecifierObjectName);
      


   void
   AddDeleteObjectWorkItem(
      int            localeId,
      const String&  displaySpecifierObjectName);



   HRESULT
   ApplyRepairs();


      
   HRESULT
   BuildRepairFiles();



   private:


   typedef std::list<int>                    LocaleIdList;
   typedef std::pair<int, String>            LocaleIdObjectNamePair;
   typedef std::list<LocaleIdObjectNamePair> LocaleIdObjectNamePairList;
   
   String                     dcpromoCsvFilePath;
   LocaleIdList               containersToCreate;
   LocaleIdObjectNamePairList objectsToCreate; 


   
   bool
   IsLocaleInObjectsToCreateTable(int localeId) const;


   
   // not implemented: no copying allowed

   Repairer(const Repairer&);
   const Repairer& operator=(const Repairer&);
};



#endif   // REPAIRER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\analisyspage.hpp ===
#ifndef ANALISYS_PAGE_HPP_INCLUDED
#define ANALISYS_PAGE_HPP_INCLUDED

struct AnalisysResults;
class CSVDSReader;

class AnalisysPage : public WizardPage 
{

   public:

      AnalisysPage(
                     const CSVDSReader& csvReader409_,
                     const CSVDSReader& csvReaderIntl_,
                     const String& ldapPrefix_,
                     const String& rootContainerDn_,
                     AnalisysResults& res,
                     const String& reportName_
                  );

      void StepProgress();
      void FinishProgress();

   protected:

      friend long WINAPI startAnalisys(long arg);
      virtual ~AnalisysPage();
   


      // WizardPage overrides


      virtual
      bool
      OnSetActive();

      virtual
      void
      OnInit();
   
      virtual
      bool
      OnWizBack();

      virtual
      bool
      OnWizNext();

   private:
      AnalisysResults& results;
      const CSVDSReader& csvReader409;
      const CSVDSReader& csvReaderIntl;
      String ldapPrefix;
      String rootContainerDn;
      String reportName;

   private:
      long pos;


      // not defined: no copying allowed
      AnalisysPage(const AnalisysPage&);
      const AnalisysPage& operator=(const AnalisysPage&);
};



#endif   // ANALISYS_PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\common.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// code common to several pages
//
// 12-16-97 sburns



#include "headers.hxx"
#include "common.hpp"
#include "resource.h"
//#include "state.hpp"
//#include "ds.hpp"
//#include <DiagnoseDcNotFound.hpp>



// Creates the fonts for setLargeFonts().
// 
// hDialog - handle to a dialog to be used to retrieve a device
// context.
// 
// bigBoldFont - receives the handle of the big bold font created.

void
InitFonts(
   HWND     hDialog,
   HFONT&   bigBoldFont)
{

   LOG_FUNCTION(InitFonts);
   ASSERT(Win::IsWindow(hDialog));

   HRESULT hr = S_OK;

   do
   {
      NONCLIENTMETRICS ncm;
      memset(&ncm, 0, sizeof(ncm));
      ncm.cbSize = sizeof(ncm);

      hr = Win::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGFONT bigBoldLogFont = ncm.lfMessageFont;
      bigBoldLogFont.lfWeight = FW_BOLD;

      String fontName = String::load(IDS_BIG_BOLD_FONT_NAME);

      // ensure null termination 260237

      memset(bigBoldLogFont.lfFaceName, 0, LF_FACESIZE * sizeof(TCHAR));
      size_t fnLen = fontName.length();
      fontName.copy(
         bigBoldLogFont.lfFaceName,

         // don't copy over the last null

         min(LF_FACESIZE - 1, fnLen));

      unsigned fontSize = 0;
      String::load(IDS_BIG_BOLD_FONT_SIZE).convert(fontSize);
      ASSERT(fontSize);
 
      HDC hdc = 0;
      hr = Win::GetDC(hDialog, hdc);
      BREAK_ON_FAILED_HRESULT(hr);

      bigBoldLogFont.lfHeight =
         - ::MulDiv(
            static_cast<int>(fontSize),
            Win::GetDeviceCaps(hdc, LOGPIXELSY),
            72);

      hr = Win::CreateFontIndirect(bigBoldLogFont, bigBoldFont);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::ReleaseDC(hDialog, hdc);
   }
   while (0);
}



void
SetControlFont(HWND parentDialog, int controlID, HFONT font)
{
   LOG_FUNCTION(SetControlFont);
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(controlID);
   ASSERT(font);

   HWND control = Win::GetDlgItem(parentDialog, controlID);

   if (control)
   {
      Win::SetWindowFont(control, font, true);
   }
}



void
SetLargeFont(HWND dialog, int bigBoldResID)
{
   LOG_FUNCTION(SetLargeFont);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(bigBoldResID);

   static HFONT bigBoldFont = 0;
   if (!bigBoldFont)
   {
      InitFonts(dialog, bigBoldFont);
   }

   SetControlFont(dialog, bigBoldResID, bigBoldFont);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\finishpage.hpp ===
#ifndef FINISH_PAGE_HPP_INCLUDED
#define FINISH_PAGE_HPP_INCLUDED



class FinishPage : public WizardPage
{

   public:

   FinishPage
   (
      const bool someRepairWasRun_,
      const String &logPath_
   );

   protected:

   virtual ~FinishPage();


   // WizardPage overrides


   virtual
   bool
   OnSetActive();

   bool
   OnCommand(
   HWND        windowFrom,
   unsigned    controlIdFrom,
   unsigned    code);   

   virtual
   bool
   OnWizBack();


   private:
   bool someRepairWasRun;
   String logPath;

   // not defined: no copying allowed
   FinishPage(const FinishPage&);
   const FinishPage& operator=(const FinishPage&);
};



#endif   // FINISH_PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\display.cpp ===
// Display.cpp : Defines the entry point for the console application.
//

#include "headers.hxx"
#include <comdef.h>
#include <crtdbg.h>

#include "AdsiHelpers.hpp"
#include "CSVDSReader.hpp"
#include "AnalysisResults.hpp"
#include "Analysis.hpp"
#include "repair.hpp"
#include "resource.h"
#include "constants.hpp"
#include "WelcomePage.hpp"
#include "AnalysisPage.hpp"
#include "constants.hpp"
#include "UpdatesRequiredPage.hpp"
#include "UpdatesPage.hpp"
#include "FinishPage.hpp"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available

// don't change this: it is also the name of a mutex that the ui
// uses to determine if it is already running.

const wchar_t* RUNTIME_NAME = L"dspecup";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;

Popup popup(IDS_APP_TITLE, false);

// this is the mutex that indicates the program is running.

HANDLE appRunningMutex = INVALID_HANDLE_VALUE;



// these are the valid exit codes returned as the process exit code

enum ExitCode
{
   // the operation failed.

   EXIT_CODE_UNSUCCESSFUL = 0,

   // the operation succeeded

   EXIT_CODE_SUCCESSFUL = 1,
};





HRESULT
Start()
{
   LOG_FUNCTION(Start);

   HRESULT hr = S_OK;
   
   do
   {
      String targetDomainControllerName;
      String csvFileName,csv409Name;

      hr=GetInitialInformation(
                                 targetDomainControllerName,
                                 csvFileName,
                                 csv409Name
                              );

      BREAK_ON_FAILED_HRESULT(hr);

      AnalysisResults results;
      CSVDSReader csvReaderIntl;
      hr=csvReaderIntl.read(csvFileName.c_str(),LOCALEIDS);
      BREAK_ON_FAILED_HRESULT(hr);
   
      CSVDSReader csvReader409;
      hr=csvReader409.read(csv409Name.c_str(),LOCALE409);
      BREAK_ON_FAILED_HRESULT(hr);

      String rootContainerDn,ldapPrefix,domainName;
      hr=InitializeADSI(
            targetDomainControllerName,
            ldapPrefix,
            rootContainerDn,
            domainName);
      BREAK_ON_FAILED_HRESULT(hr);

      String reportName;

      hr=GetFileName(L"RPT",reportName);
      BREAK_ON_FAILED_HRESULT(hr);

      Analysis analysis(
         csvReader409, 
         csvReaderIntl,
         ldapPrefix,
         rootContainerDn,
         results,
         &reportName);
   
      hr=analysis.run();
      BREAK_ON_FAILED_HRESULT(hr);

      String ldiffName;

      hr=GetFileName(L"LDF",ldiffName);
      BREAK_ON_FAILED_HRESULT(hr);

      String csvName;

      hr=GetFileName(L"CSV",csvName);
      BREAK_ON_FAILED_HRESULT(hr);
   
      String saveName;

      hr=GetFileName(L"SAV",saveName);
      BREAK_ON_FAILED_HRESULT(hr);

      String logPath;

      hr=GetMyDocuments(logPath);
      if ( FAILED(hr) )
      {
         hr=Win::GetTempPath(logPath);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,String::format(IDS_NO_WORK_PATH));
      }

      Repair repair(
         csvReader409, 
         csvReaderIntl,
         domainName,
         rootContainerDn,
         results,
         ldiffName,
         csvName,
         saveName,
         logPath);

      hr=repair.run();
      BREAK_ON_FAILED_HRESULT(hr);

      hr=SetPreviousSuccessfullRun(
                                    ldapPrefix,
                                    rootContainerDn
                                  );
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      ShowError(hr,error);
   }

   LOG_HRESULT(hr);
   return hr;
}

HRESULT
StartUI()
{
   LOG_FUNCTION(StartUI);

   HRESULT hr = S_OK;

   String rootContainerDn,ldapPrefix,domainName;

   do
   {
      String targetDomainControllerName;
      String csvFileName,csv409Name;

      hr=GetInitialInformation(
                                 targetDomainControllerName,
                                 csvFileName,
                                 csv409Name
                              );
      BREAK_ON_FAILED_HRESULT(hr);
   
      AnalysisResults results;
      CSVDSReader csvReaderIntl;
      hr=csvReaderIntl.read(csvFileName.c_str(),LOCALEIDS);
      BREAK_ON_FAILED_HRESULT(hr);
   
      CSVDSReader csvReader409;
      hr=csvReader409.read(csv409Name.c_str(),LOCALE409);
      BREAK_ON_FAILED_HRESULT(hr);

   
      hr=InitializeADSI(
            targetDomainControllerName,
            ldapPrefix,
            rootContainerDn,
            domainName);
      BREAK_ON_FAILED_HRESULT(hr);



      Wizard wiz(
                  IDS_WIZARD_TITLE,
                  IDB_BANNER16,
                  IDB_BANNER256,
                  IDB_WATERMARK16,
                  IDB_WATERMARK256
                );



      wiz.AddPage(new WelcomePage());

      String reportName;

      hr=GetFileName(L"RPT",reportName);
      BREAK_ON_FAILED_HRESULT(hr);

   
      wiz.AddPage(
                     new   AnalysisPage
                           (
                              csvReader409,
                              csvReaderIntl,
                              ldapPrefix,
                              rootContainerDn,
                              results,
                              reportName
                           )
                 );


      wiz.AddPage(
                     new UpdatesRequiredPage
                     (
                        reportName,
                        results
                     )
                 );

      String ldiffName;

      hr=GetFileName(L"LDF",ldiffName);
      BREAK_ON_FAILED_HRESULT(hr);

      String csvName;

      hr=GetFileName(L"CSV",csvName);
      BREAK_ON_FAILED_HRESULT(hr);

      String saveName;

      hr=GetFileName(L"SAV",saveName);
      BREAK_ON_FAILED_HRESULT(hr);


      String logPath;

      hr=GetMyDocuments(logPath);
      if ( FAILED(hr) )
      {
         hr=Win::GetTempPath(logPath);
         BREAK_ON_FAILED_HRESULT_ERROR(hr,String::format(IDS_NO_WORK_PATH));
      }

      bool someRepairWasRun=false;

      wiz.AddPage(
                     new   UpdatesPage
                           (
                              csvReader409,
                              csvReaderIntl,
                              domainName,
                              rootContainerDn,
                              ldiffName,
                              csvName,
                              saveName,
                              logPath,
                              results,
                              &someRepairWasRun
                           )
                 );

      wiz.AddPage(
                     new FinishPage(
                                       someRepairWasRun,
                                       logPath
                                   )
                 );


      hr=wiz.ModalExecute(Win::GetDesktopWindow());


      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      ShowError(hr,error);
   }
   else
   {
      if(FAILED(hrError))
      {
         // The error has already been shown to the
         // user, we have only to return it
         hr=hrError;
      }
      else
      {

         hr=SetPreviousSuccessfullRun(
                                       ldapPrefix,
                                       rootContainerDn
                                     );
         if (FAILED(hr))
         {
            ShowError(hr,error);
         }
      }
   }

   LOG_HRESULT(hr);
   return hr;
}




int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE   /* hPrevInstance */ ,
   LPSTR     lpszCmdLine,
   int         /* nCmdShow */)
{
   LOG_FUNCTION(WinMain);

   hResourceModuleHandle = hInstance;

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;
   HRESULT hr;

   do
   {
      try
      {
         String cmdLine(lpszCmdLine);
         String noUI=String::format(IDS_NOUI);
         if (*lpszCmdLine!=0 && cmdLine.icompare(noUI)!=0)
         {
            error=String::format(IDS_USAGE);
            ShowError(E_FAIL,error);
            exitCode = EXIT_CODE_UNSUCCESSFUL;
            break;
         }


         hr = Win::CreateMutex(0, true, RUNTIME_NAME, appRunningMutex);
         if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
         {
            // The application is already running
            error=String::format(IDS_ALREADY_RUNNING);
            ShowError(E_FAIL,error);
            exitCode = EXIT_CODE_UNSUCCESSFUL;
            break;
         }
         else
         {
            hr = ::CoInitialize(0);
            ASSERT(SUCCEEDED(hr));

            INITCOMMONCONTROLSEX sex;
            sex.dwSize = sizeof(sex);      
            sex.dwICC  = ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES;
            BOOL init = ::InitCommonControlsEx(&sex);
            ASSERT(init);

            setReplaceW2KStrs();      

            if (*lpszCmdLine==0)
            {
               hr = StartUI();
            }
            else
            {
               hr = Start();
            }
            //hr=makeStrings();
            if (SUCCEEDED(hr))
            {
               exitCode = EXIT_CODE_SUCCESSFUL;
            }
            else
            {
               exitCode = EXIT_CODE_UNSUCCESSFUL;
            }
            CoUninitialize(); 
         }
      }
      catch( std::bad_alloc )
      {
        // Since we are in an out of memory condition.
        // we will not show any messages.
        // The allocation functions have already
        // shown the user this condition
        exitCode = EXIT_CODE_UNSUCCESSFUL;
      }
   } while(0);

   return static_cast<int>(exitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\common.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// code common to several pages
//
// 12-16-97 sburns



// Sets the font of a given control in a dialog.
// 
// parentDialog - Dialog containing the control.
// 
// controlID - Res ID of the control for which the font will be
// changed.
// 
// font - handle to the new font for the control.

void
SetControlFont(HWND parentDialog, int controlID, HFONT font);



// Sets the font of a control to a large point bold font as per Wizard '97
// spec.
// 
// dialog - handle to the dialog that is the parent of the control
// 
// bigBoldResID - resource id of the control to change

void
SetLargeFont(HWND dialog, int bigBoldResID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\finishpage.cpp ===
#include "headers.hxx"
#include "FinishPage.hpp"
#include "resource.h"
#include "common.hpp"
#include "global.hpp"

FinishPage::FinishPage
   (
      const bool someRepairWasRun_,
      const String &logPath_
   )
   :
   someRepairWasRun(someRepairWasRun_),
   logPath(logPath_),
   WizardPage(
      IDD_FINISH,
      IDS_FINISH_PAGE_TITLE,
      IDS_FINISH_PAGE_SUBTITLE,
      false)
{
   LOG_CTOR(FinishPage);
}

FinishPage::~FinishPage()
{
   LOG_DTOR(FinishPage);
}


bool
FinishPage::OnSetActive()
{
   LOG_FUNCTION(FinishPage::OnSetActive);

   // hrError was set in previous pages
   if(FAILED(hrError))
   {
      if(someRepairWasRun)
      {
         Win::ShowWindow(GetDlgItem(hwnd,IDC_FILE),SW_SHOW);
         Win::ShowWindow(GetDlgItem(hwnd,IDC_CLICK),SW_SHOW);
         Win::SetDlgItemText( hwnd,IDC_CLICK, IDS_IDC_CLICK_FAILURE);
      }
      Win::PropSheet_SetWizButtons(Win::GetParent(hwnd),
                                 PSWIZB_FINISH | PSWIZB_BACK);


      if(hrError!=E_FAIL)
      {
         error += L"\r\n" + GetErrorMessage(hrError);
      }
      
      Win::SetDlgItemText( hwnd,IDC_RESULT, error);

      Win::ShowWindow(GetDlgItem(hwnd,IDC_RESTART),SW_SHOW);
   }
   else
   {
      
      Win::SetDlgItemText( hwnd,IDC_RESULT, 
            String::format(IDC_RESULT_SUCCESS));

      Win::PropSheet_SetWizButtons(Win::GetParent(hwnd),
                                 PSWIZB_FINISH);
      Win::ShowWindow(GetDlgItem(hwnd,IDC_FILE),SW_SHOW);
      Win::ShowWindow(GetDlgItem(hwnd,IDC_CLICK),SW_SHOW);
      Win::SetDlgItemText( hwnd,IDC_CLICK, IDS_IDC_CLICK_SUCCESS);
   }
   return true;
}

bool
FinishPage::OnCommand(
                     HWND        /*windowFrom*/,
                     unsigned    controlIdFrom,
                     unsigned    code
                 )
{
   LOG_FUNCTION(FinishPage::OnCommand);
   switch (controlIdFrom)
   {
      case IDC_OPEN_LOG:
      {
         if (code == BN_CLICKED)
         {
            HRESULT hr=S_OK;
            do
            {
               String csvLog = logPath + L"\\csv.log";
               String ldifLog = logPath + L"\\ldif.log";
               if (FS::FileExists(csvLog))
               {
                  hr=Notepad(csvLog);
                  BREAK_ON_FAILED_HRESULT(hr);
               }
               if (FS::FileExists(ldifLog))
               {
                  hr=Notepad(ldifLog);
                  BREAK_ON_FAILED_HRESULT(hr);
               }
            } while(0);
            if (FAILED(hr))
            {
               ShowError(hr,error);
            }
         }
      }
   }
   return true;
}



bool
FinishPage::OnWizBack()
{
   LOG_FUNCTION(FinishPage::OnWizBack);
   GetWizard().SetNextPageID(hwnd,IDD_WELCOME);
   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDB_WATERMARK256                110
#define IDB_BANNER256                   111
#define IDB_WATERMARK16                 112
#define IDB_BANNER16                    113
#define IDD_WELCOME                     115
#define IDD_ANALISYS                    116
#define IDD_UPDATES_REQUIRED            117
#define IDD_UPDATES                     118
#define IDI_BIG_WARN                    119
#define IDD_FINISH                      119
#define IDC_TEST                        1000
#define IDC_BIG_BOLD_TITLE              1001
#define IDC_PROGRESS_ANALISYS           1001
#define IDC_INTRO1                      1002
#define IDC_ANALISYS_COMPLETE           1002
#define IDC_ANALISYS_RESULT             1002
#define IDC_INTRO2                      1003
#define IDC_DELETE_OBJECTS              1003
#define IDC_CREATE_OBJECTS              1004
#define IDC_UPDATE_OBJECTS              1005
#define IDC_VIEW_DETAILS                1007
#define IDC_UPDATE_COMPLETE             1008
#define IDC_OPEN_LOG                    1009
#define IDC_FILE                        1009
#define IDC_RESTART                     1010
#define IDC_RESULT                      1011
#define IDC_LOG                         1012
#define IDC_CLICK                       1012
#define IDC_PROGRESS_REPAIR             1017
#define IDC_BULLET1                     1035
#define IDC_BULLET2                     1036
#define IDC_BULLET3                     1037
#define IDS_APP_TITLE                   1501
#define IDS_CANT_TARGET_MACHINE         1502
#define IDS_DCPROMO_CSV_FILE_MISSING    1503
#define IDS_ERROR_LOOKING_FOR_CSV_FILE  1504
#define IDS_TARGET_IS_NOT_DC            1505
#define IDS_UNABLE_TO_CONNECT_TO_DC     1506
#define IDS_UNABLE_TO_READ_DIRECTORY_INFO 1507
#define IDS_ERROR_BINDING_TO_OBJECT     1508
#define IDS_ERROR_ENTRY                 1509
#define IDS_ERROR_GETING_FILE_NAME      1510
#define IDS_INVALID_CSV_UNICODE_ID      1511
#define IDS_MISSING_LOCALES             1512
#define IDS_OBJECT_NOT_FOUND_IN_CSV     1513
#define IDS_PROPERTY_NOT_FOUND_IN_CSV   1514
#define IDS_QUOTES_NOT_CLOSED           1515
#define IDS_COULD_NOT_CREATE_CSV        1516
#define IDS_NO_COMA_IN_CSV_LINE         1517
#define IDS_NO_CSV_VALUE                1518
#define IDS_ERROR_BINDING_TO_CONTAINER  1519
#define IDS_COULD_NOT_START_EXE         1521
#define IDS_EXE_NOT_FOUND               1522
#define IDS_NO_WORK_PATH                1524
#define IDS_ERROR_IMP_EXP_FILE          1525
#define IDS_COULD_NOT_CREATE_FILE       1526
#define IDS_NO_DOMAIN                   1527
#define IDS_WELCOME_PAGE_TITLE          1529
#define IDS_WELCOME_PAGE_SUBTITLE       1530
#define IDS_WIZARD_TITLE                1531
#define IDS_BIG_BOLD_FONT_NAME          1532
#define IDS_BIG_BOLD_FONT_SIZE          1533
#define IDS_ANALISYS_PAGE_TITLE         1534
#define IDS_ANALISYS_PAGE_SUBTITLE      1535
#define IDS_IDC_ANALISYS_COMPLETE       1536
#define IDS_UPDATES_REQUIRED_TITLE      1537
#define IDS_UPDATES_REQUIRED_SUBTITLE   1538
#define IDS_IDC_LOG_DETAILS             1539
#define IDS_IDC_LOG_ERRORS              1540
#define IDS_IDC_RESULT_SUCCESS          1541
#define IDS_IDC_RESULT_FAILURE          1542
#define IDS_UPDATES_REQUIRED_PAGE_TITLE 1543
#define IDS_UPDATES_REQUIRED_PAGE_SUBTITLE 1544
#define IDS_CREATE                      1545
#define IDS_UPDATE                      1546
#define IDS_DELETE                      1547
#define IDS_OBJECTS                     1548
#define IDS_FINISH_PAGE_SUBTITLE        1549
#define IDS_FINISH_PAGE_TITLE           1550
#define IDS_UPDATES_PAGE_TITLE          1551
#define IDS_UPDATES_PAGE_SUBTITLE       1552
#define IDS_CONTAINERS                  1553
#define IDS_AND                         1554
#define IDS_CREATED_FORMAT              1555
#define IDS_NUMBER_FORMAT               1556
#define IDS_VALUES                      1557
#define IDS_RPT_OBJECT_FORMAT           1558
#define IDS_RPT_CONTAINER_FORMAT        1559
#define IDS_RPT_ADD_VALUE_FORMAT        1560
#define IDS_RPT_DEL_VALUE_FORMAT        1561
#define IDS_RPT_CONFLICTINGXP           1563
#define IDS_RPT_ACTIONS                 1564
#define IDS_RPT_CREATEW2K               1565
#define IDS_RPT_CREATEXP                1566
#define IDS_RPT_CONTAINERS              1567
#define IDS_RPT_HEADER                  1568
#define IDS_CSVDE_LDIFDE_ERROR_COMPLETE 1569
#define IDS_CSVDE_LDIFDE_ERROR_BASIC    1570
#define IDS_IDC_ANALISYS_RESULT_INCOMPLETE 1571
#define IDS_IDC_ANALISYS_RESULT_COMPLETE 1572
#define IDS_ANALISYS_ERROR              1573
#define IDS_REPAIR_ERROR                1574
#define IDS_IDC_CLICK_SUCCESS           1575
#define IDS_IDC_CLICK_FAILURE           1576
#define IDC_RESULT_SUCCESS              1577
#define IDS_ALREADY_UPDATED             1578
#define IDS_USAGE                       1579
#define IDS_NOUI                        1580
#define IDS_ALREADY_RUNNING             1581
#define IDS_VALUE_NOT_IN_CSV            1582
#define IDS_NO_VALUE_IN_CSV             1583
#define IDS_MANY_CSV_VALUES             1584
#define IDS_CANT_WRITE_OBJECT_VERSION   1585
#define IDS_CANT_READ_OBJECT_VERSION    1586
#define IDS_NOT_ONE_CSV_VALUE           1587
#define IDS_RPT_CUSTOMIZED              1588
#define IDS_RPT_EXTRANEOUS              1589
#define IDS_RPT_VALUE_FORMAT            1590
#define IDS_NO_ANALISYS                 1591
#define IDS_OUT_OF_MEMORY               1592

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\global.cpp ===
#include "headers.hxx"
#include "global.hpp"
#include "resource.h"
#include "AdsiHelpers.hpp"

String error;
HRESULT hrError=S_OK;


// Keep all printable characters and escape the others.
// Escaping means representing the character as &xxxx
// where the x is an hexadecimal digit
// This routine also replaces & for &&
// The unescape function is in ..\global.cpp
String oldEscape(const wchar_t *str)
{
   LOG_FUNCTION(oldEscape);
   String dest;
   wchar_t strNum[5];

   while(*str!=0)
   {
      if(*str=='&') 
      {
         dest+=L"&&";
      }
      else
      {
         if (
               (*str >= L'a' && *str <= L'z') ||
               (*str >= L'A' && *str <= L'Z') ||
               (*str >= L'0' && *str <= L'9') ||
               wcschr(L" !@#$%^*()-_=+[{]}\"';:.>,</?\\|",*str)!=NULL
            )
         {
            dest+=*str;
         }
         else
         {
            // I know that a w_char as a string will have
            // exactly 4 hexadecimal digits, so this is one of
            // the very rare wsprintfs that can be considered safe :)
            wsprintf(strNum,L"&%04x",*str);
            dest+=String(strNum);
         }
      }
      str++;
   }
   return dest;
}




#define H(X) (\
                  (X>='a')?\
                  (\
                     (X-'a'+10)\
                  ):\
                  (\
                     (X>='A')?(X-'A'+10):(X-'0') \
                  )\
             )\



// Converts && to & and &xxxx to the coresponding digit
// There is no error checking. This function
// suposes the string is correctly escaped
// The escape function is in the folder preBuild as a part
// of the W2KStrs tool.
String unEscape(const String &str)
{
   LOG_FUNCTION(unEscape);
   String dest;
   String::const_iterator c=str.begin();
   String::const_iterator end=str.end();
   while(c!=end)
   {
      if(*c=='&') 
      {
         c++;
         if(*c=='&')
         {
            dest+=L'&';
         }
         else
         {
            wchar_t sTmp[2];
            sTmp[0]= static_cast<wchar_t> (
                                             (H(*c)<<12)+
                                             (H(*(c+1))<<8)+
                                             (H(*(c+2))<<4)+
                                             H(*(c+3)) 
                                          );
            sTmp[1]=0;
            dest+=sTmp;
            c+=3;
         }
      }
      else
      {
         dest+=*c;
      }
      c++;
   }
   return dest;
}

// Used in WinGetVLFilePointer.
LARGE_INTEGER zero={0};

//////////////// ReadLine 
#define CHUNK_SIZE 100

HRESULT
ReadLine(HANDLE handle, 
         String& text,
         bool *endLineFound_/*=NULL*/)
{
   LOG_FUNCTION(ReadLine); 
   ASSERT(handle != INVALID_HANDLE_VALUE);
   
   bool endLineFound=false;
   
   text.erase();
   
   // Acumulating chars read on text would cause the same
   // kind of reallocation and copy that text+=chunk will
   static wchar_t chunk[CHUNK_SIZE+1];
   HRESULT hr=S_OK;
   bool flagEof=false;
   
   do
   {
      LARGE_INTEGER pos;
      
      hr = WinGetVLFilePointer(handle,&pos);
      BREAK_ON_FAILED_HRESULT(hr);
      
      long nChunks=0;
      wchar_t *csr=NULL;
      
      while(!flagEof && !endLineFound)
      {
         DWORD bytesRead;
         
         hr = Win::ReadFile(
            handle,
            chunk,
            CHUNK_SIZE*sizeof(wchar_t),
            bytesRead,
            0);
         
         if(hr==EOF_HRESULT)
         {
            flagEof=true;
            hr=S_OK;
         }
         
         BREAK_ON_FAILED_HRESULT(hr);

         if(bytesRead==0)
         {
            flagEof=true;
         }
         else
         {
         
            *(chunk+bytesRead/sizeof(wchar_t))=0;
         
            csr=wcschr(chunk,L'\n');
         
            if(csr!=NULL)
            {
               pos.QuadPart+= sizeof(wchar_t)*
                  ((nChunks * CHUNK_SIZE) + (csr - chunk)+1);
               hr=Win::SetFilePointerEx(
                  handle,
                  pos,
                  0,
                  FILE_BEGIN);
            
               BREAK_ON_FAILED_HRESULT(hr);
            
               *csr=0;
               endLineFound=true;
            }
         
            text+=chunk;
            nChunks++;
         }
      }
      
      BREAK_ON_FAILED_HRESULT(hr);

      //We know the length will fit in a long
      // and we want IA64 to build.
      long textLen=static_cast<long>(text.length());

      if(textLen!=0 && endLineFound && text[textLen-1]==L'\r')
      {
         text.erase(textLen-1,1);
      }
   
      if(endLineFound_ != NULL)
      {
         *endLineFound_=endLineFound;
      }

      if(flagEof)
      {
         hr=EOF_HRESULT;
      }
   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}



//////////////// ReadLine 

HRESULT 
ReadAllFile(const String &fileName,
            String &fileStr)
{
   LOG_FUNCTION(ReadAllFile);

   HRESULT hr=S_OK;

   fileStr.erase();
   
   HANDLE file;
   hr=FS::CreateFile(fileName,
               file,
               GENERIC_READ);
   
   if(FAILED(hr))
   {
      error=fileName;
      LOG_HRESULT(hr);
      return hr;
   }

   do
   {
      bool flagEof=false;
      while(!flagEof)
      {
         String line;
         hr=ReadLine(file,line);
         if(hr==EOF_HRESULT)
         {
            hr=S_OK;
            flagEof=true;
         }
         BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
         fileStr+=line+L"\r\n";
      }
      BREAK_ON_FAILED_HRESULT_ERROR(hr,fileName);
   } while(0);

   if ( (fileStr.size() > 0) && (fileStr[0] == 0xfeff) )
   {
      fileStr.erase(0,1);
   }

   CloseHandle(file);

   LOG_HRESULT(hr);
   return hr;   
}


HRESULT
GetMyDocuments(String &myDoc)
{
   LOG_FUNCTION(GetMyDocuments);

   LPMALLOC pMalloc;
   HRESULT hr=S_OK;
   
   do //whoever breaks will go to return hr
   {
      hr=Win::SHGetMalloc(pMalloc);
      BREAK_ON_FAILED_HRESULT(hr);

      do // whoever breaks will go to pMalloc->Release();
      {
         LPITEMIDLIST pidl;
         hr=Win::SHGetSpecialFolderLocation(
                                             Win::GetDesktopWindow(),
                                             CSIDL_PERSONAL,
                                             pidl
                                           );
         BREAK_ON_FAILED_HRESULT(hr);

         myDoc=Win::SHGetPathFromIDList(pidl);
         if(myDoc.empty() || !FS::PathExists(myDoc))
         {
            hr=E_FAIL; // don't break to free pidl
         }

         pMalloc->Free(pidl);

      } while(0);

      pMalloc->Release();

   } while(0);

   LOG_HRESULT(hr);
   return hr;
}

HRESULT
GetTempFileName
(  
  const wchar_t   *lpPathName,      // directory name
  const wchar_t   *lpPrefixString,  // file name prefix
  String          &name             // file name 
)
{
   LOG_FUNCTION(GetTempFileName);

   ASSERT(FS::PathExists(lpPathName));

   HRESULT hr=S_OK;
   do
   {
      if (!FS::PathExists(lpPathName))
      {
         hr=Win32ToHresult(ERROR_FILE_NOT_FOUND);
         error=lpPathName;
         break;
      }

      DWORD result;
      wchar_t lpName[MAX_PATH]={0};

      result=::GetTempFileName(lpPathName,lpPrefixString,0,lpName);
      
      if (result == 0) 
      {
         hr = Win::GetLastErrorAsHresult();
         error=lpPathName;
         break;
      }

      name=lpName;

      if(FS::FileExists(name))
      {
         // GetTempFilename actually created the file !
         hr=Win::DeleteFile(lpName); 
         BREAK_ON_FAILED_HRESULT_ERROR(hr,name);
      }

   } while(0);
   
   LOG_HRESULT(hr);
   return hr;
}

// Retrieves a unique temporary file name
HRESULT 
GetWorkTempFileName
(
   const wchar_t     *lpPrefixString,
   String            &name
)
{
   LOG_FUNCTION(GetWorkTempFileName);

   HRESULT hr=S_OK;
   String path;
   do
   {
      hr=GetMyDocuments(path);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,String::format(IDS_NO_WORK_PATH));

      hr=GetTempFileName(path.c_str(),lpPrefixString,name);
      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);

   LOG_HRESULT(hr);
   return hr;
}



// locate the file with the highest-numbered extension, then add 1 and
// return the result.
int
DetermineNextFileNumber
(
   const String&     dir,
   const String&     baseName,
   const wchar_t     extension[4]
)
{
   LOG_FUNCTION(DetermineNextFileNumber);
   ASSERT(!dir.empty());
   ASSERT(!baseName.empty());

   int largest = 0;

   String filespec = dir + L"\\" + baseName + L".*."+ extension;

   WIN32_FIND_DATA findData;
   HANDLE ff = ::FindFirstFile(filespec.c_str(), &findData);

   if (ff != INVALID_HANDLE_VALUE)
   {
      for (;;)
      {
         String current = findData.cFileName;

         // grab the text between the dots: "nnn" in foo.nnn.ext

         // first dot

         size_t pos = current.find(L".");
         if (pos == String::npos)
         {
            continue;
         }

         String extension = current.substr(pos + 1);

         // second dot

         pos = extension.find(L".");
         if (pos == String::npos)
         {
            continue;
         }
   
         extension = extension.substr(0, pos);

         int i = 0;
         extension.convert(i);
         largest = max(i, largest);

         if (!::FindNextFile(ff, &findData))
         {
            BOOL success = ::FindClose(ff);
            ASSERT(success);

            break;
         }
      }
   }

   // roll over after 255
   
   return (++largest & 0xFF);
}

// auxiliary in GetWorkFileName
void 
GetFileName
(
   const String&     dir,
   const String&     baseName,
   const wchar_t     extension[4],
   String            &fileName
)
{
   LOG_FUNCTION(GetFileName);
   int logNumber = DetermineNextFileNumber(dir,baseName,extension);
   fileName = dir
               +  L"\\"
               +  baseName
               +  String::format(L".%1!03d!.", logNumber)
               +  extension;

   if (::GetFileAttributes(fileName.c_str()) != 0xFFFFFFFF)
   {
      // could exist, as the file numbers roll over

      BOOL success = ::DeleteFile(fileName.c_str());
      ASSERT(success);
   }
}



// Retrieves a unique file name
HRESULT 
GetWorkFileName
(
   const String&     baseName,
   const wchar_t     *extension,
   String            &name
)
{
   LOG_FUNCTION(GetWorkFileName);

   HRESULT hr=S_OK;
   String path;
   do
   {
      hr=GetMyDocuments(path);
      BREAK_ON_FAILED_HRESULT_ERROR(hr,String::format(IDS_NO_WORK_PATH));
      GetFileName(path.c_str(),baseName,extension,name);
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}


HRESULT 
Notepad(const String& file)
{
   LOG_FUNCTION(Notepad);
   HRESULT hr=S_OK;
   do
   {
      STARTUPINFO si;
      PROCESS_INFORMATION pi;
      GetStartupInfo(&si);

      String curDir = L"";
      String prg = L"notepad " + file;

      hr=Win::CreateProcess
        (
            prg,
            NULL,    // lpProcessAttributes
            NULL,    // lpThreadAttributes
            false,   // dwCreationFlags 
            NORMAL_PRIORITY_CLASS,// fdwCreate 
            NULL,    // lpEnvironment 
            curDir,  // lpEnvironment 
            si,     // [in] lpStartupInfo 
            pi      // [out] pProcessInformation
        );
      BREAK_ON_FAILED_HRESULT_ERROR(hr,
         String::format(IDS_COULD_NOT_START_EXE,L"notepad"));

      CloseHandle(pi.hProcess);
      CloseHandle(pi.hThread);
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}

HRESULT 
GetPreviousSuccessfullRun(
                           const String &ldapPrefix,
                           const String &rootContainerDn,
                           bool &result
                         )
{
   LOG_FUNCTION(GetPreviousSuccessfullRun);

   ASSERT(!ldapPrefix.empty());
   ASSERT(!rootContainerDn.empty());

   HRESULT hr = S_OK;
   result=false;

   do
   {
      String objectPath = ldapPrefix + rootContainerDn;
      SmartInterface<IADs> iads(0);
      hr = AdsiOpenObject<IADs>(objectPath, iads);

      BREAK_ON_FAILED_HRESULT(hr);

      _variant_t variant;

      hr = iads->Get(AutoBstr(L"objectVersion"), &variant);
      if(hr==E_ADS_PROPERTY_NOT_FOUND)
      {
         result=false;
         hr=S_OK;
         break;
      }
      else if (FAILED(hr))
      {
         hr=E_FAIL;
         error=String::format(IDS_CANT_READ_OBJECT_VERSION);
         break;
      }

      result = (variant.lVal==1);

   }
   while (0);

   LOG_HRESULT(hr);
   return hr;
}

HRESULT 
SetPreviousSuccessfullRun(
                           const String &ldapPrefix,
                           const String &rootContainerDn
                         )
{
   LOG_FUNCTION(SetPreviousSuccessfullRun);

   ASSERT(!ldapPrefix.empty());
   ASSERT(!rootContainerDn.empty());


   HRESULT hr = S_OK;

   do
   {
      String objectPath = ldapPrefix + rootContainerDn;
      SmartInterface<IADs> iads(0);
      hr = AdsiOpenObject<IADs>(objectPath, iads);
      BREAK_ON_FAILED_HRESULT(hr);
      _variant_t variant(1L);
      hr = iads->Put(AutoBstr(L"objectVersion"), variant);
      BREAK_ON_FAILED_HRESULT(hr);
      hr = iads->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      hr=E_FAIL;
      error=String::format(IDS_CANT_WRITE_OBJECT_VERSION);
   }

   LOG_HRESULT(hr);
   return hr;
}

HRESULT 
getADLargeInteger(
       IDirectoryObject *iDirObj,
       wchar_t *name,
       ADS_LARGE_INTEGER &value)
{
   LOG_FUNCTION(getADLargeInteger);
   HRESULT hr=S_OK;
   do
   {
      LPWSTR nameArray[]={name};
      DWORD nAttr;
      PADS_ATTR_INFO attr;
      hr = iDirObj->GetObjectAttributes(nameArray,1,&attr,&nAttr);
      BREAK_ON_FAILED_HRESULT(hr);
      value=attr->pADsValues->LargeInteger;
   } while(0);

   LOG_HRESULT(hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\showerror.cpp ===
void ShowError(HRESULT hr,
               const String &message)
{
   LOG_FUNCTION(ShowError);

   if(hr==E_FAIL)
   {
      popup.Error(Win::GetDesktopWindow(),message);
   }
   else
   {
      if(message.empty())
      {
         popup.Error(Win::GetDesktopWindow(),GetErrorMessage(hr));
      }
      else
      {
         popup.Error(Win::GetDesktopWindow(),hr,message);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\updatesrequiredpage.cpp ===
#include "headers.hxx"
#include "UpdatesRequiredPage.hpp"
#include "resource.h"
#include "common.hpp"
#include "AnalisysResults.hpp"

UpdatesRequiredPage::UpdatesRequiredPage
   (
      const String& reportName_,
      AnalisysResults &results_
   )
   :
   reportName(reportName_),
   results(results_),
   WizardPage
   (
      IDD_UPDATES_REQUIRED,
      IDS_UPDATES_REQUIRED_PAGE_TITLE,
      IDS_UPDATES_REQUIRED_PAGE_SUBTITLE,
      true
   )
{
   LOG_CTOR(UpdatesRequiredPage);
}

UpdatesRequiredPage::~UpdatesRequiredPage()
{
   LOG_DTOR(UpdatesRequiredPage);
}


// WizardPage overrides

bool
UpdatesRequiredPage::OnSetActive()
{
   LOG_FUNCTION(UpdatesRequiredPage::OnSetActive);

   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd),
                                 PSWIZB_NEXT | PSWIZB_BACK);
   return true;
}

bool
UpdatesRequiredPage::OnCommand(
                                 HWND        /*windowFrom*/,
                                 unsigned    controlIdFrom,
                                 unsigned    code
                              )
{
   LOG_FUNCTION(UpdatesRequiredPage::OnCommand);
   switch (controlIdFrom)
   {
      case IDC_VIEW_DETAILS:
      {
         if (code == BN_CLICKED)
         {
            ShowReport();
         }
      }
   }
   return true;
}


bool
UpdatesRequiredPage::OnWizBack()
{
   LOG_FUNCTION(UpdatesRequiredPage::OnWizBack);
   GetWizard().SetNextPageID(hwnd,IDD_ANALISYS);
   return true;
}


void
UpdatesRequiredPage::OnInit()
{
   LOG_FUNCTION(UpdatesRequiredPage::OnInit);

   
   long created = results.createW2KObjects.size() + 
                  results.createXPObjects.size();

   long updated = results.objectActions.size();

   long containers = results.createContainers.size();

   String sCreated,sUpdated;

   if( containers==0)
   {
      sCreated = String::format( 
                                 String::load(IDS_NUMBER_FORMAT).c_str(),
                                 created,
                                 String::load(IDS_OBJECTS).c_str() 
                               );
   }
   else
   {
      sCreated = String::format( 
                                 String::load(IDS_CREATED_FORMAT).c_str(),
                                 created,
                                 String::load(IDS_OBJECTS).c_str(),
                                 String::load(IDS_AND).c_str(), 
                                 containers,
                                 String::load(IDS_CONTAINERS).c_str() 
                               );
   }


   sUpdated = String::format( 
                              String::load(IDS_NUMBER_FORMAT).c_str(),
                              updated,
                              String::load(IDS_VALUES).c_str() 
                            );



   Win::SetDlgItemText( hwnd,IDC_CREATE_OBJECTS, sCreated);
   
   Win::SetDlgItemText( hwnd,IDC_UPDATE_OBJECTS, sUpdated);


   HFONT
   bulletFont = CreateFont(
                   0,
                   0,
                   0,
                   0,
                   FW_NORMAL,
                   0,
                   0,
                   0,
                   SYMBOL_CHARSET,
                   OUT_CHARACTER_PRECIS,
                   CLIP_CHARACTER_PRECIS,
                   PROOF_QUALITY,
                   VARIABLE_PITCH|FF_DONTCARE,
                   L"Marlett");

   if (bulletFont)
   {
      Win::SetDlgItemText(hwnd,IDC_BULLET1,L"h");
      Win::SetDlgItemText(hwnd,IDC_BULLET2,L"h");
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET1), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET2), bulletFont, true);
   }

};



// This function is void because if we cannot show
// the report, this is not a fatal error
void
UpdatesRequiredPage::ShowReport()
{
   LOG_FUNCTION(UpdatesRequiredPage::ShowReport);
   HRESULT hr=S_OK;
   do
   {
      hr=Notepad(reportName);
      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);

   if (FAILED(hr))
   {
      ShowError(hr,error);
   }

   LOG_HRESULT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\updatesrequiredpage.hpp ===
#ifndef UPDATES_REQUIRED_PAGE_HPP_INCLUDED
#define UPDATES_REQUIRED_PAGE_HPP_INCLUDED

#include "AnalisysResults.hpp"

class UpdatesRequiredPage : public WizardPage
{

   public:

      UpdatesRequiredPage
      (
         const String& reportName_,
         AnalisysResults &results_
      );

   protected:

      virtual ~UpdatesRequiredPage();


      // WizardPage overrides


      virtual
      bool
      OnSetActive();

      virtual
      void
      OnInit();

      virtual
      bool
      OnWizBack();

      bool
      OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   private:
   
      AnalisysResults &results;
      String reportName;
      

      void
      ShowReport();

      // not defined: no copying allowed
      UpdatesRequiredPage(const UpdatesRequiredPage&);
      const UpdatesRequiredPage& operator=(const UpdatesRequiredPage&);
};



#endif   // UPDATES_REQUIRED_PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\updatespage.hpp ===
#ifndef UPDATES_PAGE_HPP_INCLUDED
#define UPDATES_PAGE_HPP_INCLUDED

struct AnalisysResults;
class CSVDSReader;

class UpdatesPage : public WizardPage
{

   public:

   UpdatesPage
   (
      const CSVDSReader& csvReader409_,
      const CSVDSReader& csvReaderIntl_,
      const String& domain_,
      const String& rootContainerDn_,
      const String& ldiffName_,
      const String& csvName_,
      const String& saveName_,
      const String& logPath_,
      AnalisysResults& res_,
      bool *someRepairWasRun_
   );

   void StepProgress(long steps);
   void FinishProgress();


   protected:

   friend long WINAPI startRepair(long arg);
   virtual ~UpdatesPage();


   // WizardPage overrides


   virtual
   bool
   OnSetActive();



   private:
   
   long pos;

   AnalisysResults& results;
   const CSVDSReader& csvReader409;
   const CSVDSReader& csvReaderIntl;
   const String domain;
   const String rootContainerDn;
   const String ldiffName;
   const String csvName;
   const String saveName;
   const String logPath;
   bool *someRepairWasRun;


   // not defined: no copying allowed
   UpdatesPage(const UpdatesPage&);
   const UpdatesPage& operator=(const UpdatesPage&);
};



#endif   // UPDATES_PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\welcomepage.cpp ===
#include "headers.hxx"
#include "WelcomePage.hpp"
#include "resource.h"
#include "common.hpp"
#include "global.hpp"


WelcomePage::WelcomePage()
   :
   WizardPage(
      IDD_WELCOME,
      IDS_WELCOME_PAGE_TITLE,
      IDS_WELCOME_PAGE_SUBTITLE,
      false)
{
   LOG_CTOR(WelcomePage);
}

WelcomePage::~WelcomePage()
{
   LOG_DTOR(WelcomePage);
}


// WizardPage overrides

bool
WelcomePage::OnSetActive()
{
   LOG_FUNCTION(WelcomePage::OnSetActive);
   EnableWindow(GetDlgItem(Win::GetParent(hwnd),IDCANCEL),true);
   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_NEXT);
   return true;
}

void
WelcomePage::OnInit()
{
   LOG_FUNCTION(WelcomePage::OnInit);
   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);

   Win::PropSheet_SetTitle(
      Win::GetParent(hwnd),     
      0,
      String::load(IDS_WIZARD_TITLE));
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\updatespage.cpp ===
#include "headers.hxx"
#include "UpdatesPage.hpp"
#include "resource.h"
#include "common.hpp"

#include "repair.hpp"
#include "AnalisysResults.hpp"
#include "CSVDSReader.hpp"


UpdatesPage::UpdatesPage
   (
      const CSVDSReader& csvReader409_,
      const CSVDSReader& csvReaderIntl_,
      const String& domain_,
      const String& rootContainerDn_,
      const String& ldiffName_,
      const String& csvName_,
      const String& saveName_,
      const String& logPath_,
      AnalisysResults& res,
      bool *someRepairWasRun_
   )
   :
   csvReader409(csvReader409_),
   csvReaderIntl(csvReaderIntl_),
   domain(domain_),
   rootContainerDn(rootContainerDn_),
   ldiffName(ldiffName_),
   csvName(csvName_),
   saveName(saveName_),
   logPath(logPath_),
   results(res),
   someRepairWasRun(someRepairWasRun_),
   WizardPage
   (
      IDD_UPDATES,
      IDS_UPDATES_PAGE_TITLE,
      IDS_UPDATES_PAGE_SUBTITLE,
      true
   )
{
   LOG_CTOR(UpdatesPage);
}

UpdatesPage::~UpdatesPage()
{
   LOG_DTOR(UpdatesPage);
}


long WINAPI startRepair(long arg)
{
   LOG_FUNCTION(startRepair);

   UpdatesPage *page=(UpdatesPage *)arg;

   HRESULT hr=S_OK;
   do
   {
      // CoInitialize must be called per thread
      hr = ::CoInitialize(0);
      ASSERT(SUCCEEDED(hr));

      Repair   repair
               (
                  page->csvReader409, 
                  page->csvReaderIntl,
                  page->domain,
                  page->rootContainerDn,
                  page->results,
                  page->ldiffName,
                  page->csvName,
                  page->saveName,
                  page->logPath,
                  page,
                  page->someRepairWasRun
               );


      HWND prog=GetDlgItem(page->hwnd,IDC_PROGRESS_REPAIR);
   
      long nProgress=repair.getTotalProgress();
      SendMessage(prog,PBM_SETRANGE,0,MAKELPARAM(0, nProgress)); 
      hr=repair.run();

      CoUninitialize();

      BREAK_ON_FAILED_HRESULT(hr);

   } while(0);

   hrError=hr;
   page->FinishProgress();
   return 0;
}


bool
UpdatesPage::OnSetActive()
{
   LOG_FUNCTION(UpdatesPage::OnSetActive);

   EnableWindow(GetDlgItem(Win::GetParent(hwnd),IDCANCEL),false);
   Win::PropSheet_SetWizButtons(
                                 Win::GetParent(hwnd),
                                 0
                               );

   pos=0;

   HANDLE hA=CreateThread( 
                           NULL,0,
                           (LPTHREAD_START_ROUTINE) startRepair,
                           this,
                           0, 0 
                         );
   CloseHandle(hA);
   return true;
}


void UpdatesPage::StepProgress(long steps)
{
   LOG_FUNCTION(UpdatesPage::StepProgress);

   HWND prog=GetDlgItem(hwnd,IDC_PROGRESS_REPAIR);
   pos+=steps;
   SendMessage(prog,PBM_SETPOS,pos,0);
}


void UpdatesPage::FinishProgress()
{
   LOG_FUNCTION(UpdatesPage::FinishProgress);
   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd),PSWIZB_NEXT);

   if (FAILED(hrError))
   {
      error=String::format(IDS_REPAIR_ERROR,error.c_str());
   }


   HWND text=GetDlgItem(hwnd,IDC_UPDATE_COMPLETE);
   Win::ShowWindow(text,SW_SHOW);

   Win::PropSheet_SetWizButtons(
                                 Win::GetParent(hwnd),
                                 PSWIZB_NEXT
                               );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\inc\dsutils.h ===
// libraryname component of the ProgID of the dsutils COM objects
// use to compose ProgIDs, e.g. DSUTILS_LIBNAME_STRING L".yourclassname.ver"

#define DSUTILS_LIBNAME_STRING L"DSUtils"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\displayspecifierupgrade\uiarchive\welcomepage.hpp ===
#ifndef WELCOME_PAGE_HPP_INCLUDED
#define WELCOME_PAGE_HPP_INCLUDED



class WelcomePage : public WizardPage
{

   public:

   WelcomePage();

   protected:

   virtual ~WelcomePage();


   // WizardPage overrides

   virtual
   void
   OnInit();

   virtual
   bool
   OnSetActive();


   private:

   // not defined: no copying allowed
   WelcomePage(const WelcomePage&);
   const WelcomePage& operator=(const WelcomePage&);
};



#endif   // WELCOME_PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\migrate\clonepr\common.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// common routines
//
// sburns 5-3-99



#include "headers.hxx"
#include "common.hpp"



void
SetComError(
   unsigned descriptionMessageResID,
   DWORD    helpContext)
{
   SetComError(String::load(descriptionMessageResID), helpContext);
}



void
SetComError(
   const String&  description,
   DWORD          helpContext)
{
   LOG_FUNCTION2(SetComError, description);

   ICreateErrorInfo* cei = 0;
   HRESULT hr = S_OK;

   do
   {
      hr = ::CreateErrorInfo(&cei);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetGUID(IID_ICloneSecurityPrincipal);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetSource(PROGID_VERSION_STRING);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         cei->SetDescription(
            const_cast<String::value_type*>(description.c_str()));
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetHelpFile(L"" /* HELPFILE_NAME */ );
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetHelpContext(helpContext);
      BREAK_ON_FAILED_HRESULT(hr);

      SmartInterface<IErrorInfo> ei;
      hr = ei.AcquireViaQueryInterface(*cei);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = ::SetErrorInfo(0, ei);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (cei)
   {
      cei->Release();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\migrate\clonepr\common.hpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// common routines 
//
// sburns 5-3-99



void
SetComError(
   const String&  desciption,
   DWORD          helpContext = 0);

void
SetComError(
   unsigned descriptionMessageResID,
   DWORD    helpContext = 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\migrate\clonepr\copyuser.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Implementation of ICloneSecurityPrincipal::CopyDownlevelUserProperties
//
// sburns 5-14-99



#include "headers.hxx"
#include "resource.h"
#include "common.hpp"
#include "implmain.hpp"



// caller must close the handle with SamCloseHandle

HRESULT
OpenSamUser(
   const String&  samName,
   SAM_HANDLE     domainSamHandle,
   SAM_HANDLE&    resultSamHandle)
{
   LOG_FUNCTION2(OpenSamUser, samName);
   ASSERT(!samName.empty());
   ASSERT(domainSamHandle != INVALID_HANDLE_VALUE);
   ASSERT(resultSamHandle == INVALID_HANDLE_VALUE);

   resultSamHandle = INVALID_HANDLE_VALUE;   

   HRESULT       hr   = S_OK;
   ULONG*        rids = 0;   
   PSID_NAME_USE use  = 0;   
   do
   {
      LOG(L"Calling SamLookupNamesInDomain");

      UNICODE_STRING userName;
      ::RtlInitUnicodeString(&userName, samName.c_str());

      hr =
         NtStatusToHRESULT(
            ::SamLookupNamesInDomain(
               domainSamHandle,
               1,
               &userName,
               &rids,
               &use));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_SAM_USER_NOT_FOUND,
               samName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }
      if (!use || *use != SidTypeUser)    // prefix 111381
      {
         hr = Win32ToHresult(ERROR_NO_SUCH_USER);
         SetComError(
            String::format(
               IDS_SAM_NAME_IS_NOT_USER,
               samName.c_str()));
         break;
      }

      LOG(L"Calling SamOpenUser");

      hr = 
         NtStatusToHRESULT(
            ::SamOpenUser(
                domainSamHandle,
                MAXIMUM_ALLOWED,
                rids[0],
                &resultSamHandle));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_OPEN_SAM_USER_FAILED,
               samName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      ASSERT(resultSamHandle != INVALID_HANDLE_VALUE);
   }
   while (0);

   if (rids)
   {
      ::SamFreeMemory(rids);
   }
   if (use)
   {
      ::SamFreeMemory(use);
   }

   return hr;
}



HRESULT
CloneSecurityPrincipal::DoCopyDownlevelUserProperties(
   const String& srcSamName,
   const String& dstSamName,
   long          flags)
{
   LOG_FUNCTION(CloneSecurityPrincipal::DoCopyDownlevelUserProperties);

   if (srcSamName.empty())
   {
      SetComError(IDS_MISSING_SRC_SAM_NAME);
      return E_INVALIDARG;
   }

   if (flags)
   {
      // not used, should be 0
      SetComError(IDS_FLAGS_ARE_UNUSED);
      return E_INVALIDARG;
   }

   if (!connection || !connection->IsConnected())
   {
      SetComError(IDS_MUST_CONNECT_FIRST);
      return Win32ToHresult(ERROR_ONLY_IF_CONNECTED);
   };

   // At this point, the Computer objects contain the normalized
   // source and destination DC names, and their domains, and any
   // necessary authenticated connections to those DCs have been
   // established.

   HRESULT hr = S_OK;
   SAM_HANDLE userSamHandle = INVALID_HANDLE_VALUE;
   USER_ALL_INFORMATION* allInfo = 0;

   do
   {
      // get a handle to the source user

      hr =
         OpenSamUser(
            srcSamName,
            connection->srcDomainSamHandle,
            userSamHandle);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"Calling SamQueryInformationUser");

      hr =
         NtStatusToHRESULT(
            ::SamQueryInformationUser(
               userSamHandle,
               UserAllInformation,
               reinterpret_cast<void**>(&allInfo)));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_QUERY_SAM_USER_FAILED,
               srcSamName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      ::SamCloseHandle(userSamHandle);
      userSamHandle = INVALID_HANDLE_VALUE;

      // get a handle to the target user

      hr =
         OpenSamUser(
            dstSamName,
            connection->dstDomainSamHandle,
            userSamHandle);
      BREAK_ON_FAILED_HRESULT(hr);

      
      ULONG* rids = 0;
      PSID_NAME_USE use = 0;

      UNICODE_STRING userName;
         ::RtlInitUnicodeString(&userName, dstSamName.c_str());

      hr =
         NtStatusToHRESULT(
            ::SamLookupNamesInDomain(
               connection->dstDomainSamHandle,
               1,
               &userName,
               &rids,
               &use));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_SAM_USER_NOT_FOUND,
               dstSamName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }
      if (*use != SidTypeUser)
      {
         hr = Win32ToHresult(ERROR_NO_SUCH_USER);
         SetComError(
            String::format(
               IDS_SAM_NAME_IS_NOT_USER,
               dstSamName.c_str()));
         break;
      }

      allInfo->WhichFields =
            USER_ALL_FULLNAME
         |  USER_ALL_ADMINCOMMENT
         |  USER_ALL_USERCOMMENT
         |  USER_ALL_HOMEDIRECTORY
         |  USER_ALL_HOMEDIRECTORYDRIVE
         |  USER_ALL_SCRIPTPATH
         |  USER_ALL_PROFILEPATH
         |  USER_ALL_WORKSTATIONS
         |  USER_ALL_LOGONHOURS
         //  USER_ALL_BADPASSWORDCOUNT
        //|  USER_ALL_PASSWORDCANCHANGE
        //|  USER_ALL_PASSWORDMUSTCHANGE
        //|  USER_ALL_USERACCOUNTCONTROL

         // this is the reason for all this nonsense
         |  USER_ALL_PARAMETERS

         |  USER_ALL_COUNTRYCODE
         |  USER_ALL_CODEPAGE
         //|  USER_ALL_PASSWORDEXPIRED*/
         ;

         if( *rids != 500 )
            allInfo->WhichFields |=  USER_ALL_ACCOUNTEXPIRES;

         if (rids)
         {
            ::SamFreeMemory(rids);
         }
         if (use)
         {
            ::SamFreeMemory(use);
         }

      // @@ why is user cannot change password not transferring?

      LOG(L"Calling SamSetInformationUser");

      hr =
         NtStatusToHRESULT(
            ::SamSetInformationUser(
               userSamHandle,
               UserAllInformation,
               allInfo));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_SET_SAM_USER_FAILED,
               dstSamName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }
   }
   while (0);

   if (userSamHandle != INVALID_HANDLE_VALUE)
   {
      ::SamCloseHandle(userSamHandle);
   }
   if (allInfo)
   {
      ::SamFreeMemory(allInfo);
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\migrate\clonepr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDS_MUST_SPECIFY_SRC_DC_OR_DOMAIN              1001
#define IDS_MUST_SPECIFY_DST_DC_OR_DOMAIN              1002
#define IDS_SRC_DC_EQUALS_DST_DC                       1003
#define IDS_SRC_DOMAIN_EQUALS_DST_DOMAIN               1004
#define IDS_COMPUTER_IS_NOT_DC                         1005
#define IDS_NOT_DC_FOR_WRONG_DOMAIN                    1006
#define IDS_CANT_FIND_DC                               1007
#define IDS_UNABLE_TO_CONNECT                          1008
#define IDS_MISSING_SRC_SAM_NAME                       1009
#define IDS_FLAGS_ARE_UNUSED                           1010
#define IDS_UNABLE_TO_READ_COMPUTER_INFO               1011
#define IDS_BIND_FAILED                                1012
#define IDS_ADD_SID_HISTORY_FAILED                     1013
#define IDS_MUST_CONNECT_FIRST                         1014
#define IDS_BAD_USERNAME                               1015
#define IDS_UNABLE_TO_CONNECT_TO_SAM_SERVER            1016
#define IDS_UNABLE_TO_LOOKUP_SAM_DOMAIN                1017
#define IDS_UNABLE_TO_OPEN_SAM_DOMAIN                  1018
#define IDS_SAM_USER_NOT_FOUND                         1019
#define IDS_SAM_NAME_IS_NOT_USER                       1020
#define IDS_OPEN_SAM_USER_FAILED                       1021
#define IDS_QUERY_SAM_USER_FAILED                      1022
#define IDS_SET_SAM_USER_FAILED                        1023
#define IDS_ADD_SID_HISTORY_FAILED_WITH_INVALID_HANDLE 1024
#define IDS_ADSI_EXTENDED_ERROR                        1029
#define IDS_LDAPOPEN_FAILED                            1030
#define IDS_LDAPBIND_FAILED                            1031
#define IDS_OBJECT_STATE_BAD                           1032
#define IDS_OUT_OF_MEMORY                              1033
#define IDS_GET_DC_INFO_FAILED                         1034
#define IDS_CANT_FIND_SRC_DC_DNS_NAME 1035

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\migrate\clonepr\dllmain.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// DllMain and COM DllXxx functions
//
// sburns 5-3-99



#include "headers.hxx"
#include "implmain.hpp"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME = L"clonepr";

DWORD DEFAULT_LOGGING_OPTIONS = OUTPUT_MUTE;

TCHAR   g_szFileName[MAX_PATH];


struct REG_DATA
{
    const wchar_t *keyName;
    const wchar_t *valueName;
    const wchar_t *value;
};



const REG_DATA g_rgEntries[] =
{
   {
      L"CLSID\\" CLSID_STRING,
      0,
      CLASSNAME_STRING
   },
   { 
      L"CLSID\\" CLSID_STRING L"\\InprocServer32",
      0,
      g_szFileName
   },
   { 
      L"CLSID\\" CLSID_STRING L"\\InprocServer32",
      L"ThreadingModel",
      L"Apartment"
   },
   {
      L"CLSID\\" CLSID_STRING L"\\ProgID",
      0,
      PROGID_VERSION_STRING
   },
   {
      L"CLSID\\" CLSID_STRING L"\\VersionIndependentProgID",
      0,
      PROGID_STRING
   },
   {
      PROGID_VERSION_STRING,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_VERSION_STRING L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_STRING L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING L"\\CurVer",
      0,
      PROGID_VERSION_STRING
   },

   // register for IADsSID
   {
      PROGID_VERSION_STRING_ADSSID,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_VERSION_STRING_ADSSID L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING_ADSSID,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_STRING_ADSSID L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING_ADSSID L"\\CurVer",
      0,
      PROGID_VERSION_STRING_ADSSID
   },

   // register for IADsError
   {
      PROGID_VERSION_STRING_ADSERROR,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_VERSION_STRING_ADSERROR L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING_ADSERROR,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_STRING_ADSERROR L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING_ADSERROR L"\\CurVer",
      0,
      PROGID_VERSION_STRING_ADSERROR
   }
};

const int g_cEntries = sizeof(g_rgEntries)/sizeof(*g_rgEntries);

static
HRESULT
Unregister(const REG_DATA *rgEntries, int cEntries)
{
   LOG_FUNCTION(Unregister);

   LOG(L"Calling UnRegisterTypeLib");

   HRESULT hr =
      ::UnRegisterTypeLib(LIBID_CloneSecurityPrincipalLib, 1, 0, 0, SYS_WIN32);

   LOG_HRESULT(hr);

   // don't break: continue on attempting to remove as much as possible
   // of our registration

   bool success = SUCCEEDED(hr);
   for (int i = cEntries - 1; i >= 0; i--)
   {
      LONG err = ::RegDeleteKey(HKEY_CLASSES_ROOT, rgEntries[i].keyName);
      if (err != ERROR_SUCCESS)
      {
         success = false;
      }
   }

   return success ? S_OK : S_FALSE;
}



static HRESULT Register(const REG_DATA *rgEntries, int cEntries)
{

   BOOL bSuccess = TRUE;
   HRESULT hr = S_OK;   // 447822 prefix warning
   const REG_DATA *pEntry = rgEntries;

    while (pEntry < rgEntries + cEntries)
    {
        HKEY hkey;
        LONG err = RegCreateKey(HKEY_CLASSES_ROOT,
                                pEntry->keyName,
                               &hkey);
        if (err == ERROR_SUCCESS)
        {
            if (pEntry->value)
                err = RegSetValueEx(hkey, 
                                pEntry->valueName,
                                0, REG_SZ, 
                                (const BYTE*)pEntry->value,
                                (lstrlen(pEntry->value) + 1) * sizeof(TCHAR));
            if (err != ERROR_SUCCESS)
            {
                bSuccess = FALSE;
                Unregister(rgEntries, static_cast<int>(1 + pEntry - rgEntries));
            }
            RegCloseKey(hkey);
        }
        if (err != ERROR_SUCCESS)
        {
            bSuccess = FALSE;
            if (pEntry != rgEntries)
                Unregister(rgEntries, static_cast<int>(pEntry - rgEntries));
        }
        pEntry++;
    };

   if (bSuccess)
	{
      OLECHAR g_wszFileName[MAX_PATH];

      // ISSUE-2002/03/06-sburns consider strsafe function
      
      lstrcpy(g_wszFileName, g_szFileName);     
		ITypeLib *ptl = 0;
		hr = LoadTypeLib(g_wszFileName, &ptl);
		if (SUCCEEDED(hr))
		{
			hr = RegisterTypeLib(ptl, g_wszFileName, 0);
			ptl->Release();
		}

		if (bSuccess)
			hr = S_OK;
		else
			hr = E_FAIL;
	}

    return hr ;//bSuccess ? S_OK : E_FAIL;
}



BOOL
APIENTRY
DllMain(HINSTANCE h, DWORD dwReason, void *)
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
      {
         hResourceModuleHandle = h;

         LOG(L"DLL_PROCESS_ATTACH");

// @@ remove this 
        GetModuleFileName(h, g_szFileName, MAX_PATH);



         break;
      }
      case DLL_PROCESS_DETACH:
      {

#ifdef DEBUG_BUILD
         LOG(TEXT("DLL_PROCESS_DETACH"));
         if (!ComServerLockState::CanUnloadNow())
         {
            LOG(L"server locks and/or outstanding object instances exit");
         }
         else
         {
            LOG(L"server can unload now.");
         }
#endif

         break;
      }
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
      default:
      {
         break;
      }
   }

   return TRUE;
}



STDAPI
DllRegisterServer()
{
   LOG_FUNCTION(DllRegisterServer);

   return Register(g_rgEntries, g_cEntries);
}



STDAPI
DllUnregisterServer()
{
   LOG_FUNCTION(DllUnregisterServer);

   return Unregister(g_rgEntries, g_cEntries);
}



STDAPI
DllCanUnloadNow()
{
   LOG_FUNCTION(DllCanUnloadNow);

   if (ComServerLockState::CanUnloadNow())
   {
      return S_OK;
   }

   return S_FALSE;
}


STDAPI
DllGetClassObject(
   const CLSID&   classID,
   const IID&     interfaceID,
   void**         interfaceDesired)
{
   LOG_FUNCTION(DllGetClassObject);

   IClassFactory* factory = 0;

   // The class objects are instances of ClassFactory<>, which are ref-counted
   // in the usual fashion (i.e. they track their ref counts, and
   // self-destruct on final Release).  I could have used static instances of
   // a C++ class that ignored the refcounting (ala Don Box's examples in
   // Essential COM)

   if (classID == CLSID_CloneSecurityPrincipal)
   {
      factory = new ClassFactory<CloneSecurityPrincipal>;
   }
   else
   {
      *interfaceDesired = 0;
      return CLASS_E_CLASSNOTAVAILABLE;
   }

   // the class factory instance starts with a ref count of 1.  If the QI
   // fails, then it self-destructs upon Release.
   HRESULT hr = factory->QueryInterface(interfaceID, interfaceDesired);
   factory->Release();
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\migrate\clonepr\connect.cpp ===
//
// Implementation of ICloneSecurityPrincipal::Connect
//
// sburns 5-10-99



#include "headers.hxx"
#include "resource.h"
#include "common.hpp"
#include "implmain.hpp"



CloneSecurityPrincipal::Connection::Connection()
   :
   dstComputer(0),
   dstDomainSamHandle(INVALID_HANDLE_VALUE),
   dstDsBindHandle(INVALID_HANDLE_VALUE),
   m_pldap(0),
   srcComputer(0),
   srcDcDnsName(),
   srcDomainSamHandle(INVALID_HANDLE_VALUE)
{
   LOG_CTOR(CloneSecurityPrincipal::Connection);
}



CloneSecurityPrincipal::Connection::~Connection()
{
   LOG_DTOR(CloneSecurityPrincipal::Connection);

   Disconnect();
}



HRESULT
ValidateDCAndDomainParameters(
   const String& srcDC,    
   const String& srcDomain,
   const String& dstDC,    
   const String& dstDomain)
{
   LOG_FUNCTION(ValidateDCAndDomainParameters);

   HRESULT hr = S_OK;
   do
   {
      if (srcDC.empty() && srcDomain.empty())
      {
         hr = E_INVALIDARG;
         SetComError(IDS_MUST_SPECIFY_SRC_DC_OR_DOMAIN);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      if (dstDC.empty() && dstDomain.empty())
      {
         hr = E_INVALIDARG;
         SetComError(IDS_MUST_SPECIFY_DST_DC_OR_DOMAIN);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      
      if (!srcDC.empty() && !dstDC.empty())
      {
         if (srcDC.icompare(dstDC) == 0)
         {
            // may not be the same dc

            hr = E_INVALIDARG;
            SetComError(IDS_SRC_DC_EQUALS_DST_DC);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }

      if (!srcDomain.empty() && dstDomain.empty())
      {
         if (srcDomain.icompare(dstDomain) == 0)
         {
            // may not be the same domain

            hr = E_INVALIDARG;
            SetComError(IDS_SRC_DOMAIN_EQUALS_DST_DOMAIN);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }
   }
   while (0);

   return hr;
}



// Creates a Computer object representing the domain controller specified, or
// located domain controller for the domain specified.  Does additional
// validation of the dc and domain parameters.

HRESULT
CreateComputer(
   const String&  dc,
   const String&  domain,
   Computer*&     computer)
{
   LOG_FUNCTION(CreateComputer);
   ASSERT(computer == 0);

   computer = 0;
   HRESULT hr = S_OK;
   do
   {
      if (dc.empty())
      {
         // source DC was not specified: find a writeable DC

         // must have supplied the source domain: we checked for that
         // in an earlier call to ValidateDCAndDomainParameters
         ASSERT(!domain.empty());
         if (domain.empty())
         {
            hr = E_INVALIDARG;
            SetComError(IDS_MUST_SPECIFY_SRC_DC_OR_DOMAIN);
            break;
         }

         DOMAIN_CONTROLLER_INFO* info = 0;
         hr =
            Win32ToHresult(
               MyDsGetDcName(
                  0,
                  domain,
                  DS_WRITABLE_REQUIRED | DS_DIRECTORY_SERVICE_PREFERRED,
                  info));

         LOG_HRESULT(hr);

         if (FAILED(hr))
         {
            SetComError(
               String::format(
                  IDS_CANT_FIND_DC,
                  domain.c_str(),
                  GetErrorMessage(hr).c_str()));
            break;
         }
            
         if (info && info->DomainControllerName)
         {
            computer = new Computer(info->DomainControllerName);
            ::NetApiBufferFree(info);
         }
         else
         {
            // should always get a result if successful 
            ASSERT(false);
            hr = E_FAIL;
            break;
         }
      }
      else
      {
         // source dc was supplied

         computer = new Computer(dc);
      }
   }
   while (0);

   return hr;
}



// HRESULT
// Authenticate(
//    const Computer&   computer,
//    const String&     username,
//    const String&     userDomain,
//    const String&     password)
// {
//    LOG_FUNCTION(Authenticate);
// 
//    // attempt to authenticate to the computer.
//    String name = computer.NameWithBackslashes();
// 
//    NETRESOURCE nr;
//    memset(&nr, 0, sizeof(nr));
// 
//    nr.dwType       = RESOURCETYPE_ANY;
//    nr.lpRemoteName = const_cast<String::value_type*>(name.c_str());
// 
//    // see KB articles Q218497, Q180548, Q183366 for the pitfalls here...
// 
//    String u;
//    if (userDomain.empty())
//    {
//       u = username;
//    }
//    else
//    {
//       ASSERT(!username.empty());
//       u = userDomain + L"\\" + username;
//    }
// 
//    LOG(L"Calling WNetAddConnection2");
//    LOG(String::format(L"username : %1", u.empty() ? L"(null)" : u.c_str()));
// 
//    HRESULT hr =
//       Win32ToHresult(
//          ::WNetAddConnection2(
//             &nr,
//             password.c_str(),
//             u.empty() ? 0 : u.c_str(),
//             0));
// 
//    LOG_HRESULT(hr);
// 
//    if (FAILED(hr))
//    {
//       SetComError(
//          String::format(
//             IDS_UNABLE_TO_CONNECT,
//             name.c_str(),
//             GetErrorMessage(hr).c_str()));
//    }
// 
//    return hr;
// }



HRESULT
ValidateInitializedComputer(
   const Computer& computer,
   const String&   domain)  
{
   LOG_FUNCTION(ValidateInitializedComputer);

   HRESULT hr = S_OK;
   do
   {
      if (!computer.IsDomainController())
      {
         hr = E_INVALIDARG;
         SetComError(
            String::format(
               IDS_COMPUTER_IS_NOT_DC,
               computer.GetNetbiosName().c_str()));
         break;
      }

      if (!domain.empty())
      {
         // check that the DC is really a DC of the specified domain
         if (
               computer.GetDomainDnsName().icompare(domain) != 0
            && computer.GetDomainNetbiosName().icompare(domain) != 0)
         {
            hr = E_INVALIDARG;
            SetComError(
               String::format(
                  IDS_NOT_DC_FOR_WRONG_DOMAIN,
                  computer.GetNetbiosName().c_str(),
                  domain.c_str()));
            break;
         }
      }
   }
   while (0);

   return hr;
}



// Returns an open handle to the SAM database for the named domain on the
// given DC.  Should be freed with SamCloseHandle.

HRESULT
OpenSamDomain(
   const String&  dcName,
   const String&  domainNetBiosName,
   SAM_HANDLE&    resultHandle)
{
   LOG_FUNCTION2(OpenSamDomain, dcName);
   ASSERT(!dcName.empty());

   resultHandle = INVALID_HANDLE_VALUE;
      
   HRESULT hr = S_OK;
   SAM_HANDLE serverHandle = INVALID_HANDLE_VALUE;
   PSID domainSID = 0;
   do
   {
      UNICODE_STRING serverName;
      memset(&serverName, 0, sizeof(serverName));
      ::RtlInitUnicodeString(&serverName, dcName.c_str());

      LOG(L"Calling SamConnect");

      hr =
         NtStatusToHRESULT(
            ::SamConnect(
               &serverName,
               &serverHandle,
               MAXIMUM_ALLOWED,
               0));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_UNABLE_TO_CONNECT_TO_SAM_SERVER,
               dcName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      UNICODE_STRING domainName;
      memset(&domainName, 0, sizeof(domainName));
      ::RtlInitUnicodeString(&domainName, domainNetBiosName.c_str());

      hr =
         NtStatusToHRESULT(
            ::SamLookupDomainInSamServer(
               serverHandle,
               &domainName,
               &domainSID));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_UNABLE_TO_LOOKUP_SAM_DOMAIN,
               domainNetBiosName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      hr =
         NtStatusToHRESULT(
            ::SamOpenDomain(
               serverHandle,
               MAXIMUM_ALLOWED,
               domainSID,
               &resultHandle));
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_UNABLE_TO_OPEN_SAM_DOMAIN,
               domainNetBiosName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }
   }
   while (0);

   if (serverHandle != INVALID_HANDLE_VALUE)
   {
      ::SamCloseHandle(serverHandle);
   }

   if (domainSID)
   {
      ::SamFreeMemory(domainSID);
   }

   return hr;
}



HRESULT
DetermineSourceDcDnsName(
   const String&  srcDcNetbiosName,
   const String&  srcDomainDnsName,
   String&        srcDcDnsName)
{
   LOG_FUNCTION(DetermineSourceDcDnsName);
   ASSERT(!srcDcNetbiosName.empty());

   srcDcDnsName.erase();

   if (srcDomainDnsName.empty())
   {
      // The computer is not a DS DC, so we don't need its DNS name.
      LOG(L"source DC is not a DS DC");

      return S_OK;
   }

   HRESULT hr = S_OK;
   HANDLE hds = 0;
   do
   {
      // Bind to self
      hr =
         MyDsBind(
            srcDcNetbiosName,
            srcDomainDnsName,
            hds);
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_BIND_FAILED,
               srcDcNetbiosName.c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      // find all the dc's for my domain.  the list should contain
      // srcDcNetbiosName.

      DS_DOMAIN_CONTROLLER_INFO_1W* info = 0;
      DWORD infoCount = 0;
      hr =
         MyDsGetDomainControllerInfo(
            hds,
            srcDomainDnsName,
            infoCount,
            info);
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_GET_DC_INFO_FAILED,
               GetErrorMessage(hr).c_str()));
         break;
      }

      // there should be at least 1 entry, the source DC itself
      ASSERT(infoCount);
      ASSERT(info);

      if (info)
      {
         for (DWORD i = 0; i < infoCount; i++)
         {
            if (info[i].NetbiosName)   
            {
               LOG(info[i].NetbiosName);

               if (srcDcNetbiosName.icompare(info[i].NetbiosName) == 0)
               {
                  // we found ourselves in the list

                  LOG(L"netbios name found");

                  if (info[i].DnsHostName)
                  {
                     LOG(L"dns hostname found!");                  
                     srcDcDnsName = info[i].DnsHostName;
                     break;
                  }

               }
            }
         }
      }

      ::DsFreeDomainControllerInfo(1, infoCount, info);

      if (srcDcDnsName.empty())
      {
         hr = E_FAIL;
         SetComError(
            String::format(
               IDS_CANT_FIND_SRC_DC_DNS_NAME,
               srcDcNetbiosName.c_str()));
         break;
      }

      LOG(srcDcDnsName);
   }
   while (0);

   if (hds)
   {
      ::DsUnBind(&hds);
      hds = 0;
   }

   return hr;
}



HRESULT
CloneSecurityPrincipal::Connection::Connect(
   const String& srcDC,              
   const String& srcDomain,          
   const String& dstDC,              
   const String& dstDomain)
{
   LOG_FUNCTION(CloneSecurityPrincipal::Connection::Connect);

   HRESULT hr = S_OK;
   do
   {
      hr = ValidateDCAndDomainParameters(srcDC, srcDomain, dstDC, dstDomain);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = CreateComputer(srcDC, srcDomain, srcComputer);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = CreateComputer(dstDC, dstDomain, dstComputer);
      BREAK_ON_FAILED_HRESULT(hr);

      // hr =
      //    Authenticate(
      //       *srcComputer,
      //       srcUsername,
      //       srcUserDomain,
      //       srcPassword);
      // BREAK_ON_FAILED_HRESULT(hr);

      hr = srcComputer->Refresh();
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_UNABLE_TO_READ_COMPUTER_INFO,
               srcComputer->GetNetbiosName().c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      hr = ValidateInitializedComputer(*srcComputer, srcDomain);
      BREAK_ON_FAILED_HRESULT(hr);
         
      hr = dstComputer->Refresh();
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_UNABLE_TO_READ_COMPUTER_INFO,
               dstComputer->GetNetbiosName().c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      hr = ValidateInitializedComputer(*dstComputer, dstDomain);
      BREAK_ON_FAILED_HRESULT(hr);

      // bind to the destination DC.

      ASSERT(dstDsBindHandle == INVALID_HANDLE_VALUE);

      hr =
         MyDsBind(
            dstComputer->GetNetbiosName(),
            String(),
            dstDsBindHandle);
      if (FAILED(hr))
      {
         SetComError(
            String::format(
               IDS_BIND_FAILED,
               dstComputer->GetNetbiosName().c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      //
      // open ldap connection to dstDC
      //
      m_pldap = ldap_open(const_cast<String::value_type*>(dstDC.c_str()), LDAP_PORT);
      if (!m_pldap)
      {
         hr = Win::GetLastErrorAsHresult();
         SetComError(
            String::format(
               IDS_LDAPOPEN_FAILED,
               dstComputer->GetNetbiosName().c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      // SEC_WINNT_AUTH_IDENTITY authInfo;
      // authInfo.User           = const_cast<wchar_t*>(dstUsername.c_str());
      // authInfo.UserLength     = dstUsername.length();
      // authInfo.Domain         = const_cast<wchar_t*>(dstUserDomain.c_str());
      // authInfo.DomainLength   = dstUserDomain.length();
      // authInfo.Password       = const_cast<wchar_t*>(dstPassword.c_str());
      // authInfo.PasswordLength = dstPassword.length();
      // authInfo.Flags          = SEC_WINNT_AUTH_IDENTITY_UNICODE;

      DWORD dwErr = ldap_bind_s(
                              m_pldap, 
                              NULL,
                              (TCHAR *) 0, 
                              LDAP_AUTH_NEGOTIATE);
      if (LDAP_SUCCESS != dwErr)
      {
         hr = Win::GetLastErrorAsHresult();

         ldap_unbind_s(m_pldap);
         m_pldap = 0;

         SetComError(
            String::format(
               IDS_LDAPBIND_FAILED,
               dstComputer->GetNetbiosName().c_str(),
               GetErrorMessage(hr).c_str()));
         break;
      }

      // obtain sam handles to source and dst domains

      ASSERT(srcDomainSamHandle == INVALID_HANDLE_VALUE);

      hr =
         OpenSamDomain(
            srcComputer->GetNetbiosName(),
            srcComputer->GetDomainNetbiosName(),
            srcDomainSamHandle);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(dstDomainSamHandle == INVALID_HANDLE_VALUE);

      hr =
         OpenSamDomain(
            dstComputer->GetNetbiosName(),
            dstComputer->GetDomainNetbiosName(),
            dstDomainSamHandle);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         DetermineSourceDcDnsName(
            srcComputer->GetNetbiosName(),
            srcComputer->GetDomainDnsName(),
            srcDcDnsName);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      Disconnect();
   }

   return hr;
}



bool
CloneSecurityPrincipal::Connection::IsConnected() const
{
   LOG_FUNCTION(CloneSecurityPrincipal::Connection::IsConnected);

   bool result =
         srcComputer
      && dstComputer
      && (dstDsBindHandle != INVALID_HANDLE_VALUE)
      && (srcDomainSamHandle != INVALID_HANDLE_VALUE);

   LOG(
      String::format(
         L"object %1 connected.",
         result ? L"is" : L"is NOT"));

   return result;
}



void
CloneSecurityPrincipal::Connection::Disconnect()
{
   LOG_FUNCTION(CloneSecurityPrincipal::Connection::Disconnect);

   // may be called if Connect fails, so we might be in a partially
   // connected state.  So we need to check the handle values.

   if (srcDomainSamHandle != INVALID_HANDLE_VALUE)
   {
      ::SamCloseHandle(srcDomainSamHandle);
      srcDomainSamHandle = INVALID_HANDLE_VALUE;
   }

   if (dstDsBindHandle != INVALID_HANDLE_VALUE)
   {
      ::DsUnBind(&dstDsBindHandle);
      dstDsBindHandle = INVALID_HANDLE_VALUE;
   }

   if (m_pldap)
   {
      ldap_unbind_s(m_pldap);
      m_pldap = 0;
   }

   delete dstComputer;
   dstComputer = 0;

   delete srcComputer;
   srcComputer = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\migrate\clonepr\implmain.hpp ===
#ifndef IMPLMAIN_HPP_INCLUDED
#define IMPLMAIN_HPP_INCLUDED



class CloneSecurityPrincipal
   :
   public ICloneSecurityPrincipal,
   public ISupportErrorInfo,
   public IADsError,
   public IADsSID
{
   // this is the only entity with access to the ctor of this class
   friend class ClassFactory<CloneSecurityPrincipal>;

	public:

   // IUnknown methods

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& riid, void **ppv);

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

	// IDispatch methods

   virtual 
   HRESULT __stdcall
   GetTypeInfoCount(UINT *pcti);

	virtual 
   HRESULT __stdcall
   GetTypeInfo(UINT cti, LCID, ITypeInfo **ppti);

   virtual 
   HRESULT __stdcall
	GetIDsOfNames(
	   REFIID  riid,    
	   OLECHAR **prgpsz,
	   UINT    cNames,  
	   LCID    lcid,    
	   DISPID  *prgids);

   virtual 
   HRESULT __stdcall
	Invoke(
	   DISPID     id,         
	   REFIID     riid,       
	   LCID       lcid,       
	   WORD       wFlags,     
	   DISPPARAMS *params,    
	   VARIANT    *pVarResult,
	   EXCEPINFO  *pei,       
	   UINT       *puArgErr); 

   // ISupportErrorInfo methods

   virtual 
   HRESULT __stdcall
   InterfaceSupportsErrorInfo(const IID& iid);
      
   // ICloneSecurityPrincipal methods

   virtual
	HRESULT __stdcall
	Connect(
		BSTR srcDomainController,
		BSTR srcDomain,          
		BSTR dstDomainController,
		BSTR dstDomain);         

   virtual
	HRESULT __stdcall
	CopyDownlevelUserProperties(
		BSTR srcSamName,
		BSTR dstSamName,
		long flags);    

   virtual 
   HRESULT __stdcall
   AddSidHistory(
		BSTR srcPrincipalSamName,
		BSTR dstPrincipalSamName,
		long flags);             

   virtual
   HRESULT __stdcall
   GetMembersSIDs(
		BSTR     dstGroupDN,
		VARIANT* pVal);

   // IADsSID methods

   virtual
   HRESULT __stdcall
	SetAs(
      long    lFormat, 
      VARIANT varData);

   virtual
   HRESULT __stdcall
   GetAs(
      long     lFormat,
      VARIANT* pVar);  

  // IADsError methods

   virtual
   HRESULT __stdcall
	GetErrorMsg(
      long  hrErr,
      BSTR* Msg); 

	private:

   // only our friend class factory can instantiate us.   
   CloneSecurityPrincipal();

   // only Release can cause us to be deleted

   virtual
   ~CloneSecurityPrincipal();

   // not implemented: no copying allowed
   CloneSecurityPrincipal(const CloneSecurityPrincipal&);
   const CloneSecurityPrincipal& operator=(const CloneSecurityPrincipal&);

   HRESULT
   DoAddSidHistory(
      const String& srcPrincipalSamName,
      const String& dstPrincipalSamName,
      long          flags);

   HRESULT
   DoCopyDownlevelUserProperties(
      const String& srcSamName,
      const String& dstSamName,
      long          flags);

   // represents the authenticated connection to the source and destination
   // domain controllers, including ds bindings

   class Connection
   {
      friend class CloneSecurityPrincipal;

      public:

      Connection();

      // disconnects, unbinds.
      ~Connection();

      HRESULT
      Connect(
         const String& srcDC,              
         const String& srcDomain,          
         const String& dstDC,              
         const String& dstDomain);

      bool
      IsConnected() const;

      private:

      Computer*  dstComputer;       
      SAM_HANDLE dstDomainSamHandle;
      HANDLE     dstDsBindHandle;   
      PLDAP      m_pldap;           
      Computer*  srcComputer;       
      String     srcDcDnsName;
      SAM_HANDLE srcDomainSamHandle;

      // not implemented: no copying allowed
      Connection(const Connection&);
      const Connection& operator=(const Connection&);

      void
      Disconnect();
   };

   Connection*        connection;  
   ComServerReference dllref;      
   long               refcount;    
   ITypeInfo**        m_ppTypeInfo;

   // used by IADsSID

   PSID	       m_pSID;
};



#endif   // IMPLMAIN_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\migrate\clonepr\implmain.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Implementation of ICloneSecurityPrincipal
//
// sburns 5-10-99



#include "headers.hxx"
#include "resource.h"
#include "implmain.hpp"
#include "common.hpp"



const size_t NUMBER_OF_AUTOMATION_INTERFACES = 3;



CloneSecurityPrincipal::CloneSecurityPrincipal()
   :
   connection(0),
   refcount(1),       // implicit AddRef
   m_pSID(NULL)
{
   LOG_CTOR(CloneSecurityPrincipal);

   m_ppTypeInfo = new ITypeInfo*[NUMBER_OF_AUTOMATION_INTERFACES];

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      m_ppTypeInfo[i] = NULL;
   }

   ITypeLib *ptl = 0;
   HRESULT hr = LoadRegTypeLib(LIBID_CloneSecurityPrincipalLib, 1, 0, 0, &ptl);
   if (SUCCEEDED(hr))
   {
      ptl->GetTypeInfoOfGuid(IID_ICloneSecurityPrincipal, &(m_ppTypeInfo[0]));
      ptl->GetTypeInfoOfGuid(IID_IADsSID, &(m_ppTypeInfo[1]));
      ptl->GetTypeInfoOfGuid(IID_IADsError, &(m_ppTypeInfo[2]));

      ptl->Release();
   }
}



CloneSecurityPrincipal::~CloneSecurityPrincipal()
{
   LOG_DTOR(CloneSecurityPrincipal);
   ASSERT(refcount == 0);

   delete connection;

   if ( m_pSID ) 
     FreeADsMem( m_pSID );

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      m_ppTypeInfo[i]->Release();
   }

   delete[] m_ppTypeInfo;
}



HRESULT __stdcall
CloneSecurityPrincipal::QueryInterface(REFIID riid, void **ppv)
{
   LOG_FUNCTION(CloneSecurityPrincipal::QueryInterface);

   if (riid == IID_IUnknown)
   {
      LOG(L"IUnknown");

      *ppv = (IUnknown*)(ICloneSecurityPrincipal*)(this);
   }
   else if (riid == IID_ICloneSecurityPrincipal)
   {
      LOG(L"ICloneSecurityPrincipal");

      *ppv = static_cast<ICloneSecurityPrincipal*>(this);
   }
   else if (riid == IID_IADsSID)
   {
      LOG(L"IADsSID");

      *ppv = static_cast<IADsSID*>(this);
   }
   else if (riid == IID_IADsError)
   {
      LOG(L"IADsError");

      *ppv = static_cast<IADsError*>(this);
   }
   else if (riid == IID_IDispatch && m_ppTypeInfo[0])
   {
      LOG(L"IDispatch");

      *ppv = (IDispatch*)(ICloneSecurityPrincipal*)(this);
   }
   else if (riid == IID_ISupportErrorInfo)
   {
      LOG(L"ISupportErrorInfo");

      *ppv = (ISupportErrorInfo*)(this);
   }
   else
   {
      LOG(L"unknown");

      return (*ppv = 0), E_NOINTERFACE;
   }

   reinterpret_cast<IUnknown*>(*ppv)->AddRef();
   return S_OK;
}



ULONG __stdcall
CloneSecurityPrincipal::AddRef(void)
{
   LOG_ADDREF(CloneSecurityPrincipal);

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
CloneSecurityPrincipal::Release(void)
{
   LOG_RELEASE(CloneSecurityPrincipal);

   // need to copy the result of the decrement, because if we delete this,
   // refcount will no longer be valid memory, and that might hose
   // multithreaded callers.  NTRAID#NTBUG9-566901-2002/03/06-sburns
   
   long newref = Win::InterlockedDecrement(refcount);
   if (newref == 0)
   {
      delete this;
      return 0;
   }

   // we should not have decremented into negative values.
   
   ASSERT(newref > 0);

   return newref;
}



HRESULT __stdcall
CloneSecurityPrincipal::GetTypeInfoCount(UINT *pcti)
{
   LOG_FUNCTION(CloneSecurityPrincipal::GetTypeInfoCount);

    if (pcti == 0)
    {
      return E_POINTER;
    }

    *pcti = 1;
    return S_OK;
}



HRESULT __stdcall
CloneSecurityPrincipal::GetTypeInfo(UINT cti, LCID, ITypeInfo **ppti)
{
   LOG_FUNCTION(CloneSecurityPrincipal::GetTypeInfo);

   if (ppti == 0)
   {
      return E_POINTER;
   }
   if (cti != 0)
   {
      *ppti = 0;
      return DISP_E_BADINDEX;
   }

   (*ppti = m_ppTypeInfo[0])->AddRef();
   return S_OK;
}



HRESULT __stdcall
CloneSecurityPrincipal::GetIDsOfNames(
   REFIID  riid,    
   OLECHAR **prgpsz,
   UINT    cNames,  
   LCID    lcid,    
   DISPID  *prgids) 
{
   LOG_FUNCTION(CloneSecurityPrincipal::GetIDsOfNames);

   HRESULT hr = S_OK;
   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
     hr = (m_ppTypeInfo[i])->GetIDsOfNames(prgpsz, cNames, prgids);
     if (SUCCEEDED(hr) || DISP_E_UNKNOWNNAME != hr)
       break;
   }

   return hr;
}



HRESULT __stdcall
CloneSecurityPrincipal::Invoke(
   DISPID     id,         
   REFIID     riid,       
   LCID       lcid,       
   WORD       wFlags,     
   DISPPARAMS *params,    
   VARIANT    *pVarResult,
   EXCEPINFO  *pei,       
   UINT       *puArgErr) 
{
   LOG_FUNCTION(CloneSecurityPrincipal::Invoke);

   HRESULT    hr = S_OK;
   IDispatch *pDispatch[NUMBER_OF_AUTOMATION_INTERFACES] =
                    {
                     (IDispatch*)(ICloneSecurityPrincipal *)(this),
                     (IDispatch*)(IADsSID *)(this),
                     (IDispatch*)(IADsError *)(this)
                    };

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      hr = (m_ppTypeInfo[i])->Invoke(
         pDispatch[i],
         id,
         wFlags,
         params,
         pVarResult,
         pei,
         puArgErr);

      if (DISP_E_MEMBERNOTFOUND != hr)
        break;
   }

   return hr;
}



HRESULT __stdcall
CloneSecurityPrincipal::InterfaceSupportsErrorInfo(const IID& iid)
{
   LOG_FUNCTION(CloneSecurityPrincipal::InterfaceSupportsErrorInfo);

   if (iid == IID_ICloneSecurityPrincipal ||
       iid == IID_IADsSID ||
       iid == IID_IADsError)
   {
      return S_OK;
   }

   return S_FALSE;
}



HRESULT __stdcall
CloneSecurityPrincipal::Connect(
  BSTR  srcDC,
  BSTR  srcDomain,          
  BSTR  dstDC,
  BSTR  dstDomain)
{
   LOG_FUNCTION(CloneSecurityPrincipal::Connect);

   delete connection;
   connection = new Connection();

   // Even though a null parameter is technically illegal (the types are
   // BSTR),  we thoughtfully accomodate the inattentive C++ user which may
   // prefer to pass null pointers instead of empty BSTRs

   return connection->Connect(
         srcDC       ? srcDC       : L"", 
         srcDomain   ? srcDomain   : L"", 
         dstDC       ? dstDC       : L"", 
         dstDomain   ? dstDomain   : L"");
}



HRESULT __stdcall
CloneSecurityPrincipal::AddSidHistory(
   BSTR srcPrincipalSamName,
   BSTR dstPrincipalSamName,
   long flags)              
{
   LOG_FUNCTION(CloneSecurityPrincipal::AddSidHistory);

   // Even though a null parameter is technically illegal (the types are
   // BSTR),  we thoughtfully accomodate the inattentive C++ user which may
   // prefer to pass null pointers instead of empty BSTRs

   return
      DoAddSidHistory(
         srcPrincipalSamName ? srcPrincipalSamName : L"",
         dstPrincipalSamName ? dstPrincipalSamName : L"",
         flags);
}



HRESULT __stdcall
CloneSecurityPrincipal::CopyDownlevelUserProperties(
   BSTR srcSamName,
   BSTR dstSamName,
   long flags)     
{
   LOG_FUNCTION(CloneSecurityPrincipal::CopyDownlevelUserProperties);

   // Even though a null parameter is technically illegal (the types are
   // BSTR),  we thoughtfully accomodate the inattentive C++ user which may
   // prefer to pass null pointers instead of empty BSTRs

   return
      DoCopyDownlevelUserProperties(
         srcSamName ? srcSamName : L"",
         dstSamName ? dstSamName : L"",
         flags);
}



//+-----------------------------------------------------------------------
//
//  Function:   CloneSecurityPrincipal::GetMembersSIDs
//
//  Synopsis:   retrieve the <sid=XXXX> of all members of dstGroupDN.
//
//------------------------------------------------------------------------

#define ATTRIBUTE_MEMBER                  L"member"

HRESULT __stdcall
CloneSecurityPrincipal::GetMembersSIDs(
   BSTR     dstGroupDN,
   VARIANT* pVal)
{
   // init the OUT parameter to hold an array of variants

   VariantInit(pVal);
   pVal->vt = VT_ARRAY | VT_VARIANT ;

   HRESULT             hr                = S_OK;
   std::vector<BSTR>   values;
   PLDAPMessage        pMsg              = 0;
   LPTSTR              lpszAttrs[]       = {ATTRIBUTE_MEMBER, 0};
   LDAPControl         serverControls    = {LDAP_SERVER_EXTENDED_DN_OID_W, {0, (PCHAR)NULL}, TRUE};
   PLDAPControl        aServerControls[] = {&serverControls, NULL};
   PLDAP               pldap             = connection->m_pldap;

   do
   {
      // the ldap connection to dstDC should have already been established

      if (!pldap)
      {
         hr = E_UNEXPECTED;   

         LOG(L"pldap is null!");
         SetComError(IDS_OBJECT_STATE_BAD);
         break;
      }

      hr =
          Win32ToHresult(
            ldap_search_ext_s(
               pldap,
               dstGroupDN,
               LDAP_SCOPE_BASE,            // scope
               _T("(objectClass=group)"),  // filter
               lpszAttrs,                  // attrs[]
               0,                          // atrssonly
               (PLDAPControl*) aServerControls, // ServerControls
               NULL,                       // ClientControls
               0,                          // no time limit
               0,                          // no SizeLimit
               &pMsg)); 
      BREAK_ON_FAILED_HRESULT(hr);

      BSTR   bstr     = NULL;                 
      PTSTR  pStart   = NULL;                 
      PTSTR  pEnd     = NULL;                 
      PTSTR* ppValues = ldap_get_values(pldap, pMsg, ATTRIBUTE_MEMBER);

      if (!ppValues)
      {
         break;
      }

      PTSTR *p = ppValues;
      while(*p)
      {
         //  *p is a string in the following format:
         //  "<GUID=42e87199a88c854998dad04be4b8d29f>;<SID=0105000000
         //  00000515000000a23ca6557d03c651772c315d00040000>;CN=S-1-
         //  5-21-1436957858-1371931517-1563503735-1024,CN=Foreign
         //  SecurityPrincipals,DC=linan,DC=nttest,DC=microsoft,DC=com"

         if ( (pStart  = _tcsstr(*p, _T("<SID="))) &&
         (pEnd    = _tcschr(pStart, _T('>'))) )
         {
            // retrieve <sid=XXXXX>, and add it to the vector

            if ( !(bstr = SysAllocStringLen(pStart, static_cast<UINT>(pEnd - pStart + 1))) )
            {
               hr = E_OUTOFMEMORY;
               SetComError(IDS_OUT_OF_MEMORY);
               break;
            }
            values.push_back(bstr);
         }

         p++;
      }

      ldap_value_free(ppValues);

      // SysAllocString may have failed and terminated the preceeding loop

      BREAK_ON_FAILED_HRESULT(hr);

      // populate the OUT parameter: the array of variants

      if (values.size() > 0)
      {
         SAFEARRAYBOUND  bounds = {values.size(), 0};
         SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
         VARIANT*        varArray;

         SafeArrayAccessData(psa, (void**)&varArray);

         int i = 0;
         for (
            std::vector<BSTR>::iterator it = values.begin();
            it != values.end();
            ++it, ++i)
         {
            VariantInit(&(varArray[i]));
            varArray[i].vt        = VT_BSTR;
            varArray[i].bstrVal   = *it;
         }

         SafeArrayUnaccessData(psa);

         pVal->parray = psa;
      }

   }
   while (0);

   if (pMsg)
   {
      ldap_msgfree(pMsg);
   }

   if (FAILED(hr))
   {
      for (
         std::vector<BSTR>::iterator it = values.begin();
         it != values.end();
         ++it)
      {
         // REVIEWED-2002/03/25-sburns hiding BSTRs in an STL container
         // confuses prefast: *it really does refer to a BSTR -- see the
         // push_back call that populates the container.
         
         SysFreeString(*it);
      }
   }

   return hr;
}



/////////////////////////////////////////////////////////////////////////////
// IADsSID methods

HRESULT VariantToSID(VARIANT *pVar , PSID *ppSID );
HRESULT ByteToHexString(LPBYTE pByte, DWORD dwLength, LPTSTR *ppRet);

// only support ADS_SID_ACTIVE_DIRECTORY_PATH and ADS_SID_WINNT_PATH and ADS_SID_SDDL
STDMETHODIMP CloneSecurityPrincipal::SetAs(long lFormat, VARIANT var)
{
   LOG_FUNCTION(CloneSecurityPrincipal::SetAs);

  PSID    pNew = NULL ;
  HRESULT hr = S_OK;
  
  //
  // performing the necessary indirection if the source is VT_BYREF
  //
  VARIANT varData;
  VariantInit(&varData);
  hr = VariantCopyInd(&varData, (LPVARIANT)&var);
  if (FAILED(hr))
    return hr;

  switch( lFormat )
  {
  case ADS_SID_ACTIVE_DIRECTORY_PATH:
    {
      if ( V_VT(&varData) != VT_BSTR )
        return E_INVALIDARG;

      IDirectoryObject  *pDir;
      hr = ADsGetObject( V_BSTR(&varData), IID_IDirectoryObject, (void**) &pDir );
      if ( FAILED(hr) )
        return hr;

      ADS_ATTR_INFO   *pAttrInfo=NULL;
      DWORD           dwReturn;
      LPWSTR          pAttrNames[]={L"objectSID" };
      DWORD           dwNumAttr=sizeof(pAttrNames)/sizeof(LPWSTR);
      
      hr = pDir->GetObjectAttributes( pAttrNames, 
                                      dwNumAttr, 
                                      &pAttrInfo, 
                                      &dwReturn );
      if ( SUCCEEDED(hr) )
      {
        pNew = (PSID) AllocADsMem( pAttrInfo->pADsValues->OctetString.dwLength );
        if (!pNew)
          hr = E_OUTOFMEMORY;
        else
        
          // REVIEWED-2002/03/06-sburns correct byte count passed.
          
          CopyMemory( pNew, pAttrInfo->pADsValues->OctetString.lpValue,
                    pAttrInfo->pADsValues->OctetString.dwLength );

        FreeADsMem( pAttrInfo );
      }

      pDir->Release();
    }
    break;

  case ADS_SID_WINNT_PATH:
    {
      if ( V_VT(&varData) != VT_BSTR )
        return E_INVALIDARG;

      IADs *pADs;
      hr = ADsGetObject( V_BSTR(&varData), IID_IADs, (void**) &pADs );
      if ( FAILED(hr) )
        return hr;

      VARIANT var1;
      VariantInit(&var1);
      hr = pADs->Get(AutoBstr(L"objectSID"), &var1 );
      if ( SUCCEEDED(hr) )
        hr = VariantToSID( &var1, &pNew );

      pADs->Release();
    }
    break;

  case ADS_SID_SDDL:
    {
      if ( V_VT(&varData) != VT_BSTR )
        return E_INVALIDARG;

      LPCTSTR pszSID = V_BSTR(&varData);
      PSID pSID = NULL;

      if ( !ConvertStringSidToSid( pszSID, &pSID ) )
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
      } else
      {
        DWORD dwLength = GetLengthSid(pSID);
        pNew = (PSID)AllocADsMem(dwLength);
        if (!pNew)
          hr = E_OUTOFMEMORY;
        else

          // REVIEWED-2002/03/06-sburns correct byte count passed.
          
          CopyMemory(pNew, pSID, dwLength);

        LocalFree(pSID);
      }
    }
    break;

   case ADS_SID_RAW:
   {
      // raw, meaning a variant (VT_ARRAY | VT_U1) containing the sid in the
      // same format as returned by the ObjectSid property.

      LOG(L"ADS_SID_RAW");

      if (V_VT(&varData) != (VT_ARRAY| VT_UI1))
      {
         return E_INVALIDARG;
      }

      hr = VariantToSID(&varData, &pNew);
      LOG_HRESULT(hr);

      break;
   }

      
  default:
    return E_INVALIDARG; // unrecognized flag.
  }

  if ( FAILED(hr) )
    return hr;

  if ( !pNew )
    return E_FAIL;

  if (!IsValidSid( pNew ) )
  {
    FreeADsMem( pNew );
    return E_FAIL;
  }

  if ( m_pSID ) 
    FreeADsMem( m_pSID );
  m_pSID = pNew;

  return hr;
}

// only support ADS_SID_SDDL and ADS_SID_HEXSTRING
STDMETHODIMP CloneSecurityPrincipal::GetAs(long lFormat, VARIANT *pVar)
{
  if ( !m_pSID )
    return E_INVALIDARG;

  HRESULT hr = S_OK;
  
  VariantClear(pVar);

  switch( lFormat )
  {
  case ADS_SID_HEXSTRING:
    {
      LPTSTR pStr;
      hr = ByteToHexString( (LPBYTE) m_pSID, GetLengthSid( m_pSID), &pStr );
      if ( SUCCEEDED(hr) )
      {
        V_VT( pVar ) = VT_BSTR;
        V_BSTR( pVar ) = SysAllocString(pStr);
        FreeADsMem( pStr );
      }
    }
    break;

  case ADS_SID_SDDL:
    {
      LPTSTR pszSID;
      if ( ConvertSidToStringSid( m_pSID, &pszSID ))
      {
        V_VT( pVar ) = VT_BSTR;
        V_BSTR( pVar ) = SysAllocString(pszSID);
        LocalFree( pszSID );
      } else
        hr = HRESULT_FROM_WIN32(GetLastError());

    }
    break;

  default:
    hr = E_INVALIDARG; // unrecognized flag.
  }

  return hr;
}

HRESULT VariantToSID(VARIANT *pVar , PSID *ppSID )
{
  HRESULT hr = S_OK;
  SAFEARRAY *aList = NULL;
  CHAR HUGEP *pArray = NULL;
  DWORD dwLower, dwUpper, dwLength;

  hr = SafeArrayGetLBound(V_ARRAY(pVar),
                          1,
                          (long FAR *) &dwLower );

  hr = SafeArrayGetUBound(V_ARRAY(pVar),
                          1,
                          (long FAR *) &dwUpper );
    
  dwLength = dwUpper - dwLower;

  *ppSID = (PSID) AllocADsMem( dwLength + 1);

  aList = V_ARRAY( pVar );

  if ( aList == NULL )
      return E_UNEXPECTED;

  hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
  if ( !SUCCEEDED(hr) )
    return hr;

  // REVIEWED-2002/03/06-sburns correct byte count passed
    
  CopyMemory( *ppSID, pArray, dwLength );

  SafeArrayUnaccessData( aList );

  if (!IsValidSid(*ppSID) )
    return E_FAIL;

  return hr;
}

HRESULT ByteToHexString( LPBYTE pByte, DWORD dwLength, LPTSTR *ppRet )
{
  LPTSTR  pDest=NULL;
  LPTSTR  pHead=NULL;
  
  pDest = pHead = (LPTSTR) AllocADsMem( ((dwLength+1)*2) * sizeof(TCHAR));
  if( pHead == NULL )
    return E_OUTOFMEMORY;

  //////////////////////////////////
  // Convert into the Hex String
  //////////////////////////////////
  for (DWORD idx=0; idx < dwLength; idx++, pDest+=2, pByte++ )
  {
    // REVIEWED-2002/03/06-sburns should consider strsafe function, but
    // pDest is correct length and null terminated.
    
    wsprintf(pDest, _T("%02X"), *pByte );  
  }

  *ppRet = pHead;

  return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IADsError methods

HRESULT
GetMessageHelper(
    OUT BSTR        *pbstr,
    IN  HRESULT     hrErr,
    IN  DWORD       dwFlags,
    IN  HINSTANCE   hMsgDll = NULL
);



#define FACILITY_ADSI   0x00005000

String
GetErrorMessageADSIExtended(HRESULT hr)
{
   LOG_FUNCTION2(GetErrorMessageADSIExtended, String::format("%1!08X!", hr));

   if (!FAILED(hr))
   {
      // no messages for success!
      return String();
   }

   String errmsg = GetErrorMessage(hr);
 
   if ((hr & FACILITY_ADSI)  ||         //adsi
       HRESULT_FACILITY(hr) == FACILITY_WIN32  )   // and win32
   {
     WCHAR szBuffer[MAX_PATH];
     WCHAR szName[MAX_PATH];
     DWORD dwError;
    
     HRESULT hrEx = ADsGetLastError( &dwError, szBuffer, (sizeof(szBuffer)/sizeof(WCHAR))-1,
                        szName, (sizeof(szName)/sizeof(WCHAR))-1 );
     if ( SUCCEEDED(hrEx) && dwError != ERROR_INVALID_DATA  && wcslen(szBuffer))
     {
        String errmsgextended;
        errmsgextended = String::format(IDS_ADSI_EXTENDED_ERROR, errmsg.c_str(), szName, szBuffer);
        return errmsgextended;
     }
   }

   return errmsg;
}



HRESULT __stdcall
CloneSecurityPrincipal::GetErrorMsg(
   long  hrErr,  
   BSTR* pbstrMsg)
{
  String s = GetErrorMessageADSIExtended(hrErr);
  *pbstrMsg = SysAllocString(const_cast<String::value_type*>(s.c_str()));

  if (!*pbstrMsg)
    return E_OUTOFMEMORY;

  return S_OK;
}

//
// S_OK: found and returned in pbstr
// S_FALSE: message not found
// hr: some error happened
//
HRESULT
GetMessageHelper(
    OUT BSTR        *pbstr,
    IN  HRESULT     hrErr,
    IN  DWORD       dwFlags,
    IN  HINSTANCE   hMsgDll
)
{
    *pbstr = NULL;

    LPTSTR lpBuffer = NULL;
    DWORD dwRet =
      FormatMessage(
         FORMAT_MESSAGE_ALLOCATE_BUFFER | dwFlags,
         (LPCVOID) hMsgDll,
         hrErr,
         0,
         (LPTSTR) &lpBuffer,
         0,
         NULL);

    if ( !dwRet )
    {
      DWORD dwErr = GetLastError();

      if (ERROR_MR_MID_NOT_FOUND == dwErr)
        return S_FALSE;
      else
        return HRESULT_FROM_WIN32(dwErr);
    }

    *pbstr = SysAllocString(lpBuffer);
    LocalFree(lpBuffer);

    if (!*pbstr)
      return E_OUTOFMEMORY;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\migrate\scripts\makefile.inc ===
.SUFFIXES : .vbt

# a .vbs file is produced from a .vbt file by executing the C preprocessor
# on the .vbt file, which produces a .i file.  then we rename the .i file
# to .vbs

.vbt{$(O)\}.vbs:
	$(CC) -nologo -EP -Tc$(@B).vbt > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\dsutils\migrate\clonepr\sidhist.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Implementation of ICloneSecurityPrincipal::AddSidHistory
//
// sburns 5-3-99



#include "headers.hxx"
#include "resource.h"
#include "common.hpp"
#include "implmain.hpp"



HRESULT
CloneSecurityPrincipal::DoAddSidHistory(
   const String& srcPrincipalSamName,
   const String& dstPrincipalSamName,
   long          flags)
{
   LOG_FUNCTION(CloneSecurityPrincipal::DoAddSidHistory);

   if (srcPrincipalSamName.empty())
   {
      SetComError(IDS_MISSING_SRC_SAM_NAME);
      return E_INVALIDARG;
   }

   if (flags)
   {
      // not used, should be 0
      SetComError(IDS_FLAGS_ARE_UNUSED);
      return E_INVALIDARG;
   }

   if (!connection || !connection->IsConnected())
   {
      SetComError(IDS_MUST_CONNECT_FIRST);
      return Win32ToHresult(ERROR_ONLY_IF_CONNECTED);
   };

   // At this point, the Computer objects contain the normalized
   // source and destination DC names, and their domains, and any
   // necessary authenticated connections to those DCs have been
   // established.

   HRESULT hr = S_OK;
   do
   {
      // use DNS names, if we have them

      String srcDc     = connection->srcDcDnsName;                   
      String srcDomain = connection->srcComputer->GetDomainDnsName();
      if (srcDomain.empty())
      {
         // source domain not win2k, so use netbios names.
         srcDomain = connection->srcComputer->GetDomainNetbiosName();
         srcDc     = connection->srcComputer->GetNetbiosName(); 
      }

      // use a DNS domain name as the dest domain is NT 5

      String dstDomain = connection->dstComputer->GetDomainDnsName();

      // if dstPrincipalSamName is not specified, use srcPrincipalSamName

      String dstSamName =
            dstPrincipalSamName.empty()
         ?  srcPrincipalSamName
         :  dstPrincipalSamName;

      SEC_WINNT_AUTH_IDENTITY authInfo;
      authInfo.Flags          = SEC_WINNT_AUTH_IDENTITY_UNICODE;
      authInfo.User           = 0;
      authInfo.UserLength     = 0;
      authInfo.Domain         = 0;
      authInfo.DomainLength   = 0;
      authInfo.Password       = 0;
      authInfo.PasswordLength = 0;

      LOG(L"Calling DsAddSidHistory");
      LOG(String::format(L"Flags               : %1!X!", 0));
      LOG(String::format(L"SrcDomain           : %1", srcDomain.c_str()));
      LOG(String::format(L"SrcPrincipal        : %1", srcPrincipalSamName.c_str()));
      LOG(String::format(L"SrcDomainController : %1", srcDc.c_str()));
      LOG(String::format(L"DstDomain           : %1", dstDomain.c_str()));
      LOG(String::format(L"DstPrincipal        : %1", dstSamName.c_str()));

      hr =
         Win32ToHresult(
            ::DsAddSidHistory(
               connection->dstDsBindHandle,
               0, // unused
               srcDomain.c_str(),
               srcPrincipalSamName.c_str(),
               srcDc.c_str(),
               0, // &authInfo,
               dstDomain.c_str(),
               dstSamName.c_str()));
      LOG_HRESULT(hr);

      if (FAILED(hr))
      {
         unsigned id = IDS_ADD_SID_HISTORY_FAILED;
         if (hr == Win32ToHresult(ERROR_INVALID_HANDLE))
         {
            // this is typically due to misconfiguring the source dc
            id = IDS_ADD_SID_HISTORY_FAILED_WITH_INVALID_HANDLE;
         }

         SetComError(
            String::format(
               id,
               GetErrorMessage(hr).c_str()));
         break;
      }
   }
   while (0);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\accessck.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       AccessCk.cpp
//
//  Contents:   Functions imported and modified from ntos\se\accessck.c
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "AccessCk.h"
#include "adutils.h"


typedef enum {
    UpdateRemaining,
    UpdateCurrentGranted,
    UpdateCurrentDenied
} ACCESS_MASK_FIELD_TO_UPDATE;



//
//  Prototypes
//
BOOLEAN
SepSidInSIDList (
    IN list<PSID>& psidList,
    IN PSID PrincipalSelfSid,
    IN PSID Sid);


HRESULT
SepAddAccessTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    IN ULONG StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate,
    IN PSID grantingSid
);

BOOLEAN
SepObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    OUT PULONG ReturnedIndex
);


HRESULT
SepUpdateParentTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    IN ULONG StartIndex,
    IN PSID grantingSid
);

HRESULT
SetGrantingSid (
        IOBJECT_TYPE_LIST& ObjectTypeItem, 
        ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate, 
        ACCESS_MASK oldAccessBits,
        ACCESS_MASK newAccessBits,
        PSID grantingSid);

///////////////////////////////////////////////////////////////////////////////


PSID SePrincipalSelfSid = 0;
static SID_IDENTIFIER_AUTHORITY    SepNtAuthority = SECURITY_NT_AUTHORITY;

HRESULT SepInit ()
{
    HRESULT hr = S_OK;
    ULONG   SidWithOneSubAuthority = RtlLengthRequiredSid (1);


    SePrincipalSelfSid = (PSID) CoTaskMemAlloc (SidWithOneSubAuthority);
    if ( SePrincipalSelfSid )
    {
        SID_IDENTIFIER_AUTHORITY    SeNtAuthority = SepNtAuthority;

        RtlInitializeSid (SePrincipalSelfSid, &SeNtAuthority, 1);
        *(RtlSubAuthoritySid (SePrincipalSelfSid, 0)) = SECURITY_PRINCIPAL_SELF_RID;
    }
    else
        hr = E_OUTOFMEMORY;


    return hr;
}

VOID SepCleanup ()
{
    if ( SePrincipalSelfSid )
    {
        CoTaskMemFree (SePrincipalSelfSid);
        SePrincipalSelfSid = 0;
    }
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
SepMaximumAccessCheck(
    list<PSID>& psidList,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN size_t LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN size_t ObjectTypeListLength
    )
/*++

Routine Description:

    Does an access check for maximum allowed or with a result list. The current
    granted access is stored in the Remaining access and then another access
    check is run.

Arguments:
    psidList - list of object sid to check, plus sids of all groups that the object belongs to

    Dacl - ACL to check

    PrincipalSelfSid - Sid to use in replacing the well-known self sid

    LocalTypeListLength - Length of list of types.

    LocalTypeList - List of types.

    ObjectTypeList - Length of caller-supplied list of object types.

Return Value:

    none

--*/

{
    if ( !LocalTypeList || ! Dacl )
        return E_POINTER;

    if ( PrincipalSelfSid && !IsValidSid (PrincipalSelfSid) )
        return E_INVALIDARG;
    _TRACE (1, L"Entering  SepMaximumAccessCheck\n");

    PVOID   Ace = 0;
    ULONG   AceCount = Dacl->AceCount;
    ULONG   Index = 0;
    HRESULT hr = S_OK;

    //
    // granted == NUL
    // denied == NUL
    //
    //  for each ACE
    //
    //      if grant
    //          for each SID
    //              if SID match, then add all that is not denied to grant mask
    //
    //      if deny
    //          for each SID
    //              if SID match, then add all that is not granted to deny mask
    //

    ULONG i = 0;
    for (Ace = FirstAce (Dacl);
          i < AceCount;
          i++, Ace = NextAce (Ace)) 
    {
        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) 
        {
            switch (((PACE_HEADER)Ace)->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                if (SepSidInSIDList(psidList, PrincipalSelfSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart)) 
                {

                    //
                    // Only grant access types from this mask that have
                    // not already been denied
                    //

                    // Optimize 'normal' case
                    if ( LocalTypeListLength == 1 ) 
                    {
                        // TODO: do granting SID

                        LocalTypeList->CurrentGranted |=
                           (((PACCESS_ALLOWED_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                    } 
                    else 
                    {
                       //
                       // The zeroeth object type represents the object itself.
                       //
                       hr = SepAddAccessTypeList(
                            LocalTypeList,          // List to modify
                            LocalTypeListLength,    // Length of list
                            0,                      // Element to update
                            ((PACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                            UpdateCurrentGranted,
                            &((PACCESS_ALLOWED_ACE)Ace)->SidStart);
                   }
                }
                break;

            //
            // Handle an object specific Access Allowed ACE
            //
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                {
                    //
                    // If no object type is in the ACE,
                    //  treat this as an ACCESS_ALLOWED_ACE.
                    //

                    GUID* ObjectTypeInAce = RtlObjectAceObjectType(Ace);

                    if ( ObjectTypeInAce == NULL ) 
                    {
                        if ( SepSidInSIDList(psidList, PrincipalSelfSid, RtlObjectAceSid(Ace)) ) 
                        {
                            // Optimize 'normal' case
                            if ( LocalTypeListLength == 1 ) 
                            {
                                // TODO: do granting SID
                                LocalTypeList->CurrentGranted |=
                                   (((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                            } 
                            else 
                            {
                                hr = SepAddAccessTypeList(
                                    LocalTypeList,          // List to modify
                                    LocalTypeListLength,    // Length of list
                                    0,                      // Element to update
                                    ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                    UpdateCurrentGranted,
                                    RtlObjectAceSid(Ace));
                            }
                        }

                    //
                    // If no object type list was passed,
                    //  don't grant access to anyone.
                    //

                    } 
                    else if ( ObjectTypeListLength == 0 ) 
                    {

                        // Drop through


                   //
                   // If an object type is in the ACE,
                   //   Find it in the LocalTypeList before using the ACE.
                   //
                    } 
                    else 
                    {

                        if ( SepSidInSIDList(psidList, PrincipalSelfSid, RtlObjectAceSid(Ace)) ) 
                        {
                            if ( SepObjectInTypeList( ObjectTypeInAce,
                                                      LocalTypeList,
                                                      LocalTypeListLength,
                                                      &Index ) ) 
                            {
                                hr = SepAddAccessTypeList(
                                     LocalTypeList,          // List to modify
                                     LocalTypeListLength,   // Length of list
                                     Index,                  // Element already updated
                                     ((PACCESS_ALLOWED_OBJECT_ACE)Ace)->Mask, // Access Granted
                                     UpdateCurrentGranted,
                                     RtlObjectAceSid(Ace));
                            }
                        }
                   }
                } 
                break;

            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                //
                //  If we're impersonating, EToken is set to the Client, and if we're not,
                //  EToken is set to the Primary.  According to the DSA architecture, if
                //  we're asked to evaluate a compound ACE and we're not impersonating,
                //  pretend we are impersonating ourselves.  So we can just use the EToken
                //  for the client token, since it's already set to the right thing.
                //


                if ( SepSidInSIDList(psidList, PrincipalSelfSid, RtlCompoundAceClientSid( Ace )) &&
                     SepSidInSIDList(psidList,  NULL, RtlCompoundAceServerSid( Ace )) ) 
                {

                    //
                    // Only grant access types from this mask that have
                    // not already been denied
                    //

                    // Optimize 'normal' case
                    if ( LocalTypeListLength == 1 ) 
                    {
                        // TODO: do granting SID
                        LocalTypeList->CurrentGranted |=
                           (((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask & ~LocalTypeList->CurrentDenied);
                    } 
                    else 
                    {
                       //
                       // The zeroeth object type represents the object itself.
                       //
                       hr = SepAddAccessTypeList(
                            LocalTypeList,          // List to modify
                            LocalTypeListLength,    // Length of list
                            0,                      // Element to update
                            ((PCOMPOUND_ACCESS_ALLOWED_ACE)Ace)->Mask, // Access Granted
                            UpdateCurrentGranted,
                            RtlCompoundAceClientSid (Ace));
                    }
                }
                break;

            case ACCESS_DENIED_ACE_TYPE:
                if ( SepSidInSIDList(psidList, PrincipalSelfSid, &((PACCESS_DENIED_ACE)Ace)->SidStart)) 
                {
                     //
                     // Only deny access types from this mask that have
                     // not already been granted
                     //

                    // Optimize 'normal' case
                    if ( LocalTypeListLength == 1 ) 
                    {
                        // TODO: do granting SID
                        LocalTypeList->CurrentDenied |=
                            (((PACCESS_DENIED_ACE)Ace)->Mask & ~LocalTypeList->CurrentGranted);
                    } 
                    else 
                    {
                        //
                        // The zeroeth object type represents the object itself.
                        //
                        hr = SepAddAccessTypeList(
                            LocalTypeList,          // List to modify
                            LocalTypeListLength,    // Length of list
                            0,                      // Element to update
                            ((PACCESS_DENIED_ACE)Ace)->Mask, // Access denied
                            UpdateCurrentDenied,
                            &((PACCESS_DENIED_ACE)Ace)->SidStart);
                   }
                }
                break;

            //
            // Handle an object specific Access Denied ACE
            //
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                {
                    PSID    psid = RtlObjectAceSid(Ace);
					ASSERT (IsValidSid (psid));

                    if ( IsValidSid (psid) && SepSidInSIDList(psidList, PrincipalSelfSid, psid) ) 
                    {
                        //
                        // If there is no object type in the ACE,
                        //  or if the caller didn't specify an object type list,
                        //  apply this deny ACE to the entire object.
                        //

                        GUID* ObjectTypeInAce = RtlObjectAceObjectType(Ace);
                        if ( ObjectTypeInAce == NULL ||
                             ObjectTypeListLength == 0 ) 
                        {
                            // TODO: do granting SID
                            LocalTypeList->CurrentDenied |=
                                (((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask & ~LocalTypeList->CurrentGranted);

                        //
                        // Otherwise apply the deny ACE to the object specified
                        //  in the ACE.
                        //

                        } 
                        else if ( SepObjectInTypeList( ObjectTypeInAce,
                                                      LocalTypeList,
                                                      LocalTypeListLength,
                                                      &Index ) ) 
                        {
                            hr = SepAddAccessTypeList(
                                LocalTypeList,          // List to modify
                                LocalTypeListLength,    // Length of list
                                Index,                  // Element to update
                                ((PACCESS_DENIED_OBJECT_ACE)Ace)->Mask, // Access denied
                                UpdateCurrentDenied,
                                psid);
                        }
                    }
                }
                break;

            default:
                break;
            }
        }
    }

    _TRACE (-1, L"Leaving SepMaximumAccessCheck\n");
    return hr;
}


NTSTATUS
SeCaptureObjectTypeList (
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN size_t ObjectTypeListLength,
    OUT PIOBJECT_TYPE_LIST *CapturedObjectTypeList
)
/*++

Routine Description:

    This routine probes and captures a copy of any object type list
    that might have been provided via the ObjectTypeList argument.

    The object type list is converted to the internal form that explicitly
    specifies the hierarchical relationship between the entries.

    The object typs list is validated to ensure a valid hierarchical
    relationship is represented.

Arguments:

    ObjectTypeList - The object type list from which the type list
        information is to be retrieved.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    CapturedObjectTypeList - Receives the captured type list which
        must be freed using SeFreeCapturedObjectTypeList().

Return Value:

    STATUS_SUCCESS indicates no exceptions were encountered.

    Any access violations encountered will be returned.

--*/

{
    _TRACE (1, L"Entering  SeCaptureObjectTypeList\n");
    NTSTATUS            Status = STATUS_SUCCESS;
    PIOBJECT_TYPE_LIST  LocalTypeList = NULL;
    ULONG               Levels[ACCESS_MAX_LEVEL+1];

    //
    //  Set default return
    //

    *CapturedObjectTypeList = NULL;


    if ( ObjectTypeListLength == 0 ) 
    {

        // Drop through

    } 
    else if ( !ARGUMENT_PRESENT(ObjectTypeList) ) 
    {
        Status = STATUS_INVALID_PARAMETER;

    } 
    else 
    {
        //
        // Allocate a buffer to copy into.
        //

        LocalTypeList = new IOBJECT_TYPE_LIST[ObjectTypeListLength];
        if ( !LocalTypeList ) 
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;

        //
        // Copy the callers structure to the local structure.
        //

        } 
        else 
        {
            GUID * CapturedObjectType = 0;
            for (ULONG i=0; i < ObjectTypeListLength; i++ ) 
            {
                //
                // Limit ourselves
                //
                USHORT CurrentLevel = ObjectTypeList[i].Level;
                if ( CurrentLevel > ACCESS_MAX_LEVEL ) 
                {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // Copy data the caller passed in
                //
                LocalTypeList[i].Level = CurrentLevel;
                LocalTypeList[i].Flags = 0;
                CapturedObjectType = ObjectTypeList[i].ObjectType;
                LocalTypeList[i].ObjectType = *CapturedObjectType;
                LocalTypeList[i].Remaining = 0;
                LocalTypeList[i].CurrentGranted = 0;
                LocalTypeList[i].CurrentDenied = 0;

                //
                // Ensure that the level number is consistent with the
                //  level number of the previous entry.
                //

                if ( i == 0 ) 
                {
                    if ( CurrentLevel != 0 ) 
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }

                } 
                else 
                {

                    //
                    // The previous entry is either:
                    //  my immediate parent,
                    //  my sibling, or
                    //  the child (or grandchild, etc.) of my sibling.
                    //
                    if ( CurrentLevel > LocalTypeList[i-1].Level + 1 ) 
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }

                    //
                    // Don't support two roots.
                    //
                    if ( CurrentLevel == 0 ) 
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }

                }

                //
                // If the above rules are maintained,
                //  then my parent object is the last object seen that
                //  has a level one less than mine.
                //

                if ( CurrentLevel == 0 ) 
                {
                    LocalTypeList[i].ParentIndex = -1;
                } 
                else 
                {
                    LocalTypeList[i].ParentIndex = Levels[CurrentLevel-1];
                }

                //
                // Save this obect as the last object seen at this level.
                //

                Levels[CurrentLevel] = i;

            }

        }

    } // end_if

    *CapturedObjectTypeList = LocalTypeList;
    _TRACE (-1, L"Leaving SeCaptureObjectTypeList: Status = 0x%x\n", Status);
    return Status;
}


BOOLEAN
SepSidInSIDList (
    IN list<PSID>& psidList,
    IN PSID PrincipalSelfSid,
    IN PSID Sid)

/*++

Routine Description:

    Checks to see if a given restricted SID is in the given sid list.

    N.B. The code to compute the length of a SID and test for equality
         is duplicated from the security runtime since this is such a
         frequently used routine.

Arguments:

    psidList - the list of sids to be examined

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.


    Sid - Pointer to the SID of interest

    DenyAce - The ACE being evaluated is a DENY or ACCESS DENIED ace

    Restricted - The access check being performed uses the restricted sids.

Return Value:

    A value of TRUE indicates that the SID is in the token, FALSE
    otherwise.

--*/

{
    _TRACE (1, L"Entering  SeSidInSIDList\n");
    BOOLEAN bRVal = FALSE;
    PISID   MatchSid = 0;


    ASSERT (IsValidSid (Sid));
    if ( IsValidSid (Sid) )
    {
        //
        // If Sid is the constant PrincipalSelfSid,
        //  replace it with the passed in PrincipalSelfSid.
        //

        if ( PrincipalSelfSid != NULL && EqualSid (SePrincipalSelfSid, Sid) ) 
        {
            Sid = PrincipalSelfSid;
        }

        //
        // Get address of user/group array and number of user/groups.
        //

        //
        // Scan through the user/groups and attempt to find a match with the
        // specified SID.
        //

        ULONG i = 0;
        for (list<PSID>::iterator itr = psidList.begin (); 
                itr != psidList.end (); 
                itr++, i++) 
        {
            ASSERT (IsValidSid (*itr));
            MatchSid = (PISID)*itr;

            if ( ::EqualSid (Sid, *itr) )
            {
                bRVal = true;
                break;
            }
        }
    }

    _TRACE (-1, L"Leaving SeSidInSIDList: %s\n", bRVal ? L"TRUE" : L"FALSE");
    return bRVal;
}

HRESULT
SepAddAccessTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    IN ULONG StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate,
    IN PSID grantingSid
)
/*++

Routine Description:

    This routine grants the specified AccessMask to all of the objects that
    are descendents of the object specified by StartIndex.

    The Access fields of the parent objects are also recomputed as needed.

    For example, if an ACE granting access to a Property Set is found,
        that access is granted to all the Properties in the Property Set.

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the target element to update.

    AccessMask - Mask of access to grant to the target element and
        all of its decendents

    FieldToUpdate - Indicate which fields to update in object type list

Return Value:

    None.

--*/

{
    if ( !ObjectTypeList )
        return E_POINTER;
    if ( !IsValidSid (grantingSid) )
        return E_INVALIDARG;
    _TRACE (1, L"Entering  SepAddAccessTypeList\n");

    ACCESS_MASK OldRemaining = 0;
    ACCESS_MASK OldCurrentGranted = 0;
    ACCESS_MASK OldCurrentDenied = 0;
    BOOLEAN     AvoidParent = FALSE;
    HRESULT     hr = S_OK;

//    PAGED_CODE();

    //
    // Update the requested field.
    //
    // Always handle the target entry.
    //
    // If we've not actually changed the bits,
    //  early out.
    //

    switch (FieldToUpdate ) 
    {
    case UpdateRemaining:
        OldRemaining = ObjectTypeList[StartIndex].Remaining;
        ObjectTypeList[StartIndex].Remaining = OldRemaining & ~AccessMask;

        if ( OldRemaining == ObjectTypeList[StartIndex].Remaining ) 
        {
            return hr;
        }
        else
        {
            hr = SetGrantingSid (
                    ObjectTypeList[StartIndex], 
                    FieldToUpdate, 
                    OldRemaining,
                    AccessMask & ~ObjectTypeList[StartIndex].Remaining,
                    grantingSid);
        }
        break;

    case UpdateCurrentGranted:
        OldCurrentGranted = ObjectTypeList[StartIndex].CurrentGranted;
        ObjectTypeList[StartIndex].CurrentGranted |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentDenied;

        if ( OldCurrentGranted == ObjectTypeList[StartIndex].CurrentGranted ) 
        {
            //
            // We can't simply return here.
            // We have to visit our children.  Consider the case where there
            // was a previous deny ACE on a child.  That deny would have
            // propagated up the tree to this entry.  However, this allow ACE
            // needs to be added all of the children that haven't been
            // explictly denied.
            //
            AvoidParent = TRUE;
        }
        else
        {
            hr = SetGrantingSid (
                    ObjectTypeList[StartIndex], 
                    FieldToUpdate, 
                    OldCurrentGranted,
                    AccessMask & ~ObjectTypeList[StartIndex].CurrentDenied,
                    grantingSid);
        }
        break;

    case UpdateCurrentDenied:
        OldCurrentDenied = ObjectTypeList[StartIndex].CurrentDenied;
        ObjectTypeList[StartIndex].CurrentDenied |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentGranted;

        if ( OldCurrentDenied == ObjectTypeList[StartIndex].CurrentDenied ) 
        {
            return hr;
        }
        else
        {
            hr = SetGrantingSid (
                    ObjectTypeList[StartIndex], 
                    FieldToUpdate, 
                    OldCurrentDenied,
                    AccessMask & ~ObjectTypeList[StartIndex].CurrentGranted,
                    grantingSid);
        }
        break;

    default:
        return hr;
    }


    //
    // Go update parent of the target.
    //

    if ( !AvoidParent ) 
    {
        hr = SepUpdateParentTypeList( ObjectTypeList,
                                 ObjectTypeListLength,
                                 StartIndex,
                                 grantingSid);
    }

    //
    // Loop handling all children of the target.
    //

    for (ULONG Index = StartIndex + 1; Index < ObjectTypeListLength; Index++) 
    {
        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if ( ObjectTypeList[Index].Level <= ObjectTypeList[StartIndex].Level ) 
        {
            break;
        }

        //
        // Grant access to the children
        //

        switch (FieldToUpdate) 
        {
        case UpdateRemaining:
            ObjectTypeList[Index].Remaining &= ~AccessMask;
            hr = SetGrantingSid (
                    ObjectTypeList[Index], 
                    FieldToUpdate, 
                    OldRemaining,
                    ~AccessMask,
                    grantingSid);
            break;

        case UpdateCurrentGranted:
            ObjectTypeList[Index].CurrentGranted |=
                AccessMask & ~ObjectTypeList[Index].CurrentDenied;
            hr = SetGrantingSid (
                    ObjectTypeList[Index], 
                    FieldToUpdate, 
                    OldCurrentGranted,
                    AccessMask & ~ObjectTypeList[Index].CurrentDenied,
                    grantingSid);
            break;

        case UpdateCurrentDenied:
            ObjectTypeList[Index].CurrentDenied |=
                AccessMask & ~ObjectTypeList[Index].CurrentGranted;
            hr = SetGrantingSid (
                    ObjectTypeList[Index], 
                    FieldToUpdate, 
                    OldCurrentDenied,
                    AccessMask & ~ObjectTypeList[Index].CurrentGranted,
                    grantingSid);
            break;

        default:
            return hr;
        }
    }

    _TRACE (-1, L"Leaving SepAddAccessTypeList\n");
    return hr;
}


BOOLEAN
SepObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    OUT PULONG ReturnedIndex
)
/*++

Routine Description:

    This routine searches an ObjectTypeList to determine if the specified
    object type is in the list.

Arguments:

    ObjectType - Object Type to search for.

    ObjectTypeList - The object type list to search.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    ReturnedIndex - Index to the element ObjectType was found in


Return Value:

    TRUE: ObjectType was found in list.
    FALSE: ObjectType was not found in list.

--*/

{
    if ( !ObjectType || !ObjectTypeList )
        return FALSE;
    _TRACE (1, L"Entering  SepObjectInTypeList\n");

    BOOLEAN bRVal = FALSE;
    GUID*   LocalObjectType = 0;

#if DBG
    HRESULT     hr = S_OK;
    GUID_TYPE*  pType = 0;
    wstring     strClassName1;


    hr = _Module.GetClassFromGUID (*ObjectType, strClassName1, pType);
    ASSERT (SUCCEEDED (hr));
#endif

#pragma warning (disable : 4127)
    ASSERT( sizeof(GUID) == sizeof(ULONG) * 4 );
#pragma warning (default : 4127)

    for (ULONG Index = 0; Index < ObjectTypeListLength; Index++) 
    {
        LocalObjectType = &ObjectTypeList[Index].ObjectType;
#if DBG
        wstring strClassName2;

        hr = _Module.GetClassFromGUID (*LocalObjectType, strClassName2, pType);
        ASSERT (SUCCEEDED (hr));

        _TRACE (0, L"\tComparing %s to %s\n", strClassName1.c_str (), strClassName2.c_str ());
#endif
        if  ( RtlpIsEqualGuid( ObjectType, LocalObjectType ) ) 
        {
            *ReturnedIndex = Index;
            bRVal = TRUE;
            break;
        }
    }

    _TRACE (-1, L"Leaving SepObjectInTypeList: %s\n", bRVal ? L"TRUE" : L"FALSE");
    return bRVal;
}

HRESULT
SepUpdateParentTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN size_t ObjectTypeListLength,
    IN ULONG StartIndex,
    PSID    grantingSid
)
/*++

Routine Description:

    Update the Access fields of the parent object of the specified object.


        The "remaining" field of a parent object is the logical OR of
        the remaining field of all of its children.

        The CurrentGranted field of the parent is the collection of bits
        granted to every one of its children..

        The CurrentDenied fields of the parent is the logical OR of
        the bits denied to any of its children.

    This routine takes an index to one of the children and updates the
    remaining field of the parent (and grandparents recursively).

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the "child" element whose parents are to be updated.

Return Value:

    None.


--*/

{
    if ( !ObjectTypeList )
        return E_POINTER;
    if ( !IsValidSid (grantingSid) )
        return E_INVALIDARG;
    _TRACE (1, L"Entering  SepUpdateParentTypeList\n");

    ACCESS_MASK NewRemaining = 0;
    ACCESS_MASK NewCurrentGranted = 0xFFFFFFFF;
    ACCESS_MASK NewCurrentDenied = 0;
    HRESULT     hr = S_OK;
 
    //
    // If the target node is at the root,
    //  we're all done.
    //

    if ( ObjectTypeList[StartIndex].ParentIndex == -1 ) 
    {
        return hr;
    }

    //
    // Get the index to the parent that needs updating and the level of
    // the siblings.
    //

    ULONG   ParentIndex = ObjectTypeList[StartIndex].ParentIndex;
    ULONG   Level = ObjectTypeList[StartIndex].Level;

    //
    // Loop through all the children.
    //

    for (UINT Index=ParentIndex+1; Index<ObjectTypeListLength; Index++ ) 
    {
        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if ( ObjectTypeList[Index].Level <= ObjectTypeList[ParentIndex].Level ) 
        {
            break;
        }

        //
        // Only handle direct children of the parent.
        //

        if ( ObjectTypeList[Index].Level != Level ) 
        {
            continue;
        }

        //
        // Compute the new bits for the parent.
        //

        NewRemaining |= ObjectTypeList[Index].Remaining;
        NewCurrentGranted &= ObjectTypeList[Index].CurrentGranted;
        NewCurrentDenied |= ObjectTypeList[Index].CurrentDenied;

    }

    //
    // If we've not changed the access to the parent,
    //  we're done.
    //

    if ( NewRemaining == ObjectTypeList[ParentIndex].Remaining &&
         NewCurrentGranted == ObjectTypeList[ParentIndex].CurrentGranted &&
        NewCurrentDenied == ObjectTypeList[ParentIndex].CurrentDenied ) 
    {
        return hr;
    }


    //
    // Change the parent.
    //

    hr = SetGrantingSid (
            ObjectTypeList[ParentIndex], 
            UpdateRemaining, 
            ObjectTypeList[ParentIndex].Remaining,
            NewRemaining,
            grantingSid);
    ObjectTypeList[ParentIndex].Remaining = NewRemaining;
    hr = SetGrantingSid (
            ObjectTypeList[ParentIndex], 
            UpdateCurrentGranted, 
            ObjectTypeList[ParentIndex].CurrentGranted,
            NewCurrentGranted,
            grantingSid);
    ObjectTypeList[ParentIndex].CurrentGranted = NewCurrentGranted;
    hr = SetGrantingSid (
            ObjectTypeList[ParentIndex], 
            UpdateCurrentDenied, 
            ObjectTypeList[ParentIndex].CurrentDenied,
            NewCurrentDenied,
            grantingSid);
    ObjectTypeList[ParentIndex].CurrentDenied = NewCurrentDenied;

    //
    // Go update the grand parents.
    //

    hr = SepUpdateParentTypeList( ObjectTypeList,
                             ObjectTypeListLength,
                             ParentIndex,
                             grantingSid);

    _TRACE (-1, L"Leaving SepUpdateParentTypeList\n");
    return hr;
}

PSID AllocAndCopySid (PSID pSid)
{
    if ( !pSid )
        return 0;

    DWORD   dwSidLen = GetLengthSid (pSid);
    PSID    pSidCopy = CoTaskMemAlloc (dwSidLen);
    
    if ( pSidCopy )
    {
        if ( CopySid (dwSidLen, pSidCopy, pSid) )
        {
            ASSERT (IsValidSid (pSidCopy));
        }
    }

    return pSidCopy;
}

HRESULT SetGrantingSid (
        IOBJECT_TYPE_LIST& ObjectTypeItem, 
        ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate, 
        ACCESS_MASK oldAccessBits,
        ACCESS_MASK newAccessBits,
        PSID grantingSid)
{
    if ( !IsValidSid (grantingSid) )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    UINT    nSid = 0;

    for (ULONG nBit = 0x1; nBit; nBit <<= 1, nSid++)
    {
        if ( (newAccessBits & nBit) &&
             !(oldAccessBits & nBit) )
        {
            switch (FieldToUpdate)
            {
            case UpdateCurrentGranted:
                if ( !ObjectTypeItem.grantingSid[nSid] )
                {
                    ObjectTypeItem.grantingSid[nSid] = AllocAndCopySid (grantingSid);
                    if ( !ObjectTypeItem.grantingSid[nSid] )
                        hr = E_OUTOFMEMORY;
                    break;
                }
                break;

            case UpdateCurrentDenied:
                if ( !ObjectTypeItem.denyingSid[nSid] )
                {
                    ObjectTypeItem.denyingSid[nSid] = AllocAndCopySid (grantingSid);
                    if ( !ObjectTypeItem.denyingSid[nSid] )
                        hr = E_OUTOFMEMORY;
                    break;
                }
                break;

            case UpdateRemaining:
                break;

            default:
                break;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\accessck.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       AccessCk.h
//
//  Contents:   Code copied and modified from private\ntos\se\accessck.c
//              
//
//----------------------------------------------------------------------------
#ifndef __ACCESSCK_ADUTILS_H
#define __ACCESSCK_ADUTILS_H

#define SID_ARRAY_SIZE  sizeof (ULONG) * 8

class IOBJECT_TYPE_LIST {
public:
    IOBJECT_TYPE_LIST () :
        Level (0),
        Flags (0),
        ParentIndex (0),
        Remaining (0),
        CurrentGranted (0),
        CurrentDenied (0)
    {
        ::ZeroMemory (&ObjectType, sizeof (GUID));
        ::ZeroMemory (grantingSid, sizeof (grantingSid));
        ::ZeroMemory (denyingSid, sizeof (denyingSid));
    }
    ~IOBJECT_TYPE_LIST ()
    {
        for (UINT nIndex = 0; nIndex < SID_ARRAY_SIZE; nIndex++)
        {
            if ( grantingSid[nIndex] )
                CoTaskMemFree (grantingSid[nIndex]);
            if ( denyingSid[nIndex] )
                CoTaskMemFree (denyingSid[nIndex]);
        }
    }


    USHORT Level;
    USHORT Flags;
#define OBJECT_SUCCESS_AUDIT 0x1
#define OBJECT_FAILURE_AUDIT 0x2
    GUID ObjectType;
    LONG ParentIndex;
    ULONG Remaining;
    ULONG CurrentGranted;
    ULONG CurrentDenied;
    PSID  grantingSid[SID_ARRAY_SIZE];
    PSID  denyingSid[SID_ARRAY_SIZE];
};


typedef IOBJECT_TYPE_LIST*  PIOBJECT_TYPE_LIST;


HRESULT SepInit ();
VOID    SepCleanup ();

HRESULT
SepMaximumAccessCheck(
    list<PSID>& psidList,
    IN PACL Dacl,
    IN PSID PrincipalSelfSid,
    IN size_t LocalTypeListLength,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN size_t ObjectTypeListLength);

NTSTATUS
SeCaptureObjectTypeList (
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN size_t ObjectTypeListLength,
    OUT PIOBJECT_TYPE_LIST *CapturedObjectTypeList
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\adsiobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2002.
//
//  File:       ADSIObj.cpp
//
//  Contents:   ADSI Object 
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "ADSIObj.h"
#include "ADUtils.h"


HRESULT CACLAdsiObject::AddAttrGUIDToList (
        const BSTR pszAttrName, 
        list<POBJECT_TYPE_LIST>& guidList)
{
    _TRACE (1, L"Entering  CACLAdsiObject::AddAttrGUIDToList ()\n");
    HRESULT hr = S_OK;
    CComPtr<IADsPathname>   spPathname;

    //
    // Constructing the directory paths
    //
    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG (IADsPathname, &spPathname));
    if ( SUCCEEDED (hr) )
    {
        ASSERT (!!spPathname);

        hr = spPathname->Set (CComBSTR (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (CComBSTR (GetPhysicalSchemaNamingContext()), 
                    ADS_SETTYPE_DN);
            if ( SUCCEEDED (hr) )
            {
                BSTR strAttrCommonName = 0;
                hr = ReadSchemaAttributeCommonName (pszAttrName, &strAttrCommonName);
                if ( SUCCEEDED (hr) )
                {
                    wstring strLeaf;
                    
                    FormatMessage (strLeaf, L"CN=%1", strAttrCommonName);
                    hr = spPathname->AddLeafElement(CComBSTR (strLeaf.c_str ()));
                    if ( SUCCEEDED (hr) )
                    {
                        BSTR bstrFullPath = 0;
                        hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
                        if ( SUCCEEDED (hr) )
                        {
                            CComPtr<IDirectoryObject> spDirObj;


                            hr = ADsOpenObjectHelper(bstrFullPath,
                                                     IID_IDirectoryObject, 
                                                     0,
                                                     (void**)&spDirObj);
                            if ( SUCCEEDED (hr) )
                            {
                                GUID*               pGUID = 0;
                                POBJECT_TYPE_LIST   pOtl = 0;
                                bool                bPropertySetFound = false;

                                // Property set GUIDs must be added before property GUIDs
                                // See documentation for "AccessCheckByTypeResultList
                                {
                                    // Get attribute security GUID (property set GUID)
                                    PADS_ATTR_INFO  pAttrs = 0;
                                    DWORD           cAttrs = 0;
                                    LPWSTR          rgpwzAttrNames[] = {L"attributeSecurityGUID"};

                                    hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                        {   
                                            if ( pAttrs->pADsValues->OctetString.dwLength == sizeof (GUID) )
                                            {
                                                bPropertySetFound = true;
                                                pGUID = (GUID*) CoTaskMemAlloc (sizeof (GUID));
                                                if ( pGUID )
                                                {
                                                    bool    bFound = false;
                                            

                                                    memcpy (pGUID, 
                                                            pAttrs->pADsValues->OctetString.lpValue,
                                                            pAttrs->pADsValues->OctetString.dwLength);
                                                    for (list<POBJECT_TYPE_LIST>::iterator itr = guidList.begin ();
                                                            itr != guidList.end ();
                                                            itr++)
                                                    {
                                                        if ( ::IsEqualGUID (*((*itr)->ObjectType), *pGUID) )
                                                        {
                                                            bFound = true;
                                                            break;
                                                        }
                                                    }

                                                    if ( !bFound )
                                                    {
                                                        pOtl = (POBJECT_TYPE_LIST) CoTaskMemAlloc (sizeof (OBJECT_TYPE_LIST));
                                                        if ( pOtl )
                                                        {
                                                            ::ZeroMemory (pOtl, sizeof (OBJECT_TYPE_LIST));
                                                            pOtl->Level = ACCESS_PROPERTY_SET_GUID;
                                                            pOtl->ObjectType = pGUID;
                                                            pOtl->Sbz = 0;
                                                            guidList.push_back (pOtl);
                                                        }
                                                        else
                                                        {
                                                            CoTaskMemFree (pGUID);
                                                            hr = E_OUTOFMEMORY;
                                                        }
                                                    }
                                                    else
                                                        CoTaskMemFree (pGUID);
                                                }
                                                else
                                                    hr = E_OUTOFMEMORY;
                                            }
                                            else
                                                hr = E_UNEXPECTED;
                                        }
                                        if ( pAttrs )
                                            FreeADsMem (pAttrs);
                                    }
                                    else
                                    {
                                        _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                                    }
                                }


                                if ( SUCCEEDED (hr) )
                                {
                                    // Get attribute GUID (schemaIDGUID)
                                    PADS_ATTR_INFO  pAttrs = 0;
                                    DWORD           cAttrs = 0;
                                    LPWSTR          rgpwzAttrNames[] = {L"schemaIDGUID"};

                                    hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                        {   
                                            if ( pAttrs->pADsValues->OctetString.dwLength == sizeof (GUID) )
                                            {
                                                pGUID = (GUID*) CoTaskMemAlloc (sizeof (GUID));
                                                if ( pGUID )
                                                {
                                                    memcpy (pGUID, 
                                                            pAttrs->pADsValues->OctetString.lpValue,
                                                            pAttrs->pADsValues->OctetString.dwLength);
                                                    pOtl = (POBJECT_TYPE_LIST) CoTaskMemAlloc (sizeof (OBJECT_TYPE_LIST));
                                                    if ( pOtl )
                                                    {
                                                        ::ZeroMemory (pOtl, sizeof (OBJECT_TYPE_LIST));
                                                        if ( bPropertySetFound )
                                                            pOtl->Level = ACCESS_PROPERTY_GUID;
                                                        else
                                                            pOtl->Level = ACCESS_PROPERTY_SET_GUID;
                                                        pOtl->ObjectType = pGUID;
                                                        pOtl->Sbz = 0;
                                                        guidList.push_back (pOtl);
                                                    }
                                                    else
                                                    {
                                                        CoTaskMemFree (pGUID);
                                                        hr = E_OUTOFMEMORY;
                                                    }
                                                }
                                                else
                                                    hr = E_OUTOFMEMORY;
                                            }
                                            else
                                                hr = E_UNEXPECTED;
                                        }

                                        if ( pAttrs )
                                            FreeADsMem (pAttrs);
                                    }
                                    else
                                    {
                                        _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                                    }
                                }
                            }
                            else
                            {
                                _TRACE (0, L"ADsOpenObjectHelper (%s) failed: 0x%x\n", bstrFullPath);
                      
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IADsPathname->Retrieve () failed: 0x%x\n", hr);
                        }
                    }
                    else
                    {
                        _TRACE (0, L"IADsPathname->AddLeafElement (%s) failed: 0x%x\n", 
                                strLeaf.c_str (), hr);
                    }
                    SysFreeString (strAttrCommonName);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        GetPhysicalSchemaNamingContext(), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CACLAdsiObject::AddAttrGUIDToList (): 0x%x\n", hr);
    return hr;
}


HRESULT CACLAdsiObject::BuildObjectTypeList (POBJECT_TYPE_LIST* pObjectTypeList, size_t& objectTypeListLength)
{
    _TRACE (1, L"Entering  CACLAdsiObject::BuildObjectTypeList ()\n");
    if ( !pObjectTypeList )
        return E_POINTER;

    HRESULT                 hr = S_OK;   
    CComPtr<IADsPathname>   spPathname;
    list<POBJECT_TYPE_LIST> guidList;

    //
    // Constructing the directory paths
    //
    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG (IADsPathname, &spPathname));
    if ( SUCCEEDED (hr) )
    {
        ASSERT (!!spPathname);
        hr = spPathname->Set (CComBSTR (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (CComBSTR (GetPhysicalSchemaNamingContext()), 
                    ADS_SETTYPE_DN);
            if ( SUCCEEDED (hr) )
            {
                wstring strLeaf;
                
                FormatMessage (strLeaf, L"CN=%1", GetSchemaCommonName ());
                hr = spPathname->AddLeafElement(CComBSTR (strLeaf.c_str ()));
                if ( SUCCEEDED (hr) )
                {

                    BSTR bstrFullPath = 0;
                    hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
                    if ( SUCCEEDED (hr) )
                    {
                        CComPtr<IDirectoryObject> spDirObj;


                        hr = ADsOpenObjectHelper (bstrFullPath,
                                                  IID_IDirectoryObject, 
                                                  0,
                                                  (void**)&spDirObj);
                        if ( SUCCEEDED (hr) )
                        {
                            GUID*               pGUID = 0;
                            POBJECT_TYPE_LIST   pOtl = 0;


                            {
                                // Get class GUID (schemaIDGUID)
                                LPWSTR          rgpwzAttrNames1[] = {L"schemaIDGUID"};
                                PADS_ATTR_INFO  pAttrs = 0;
                                DWORD           cAttrs = 0;

                                hr = spDirObj->GetObjectAttributes(rgpwzAttrNames1, 1, &pAttrs, &cAttrs);
                                if ( SUCCEEDED (hr) )
                                {
                                    if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                    {   
                                        if ( pAttrs->pADsValues->OctetString.dwLength == sizeof (GUID) )
                                        {
                                            pGUID = (GUID*) CoTaskMemAlloc (sizeof (GUID));
                                            if ( pGUID )
                                            {
                                                memcpy (pGUID, 
                                                        pAttrs->pADsValues->OctetString.lpValue,
                                                        pAttrs->pADsValues->OctetString.dwLength);

                                                pOtl = (POBJECT_TYPE_LIST) CoTaskMemAlloc (sizeof (OBJECT_TYPE_LIST));
                                                if ( pOtl )
                                                {
                                                    ::ZeroMemory (pOtl, sizeof (OBJECT_TYPE_LIST));
                                                    pOtl->Level = ACCESS_OBJECT_GUID;
                                                    pOtl->ObjectType = pGUID;
                                                    pOtl->Sbz = 0;
                                                    guidList.push_back (pOtl);
                                                }
                                                else
                                                {
                                                    CoTaskMemFree (pGUID);
                                                    hr = E_OUTOFMEMORY;
                                                }
                                            }
                                            else
                                                hr = E_OUTOFMEMORY;
                                        }
                                        else
                                            hr = E_UNEXPECTED;
                                        
                                    }

                                    if ( pAttrs )
                                        FreeADsMem (pAttrs);
                                }
                                else
                                {
                                    _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                                }
                            }

                            if ( SUCCEEDED (hr) )
                            {
                                //
                                // Get "allowedAttributes" attribute
                                //
                                PADS_ATTR_INFO  pAttrs = 0;
                                DWORD           cAttrs = 0;
                                LPWSTR          rgpwzAttrNames2[] = {L"allowedAttributes"};

                                hr = spDirObj->GetObjectAttributes(rgpwzAttrNames2, 1, &pAttrs, &cAttrs);
                                if ( SUCCEEDED (hr) )
                                {
                                    if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                    {
                                        for (DWORD  dwIdx = 0; 
                                                dwIdx < pAttrs->dwNumValues && SUCCEEDED (hr); 
                                                dwIdx++)
                                        {
                                            hr = AddAttrGUIDToList (
                                                    CComBSTR (pAttrs->pADsValues[dwIdx].CaseIgnoreString), 
                                                    guidList);
                                        }
                                    }
                                    if ( pAttrs )
                                        FreeADsMem (pAttrs);
                                }
                                else
                                {
                                    _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                                }
                            }

                            if ( SUCCEEDED (hr) )
                            {
                                objectTypeListLength = guidList.size ();
                                *pObjectTypeList = (POBJECT_TYPE_LIST) CoTaskMemAlloc (
                                        sizeof (OBJECT_TYPE_LIST) + (sizeof (GUID) * objectTypeListLength));
                                if ( *pObjectTypeList )
                                {
                                    DWORD idx = 0;
                                    list<POBJECT_TYPE_LIST>::iterator itr = guidList.begin ();

                                    for (; idx < objectTypeListLength && itr != guidList.end (); 
                                            idx++, itr++)
                                    {
                                        pOtl = *itr;
                                        (*pObjectTypeList)[idx].Level = pOtl->Level;
                                        // Note just copy pointer here and don't free the pOtl->ObjectType later.
                                        (*pObjectTypeList)[idx].ObjectType = pOtl->ObjectType;
                                        pOtl->ObjectType = 0;
                                        (*pObjectTypeList)[idx].Sbz = 0;
                                        CoTaskMemFree (pOtl);
                                    }
                                }
                                else
                                    hr = E_OUTOFMEMORY;
                            }
                        }
                        else
                        {
                            _TRACE (0, L"ADsOpenObjectHelper (%s) failed: 0x%x\n", bstrFullPath);
                      
                        }
                    }
                    else
                    {
                        _TRACE (0, L"IADsPathname->Retrieve () failed: 0x%x\n", hr);
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->AddLeafElement (%s) failed: 0x%x\n", 
                            strLeaf.c_str (), hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        GetPhysicalSchemaNamingContext(), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CACLAdsiObject::BuildObjectTypeList (): 0x%x\n", hr);
    return hr;
}


HRESULT CACLAdsiObject::ReadSchemaCommonName ()
{
    _TRACE (1, L"Entering  CACLAdsiObject::ReadSchemaCommonName ()\n");
    HRESULT hr = S_OK;
    CComPtr<IADsPathname>   spPathname;


    //
    // Constructing the directory paths
    //
    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG (IADsPathname, &spPathname));
    if ( SUCCEEDED (hr) )
    {
        ASSERT (!!spPathname);
        hr = spPathname->Set (CComBSTR (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (CComBSTR (GetPhysicalSchemaNamingContext()), 
                    ADS_SETTYPE_DN);
            if ( SUCCEEDED (hr) )
            {
                BSTR bstrFullPath = 0;
                hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
                if ( SUCCEEDED (hr) )
                {
                    CComPtr<IDirectoryObject> spDirObj;


                    hr = ADsOpenObjectHelper (bstrFullPath,
                                              IID_IDirectoryObject, 
                                              0,
                                              (void**)&spDirObj);
                    if ( SUCCEEDED (hr) )
                    {
                        CComPtr<IDirectorySearch>   spDsSearch;
                        hr = spDirObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
                        if ( SUCCEEDED (hr) )
                        {
                            ASSERT (!!spDsSearch);
                            ADS_SEARCHPREF_INFO pSearchPref[2];
                            DWORD dwNumPref = 2;

                            pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
                            pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
                            pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
                            pSearchPref[1].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
                            pSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
                            pSearchPref[1].vValue.Integer = ADS_CHASE_REFERRALS_NEVER;

                            hr = spDsSearch->SetSearchPreference(
                                     pSearchPref,
                                     dwNumPref
                                     );
                            if ( SUCCEEDED (hr) )
                            {
                                PWSTR               rgszAttrList[] = {L"cn"};
                                ADS_SEARCH_HANDLE   hSearchHandle = 0;
                                DWORD               dwNumAttributes = 1;
                                wstring            strQuery;
                                ADS_SEARCH_COLUMN   Column;

                                ::ZeroMemory (&Column, sizeof (ADS_SEARCH_COLUMN));
                                FormatMessage (strQuery, 
                                        L"lDAPDisplayName=%1",
                                        this->GetClass ());

                                hr = spDsSearch->ExecuteSearch(
                                                     const_cast <LPWSTR>(strQuery.c_str ()),
                                                     rgszAttrList,
                                                     dwNumAttributes,
                                                     &hSearchHandle
                                                     );
                                if ( SUCCEEDED (hr) )
                                {
                                    hr = spDsSearch->GetFirstRow (hSearchHandle);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        while (hr != S_ADS_NOMORE_ROWS )
                                        {
                                            //
                                            // Getting current row's information
                                            //
                                            hr = spDsSearch->GetColumn(
                                                     hSearchHandle,
                                                     rgszAttrList[0],
                                                     &Column
                                                     );
                                            if ( SUCCEEDED (hr) )
                                            {
                                                m_strSchemaCommonName = Column.pADsValues->CaseIgnoreString;

                                                spDsSearch->FreeColumn (&Column);
                                                Column.pszAttrName = NULL;
                                                break;
                                            }
                                            else if ( hr != E_ADS_COLUMN_NOT_SET )
                                            {
                                                break;
                                            }
                                            else
                                            {
                                                _TRACE (0, L"IDirectorySearch::GetColumn (): 0x%x\n", hr);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        _TRACE (0, L"IDirectorySearch::GetFirstRow (): 0x%x\n", hr);
                                    }

                                    if (Column.pszAttrName)
                                    {
                                        spDsSearch->FreeColumn(&Column);
                                    }
                                    spDsSearch->CloseSearchHandle(hSearchHandle);
                                }
                                else
                                {
                                    _TRACE (0, L"IDirectorySearch::ExecuteSearch (): 0x%x\n", hr);
                                    hr = S_OK;
                                }
                            }
                            else
                            {
                                _TRACE (0, L"IDirectorySearch::SetSearchPreference (): 0x%x\n", hr);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch): 0x%x\n", hr);
                        }
                   }
                    else
                    {
                        _TRACE (0, L"ADsOpenObjectHelper (%s) failed: 0x%x\n", bstrFullPath);
                  
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve () failed: 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        GetPhysicalSchemaNamingContext(), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CACLAdsiObject::ReadSchemaCommonName (): 0x%x\n", hr);
    return hr;
}

HRESULT CACLAdsiObject::Bind(LPCWSTR lpszLdapPath)
{
    _TRACE (1, L"Entering  CACLAdsiObject::Bind ()\n");
    HRESULT hr = CAdsiObject::Bind (lpszLdapPath);
    if ( SUCCEEDED (hr) )
    {
        hr = ReadSchemaCommonName ();
    }

    _TRACE (-1, L"Leaving CACLAdsiObject::Bind (): 0x%x\n", hr);
    return hr;
}

HRESULT CACLAdsiObject::ReadSchemaAttributeCommonName (const BSTR pszAttrName, BSTR* ppszAttrCommonName)
{
    _TRACE (1, L"Entering  CACLAdsiObject::ReadSchemaAttributeCommonName ()\n");
    if ( !pszAttrName || !ppszAttrCommonName )
        return E_POINTER;

    HRESULT hr = S_OK;
    CComPtr<IADsPathname>   spPathname;


    //
    // Constructing the directory paths
    //
    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG (IADsPathname, &spPathname));
    if ( SUCCEEDED (hr) )
    {
        ASSERT (!!spPathname);
        hr = spPathname->Set (CComBSTR (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (CComBSTR (GetPhysicalSchemaNamingContext()), 
                    ADS_SETTYPE_DN);
            if ( SUCCEEDED (hr) )
            {
                BSTR bstrFullPath = 0;
                hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
                if ( SUCCEEDED (hr) )
                {
                    CComPtr<IDirectoryObject> spDirObj;


                    hr = ADsOpenObjectHelper (bstrFullPath,
                                              IID_IDirectoryObject, 
                                              0,
                                              (void**)&spDirObj);
                    if ( SUCCEEDED (hr) )
                    {
                        CComPtr<IDirectorySearch>   spDsSearch;
                        hr = spDirObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
                        if ( SUCCEEDED (hr) )
                        {
                            ASSERT (!!spDsSearch);
                            ADS_SEARCHPREF_INFO pSearchPref[2];
                            DWORD dwNumPref = 2;

                            pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
                            pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
                            pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
                            pSearchPref[1].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
                            pSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
                            pSearchPref[1].vValue.Integer = ADS_CHASE_REFERRALS_NEVER;

                            hr = spDsSearch->SetSearchPreference(
                                     pSearchPref,
                                     dwNumPref
                                     );
                            if ( SUCCEEDED (hr) )
                            {
                                PWSTR               rgszAttrList[] = {L"cn"};
                                ADS_SEARCH_HANDLE   hSearchHandle = 0;
                                DWORD               dwNumAttributes = 1;
                                wstring             strQuery;
                                ADS_SEARCH_COLUMN   Column;

                                ::ZeroMemory (&Column, sizeof (ADS_SEARCH_COLUMN));
                                FormatMessage (strQuery, 
                                        L"lDAPDisplayName=%1",
                                        pszAttrName);

                                hr = spDsSearch->ExecuteSearch(
                                                     const_cast <LPWSTR>(strQuery.c_str ()),
                                                     rgszAttrList,
                                                     dwNumAttributes,
                                                     &hSearchHandle
                                                     );
                                if ( SUCCEEDED (hr) )
                                {
                                    hr = spDsSearch->GetFirstRow (hSearchHandle);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        while (hr != S_ADS_NOMORE_ROWS )
                                        {
                                            //
                                            // Getting current row's information
                                            //
                                            hr = spDsSearch->GetColumn(
                                                     hSearchHandle,
                                                     rgszAttrList[0],
                                                     &Column
                                                     );
                                            if ( SUCCEEDED (hr) )
                                            {
                                                *ppszAttrCommonName = SysAllocString (Column.pADsValues->CaseIgnoreString);
                                                if ( !(*ppszAttrCommonName) )
                                                    hr = E_OUTOFMEMORY;
                                                spDsSearch->FreeColumn (&Column);
                                                Column.pszAttrName = NULL;
                                                break;
                                            }
                                            else if ( hr != E_ADS_COLUMN_NOT_SET )
                                            {
                                                break;
                                            }
                                            else
                                            {
                                                _TRACE (0, L"IDirectorySearch::GetColumn (): 0x%x\n", hr);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        _TRACE (0, L"IDirectorySearch::GetFirstRow (): 0x%x\n", hr);
                                    }

                                    if (Column.pszAttrName)
                                    {
                                        spDsSearch->FreeColumn(&Column);
                                    }
                                    spDsSearch->CloseSearchHandle(hSearchHandle);
                                }
                                else
                                {
                                    _TRACE (0, L"IDirectorySearch::ExecuteSearch (): 0x%x\n", hr);
                                    hr = S_OK;
                                }
                            }
                            else
                            {
                                _TRACE (0, L"IDirectorySearch::SetSearchPreference (): 0x%x\n", hr);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch): 0x%x\n", hr);
                        }
                   }
                    else
                    {
                        _TRACE (0, L"ADsOpenObjectHelper (%s) failed: 0x%x\n", bstrFullPath);
                  
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve () failed: 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        GetPhysicalSchemaNamingContext(), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CACLAdsiObject::ReadSchemaAttributeCommonName (): 0x%x\n", hr);
    return hr;
}

HRESULT CACLAdsiObject::GetPrincipalSelfSid(PSID &principalSelfSid)
{
    _TRACE (1, L"Entering  CACLAdsiObject::GetPrincipalSelfSid ()\n");

    HRESULT hr = S_OK;

    ASSERT (!!m_spIADs);
    if ( !!m_spIADs )
    {
        CComPtr<IDirectoryObject> spDirObj;
        hr = m_spIADs->QueryInterface (IID_PPV_ARG(IDirectoryObject, &spDirObj));
        if ( SUCCEEDED (hr) )
        {
            ASSERT ( !!spDirObj);
            //
            // Get "objectSid" attribute
            //
            const PWSTR     wzAllowedAttributes = L"objectSid";
            PADS_ATTR_INFO  pAttrs = 0;
            DWORD           cAttrs = 0;
            LPWSTR          rgpwzAttrNames[] = {wzAllowedAttributes};

            hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
            if ( SUCCEEDED (hr) )
            {
                if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues && 1 == pAttrs->dwNumValues )
                {
                    PSID    pSid = pAttrs->pADsValues->OctetString.lpValue;
                    DWORD   dwSidLen = GetLengthSid (pSid);
                    PSID    pSidCopy = CoTaskMemAlloc (dwSidLen);
                    
                    if ( pSidCopy )
                    {
                        if ( CopySid (dwSidLen, pSidCopy, pSid) )
                        {
                            ASSERT (IsValidSid (pSidCopy));
                            principalSelfSid = pSidCopy;
                        }
                        else
                        {
                            CoTaskMemFree (pSidCopy);
                            hr = GetLastError ();
                            _TRACE (0, L"CopySid () failed: 0x%x\n", hr);
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                    principalSelfSid = 0;
                if ( pAttrs )
                    FreeADsMem (pAttrs);
            }
            else
            {
                _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
            }
        }
        else
        {
            _TRACE (0, L"IADs->QueryInterface (IDirectoryObject): 0x%x\n", hr);
        }
    }
    else
        hr = E_UNEXPECTED;
    
    _TRACE (-1, L"Leaving CACLAdsiObject::GetPrincipalSelfSid (): 0x%x\n", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\acldiag.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ACLDiag.cpp
//
//  Contents:   Defines the entry point for the console application.
//              
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "adutils.h"
#include "SecDesc.h"
#include "schema.h"
#include "ChkDeleg.h"
#include "EffRight.h"

CACLDiagComModule _Module;

// Function prototypes
void DisplayHelp ();


// Command-line options string constants
const wstring strSchemaFlag = L"/schema";
const wstring strCheckDelegationFlag = L"/chkdeleg";
const wstring strGetEffectiveFlag = L"/geteffective:";
const wstring strFixDelegationFlag = L"/fixdeleg";
const wstring strTabDelimitedOutputFlag = L"/tdo";
const wstring strLogFlag = L"/log:";
const wstring strHelpFlag = L"/?"; 
const wstring strSkipDescriptionFlag = L"/skip";

int _cdecl main(int argc, char* argv[])
{
    UNREFERENCED_PARAMETER (argv);

    // If no arguments provided, display the help
    if ( 1 == argc )
    {
        DisplayHelp ();
        return 0;
    }

#if DBG
    CheckDebugOutputLevel ();
#endif

    LPCWSTR * lpServiceArgVectors = 0;  // Array of pointers to string
    int cArgs = 0;                      // Count of arguments
    size_t lenEffectiveFlag = strGetEffectiveFlag.length ();
    size_t lenLogFlag = strLogFlag.length ();

    lpServiceArgVectors = (LPCWSTR *)CommandLineToArgvW(GetCommandLineW(), OUT &cArgs);
    if (lpServiceArgVectors == NULL)
        return NULL;
    for (int nToken = 1; nToken < cArgs; nToken++)
    {
        ASSERT(lpServiceArgVectors[nToken] != NULL);
        if ( !lpServiceArgVectors[nToken] )
            break;
        
        wstring strToken = lpServiceArgVectors[nToken]; // Copy the string

        switch (nToken)
        {
            case 0:     // appName: skip
                continue;   

            case 1:     // object name or a help flag
                if ( !_wcsnicmp (strHelpFlag.c_str (), strToken.c_str (), 
                        strToken.length ()) )
                {
                    DisplayHelp ();
                    return 0;
                }
                else
                    _Module.SetObjectDN (strToken);
                break;

            default:
                {
                    size_t lenToken = strToken.length ();
                    if ( !_wcsnicmp (strSchemaFlag.c_str (), strToken.c_str (), 
                            lenToken))
                    {
                        _Module.SetDoSchema ();
                    }
                    else if ( !_wcsnicmp (strCheckDelegationFlag.c_str (), 
                            strToken.c_str (), lenToken) )
                    {
                        _Module.SetCheckDelegation ();
                    }
                    else if ( !_wcsnicmp (strGetEffectiveFlag.c_str (), 
                            strToken.c_str (), lenEffectiveFlag) )
                    {
                        wstring strUserGroup = strToken.substr(lenEffectiveFlag,
                                lenToken - lenEffectiveFlag);
                        _Module.SetDoGetEffective (strUserGroup);
                    }
                    else if ( !_wcsnicmp (strFixDelegationFlag.c_str (), 
                            strToken.c_str (), lenToken) )
                    {
                        _Module.SetFixDelegation ();
                    }
                    else if ( !_wcsnicmp (strTabDelimitedOutputFlag.c_str (), 
                            strToken.c_str (), lenToken) )
                    {
                        _Module.SetTabDelimitedOutput ();
                    }
                    else if ( !_wcsnicmp (strLogFlag.c_str (), strToken.c_str (), 
                            lenLogFlag) )
                    {
                        wstring strPath = strToken.substr(lenLogFlag, lenToken - lenLogFlag);
                        _Module.SetDoLog (strPath);
                    }
                    else if ( !_wcsnicmp (strSkipDescriptionFlag.c_str (), 
                            strToken.c_str (), lenToken) )
                    {
                        _Module.SetSkipDescription ();;
                    }
                    else if ( !_wcsnicmp (strHelpFlag.c_str (), strToken.c_str (), 
                            lenToken) )
                    {
                        DisplayHelp ();
                        return 0;
                    }
                    else
                    {
                        wstring    str;

                        FormatMessage (str, IDS_INVALID_OPTION, strToken.c_str ());
                        MyWprintf (str.c_str ());
                        DisplayHelp ();
                        return 0;
                    }
                }
                break;
        }
    }
    LocalFree (lpServiceArgVectors);


    HRESULT hr = CoInitialize(NULL);
    if ( SUCCEEDED (hr) ) 
    {
        hr = _Module.Init ();
        if ( SUCCEEDED (hr) )
        {
            hr = DoSecurityDescription ();

            if ( SUCCEEDED (hr) && _Module.DoSchema () )
                hr = DoSchemaDiagnosis ();

            if ( SUCCEEDED (hr) && _Module.CheckDelegation () )
                hr = CheckDelegation ();

            if ( SUCCEEDED (hr) && _Module.DoGetEffective () )
                hr = EffectiveRightsDiagnosis ();
        }
        else
            DisplayHelp ();
    }
    else
    {
        _TRACE (0, L"CoInitialize Failed with %x\n",hr);
        return 0;
    }

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
//
//  Method: DisplayHelp
//
//  Print the purpose of the tool and each of the command-line options.
//
///////////////////////////////////////////////////////////////////////////////
void DisplayHelp ()
{
    CWString    str;
    int         helpIDs[] = {IDS_HELP_MAIN, 
                            IDS_HELP_SCHEMA, 
                            IDS_HELP_CHKDELEG,
                            IDS_HELP_GETEFFECTIVE,
                            IDS_HELP_FIXDELEG,
//                            IDS_HELP_LOG,
                            IDS_HELP_SKIP_DESCRIPTION,
                            IDS_HELP_CDO,
                            IDS_HELP_EXAMPLE,
                            0};

    for (int nIndex = 0; helpIDs[nIndex]; nIndex++)
    {
        str.LoadFromResource (helpIDs[nIndex]);
        MyWprintf (str.c_str ());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\adsiobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ADSIObj.h
//
//  Contents:   Classes CACLAdsiObject
//              
//
//----------------------------------------------------------------------------
#ifndef __ADSIOBJ_ADUTILS_H
#define __ADSIOBJ_ADUTILS_H

#include "stdafx.h"
#include "util.h"

class CACLAdsiObject : public CAdsiObject 
{
public:  
	HRESULT GetPrincipalSelfSid (PSID& principalSelfSid);
    CACLAdsiObject () : CAdsiObject ()
    {
    }

    virtual ~CACLAdsiObject () {};

    HRESULT BuildObjectTypeList (
                POBJECT_TYPE_LIST* pObjectTypeList, 
                size_t& objectTypeListLength);
    LPCWSTR GetSchemaCommonName ()
    {
        return m_strSchemaCommonName.c_str ();
    }
    virtual HRESULT Bind(LPCWSTR lpszLdapPath);

protected:
    HRESULT ReadSchemaCommonName ();
    HRESULT AddAttrGUIDToList (
                const BSTR pszAttrName, 
                list<POBJECT_TYPE_LIST>& rGuidList);
    HRESULT ReadSchemaAttributeCommonName (
                const BSTR pszAttrName,
                BSTR* attrCommonName);

private:
    wstring m_strSchemaCommonName;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\adutils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2002.
//
//  File:       ADUtils.cpp
//
//  Contents:   Classes CWString, CACLDiagComModule, ACE_SAMNAME, helper 
//              methods
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "adutils.h"

#include <util.h>
#include <sddl.h>
#include "dscmn.h"
#include "SecDesc.h"



void StripQuotes (wstring& str)
{
    size_t  qPos = str.find_first_of (L"\"", 0);
    if ( 0 == qPos )
    {
        str = str.substr (1);
        qPos = str.find_last_of (L"\"");
        if ( str.npos != qPos )
            str.replace (qPos, 1, 1, 0);
    }
}

wstring GetSystemMessage (DWORD dwErr)
{
    wstring message;

    if ( E_ADS_BAD_PATHNAME == dwErr )
    {
        CWString    msg;

        msg.LoadFromResource (IDS_ADS_BAD_PATHNAME);
        message = msg;
    }
    else
    {
        LPVOID pMsgBuf = 0;
            
        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                        FORMAT_MESSAGE_FROM_SYSTEM,    
                NULL,
                dwErr,
                MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                 (LPWSTR) &pMsgBuf,    0,    NULL );
        message = (LPWSTR) pMsgBuf;

        // Free the buffer.
        if ( pMsgBuf ) 
            LocalFree (pMsgBuf);
    }


    return message;
}

/*
// Attempt to locate a message in a given module.  Return the message string
// if found, the empty string if not.
// 
// flags - FormatMessage flags to use
// 
// module - module handle of message dll to look in, or 0 to use the system
// message table.
// 
// code - message code to look for

String
getMessageHelper(DWORD flags, HMODULE module, HRESULT code)
{
   ASSERT(code);
   ASSERT(flags & FORMAT_MESSAGE_ALLOCATE_BUFFER);

   String message;

   TCHAR* sys_message = 0;
   DWORD result =
      ::FormatMessage(
         flags,
         module,
         static_cast<DWORD>(code),
         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
         reinterpret_cast<LPTSTR>(&sys_message),
         0,
         0);
   if (result)
   {
      ASSERT(sys_message);
      if (sys_message)
      {
         message = sys_message;

         ASSERT(result == message.length());

         Win::LocalFree(sys_message);
         message.replace(TEXT("\r\n"), TEXT(" "));
      }
   }

   return message;
}



// Attempts to locate message strings for various facility codes in the
// HRESULT

String
GetErrorMessage(HRESULT hr)
{
   TRACE_FUNCTION2(GetErrorMessage, String::format("%1!08X!", hr));
   ASSERT(FAILED(hr));

   if (!FAILED(hr))
   {
      // no messages for success!
      return String();
   }

   HRESULT code = HRESULT_CODE(hr);

   if (code == -1)
   {
      return String::load(IDS_UNKNOWN_ERROR_CODE);
   }

   String message;

   // default is the system error message table
   HMODULE module = 0;

   DWORD flags =
         FORMAT_MESSAGE_ALLOCATE_BUFFER
      |  FORMAT_MESSAGE_IGNORE_INSERTS
      |  FORMAT_MESSAGE_FROM_SYSTEM;

   int facility = HRESULT_FACILITY(hr);
   switch (facility)
   {
      case FACILITY_WIN32:    // 0x7
      {
         // included here:
         // lanman error codes (in it's own dll) see lmerr.h
         // dns
         // winsock

         // @@ use SafeDLL here?
         static HMODULE lm_err_res_dll = 0;
         if (code >= NERR_BASE && code <= MAX_NERR)
         {
            // use the net error message resource dll
            if (lm_err_res_dll == 0)
            {
               lm_err_res_dll =
                  Win::LoadLibraryEx(
                     TEXT("netmsg.dll"),
                     LOAD_LIBRARY_AS_DATAFILE);
            }

            module = lm_err_res_dll;
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
         }
         break;
      }
      case 0x0:
      {
         if (code >= 0x5000 && code <= 0x50FF)
         {
            // It's an ADSI error.  They put the facility code (5) in the
            // wrong place!

            // @@ use SafeDLL here?
            static HMODULE adsi_err_res_dll = 0;
            // use the net error message resource dll
            if (adsi_err_res_dll == 0)
            {
               adsi_err_res_dll =
                  Win::LoadLibraryEx(
                     TEXT("activeds.dll"),
                     LOAD_LIBRARY_AS_DATAFILE);
            }

            module = adsi_err_res_dll;
            flags |= FORMAT_MESSAGE_FROM_HMODULE;

            // the message dll expects the entire error code
            code = hr;
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   message = getMessageHelper(flags, module, code);
   if (message.empty())
   {
      message = String::load(IDS_UNKNOWN_ERROR_CODE);
   }

   return message;
}


*/
///////////////////////////////////////////////////////////////////////
// wstring helper methods

HRESULT wstringFromGUID (wstring& str, REFGUID guid)
{
    HRESULT hr = S_OK;

    const int BUF_LEN = 128;
    WCHAR awch[BUF_LEN];
    hr = StringFromGUID2(guid, awch, BUF_LEN);
    if ( SUCCEEDED (hr) )
        str = OLE2T(awch);
    
    return hr;
}

bool LoadFromResource(wstring& str, UINT uID)
{
    int nBufferSize = 128;
    static const int nCountMax = 4;
    int nCount = 1;
    bool    bRVal = false;
    bool    bDone = true;

    do 
    {
        LPWSTR lpszBuffer = new WCHAR[nBufferSize];
        if ( lpszBuffer )
        {
            int iRet = ::LoadString(_Module.GetResourceInstance(), uID, 
                        lpszBuffer, nBufferSize);
            if (iRet == 0)
            {
                str = L"?";
                bDone = true; // not found
            }
            if (iRet == nBufferSize-1) // truncation
            {
                if (nCount > nCountMax)
                {
                    // too many reallocations
                    str = lpszBuffer;
                    bRVal = false; // truncation
                }
                // try to expand buffer
                nBufferSize *=2;
                nCount++;
            }
            else
            {
                // got it
                str = lpszBuffer;
                bRVal = true;
                bDone = true;
            }
            delete [] lpszBuffer;
            if ( bDone )
                break;
        }
        else
            break;
    }
#pragma warning (disable : 4127)
    while (true);
#pragma warning (default : 4127)

    return bRVal;
}

bool FormatMessage(wstring& str, UINT nFormatID, ...)
{
    bool bResult = false;

    // get format string from string table
    wstring strFormat;
    if ( LoadFromResource (strFormat, nFormatID) )
    {
        // format message into temporary buffer lpszTemp
        va_list argList;
        va_start(argList, nFormatID);
        PWSTR lpszTemp = 0;
        if (::FormatMessage (FORMAT_MESSAGE_FROM_STRING |
                FORMAT_MESSAGE_ALLOCATE_BUFFER,
            strFormat.c_str (), 0, 0, (PWSTR)&lpszTemp, 0, &argList) == 0 ||
            lpszTemp == NULL)
        {
            return false; 
        }

        // assign lpszTemp into the resulting string and free lpszTemp
        str = lpszTemp;
        bResult = true;
        LocalFree(lpszTemp);
        va_end(argList);
    }

    return bResult;
}

bool FormatMessage(wstring& str, LPCTSTR lpszFormat, ...)
{
    bool bResult = false;


    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPTSTR lpszTemp;

    if ( ::FormatMessage (FORMAT_MESSAGE_FROM_STRING | 
                FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
        return false; //AfxThrowMemoryException();
    }

    // assign lpszTemp into the resulting string and free the temporary
    str = lpszTemp;
    bResult = true;
    LocalFree(lpszTemp);
    va_end(argList);

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
// CACLDiagComModule
CACLDiagComModule::CACLDiagComModule() :
    m_bDoSchema (false),
    m_bDoCheckDelegation (false),
    m_bDoGetEffective (false),
    m_bDoFixDelegation (false),
    m_pSecurityDescriptor (0),
    m_bTabDelimitedOutput (false),
    m_hPrivToken (0),
    m_bLogErrors (false)
{
    DWORD dwPriv = SE_SECURITY_PRIVILEGE;
    m_hPrivToken = EnablePrivileges(&dwPriv, 1);
}

CACLDiagComModule::~CACLDiagComModule ()
{
    if ( m_pSecurityDescriptor )
    {
        LocalFree (m_pSecurityDescriptor);
        m_pSecurityDescriptor = 0;
    }
    ReleasePrivileges(m_hPrivToken);
}


HRESULT CACLDiagComModule::GetClassFromGUID (
        REFGUID rightsGUID, 
        wstring& strClassName, 
        GUID_TYPE* pGuidType)
{
    HRESULT hr = S_OK;
    CSchemaClassInfo*   pInfo = 0;
    bool                bFound = false;

    // Search for a class
    for (int nIndex = 0; nIndex < (int) m_classInfoArray.GetCount (); nIndex++)
    {
        pInfo = m_classInfoArray[nIndex];
        if ( pInfo && IsEqualGUID (*(pInfo->GetSchemaGUID ()), 
                rightsGUID) )
        {
            PCWSTR  pszDisplayName = pInfo->GetDisplayName ();
            strClassName = pszDisplayName ? pszDisplayName : L"";
            bFound = true;
            if ( pGuidType )
                *pGuidType = GUID_TYPE_CLASS;
            break;
        }
    }

    // Search for an attribute
    if ( !bFound )
    {
        for (int nIndex = 0; nIndex < (int) m_attrInfoArray.GetCount (); nIndex++)
        {
            pInfo = m_attrInfoArray[nIndex];
            if ( pInfo && IsEqualGUID (*(pInfo->GetSchemaGUID ()), 
                    rightsGUID) )
            {
                PCWSTR  pszDisplayName = pInfo->GetDisplayName ();
                strClassName = pszDisplayName ? pszDisplayName : L"";
                bFound = true;
                if ( pGuidType )
                    *pGuidType = GUID_TYPE_ATTRIBUTE;
                break;
            }
        }
    }

    // Search for a control
    if ( !bFound )
    {
        hr = GetControlDisplayName (rightsGUID, strClassName);
        if ( SUCCEEDED (hr) && strClassName.length () )
        {
            if ( pGuidType )
                *pGuidType = GUID_TYPE_CONTROL;
        }
        else
        {
            if ( pGuidType )
                *pGuidType = GUID_TYPE_UNKNOWN;
            strClassName = L"unknown";
        }
    }

    return hr;
}

HRESULT CACLDiagComModule::Init()
{
    // Find out if logged-in users is an Administrator
    BOOL    bIsUserAdministrator = FALSE;
    HRESULT hr = IsUserAdministrator (bIsUserAdministrator);
    if ( SUCCEEDED (hr) )
    {
        if ( bIsUserAdministrator )
        {
            wstring     strObjectDN;
            LPCWSTR     pszLDAP = L"LDAP://";

            size_t      len = wcslen (pszLDAP);

            if ( m_strObjectDN.compare (0, len, pszLDAP) )
            {
                strObjectDN = pszLDAP;
            }
            strObjectDN += m_strObjectDN;

            hr = m_adsiObject.Bind (strObjectDN.c_str ());
            if ( SUCCEEDED (hr) )
            {
                // Get the class of strObjectDN

                // enumerate all classes in schema
                hr = m_adsiObject.QuerySchemaClasses (&m_classInfoArray, false);
                if ( SUCCEEDED (hr) )
                {
/*
#if DBG
                    // Dump all the class info to the debug window
                    _TRACE (0, L"\n----------------------------------------------------\n");
                    _TRACE (0, L"-- Classes --\n\n");
                    for (int nIndex = 0; nIndex < m_classInfoArray.GetCount (); nIndex++)
                    {
                        CSchemaClassInfo* pInfo = m_classInfoArray[nIndex];
                        if ( pInfo )
                        {
                            _TRACE (0, L"\t%d\t%s\t%s\n", nIndex, pInfo->GetSchemaIDGUID (), 
                                    pInfo->GetDisplayName ());
                        }
                    }
                    _TRACE (0, L"\n----------------------------------------------------\n\n");
#endif // DBG
*/
                    // enumerate all attributes in schema
                    hr = m_adsiObject.QuerySchemaClasses (&m_attrInfoArray, 
                            true);
                    if ( SUCCEEDED (hr) )
                    {
/*
#if DBG
                        // Dump all the attributes info to the debug window
                        _TRACE (0, L"\n----------------------------------------------------\n");
                        _TRACE (0, L"-- Attributes --\n\n");
                        for (int nIndex = 0; nIndex < m_attrInfoArray.GetCount (); nIndex++)
                        {
                            CSchemaClassInfo* pInfo = m_attrInfoArray[nIndex];
                            if ( pInfo )
                            {
                                _TRACE (0, L"\t%d\t%s\t%s\n", nIndex, pInfo->GetSchemaIDGUID (), 
                                        pInfo->GetDisplayName ());
                            }
                        }
                        _TRACE (0, L"\n----------------------------------------------------\n\n");
#endif // DBG
                        */
                    }
                    wprintf (L"\n");
                }
            }
            else
            {
                wstring    str;


                FormatMessage (str, IDS_INVALID_OBJECT, m_strObjectDN.c_str (), 
                        GetSystemMessage (hr).c_str ());
                MyWprintf (str.c_str ());
            }
        }
        else
        {
            wstring    str;

            LoadFromResource (str, IDS_USER_MUST_BE_ADMINISTRATOR);
            MyWprintf (str.c_str ());
        }
    }
    else
    {
        wstring    str;

        FormatMessage (str, IDS_COULD_NOT_VALIDATE_USER_CREDENTIALS, 
                GetSystemMessage (hr).c_str ());
        MyWprintf (str.c_str ());
    }

    return hr;
}

HRESULT CACLDiagComModule::IsUserAdministrator (BOOL & bIsAdministrator)
{
    bIsAdministrator = TRUE;
    return S_OK;
/*
    _TRACE (1, L"Entering  CACLDiagComModule::IsUserAdministrator\n");
    HRESULT hr = S_OK;
    DWORD   dwErr = 0;

    bIsAdministrator = FALSE;
    if ( IsWindowsNT () )
    {
        DWORD                       dwInfoBufferSize = 0;
        PSID                        psidAdministrators;
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

        BOOL bResult = AllocateAndInitializeSid (&siaNtAuthority, 2,
                SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0, &psidAdministrators);
        if ( bResult )
        {
            bResult = CheckTokenMembership (0, psidAdministrators,
                    &bIsAdministrator);
            ASSERT (bResult);
            if ( !bResult )
            {
                dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
            }
            FreeSid (psidAdministrators);
        }
        else
        {
            dwErr = GetLastError ();
            hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }

    _TRACE (-1, L"Leaving CACLDiagComModule::IsUserAdministrator\n");
    return hr
*/
}

bool CACLDiagComModule::IsWindowsNT()
{
    OSVERSIONINFO   versionInfo;

    ::ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
    versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    BOOL    bResult = ::GetVersionEx (&versionInfo);
    ASSERT (bResult);
    if ( bResult )
    {
        if ( VER_PLATFORM_WIN32_NT == versionInfo.dwPlatformId )
            bResult = TRUE;
    }
        
    return bResult ? true : false;
}


///////////////////////////////////////////////////////////////////////////////
// ACE_SAMNAME

BOOL ACE_SAMNAME::operator==(const ACE_SAMNAME& rAceSAMName) const
{
    // Neutralize INHERITED_ACE flag in Header.AceFlags
    // Consider equivalent if all the mask bits in 'this' are found in rAceSAMName
    BOOL bResult = FALSE;
    if ( (m_AceType == rAceSAMName.m_AceType) && 
            ( !this->m_SAMAccountName.compare (rAceSAMName.m_SAMAccountName)) )
    {
        switch (m_AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            if ( m_pAllowedAce->Mask == rAceSAMName.m_pAllowedAce->Mask &&
                    (m_pAllowedAce->Header.AceFlags | INHERITED_ACE ) == 
                            (rAceSAMName.m_pAllowedAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pAllowedAce->Header.AceSize == rAceSAMName.m_pAllowedAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            if ( m_pAllowedObjectAce->Mask == rAceSAMName.m_pAllowedObjectAce->Mask &&
                    (m_pAllowedObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pAllowedObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                     m_pAllowedObjectAce->Header.AceSize == rAceSAMName.m_pAllowedObjectAce->Header.AceSize &&
                    ::IsEqualGUID (m_pAllowedObjectAce->ObjectType, rAceSAMName.m_pAllowedObjectAce->ObjectType) )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_DENIED_ACE_TYPE:
            if ( m_pDeniedAce->Mask == rAceSAMName.m_pDeniedAce->Mask &&
                    (m_pDeniedAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pDeniedAce->Header.AceFlags | INHERITED_ACE )  &&
                    m_pDeniedAce->Header.AceSize == rAceSAMName.m_pDeniedAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:
            if ( m_pDeniedObjectAce->Mask == rAceSAMName.m_pDeniedObjectAce->Mask &&
                    (m_pDeniedObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pDeniedObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pDeniedObjectAce->Header.AceSize == rAceSAMName.m_pDeniedObjectAce->Header.AceSize &&
                    ::IsEqualGUID (m_pDeniedObjectAce->ObjectType, rAceSAMName.m_pDeniedObjectAce->ObjectType) )
            {
                bResult = TRUE;
            }
            break;

        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            if ( m_pSystemAuditObjectAce->Mask == rAceSAMName.m_pSystemAuditObjectAce->Mask &&
                    (m_pSystemAuditObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pSystemAuditObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pSystemAuditObjectAce->Header.AceSize == rAceSAMName.m_pSystemAuditObjectAce->Header.AceSize &&
                    ::IsEqualGUID (m_pSystemAuditObjectAce->ObjectType, rAceSAMName.m_pSystemAuditObjectAce->ObjectType) )
            {
                bResult = TRUE;
            }
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            if ( m_pSystemAuditAce->Mask == rAceSAMName.m_pSystemAuditAce->Mask &&
                    (m_pSystemAuditAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pSystemAuditAce->Header.AceFlags | INHERITED_ACE )  &&
                    m_pSystemAuditAce->Header.AceSize == rAceSAMName.m_pSystemAuditAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        default:
            break;
        }
    }
    return bResult;
}


BOOL ACE_SAMNAME::IsEquivalent (ACE_SAMNAME& rAceSAMName, ACCESS_MASK accessMask)
{
    // Neutralize INHERITED_ACE flag in Header.AceFlags
    BOOL bResult = FALSE;
    if ( m_AceType == rAceSAMName.m_AceType )
    {
        switch (m_AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            if ( (m_pAllowedAce->Mask & accessMask) == 
                        (rAceSAMName.m_pAllowedAce->Mask & accessMask) &&
                    m_pAllowedAce->SidStart == rAceSAMName.m_pAllowedAce->SidStart &&
                    (m_pAllowedAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pAllowedAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pAllowedAce->Header.AceSize == rAceSAMName.m_pAllowedAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            if ( (m_pAllowedObjectAce->Mask & accessMask) == 
                        (rAceSAMName.m_pAllowedObjectAce->Mask & accessMask) &&
                    m_pAllowedObjectAce->SidStart == rAceSAMName.m_pAllowedObjectAce->SidStart &&
                    (m_pAllowedObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pAllowedObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pAllowedObjectAce->Header.AceSize == rAceSAMName.m_pAllowedObjectAce->Header.AceSize &&
                    ::IsEqualGUID (m_pAllowedObjectAce->ObjectType, rAceSAMName.m_pAllowedObjectAce->ObjectType) )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_DENIED_ACE_TYPE:
            if ( (m_pDeniedAce->Mask & accessMask) == 
                        (rAceSAMName.m_pDeniedAce->Mask & accessMask) &&
                    m_pDeniedAce->SidStart == rAceSAMName.m_pDeniedAce->SidStart &&
                    (m_pDeniedAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pDeniedAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pDeniedAce->Header.AceSize == rAceSAMName.m_pDeniedAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:
            if ( (m_pDeniedObjectAce->Mask & accessMask) == 
                        (rAceSAMName.m_pDeniedObjectAce->Mask & accessMask) &&
                    m_pDeniedObjectAce->SidStart == rAceSAMName.m_pDeniedObjectAce->SidStart &&
                    (m_pDeniedObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pDeniedObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pDeniedObjectAce->Header.AceSize == rAceSAMName.m_pDeniedObjectAce->Header.AceSize &&
                    ::IsEqualGUID (m_pDeniedObjectAce->ObjectType, rAceSAMName.m_pDeniedObjectAce->ObjectType) )
            {
                bResult = TRUE;
            }
            break;

        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            if ( (m_pSystemAuditObjectAce->Mask & accessMask) == 
                        (rAceSAMName.m_pSystemAuditObjectAce->Mask & accessMask) &&
                    m_pSystemAuditObjectAce->SidStart == rAceSAMName.m_pSystemAuditObjectAce->SidStart &&
                    (m_pSystemAuditObjectAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pSystemAuditObjectAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pSystemAuditObjectAce->Header.AceSize == rAceSAMName.m_pSystemAuditObjectAce->Header.AceSize )
            {
                bResult = TRUE;
            }
             break;

        case SYSTEM_AUDIT_ACE_TYPE:
            if ( (m_pSystemAuditAce->Mask & accessMask) == 
                        (rAceSAMName.m_pSystemAuditAce->Mask & accessMask) &&
                    m_pSystemAuditAce->SidStart == rAceSAMName.m_pSystemAuditAce->SidStart &&
                    (m_pSystemAuditAce->Header.AceFlags | INHERITED_ACE ) == 
                        (rAceSAMName.m_pSystemAuditAce->Header.AceFlags | INHERITED_ACE ) &&
                    m_pSystemAuditAce->Header.AceSize == rAceSAMName.m_pSystemAuditAce->Header.AceSize )
            {
                bResult = TRUE;
            }
            break;

        default:
            break;
        }
    }
    return bResult;
}

bool ACE_SAMNAME::IsInherited() const
{
    return (m_pAllowedAce->Header.AceFlags & INHERITED_ACE) ? true : false;
}


void ACE_SAMNAME::DebugOut() const
{
#if DBG == 1
    wstring     strGuidResult;
    GUID_TYPE   guidType = GUID_TYPE_UNKNOWN;
    _TRACE (0, L"\n");

    _TRACE (0, L"Principal Name:   %s\n", m_SAMAccountName.c_str ());
    switch (m_AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        _TRACE (0, L"AceType:  ACCESS_ALLOWED_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pAllowedAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pAllowedAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pAllowedAce->Header.AceSize);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        _TRACE (0, L"AceType: ACCESS_ALLOWED_OBJECT_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pAllowedObjectAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pAllowedObjectAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pAllowedObjectAce->Header.AceSize);
        _Module.GetClassFromGUID (m_pAllowedObjectAce->ObjectType, strGuidResult, &guidType);
        break;

    case ACCESS_DENIED_ACE_TYPE:
        _TRACE (0, L"AceType: ACCESS_DENIED_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pDeniedAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pDeniedAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pDeniedAce->Header.AceSize);
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        _TRACE (0, L"AceType: ACCESS_DENIED_OBJECT_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pDeniedObjectAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pDeniedObjectAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pDeniedObjectAce->Header.AceSize);
        _Module.GetClassFromGUID (m_pDeniedObjectAce->ObjectType, strGuidResult, &guidType);
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        _TRACE (0, L"AceType: SYSTEM_AUDIT_OBJECT_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pSystemAuditObjectAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pSystemAuditObjectAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pSystemAuditObjectAce->Header.AceSize);
        _Module.GetClassFromGUID (m_pSystemAuditObjectAce->ObjectType, strGuidResult, &guidType);
        break;

    case SYSTEM_AUDIT_ACE_TYPE:
        _TRACE (0, L"AceType: SYSTEM_AUDIT_ACE_TYPE\n");
        _TRACE (0, L"Mask:     0x%x\n", m_pSystemAuditAce->Mask);
        _TRACE (0, L"AceFlags: 0x%x\n", m_pSystemAuditAce->Header.AceFlags);
        _TRACE (0, L"AceSize:  %d bytes\n", m_pSystemAuditAce->Header.AceSize);
        break;
    }

    if ( IsObjectAceType (m_pAllowedAce) )
    {
        wstring strGuidType;
        switch (guidType)
        {
        case GUID_TYPE_CLASS:
            strGuidType = L"GUID_TYPE_CLASS";
            break;

        case GUID_TYPE_ATTRIBUTE:
            strGuidType = L"GUID_TYPE_ATTRIBUTE";
            break;

        case GUID_TYPE_CONTROL:
            strGuidType = L"GUID_TYPE_CONTROL";
            break;

        default:
#pragma warning (disable : 4127)
            ASSERT (0);
#pragma warning (default : 4127)
            // fall through

        case GUID_TYPE_UNKNOWN:
            strGuidType = L"GUID_TYPE_UNKNOWN";
            break;
        }
        _TRACE (0, L"ObjectType type:  %s\n", strGuidType.c_str ());
        _TRACE (0, L"ObjectType value: %s\n", strGuidResult.c_str ());
    }

    _TRACE (0, L"\n");
#endif
}

///////////////////////////////////////////////////////////////////////////////
HRESULT
SetSecurityInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si)
{
    HRESULT hr = E_INVALIDARG;
    if (punk)
    {
        IADsObjectOptions *pOptions;
        hr = punk->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            V_VT(&var) = VT_I4;
            V_I4(&var) = si;
            hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);
            pOptions->Release();
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
/*******************************************************************

    NAME:       EnablePrivileges

    SYNOPSIS:   Enables the given privileges in the current token

    ENTRY:      pdwPrivileges - list of privileges to enable

    RETURNS:    On success, the previous thread handle (if present) or NULL
                On failure, INVALID_HANDLE_VALUE

    NOTES:      The returned handle should be passed to ReleasePrivileges
                to ensure proper cleanup.  Otherwise, if not NULL or
                INVALID_HANDLE_VALUE it should be closed with CloseHandle.

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/
HANDLE EnablePrivileges(PDWORD pdwPrivileges, ULONG cPrivileges)
{
    BOOL                fResult;
    HANDLE              hToken;
    HANDLE              hOriginalThreadToken;
    PTOKEN_PRIVILEGES   ptp;
    ULONG               nBufferSize;

    if (!pdwPrivileges || !cPrivileges)
        return INVALID_HANDLE_VALUE;

    // Note that TOKEN_PRIVILEGES includes a single LUID_AND_ATTRIBUTES
    nBufferSize = sizeof(TOKEN_PRIVILEGES) + (cPrivileges - 1) * 
            sizeof(LUID_AND_ATTRIBUTES);
    ptp = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, nBufferSize);
    if (!ptp)
        return INVALID_HANDLE_VALUE;

    //
    // Initialize the Privileges Structure
    //
    ptp->PrivilegeCount = cPrivileges;
    for (ULONG i = 0; i < cPrivileges; i++)
    {
        //ptp->Privileges[i].Luid = RtlConvertUlongToLuid(*pdwPrivileges++);
        ptp->Privileges[i].Luid.LowPart = *pdwPrivileges++;
        ptp->Privileges[i].Luid.HighPart = 0;
        ptp->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
    }

    //
    // Open the Token
    //
    hToken = hOriginalThreadToken = INVALID_HANDLE_VALUE;
    fResult = OpenThreadToken (GetCurrentThread (), TOKEN_DUPLICATE, FALSE, 
            &hToken);
    if (fResult)
        hOriginalThreadToken = hToken;  // Remember the thread token
    else
        fResult = OpenProcessToken (GetCurrentProcess(), TOKEN_DUPLICATE, 
                &hToken);

    if (fResult)
    {
        HANDLE hNewToken;

        //
        // Duplicate that Token
        //
        fResult = DuplicateTokenEx(hToken,
                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                   NULL,                   // PSECURITY_ATTRIBUTES
                   SecurityImpersonation,  // SECURITY_IMPERSONATION_LEVEL
                   TokenImpersonation,     // TokenType
                   &hNewToken);            // Duplicate token
        if (fResult)
        {
            //
            // Add new privileges
            //
            fResult = AdjustTokenPrivileges(hNewToken,  // TokenHandle
                        FALSE,      // DisableAllPrivileges
                        ptp,        // NewState
                        0,          // BufferLength
                        NULL,       // PreviousState
                        NULL);      // ReturnLength
            if (fResult)
            {
                //
                // Begin impersonating with the new token
                //
                fResult = SetThreadToken(NULL, hNewToken);
            }

            CloseHandle(hNewToken);
        }
    }

    // If something failed, don't return a token
    if (!fResult)
        hOriginalThreadToken = INVALID_HANDLE_VALUE;

    // Close the original token if we aren't returning it
    if (hOriginalThreadToken == INVALID_HANDLE_VALUE && 
            hToken != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hToken);
    }

    // If we succeeded, but there was no original thread token,
    // return NULL to indicate we need to do SetThreadToken(NULL, NULL)
    // to release privs.
    if (fResult && hOriginalThreadToken == INVALID_HANDLE_VALUE)
        hOriginalThreadToken = NULL;

    LocalFree(ptp);

    return hOriginalThreadToken;
}


/*******************************************************************

    NAME:       ReleasePrivileges

    SYNOPSIS:   Resets privileges to the state prior to the corresponding
                EnablePrivileges call.

    ENTRY:      hToken - result of call to EnablePrivileges

    RETURNS:    nothing

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/
BOOL ReleasePrivileges(HANDLE hToken)
{
    BOOL    bRVal = FALSE;

    if (INVALID_HANDLE_VALUE != hToken)
    {
        bRVal = SetThreadToken(NULL, hToken);
        if (hToken)
            CloseHandle(hToken);
    }

    return bRVal;
}

VOID LocalFreeStringW(LPWSTR* ppString)
{
    if ( ppString && *ppString )
    {
        LocalFree((HLOCAL)*ppString);

        *ppString = NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     GetNameFromSid ()
//
//  Purpose:    Get the name of the object represented by this Sid
//
//  Inputs:     pSid - SID of the object whose name we wish to retrieve
//
//  Outputs:    strPrincipalName - name of the object in NameUserPrincipal
//              pstrFQDN - (optional) name of the object as Fully Qualified DN
//
HRESULT GetNameFromSid (
        PSID pSid, 
        wstring& strPrincipalName, 
        wstring* pstrFQDN, 
        SID_NAME_USE& sne)
{
    ASSERT (IsValidSid (pSid));
    if ( !IsValidSid (pSid) )
        return E_INVALIDARG;

    PWSTR   pwszName = 0;
    DWORD   cchName = 0;
    PWSTR   pwszDomain = 0;
    DWORD   cchDomain = 0;
    HRESULT hr = S_OK;

    BOOL bRVal = ::LookupAccountSid (NULL,    // name of local or remote computer
            pSid,                       // security identifier
            pwszName,                   // account name buffer
            &cchName,                   // size of account name buffer, in characters
            pwszDomain,                 // domain name
            &cchDomain,                 // size of domain name buffer, in characters
            &sne);                      // SID type
    if ( FALSE == bRVal )
    {
        DWORD dwErr = GetLastError ();
        if ( ERROR_INSUFFICIENT_BUFFER == dwErr )
        {
            ASSERT (0 != cchDomain && 0 != cchName);
            if ( 0 == cchDomain || 0 == cchName )
                return E_UNEXPECTED;

            pwszName = new WCHAR[cchName];
            if ( pwszName )
            {
                pwszDomain = new WCHAR[cchDomain];
                if ( pwszDomain )
                {
                    if ( ::LookupAccountSid (NULL,    // name of local or remote computer
                            pSid,                   // security identifier
                            pwszName,                 // account name buffer
                            &cchName,               // size of account name buffer
                            pwszDomain,               // domain name
                            &cchDomain,             // size of domain name buffer
                            &sne) )                 // SID type
                    {
                        wstring strSamCompatibleName (pwszDomain);

                        strSamCompatibleName += L"\\";
                        strSamCompatibleName += pwszName;

                        // Get Principal Name
                        {
                            PWSTR   pszTranslatedName = 0;
            

                            if ( SUCCEEDED (CrackName(const_cast<PWSTR> (strSamCompatibleName.c_str ()), 
                                    &pszTranslatedName, 
                                    GET_OBJ_UPN, //GET_OBJ_NT4_NAME,
                                    0)) )
                            {
                                strPrincipalName = pszTranslatedName;
                                LocalFreeStringW(&pszTranslatedName);
                            }
                            else
                            {
                                strPrincipalName = strSamCompatibleName;
                            }
                        }


                        // Get fully qualified DN
                        if ( pstrFQDN )
                        {
                            PWSTR   pszTranslatedName = 0;

                            if ( SUCCEEDED (CrackName(const_cast<PWSTR> (strSamCompatibleName.c_str ()), 
                                    &pszTranslatedName, 
                                    GET_OBJ_1779_DN,
                                    0)) )
                            {
                                *pstrFQDN = pszTranslatedName;
                                LocalFreeStringW(&pszTranslatedName);
                            }
                            else
                            {
                                *pstrFQDN = strSamCompatibleName;
                            }
                        }
                    }
                    else
                    {
                        dwErr = GetLastError ();
                        _TRACE (0, L"LookupAccountSid failed: 0x%x\n", dwErr);
                        if ( ERROR_NONE_MAPPED == dwErr )
                        {
                            PWSTR   pszStringSid = 0;
                            if ( ::ConvertSidToStringSid (pSid, &pszStringSid) )
                            {
                                strPrincipalName = pszStringSid;
                                if ( pstrFQDN )
                                    *pstrFQDN = pszStringSid;

                                ::LocalFree (pszStringSid);
                            }
                            else
                                hr = E_OUTOFMEMORY;
                        }
                        else
                            hr = HRESULT_FROM_WIN32 (dwErr);
                    }
                    delete [] pwszDomain;
                }
                else
                    hr = E_OUTOFMEMORY;

                delete [] pwszName;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            dwErr = GetLastError ();
            _TRACE (0, L"LookupAccountSid failed: 0x%x\n", dwErr);
            if ( ERROR_NONE_MAPPED == dwErr )
            {
                PWSTR   pszStringSid = 0;
                if ( ::ConvertSidToStringSid (pSid, &pszStringSid) )
                {
                    strPrincipalName = pszStringSid;
                    if ( pstrFQDN )
                        *pstrFQDN = pszStringSid;

                    ::LocalFree (pszStringSid);
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
                hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }
    else
    {
        // Huh?  How can this API return TRUE with null buffers?
        hr = E_UNEXPECTED;
    }

    return hr;
}

#define MAX_BUF_SIZE    4096
CHAR    AnsiBuf[MAX_BUF_SIZE*3];    /* worst case is DBCS, which    */
                                    /* needs more than *2       */
WCHAR   ConBuf [MAX_BUF_SIZE];

int FileIsConsole(HANDLE fh)
{
    unsigned htype ;

    htype = GetFileType(fh);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}


int MyWriteConsole()
{
    DWORD cch = (DWORD) wcslen(ConBuf);
    HANDLE  hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (FileIsConsole(hOut))
        WriteConsole(hOut, ConBuf, cch, &cch, NULL);
    else 
    {
        cch = WideCharToMultiByte(CP_OEMCP, 0,
                  ConBuf, (int) cch,
                  AnsiBuf, MAX_BUF_SIZE*3,
                  NULL, NULL);
        WriteFile(hOut, AnsiBuf, cch, &cch, NULL);
    }

    return (int) cch;
}

int MyWprintf( const wchar_t *fmt, ... )
{
    va_list     args;

    va_start( args, fmt );
    ::ZeroMemory (ConBuf, sizeof (ConBuf));
    _vsnwprintf( ConBuf, MAX_BUF_SIZE-1, fmt, args );
    va_end( args );
    return MyWriteConsole ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\chkdeleg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ChkDeleg.h
//
//  Contents:   CheckDelegation and support methods
//              
//
//----------------------------------------------------------------------------
#ifndef __ACLDIAG_CHKDELEG_H
#define __ACLDIAG_CHKDELEG_H

#include "stdafx.h"


HRESULT CheckDelegation ();

#endif //__ACLDIAG_CHKDELEG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\adutils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ADUtils.h
//
//  Contents:   Classes CWString, CACLDiagComModule, ACE_SAMNAME, helper methods
//              
//
//----------------------------------------------------------------------------
#ifndef __ACLDIAG_ADUTILS_H
#define __ACLDIAG_ADUTILS_H

#include "stdafx.h"
#include "ADSIObj.h"

///////////////////////////////////////////////////////////////////////
// wstring helper methods

HRESULT wstringFromGUID (wstring& str, REFGUID guid);
bool LoadFromResource(wstring& str, UINT uID);
bool FormatMessage(wstring& str, UINT nFormatID, ...);
bool FormatMessage(wstring& str, LPCTSTR lpszFormat, ...);


#include <util.h>

void StripQuotes (wstring& str);
wstring GetSystemMessage (DWORD dwErr);
HRESULT SetSecurityInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si);
HANDLE EnablePrivileges(PDWORD pdwPrivileges, ULONG cPrivileges);
BOOL ReleasePrivileges(HANDLE hToken);

static const GUID NULLGUID =
{ 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };

#define IsObjectAceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE) && \
        (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)    \
            )


#define THROW(e) throw e


#define ACLDIAG_CONFIG_NAMING_CONTEXT  L"configurationNamingContext"
#define ACLDIAG_ROOTDSE                L"RootDSE"

class PSID_FQDN 
{
public:
    PSID_FQDN (PSID psid, const wstring& strFQDN, const wstring& strDownLevelName, SID_NAME_USE sne) :
        m_PSID (psid),
        m_strFQDN (strFQDN),
        m_strDownLevelName (strDownLevelName),
        m_sne (sne)
    {
    }
    PSID            m_PSID;
    wstring         m_strFQDN;
    wstring         m_strDownLevelName;
    SID_NAME_USE    m_sne;
};

///////////////////////////////////////////////////////////////////////////////
// Important note:  m_pAllowedAce is used to refer to the Header and Mask fields.
// This allows most operations because the fields are always in the same place for
// all the structs below.  For anything else, one of the other members of the 
// union must be used, depending on the m_AceType.
class ACE_SAMNAME 
{
public:
    ACE_SAMNAME () : 
        m_AceType (0),
        m_pAllowedAce (0)
    {
    }

    void DebugOut () const;
    bool IsInherited () const;
    BOOL operator==(const ACE_SAMNAME& rAceSAMName) const;
    BOOL IsEquivalent (ACE_SAMNAME& rAceSAMName, ACCESS_MASK accessMask);
    BYTE                        m_AceType;
    union {
        PACCESS_ALLOWED_ACE         m_pAllowedAce;
        PACCESS_ALLOWED_OBJECT_ACE  m_pAllowedObjectAce;
        PACCESS_DENIED_ACE          m_pDeniedAce;
        PACCESS_DENIED_OBJECT_ACE   m_pDeniedObjectAce;
        PSYSTEM_AUDIT_ACE           m_pSystemAuditAce;
        PSYSTEM_AUDIT_OBJECT_ACE    m_pSystemAuditObjectAce;
    };
    wstring                     m_SAMAccountName;
    wstring                     m_strObjectGUID;
    wstring                     m_strInheritedObjectGUID;
};


typedef list<ACE_SAMNAME*>  ACE_SAMNAME_LIST;

typedef list<PSID_FQDN*> PSID_FQDN_LIST;

class SAMNAME_SD {
public:
    SAMNAME_SD (const wstring& upn, PSECURITY_DESCRIPTOR pSecurityDescriptor)
    {
        m_upn = upn;
        m_pSecurityDescriptor = pSecurityDescriptor;
    }
    virtual ~SAMNAME_SD ()
    {
        if ( m_pSecurityDescriptor )
            ::LocalFree (m_pSecurityDescriptor);
    }
    wstring                 m_upn;
    PSECURITY_DESCRIPTOR    m_pSecurityDescriptor;
    ACE_SAMNAME_LIST          m_DACLList;
    ACE_SAMNAME_LIST          m_SACLList;
};


typedef enum {
    GUID_TYPE_UNKNOWN = -1,
    GUID_TYPE_CLASS = 0,
    GUID_TYPE_ATTRIBUTE,
    GUID_TYPE_CONTROL
} GUID_TYPE;

class CACLDiagComModule : public CComModule
{
public:
    CACLDiagComModule();

    virtual ~CACLDiagComModule ();

    HRESULT Init ();

    void SetObjectDN (const wstring& objectDN)
    {
        // strip quotes, if present
        m_strObjectDN = objectDN;
        StripQuotes (m_strObjectDN);
    }

    wstring GetObjectDN () const { return m_strObjectDN;}

    bool DoSchema () const { return m_bDoSchema;}
    void SetDoSchema () { m_bDoSchema = true;}

    bool CheckDelegation () const { return m_bDoCheckDelegation;}
    void SetCheckDelegation () { m_bDoCheckDelegation = true;}
    void TurnOffFixDelegation() { m_bDoFixDelegation = false;}
    bool FixDelegation () const { return m_bDoFixDelegation;}
    void SetFixDelegation () { m_bDoFixDelegation = true;}

    bool DoGetEffective () const { return m_bDoGetEffective;}
    void SetDoGetEffective (const wstring& strUserGroupDN) 
    { 
        // strip quotes, if present
        m_strUserGroupDN = strUserGroupDN;
        StripQuotes (m_strUserGroupDN);
        m_bDoGetEffective = true;
    }
    wstring GetEffectiveRightsPrincipal() const { return m_strUserGroupDN;}

    void SetTabDelimitedOutput () { m_bTabDelimitedOutput = true;}
    bool DoTabDelimitedOutput () const { return m_bTabDelimitedOutput;}

    void SetSkipDescription () { m_bSkipDescription = true;}
    bool SkipDescription () const { return m_bSkipDescription;}

    HRESULT GetClassFromGUID (REFGUID rGuid, wstring& strClassName, GUID_TYPE* pGuidType = 0);

    static HRESULT IsUserAdministrator (BOOL & bIsAdministrator);
    static bool IsWindowsNT();

    void SetDoLog(const wstring &strPath)
    {
        m_bLogErrors = true;
        m_strLogPath = strPath;
    }
    bool DoLog () const { return m_bLogErrors;}
    wstring GetLogPath () const { return m_strLogPath;};

public:    
    // SD of m_strObjectDN
    PSECURITY_DESCRIPTOR    m_pSecurityDescriptor;
    PSID_FQDN_LIST       m_PSIDList;    // SIDs of interest: the owner, the SACL, the DACL

    // DACL and SACL of m_strObjectDN
    ACE_SAMNAME_LIST        m_DACLList;
    ACE_SAMNAME_LIST        m_SACLList;

    // SDs and DACLs for all the parents of m_strObjectDN
    list<SAMNAME_SD*>       m_listOfParentSDs;

    // List of all known classes and properties, with their GUIDs
    CGrowableArr<CSchemaClassInfo>   m_classInfoArray;
    CGrowableArr<CSchemaClassInfo>   m_attrInfoArray;

    CACLAdsiObject m_adsiObject;

private:
    bool m_bSkipDescription;
    wstring m_strLogPath;
    HANDLE      m_hPrivToken;
    wstring     m_strObjectDN;
    wstring     m_strUserGroupDN;
    bool        m_bDoSchema;
    bool        m_bDoCheckDelegation;
    bool        m_bDoGetEffective;
    bool        m_bDoFixDelegation;
    bool        m_bTabDelimitedOutput;
    bool        m_bLogErrors;
};

extern CACLDiagComModule _Module;


VOID LocalFreeStringW(LPWSTR* ppString);
HRESULT GetNameFromSid (PSID pSid, wstring& strPrincipalName, wstring* pstrFQDN, SID_NAME_USE& sne);


int MyWprintf( const wchar_t *format, ... );


#endif __ACLDIAG_ADUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\chkdeleg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ChkDeleg.cpp
//
//  Contents:   CheckDelegation and support methods
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <conio.h>
#include <aclapi.h>
#include "adutils.h"
#include <util.h>
#include "ChkDeleg.h"
#include <deltempl.h>
#include <tempcore.h>
#include "SecDesc.h"



#include <sddl.h>
#include <dscmn.h>  // from the admin\display project (CrackName)

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif

#include <_util.cpp>
#include <_tempcor.cpp>
#include <_deltemp.cpp>




class CTemplateAccessPermissionsHolderManagerVerify : public CTemplateAccessPermissionsHolderManager
{
public:

  HRESULT ProcessTemplates ();  // for ACLDiag - process each template in turn
  HRESULT ProcessPermissions(
                const wstring& strObjectClass, 
                CTemplate* pTemplate, 
                PACL pAccessList,
                CPrincipalList& principalList);
};




HRESULT CheckDelegation ()
{
    _TRACE (1, L"Entering  CheckDelegation\n");
    HRESULT hr = S_OK;
    wstring str;


    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_DELEGATION_TEMPLATE_DIAGNOSIS);
        MyWprintf (str.c_str ());
    }

    CTemplateAccessPermissionsHolderManagerVerify templateAccessPermissionsHolderManager;

    if ( templateAccessPermissionsHolderManager.LoadTemplates() )
    {
        hr = templateAccessPermissionsHolderManager.ProcessTemplates ();
    }
    else
    {
        LoadFromResource (str, IDS_FAILED_TO_LOAD_TEMPLATES);
        MyWprintf (str.c_str ());
        hr = E_FAIL;
    }

    _TRACE (-1, L"Leaving CheckDelegation: 0x%x\n", hr);
    return hr;
}

PTOKEN_USER EfspGetTokenUser ()
{
    _TRACE (1, L"Entering  EfspGetTokenUser\n");
    HANDLE              hToken = 0;
    DWORD               dwReturnLength = 0;
    PTOKEN_USER         pTokenUser = NULL;

    BOOL    bResult = ::OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &hToken);
    if ( bResult )
    {
        bResult  = ::GetTokenInformation (
                     hToken,
                     TokenUser,
                     NULL,
                     0,
                     &dwReturnLength
                     );

        if ( !bResult && dwReturnLength > 0 )
        {
            pTokenUser = (PTOKEN_USER) malloc (dwReturnLength);

            if (pTokenUser)
            {
                bResult = GetTokenInformation (
                             hToken,
                             TokenUser,
                             pTokenUser,
                             dwReturnLength,
                             &dwReturnLength
                             );

                if ( !bResult)
                {
                    DWORD dwErr = GetLastError ();
                    _TRACE (0, L"GetTokenInformation () failed: 0x%x\n", dwErr);
                    free (pTokenUser);
                    pTokenUser = NULL;
                }
            }
        }
        else
        {
            DWORD dwErr = GetLastError ();
            _TRACE (0, L"GetTokenInformation () failed: 0x%x\n", dwErr);
        }

        ::CloseHandle (hToken);
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"OpenProcessToken () failed: 0x%x\n", dwErr);
    }

    _TRACE (-1, L"Leaving EfspGetTokenUser\n");
    return pTokenUser;
}

HRESULT CTemplateAccessPermissionsHolderManagerVerify::ProcessTemplates ()
{
    HRESULT                 hr = S_OK;

    DWORD   dwErr = 0;

    // the access list is read in, modified, written back
    // If /fixdeleg is on, this list will be populated from the DS,
    // will receive the permissions associated with selected templates is the
    // user chooses to fix delegation, and then will be written back to the DS.
    PACL pFixDACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;


    LPCWSTR lpszObjectLdapPath = _Module.m_adsiObject.GetLdapPath();

    // get the security info
    if ( _Module.FixDelegation () && !_Module.DoTabDelimitedOutput () )
    {
        _TRACE (0, L"calling GetSDForDsObjectPath(%s, ...)\n", lpszObjectLdapPath);
        HRESULT hr1 = ::GetSDForDsObjectPath ((LPWSTR) lpszObjectLdapPath,    // name of the object
                                         &pFixDACL,            // receives a pointer to the DACL
                                         &pSD);
        if (FAILED(hr1))
        {
            _TRACE (0, L"failed on GetSDForDsObjectPath(): hr1 = 0x%x\n", hr1);
            wstring str;
            LoadFromResource (str, IDS_DELEGWIZ_ERR_GET_SEC_INFO);
            MyWprintf (str.c_str ());
            _Module.TurnOffFixDelegation ();
        }
    }

    CPrincipal              principal;  // a dummy placeholder for us to get 
                                        // the incremental rights associated
                                        // with each template

    // We will use the current logged-in user as a placeholder only.
    PTOKEN_USER pTokenUser = ::EfspGetTokenUser ();
    if ( pTokenUser )
    {
        hr = principal.Initialize (pTokenUser->User.Sid);
        free (pTokenUser);
    }

    if ( SUCCEEDED (hr) )
    {
        CTemplateList* pList = m_templateManager.GetTemplateList();
        for (CTemplateList::iterator itr = pList->begin(); itr != pList->end(); itr++)
        {
            CTemplate* pTemplate = *itr;
            ASSERT(pTemplate != NULL);

            // Select the templates one at a time to get the
            // permissions representing them
            pTemplate->m_bSelected = TRUE;

            if ( InitPermissionHoldersFromSelectedTemplates (
                    &_Module.m_classInfoArray,
                    &_Module.m_adsiObject) )
            {
                // This access list will contain only the access control values 
                // associated with the selected template
                PACL pAccessList = 0; //(PACL) ::LocalAlloc (LMEM_ZEROINIT, sizeof (ACL));
                if ( 1 ) //pAccessList )
                {
                    dwErr = UpdateAccessList (
                            &principal, 
                            _Module.m_adsiObject.GetServerName(),
                            _Module.m_adsiObject.GetPhysicalSchemaNamingContext(),
                            &pAccessList
                            );

                    if ( 0 == dwErr )
                    {
                        CPrincipalList  principalList;
                        PSID            pSid = principal.GetSid ();
                        SID_NAME_USE    sne = SidTypeUnknown;
                        wstring         strPrincipalName;

                        hr = GetNameFromSid (pSid, strPrincipalName, 0, sne);
                        if ( SUCCEEDED (hr) )
                        {
                            hr = ProcessPermissions (_Module.m_adsiObject.GetClass (),
                                    pTemplate, pAccessList, principalList);
                            if ( SUCCEEDED (hr) && _Module.FixDelegation () && !_Module.DoTabDelimitedOutput () )
                            {
                                // loop thru all the principals and classes
                                CPrincipalList::iterator i;
                              for (i = principalList.begin(); i != principalList.end(); ++i)
                              {
                                    CPrincipal* pCurrPrincipal = (*i);
                                    dwErr = UpdateAccessList(
                                            pCurrPrincipal, 
                                            _Module.m_adsiObject.GetServerName(),
                                            _Module.m_adsiObject.GetPhysicalSchemaNamingContext(),
                                            &pFixDACL);
                                    if (dwErr != 0)
                                        break;
                                } // for pCurrPrincipal
                            }
                        }
                    }

                    ::LocalFree (pAccessList);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            pTemplate->m_bSelected = FALSE;
        }

        if ( _Module.FixDelegation () && !_Module.DoTabDelimitedOutput () )
        {
            // commit changes
            _TRACE (0, L"calling SetNamedSecurityInfo(%s, ...)\n", lpszObjectLdapPath);
            dwErr = ::SetNamedSecurityInfoW(
                    (LPWSTR) lpszObjectLdapPath,
                    SE_DS_OBJECT_ALL,
                    DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pFixDACL,
                    0);
            if (dwErr != ERROR_SUCCESS)
            {
                _TRACE (0, L"failed on SetNamedSecurityInfo(): dwErr = 0x%x\n", dwErr);
                wstring str;
                LoadFromResource (str, IDS_DELEGWIZ_ERR_SET_SEC_INFO);
                MyWprintf (str.c_str ());
            }
        }
    }


    if ( pSD )
        ::LocalFree (pSD);


    return hr;
}


class CTemplateStatus 
{
public:
    CTemplateStatus () : 
            m_nACECnt (1),
            m_bApplies (false),
            m_bInherited (false)
    {
    }

    ULONG                       m_nACECnt;
    bool                        m_bApplies;
    bool                        m_bInherited;
    wstring                     m_strObjName;
    PSID                        m_psid;
};

typedef list<CTemplateStatus*>  CStatusList;

HRESULT CTemplateAccessPermissionsHolderManagerVerify::ProcessPermissions(
        const wstring& strObjectClass, 
        CTemplate* pTemplate, 
        PACL pDacl,
        CPrincipalList& principalList)
{
    if ( !pTemplate )
        return E_POINTER;

    HRESULT         hr = S_OK;
    CStatusList     statusList; // This list will contain 1 entry for each 
                                // SidStart/bInherited/bApplies triplet.
                                // The counter for each item will incremented 
                                // each time an ACE is found that belongs to 
                                // the object pointed to by the SidStart.
    ULONG           nExpectedCnt = 0;
    bool            bApplies = pTemplate->AppliesToClass(strObjectClass.c_str ()) ? true : false;
    ACE_SAMNAME*    pAceSAMName = 0;


    // Look in global DACL for each right
    PACCESS_ALLOWED_ACE pAllowedAce = 0;

    // iterate through the template ACES
    for (int i = 0; i < pDacl->AceCount; i++)
    {
        if ( GetAce (pDacl, i, (void **)&pAllowedAce) )
        {
            PSID AceSid = 0;
            if ( IsObjectAceType ( pAllowedAce ) ) 
            {
                AceSid = RtlObjectAceSid( pAllowedAce );
            } 
            else 
            {
                AceSid = &( ( PKNOWN_ACE )pAllowedAce )->SidStart;
            }
            ASSERT (IsValidSid (AceSid));

            if ( !IsValidSid (AceSid) )
                continue;

//            wstring         strPrincipalName;
//            SID_NAME_USE    sne = SidTypeUnknown;
//            hr = GetNameFromSid (AceSid, strPrincipalName, 0, sne);
//            if ( SUCCEEDED (hr) )
            {
                ACE_SAMNAME* pAceTemplate = new ACE_SAMNAME;
                if ( pAceTemplate )
                {
                    pAceTemplate->m_AceType = pAllowedAce->Header.AceType;
                    switch (pAceTemplate->m_AceType)
                    {
                    case ACCESS_ALLOWED_ACE_TYPE:
                        pAceTemplate->m_pAllowedAce = pAllowedAce;
                        break;

                    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                        pAceTemplate->m_pAllowedObjectAce = 
                                reinterpret_cast <PACCESS_ALLOWED_OBJECT_ACE> (pAllowedAce);
                        break;

                    case ACCESS_DENIED_ACE_TYPE:
                        pAceTemplate->m_pDeniedAce = 
                                reinterpret_cast <PACCESS_DENIED_ACE> (pAllowedAce);
                        break;

                    case ACCESS_DENIED_OBJECT_ACE_TYPE:
                        pAceTemplate->m_pDeniedObjectAce = 
                                reinterpret_cast <PACCESS_DENIED_OBJECT_ACE> (pAllowedAce);
                        break;

                    default:
                        break;
                    }
//                    pAceTemplate->m_SAMAccountName = strPrincipalName;
                    pAceTemplate->DebugOut ();
                    nExpectedCnt++;
                    ACE_SAMNAME_LIST::iterator itr = _Module.m_DACLList.begin ();
                    for (; itr != _Module.m_DACLList.end () && SUCCEEDED (hr); itr++)
                    {
                        pAceSAMName = *itr;

                        // to neutralize Sid differences
                        pAceTemplate->m_SAMAccountName = pAceSAMName->m_SAMAccountName;
                        if ( *pAceSAMName == *pAceTemplate )
                        {
                            bool                    bFound = false;
                            CTemplateStatus*        pStatus = 0;
                            CStatusList::iterator   itr1 = statusList.begin ();
                            wstring                 strObjName;
                            PSID                    psid = 0;


                            if ( ACCESS_ALLOWED_OBJECT_ACE_TYPE == pAceSAMName->m_AceType ) 
                            {
                                psid = RtlObjectAceSid (pAceSAMName->m_pAllowedObjectAce);
                            } 
                            else 
                            {
                                psid = &( ( PKNOWN_ACE )pAceSAMName->m_pAllowedAce )->SidStart;
                            }

                            SID_NAME_USE    sne = SidTypeUnknown;
                            hr = GetNameFromSid (psid, strObjName, 0, sne);
                            if ( SUCCEEDED (hr) )
                            {
                                for (; itr1 != statusList.end (); itr1++)
                                {
                                    pStatus = *itr1;
                                    if ( (pStatus->m_bApplies == bApplies) && 
                                            ( pStatus->m_bInherited == pAceSAMName->IsInherited () ) &&
                                            ( !_wcsicmp (
                                                    pStatus->m_strObjName.c_str (), 
                                                    strObjName.c_str ())) )
                                    {
                                        bFound = true;
                                        break;
                                    }
                                }

                                if ( bFound )
                                {
                                    pStatus->m_nACECnt++;
                                }
                                else
                                {
                                    pStatus = new CTemplateStatus;
                                    if ( pStatus )
                                    {
                                        pStatus->m_strObjName = strObjName;
                                        pStatus->m_bApplies = bApplies;
                                        pStatus->m_bInherited = pAceSAMName->IsInherited ();
                                        pStatus->m_psid = psid;
                                        statusList.push_back (pStatus);
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
        }
    }


    // Now, iterate thru status list and evaluate each item
    // If the list is empty, then this template is not present.
    // Otherwise, for each present item, if the class and attr count is less than the required count
    // the template is partial for the item.
    // Otherwise, it is OK.
    CStatusList::iterator   itr = statusList.begin ();
    CTemplateStatus*        pStatus = 0;    
    wstring                 str;
    wstring                 strStatus;


    for (; itr != statusList.end () && SUCCEEDED (hr); itr++)
    {
        pStatus = *itr;

        // Print template description
        bool    bMisconfigured = false;

        if ( _Module.DoTabDelimitedOutput () )
        {
            FormatMessage (str, IDS_DELEGATION_TITLE_CDO, pTemplate->GetDescription (),  
                    pStatus->m_strObjName.c_str ());
        }
        else
        {
            FormatMessage (str, IDS_DELEGATION_TITLE, pTemplate->GetDescription (),  
                    pStatus->m_strObjName.c_str ());
        }
        MyWprintf (str.c_str ());

        // Print "Status: OK/MISCONFIGURED"
        if ( pStatus->m_nACECnt < nExpectedCnt )
        {
            LoadFromResource (strStatus, IDS_MISCONFIGURED);
            bMisconfigured = true;
        }
        else
            LoadFromResource (strStatus, IDS_OK);

        if ( _Module.DoTabDelimitedOutput () )
            FormatMessage (str, IDS_DELTEMPL_STATUS_CDO, strStatus.c_str ());
        else
            FormatMessage (str, IDS_DELTEMPL_STATUS, strStatus.c_str ());
        MyWprintf (str.c_str ());

        // Print "Applies on this object: YES/NO"
        if ( pStatus->m_bApplies )
        {
            LoadFromResource (strStatus, 
                    _Module.DoTabDelimitedOutput () ? IDS_APPLIES : IDS_YES);
        }
        else
        {
            LoadFromResource (strStatus, 
                    _Module.DoTabDelimitedOutput () ? IDS_DOES_NOT_APPLY : IDS_NO);
        }

        if ( _Module.DoTabDelimitedOutput () )
            FormatMessage (str, IDS_APPLIES_ON_THIS_OBJECT_CDO, strStatus.c_str ());
        else
            FormatMessage (str, IDS_APPLIES_ON_THIS_OBJECT, strStatus.c_str ());
        MyWprintf (str.c_str ());

        // Print "Inherited from parent: YES/NO"
        if ( pStatus->m_bInherited )
        {
            LoadFromResource (strStatus, 
                    _Module.DoTabDelimitedOutput () ? IDS_INHERITED : IDS_YES);
        }
        else
        {
            LoadFromResource (strStatus, 
                    _Module.DoTabDelimitedOutput () ? IDS_EXPLICIT : IDS_NO);
        }

        if ( _Module.DoTabDelimitedOutput () )
            FormatMessage (str, IDS_INHERITED_FROM_PARENT_CDO, strStatus.c_str ());
        else
            FormatMessage (str, IDS_INHERITED_FROM_PARENT, strStatus.c_str ());
        MyWprintf (str.c_str ());

        if ( bMisconfigured && _Module.FixDelegation () && !_Module.DoTabDelimitedOutput () )
        {
            LoadFromResource (str, IDS_FIX_DELEGATION_QUERY);

            while (1)
            {
                MyWprintf (str.c_str ());

                int ch = _getche ();
                
                if ( 'y' == ch )
                {
                    CPrincipal* pPrincipal = new CPrincipal;

                    if ( pPrincipal )
                    {
                        if ( SUCCEEDED (pPrincipal->Initialize (pStatus->m_psid)) )
                            principalList.push_back (pPrincipal);
                        else
                            delete pPrincipal;
                    }
                    else
                        hr = E_OUTOFMEMORY;

                    MyWprintf (L"\n\n");
                    break;
                }
                else if ( 'n' == ch )
                {
                    MyWprintf (L"\n\n");
                    break;
                }
                else
                {
                    MyWprintf (L"\n");
                    continue;
                }
            }
        }
    }

    if ( !pStatus ) // None found
    {
        // Print template description
        if ( _Module.DoTabDelimitedOutput () )
        {
            FormatMessage (str, IDS_DELEGATION_NOT_FOUND_CDO, 
                    pTemplate->GetDescription ());
            MyWprintf (str.c_str ());
        }
        else
        {
            FormatMessage (str, L"\t%1\n\n", pTemplate->GetDescription ());
            MyWprintf (str.c_str ());

            LoadFromResource (strStatus, IDS_NOT_PRESENT);
            FormatMessage (str, IDS_DELTEMPL_STATUS, strStatus.c_str ());
            MyWprintf (str.c_str ());
        }
    }

    if ( !_Module.DoTabDelimitedOutput () )
        MyWprintf (L"\n");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000.
//
//  File:       debug.cpp
//
//  Contents:   Debugging support
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "strsafe.h"

#if DBG == 1
#define DEBUG_OUTPUT_NONE       0
#define DEBUG_OUTPUT_ERROR      1
#define DEBUG_OUTPUT_WARNING    2
#define DEBUG_OUTPUT_TRACE      3
#define DEBUGKEY    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug\\ACLDiag"
#define DEBUGLEVEL  L"debugOutput"

static bool             g_fDebugOutputLevelInit = false;
static unsigned long    g_ulDebugOutput = DEBUG_OUTPUT_NONE;
static int indentLevel = 0;

//NTRAID#NTBUG9-530206-2002/06/18-ronmart-Use countof for buffers on the stack
#ifndef countof
#define countof(x) (sizeof(x) / sizeof((x)[0]))
#endif // countof

void TRACE (const wchar_t *format, ... )
{
    if ( g_ulDebugOutput > DEBUG_OUTPUT_NONE )
    {
        va_list         arglist;
        const size_t    BUF_LEN = 512;
        WCHAR           szBuffer[BUF_LEN];

        //
        // Format the output into a buffer and then print it.
        //
        wstring strTabs;

        for (int nLevel = 0; nLevel < indentLevel; nLevel++)
            strTabs += L"  ";

        OutputDebugStringW (strTabs.c_str ());

        va_start(arglist, format);
        //NTRAID#NTBUG9-530206-2002/06/18-ronmart-Use countof for buffers on the stack
        HRESULT hr = StringCchVPrintf (szBuffer,
                                countof(szBuffer),
                                format,
                                arglist);
        if ( SUCCEEDED (hr) )
        {
            OutputDebugStringW (szBuffer);
        }

        va_end(arglist);
    }
}

void _TRACE (int level, const wchar_t *format, ... )
{
    if ( g_ulDebugOutput > DEBUG_OUTPUT_NONE )
    {
        va_list arglist;
        const   size_t BUF_LEN = 512;
        WCHAR   szBuffer[BUF_LEN];

        if ( level < 0 )
            indentLevel += level;
        //
        // Format the output into a buffer and then print it.
        //
        wstring strTabs;

        for (int nLevel = 0; nLevel < indentLevel; nLevel++)
            strTabs += L"  ";

        OutputDebugStringW (strTabs.c_str ());

        va_start(arglist, format);
        //NTRAID#NTBUG9-530206-2002/06/18-ronmart-Use countof for buffers on the stack
        HRESULT hr = StringCchVPrintf (szBuffer,
                                countof(szBuffer),
                                format,
                                arglist);
        if ( SUCCEEDED (hr) )
        {
            OutputDebugStringW (szBuffer);
        }

        va_end(arglist);

        if ( level > 0 )
            indentLevel += level;
    }
}


PCSTR StripDirPrefixA (PCSTR pszPathName)

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    ASSERT (pszPathName);
    if ( !pszPathName )
        return 0;

    if ( !pszPathName[0] )
        return 0;

    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

//+----------------------------------------------------------------------------
// Function:    CheckDebugOutputLevel
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void CheckDebugOutputLevel ()
{
    if ( g_fDebugOutputLevelInit ) 
        return;
    g_fDebugOutputLevelInit = true;
    HKEY    hKey = 0;
    DWORD   dwDisposition = 0;
    LONG lResult = ::RegCreateKeyEx (HKEY_LOCAL_MACHINE, // handle of an open key
            DEBUGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_VOLATILE,      // special options flag 
            KEY_ALL_ACCESS,    // desired security access - required to create new key
            NULL,     // address of key security structure
            &hKey,      // address of buffer for opened handle
            &dwDisposition);  // address of disposition value buffer
    if (lResult == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof(unsigned long);
        lResult = RegQueryValueExW (hKey, DEBUGLEVEL, NULL, NULL,
                                (LPBYTE)&g_ulDebugOutput, &dwSize);
        if (lResult != ERROR_SUCCESS)
        {
            g_ulDebugOutput = DEBUG_OUTPUT_NONE;
            if ( ERROR_FILE_NOT_FOUND == lResult )
            {
                RegSetValueExW (hKey, DEBUGLEVEL, 0, REG_DWORD,
                        (LPBYTE)&g_ulDebugOutput, sizeof (g_ulDebugOutput));
            }
        }
        RegCloseKey(hKey);
    }
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\effright.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       EffRight.h
//
//  Contents:   Effective Rights Diagnosis and support methods
//              
//
//----------------------------------------------------------------------------
#ifndef __ACLDIAG_EFFRIGHT_H
#define __ACLDIAG_EFFRIGHT_H

#include "stdafx.h"


HRESULT EffectiveRightsDiagnosis ();

#endif //__ACLDIAG_EFFRIGHT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000.
//
//  File:       debug.h
//
//  Contents:   Debugging macros and prototypes
//
//----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG == 1


void _TRACE (int level, const wchar_t *format, ... );
void TRACE (const wchar_t *format, ... );


//
// External functions
//

PCSTR StripDirPrefixA(PCSTR);



//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//

#ifdef ASSERT
#undef ASSERT
#undef ASSERTMSG
#endif

#define ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
               _TRACE (0, L"ACLDiag(Thread ID: %d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                _TRACE (0, L"ACLDiag(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                _TRACE (0, msg);                                           \
                _TRACE (0, "\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

void CheckDebugOutputLevel ();

#else // !DBG


#define _TRACE 
#define TRACE

#ifndef ASSERT
#define ASSERT(expr)
#endif

#ifndef ASSERTMSG
#define ASSERTMSG(expr, msg)
#endif

#endif


#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\effright.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2002.
//
//  File:       EffRight.cpp
//
//  Contents:   Effective Rights Diagnosis and support methods
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "adutils.h"
#include "EffRight.h"
#include "AccessCk.h"
#include "SecDesc.h"

// Classes
#pragma warning (disable : 4127)

class CResultObject
{
public:
    CResultObject (
            ACCESS_MASK accessBit, 
            const wstring& strResult, 
            GUID_TYPE guidType,
            USHORT level);
    ~CResultObject () {}

    bool operator== (CResultObject& rResultObject)
    {
        if ( m_accessBit == rResultObject.m_accessBit )
            return true;
        else
            return false;
    }
    bool operator< (CResultObject& rResultObject)
    {
        if ( 0 == m_level )
            return true;

        if ( m_accessBit < rResultObject.m_accessBit )
        {
            return true;
        }
        else
            return false;
    }

    const CResultObject& operator= (const CResultObject& obj)
    {
        UNREFERENCED_PARAMETER (obj);
        ASSERT (0);
    }

    void PrintResult ()
    {
        MyWprintf (m_strResult.c_str ());
    }

    ACCESS_MASK GetRight () const
    {
        return m_accessBit;
    }

    bool IsValid () const
    {
        return m_bIsValid;
    }

    USHORT GetLevel () const
    {
        return m_level;
    }

private:
    const wstring     m_strResult;
    const ACCESS_MASK m_accessBit;
    const GUID_TYPE   m_guidType;
    bool              m_bIsValid;
    const USHORT      m_level;
};

CResultObject::CResultObject (
        ACCESS_MASK accessBit, 
        const wstring& strResult, 
        GUID_TYPE guidType,
        USHORT level) :
    m_accessBit (accessBit),
    m_strResult (strResult),
    m_guidType (guidType),
    m_bIsValid (true),
    m_level (level)
{

//    case ACTRL_DS_LIST:
//    case ACTRL_DELETE:
//    case ACTRL_CHANGE_ACCESS:
//    case ACTRL_CHANGE_OWNER:
//    case ACTRL_DS_LIST_OBJECT:
//    case ACTRL_DS_SELF:

    switch (guidType)
    {
    case GUID_TYPE_CLASS:
        ASSERT (0 == m_level);
        switch (accessBit)
        {
        case ACTRL_DS_CREATE_CHILD:
        case ACTRL_DS_DELETE_CHILD:
        case ACTRL_DS_READ_PROP:         // all
        case ACTRL_DS_WRITE_PROP:       // all
        case ACTRL_DS_LIST:
        case ACTRL_DS_LIST_OBJECT:
        case ACTRL_DS_CONTROL_ACCESS:   // all
        case ACTRL_DS_SELF:
            break;

        default:
            m_bIsValid = false;
            break;
        }
        break;

    case GUID_TYPE_ATTRIBUTE:
        ASSERT (0 != m_level);
        switch (accessBit)
        {
        case ACTRL_DS_READ_PROP:
        case ACTRL_DS_WRITE_PROP:
            break;

        case ACTRL_DS_CREATE_CHILD:
        case ACTRL_DS_DELETE_CHILD:
        case ACTRL_DS_CONTROL_ACCESS:
            m_bIsValid = false;
            break;
        
        default:
            m_bIsValid = false;
            break;
        }
        break;

        break;

    case GUID_TYPE_CONTROL:
        ASSERT (0 != m_level);
        switch (accessBit)
        {
        case ACTRL_DS_CONTROL_ACCESS:
        case ACTRL_DS_CREATE_CHILD:
        case ACTRL_DS_DELETE_CHILD:
            m_bIsValid = false;
            break;

        case ACTRL_DS_READ_PROP:
        case ACTRL_DS_WRITE_PROP:
        case ACTRL_READ_CONTROL:
        default:
            m_bIsValid = false;
            break;
        }
        break;

    default:
        ASSERT (FALSE);
        break;
    }
}

typedef CResultObject* PCResultObject;

bool compare_resultObject (PCResultObject& obj1, PCResultObject& obj2)
{
    return (*obj1) < (*obj2);
}


//
//  Function Prototypes
//

HRESULT GetFQDN (
            PSID_FQDN* pPsidFQDN, 
            wstring& strFQDN);
HRESULT GetDownlevelName (
            PSID_FQDN* pPsidFQDN, 
            wstring& strDownlevelName);
HRESULT ProcessObject (
            const wstring&      strObjectDN, 
            POBJECT_TYPE_LIST   pObjectTypeList, 
            size_t              objectTypeListLength,
            PSID                principalSelfSid,
            const wstring&      strDownlevelName);
HRESULT GetTokenGroups (
            const wstring& strObjectDN, 
            list<PSID>& psidList);
HRESULT EnumerateEffectivePermissions (
            const wstring& strObjectDN, 
            const IOBJECT_TYPE_LIST& otl, 
            const P_TYPE ptype, 
            vector<PCResultObject>& resultList);
HRESULT DisplayEffectivePermission (
            const wstring& strObjectDN, 
            const IOBJECT_TYPE_LIST& otl,
            const ACCESS_MASK accessMask,
            const P_TYPE  ptype,
            const int strIDAll, 
            const int strIDParam, 
            const int strIDCDO,
            vector<PCResultObject>& resultList);
HRESULT DisplayEffectivePermission (
            const wstring& strObjectDN, 
            const IOBJECT_TYPE_LIST& otl,
            const ACCESS_MASK accessMask,
            const P_TYPE  ptype,
            const int strID,
            vector<PCResultObject>& resultList);
void PrintGroupProvenance (
            const ACCESS_MASK accessMask, 
            const IOBJECT_TYPE_LIST& otl,
            const P_TYPE  ptype,
            wstring& strProvenance);
void PrintEffectiveRightsHeader (
            ACCESS_MASK lastRight,
            USHORT level);

HRESULT EffectiveRightsDiagnosis ()
{
    _TRACE (1, L"Entering  EffectiveRightsDiagnosis\n");
    HRESULT hr = S_OK;

    wstring str;

    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_EFFECTIVE_RIGHTS_DIAGNOSIS);

        MyWprintf (str.c_str ());
    }

    POBJECT_TYPE_LIST   pObjectTypeList = 0;
    size_t              objectTypeListLength = 0;

    hr = _Module.m_adsiObject.BuildObjectTypeList (&pObjectTypeList, objectTypeListLength);

    if ( SUCCEEDED (hr) && SUCCEEDED (SepInit ()) )
    {
        PSID principalSelfSid = 0;
        hr = _Module.m_adsiObject.GetPrincipalSelfSid (principalSelfSid);
        if ( !wcscmp (_Module.GetEffectiveRightsPrincipal ().c_str (), L"*") )
        {
            for (PSID_FQDN_LIST::iterator itr = _Module.m_PSIDList.begin (); 
                       itr != _Module.m_PSIDList.end ();// && SUCCEEDED (hr); 
                       itr++)
            {
                wstring strDownlevelName;
                wstring strFQDN;

                hr = GetFQDN (*itr, strFQDN);
                if ( SUCCEEDED (hr) )
                {
                    hr = GetDownlevelName (*itr, strDownlevelName);
                    if ( SUCCEEDED (hr) )
                    {
                        hr = ProcessObject (strFQDN, pObjectTypeList, 
                                objectTypeListLength, principalSelfSid, 
                                strDownlevelName);
                    }
                }
            }
        }
        else
        {
            hr = ProcessObject (_Module.GetEffectiveRightsPrincipal (), 
                    pObjectTypeList, objectTypeListLength, principalSelfSid,
                    _Module.GetEffectiveRightsPrincipal ());
        }

        // Free memory allocated for Sid
        if ( principalSelfSid )
            CoTaskMemFree (principalSelfSid);

        // Free object type list array
        for (DWORD idx = 0; idx < objectTypeListLength; idx++)
        {
            CoTaskMemFree (pObjectTypeList[idx].ObjectType);
        }
        CoTaskMemFree (pObjectTypeList);

        SepCleanup ();
    }

   _TRACE (-1, L"Leaving EffectiveRightsDiagnosis: 0x%x\n", hr);
    return hr;
}

HRESULT GetDownlevelName (PSID_FQDN* pPsidFQDN, wstring& strDownlevelName)
{
    _TRACE (1, L"Entering  GetDownlevelName\n");
    HRESULT hr = S_OK;

    if ( pPsidFQDN )
    {
        switch (pPsidFQDN->m_sne)
        {
        case SidTypeUser:           // Indicates a user SID. 
        case SidTypeGroup:          // Indicates a group SID. 
        case SidTypeAlias:          // Indicates an alias SID. 
        case SidTypeWellKnownGroup: // Indicates an SID for a well-known group. 
        case SidTypeDomain:         // Indicates a domain SID. 
        case SidTypeDeletedAccount: // Indicates an SID for a deleted account. 
            strDownlevelName = pPsidFQDN->m_strDownLevelName;
            break;

        case SidTypeInvalid:        // Indicates an invalid SID. 
        case SidTypeUnknown:        // Indicates an unknown SID type. 
            hr = E_FAIL;
            break;

        default:
            hr = E_UNEXPECTED;
            break;
        }
    }
    else
        hr = E_POINTER;

   _TRACE (-1, L"Leaving GetDownlevelName: 0x%x\n", hr);
    return hr;
}

HRESULT GetFQDN (PSID_FQDN* pPsidFQDN, wstring& strFQDN)
{
    _TRACE (1, L"Entering  GetFQDN\n");
    HRESULT hr = S_OK;

    if ( pPsidFQDN )
    {
        switch (pPsidFQDN->m_sne)
        {
        case SidTypeUser:           // Indicates a user SID. 
        case SidTypeGroup:          // Indicates a group SID. 
        case SidTypeAlias:          // Indicates an alias SID. 
        case SidTypeWellKnownGroup: // Indicates an SID for a well-known group. 
            strFQDN = pPsidFQDN->m_strFQDN;
            break;

        case SidTypeDomain:         // Indicates a domain SID. 
        case SidTypeDeletedAccount: // Indicates an SID for a deleted account. 
        case SidTypeInvalid:        // Indicates an invalid SID. 
        case SidTypeUnknown:        // Indicates an unknown SID type. 
            hr = E_FAIL;
            break;

        default:
            hr = E_UNEXPECTED;
            break;
        }
    }
    else
        hr = E_POINTER;

   _TRACE (-1, L"Leaving GetFQDN: 0x%x\n", hr);
    return hr;
}


HRESULT GetTokenGroups (const wstring& strObjectDN, list<PSID>& psidList)
{
    _TRACE (1, L"Entering  GetTokenGroups\n");
    HRESULT     hr = S_OK;

    
    CComPtr<IADsPathname> spPathname;
    //
    // Constructing the directory paths
    //
    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG (IADsPathname, &spPathname));
    if ( SUCCEEDED (hr) )
    {
        ASSERT (!!spPathname);
        hr = spPathname->put_EscapedMode (ADS_ESCAPEDMODE_OFF_EX );

        hr = spPathname->Set (CComBSTR (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (CComBSTR (strObjectDN.c_str ()), ADS_SETTYPE_DN);
            if ( SUCCEEDED (hr) )
            {
                BSTR bstrFullPath = 0;
                hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
                if ( SUCCEEDED (hr) )
                {
                    CComPtr<IDirectoryObject> spDirObj;


                    hr = ADsOpenObjectHelper (bstrFullPath,
                                              IID_IDirectoryObject, 
                                              0,
                                              (void**)&spDirObj);
                    if ( SUCCEEDED (hr) )
                    {
                        {
                            //
                            // Get "objectSid" attribute
                            //
                            const PWSTR     wzAllowedAttributes = L"objectSid";
                            PADS_ATTR_INFO  pAttrs = 0;
                            DWORD           cAttrs = 0;
                            LPWSTR          rgpwzAttrNames[] = {wzAllowedAttributes};

                            hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
                            if ( SUCCEEDED (hr) )
                            {
                                if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                {
                                    for (DWORD  dwIdx = 0; dwIdx < pAttrs->dwNumValues; dwIdx++)
                                    {
                                        PSID    pSid = pAttrs->pADsValues[dwIdx].OctetString.lpValue;
                                        if ( pSid && IsValidSid (pSid) )
                                        { 
                                            DWORD   dwSidLen = GetLengthSid (pSid);
                                            PSID    pSidCopy = CoTaskMemAlloc (dwSidLen);
                                            
                                            if ( pSidCopy )
                                            {
                                                if ( CopySid (dwSidLen, pSidCopy, pSid) )
                                                {
                                                    ASSERT (IsValidSid (pSidCopy));
                                                    psidList.push_back (pSidCopy);
                                                }
                                                else
                                                {
                                                    CoTaskMemFree (pSidCopy);
                                                    hr = GetLastError ();
                                                    _TRACE (0, L"CopySid () failed: 0x%x\n", hr);
                                                    break;
                                                }
                                            }
                                            else
                                            {
                                                hr = E_OUTOFMEMORY;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if ( pAttrs )
                                    FreeADsMem (pAttrs);
                            }
                            else
                            {
                                _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                            }
                        }

                        if ( SUCCEEDED (hr) )
                        {
                            //
                            // Get "tokenGroups" attribute
                            //
                            const PWSTR     wzAllowedAttributes = L"tokenGroups";
                            PADS_ATTR_INFO  pAttrs = 0;
                            DWORD           cAttrs = 0;
                            LPWSTR          rgpwzAttrNames[] = {wzAllowedAttributes};

                            hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
                            if ( SUCCEEDED (hr) )
                            {
                                if ( 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                                {
                                    for (DWORD  dwIdx = 0; dwIdx < pAttrs->dwNumValues; dwIdx++)
                                    {
                                        PSID    pSid = pAttrs->pADsValues[dwIdx].OctetString.lpValue;
                                        if ( pSid && IsValidSid (pSid) )
                                        { 
                                            DWORD   dwSidLen = GetLengthSid (pSid);
                                            PSID    pSidCopy = CoTaskMemAlloc (dwSidLen);
                                            
                                            if ( pSidCopy )
                                            {
                                                if ( CopySid (dwSidLen, pSidCopy, pSid) )
                                                {
                                                    ASSERT (IsValidSid (pSidCopy));
                                                    psidList.push_back (pSidCopy);
                                                }
                                                else
                                                {
                                                    CoTaskMemFree (pSidCopy);
                                                    hr = GetLastError ();
                                                    _TRACE (0, L"CopySid () failed: 0x%x\n", hr);
                                                    break;
                                                }
                                            }
                                            else
                                            {
                                                hr = E_OUTOFMEMORY;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if ( pAttrs )
                                    FreeADsMem (pAttrs);
                            }
                            else
                            {
                                _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                            }
                        }
                    }
                    else
                    {
                        _TRACE (0, L"ADsOpenObjectHelper (%s) failed: 0x%x\n", bstrFullPath);
                      
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve () failed: 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        strObjectDN.c_str (), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname) failed: 0x%x\n", hr);
    }

   _TRACE (-1, L"Leaving GetTokenGroups: 0x%x\n", hr);
    return hr;
}

HRESULT ProcessObject (
        const wstring&  strObjectDN,         // object having permissions on the 
                                            // target object
        POBJECT_TYPE_LIST pObjectTypeList,  // class, property and property set 
                                            // GUIDs of target object
        size_t          objectTypeListLength,// number of elements in pObjectTypeList
        PSID            principalSelfSid,
        const wstring&  strDownlevelName)
{
    _TRACE (1, L"Entering  ProcessObject\n");
    HRESULT     hr = S_OK;
    list<PSID>  psidList;   // sid of strObjectDN and all groups of which it is a member


    hr = GetTokenGroups (strObjectDN, psidList);
    if ( SUCCEEDED (hr) )
    {
        PACL    pDacl = 0;
        BOOL    bDaclPresent = FALSE;
        BOOL    bDaclDefaulted = FALSE;

        if ( GetSecurityDescriptorDacl (_Module.m_pSecurityDescriptor,
                &bDaclPresent, &pDacl, &bDaclDefaulted) )
        {
            PIOBJECT_TYPE_LIST LocalTypeList = 0;
            //
            // Capture any Object type list
            //

            NTSTATUS    Status = SeCaptureObjectTypeList( pObjectTypeList,
                                              objectTypeListLength,
                                              &LocalTypeList);

            if ( NT_SUCCESS(Status) ) 
            {
                hr = SepMaximumAccessCheck (psidList,
                        pDacl,
                        principalSelfSid,
                        objectTypeListLength,
                        LocalTypeList,
                        objectTypeListLength);

                if ( !_Module.DoTabDelimitedOutput () )
                {
                    wstring str;

                    FormatMessage (str, L"\n%1:\n\n", strDownlevelName.c_str ());
                    MyWprintf (str.c_str ());
                }

                vector<PCResultObject> resultList;

                for (DWORD idx = 0; idx < objectTypeListLength; idx++)
                {
                    EnumerateEffectivePermissions (strDownlevelName, 
                            LocalTypeList[idx], P_ALLOW, resultList);
                    EnumerateEffectivePermissions (strDownlevelName, 
                            LocalTypeList[idx], P_DENY, resultList);
                }

                // Sort LocalTypeList
                // 1. Object Level Rights
                // 2. Property Level Rights
                //      a. Create
                //      b. Delete
                //      c. Read
                //      d. Write
                // 3. Control Rights
                sort (resultList.begin (), resultList.end (), compare_resultObject);
                ACCESS_MASK lastRight = 0;

                for (vector<PCResultObject>::iterator itr = resultList.begin ();
                        itr != resultList.end (); itr++)
                {
                    PCResultObject pResultObject = *itr;

                    if ( lastRight != pResultObject->GetRight () )
                    {
                        lastRight = pResultObject->GetRight ();
                        if ( !_Module.DoTabDelimitedOutput () )
                            PrintEffectiveRightsHeader (lastRight, pResultObject->GetLevel ());
                    }
                    pResultObject->PrintResult ();
                    delete pResultObject;
                }
            }

            if ( LocalTypeList )
                delete [] LocalTypeList;
        }

        // Free memory pointed to by psidList members
        for (list<PSID>::iterator itr = psidList.begin (); 
                itr != psidList.end (); 
                itr++) 
        {
            CoTaskMemFree (*itr);
        }
    }

   _TRACE (-1, L"Leaving ProcessObject: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     EnumerateEffectivePermissions ()
//
//  Purpose:    Print all the permissions contained on the passed in ACE
//
//  Inputs:     otl - structure containing the ACE whose permissions we wish
//              to print
//
//              ptype - allow, deny, succes, failure, success and failure
//
HRESULT EnumerateEffectivePermissions (
        const wstring& strObjectDN, 
        const IOBJECT_TYPE_LIST& otl, 
        const P_TYPE ptype, 
        vector<PCResultObject>& resultList)
{
    HRESULT hr = S_OK;

    hr = DisplayEffectivePermission (strObjectDN,
            otl,
            ACTRL_DS_CREATE_CHILD, 
            ptype,
            IDS_CREATE_ALL_SUBOBJECTS_ER,
            IDS_CREATE_CLASS_OBJECTS_ER,
            IDS_CREATE_CLASS_OBJECTS,
            resultList);
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_DELETE_CHILD,
                ptype,
                IDS_DELETE_ALL_SUBOBJECTS_ER,
                IDS_DELETE_CLASS_OBJECTS_ER,
                IDS_DELETE_CLASS_OBJECTS,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_READ_PROP,
                ptype,
                IDS_READ_ALL_PROPERTIES_ER,
                IDS_READ_PROPERTY_PROPERTY_ER,
                IDS_READ_PROPERTY_PROPERTY,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_WRITE_PROP,
                ptype,
                IDS_WRITE_ALL_PROPERTIES_ER,
                IDS_WRITE_PROPERTY_PROPERTY_ER,
                IDS_WRITE_PROPERTY_PROPERTY,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl, 
                ACTRL_DS_LIST, 
                ptype,
                IDS_LIST_CONTENTS_ER, 
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_LIST_OBJECT,
                ptype,
                IDS_LIST_OBJECT_ER,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        if ( otl.CurrentGranted & ACTRL_DS_CONTROL_ACCESS )
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_CONTROL_ACCESS,
                ptype,
                IDS_ALL_CONTROL_ACCESSES_ER,
                IDS_CONTROL_ACCESS_DISPLAY_NAME,
                IDS_CONTROL_ACCESS_DISPLAY_NAME,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DELETE,
                ptype,
                IDS_DELETE_THIS_OBJECT_ER,
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_READ_CONTROL,
                ptype,
                IDS_READ_PERMISSIONS_ER, 
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_CHANGE_ACCESS,
                ptype,
                IDS_MODIFY_PERMISSIONS_ER, 
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_CHANGE_OWNER,
                ptype,
                IDS_TAKE_CHANGE_OWNERSHIP_ER, 
                resultList);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = DisplayEffectivePermission (strObjectDN,
                otl,
                ACTRL_DS_SELF,
                ptype,
                IDS_MODIFY_MEMBERSHIP_ER, 
                resultList);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     DisplayEffectivePermission ()
//
//  Purpose:    Print an OBJECT_ACE_TYPE permission
//
//  Inputs:     otl - structure containing the ACE whose permission we wish
//              to print
//
//              accessMask - the specific permission we're looking to print
//
//              bAllow - whether the permission is allowed or denied
//
//              strIDAll - string to print if permission applies to all object 
//              classes
//
//              strIDParam - string print if permission applies to a specific
//              object class
//
HRESULT DisplayEffectivePermission (const wstring& strObjectDN, 
        const IOBJECT_TYPE_LIST& otl,
        const ACCESS_MASK accessMask,
        const P_TYPE  ptype,
        const int strIDAll, 
        const int strIDParam, 
        const int strIDCDO,
        vector<PCResultObject>& resultList)
{
    HRESULT hr = S_OK;

    wstring str;
    wstring strPermission;


    if ( ((P_ALLOW == ptype) && (otl.CurrentGranted & accessMask)) ||
            ((P_DENY == ptype) && (otl.CurrentDenied & accessMask)) )
    {
        wstring strGuidResult;
        GUID_TYPE   guidType = GUID_TYPE_UNKNOWN;

        _Module.GetClassFromGUID (otl.ObjectType, strGuidResult, &guidType);

        switch (guidType)
        {
        case GUID_TYPE_CLASS:
            FormatMessage (strPermission, strIDAll, strGuidResult.c_str ());
            break;

        case GUID_TYPE_ATTRIBUTE:
            switch (accessMask)
            {
            case ACTRL_DS_LIST:
            case ACTRL_DS_LIST_OBJECT:
            case ACTRL_DS_SELF:
//            case ACTRL_DS_CONTROL_ACCESS:
                return S_OK;

            default:
                if ( _Module.DoTabDelimitedOutput () )
                    FormatMessage (strPermission, strIDCDO, strGuidResult.c_str ());
                else
                    FormatMessage (strPermission, strIDParam, strGuidResult.c_str ());
                break;
            }
            break;

        case GUID_TYPE_CONTROL:
            switch (accessMask)
            {
            case ACTRL_DS_LIST:
            case ACTRL_DS_LIST_OBJECT:
            case ACTRL_DS_SELF:
            case ACTRL_DS_CREATE_CHILD:
            case ACTRL_DS_DELETE_CHILD:
            case ACTRL_DELETE:
            case ACTRL_CHANGE_ACCESS:
            case ACTRL_CHANGE_OWNER:
            case ACTRL_DS_CONTROL_ACCESS:
                return S_OK;

            case ACTRL_DS_READ_PROP:
            case ACTRL_DS_WRITE_PROP:
            case ACTRL_READ_CONTROL:
            default:
                FormatMessage (strPermission, strIDParam, strGuidResult.c_str ());
                break;
            }
            break;

        case GUID_TYPE_UNKNOWN:
        default:
            return E_UNEXPECTED;
        }


        int strid = 0;

        switch (ptype)
        {
        case P_ALLOW:
            if ( _Module.DoTabDelimitedOutput () )
                strid = IDS_CAN_CDO;
            else
                strid = IDS_CAN_ER;
            break;

        case P_DENY:
            if ( _Module.DoTabDelimitedOutput () )
                strid = IDS_CANNOT_CDO;
            else
                strid = IDS_CANNOT_EF;
            break;

        default:
            return E_UNEXPECTED;
        }
        if ( _Module.DoTabDelimitedOutput () )
        {
            FormatMessage (str, strid, 
                    strObjectDN.c_str (),
                    strPermission.c_str ());
        }
        else
        {
            FormatMessage (str, strid, 
                    strPermission.c_str ());
        }

        wstring strProvenance;

        PrintGroupProvenance (accessMask, otl, ptype, strProvenance);
        str += strProvenance;

        PCResultObject pResultObject = new CResultObject (accessMask, str, 
                guidType, otl.Level);
        if ( pResultObject )
        {
            if ( pResultObject->IsValid () )
                resultList.push_back (pResultObject);
            else
                delete pResultObject;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     DisplayEffectivePermission ()
//
//  Purpose:    Print a non-OBJECT_ACE_TYPE permission
//
//  Inputs:     otl - structure containing the ACE whose permission we wish
//              to print
//
//              accessMask - the specific permission we're looking to print
//
//              bAllow - whether the permission is allowed or denied
//
//              strID - string to print
//
HRESULT DisplayEffectivePermission (
        const wstring& strObjectDN, 
        const IOBJECT_TYPE_LIST& otl,
        const ACCESS_MASK accessMask,
        const P_TYPE  ptype,
        const int strID,
        vector<PCResultObject>& resultList)
{
    HRESULT     hr = S_OK;
    wstring     str;
    wstring     strPermission;


    if ( ((P_ALLOW == ptype) && (otl.CurrentGranted & accessMask)) ||
            ((P_DENY == ptype) && (otl.CurrentDenied & accessMask)) )
    {
        wstring strGuidResult;
        GUID_TYPE   guidType = GUID_TYPE_UNKNOWN;
        wstring strType;

        _Module.GetClassFromGUID (otl.ObjectType, strGuidResult, &guidType);

        switch (guidType)
        {
        case GUID_TYPE_CLASS:
            LoadFromResource (strType, IDS_CLASS);
            break;

        case GUID_TYPE_ATTRIBUTE:
            switch (accessMask)
            {
            case ACTRL_DS_LIST:
            case ACTRL_DS_LIST_OBJECT:
            case ACTRL_DS_SELF:
                return S_OK;

            default:
                LoadFromResource (strType, IDS_PROPERTY);
                break;
            }
            break;

        case GUID_TYPE_CONTROL:
            switch (accessMask)
            {
            case ACTRL_DS_LIST:
            case ACTRL_DS_LIST_OBJECT:
            case ACTRL_DS_SELF:
            case ACTRL_DS_CREATE_CHILD:
            case ACTRL_DS_DELETE_CHILD:
            case ACTRL_DELETE:
            case ACTRL_CHANGE_ACCESS:
            case ACTRL_CHANGE_OWNER:
            case ACTRL_DS_CONTROL_ACCESS:
                return S_OK;

            case ACTRL_DS_READ_PROP:
            case ACTRL_DS_WRITE_PROP:
            case ACTRL_READ_CONTROL:
            default:
                LoadFromResource (strType, IDS_CONTROL);
                break;
            }
            break;

        case GUID_TYPE_UNKNOWN:
        default:
            return E_UNEXPECTED;
        }

        LoadFromResource (strPermission, strID);

        int id = 0;
        switch (ptype)
        {
        case P_ALLOW:
            if ( _Module.DoTabDelimitedOutput () )
                id = IDS_CAN_CDO;
            else
                id = IDS_CAN;
            break;

        case P_DENY:
            if ( _Module.DoTabDelimitedOutput () )
                id = IDS_CANNOT_CDO;
            else
                id = IDS_CANNOT_EF;
            break;

        default:
            return E_UNEXPECTED;
        }
        if ( _Module.DoTabDelimitedOutput () )
        {
            FormatMessage (str, id, 
                    strObjectDN.c_str (),
                    strPermission.c_str ());
        }
        else
        {
            FormatMessage (str, id, strPermission.c_str ());
        }

        wstring strProvenance;

        PrintGroupProvenance (accessMask, otl, ptype, strProvenance);
        str += strProvenance;

        PCResultObject pResultObject = new CResultObject (accessMask, str, 
                guidType, otl.Level);
        if ( pResultObject )
        {
            if ( pResultObject->IsValid () )
                resultList.push_back (pResultObject);
            else
                delete pResultObject;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


void PrintGroupProvenance (
        const ACCESS_MASK accessMask, 
        const IOBJECT_TYPE_LIST& otl,
        const P_TYPE ptype,
        wstring& strProvenance)
{
    UINT    nSid = 0;

    for (ULONG nBit = 0x1; nBit; nBit <<= 1, nSid++)
    {
        if ( accessMask & nBit )
        {
            wstring strGroup;
            PSID            psid = 0;
            SID_NAME_USE    sne = SidTypeUnknown;

            if ( P_ALLOW == ptype )
                psid = otl.grantingSid[nSid];
            else
                psid = otl.denyingSid[nSid];
            
            if ( IsValidSid (psid) )
            {
                GetNameFromSid (psid, strGroup, 0, sne);
                if ( SidTypeGroup == sne )
                {
                    if ( _Module.DoTabDelimitedOutput () )
                        FormatMessage (strProvenance, IDS_EFFRIGHT_FROM_GROUP_CDO, strGroup.c_str ());
                    else
                        FormatMessage (strProvenance, IDS_EFFRIGHT_FROM_GROUP, strGroup.c_str ());
                }
            }
            break;
        }
    }
    strProvenance += L"\n";
}


void PrintEffectiveRightsHeader (ACCESS_MASK lastRight, USHORT level)
{
    wstring str;


    if ( 0 == level ) // Object level rights
    {
        return;
    }
    else
    {
        switch (lastRight)
        {
        case ACTRL_DS_LIST:
        case ACTRL_DELETE:
        case ACTRL_READ_CONTROL:
        case ACTRL_CHANGE_ACCESS:
        case ACTRL_CHANGE_OWNER:
            str = L"\n\n";
            break;
        
        case ACTRL_DS_CREATE_CHILD:
            LoadFromResource (str, IDS_CAN_CREATE_FOLLOWING_CHILD_OBJECTS);
            break;

        case ACTRL_DS_DELETE_CHILD:
            LoadFromResource (str, IDS_CAN_DELETE_FOLLOWING_CHILD_OBJECTS);
            break;

        case ACTRL_DS_READ_PROP:
            LoadFromResource (str, IDS_CAN_READ_FOLLOWING_PROPERTIES);
            break;

        case ACTRL_DS_WRITE_PROP:
            LoadFromResource (str, IDS_CAN_WRITE_FOLLOWING_PROPERTIES);
            break;

        case ACTRL_DS_CONTROL_ACCESS:
            LoadFromResource (str, IDS_CAN_DO_FOLLOWING_CONTROL_OPERATIONS);
            break;

        case ACTRL_DS_LIST_OBJECT:
        case ACTRL_DS_SELF:
        default:
            str = L"\n\n";
            break;;
        }
    }

    MyWprintf (str.c_str ());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\makefile.inc ===
!include ..\..\makefile.inc

$(O)\ACLDIAG.res: resource.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\schema.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       Schema.h
//
//  Contents:   DoSchemaDiagnosis and support methods
//              
//
//----------------------------------------------------------------------------
#ifndef __ACLDIAG_SCHEMA
#define __ACLDIAG_SCHEMA

HRESULT DoSchemaDiagnosis ();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\secdesc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2002.
//
//  File:       SecDesc.cpp
//
//  Contents:   DoSecurityDescription and support methods
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "ADUtils.h"
#include "SecDesc.h"



///////////////////////////////////////////////////////////////////////////////
//
//  Method:     DoSecurityDescription ()
//
//  Purpose:    Main routine for doing security description
//
//

HRESULT DoSecurityDescription ()
{
    _TRACE (1, L"Entering  DoSecurityDescription\n");
    HRESULT hr = S_OK;

    wstring    str;

    // Print header
    if ( _Module.DoTabDelimitedOutput () )
    {
        MyWprintf (_Module.GetObjectDN ().c_str ());
        MyWprintf (L"\n");
    }
    else
    {
        FormatMessage (str, IDS_SECURITY_DIAGNOSIS_FOR, _Module.GetObjectDN ().c_str ());
        MyWprintf (str.c_str ());

        if ( !_Module.SkipDescription () )
        {
            LoadFromResource (str, IDS_DESCRIPTION);
            str += L"\n";
            MyWprintf (str.c_str ());
        }
    }

    hr = GetSecurityDescriptor (_Module.GetObjectDN (), &_Module.m_pSecurityDescriptor);
    if ( SUCCEEDED (hr) )
    {
        if ( _Module.m_pSecurityDescriptor )
        {
            hr = DisplayOwner ();
            if ( SUCCEEDED (hr) )
            {
                SECURITY_DESCRIPTOR_CONTROL control;
                DWORD                       dwRevision = 0;

                if ( GetSecurityDescriptorControl (
                        _Module.m_pSecurityDescriptor,
                        &control,
                        &dwRevision) )
                {
                    if ( _Module.DoTabDelimitedOutput () )
                    {
                        MyWprintf (L"\n");
                        if ( control & SE_DACL_PROTECTED )
                            LoadFromResource (str, IDS_PERMISSIONS_PROTECTED);
                        else
                            LoadFromResource (str, IDS_PERMISSIONS_NOT_PROTECTED);

                        MyWprintf (str.c_str ());

                        if ( control & SE_SACL_PROTECTED )
                            LoadFromResource (str, IDS_AUDITING_PROTECTED);
                        else
                            LoadFromResource (str, IDS_AUDITING_NOT_PROTECTED);
                        MyWprintf (str.c_str ());
                    }
                    else
                    {
                        if ( control & SE_DACL_PROTECTED )
                        {
                            LoadFromResource (str, IDS_CONFIG_NO_INHERIT);
                            MyWprintf (str.c_str ());
                        }
                    }

                }
                else
                {
                    _TRACE (0, L"GetSecurityDescriptorControl () failed: 0x%x\n", GetLastError ());
                }

                hr = EnumerateDacl (_Module.m_pSecurityDescriptor, _Module.m_DACLList, true);
                if ( SUCCEEDED (hr) )
                {
                    hr = EnumerateSacl (_Module.m_pSecurityDescriptor, _Module.m_SACLList);
                    if ( SUCCEEDED (hr) && !_Module.SkipDescription () )
                    {
                        hr = PrintEffectivePermissions ();
                        if ( SUCCEEDED (hr) )
                        {
                            hr = PrintInheritedPermissions ();
                            if ( SUCCEEDED (hr) )
                            {
                                hr = PrintAuditingInformation ();
                            }
                        }
                    }
                }
            }
        }
        else
        {
            hr = E_ACCESSDENIED;
            wstring str;
            FormatMessage (str, IDS_UNABLE_TO_READ_SECURITY_DESCRIPTOR, _Module.GetObjectDN ().c_str ());
            MyWprintf (str.c_str ());
        }
    }

    _TRACE (-1, L"Leaving DoSecurityDescription: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     GetSecurityDescriptor ()
//
//  Purpose:    Get ths security descriptor for the indicated object
//
//  Inputs:     strObjectDN - the object show security descriptor we wish to 
//              retrieve
//
//  Outputs:    ppAttrs - returns the security descriptor raw data - this holds the data
//              persistent in memory
//
//              ppSecurityDescriptor - returns the security descriptor
//
HRESULT GetSecurityDescriptor (
        wstring strObjectDN,        // pass by value
        PSECURITY_DESCRIPTOR* ppSecurityDescriptor)
{
    _TRACE (1, L"Entering  GetSecurityDescriptor\n");
    HRESULT hr = S_OK;

    if ( ppSecurityDescriptor )
    {
        CComPtr<IADsPathname> spPathname;
        //
        // Constructing the directory paths
        //
        hr = CoCreateInstance(
                    CLSID_Pathname,
                    NULL,
                    CLSCTX_ALL,
                    IID_PPV_ARG (IADsPathname, &spPathname));
        if ( SUCCEEDED (hr) )
        {
            ASSERT (!!spPathname);
            LPCWSTR     pszLDAP = L"LDAP://";

            // If object name is preceded with LDAP, set the whole name at once.
            if ( !wcsncmp (strObjectDN.c_str (), pszLDAP, wcslen (pszLDAP)) )
            {
                hr = spPathname->Set (CComBSTR (strObjectDN.c_str ()),
                        ADS_SETTYPE_FULL);
                if ( FAILED (hr) )
                {
                    _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                            strObjectDN.c_str (), hr);
                }
            }
            else
            {
                hr = spPathname->Set (CComBSTR (ACLDIAG_LDAP),
                        ADS_SETTYPE_PROVIDER);
                if ( SUCCEEDED (hr) )
                {
                    hr = spPathname->Set (CComBSTR (strObjectDN.c_str ()), 
                            ADS_SETTYPE_DN);
                    if ( FAILED (hr) )
                    {
                        _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                                strObjectDN.c_str (), hr);
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
                }
            }

            if ( SUCCEEDED (hr) )
            {
                BSTR bstrFullPath = 0;
                hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
                if ( SUCCEEDED (hr) )
                {
                    CComPtr<IDirectoryObject> spDirObj;


                    hr = ADsOpenObjectHelper (bstrFullPath,
                                              IID_IDirectoryObject, 
                                              0,
                                              (void**)&spDirObj);
                    if ( SUCCEEDED (hr) )
                    {
                        hr = SetSecurityInfoMask (spDirObj, 
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION |
                                SACL_SECURITY_INFORMATION);

                        //
                        // Get this object's Security Descriptor.
                        //
                        const PWSTR     wzSecDescriptor = L"nTSecurityDescriptor";
                        PADS_ATTR_INFO  pAttrs = 0;
                        DWORD           cAttrs = 0;
                        LPWSTR          rgpwzAttrNames[] = {wzSecDescriptor};

                        hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
                        if ( SUCCEEDED (hr) )
                        {
                            if ( 0 == cAttrs )
                            {
                                // remove SACL_SECURITY_INFORMATION
                                hr = SetSecurityInfoMask (spDirObj, 
                                        OWNER_SECURITY_INFORMATION |
                                        GROUP_SECURITY_INFORMATION |
                                        DACL_SECURITY_INFORMATION);
                                hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);
                            }

                            if ( SUCCEEDED (hr) && 1 == cAttrs && pAttrs && pAttrs->pADsValues )
                            {
                                if (!(pAttrs->pADsValues->SecurityDescriptor.lpValue) ||
                                    !(pAttrs->pADsValues->SecurityDescriptor.dwLength))
                                {
                                    _TRACE (0, L"IADS return bogus SD!\n");
                                    hr =  E_UNEXPECTED;
                                }
                                else if (!IsValidSecurityDescriptor(pAttrs->pADsValues->SecurityDescriptor.lpValue))
                                {
                                    _TRACE (0, L"IsValidSecurityDescriptor failed!\n");
                                    hr = HRESULT_FROM_WIN32(GetLastError());
                                }
                                else
                                {
                                    *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR) 
                                            ::LocalAlloc (LMEM_ZEROINIT, pAttrs->pADsValues->SecurityDescriptor.dwLength);
                                    if ( *ppSecurityDescriptor )
                                    {
                                        memcpy (*ppSecurityDescriptor, 
                                                pAttrs->pADsValues->SecurityDescriptor.lpValue,
                                                pAttrs->pADsValues->SecurityDescriptor.dwLength);
                                    }
                                    else
                                        hr = E_OUTOFMEMORY;
                                }
                                FreeADsMem (pAttrs);
                            }
                            else
                            {
                                if ( !wcscmp (strObjectDN.c_str (), _Module.GetObjectDN ().c_str ()) )
                                {
                                    wstring str;

                                    FormatMessage (str, IDS_NO_SECDESC_RETURNED, strObjectDN.c_str ());
                                    MyWprintf (str.c_str ());
                                }
                            }
                        }
                        else
                        {
                            if ( !wcscmp (strObjectDN.c_str (), _Module.GetObjectDN ().c_str ()) )
                            {
                                wstring str;

                                FormatMessage (str, IDS_NO_SECDESC_RETURNED_WITH_CODE, 
                                        strObjectDN.c_str (), GetSystemMessage (hr).c_str ());
                                MyWprintf (str.c_str ());
                            }
                            _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                        }
                    }
                    else
                    {
                        if ( ERROR_DS_REFERRAL == HRESULT_CODE (hr) )
                            hr = S_FALSE;
                        else
                        {
                            _TRACE (0, L"ADsOpenObjectHelper (%s): 0x%x\n", bstrFullPath, hr);
                            wstring    strErr;
                   

                            FormatMessage (strErr, IDS_INVALID_OBJECT, 
                                    _Module.GetObjectDN ().c_str (), 
                                    GetSystemMessage (hr).c_str ());
                            MyWprintf (strErr.c_str ());
                        }
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
                }
            }
        }
        else
        {
            _TRACE (0, L"CoCreateInstance(CLSID_Pathname): 0x%x\n", hr);
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving GetSecurityDescriptor: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     DisplayOwner ()
//
//  Purpose:    Display the owner of this object
//
HRESULT DisplayOwner ()
{
    _TRACE (1, L"Entering  DisplayOwner\n");
    HRESULT hr = S_OK;
    PSID    pSidOwner = 0;
    BOOL    bOwnerDefaulted = FALSE;
    if ( ::GetSecurityDescriptorOwner(
            _Module.m_pSecurityDescriptor,
            &pSidOwner,
            &bOwnerDefaulted) )
    {
        wstring         strPrincipalName;
        wstring         strFQDN;
        SID_NAME_USE    sne = SidTypeUnknown;
            
        hr = GetNameFromSid (pSidOwner, strPrincipalName, &strFQDN, sne);
        if ( SUCCEEDED (hr) && !_Module.SkipDescription () )
        {
            wstring    str;

            if ( _Module.DoTabDelimitedOutput () )
                FormatMessage (str, IDS_OWNER_CDO, strPrincipalName.c_str ());
            else
                FormatMessage (str, IDS_OWNER, strPrincipalName.c_str ());
            MyWprintf (str.c_str ());
        }
        PSID_FQDN* pItem = new PSID_FQDN (pSidOwner, strFQDN, strPrincipalName, sne);
        if ( pItem )
            _Module.m_PSIDList.push_back (pItem);
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"GetSecurityDescriptorOwner () failed: 0x%x\n", 
                dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (-1, L"Leaving DisplayOwner: 0x%x\n", hr);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     EnumerateDacl ()
//
//  Purpose:    Enumerate the DACL and store it in a list
//
//  Inputs:     pSecurityDescriptor - where to get the DACL
//
//  Outputs:    DACLList - return the ACEs in this list
//
HRESULT EnumerateDacl (PSECURITY_DESCRIPTOR pSecurityDescriptor, ACE_SAMNAME_LIST& DACLList, bool bListSids)
{
    _TRACE (1, L"Entering  EnumerateDacl\n");
    HRESULT hr = S_OK;
    ASSERT (pSecurityDescriptor);
    if ( !pSecurityDescriptor )
        return E_POINTER;


    PACL    pDacl = 0;
    BOOL    bDaclPresent = FALSE;
    BOOL    bDaclDefaulted = FALSE;
    _TRACE (0, L"Calling GetSecurityDescriptorDacl ()\n");
    if ( GetSecurityDescriptorDacl (pSecurityDescriptor,
            &bDaclPresent, &pDacl, &bDaclDefaulted) )
    {
        _TRACE (0, L"Call to GetSecurityDescriptorDacl () succeeded.\n");
        if ( bDaclPresent )
        {
            PACCESS_ALLOWED_ACE         pAllowedAce;
            PSID_FQDN_LIST::iterator    itrPSID = _Module.m_PSIDList.begin ();
            ACE_SAMNAME*                pAceSAMName = 0;
            PSID_FQDN*                  pPsidFQDN = 0;
            SID_NAME_USE                sne = SidTypeUnknown;

            // copy the ACES
            for (int i = 0; i < pDacl->AceCount; i++)
            {
                if ( GetAce (pDacl, i, (void **)&pAllowedAce) )
                {
                    PSID AceSid = 0;
                    if ( IsObjectAceType ( pAllowedAce ) ) 
                    {
                        AceSid = RtlObjectAceSid( pAllowedAce );
                    } 
                    else 
                    {
                        AceSid = &( ( PKNOWN_ACE )pAllowedAce )->SidStart;
                    }
                    ASSERT (IsValidSid (AceSid));

                    wstring strPrincipalName;
                    wstring strFQDN;
                    hr = GetNameFromSid (AceSid, strPrincipalName, 
                            bListSids ? &strFQDN : 0, sne);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( bListSids )
                        {
                            bool bFound = false;
                            for (PSID_FQDN_LIST::iterator itrPSIDFind = _Module.m_PSIDList.begin ();
                                    itrPSIDFind != _Module.m_PSIDList.end ();
                                    itrPSIDFind++)
                            {
                                pPsidFQDN = *itrPSIDFind;
                                if ( pPsidFQDN )
                                {
                                    if ( !wcscmp (pPsidFQDN->m_strFQDN.c_str (), strFQDN.c_str ()) )
                                    {
                                        bFound = true;
                                    }
                                }
                            }

                            if ( !bFound )
                            {
                                pPsidFQDN = new PSID_FQDN (AceSid, strFQDN, strPrincipalName, sne);
                                if ( pPsidFQDN )
                                {
                                    _Module.m_PSIDList.push_back (pPsidFQDN);
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                    break;
                                }
                            }
                        }
                        pAceSAMName = new ACE_SAMNAME;
                        if ( pAceSAMName )
                        {
                            pAceSAMName->m_AceType = pAllowedAce->Header.AceType;
                            switch (pAceSAMName->m_AceType)
                            {
                            case ACCESS_ALLOWED_ACE_TYPE:
                                pAceSAMName->m_pAllowedAce = pAllowedAce;
                                break;

                            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                                pAceSAMName->m_pAllowedObjectAce = 
                                        reinterpret_cast <PACCESS_ALLOWED_OBJECT_ACE> (pAllowedAce);
                                break;

                            case ACCESS_DENIED_ACE_TYPE:
                                pAceSAMName->m_pDeniedAce = 
                                        reinterpret_cast <PACCESS_DENIED_ACE> (pAllowedAce);
                                break;

                            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                                pAceSAMName->m_pDeniedObjectAce = 
                                        reinterpret_cast <PACCESS_DENIED_OBJECT_ACE> (pAllowedAce);
                                break;

                            default:
                                break;
                            }
                            pAceSAMName->m_SAMAccountName = strPrincipalName;
                            pAceSAMName->DebugOut ();
                            DACLList.push_back (pAceSAMName);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                    }
                }
                else
                {
                    _TRACE (0, L"GetAce failed: 0x%x\n", GetLastError ());
                    break;
                }
            }
        }
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"Call to GetSecurityDescriptorDacl () failed: 0x%x\n", dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (-1, L"Leaving EnumerateDacl: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     EnumerateSacl ()
//
//  Purpose:    Enumerate the SACL and store it in a list
//
//  Inputs:     pSecurityDescriptor - where to get the DACL
//
//  Outputs:    The results are store in the _Module.m_SACLList
//
HRESULT EnumerateSacl (PSECURITY_DESCRIPTOR pSecurityDescriptor, ACE_SAMNAME_LIST& SACLList)
{
    _TRACE (1, L"Entering  EnumerateSacl\n");
    HRESULT hr = S_OK;
    ASSERT (pSecurityDescriptor);
    if ( !pSecurityDescriptor )
        return E_POINTER;

    PACL    pSacl = 0;
    BOOL    bSaclPresent = FALSE;
    BOOL    bSaclDefaulted = FALSE;
    _TRACE (0, L"Calling GetSecurityDescriptorSacl ()\n");
    if ( GetSecurityDescriptorSacl (pSecurityDescriptor,
            &bSaclPresent, &pSacl, &bSaclDefaulted) )
    {
        _TRACE (0, L"Call to GetSecurityDescriptorSacl () succeeded.\n");
        if ( bSaclPresent && pSacl )
        {
            PACCESS_ALLOWED_ACE         pAllowedAce;
            wstring                     strPrincipalName;
            wstring                     strFQDN;
            ACE_SAMNAME*                pAceSAMName = 0;
            SID_NAME_USE                sne = SidTypeUnknown;

            // copy the ACES
            for (int i = 0; i < pSacl->AceCount; i++)
            {
                if ( GetAce (pSacl, i, (void **)&pAllowedAce) )
                {
                    PSID AceSid;
                    if ( IsObjectAceType ( pAllowedAce ) ) 
                    {
                        AceSid = RtlObjectAceSid( pAllowedAce );
                    } 
                    else 
                    {
                        AceSid = &( ( PKNOWN_ACE )pAllowedAce )->SidStart;
                    }
                    
                    hr = GetNameFromSid (AceSid, strPrincipalName, 0, sne);
                    if ( SUCCEEDED (hr) )
                    {
                        pAceSAMName = new ACE_SAMNAME;
                        if ( pAceSAMName )
                        {
                            pAceSAMName->m_AceType = pAllowedAce->Header.AceType;
                            switch (pAceSAMName->m_AceType)
                            {
                            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                                pAceSAMName->m_pSystemAuditObjectAce = 
                                        reinterpret_cast <PSYSTEM_AUDIT_OBJECT_ACE> (pAllowedAce);
                                break;

                            case SYSTEM_AUDIT_ACE_TYPE:
                                pAceSAMName->m_pSystemAuditAce = 
                                        reinterpret_cast <PSYSTEM_AUDIT_ACE> (pAllowedAce);
                                break;

                            default:
                                break;
                            }
                            pAceSAMName->m_SAMAccountName = strPrincipalName;
                            pAceSAMName->DebugOut ();
                            SACLList.push_back (pAceSAMName);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                    }
                }
                else
                {
                    _TRACE (0, L"GetAce failed: 0x%x\n", GetLastError ());
                    break;
                }
            }
        }
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"GetSecurityDescriptorSacl () failed: 0x%x\n", dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (-1, L"Leaving EnumerateSacl: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintEffectivePermissions ()
//
//  Purpose:    Print the permissions effective on the object
//
HRESULT PrintEffectivePermissions ()
{
    HRESULT                     hr = S_OK;
    ACE_SAMNAME_LIST::iterator    itr =  _Module.m_DACLList.begin ();
    wstring                    str;
    ACE_SAMNAME*                    pAceSAMName = 0;


    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_PERMISSIONS_EFFECTIVE);
        MyWprintf (str.c_str ());
    }

    for (itr = _Module.m_DACLList.begin(); itr != _Module.m_DACLList.end(); itr++)
    {
        pAceSAMName = *itr;
        if ( !(pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERIT_ONLY_ACE) )
        {
            switch (pAceSAMName->m_AceType)
            {    
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                hr = EnumeratePermissions (pAceSAMName, P_ALLOW, P_THIS_OBJECT, L"");
                break;

            case ACCESS_DENIED_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
                hr = EnumeratePermissions (pAceSAMName, P_DENY, P_THIS_OBJECT, L"");
                break;

            default:
                break;
            }
        }
    }


    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     EnumeratePermissions ()
//
//  Purpose:    Print all the permissions contained on the passed in ACE
//
//  Inputs:     pAceSAMName - structure containing the ACE whose permissions we wish
//              to print
//
//              ptype - allow, deny, succes, failure, success and failure
//
HRESULT EnumeratePermissions (ACE_SAMNAME*  pAceSAMName, P_TYPE ptype, P_WHO pWho, PCWSTR pwszClassName)
{
    HRESULT hr = S_OK;

    if ( pAceSAMName )
    {
        hr = PrintPermission (pAceSAMName,
                ACTRL_DS_CREATE_CHILD, 
                ptype,
                IDS_CREATE_ALL_SUBOBJECTS,
                IDS_CREATE_CLASS_OBJECTS,
                pWho,
                pwszClassName);
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_DELETE_CHILD,
                    ptype,
                    IDS_DELETE_ALL_SUBOBJECTS,
                    IDS_DELETE_CLASS_OBJECTS,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_READ_PROP,
                    ptype,
                    IDS_READ_ALL_PROPERTIES,
                    IDS_READ_PROPERTY_PROPERTY,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_WRITE_PROP,
                    ptype,
                    IDS_WRITE_ALL_PROPERTIES,
                    IDS_WRITE_PROPERTY_PROPERTY,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName, 
                    ACTRL_DS_LIST, 
                    ptype,
                    IDS_LIST_CONTENTS, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_LIST_OBJECT,
                    ptype,
                    IDS_LIST_OBJECT, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_CONTROL_ACCESS,
                    ptype,
                    IDS_ALL_CONTROL_ACCESSES,
                    IDS_CONTROL_ACCESS_DISPLAY_NAME,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DELETE,
                    ptype,
                    IDS_DELETE_THIS_OBJECT, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_READ_CONTROL,
                    ptype,
                    IDS_READ_PERMISSIONS, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_CHANGE_ACCESS,
                    ptype,
                    IDS_MODIFY_PERMISSIONS, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_CHANGE_OWNER,
                    ptype,
                    IDS_TAKE_CHANGE_OWNERSHIP, false,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_SELF,
                    ptype,
                    IDS_MODIFY_MEMBERSHIP, false,
                    pWho,
                    pwszClassName);
        }
    }
    else
        hr = E_POINTER;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintPermission ()
//
//  Purpose:    Print an OBJECT_ACE_TYPE permission
//
//  Inputs:     pAceSAMName - structure containing the ACE whose permission we wish
//              to print
//
//              accessMask - the specific permission we're looking to print
//
//              bAllow - whether the permission is allowed or denied
//
//              strIDAll - string to print if permission applies to all object 
//              classes
//
//              strIDParam - string print if permission applies to a specific
//              object class
//
HRESULT PrintPermission (ACE_SAMNAME*  pAceSAMName,
        ACCESS_MASK accessMask,
        P_TYPE  ptype,
        int strIDAll, 
        int strIDParam, 
        P_WHO pWho, 
        PCWSTR pwszClassName)
{
    HRESULT hr = S_OK;

    if ( pAceSAMName )
    {
        wstring str;
        wstring strPermission;


        if ( pAceSAMName->m_pAllowedAce->Mask & accessMask )
        {
            bool    bIsAudit = false;

            switch (pAceSAMName->m_AceType )
            {
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                if ( (pAceSAMName->m_pAllowedObjectAce->Flags & ACE_OBJECT_TYPE_PRESENT) && 
                        !::IsEqualGUID (pAceSAMName->m_pAllowedObjectAce->ObjectType, NULLGUID) )
                {
                    wstring strClass;

                    if ( ACTRL_DS_CONTROL_ACCESS == accessMask )
                    {
                        hr = GetControlDisplayName (
                                pAceSAMName->m_pAllowedObjectAce->ObjectType, strClass);
                    }
                    else
                    {
                        _Module.GetClassFromGUID (
                                pAceSAMName->m_pAllowedObjectAce->ObjectType,
                                strClass);
                    }

                    FormatMessage (strPermission, strIDParam, 
                            strClass.c_str ());
                }
                else
                {
                    LoadFromResource (strPermission, strIDAll);
                }
                break;

            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                if ( (pAceSAMName->m_pDeniedObjectAce->Flags & ACE_OBJECT_TYPE_PRESENT) && 
                        !::IsEqualGUID (pAceSAMName->m_pDeniedObjectAce->ObjectType, NULLGUID) )
                {
                    wstring strClass;


                    if ( ACTRL_DS_CONTROL_ACCESS == accessMask )
                    {
                        hr = GetControlDisplayName (
                                pAceSAMName->m_pDeniedObjectAce->ObjectType, strClass);
                    }
                    else
                    {
                        _Module.GetClassFromGUID (
                                pAceSAMName->m_pDeniedObjectAce->ObjectType,
                                strClass);
                    }
                    FormatMessage (strPermission,strIDParam, 
                            strClass.c_str ());
                }
                else
                {
                    LoadFromResource (strPermission, strIDAll);
                }
                break;

            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                if ( (pAceSAMName->m_pSystemAuditObjectAce->Flags & ACE_OBJECT_TYPE_PRESENT) && 
                        !::IsEqualGUID (pAceSAMName->m_pSystemAuditObjectAce->ObjectType, NULLGUID) )
                {
                    wstring strClass;


                    if ( ACTRL_DS_CONTROL_ACCESS == accessMask )
                    {
                        hr = GetControlDisplayName (
                                pAceSAMName->m_pSystemAuditObjectAce->ObjectType, strClass);
                    }
                    else
                    {
                        _Module.GetClassFromGUID (
                                pAceSAMName->m_pSystemAuditObjectAce->ObjectType,
                                strClass);
                    }

                    FormatMessage (strPermission,strIDParam, 
                            strClass.c_str ());
                }
                else
                {
                    LoadFromResource (strPermission, strIDAll);
                }
                bIsAudit = true;
                break;

            case SYSTEM_AUDIT_ACE_TYPE:
                bIsAudit = true;
                // fall through

            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            default:
                LoadFromResource (strPermission, strIDAll);
                break;
            }
            int strid = 0;

            switch (ptype)
            {
            case P_ALLOW:
                if ( _Module.DoTabDelimitedOutput () )
                    strid = IDS_ALLOW_CDO;
                else
                    strid = IDS_ALLOW;
                break;

            case P_DENY:
                if ( _Module.DoTabDelimitedOutput () )
                    strid = IDS_DENY_CDO;
                else
                    strid = IDS_DENY;
                break;

            case P_SUCCESS:
                if ( _Module.DoTabDelimitedOutput () )
                    strid = IDS_SUCCESS_CDO;
                else
                    strid = IDS_SUCCESS;
                break;

            case P_FAILURE:
                if ( _Module.DoTabDelimitedOutput () )
                    strid = IDS_FAILURE_CDO;
                else
                    strid = IDS_FAILURE;
                break;

            case P_SUCCESS_AND_FAILURE:
                if ( _Module.DoTabDelimitedOutput () )
                    strid = IDS_SUCCESS_AND_FAILURE_CDO;
                else
                    strid = IDS_SUCCESS_AND_FAILURE;
                break;

            default:
                return E_UNEXPECTED;
            }
            if ( _Module.DoTabDelimitedOutput () )
            {
                wstring     strObject;


                switch ( pWho )
                {
                case P_THIS_OBJECT:
                    LoadFromResource (strObject, IDS_THIS_OBJECT);
                    break;

                case P_ALL_OBJECTS:
                    LoadFromResource (strObject, IDS_ALL_SUBOBJECTS);
                    break;

                case P_CLASS_OBJECT:
                    FormatMessage (strObject, IDS_CLASS_OBJECT, pwszClassName);
                    break;
                }

                FormatMessage (str, strid, 
                        strObject.c_str (),
                        pAceSAMName->m_SAMAccountName.c_str (),
                        strPermission.c_str ());
            }
            else
            {
                FormatMessage (str, strid, 
                        pAceSAMName->m_SAMAccountName.c_str (),
                        strPermission.c_str ());
            }
            MyWprintf (str.c_str ());
            if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERITED_ACE && 
                    (P_ALLOW == ptype || P_DENY == ptype) )
            {
                hr = PrintInheritedPermissionFromDN (pAceSAMName, accessMask, bIsAudit);
            }
            if ( _Module.DoTabDelimitedOutput () )
                MyWprintf (L"\n");
        }
    }
    else
        hr = E_POINTER;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintPermission ()
//
//  Purpose:    Print a non-OBJECT_ACE_TYPE permission
//
//  Inputs:     pAceSAMName - structure containing the ACE whose permission we wish
//              to print
//
//              accessMask - the specific permission we're looking to print
//
//              bAllow - whether the permission is allowed or denied
//
//              strID - string to print
//
HRESULT PrintPermission (ACE_SAMNAME*  pAceSAMName,
        ACCESS_MASK accessMask,
        P_TYPE  ptype,
        int strID,
        bool bIsAudit,
        P_WHO pWho, 
        PCWSTR pwszClassName)
{
    HRESULT     hr = S_OK;
    if ( pAceSAMName )
    {
        wstring    str;
        wstring    strPermission;


        if ( pAceSAMName->m_pAllowedAce->Mask & accessMask )
        {
            LoadFromResource (strPermission, strID);

            int id = 0;
            switch (ptype)
            {
            case P_ALLOW:
                if ( _Module.DoTabDelimitedOutput () )
                    id = IDS_ALLOW_CDO;
                else
                    id = IDS_ALLOW;
                break;

            case P_DENY:
                if ( _Module.DoTabDelimitedOutput () )
                    id = IDS_DENY_CDO;
                else
                    id = IDS_DENY;
                break;

            case P_SUCCESS:
                if ( _Module.DoTabDelimitedOutput () )
                    id = IDS_SUCCESS_CDO;
                else
                    id = IDS_SUCCESS;
                break;

            case P_FAILURE:
                if ( _Module.DoTabDelimitedOutput () )
                    id = IDS_FAILURE_CDO;
                else
                    id = IDS_FAILURE;
                break;

            case P_SUCCESS_AND_FAILURE:
                if ( _Module.DoTabDelimitedOutput () )
                    id = IDS_SUCCESS_AND_FAILURE_CDO;
                else
                    id = IDS_SUCCESS_AND_FAILURE;
                break;

            default:
                return E_UNEXPECTED;
            }
            if ( _Module.DoTabDelimitedOutput () )
            {
                wstring     strObject;


                switch ( pWho )
                {
                case P_THIS_OBJECT:
                    LoadFromResource (strObject, IDS_THIS_OBJECT);
                    break;

                case P_ALL_OBJECTS:
                    LoadFromResource (strObject, IDS_ALL_SUBOBJECTS);
                    break;

                case P_CLASS_OBJECT:
                    FormatMessage (strObject, IDS_CLASS_OBJECT, pwszClassName);
                    break;
                }

                FormatMessage (str, id, 
                        strObject.c_str (),
                        pAceSAMName->m_SAMAccountName.c_str (),
                        strPermission.c_str ());
            }
            else
            {
                FormatMessage (str, id, 
                        pAceSAMName->m_SAMAccountName.c_str (),
                        strPermission.c_str ());
            }

            MyWprintf (str.c_str ());
            if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERITED_ACE )
            {
                hr = PrintInheritedPermissionFromDN (pAceSAMName, accessMask, bIsAudit);
            }
            if ( _Module.DoTabDelimitedOutput () )
                MyWprintf (L"\n");
        }
    }
    else
        hr = E_POINTER;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// GetParentObjectDNWithSameACE ()
//
// This function is called recursively to try to find an ACE that matches the ACE
// contained in pAceSAMName somewhere in the parent container of the object pointed to
// by pPathName.  Each iteration strips a leaf element off pPathName, gets its
// security descriptor and searches the Dacl list for the ACE.  If a match is 
// found, taking into account the INHERITED_ACE flag, we look to see if the 
// INHERITED_ACE flag is set.  If so, we call GetParentObjectDNWithSameACE () again.
// If not, we get the return the object name at this level.
// 
HRESULT GetParentObjectDNWithSameACE (
        IN ACE_SAMNAME*  pAceSAMName, 
        IN IADsPathname* pPathName,
        IN ACCESS_MASK accessMask,
        OUT wstring& strParentDN,
        bool bIsAudit)
{
    _TRACE (1, L"Entering  GetParentObjectDNWithSameACE\n");
    HRESULT hr = pPathName->RemoveLeafElement ();
    if ( SUCCEEDED (hr) )
    {
        BSTR bstrFullPath = 0;
        hr = pPathName->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
        if ( SUCCEEDED (hr) )
        {
            if ( !wcscmp (bstrFullPath, L"LDAP://") )
                return S_FALSE;

            PSECURITY_DESCRIPTOR    pSecurityDescriptor = 0;  
            bool                    bFound = false;
                
            // Check to see if we already have this object's Security Descriptor
            list<SAMNAME_SD*>::iterator sdItr = _Module.m_listOfParentSDs.begin ();
            SAMNAME_SD*                 pCurrSAMNameSD = 0;
            for (; sdItr != _Module.m_listOfParentSDs.end (); sdItr++)
            {
                pCurrSAMNameSD = *sdItr;
                if ( !pCurrSAMNameSD->m_upn.compare (bstrFullPath) )
                {
                    pSecurityDescriptor = pCurrSAMNameSD->m_pSecurityDescriptor;
                    bFound = true; // Note - pSecurityDescriptor could be NULL
                                    // this is expected.
                    break;
                }
            }

            // If we don't already have the SD for this object, get it and cache it.
            if ( !bFound )
            {
                wstring objectDN (bstrFullPath);
                hr = GetSecurityDescriptor  (objectDN, &pSecurityDescriptor);
                if ( SUCCEEDED (hr) )
                {
                    pCurrSAMNameSD = new SAMNAME_SD (bstrFullPath, pSecurityDescriptor);
                    if ( pCurrSAMNameSD )
                    {
                        if ( pSecurityDescriptor )
                        {
                             hr = EnumerateDacl (pSecurityDescriptor, pCurrSAMNameSD->m_DACLList, false);
                             if ( SUCCEEDED (hr) )
                                 hr = EnumerateSacl (pSecurityDescriptor, pCurrSAMNameSD->m_SACLList);
                        }
                        _Module.m_listOfParentSDs.push_back (pCurrSAMNameSD);
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
            }

            if ( SUCCEEDED (hr) && pCurrSAMNameSD )
            {
                ACE_SAMNAME_LIST*    pList = 0;

                if ( bIsAudit )
                    pList = &pCurrSAMNameSD->m_SACLList;
                else
                    pList = &pCurrSAMNameSD->m_DACLList;

                ACE_SAMNAME_LIST::iterator    itr =  pList->begin ();
                ACE_SAMNAME*                    pCurrSAMName = 0;

                for (; itr != pList->end(); itr++)
                {
                    pCurrSAMName = *itr;
                    if ( pCurrSAMName->IsEquivalent (*pAceSAMName, 
                            accessMask) )
                    {
                        if ( pCurrSAMName->m_pAllowedAce->Header.AceFlags & INHERITED_ACE )
                        {
                            hr = GetParentObjectDNWithSameACE (
                                    pAceSAMName, 
                                    pPathName, 
                                    accessMask, 
                                    strParentDN,
                                    bIsAudit);
                        }
                        else
                        {
                            BSTR bstrDN = 0;
                            hr = pPathName->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
                            if ( SUCCEEDED (hr) )
                            {
                                strParentDN = bstrDN;
                            }
                            else
                            {
                                _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
                            }
                        }
                        break;
                    }
                }
            }
            SysFreeString (bstrFullPath);
        }
        else
        {
            _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
        }
    }

    if ( SUCCEEDED (hr) && S_FALSE != hr && !strParentDN.length () )
    {
        hr = GetParentObjectDNWithSameACE (pAceSAMName, pPathName, accessMask, 
                strParentDN, bIsAudit);
    }


    _TRACE (-1, L"Leaving GetParentObjectDNWithSameACE: 0x%x\n", hr);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintInheritedPermissionFromDN ()
//
//  Purpose:    Print a message indicating that a permission is inherited from 
//              another object plus that object's DN
//
//  Inputs:     pAceSAMName - structure containing the ACE whose permission we wish
//              to print
//
//              accessMask - the specific permission we're looking to print
//
HRESULT PrintInheritedPermissionFromDN (ACE_SAMNAME* pAceSAMName, ACCESS_MASK accessMask, bool bIsAudit)
{
    _TRACE (1, L"Entering  PrintInheritedPermissionFromDN\n");
    HRESULT hr = S_OK;


    if ( pAceSAMName )
    {
        CComPtr<IADsPathname> spPathname;
        //
        // Constructing the directory paths
        //
        hr = CoCreateInstance(
                    CLSID_Pathname,
                    NULL,
                    CLSCTX_ALL,
                    IID_IADsPathname,
                    (void**)&spPathname);
        if ( SUCCEEDED (hr) )
        {
            ASSERT (!!spPathname);
            hr = spPathname->Set (CComBSTR (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
            if ( SUCCEEDED (hr) )
            {            
                hr = spPathname->Set (CComBSTR (_Module.GetObjectDN ().c_str ()),
                        ADS_SETTYPE_DN);
                if ( SUCCEEDED (hr) )
                {
                    wstring    str;
                    wstring    strParentDN;

                    hr = GetParentObjectDNWithSameACE (pAceSAMName, 
                    spPathname, accessMask, strParentDN, bIsAudit);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( !strParentDN.length () )
                        {
                            if ( _Module.DoTabDelimitedOutput () )
                            {
                                LoadFromResource (str, 
                                        IDS_GENERATED_INHERITED_PERMISSION_CDO);
                            }
                            else
                            {
                                LoadFromResource (str, 
                                        IDS_GENERATED_INHERITED_PERMISSION);
                            }
                        }
                        else
                        {
                            if ( _Module.DoTabDelimitedOutput () )
                            {
                                FormatMessage (str, IDS_INHERITED_PERMISSION_CDO, 
                                        strParentDN.c_str ());
                            }
                            else
                            {
                                FormatMessage (str, IDS_INHERITED_PERMISSION, 
                                        strParentDN.c_str ());
                            }
                        }
                        MyWprintf (str.c_str ());
                    }
                }
            }
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving PrintInheritedPermissionFromDN: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintInheritedPermissions ()
//
//  Purpose:    Print permissions that are inherited by subobjects
//
HRESULT PrintInheritedPermissions ()
{
    _TRACE (1, L"Entering  PrintInheritedPermissions\n");
    HRESULT                     hr = S_OK;
    ACE_SAMNAME_LIST::iterator  aceItr =  _Module.m_DACLList.begin ();
    wstring                     str;
    ACE_SAMNAME*                pAceSAMName = 0;
    list<GUID*>                 guidList;
    

    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_PERMISSIONS_INHERITED_BY_SUBOBJECTS);
        MyWprintf (str.c_str ());

        LoadFromResource (str, IDS_INHERIT_TO_ALL_SUBOBJECTS);
        MyWprintf (str.c_str ());
    }

    // Second iteration: Each ACE which has CONTAINER_INHERIT is inherited to 
    // sub-objects.
    // Several "subiterations" are done to categorize inherit ACEs to the 
    // subobject type they apply.
    // First subiteration is for ACEs which are not object type or have 
    // InheritedObjectType = NULL.  These apply to "All Subobjects". We'll gather
    // the GUIDs of the InheritedObjectType's which are not NULL at this point to
    // use in the subsequent iterations.
    // Subsequent subiterations are for each unique InheritedObjectType 
    // present in the DACL.
    for (aceItr = _Module.m_DACLList.begin(); aceItr != _Module.m_DACLList.end(); aceItr++)
    {
        pAceSAMName = *aceItr;
        if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & CONTAINER_INHERIT_ACE )
        {
            switch (pAceSAMName->m_AceType)
            {    
            case ACCESS_ALLOWED_ACE_TYPE:
                hr = EnumeratePermissions (pAceSAMName, P_ALLOW, P_ALL_OBJECTS, L"");
                break;

            case ACCESS_DENIED_ACE_TYPE:
                hr = EnumeratePermissions (pAceSAMName, P_DENY, P_ALL_OBJECTS, L"");
                break;

            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                if ( !(pAceSAMName->m_pDeniedObjectAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) && 
                        ::IsEqualGUID (pAceSAMName->m_pDeniedObjectAce->ObjectType, NULLGUID) )
                {
                    hr = EnumeratePermissions (pAceSAMName, P_DENY, P_ALL_OBJECTS, L"");
                }
                else
                {
                    AddToInheritedObjectTypeGUIDList (guidList, 
                            &(pAceSAMName->m_pDeniedObjectAce->ObjectType));
                }
                break;

            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                if ( !(pAceSAMName->m_pAllowedObjectAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) && 
                        ::IsEqualGUID (pAceSAMName->m_pAllowedObjectAce->ObjectType, NULLGUID) )
                {
                    hr = EnumeratePermissions (pAceSAMName, P_ALLOW, P_ALL_OBJECTS, L"");
                }
                else
                {
                    AddToInheritedObjectTypeGUIDList (guidList, 
                            &(pAceSAMName->m_pAllowedObjectAce->ObjectType));
                }
                break;

            default:
                break;
            }
        }
    }

    
    GUID*       pGuid = 0;
    wstring     strClassName;
    GUID_TYPE   guidType;

    for (list<GUID*>::iterator guidItr =  guidList.begin ();
            guidItr != guidList.end ();
            guidItr++)
    {
        pGuid = *guidItr;
        hr = _Module.GetClassFromGUID (*pGuid, strClassName, &guidType);
        if ( SUCCEEDED (hr) && GUID_TYPE_CLASS == guidType )
        {
            if ( !_Module.DoTabDelimitedOutput () )
            {
                FormatMessage (str, IDS_INHERIT_TO_X_OBJECTS_ONLY, strClassName.c_str ());
                MyWprintf (str.c_str ());
            }

            for (aceItr = _Module.m_DACLList.begin(); aceItr != _Module.m_DACLList.end(); aceItr++)
            {
                pAceSAMName = *aceItr;
                if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & CONTAINER_INHERIT_ACE )
                {
                    switch (pAceSAMName->m_AceType)
                    {    
                    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                        if ( ::IsEqualGUID (pAceSAMName->m_pAllowedObjectAce->ObjectType, 
                                *pGuid) )
                        {
                            hr = EnumeratePermissions (pAceSAMName, P_ALLOW, 
                                    P_CLASS_OBJECT, strClassName.c_str ());
                        }
                        break;

                    case ACCESS_DENIED_OBJECT_ACE_TYPE:
                        if ( ::IsEqualGUID (pAceSAMName->m_pDeniedObjectAce->ObjectType, 
                                *pGuid) )
                        {
                            hr = EnumeratePermissions (pAceSAMName, P_DENY, 
                                    P_CLASS_OBJECT, strClassName.c_str ());
                        }
                        break;

                    default:
                        break;
                    }
                }
            }
        }
    }


    _TRACE (1, L"Entering  PrintInheritedPermissions: 0x%x\n", hr);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     AddToInheritedObjectTypeGUIDList ()
//
//  Purpose:    Add a GUID to a list.  Ensure that it is unique.
//
//  Inputs:     guidList - list to which the GUID should be added
//
//              pGuid - GUID to add to the list
//
void AddToInheritedObjectTypeGUIDList (list<GUID*>& guidList, GUID* pGuid)
{
    // The guidList should only contain unique GUIDs.  Verify that the one we
    // wish to add is not already in the list.
    if ( pGuid )
    {
        bool                    bFound = false;
        GUID*                   pCurrGuid = 0;
        list<GUID*>::iterator   guidItr = guidList.begin();

        for (; guidItr != guidList.end(); guidItr++)
        {
            pCurrGuid = *guidItr;
            if ( ::IsEqualGUID (*pCurrGuid, *pGuid) )
            {
                bFound = true;
                break;
            }
        }
        if ( !bFound )
        {
            guidList.push_back (pGuid);
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintAuditingInformation ()
//
//  Purpose:    Print auditing information from the SACL
//
HRESULT PrintAuditingInformation ()
{
    _TRACE (1, L"Entering  PrintAuditingInformation\n");
    HRESULT     hr = S_OK;
    wstring    str;

    MyWprintf (L"\n\n");

    SECURITY_DESCRIPTOR_CONTROL control;
    DWORD                       dwRevision = 0;
    if ( GetSecurityDescriptorControl (
            _Module.m_pSecurityDescriptor,
            &control,
            &dwRevision) )
    {
        if ( !_Module.DoTabDelimitedOutput () && (control & SE_SACL_PROTECTED) )
        {
            wstring    str;

            LoadFromResource (str, IDS_CONFIG_NO_INHERIT);
            MyWprintf (str.c_str ());
        }
    }
    else
    {
        _TRACE (0, L"GetSecurityDescriptorControl () failed: 0x%x\n", GetLastError ());
    }

    hr = PrintEffectiveAuditing ();
    if ( SUCCEEDED (hr) )
        hr = PrintInheritedAuditing ();

    _TRACE (-1, L"Leaving PrintAuditingInformation: 0x%x\n", hr);
    return hr;
}

HRESULT PrintEffectiveAuditing ()
{
    _TRACE (1, L"Entering  PrintEffectiveAuditing\n");
    HRESULT                     hr = S_OK;
    ACE_SAMNAME_LIST::iterator    itr =  _Module.m_SACLList.begin ();
    wstring                    str;
    ACE_SAMNAME*                    pAceSAMName = 0;


    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_AUDITING_EFFECTIVE_ON_THIS_OBJECT);
        MyWprintf (str.c_str ());
    }

    for (itr = _Module.m_SACLList.begin(); itr != _Module.m_SACLList.end(); itr++)
    {
        pAceSAMName = *itr;
        if ( !(pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERIT_ONLY_ACE) )
        {
            switch (pAceSAMName->m_AceType)
            {    
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
                hr = EnumerateAudits (pAceSAMName, P_THIS_OBJECT, L"");
                break;

            default:
                break;
            }
        }
    }

    _TRACE (-1, L"Leaving PrintEffectiveAuditing: 0x%x\n", hr);
    return hr;
}


HRESULT EnumerateAudits (ACE_SAMNAME* pAceSAMName, P_WHO pWho, PCWSTR pwszClassName)
{
    _TRACE (1, L"Entering  EnumerateAudits\n");
    HRESULT hr = S_OK;
    P_TYPE  ptype = P_UNASSIGNED;
    BYTE    byBoth = SUCCESSFUL_ACCESS_ACE_FLAG | FAILED_ACCESS_ACE_FLAG;

    if ( (pAceSAMName->m_pAllowedAce->Header.AceFlags & byBoth) == byBoth )
    {
        ptype = P_SUCCESS_AND_FAILURE;
    }
    else if (  pAceSAMName->m_pAllowedAce->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG )
        ptype = P_SUCCESS;
    else if (  pAceSAMName->m_pAllowedAce->Header.AceFlags & FAILED_ACCESS_ACE_FLAG )
        ptype = P_FAILURE;
    else
        return E_UNEXPECTED;

    if ( pAceSAMName )
    {
        hr = PrintPermission (pAceSAMName,
                ACTRL_DS_CREATE_CHILD,
                ptype,
                IDS_CREATE_ALL_SUBOBJECTS,
                IDS_CREATE_CLASS_OBJECTS,
                pWho,
                pwszClassName);
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_DELETE_CHILD,
                    ptype,
                    IDS_DELETE_ALL_SUBOBJECTS,
                    IDS_DELETE_CLASS_OBJECTS,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_READ_PROP,
                    ptype,
                    IDS_READ_ALL_PROPERTIES,
                    IDS_READ_PROPERTY_PROPERTY,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_WRITE_PROP,
                    ptype,
                    IDS_WRITE_ALL_PROPERTIES,
                    IDS_WRITE_PROPERTY_PROPERTY,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName, 
                    ACTRL_DS_LIST, 
                    ptype,
                    IDS_LIST_CONTENTS, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_LIST_OBJECT,
                    ptype,
                    IDS_LIST_OBJECT, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            if ( pAceSAMName->m_pAllowedAce->Mask & ACTRL_DS_CONTROL_ACCESS )
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_CONTROL_ACCESS,
                    ptype,
                    IDS_ALL_CONTROL_ACCESSES,
                    IDS_CONTROL_ACCESS_DISPLAY_NAME,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DELETE,
                    ptype,
                    IDS_DELETE_THIS_OBJECT, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_READ_CONTROL,
                    ptype,
                    IDS_READ_PERMISSIONS, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_CHANGE_ACCESS,
                    ptype,
                    IDS_MODIFY_PERMISSIONS, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_CHANGE_OWNER,
                    ptype,
                    IDS_TAKE_CHANGE_OWNERSHIP, true,
                    pWho,
                    pwszClassName);
        }
        if ( SUCCEEDED (hr) )
        {
            hr = PrintPermission (pAceSAMName,
                    ACTRL_DS_SELF,
                    ptype,
                    IDS_MODIFY_MEMBERSHIP, true,
                    pWho,
                    pwszClassName);
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving EnumerateAudits: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     PrintInheritedAuditing ()
//
//  Purpose:    Print audits that are inherited to subobjects
//
HRESULT PrintInheritedAuditing ()
{
    _TRACE (1, L"Entering  PrintInheritedAuditing\n");
    HRESULT hr = S_OK;
    ACE_SAMNAME_LIST::iterator    aceItr =  _Module.m_SACLList.begin ();
    wstring                    str;
    ACE_SAMNAME*                    pAceSAMName = 0;
    list<GUID*>                 guidList;
    

    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_AUDITING_INHERITED_TO_SUBOBJECTS);
        MyWprintf (str.c_str ());

        LoadFromResource (str, IDS_INHERIT_TO_ALL_SUBOBJECTS);
        MyWprintf (str.c_str ());
    }

    // Second iteration: Each ACE which has CONTAINER_INHERIT is inherited to 
    // sub-objects.
    // Several "subiterations" are done to categorize inherit ACEs to the 
    // subobject type they apply.
    // First subiteration is for ACEs which are not object type or have 
    // InheritedObjectType = NULL.  These apply to "All Subobjects". We'll gather
    // the GUIDs of the InheritedObjectType's which are not NULL at this point to
    // use in the subsequent iterations.
    // Subsequent subiterations are for each unique InheritedObjectType 
    // present in the DACL.
    for (aceItr = _Module.m_SACLList.begin(); aceItr != _Module.m_SACLList.end(); aceItr++)
    {
        pAceSAMName = *aceItr;
        if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & CONTAINER_INHERIT_ACE )
        {
            switch (pAceSAMName->m_AceType)
            {    
            case SYSTEM_AUDIT_ACE_TYPE:
                hr = EnumerateAudits (pAceSAMName, P_ALL_OBJECTS, L"");
                break;

            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                if ( !(pAceSAMName->m_pSystemAuditObjectAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) && 
                        ::IsEqualGUID (pAceSAMName->m_pSystemAuditObjectAce->ObjectType, NULLGUID) )
                {
                    hr = EnumerateAudits (pAceSAMName, P_ALL_OBJECTS, L"");
                }
                else
                {
                    AddToInheritedObjectTypeGUIDList (guidList, 
                            &(pAceSAMName->m_pSystemAuditObjectAce->ObjectType));
                }
                break;

            default:
                break;
            }
        }
    }

    
    GUID*   pGuid = 0;
    wstring strClassName;


    for (list<GUID*>::iterator guidItr =  guidList.begin ();
            guidItr != guidList.end ();
            guidItr++)
    {
        pGuid = *guidItr;
        hr = _Module.GetClassFromGUID (*pGuid, strClassName);
        if ( SUCCEEDED (hr) )
        {
            if ( !_Module.DoTabDelimitedOutput () )
            {
                FormatMessage (str, IDS_INHERIT_TO_X_OBJECTS_ONLY, strClassName.c_str ());
                MyWprintf (str.c_str ());
            }

            for (aceItr = _Module.m_SACLList.begin(); aceItr != _Module.m_SACLList.end(); aceItr++)
            {
                pAceSAMName = *aceItr;
                if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & CONTAINER_INHERIT_ACE )
                {
                    switch (pAceSAMName->m_AceType)
                    {    
                    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                        if ( ::IsEqualGUID (pAceSAMName->m_pSystemAuditObjectAce->ObjectType, 
                                *pGuid) )
                        {
                            hr = EnumerateAudits (pAceSAMName, P_CLASS_OBJECT, strClassName.c_str ());
                        }
                        break;

                    case SYSTEM_AUDIT_ACE_TYPE:
                    default:
                        break;
                    }
                }
            }
        }
    }


    _TRACE (-1, L"Leaving PrintInheritedAuditing: 0x%x\n", hr);
    return hr;
}


HRESULT GetControlDisplayName (REFGUID guid, wstring& strDisplayName)
{
    HRESULT hr = S_OK;
    wstring strGUID;

    hr = wstringFromGUID (strGUID, guid);
    if ( SUCCEEDED (hr) )
    {
        // strip braces from GUID
        wstring strRightsGUID (strGUID.substr (1, strGUID.length () - 2));

        hr = GetControlDisplayName (strRightsGUID, strDisplayName);
    }
    else
        hr = E_INVALIDARG;

    return hr;
}


// TODO:  Optimize this by searching for all controls and putting them in an 
// array like the classes and attributes
HRESULT GetControlDisplayName (const wstring strGuid, wstring& strDisplayName)
{
    HRESULT hr = S_OK;

    CComPtr<IADsPathname> spPathname;
    //
    // Constructing the directory paths
    //
    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG (IADsPathname, &spPathname));
    if ( SUCCEEDED (hr) )
    {
        ASSERT (!!spPathname);
        hr = spPathname->Set(CComBSTR (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            //
            // Open the root DSE object
            //
            hr = spPathname->AddLeafElement(CComBSTR (ACLDIAG_ROOTDSE));
            if ( SUCCEEDED (hr) )
            {
                BSTR bstrFullPath = 0;
                hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
                if ( SUCCEEDED (hr) )
                {
                    CComPtr<IADs> spRootDSEObject;
                    VARIANT varNamingContext;


                    hr = ADsOpenObjectHelper(bstrFullPath,IID_IADs, 0,(void**)&spRootDSEObject);
                    if ( SUCCEEDED (hr) )
                    {
                        ASSERT (!!spRootDSEObject);
                        //
                        // Get the configuration naming context from the root DSE
                        //
                        hr = spRootDSEObject->Get(CComBSTR (ACLDIAG_CONFIG_NAMING_CONTEXT),
                                             &varNamingContext);
                        if ( SUCCEEDED (hr) )
                        {
                            if ( V_VT (&varNamingContext) == VT_BSTR )
                            {
                                hr = spPathname->Set(V_BSTR(&varNamingContext),
                                                    ADS_SETTYPE_DN);
                                if ( SUCCEEDED (hr) )
                                {
                                    hr = spPathname->AddLeafElement (CComBSTR (L"CN=Extended-Rights"));
                                    if ( SUCCEEDED (hr) )
                                    {
                                        BSTR bstrFullPath1 = 0;
                                        hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath1);
                                        if ( SUCCEEDED (hr) )
                                        {
                                            CComPtr<IDirectoryObject> spExtRightsContObj;


                                            hr = ADsOpenObjectHelper (bstrFullPath1,
                                                                      IID_IDirectoryObject, 
                                                                      0,
                                                                      (void**)&spExtRightsContObj);
                                            if ( SUCCEEDED (hr) )
                                            {
                                                CComPtr<IDirectorySearch>   spDsSearch;
                                                hr = spExtRightsContObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
                                                if ( SUCCEEDED (hr) )
                                                {
                                                    ASSERT (!!spDsSearch);
                                                    ADS_SEARCHPREF_INFO pSearchPref[2];
                                                    DWORD dwNumPref = 2;

                                                    pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
                                                    pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
                                                    pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
                                                    pSearchPref[1].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
                                                    pSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
                                                    pSearchPref[1].vValue.Integer = ADS_CHASE_REFERRALS_NEVER;

                                                    hr = spDsSearch->SetSearchPreference(
                                                             pSearchPref,
                                                             dwNumPref
                                                             );
                                                    if ( SUCCEEDED (hr) )
                                                    {
                                                        PWSTR               rgszAttrList[] = {L"displayName"};
                                                        ADS_SEARCH_HANDLE   hSearchHandle = 0;
                                                        DWORD               dwNumAttributes = 1;
                                                        wstring            strQuery;
                                                        ADS_SEARCH_COLUMN   Column;

                                                        Column.pszAttrName = 0;
                                                        FormatMessage (strQuery,
                                                                L"rightsGUID=%1",
                                                                strGuid.c_str ());

                                                        hr = spDsSearch->ExecuteSearch(
                                                                             const_cast <LPWSTR>(strQuery.c_str ()),
                                                                             rgszAttrList,
                                                                             dwNumAttributes,
                                                                             &hSearchHandle
                                                                             );
                                                        if ( SUCCEEDED (hr) )
                                                        {
                                                            hr = spDsSearch->GetFirstRow (hSearchHandle);
                                                            if ( SUCCEEDED (hr) )
                                                            {
                                                                while (hr != S_ADS_NOMORE_ROWS )
                                                                {
                                                                    //
                                                                    // Getting current row's information
                                                                    //
                                                                    hr = spDsSearch->GetColumn(
                                                                             hSearchHandle,
                                                                             rgszAttrList[0],
                                                                             &Column
                                                                             );
                                                                    if ( SUCCEEDED (hr) )
                                                                    {
                                                                        strDisplayName = Column.pADsValues->CaseIgnoreString;

                                                                        spDsSearch->FreeColumn (&Column);
                                                                        Column.pszAttrName = NULL;
                                                                        break;
                                                                    }
                                                                    else if ( hr != E_ADS_COLUMN_NOT_SET )
                                                                    {
                                                                        break;
                                                                    }
                                                                    else
                                                                    {
                                                                        _TRACE (0, L"IDirectorySearch::GetColumn (): 0x%x\n", hr);
                                                                    }
                                                                }
                                                            }
                                                            else
                                                            {
                                                                 _TRACE (0, L"IDirectorySearch::GetFirstRow (): 0x%x\n", hr);
                                                            }

                                                            if (Column.pszAttrName)
                                                            {
                                                                spDsSearch->FreeColumn(&Column);
                                                            }
                                                            spDsSearch->CloseSearchHandle(hSearchHandle);
                                                        }
                                                        else
                                                        {
                                                            _TRACE (0, L"IDirectorySearch::ExecuteSearch (): 0x%x\n", hr);
                                                            hr = S_OK;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        _TRACE (0, L"IDirectorySearch::SetSearchPreference (): 0x%x\n", hr);
                                                    }
                                                }
                                                else
                                                {
                                                    _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch): 0x%x\n", hr);
                                                }
                                            }
                                            else
                                            {
                                                _TRACE (0, L"ADsOpenObjectHelper (%s): 0x%x\n", bstrFullPath1, hr);
                                            }
                                        }
                                        else
                                        {
                                            _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
                                        }
                                    }
                                    else
                                    {
                                        _TRACE (0, L"IADsPathname->AddLeafElement (%s): 0x%x\n", 
                                                L"CN=Extended-Rights", hr);
                                    }
                                }
                                else
                                {
                                    _TRACE (0, L"IADsPathname->Set (): 0x%x\n", V_BSTR(&varNamingContext), hr);
                                }
                            }
                            else
                                hr = E_FAIL;
                        }
                        else
                        {
                            _TRACE (0, L"IADs->Get (%s): 0x%x\n", ACLDIAG_CONFIG_NAMING_CONTEXT, hr);
                        }
                    }
                    else
                    {
                        _TRACE (0, L"ADsOpenObjectHelper (%s): 0x%x\n", bstrFullPath, hr);
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->AddLeafElement (%s): 0x%x\n", ACLDIAG_ROOTDSE, hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname): 0x%x\n", hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by acldiag.rc
//
#define IDS_BAD_CL_SYNTAX               1
#define IDS_BAD_CL_SYNTAX_NO_CLOSE_QUOTE 2
#define IDS_SECURITY_DIAGNOSIS_FOR      3
#define IDS_DESCRIPTION                 4
#define IDS_INVALID_OBJECT              5
#define IDS_OWNER                       6
#define IDS_CONFIG_NO_INHERIT           7
#define IDS_ALLOW                       8
#define IDS_DENY                        9
#define IDS_PERMISSIONS_EFFECTIVE       10
#define IDS_CREATE_ALL_SUBOBJECTS       11
#define IDS_CREATE_CLASS_OBJECTS        12
#define IDS_DELETE_ALL_SUBOBJECTS       13
#define IDS_DELETE_CLASS_OBJECTS        14
#define IDS_READ_ALL_PROPERTIES         15
#define IDS_READ_PROPERTY_PROPERTY      16
#define IDS_WRITE_ALL_PROPERTIES        17
#define IDS_WRITE_PROPERTY_PROPERTY     18
#define IDS_LIST_CONTENTS               19
#define IDS_LIST_OBJECT                 20
#define IDS_DELETE_TREE                 21
#define IDS_ALL_CONTROL_ACCESSES        22
#define IDS_CONTROL_ACCESS_DISPLAY_NAME 23
#define IDS_DELETE_THIS_OBJECT          24
#define IDS_READ_PERMISSIONS            25
#define IDS_TAKE_CHANGE_OWNERSHIP       26
#define IDS_MODIFY_PERMISSIONS          27
#define IDS_MODIFY_MEMBERSHIP           28
#define IDS_INHERITED_PERMISSION        29
#define IDS_DELEGWIZ_READ_PROPERTY      30
#define IDS_DELEGWIZ_WRITE_PROPERTY     31
#define IDS_DELEGWIZ_CREATE_CLASS       32
#define IDS_DELEGWIZ_DELETE_CLASS       33
#define IDS_PERMISSIONS_INHERITED_BY_SUBOBJECTS 34
#define IDS_INHERIT_TO_ALL_SUBOBJECTS   35
#define IDS_INHERIT_TO_X_OBJECTS_ONLY   36
#define IDS_AUDITING_EFFECTIVE_ON_THIS_OBJECT 37
#define IDS_SCHEMA_DEFAULTS_DIAGNOSIS   38
#define IDS_SCHEMA_DEFAULTS             39
#define IDS_OBTAINED                    40
#define IDS_ABSENT                      41
#define IDS_PRESENT                     42
#define IDS_PARTIAL                     43
#define IDS_AT_CREATION                 44
#define IDS_BY_INHERITANCE              45
#define IDS_SUCCESS                     46
#define IDS_FAILURE                     47
#define IDS_SUCCESS_AND_FAILURE         48
#define IDS_AUDITING_INHERITED_TO_SUBOBJECTS 49
#define IDS_COULD_NOT_VALIDATE_USER_CREDENTIALS 50
#define IDS_USER_MUST_BE_ADMINISTRATOR  51
#define IDS_UNKNOWN_PARENT              52
#define IDS_HELP_MAIN                   53
#define IDS_ADS_BAD_PATHNAME            54
#define IDS_INVALID_OPTION              55
#define IDS_HELP_SCHEMA                 56
#define IDS_HELP_CHKDELEG               57
#define IDS_HELP_GETEFFECTIVE           58
#define IDS_HELP_CDO                    59
#define IDS_UNABLE_TO_READ_SECURITY_DESCRIPTOR 60
#define IDS_DELEGWIZ_FINISH_TEMPLATE    61
#define IDS_DELEGWIZ_FINISH_PRINCIPALS  62
#define IDS_DELEGWIZ_ERR_OBJ_PEC_PERM   63
#define IDS_DELEGWIZ_FULL_CONTROL       64
#define IDS_DELEGWIZ_FINISH_PERMISSIONS 65
#define IDS_DELEGWIZ_RW_PROPERTYSET     66
#define IDS_DELEGWIZ_ACTRL_FULL         67
#define IDS_DELEGWIZ_ACTRL_READ         68
#define IDS_DELEGWIZ_ACTRL_WRITE        69
#define IDS_DELEGWIZ_ACTRL_DS_CREATE_CHILD 70
#define IDS_DELEGWIZ_ACTRL_DS_DELETE_CHILD 71
#define IDS_DELEGATION_TEMPLATE_DIAGNOSIS 72
#define IDS_DELTEMPL_STATUS             73
#define IDS_OK                          74
#define IDS_NOT_PRESENT                 75
#define IDS_MISCONFIGURED               76
#define IDS_APPLIES_ON_THIS_OBJECT      77
#define IDS_INHERITED_FROM_PARENT       78
#define IDS_YES                         79
#define IDS_NO                          80
#define IDS_DELEGATION_TITLE            81
#define IDS_FIX_DELEGATION_QUERY        82
#define IDS_DELEGWIZ_ERR_SET_SEC_INFO   83
#define IDS_DELEGWIZ_ERR_GET_SEC_INFO   84
#define IDS_EFFECTIVE_RIGHTS_DIAGNOSIS  85
#define IDS_OWNER_CDO                   86
#define IDS_PERMISSIONS_PROTECTED       87
#define IDS_PERMISSIONS_NOT_PROTECTED   88
#define IDS_AUDITING_PROTECTED          89
#define IDS_AUDITING_NOT_PROTECTED      90
#define IDS_ALLOW_CDO                   91
#define IDS_DENY_CDO                    92
#define IDS_THIS_OBJECT                 93
#define IDS_ALL_SUBOBJECTS              94
#define IDS_SUCCESS_CDO                 95
#define IDS_FAILURE_CDO                 96
#define IDS_SUCCESS_AND_FAILURE_CDO     97
#define IDS_INHERITED_PERMISSION_CDO    98
#define IDS_CLASS_OBJECT                99
#define IDS_SCHEMA_DEFAULTS_CDO         100
#define IDS_OBTAINED_CDO                101
#define IDS_DELEGATION_TITLE_CDO        102
#define IDS_DELTEMPL_STATUS_CDO         103
#define IDS_APPLIES_ON_THIS_OBJECT_CDO  104
#define IDS_APPLIES                     105
#define IDS_DOES_NOT_APPLY              106
#define IDS_INHERITED_FROM_PARENT_CDO   107
#define IDS_EXPLICIT                    108
#define IDS_INHERITED                   109
#define IDS_DELEGATION_NOT_FOUND_CDO    110
#define IDS_HELP_LOG                    111
#define IDS_CAN                         112
#define IDS_CAN_CDO                     113
#define IDS_HELP_SKIP_DESCRIPTION       114
#define IDS_CREATE_ALL_SUBOBJECTS_ER    115
#define IDS_DELETE_ALL_SUBOBJECTS_ER    116
#define IDS_READ_ALL_PROPERTIES_ER      117
#define IDS_WRITE_ALL_PROPERTIES_ER     118
#define IDS_ALL_CONTROL_ACCESSES_ER     119
#define IDS_LIST_CONTENTS_ER            123
#define IDS_LIST_OBJECT_ER              124
#define IDS_READ_PERMISSIONS_ER         125
#define IDS_MODIFY_PERMISSIONS_ER       126
#define IDS_TAKE_CHANGE_OWNERSHIP_ER    127
#define IDS_MODIFY_MEMBERSHIP_ER        128
#define IDS_DELETE_THIS_OBJECT_ER       129
#define IDS_CLASS                       130
#define IDS_PROPERTY                    131
#define IDS_CONTROL                     132
#define IDS_CANNOT_EF                   133
#define IDS_CANNOT_CDO                  134
#define IDS_NO_SECDESC_RETURNED         135
#define IDS_NO_SECDESC_RETURNED_WITH_CODE 136
#define IDS_EFFRIGHT_FROM_GROUP         137
#define IDS_EFFRIGHT_FROM_GROUP_CDO     138
#define IDS_CAN_CREATE_FOLLOWING_CHILD_OBJECTS 139
#define IDS_CAN_DELETE_FOLLOWING_CHILD_OBJECTS 140
#define IDS_CAN_READ_FOLLOWING_PROPERTIES 141
#define IDS_CAN_WRITE_FOLLOWING_PROPERTIES 142
#define IDS_CAN_DO_FOLLOWING_CONTROL_OPERATIONS 143
#define IDS_CREATE_CLASS_OBJECTS_ER     144
#define IDS_DELETE_CLASS_OBJECTS_ER     145
#define IDS_READ_PROPERTY_PROPERTY_ER   146
#define IDS_WRITE_PROPERTY_PROPERTY_ER  147
#define IDS_CAN_ER                      148
#define IDS_FAILED_TO_LOAD_TEMPLATES    149
#define IDS_DELEGWIZ_ACTRL_DS_READ_PROP 150
#define IDS_DELEGWIZ_ACTRL_DS_WRITE_PROP 151
#define IDS_GENERATED_INHERITED_PERMISSION 152
#define IDS_GENERATED_INHERITED_PERMISSION_CDO 153
#define IDS_HELP_FIXDELEG               154
#define IDS_HELP_EXAMPLE                155

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\schema.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2002.
//
//  File:       Schema.cpp
//
//  Contents:   DoSchemaDiagnosis and support methods
//              
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <security.h>
#include <seopaque.h>
#include <sddl.h>
#include "ADUtils.h"
#include "Schema.h"
#include "SecDesc.h"


// Function prototypes
bool FindInGlobalList (const ACE_SAMNAME* pAceSAMNameToFind, const ACE_SAMNAME_LIST& defACLList);
HRESULT GetSchemaDefaultSecurityDescriptor (
            const wstring& strObjectDN, 
            PADS_ATTR_INFO* ppAttrs, 
            PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
            wstring &objectClass);
HRESULT GetObjectClass (const wstring& strObjectDN, wstring& ldapClassName);
HRESULT GetClassSecurityDescriptor (
            PADS_ATTR_INFO* ppAttrs, 
            PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
            CComPtr<IADsPathname>& spPathname,
            const wstring& ldapClassName);
HRESULT GetADClassName (
            CComPtr<IADsPathname>& spPathname, 
            const wstring& ldapClassName, 
            wstring& adClassName);


// Functions
HRESULT DoSchemaDiagnosis ()
{
    _TRACE (1, L"Entering  DoSchemaDiagnosis\n");
    HRESULT         hr = S_OK;
    wstring         str;
    size_t          nDACLAcesFound = 0;
    bool            bAllExplicit = true;
    bool            bAllInherited = true;
    ACE_SAMNAME_LIST  defDACLList;
    ACE_SAMNAME_LIST  defSACLList;

    if ( !_Module.DoTabDelimitedOutput () )
    {
        LoadFromResource (str, IDS_SCHEMA_DEFAULTS_DIAGNOSIS);
        MyWprintf (str.c_str ());
    }

    PSECURITY_DESCRIPTOR    pSecurityDescriptor = 0;
    PADS_ATTR_INFO          pAttrs = NULL;
    wstring                 ldapClassName;
    hr = GetSchemaDefaultSecurityDescriptor (_Module.GetObjectDN (), &pAttrs,
            &pSecurityDescriptor, ldapClassName);
    if ( SUCCEEDED (hr) && pSecurityDescriptor )
    {
        hr = EnumerateDacl (pSecurityDescriptor, defDACLList, false);
        if ( SUCCEEDED (hr) )
        {
            ACE_SAMNAME*    pAceSAMName = 0;


            // Compare the DACL
            for (ACE_SAMNAME_LIST::iterator itr = defDACLList.begin(); 
                    itr != defDACLList.end(); 
                    itr++)
            {
                pAceSAMName = *itr;
                if ( FindInGlobalList (pAceSAMName, _Module.m_DACLList) )
                {
                    if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERITED_ACE )
                    {
                        switch ( pAceSAMName->m_AceType )
                        {
                        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                            {
                                wstring inheritedObjectClass;

                                if ( SUCCEEDED (_Module.GetClassFromGUID (
                                        pAceSAMName->m_pAllowedObjectAce->InheritedObjectType,
                                        inheritedObjectClass) ) )
                                {
                                    if ( !ldapClassName.compare (inheritedObjectClass) )
                                        break;  // matches
                                }
                            }
                            continue;   // not a match

                        case ACCESS_DENIED_OBJECT_ACE_TYPE:
                            {
                                wstring inheritedObjectClass;

                                if ( SUCCEEDED (_Module.GetClassFromGUID (
                                        pAceSAMName->m_pDeniedObjectAce->InheritedObjectType,
                                        inheritedObjectClass) ) )
                                {
                                    if ( !ldapClassName.compare (inheritedObjectClass) )
                                        break;  // matches
                                }
                            }
                            continue;   // not a match

                        default:
                            break;  // matches
                        }
                        bAllExplicit = false;
                    }
                    else
                        bAllInherited = false;
                    nDACLAcesFound++;
                }
            }
        }

        // Compare the SACL
        hr = EnumerateSacl (pSecurityDescriptor, defSACLList);
        if ( SUCCEEDED (hr) )
        {
            ACE_SAMNAME*    pAceSAMName = 0;


            for (ACE_SAMNAME_LIST::iterator itr = defSACLList.begin(); 
                    itr != defSACLList.end(); 
                    itr++)
            {
                pAceSAMName = *itr;
                if ( FindInGlobalList (pAceSAMName, _Module.m_SACLList) )
                {
                    if ( pAceSAMName->m_pAllowedAce->Header.AceFlags & INHERITED_ACE )
                    {
                        switch ( pAceSAMName->m_AceType )
                        {
                        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                            {
                                wstring inheritedObjectClass;

                                if ( SUCCEEDED (_Module.GetClassFromGUID (
                                        pAceSAMName->m_pSystemAuditObjectAce->InheritedObjectType,
                                        inheritedObjectClass) ) )
                                {
                                    if ( !ldapClassName.compare (inheritedObjectClass) )
                                        break;  // matches
                                }
                            }
                            continue;   // not a match

                        case SYSTEM_AUDIT_ACE_TYPE:
                        default:
                            break;  // matches
                        }
                        bAllExplicit = false;
                    }
                    else
                        bAllInherited = false;
                    nDACLAcesFound++;
                }
            }
        }
    }

    wstring    strDefaultState;
    bool        bPresent = false;
    if ( !nDACLAcesFound )
    {
        // absent
        LoadFromResource (strDefaultState, IDS_ABSENT);
    }
    else 
    {
        if ( nDACLAcesFound == defDACLList.size () )
        {
            if ( bAllExplicit | bAllInherited )
            {
                // present
                LoadFromResource (strDefaultState, IDS_PRESENT);
                bPresent = true;
            }
            else
            {
                // partial
                LoadFromResource (strDefaultState, IDS_PARTIAL);
            }
        }
        else
        {
            // partial
            LoadFromResource (strDefaultState, IDS_PARTIAL);
        }
    }
    if ( _Module.DoTabDelimitedOutput () )
        FormatMessage (str, IDS_SCHEMA_DEFAULTS_CDO, strDefaultState.c_str ());
    else
        FormatMessage (str, IDS_SCHEMA_DEFAULTS, strDefaultState.c_str ());
    MyWprintf (str.c_str ());

    if ( bPresent )
    {
        if ( bAllExplicit )
            LoadFromResource (strDefaultState, IDS_AT_CREATION);
        else
            LoadFromResource (strDefaultState, IDS_BY_INHERITANCE);
        if ( _Module.DoTabDelimitedOutput () )
            FormatMessage (str, IDS_OBTAINED_CDO, strDefaultState.c_str ());
        else
            FormatMessage (str, IDS_OBTAINED, strDefaultState.c_str ());
        MyWprintf (str.c_str ());
    }
    else if ( _Module.DoTabDelimitedOutput () )
        MyWprintf (L"\n\n");

    _TRACE (-1, L"Leaving DoSchemaDiagnosis: 0x%x\n", hr);
    return hr;
}

HRESULT GetSchemaDefaultSecurityDescriptor (
        const wstring& strObjectDN, 
        PADS_ATTR_INFO* ppAttrs, 
        PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
        wstring &ldapClassName)
{
    _TRACE (1, L"Entering  GetSchemaDefaultSecurityDescriptor\n");
    HRESULT hr = S_OK;

    if ( ppAttrs && ppSecurityDescriptor )
    {
        hr = GetObjectClass (strObjectDN, ldapClassName);
        if ( SUCCEEDED (hr) )
        {
            wstring  strDC;

            size_t pos = strObjectDN.find (L"DC=", 0);
            if ( strObjectDN.npos != pos )
            {
                strDC = strObjectDN.substr (pos);
                CComPtr<IADsPathname> spPathname;
                //
                // Constructing the directory paths
                //
                hr = CoCreateInstance(
                            CLSID_Pathname,
                            NULL,
                            CLSCTX_ALL,
                            IID_PPV_ARG (IADsPathname, &spPathname));
                if ( SUCCEEDED (hr) )
                {
                    ASSERT (!!spPathname);
                    hr = spPathname->Set (CComBSTR (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
                    if ( SUCCEEDED (hr) )
                    {
                        hr = spPathname->Set (CComBSTR (strDC.c_str ()), ADS_SETTYPE_DN);
                        if ( SUCCEEDED (hr) )
                        {
                            hr = spPathname->AddLeafElement (CComBSTR (L"CN=Configuration"));
                            if ( SUCCEEDED (hr) )
                            {
                                hr = spPathname->AddLeafElement (CComBSTR (L"CN=Schema"));
                                if ( SUCCEEDED (hr) )
                                {
                                    hr = GetClassSecurityDescriptor (
                                            ppAttrs, 
                                            ppSecurityDescriptor,
                                            spPathname,
                                            ldapClassName);
                                }
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                                    strDC.c_str (), hr);
                        }
                    }
                    else
                    {
                        _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
                    }
                }
                else
                {
                    _TRACE (0, L"CoCreateInstance(CLSID_Pathname): 0x%x\n", hr);
                }
            }

        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving GetSchemaDefaultSecurityDescriptor: 0x%x\n", hr);
    return hr;
}

HRESULT GetObjectClass (const wstring& strObjectDN, wstring& ldapClassName)
{
    _TRACE (1, L"Entering  GetObjectClass\n");
    HRESULT hr = S_OK;

    CComPtr<IADsPathname> spPathname;
    //
    // Constructing the directory paths
    //
    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG (IADsPathname, &spPathname));
    if ( SUCCEEDED (hr) )
    {
        ASSERT (!!spPathname);
        hr = spPathname->Set (CComBSTR (ACLDIAG_LDAP), ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (CComBSTR (strObjectDN.c_str ()), ADS_SETTYPE_DN);
            if ( SUCCEEDED (hr) )
            {
                BSTR bstrFullPath = 0;
                hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
                if ( SUCCEEDED (hr) )
                {
                    CComPtr<IDirectoryObject> spDirObj;


                    hr = ADsOpenObjectHelper (bstrFullPath,
                                              IID_IDirectoryObject, 
                                              0,
                                              (void**)&spDirObj);
                    if ( SUCCEEDED (hr) )
                    {
                        //
                        // Get this object's object class.
                        //
                        const PWSTR wzObjectClass = L"objectClass";
                    
                        DWORD cAttrs = 0;
                        LPWSTR rgpwzAttrNames[] = {wzObjectClass};
                        PADS_ATTR_INFO pAttrs = NULL;

                        hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, 
                                &pAttrs, &cAttrs);
                        if ( SUCCEEDED (hr) )
                        {
                            if ( 1 <= cAttrs && pAttrs && pAttrs->pADsValues )
                            {
                                if (!(pAttrs->pADsValues[pAttrs->dwNumValues-1].CaseIgnoreString) )
                                {
                                    _TRACE (0, L"IADS return bogus object class!\n");
                                    hr =  E_UNEXPECTED;
                                }
                                else
                                {
                                    ldapClassName = 
                                            pAttrs->pADsValues[pAttrs->dwNumValues-1].CaseIgnoreString;
                                }
                                FreeADsMem (pAttrs);
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                        {
                            _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                        }
                    }
                    else
                    {
                        _TRACE (0, L"ADsOpenObjectHelper (%s): 0x%x\n", bstrFullPath, hr);
                        wstring    strErr;
                   

                        FormatMessage (strErr, IDS_INVALID_OBJECT, 
                                _Module.GetObjectDN ().c_str (), 
                                GetSystemMessage (hr).c_str ());
                        MyWprintf (strErr.c_str ());
                    }
                }
                else
                {
                    _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", 
                        _Module.GetObjectDN ().c_str (), hr);
            }
        }
        else
        {
            _TRACE (0, L"IADsPathname->Set (%s): 0x%x\n", ACLDIAG_LDAP, hr);
        }
    }
    else
    {
        _TRACE (0, L"CoCreateInstance(CLSID_Pathname): 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving GetObjectClass: 0x%x\n", hr);
    return hr;
}

bool FindInGlobalList (const ACE_SAMNAME* pAceSAMNameToFind, const ACE_SAMNAME_LIST& defDACLList)
{
    _TRACE (1, L"Entering  FindInGlobalList\n");
    bool        bFound = false;
    ACE_SAMNAME*    pAceSAMName = 0;

    for (ACE_SAMNAME_LIST::iterator itr = defDACLList.begin(); 
            itr != defDACLList.end(); 
            itr++)
    {
        pAceSAMName = *itr;
        // pAceSAMNameToFind must be on the left
        if ( *pAceSAMNameToFind == *pAceSAMName )
        {
            bFound = true;
            break;
        }
    }
    
    _TRACE (-1, L"Leaving FindInGlobalList: %s\n", bFound ? L"found" : L"not found");
    return bFound;
}


HRESULT GetClassSecurityDescriptor (PADS_ATTR_INFO* ppAttrs, 
        PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
        CComPtr<IADsPathname>& spPathname,
        const wstring& ldapClassName)
{
    _TRACE (1, L"Entering  GetClassSecurityDescriptor\n");
    // ldapClassName must be converted from LDAP class to AD class
    wstring adClassName;

    HRESULT hr = GetADClassName (spPathname, ldapClassName, adClassName);
    if ( SUCCEEDED (hr) )
    {
        wstring cnClassName (L"CN=");
        cnClassName += adClassName;
        hr = spPathname->AddLeafElement (
                CComBSTR (cnClassName.c_str ()));
        if ( SUCCEEDED (hr) )
        {
            BSTR bstrFullPath = 0;
            hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
            if ( SUCCEEDED (hr) )
            {
                CComPtr<IDirectoryObject> spDirObj;

                hr = ADsOpenObjectHelper (bstrFullPath,
                                          IID_IDirectoryObject, 
                                          0,
                                          (void**)&spDirObj);
                if ( SUCCEEDED (hr) )
                {
                     hr = SetSecurityInfoMask (spDirObj, 
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION |
                            SACL_SECURITY_INFORMATION);

                    //
                    // Get this object's default Security Descriptor.
                    //
                    const PWSTR wzSecDescriptor = L"defaultSecurityDescriptor";

                    DWORD cAttrs = 0;
                    LPWSTR rgpwzAttrNames[] = {wzSecDescriptor};

                    hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, 1, ppAttrs, &cAttrs);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( 1 == cAttrs && *ppAttrs && (*ppAttrs)->pADsValues )
                        {
                            // Caller will delete the SD w/ LocalFree         
                            if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
                                    (*ppAttrs)->pADsValues->CaseIgnoreString,
                                    SDDL_REVISION,
                                    ppSecurityDescriptor,
                                    0) )
                            {
                                hr = HRESULT_FROM_WIN32(::GetLastError());
                            }

                            if ( SUCCEEDED (hr) )
                            {
                                ASSERT (*ppSecurityDescriptor);
                                if ( !*ppSecurityDescriptor )
                                {
                                    _TRACE (0, L"Call to ConvertStringSecurityDescriptorToSecurityDescriptor () succeeded but returned null security descriptor.\n");
                                    hr = E_FAIL;
                                }
                            }
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    else
                    {
                        _TRACE (0, L"IDirectoryObject->GetObjectAttributes (): 0x%x\n", hr);
                    }
                }
                else
                {
                    _TRACE (0, L"ADsOpenObjectHelper (%s): 0x%x\n", bstrFullPath, hr);
                    wstring    strErr;


                    FormatMessage (strErr, IDS_INVALID_OBJECT, 
                            _Module.GetObjectDN ().c_str (), 
                            GetSystemMessage (hr).c_str ());
                    MyWprintf (strErr.c_str ());
                }
            }
            else
            {
                _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
            }
        }
    }

    _TRACE (-1, L"Leaving GetClassSecurityDescriptor: 0x%x\n", hr);
    return hr;
}


HRESULT GetADClassName (
            CComPtr<IADsPathname>& spPathname, 
            const wstring& ldapClassName, 
            wstring& adClassName)
{
    _TRACE (1, L"Entering  GetADClassName\n");
    HRESULT hr = S_OK;

    // Get the "CN=Schema,CN=Configuration,DC=..." object
    // Search for a child whose LDAP-Display-Name matches ldapClassName
    BSTR bstrFullPath = 0;
    hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
    if ( SUCCEEDED (hr) )
    {
        CComPtr<IDirectoryObject> spDirObj;

        hr = ADsOpenObjectHelper (bstrFullPath,
                                  IID_IDirectoryObject, 
                                  0,
                                  (void**)&spDirObj);
        if ( SUCCEEDED (hr) )
        {
            CComPtr<IDirectorySearch>   spDsSearch;
            hr = spDirObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
            if ( SUCCEEDED (hr) )
            {
                ASSERT (!!spDsSearch);
                ADS_SEARCHPREF_INFO pSearchPref[2];
                DWORD dwNumPref = 2;

                pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
                pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
                pSearchPref[1].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
                pSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
                pSearchPref[1].vValue.Integer = ADS_CHASE_REFERRALS_NEVER;

                hr = spDsSearch->SetSearchPreference(
                         pSearchPref,
                         dwNumPref
                         );
                if ( SUCCEEDED (hr) )
                {
                    PWSTR               rgszAttrList[] = {L"cn"}; //Common-Name", NULL };
                    ADS_SEARCH_HANDLE   hSearchHandle = 0;
                    DWORD               dwNumAttributes = 1;
                    wstring             strQuery;
                    ADS_SEARCH_COLUMN   Column;

                    ::ZeroMemory (&Column, sizeof (ADS_SEARCH_COLUMN));
                    FormatMessage (strQuery, 
                            L"lDAPDisplayName=%1", //L"LDAP-Display-Name=%1",
                            ldapClassName.c_str ());

                    hr = spDsSearch->ExecuteSearch(
                                         const_cast <LPWSTR>(strQuery.c_str ()),
                                         rgszAttrList,
                                         dwNumAttributes,
                                         &hSearchHandle
                                         );
                    if ( SUCCEEDED (hr) )
                    {
                        hr = spDsSearch->GetFirstRow (hSearchHandle);
                        if ( SUCCEEDED (hr) )
                        {
                            while (hr != S_ADS_NOMORE_ROWS )
                            {
                                //
                                // Getting current row's information
                                //
                                hr = spDsSearch->GetColumn(
                                         hSearchHandle,
                                         rgszAttrList[0],
                                         &Column
                                         );
                                if ( SUCCEEDED (hr) )
                                {
                                    adClassName = Column.pADsValues->CaseIgnoreString;

                                    spDsSearch->FreeColumn (&Column);
                                    Column.pszAttrName = NULL;
                                    break;
                                }
                                else if ( hr != E_ADS_COLUMN_NOT_SET )
                                {
                                    break;
                                }
                                else
                                {
                                    _TRACE (0, L"IDirectorySearch::GetColumn (): 0x%x\n", hr);
                                }
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IDirectorySearch::GetFirstRow (): 0x%x\n", hr);
                        }

                        if (Column.pszAttrName)
                        {
                            spDsSearch->FreeColumn(&Column);
                        }
                        spDsSearch->CloseSearchHandle(hSearchHandle);
                    }
                    else
                    {
                        _TRACE (0, L"IDirectorySearch::ExecuteSearch (): 0x%x\n", hr);
                        hr = S_OK;
                    }
                }
                else
                {
                    _TRACE (0, L"IDirectorySearch::SetSearchPreference (): 0x%x\n", hr);
                }
            }
            else
            {
                _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch): 0x%x\n", hr);
            }
        }
        else
        {
            _TRACE (0, L"ADsOpenObjectHelper (%s): 0x%x\n", bstrFullPath, hr);
        }
    }
    else
    {
        _TRACE (0, L"IADsPathname->Retrieve (): 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving GetADClassName: 0x%x\n", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ACLDiag.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__66DB1632_C78B_11D2_AC41_00C04F79DDCA__INCLUDED_)
#define AFX_STDAFX_H__66DB1632_C78B_11D2_AC41_00C04F79DDCA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT

#define _ATL_APARTMENT_THREADED

#pragma warning (disable : 4514)
#pragma warning (push, 3)
//////////////////////////////////////////////
// CRT and C++ headers

#include <xstring>
#include <list>
#include <vector>
#include <algorithm>

using namespace std;

//////////////////////////////////////////////
// Windows and ATL headers

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <shellapi.h>
#include <shlobj.h>

#include <objsel.h>

#include <atlbase.h>
using namespace ATL;

#include <iads.h>
#include <adserr.h>
#include <adshlp.h>
#include <adsprop.h>
#include <iadsp.h>
#include <security.h>
#include <seopaque.h>

#include <accctrl.h>
#include <setupapi.h> // to read the .INF file

#pragma warning (pop)

//
//strsafe apis
//
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h> 


#include "debug.h"


#include "resource.h"

#define IID_PPV_ARG(Type, Expr) IID_##Type, \
	reinterpret_cast<void**>(static_cast<Type **>(Expr))
#define ACLDIAG_LDAP                   L"LDAP"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__66DB1632_C78B_11D2_AC41_00C04F79DDCA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\acldiag\secdesc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       SecDesc.h
//
//  Contents:   DoSecurityDescription and support methods
//              
//
//----------------------------------------------------------------------------
#ifndef __ACLDIAG_SECDESC
#define __ACLDIAG_SECDESC

HRESULT DoSecurityDescription ();
HRESULT DisplayOwner ();
HRESULT EnumerateDacl (PSECURITY_DESCRIPTOR pSecurityDescriptor, ACE_SAMNAME_LIST& DACLList, bool bListSids);
HRESULT EnumerateSacl (PSECURITY_DESCRIPTOR pSecurityDescriptor, ACE_SAMNAME_LIST& SACLList);
HRESULT PrintEffectivePermissions ();


typedef enum {
    P_UNASSIGNED = -1,
    P_ALLOW = 0,
    P_DENY,
    P_SUCCESS,
    P_FAILURE,
    P_SUCCESS_AND_FAILURE
} P_TYPE;

typedef enum {
    P_THIS_OBJECT = 0,
    P_ALL_OBJECTS,
    P_CLASS_OBJECT
} P_WHO;

HRESULT PrintPermission (ACE_SAMNAME* pAceSAMName,
        ACCESS_MASK accessMask,
        P_TYPE  ptype,
        int     strIDAll, 
        int     strIDParam,
        P_WHO    pWho, 
        PCWSTR pwszClassName);
HRESULT PrintPermission (ACE_SAMNAME*  pAceSAMName,
        ACCESS_MASK accessMask,
        P_TYPE  ptype,
        int strID,
        bool bIsAudit,
        P_WHO    pWho, 
        PCWSTR pwszClassName);
HRESULT EnumeratePermissions (ACE_SAMNAME*  pAceSAMName, P_TYPE ptype, P_WHO pWho, PCWSTR pwszClassName);
HRESULT GetParentObjectDNWithSameACE (
            ACE_SAMNAME*  pAceSAMName, 
            IADsPathname* pPathName,
            ACCESS_MASK accessMask,
            string  strParentDN,
            bool bIsAudit);
HRESULT PrintInheritedPermissionFromDN (
            ACE_SAMNAME* pAceSAMName, 
            ACCESS_MASK accessMask,
            bool bIsAudit);

HRESULT PrintInheritedPermissions ();
void AddToInheritedObjectTypeGUIDList (list<GUID*>& guidList, GUID* pGuid);
HRESULT PrintAuditingInformation ();
HRESULT GetSecurityDescriptor (
            wstring strObjectDN,    // pass by value
            PSECURITY_DESCRIPTOR* ppSecurityDescriptor);
HRESULT EnumerateAudits (ACE_SAMNAME* pAceSAMName, P_WHO pWho, PCWSTR pwszClassName);
HRESULT PrintEffectiveAuditing ();
HRESULT PrintInheritedAuditing ();
HRESULT GetControlDisplayName (REFGUID guid, wstring& strDisplayName);
HRESULT GetControlDisplayName (const wstring strGuid, wstring& strDisplayName);
#endif	//  __ACLDIAG_SECDESC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\common\deltempl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       deltempl.h
//
//--------------------------------------------------------------------------


#ifndef _DELTEMPL_H__
#define _DELTEMPL_H__

#include "util.h"
#include "tempcore.h"


///////////////////////////////////////////////////////////////////////
// CTemplateAccessPermissionsHolder

class CTemplateClassReferences; // fwd decl

class CTemplateAccessPermissionsHolder : public CAccessPermissionsHolderBase
{
public:
  CTemplateAccessPermissionsHolder(CSchemaClassInfo* pClassInfo, BOOL bScopeClass);
  virtual ~CTemplateAccessPermissionsHolder();

  HRESULT GetAccessPermissions(CAdsiObject* pADSIObj);
  
  BOOL SetupFromClassReferences(CTemplateObjectTypeListRef* pRefList);

  DWORD UpdateAccessList(CPrincipal* pPrincipal,
                        LPCWSTR lpszServerName,
                        LPCWSTR lpszPhysicalSchemaNamingContext,
                        PACL *ppAcl);

protected:
  virtual HRESULT _LoadAccessRightInfoArrayFromTable( BOOL bIgnore, BOOL bHideListObject);

private:
  BOOL _SetControlRight(LPCWSTR lpszControlRight);
  BOOL _SetAccessMask(LPCWSTR lpszName, ULONG fAccessMask);

  BOOL _SetGeneralRighs(ULONG fAccessMask);
  BOOL _SetPropertyRight(LPCWSTR lpszName, ULONG fAccessMask);
  BOOL _SetSubObjectRight(LPCWSTR lpszName, ULONG fAccessMask);

private:
  CSchemaClassInfo* m_pClassInfo;
  BOOL m_bScopeClass;
};


typedef CGrowableArr<CTemplateAccessPermissionsHolder> CTemplatePermissionHolderArray;


///////////////////////////////////////////////////////////////////////
// CTemplateAccessPermissionsHolderManager

class CTemplateAccessPermissionsHolderManager
{
public:
  CTemplateAccessPermissionsHolderManager()
  {
  }

  BOOL LoadTemplates(); // load template manager from INF file
  
  BOOL HasTemplates(LPCWSTR lpszClass); // tell if there are loaded templates for a class
  BOOL HasSelectedTemplates();  // tell if there is a selection
  void DeselectAll();

  BOOL InitPermissionHoldersFromSelectedTemplates(CGrowableArr<CSchemaClassInfo>* pSchemaClassesInfoArray,
                              CAdsiObject* pADSIObj);

  DWORD UpdateAccessList(CPrincipal* pPrincipal,
                        LPCWSTR lpszServerName,
                        LPCWSTR lpszPhysicalSchemaNamingContext,
                        PACL *ppAcl);

  // UI related operations
  BOOL FillTemplatesListView(CCheckListViewHelper* pListViewHelper, LPCWSTR lpszClass);
  void WriteSummary(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine);

protected:
  CTemplatePermissionHolderArray m_permissionHolderArray;

  CTemplateManager  m_templateManager;
};


#endif // _DELTEMPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\common\stlutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stlutil.h
//
//--------------------------------------------------------------------------

#ifndef _STLUTIL_H__
#define _STLUTIL_H__


#if defined (DBG)
  #define _DUMP
#endif



/////////////////////////////////////////////////////////////////////////
// STL based helper template functions

template <class CNT> void _Clear(CNT* pCnt, BOOL bDel)
{
  if (bDel)
  {
    CNT::iterator i;
    for (i = pCnt->begin(); i != pCnt->end(); ++i)
    {
      if (*i != NULL)
      {
        delete (*i);
        *i = NULL;
      }
    }
  }
  pCnt->clear();
}


template <class CNT, class T> BOOL _Remove(CNT* pCnt, T* p, BOOL bDel = TRUE)
{
  CNT::iterator i;
  i = find(pCnt->begin(), pCnt->end(), p);
  if (i == pCnt->end())
  {
    return FALSE;
  }

  pCnt->erase(i);

  if (bDel)
    delete p;
  return TRUE;
}



///////////////////////////////////////////////////////////////////////
// CCompare<>

template <class T> class CCompare
{
public:
  bool operator()(const T x, const T y)
  {
    return *x < *y;
  }
};

///////////////////////////////////////////////////////////////////////
// CPtrList<>

template <class T> class CPtrList : public list<T>
{
public:
  CPtrList(BOOL bOwnMem)
  {
    m_bOwnMem = bOwnMem;
  }
  ~CPtrList()
  {
    Clear();
  }

#ifdef _DUMP
  void Dump()
  {
    CPtrList<T>::iterator i;
    for (i = this->begin(); i != this->end(); ++i)
    {
      (*i)->Dump();
    }
  }
#endif // _DUMP

  void Clear() { _Clear(this, m_bOwnMem);}
  BOOL Remove(T p) { return _Remove(this, p, m_bOwnMem);}

private:
  BOOL m_bOwnMem;
};

///////////////////////////////////////////////////////////////////////
// CGrowableArr<>

template <class T, class CMP = CCompare<T*> > class CGrowableArr
{
public:
	CGrowableArr(BOOL bOwnMem = TRUE)
	{
    m_bOwnMem = bOwnMem;
	};
	virtual ~CGrowableArr()
	{
		Clear();
	}
  size_t GetCount() { return m_pEntries.size(); }
	BOOL Alloc(long n)
	{
		return TRUE;
	}
  void Clear()
  {
    _Clear(&m_pEntries, m_bOwnMem);
  }

  T* operator[](long i)
  {
    return m_pEntries[i];
  }

  BOOL Add(T* p)
  {
    m_pEntries.push_back(p);
    return TRUE;
  }
  void Sort()
  {
    sort(m_pEntries.begin(), m_pEntries.end(), CMP());
  }

#ifdef _DUMP
  void Dump()
  {
    vector<T*>::iterator i;
    for (i = m_pEntries.begin(); i != m_pEntries.end(); ++i)
    {
      (*i)->Dump();
    }
  }
#endif // _DUMP
private:
  BOOL m_bOwnMem;
  vector<T*> m_pEntries;
};
   




#endif // _STLUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\common\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2002
//
//  File:       util.h
//
//--------------------------------------------------------------------------

#ifndef _UTIL_H__
#define _UTIL_H__

#include <dsclient.h>
#include "stlutil.h"
#include "dscmn.h"
///////////////////////////////////////////////////////////////////////
// MACROS


// flags to interpret the DSSEC.DAT file values (from JeffreyS)
#define IDC_CLASS_NO_CREATE     0x00000001
#define IDC_CLASS_NO_DELETE     0x00000002
#define IDC_CLASS_NO_INHERIT    0x00000004
#define IDC_PROP_NO_READ        0x00000001
#define IDC_PROP_NO_WRITE       0x00000002

// derived flags
#define IDC_CLASS_NO (IDC_CLASS_NO_CREATE | IDC_CLASS_NO_DELETE | IDC_CLASS_NO_INHERIT)
#define IDC_PROP_NO (IDC_PROP_NO_READ | IDC_PROP_NO_WRITE)

///////////////////////////////////////////////////////////////////////
// strings

// special classes

extern PWSTR g_wzRootDSE;
extern PWSTR g_wzSchemaNamingContext;
extern PWSTR g_wzLDAPAbstractSchemaFormat;


// fwd decl
class CAdsiObject;
class CErrorMessageHandlerBase;

///////////////////////////////////////////////////////////////////////
// CWString

class CWString : public wstring
{
public:
  operator LPCWSTR() { return c_str(); }
  CWString& operator=(LPCWSTR lpsz)
  {
    if (lpsz == NULL)
      lpsz = L"";
    *((wstring*)this) = lpsz;
    return *this;
  }
  BOOL LoadFromResource(UINT uID);
};


///////////////////////////////////////////////////////////////////////
// GLOBAL FUNCTIONS


BOOL LoadStringHelper(UINT uID, LPTSTR lpszBuffer, int nBufferMax);

BOOL GetStringFromHRESULTError(HRESULT hr, CWString& szErrorString, BOOL bTryADsIErrors = TRUE);
BOOL GetStringFromWin32Error(DWORD dwErr, CWString& CWString);

inline HRESULT ADsOpenObjectHelper(LPCWSTR lpszPathName, REFIID riid,DWORD dwFlags, void** ppObject)
{
  static DWORD additionalFlags = GetADsOpenObjectFlags();

  dwFlags |= additionalFlags;
  dwFlags |= ADS_SECURE_AUTHENTICATION;


  return ADsOpenObject((LPWSTR)lpszPathName,
                        NULL, //LPWSTR lpszUserName,
                        NULL, //LPWSTR lpszPassword,
                        dwFlags, //DWORD  dwReserved,
                        riid,    
                        ppObject
                        );
}



HRESULT InitCheckAccess( HWND hwndParent, LPCWSTR pszObjectLADPPath );


// functions to access DSSEC.DAT
ULONG GetClassFlags(LPCWSTR lpszClassName);
ULONG GetAttributeFlags(LPCWSTR lpszClassName, LPCWSTR lpszAttr);

void BuildLdapPathHelper(LPCWSTR lpszServerName, LPCWSTR lpszNamingContext, CWString& szLdapPath);
void BuildWin32PathHelper(LPCWSTR lpszServerName, LPCWSTR lpszNamingContext, CWString& szWin32Path);

HRESULT GetCanonicalNameFromNamingContext(LPCWSTR lpszNamingContext, CWString& szCanonicalName);

HRESULT GetGlobalNamingContexts(LPCWSTR lpszServerName, 
                                CWString& szPhysicalSchemaNamingContext,
                                CWString& szConfigurationNamingContext);


extern LPCWSTR g_lpszSummaryIdent;
extern LPCWSTR g_lpszSummaryNewLine;

void WriteSummaryTitleLine(CWString& szSummary, UINT nTitleID, LPCWSTR lpszNewLine);
void WriteSummaryLine(CWString& szSummary, LPCWSTR lpsz, LPCWSTR lpszIdent, LPCWSTR lpszNewLine);

DWORD AddObjectRightInAcl(IN      PSID pSid, 
                          IN      ULONG uAccess, 
                          IN      const GUID* pRightGUID, 
                          IN      const GUID* pInheritGUID, 
                          IN OUT  PACL* ppAcl);

///////////////////////////////////////////////////////////////////////
//////////////////////////// HELPER CLASSES ///////////////////////////



///////////////////////////////////////////////////////////////////////
// CWaitCursor

class CWaitCursor
{
public:
  CWaitCursor()
  {
    m_hCurrentCursor = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
  }
  ~CWaitCursor()
  {
    ::SetCursor(m_hCurrentCursor);
  }
private:
  HCURSOR m_hCurrentCursor;
};




BOOL FormatStringGUID(LPWSTR lpszBuf, UINT nBufSize, const GUID* pGuid);

BOOL GuidFromString(GUID* pGuid, LPCWSTR lpszGuidString);

///////////////////////////////////////////////////////////////////////
// CFilterBase

class CFilterBase
{
public:
  virtual BOOL CanAdd(LPCWSTR lpsz, ULONG* pFilterFlags) = 0;
};

///////////////////////////////////////////////////////////////////////
// CSidHolder

class CSidHolder
{
public:
  CSidHolder()
  {
    _Init();
  }
  ~CSidHolder()
  {
    _Free();
  }
  
  PSID Get()
  {
    return m_pSID;
  }

  BOOL Copy(PSID p)
  {
    _Free();
    return _Copy(p);
  }

  void Attach(PSID p, BOOL bLocalAlloc)
  {
    _Free();
    m_pSID = p;
    m_bLocalAlloc = bLocalAlloc;
  }

private:
  void _Init()
  {
    m_pSID = NULL;
    m_bLocalAlloc = TRUE;
  }

  void _Free()
  {
    if (m_pSID != NULL)
    {
      if (m_bLocalAlloc)
        ::LocalFree(m_pSID);
      else
        ::FreeSid(m_pSID);
      _Init();
    }
  }

  BOOL _Copy(PSID p)
  {
    if ( (p == NULL) || !::IsValidSid(p) )
      return FALSE;
    DWORD dwLen = ::GetLengthSid(p);
    PSID pNew = ::LocalAlloc(LPTR, dwLen);
    if(!pNew)
        return FALSE;   
    if (!::CopySid(dwLen, pNew, p))
    {
      ::LocalFree(pNew);
      return FALSE;
    }
    m_bLocalAlloc = TRUE;
    m_pSID = pNew;
    ASSERT(dwLen == ::GetLengthSid(m_pSID));
    ASSERT(memcmp(p, m_pSID, dwLen) == 0);
    return TRUE;
  }

  PSID m_pSID;
  BOOL m_bLocalAlloc;
};




///////////////////////////////////////////////////////////////////////
// CPrincipal

class CPrincipal
{
public:
	CPrincipal() 
  { 
    m_hClassIcon = NULL;
  }

  HRESULT Initialize(PDS_SELECTION pDsSelection, HICON hClassIcon);

  HRESULT Initialize (PSID psid);

  BOOL IsEqual(CPrincipal* p);


  PSID GetSid()
  {
    return m_sidHolder.Get();
  }

  LPCWSTR GetClass()
  {
    return m_szClass;
  }

  HICON GetClassIcon()
  {
    return m_hClassIcon;
  }

  LPCWSTR GetDisplayName()
  {
    return m_szDisplayName;
  }

private:
  void _ComposeDisplayName();

  // names
  CWString m_szName; // e.g. "JoeB"
  CWString m_szADsPath; //e.g. "WINNT://FOODOM/JoeB"
  CWString m_szUPN; // e.g. "JoeB@foo.com."
  CWString m_szClass; // e.g. "user"

  CWString m_szDisplayName; // generated, to be shown into the UI

  // other data
  HICON m_hClassIcon;       // icon handle
  CSidHolder m_sidHolder;   // PSID holder
};


///////////////////////////////////////////////////////////////////////
// CPrincipalList


class CPrincipalList : public CPtrList<CPrincipal*>
{
public:
  CPrincipalList(BOOL bOwnMem = TRUE) : CPtrList<CPrincipal*>(bOwnMem) 
  {
  }
  BOOL AddIfNotPresent(CPrincipal* p);
  void WriteSummaryInfo(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine);
};



///////////////////////////////////////////////////////////////////////
// CBasicRightInfo

class CBasicRightInfo
{
public:
  CBasicRightInfo()
  {
    m_fAccess = 0x0;
    m_bSelected = FALSE;
  }

  LPCWSTR GetDisplayName() { return m_szDisplayName; }
  ULONG GetAccess() { return m_fAccess; }

  BOOL IsSelected() { return m_bSelected; }
  void Select(BOOL b) { m_bSelected = b; }

protected:
  CWString m_szDisplayName;
  ULONG m_fAccess;
private:
  BOOL m_bSelected;
};


///////////////////////////////////////////////////////////////////////
// CAccessRightInfo

class CTemplateAccessPermissionsHolder; // fwd decl
class CCustomAccessPermissionsHolder; // fwd decl

class CAccessRightInfo : public CBasicRightInfo
{
  friend class CTemplateAccessPermissionsHolder;
  friend class CCustomAccessPermissionsHolder;
};

///////////////////////////////////////////////////////////////////////
// CAccessRightInfoArray


class CAccessRightInfoArray : public CGrowableArr<CAccessRightInfo>
{
};
  

///////////////////////////////////////////////////////////////////////
// CControlRightInfo

class CControlRightInfoArray; //fwd decl

class CControlRightInfo : public CBasicRightInfo
{
public:
  CControlRightInfo()
  {
    ZeroMemory(&m_rightsGUID, sizeof (GUID));
  }

  const GUID* GetRightsGUID() { return &m_rightsGUID;}
  LPCWSTR GetLdapDisplayName() { return m_szLdapDisplayName; }
  LPCWSTR GetLocalizedName() { return m_szLocalizedName; }

  BOOL IsPropertySet() 
  { 
    return ((m_fAccess & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)) != 0);
  }

  void SetLocalizedName(UINT nLocalizationDisplayId, HMODULE hModule);

private:
  GUID m_rightsGUID;
  CWString m_szLdapDisplayName; // this is from the schema, not localized
  CWString m_szLocalizedName;   // this is obtained from NTMARTA

  friend class CControlRightInfoArray;
};

///////////////////////////////////////////////////////////////////////
// CControlRightInfoArray 

class CControlRightInfoArray : public CGrowableArr<CControlRightInfo>
{
public:
  HRESULT InitFromDS(CAdsiObject* pADSIObj,
                         const GUID* pSchemaIDGUID);
};


///////////////////////////////////////////////////////////////////////
// CSchemaObjectInfo

class CSchemaObjectInfo
{
public:
	CSchemaObjectInfo(LPCWSTR lpszName)
	{
        m_bFilter = FALSE;
        if (lpszName != NULL)
        m_szName = lpszName;

        ZeroMemory(&m_schemaIDGUID, sizeof(GUID));
    }
	virtual ~CSchemaObjectInfo()
	{ 
	}

  void SetDisplayName(LPCWSTR lpszDisplayName) 
  { 
    //TRACE(_T("SetDisplayName(%s)\n"),lpszDisplayName); 
    m_szDisplayName = (lpszDisplayName != NULL) ? lpszDisplayName : m_szName;
    //TRACE(_T("m_szDisplayName = (%s)\n"),m_szDisplayName.c_str()); 
  }
  LPCWSTR GetName()
  { 
    return (m_szName.data()[0] == NULL) ? NULL : m_szName.c_str();
  }
  LPCWSTR GetDisplayName() 
  { 
    //TRACE(_T("GetDisplayName() m_szName = (%s) m_szDisplayName = (%s)\n"),
    //  m_szName.c_str(), m_szDisplayName.c_str()); 
    return (m_szDisplayName.data()[0] == NULL) ? NULL : m_szDisplayName.c_str();
  }

  const GUID* GetSchemaGUID()
  {
    return &m_schemaIDGUID;
  }

  bool operator<(CSchemaObjectInfo& x) 
  { 
    if ((GetDisplayName() == NULL) || (x.GetDisplayName() == NULL))
      return false;
    return (_wcsicmp(GetDisplayName(), x.GetDisplayName()) < 0);
  }

  void SetFiltered() { m_bFilter = TRUE;}
  BOOL IsFiltered() { return m_bFilter;}

protected:
  BOOL m_bFilter;
  CWString m_szName;
  CWString m_szDisplayName;
  GUID m_schemaIDGUID;

};

//////////////////////////////////////////////////////////////////////
// CPropertyRightInfo

class CPropertyRightInfoArray; // fwd decl

class CPropertyRightInfo : public CSchemaObjectInfo
{
public:
  CPropertyRightInfo(ULONG filterFlags, LPCWSTR lpszName) 
    : CSchemaObjectInfo(lpszName)
  {
    //TRACE(_T("CPropertyRightInfo(0x%x, %s)\n"),filterFlags, lpszName);
    m_FilterFlags = filterFlags;
    m_nRightCount = m_nRightCountMax;
    if (m_FilterFlags & IDC_PROP_NO_READ)
      m_nRightCount--;
    if (m_FilterFlags & IDC_PROP_NO_WRITE)
      m_nRightCount--;

    ASSERT(m_nRightCount > 0);
    m_Access = 0x0;
  }
  ~CPropertyRightInfo() {}

  static const ULONG m_nRightCountMax;
  static const ULONG m_nReadIndex;
  static const ULONG m_nWriteIndex;

  LPCWSTR GetRightDisplayString(ULONG iRight);
  void SetRight(ULONG iRight, BOOL b);
  ULONG GetRight(ULONG iRight);
  BOOL IsRightSelected(ULONG iRight);
  ULONG GetAccess() { return m_Access;}
  void AddAccessRight(ULONG uRight) { m_Access |= uRight;}
  ULONG GetRightCount() { return m_nRightCount;}

private:
  ULONG m_nRightCount;
  ULONG m_FilterFlags;
  ULONG m_Access;

  friend class CPropertyRightInfoArray;
};

//////////////////////////////////////////////////////////////////////
// CPropertyRightInfoArray

class CPropertyRightInfoFilter : public CFilterBase
{
public:
  virtual BOOL CanAdd(LPCWSTR lpsz, ULONG* pFilterFlags)
  {
    *pFilterFlags = ::GetAttributeFlags(m_szClassName, lpsz);
    if (*pFilterFlags == 0)
      return TRUE; // have no info, so add anyway
    if ((*pFilterFlags & IDC_PROP_NO) == IDC_PROP_NO)
      return FALSE; // have all the hide flags set
    return TRUE; // some of the hide flags not set

  }
  void SetClassName(LPCWSTR lpszClassName)
  {
    if (lpszClassName == NULL)
      m_szClassName = L"";
    else
      m_szClassName = lpszClassName;
  }
private:
  CWString m_szClassName;
};


class CPropertyRightInfoArray : public CGrowableArr<CPropertyRightInfo>
{
public:
  HRESULT InitFromSchema(CAdsiObject* pADSIObj, IADsClass* pDsSchemaClass, 
                         LPCWSTR lpszClassName, BOOL bUseFilter);
};

//////////////////////////////////////////////////////////////////////
// CClassRightInfo

class CClassRightInfoArray; // fwd decl.

class CClassRightInfo : public CSchemaObjectInfo
{
public:
  CClassRightInfo(ULONG filterFlags, LPCWSTR lpszName)
    : CSchemaObjectInfo(lpszName)
  {
    //TRACE(_T("CClassRightInfo(0x%x, %s)\n"),filterFlags, lpszName);

    m_FilterFlags = filterFlags;
    m_nRightCount = m_nRightCountMax;
    if (m_FilterFlags & IDC_CLASS_NO_CREATE)
      m_nRightCount--;
    if (m_FilterFlags & IDC_CLASS_NO_DELETE)
      m_nRightCount--;

    // REVIEW_MARCOC: do we need this?
    //if (m_FilterFlags & IDC_CLASS_NO_INHERIT)
    //  m_nRightCount--;

    ASSERT(m_nRightCount > 0);
    m_Access = 0x0;
  }
  ~CClassRightInfo() {}

  static const ULONG m_nRightCountMax;
  static const ULONG m_nCreateIndex;
  static const ULONG m_nDeleteIndex;

  LPCWSTR GetRightDisplayString(ULONG iRight);
  void SetRight(ULONG iRight, BOOL b);
  ULONG GetRight(ULONG iRight);
  BOOL IsRightSelected(ULONG iRight);
  ULONG GetAccess() { return m_Access;}
  void AddAccessRight(ULONG uRight) { m_Access |= uRight;}
  ULONG GetRightCount() { return m_nRightCount;}

private:
  ULONG m_nRightCount;
  ULONG m_FilterFlags;
  ULONG m_Access;

  friend class CClassRightInfoArray;

};

//////////////////////////////////////////////////////////////////////
// CClassRightInfoArray

class CClassRightInfoFilter : public CFilterBase
{
public:
  virtual BOOL CanAdd(LPCWSTR lpsz, ULONG* pFilterFlags)
  {
    *pFilterFlags = ::GetClassFlags(lpsz);
    if (*pFilterFlags == 0)
      return TRUE; // have no info, so add anyway
    if ((*pFilterFlags & IDC_CLASS_NO) == IDC_CLASS_NO)
      return FALSE; // have all the hide flags set
    return TRUE; // some of the hide flags not set
  }
};

class CClassRightInfoArray : public CGrowableArr<CClassRightInfo>
{
public:
  HRESULT InitFromSchema(CAdsiObject* pADSIObj, IADsClass* pDsSchemaClass, BOOL bUseFilter);
};


///////////////////////////////////////////////////////////////////////
// CSchemaClassInfo
#define CHILD_CLASS_NOT_EXIST   1
#define CHILD_CLASS_EXIST       2
#define CHILD_CLASS_NOT_CALCULATED  3

class CSchemaClassInfo : public CSchemaObjectInfo
{
public:
  CSchemaClassInfo(LPCWSTR lpszName, LPCWSTR lpszSchemaClassName,
                                     const GUID* pSchemaIDGUID)
                  : CSchemaObjectInfo(lpszName)
  { 
    m_szSchemaClassName = lpszSchemaClassName;
    m_schemaIDGUID = *pSchemaIDGUID;
    m_dwChildClass = CHILD_CLASS_NOT_CALCULATED;
    m_bSelected = FALSE;
	m_bAux = FALSE;
  }

  ~CSchemaClassInfo()
  {
  }

  VOID SetAux(){m_bAux=TRUE;}
  BOOL IsAux(){return m_bAux;}
  BOOL	m_bSelected;
  DWORD m_dwChildClass;
  LPCWSTR GetSchemaClassName() { return m_szSchemaClassName; }
private:
  CWString m_szSchemaClassName;
   BOOL  m_bAux;
};


////////////////////////////////////////////////////////////////////////
// CRigthsListViewItem

class CRigthsListViewItem
{
public:
  enum rightType { access, ctrl, prop, subobj };

  CRigthsListViewItem(ULONG iIndex, ULONG iRight, rightType type)
  {
    m_type = type;
    m_iIndex = iIndex;
    m_iRight = iRight;
  }

public:
  rightType m_type;
  ULONG m_iIndex;
  ULONG m_iRight;
};

typedef CGrowableArr<CRigthsListViewItem> CRigthsListViewItemArray;




///////////////////////////////////////////////////////////////////////
// CAccessPermissionsHolderBase

class CAccessPermissionsHolderBase
{
public:
  CAccessPermissionsHolderBase(BOOL bUseFilter);
  virtual ~CAccessPermissionsHolderBase();

  void Clear();

  // entry manipulation functions
  size_t GetTotalCount() 
  { 
    return m_accessRightInfoArr.GetCount() + m_controlRightInfoArr.GetCount()
      + m_propertyRightInfoArray.GetCount() + m_classRightInfoArray.GetCount();
  }

  BOOL HasPermissionSelected();
  
  // backend DS operations
  HRESULT ReadDataFromDS(CAdsiObject* pADSIObj,
                       LPCWSTR lpszObjectNamingContext,
                       LPCWSTR lpszClassName,
                       const GUID* pSchemaIDGUID,
                       BOOL bChildClass,
					   BOOL bHideListObject = FALSE);

  DWORD UpdateAccessList( CPrincipal* pPrincipal,
								          CSchemaClassInfo* pClassInfo,
                          LPCWSTR lpszServerName,
                          LPCWSTR lpszPhysicalSchemaNamingContext,
								          PACL* ppAcl);
protected:

  // standard access rigths
  CAccessRightInfoArray m_accessRightInfoArr; 
  virtual HRESULT _LoadAccessRightInfoArrayFromTable( BOOL bCreateDeleteChild,BOOL bHideListObject) = 0;

  // extended access rigths
  CControlRightInfoArray m_controlRightInfoArr;  


  // array of property rights
  CPropertyRightInfoArray	m_propertyRightInfoArray;

  // array of class rights
  CClassRightInfoArray	m_classRightInfoArray;

  // array of selections in the UI
  BOOL* m_pbSelectedArr;                // selected?

private:

  BOOL m_bUseFilter;

  HRESULT _ReadClassInfoFromDS(CAdsiObject* pADSIObj, LPCWSTR lpszClassName);
  
  DWORD _UpdateAccessListHelper(PSID pSid,
                         const GUID* pClassGUID,
                         PACL *ppAcl,
                         BOOL bChildClass);

};




///////////////////////////////////////////////////////////////////////
// CCustomAccessPermissionsHolder


// bitfields to keep track of the filtering state
#define FILTER_EXP_GEN    0x1
#define FILTER_EXP_PROP   0x2
#define FILTER_EXP_SUBOBJ 0x4
#define FILTER_EXP_GEN_DISABLED 0x8


class CCheckListViewHelper; // fwd decl

class CCustomAccessPermissionsHolder : public CAccessPermissionsHolderBase
{
public:
  CCustomAccessPermissionsHolder();
  virtual ~CCustomAccessPermissionsHolder();

  void Clear();

  // entry manipulation functions

  void Select(IN CRigthsListViewItem* pItem,
              IN BOOL bSelect,
              OUT ULONG* pnNewFilterState);

  void FillAccessRightsListView(
                       CCheckListViewHelper* pListViewHelper, 
                       ULONG nFilterState);

  void UpdateAccessRightsListViewSelection(
                       CCheckListViewHelper* pListViewHelper, 
                       ULONG nFilterState);

  // display finish page summary info
  void WriteSummary(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine);

protected:
  virtual HRESULT _LoadAccessRightInfoArrayFromTable(BOOL bCreateDeleteChild,BOOL bHideListObject);

private:
  
  // helper functions to do selection and deselection
  void _SelectAllRigths();
  void _SelectAllPropertyRigths(ULONG fAccessPermission);
  void _SelectAllSubObjectRigths(ULONG fAccessPermission);
  void _DeselectAssociatedRights(ULONG fAccessPermission);

  // array of listview items, for indexing
  CRigthsListViewItemArray m_listViewItemArr;

};



///////////////////////////////////////////////////////////////////////
// CCheckListViewHelper

class CCheckListViewHelper
{
public:
	static BOOL CheckChanged(NM_LISTVIEW* pNMListView);
	static BOOL IsChecked(NM_LISTVIEW* pNMListView);

	CCheckListViewHelper()
	{
		m_hWnd = NULL;
	}

	BOOL Initialize(UINT nID, HWND hParent);
	int InsertItem(int iItem, LPCTSTR lpszText, LPARAM lParam, BOOL bCheck);
	BOOL SetItemCheck(int iItem, BOOL bCheck);
	void SetCheckAll(BOOL bCheck);
	LPARAM GetItemData(int iItem);
  BOOL IsItemChecked(int iItem);
	int GetCheckCount();
	void GetCheckedItems(int nCheckCount, int* nCheckArray);

	BOOL GetCheckState(int iItem)
	{
		return ListView_GetCheckState(m_hWnd,iItem);
	}
	int GetItemCount()
	{
		return ListView_GetItemCount(m_hWnd);
	}

	BOOL DeleteAllItems()
	{
		return ListView_DeleteAllItems(m_hWnd);
	}
	void EnableWindow(BOOL bEnable)
	{
		::EnableWindow(m_hWnd, bEnable);
	}
private:
	HWND m_hWnd;
};

////////////////////////////////////////////////////////////////////////////
// CNamedSecurityInfo
/*
class CNamedSecurityInfo
{
public:
  CNamedSecurityInfo()
  {
    m_pAuditList = NULL;
    m_pOwner = NULL;
    m_pGroup = NULL;

    m_pAccessList = NULL;
  }
  ~CNamedSecurityInfo()
  {
    Reset();
  }

  DWORD Get();
  DWORD Set();
  void Reset();

private:
  CWString m_szObjectName; // name of the object

 	// the following varables are just read and written back
	// i.e. no modification
  PACTRL_AUDIT m_pAuditList;
  LPWSTR m_pOwner;
  LPWSTR m_pGroup;

  // list to be edited and written back
  PACTRL_ACCESS m_pAccessList;

};
*/

////////////////////////////////////////////////////////////////////////////
// CAdsPathNameObj

class CAdsPathNameObj
{
public:
  CAdsPathNameObj(){}
  ~CAdsPathNameObj(){ m_spADsPath = NULL;}

  HRESULT SkipPrefix(LPCWSTR pwzObj, BSTR* pBstr)
  {
    HRESULT hr = _Create();
    if (FAILED(hr))
  	  return hr;

    hr = m_spADsPath->Set(CComBSTR (pwzObj), ADS_SETTYPE_FULL);
    if (FAILED(hr))
  	  return hr;

    hr = m_spADsPath->Retrieve(ADS_FORMAT_X500_DN, pBstr);
    return hr;
  }
  HRESULT SkipPrefix(LPCWSTR pwzObj, CWString& str)
  {
    CComBSTR b;
    HRESULT hr = SkipPrefix(pwzObj, &b);
    if (FAILED(hr))
    {
      str = L"";
    }
    else
    {
      str = b;
    }
    return hr;
  }
  HRESULT GetProvider(LPCWSTR pwzObj, BSTR* pBstr)
  {
    HRESULT hr = _Create();
    if (FAILED(hr))
  	  return hr;

    hr = m_spADsPath->Set(CComBSTR (pwzObj), ADS_SETTYPE_FULL);
    if (FAILED(hr))
  	  return hr;

    hr = m_spADsPath->Retrieve(ADS_FORMAT_PROVIDER, pBstr);
    return hr;
  }

private:
  CComPtr<IADsPathname>		m_spADsPath;

  HRESULT _Create()
  {
    HRESULT hr = S_OK;
    if (m_spADsPath == NULL)
    {
      hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                            IID_IADsPathname, (PVOID *)&m_spADsPath);
    }
    return hr;
  }

};








////////////////////////////////////////////////////////////////////////////
// CAdsiObject

class CAdsiObject
{
public:
	CAdsiObject():m_iListObjectEnforced(-1)
	{ _Clear(); }
  virtual ~CAdsiObject(){}

  virtual HRESULT Bind(LPCWSTR lpszLdapPath);
  BOOL IsBound() { return m_spIADs != NULL; }
  HRESULT QuerySchemaClasses(CGrowableArr<CSchemaClassInfo>*	pSchemaClassesInfoArray,
                             BOOL bGetAttributes = FALSE);

  // accessor functions
  LPCWSTR GetLdapPath() { return m_szLdapPath; }
  LPCWSTR GetServerName() { return m_szServerName; }
  LPCWSTR GetNamingContext() { return m_szNamingContext; }
  LPCWSTR GetCanonicalName() { return m_szCanonicalName; }
  LPCWSTR GetClass() { return m_szClass; }
  LPCWSTR GetPhysicalSchemaNamingContext() { return m_szPhysicalSchemaNamingContext;}
  LPCWSTR GetConfigurationNamingContext() { return m_szConfigurationNamingContext;}

  // methods to access display specifiers
  HICON   GetClassIcon(LPCWSTR lpszObjectClass);
  HRESULT GetFriendlyClassName(LPCWSTR lpszObjectClass, 
                               LPWSTR lpszBuffer, int cchBuffer);
  HRESULT GetFriendlyAttributeName(LPCWSTR lpszObjectClass, 
                                   LPCWSTR lpszAttributeName,
                                   LPWSTR lpszBuffer, int cchBuffer);


  HRESULT GetClassGuid(LPCWSTR lpszClassLdapDisplayName, BOOL bGetAttribute, GUID& guid);

  CAdsPathNameObj* GetPathNameObject()
  {
    return &m_pathNameObject;
  }

  bool GetListObjectEnforced();

protected:
  CComPtr<IADs>                     m_spIADs;                 // pointer to ADSI object

private:

  int m_iListObjectEnforced;			
  CComPtr<IDsDisplaySpecifier>      m_spIDsDisplaySpecifier;  // pointer to Display Specifier Cache
  CAdsPathNameObj                   m_pathNameObject;         // path cracker object wrapper

  // cached naming strings
  CWString           m_szServerName;     // DNS name the object is bound to ("foo.bar.com.")
  CWString           m_szNamingContext;  // naming context (X500) ("cn=xyz,...");
	CWString						m_szLdapPath;		    // full LDAP path ("LDAP://foo.bar.com.\cn=xyz,...")
  CWString           m_szCanonicalName;  // name in canonical form
  CWString           m_szClass;          // class name in abstract schema, corresponding to 
                                        // LDAPDisplayName attribute in physical schema, 
                                        // (e.g. "organizationalUnit")

  // commonly used naming contexts
  CWString           m_szPhysicalSchemaNamingContext;
  CWString           m_szConfigurationNamingContext;

  void _Clear()
  {
    m_spIADs = NULL;
    m_spIDsDisplaySpecifier = NULL;
    m_szServerName = L"";
    m_szLdapPath = L"";
    m_szCanonicalName = L"";
    m_szClass = L"";

    m_szPhysicalSchemaNamingContext = L"";
    m_szConfigurationNamingContext = L"";
  }

  HRESULT _QueryDNSServerName();
  HRESULT _InitGlobalNamingContexts();

  HRESULT _GetFriendlyClassNames(CGrowableArr<CSchemaClassInfo>*	pSchemaClassesInfoArray);
  

};

////////////////////////////////////////////////////////////////////////////////////////
// CAdsiSearch

class CAdsiSearch
{
public:
  CAdsiSearch()
  {
    m_SearchHandle = NULL;
  }
  ~CAdsiSearch()
  {
    Reset();
  }

  HRESULT Init(LPCWSTR lpszObjectPath)
  {
    Reset();
    return ::ADsOpenObjectHelper(lpszObjectPath, IID_IDirectorySearch,0,
                    (void**)&m_spSearchObj);
  }

  void Reset()
  {
    if (m_spSearchObj != NULL) 
    {
      if (m_SearchHandle != NULL) 
      {
        m_spSearchObj->CloseSearchHandle(m_SearchHandle);
        m_SearchHandle = NULL;
      }
    }
    m_spSearchObj = NULL;
  }

  HRESULT SetSearchScope(ADS_SCOPEENUM scope)
  {
    if (m_spSearchObj == NULL)
      return E_ADS_BAD_PATHNAME;

    ADS_SEARCHPREF_INFO aSearchPref;
    aSearchPref.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    aSearchPref.vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref.vValue.Integer = scope;
    return m_spSearchObj->SetSearchPreference(&aSearchPref, 1);
  }

  HRESULT DoQuery(LPCWSTR lpszFilter, LPCWSTR* pszAttribsArr, const int cAttrs);

  HRESULT GetNextRow()
  {
    if (m_spSearchObj == NULL)
      return E_ADS_BAD_PATHNAME;
    return m_spSearchObj->GetNextRow(m_SearchHandle);
  }

  HRESULT GetColumn(LPCWSTR lpszAttribute,
                     PADS_SEARCH_COLUMN pColumnData)
  {
    if (m_spSearchObj == NULL)
      return E_ADS_BAD_PATHNAME;

    return m_spSearchObj->GetColumn(m_SearchHandle,
                              (LPWSTR)lpszAttribute,
                              pColumnData);
  }
  HRESULT FreeColumn(PADS_SEARCH_COLUMN pColumnData)
  {
    if (m_spSearchObj == NULL)
      return E_ADS_BAD_PATHNAME;
    return m_spSearchObj->FreeColumn(pColumnData);
  }

  HRESULT GetColumnString(LPCWSTR lpszAttribute,
                     CWString& szData)
  {
    ADS_SEARCH_COLUMN ColumnData;
    ::ZeroMemory (&ColumnData, sizeof (ADS_SEARCH_COLUMN));
    HRESULT hr = GetColumn(lpszAttribute, &ColumnData);
    if (SUCCEEDED(hr))
    {
      if (ColumnData.dwADsType == ADSTYPE_CASE_IGNORE_STRING)
        szData = ColumnData.pADsValues->CaseIgnoreString;
      else
      {
        szData = L"";
        hr = E_INVALIDARG;
      }
      FreeColumn(&ColumnData);
    }
    return hr;
  }

  HRESULT GetColumnOctectStringGUID(LPCWSTR lpszAttribute,
                     GUID& guid)
  {
    ADS_SEARCH_COLUMN ColumnData;
    ::ZeroMemory (&ColumnData, sizeof (ADS_SEARCH_COLUMN));
    HRESULT hr = GetColumn(lpszAttribute, &ColumnData);
    if (SUCCEEDED(hr))
    {
      if ( (ColumnData.dwADsType == ADSTYPE_OCTET_STRING) &&
            (ColumnData.pADsValues->OctetString.dwLength == 16) )
      {
        // we have a blob containing a GUID in binary form
        memcpy(&guid, ColumnData.pADsValues->OctetString.lpValue, sizeof(GUID));
      }
      else
      {
        guid = GUID_NULL;
        hr = E_INVALIDARG;
      }
      FreeColumn(&ColumnData);
    }
    return hr;
  }

  HRESULT GetColumnOctectStringGUID(LPCWSTR lpszAttribute,
                     CWString& szData)
  {
    GUID guid;
    szData = L"";
    HRESULT hr = GetColumnOctectStringGUID(lpszAttribute, guid);
    if (SUCCEEDED(hr))
    {
      WCHAR szBuf[128];
      if (FormatStringGUID(szBuf, 128, &guid))
      {
        szData = szBuf;
      }
      else
      {
        szData = L"";
        hr = E_INVALIDARG;
      }
    }
    return hr;
  }

  HRESULT GetColumnInteger(LPCWSTR lpszAttribute,
                        ULONG& uVal)
  {
    ADS_SEARCH_COLUMN ColumnData;
    ::ZeroMemory (&ColumnData, sizeof (ADS_SEARCH_COLUMN));
    HRESULT hr = GetColumn(lpszAttribute, &ColumnData);
    if (SUCCEEDED(hr))
    {
      if (ColumnData.dwADsType == ADSTYPE_INTEGER)
        uVal = ColumnData.pADsValues->Integer;
      else
        hr = E_INVALIDARG;
      FreeColumn(&ColumnData);
    }
    return hr;
  }

private:
  CComPtr<IDirectorySearch> m_spSearchObj;
  ADS_SEARCH_HANDLE  m_SearchHandle;

};

///////////////////////////////////////////////////////////////////////
// CErrorMessageHandlerBase

class CErrorMessageHandlerBase
{
public:
  CErrorMessageHandlerBase() {}
  virtual ~CErrorMessageHandlerBase() {}

  virtual void ReportHRESULTError(LPCWSTR lpszMsg, HRESULT hr) 
  {
      UNREFERENCED_PARAMETER (lpszMsg);
      UNREFERENCED_PARAMETER (hr);
  }
  virtual void ReportHRESULTError(UINT nStringID, HRESULT hr) 
  {
      UNREFERENCED_PARAMETER (nStringID);
      UNREFERENCED_PARAMETER (hr);
  }
};


DWORD
FormatStringID(LPTSTR *ppszResult, UINT idStr , ...);

   HRESULT
   SetSecInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si);

   HRESULT GetSDForDsObject(IDirectoryObject* pDsObject,
                           PACL* ppDACL,
                           PSECURITY_DESCRIPTOR* ppSD);

   HRESULT GetSDForDsObjectPath(LPCWSTR pszObjectPath,
                              PACL* ppDACL,
                              PSECURITY_DESCRIPTOR* ppSecurityDescriptor);

   HRESULT SetDaclForDsObject(IDirectoryObject* pDsObject,
                              PACL pDACL);

   HRESULT SetDaclForDsObjectPath(LPCWSTR pszObjectPath,
                                 PACL pDACL);


#endif // _UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\common\tempcore.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tempcore.h
//
//--------------------------------------------------------------------------


#ifndef _TEMPCORE_H
#define _TEMPCORE_H


#include "stlutil.h"



//////////////////////////////////////////////////////////////////////////////
// Keywords for the INF file format



extern LPCWSTR g_lpszTemplates;
extern LPCWSTR g_lpszDelegationTemplates;
extern LPCWSTR g_lpszDescription;
extern LPCWSTR g_lpszAppliesToClasses;

extern LPCWSTR g_lpszScope;
extern LPCWSTR g_lpszControlRight;
extern LPCWSTR g_lpszThisObject;
extern LPCWSTR g_lpszObjectTypes;
                          
////////////////////////////////////////////////////////////////////////////////


#define _GRANT_ALL \
  (STANDARD_RIGHTS_REQUIRED | ACTRL_DS_CONTROL_ACCESS | \
  ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD | ACTRL_DS_LIST | ACTRL_DS_SELF | \
  ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP | ACTRL_DS_DELETE_TREE | ACTRL_DS_LIST_OBJECT)






///////////////////////////////////////////////////////////////////////////////
// global functions


struct _ACCESS_BIT_MAP
{
  LPCWSTR lpsz;
  ULONG fMask;
};

const _ACCESS_BIT_MAP* GetTemplateAccessRightsMap();

void GetStringFromAccessMask(ULONG fAccessMask, wstring& szAccessMask);



///////////////////////////////////////////////////////////////////////////////
// CInfFile

class CInfFile
{
public:
  CInfFile()
  {
    m_InfHandle = INVALID_HANDLE_VALUE;
  }

  ~CInfFile()
  {
    Close();
  }
  BOOL Open(LPCWSTR lpszFile)
  {
    Close();
    UINT nErrorLine = 0;
    m_InfHandle = ::SetupOpenInfFile( lpszFile,  // PCTSTR FileName, // name of the INF to open
                                  NULL,             // PCTSTR InfClass, // optional, the class of the INF file
                                  INF_STYLE_WIN4,   // DWORD InfStyle,  // specifies the style of the INF file
                                  &nErrorLine       // PUINT ErrorLine  // optional, receives error information
                                );
  
    if (m_InfHandle == INVALID_HANDLE_VALUE)
    {
      TRACE(L"Failed to open file, line = %d\n", nErrorLine);
      return FALSE;
    }
    return TRUE;
  }
  void Close()
  {
    if(m_InfHandle != INVALID_HANDLE_VALUE)
    {
      ::SetupCloseInfFile(m_InfHandle);
      m_InfHandle = INVALID_HANDLE_VALUE;
    }
  }
  operator HINF() { return m_InfHandle; }
private:
  HINF m_InfHandle;
};


///////////////////////////////////////////////////////////////////////////////
// CInfBase

#define N_BUF_LEN 256

class CInfBase
{
public:
  CInfBase(HINF InfHandle)
  {
    //ASSERT(InfHandle != INVALID_HANDLE_VALUE);
    m_InfHandle = InfHandle;
    m_szBuf[0] = NULL;
  }
  LPCWSTR GetBuf() { return m_szBuf; }
protected:
  HINF m_InfHandle;
  WCHAR m_szBuf[N_BUF_LEN];
  
};



///////////////////////////////////////////////////////////////////////////////
// CInfLine

class CInfLine : public CInfBase
{
public:
  CInfLine(HINF InfHandle) : CInfBase(InfHandle)
  {
  }
  
  BOOL Bind(LPCWSTR lpszSection, LPCWSTR lpszKey)
  {
    DWORD dwRequiredSize;
    if (!SetupGetLineText(NULL, m_InfHandle, lpszSection, lpszKey, 
                         m_szBuf, N_BUF_LEN, &dwRequiredSize))
    {
      m_szBuf[0] = NULL;
      return FALSE;
    }
    return TRUE;
  }
};



///////////////////////////////////////////////////////////////////////////////
// CInfList

class CInfList : public CInfBase
{
public:
  CInfList(HINF InfHandle) : CInfBase(InfHandle)
  {
    m_iField = 0;
  }

  BOOL Bind(LPCWSTR lpszSection, LPCWSTR lpszKey)
  {
    if (SetupFindFirstLine(m_InfHandle, lpszSection, lpszKey, &m_Context))
    {
      m_iField = 1;
      return TRUE;
    }
    return FALSE;
  }

  BOOL MoveNext()
  {
    DWORD dwRequiredSize;
    if (!SetupGetStringField(&m_Context, m_iField, m_szBuf, N_BUF_LEN, &dwRequiredSize))
    {
      m_szBuf[0] = NULL;
      return FALSE;
    }
    m_iField++;
    return TRUE;
  }

private:
  INFCONTEXT m_Context;
  UINT m_iField;
};



///////////////////////////////////////////////////////////////////////////////
// CInfSectionKeys

class CInfSectionKeys : public CInfBase
{
public:
  CInfSectionKeys(HINF InfHandle) : CInfBase(InfHandle)
  {
    m_nLineCount = (ULONG) -1;
    m_iCurrLine = (ULONG) -1;
  }

  BOOL Bind(LPCWSTR lpszSection)
  {
    m_szSection = lpszSection ? lpszSection : L"";
    m_nLineCount = SetupGetLineCount(m_InfHandle, lpszSection);
    if (m_nLineCount <= 0)
    {
      return FALSE;
    }
    m_iCurrLine = 0;
    return TRUE;
  }

  BOOL MoveNext()
  {
    if (m_iCurrLine >= m_nLineCount)
    {
      return FALSE;
    }
    INFCONTEXT Context;
    if (!::SetupGetLineByIndex(m_InfHandle, m_szSection.c_str(), m_iCurrLine, &Context))
      return FALSE;

    DWORD dwRequiredSize;
    if (!::SetupGetStringField(&Context, 0, m_szBuf, N_BUF_LEN, &dwRequiredSize))
    {
      m_szBuf[0] = NULL;
      return FALSE;
    }
    m_iCurrLine++;
    return TRUE;
  }

private:
  LONG m_nLineCount;
  LONG m_iCurrLine;
  wstring m_szSection;
};








////////////////////////////////////////////////////////////////////////
// CTemplatePermission

class CTemplatePermission
{
public:
  CTemplatePermission()
  {
    m_szName = L"";
    m_fAccessMask = 0x0;
    m_szControlRight = L"";
  }


  void SetAccessMask(LPCWSTR lpszName, ULONG fAccessMask)
  {
    m_szName = lpszName;
    m_fAccessMask = fAccessMask;
    m_szControlRight = L"";
  }

  void SetControlRight(LPCWSTR lpszControlRight)
  {
    m_szName = L"";
    m_fAccessMask = 0x0;
    m_szControlRight = lpszControlRight;
  }

  LPCWSTR GetName() { return m_szName.c_str(); }
  LPCWSTR GetControlRight() { return m_szControlRight.c_str();}
  ULONG GetAccessMask() { return m_fAccessMask;}

#ifdef _DUMP
  void Dump()
  {
    wstring szAccessMask;
    GetStringFromAccessMask(GetAccessMask(), szAccessMask);
    TRACE(L"      Right: name = <%s> mask = 0x%x (%s) control right = <%s>\n", 
                                    GetName(),  GetAccessMask(), szAccessMask.c_str(), GetControlRight());
  
  }
#endif // _DUMP

private:
  wstring m_szName;

  ULONG m_fAccessMask;
  wstring m_szControlRight;
};



////////////////////////////////////////////////////////////////////////
// CTemplatePermissionList

class CTemplatePermissionList : public CPtrList<CTemplatePermission*>
{
public:
  CTemplatePermissionList(BOOL bOwnMem = TRUE) : CPtrList<CTemplatePermission*>(bOwnMem) 
  {
  }

};

////////////////////////////////////////////////////////////////////////
// CTemplateObjectType

class CTemplateObjectType
{
public:

  CTemplateObjectType(LPCWSTR lpszObjectName)
  {
    m_szObjectName = lpszObjectName;
  }
  
  LPCWSTR GetObjectName() { return m_szObjectName.c_str(); }
  CTemplatePermissionList* GetPermissionList() { return &m_permissionList; }

#ifdef _DUMP
  void Dump()
  {
    TRACE(L"    ObjectType: <%s>\n", GetObjectName());
    m_permissionList.Dump();
  }
#endif // _DUMP

private:
  wstring m_szObjectName;
  CTemplatePermissionList m_permissionList;
};

////////////////////////////////////////////////////////////////////////
// CTemplateObjectTypeList

class CTemplateObjectTypeList : public CPtrList<CTemplateObjectType*>
{
public:
  CTemplateObjectTypeList(BOOL bOwnMem = TRUE) : CPtrList<CTemplateObjectType*>(bOwnMem) 
  {
  }
};


class CTemplateObjectTypeListRef : public CTemplateObjectTypeList
{
public:
  CTemplateObjectTypeListRef() : CTemplateObjectTypeList(FALSE) {}
};



////////////////////////////////////////////////////////////////////////
// CTemplate

class CTemplate
{
public:

  CTemplate(LPCWSTR lpszDescription)
  {
    m_szDescription = lpszDescription;
    m_bSelected = FALSE;
  }

  LPCWSTR GetDescription() { return m_szDescription.c_str(); }
  CTemplateObjectTypeList* GetObjectTypeList() { return &m_objectTypeList; }

  void AddAppliesToClass(LPCWSTR lpszClass)
  {
    m_appliestToClassesList.push_back(lpszClass);
  }

  BOOL AppliesToClass(LPCWSTR lpszClass)
  {
    if (m_appliestToClassesList.size() == 0)
    {
      // no classes, applies to all
      return TRUE;
    }

    // some classes on the list
    list<wstring>::iterator i;
    for (i = m_appliestToClassesList.begin(); i != m_appliestToClassesList.end(); ++i)
    {
      if (wcscmp((*i).c_str(), lpszClass) == 0)
      {
        return TRUE;
      }
    }
    return FALSE;
  }

#ifdef _DUMP
  void Dump()
  {
    TRACE(L"\n  Template Description: <%s>\n", GetDescription());

    if (m_appliestToClassesList.size() > 0)
    {
      list<wstring>::iterator i;
      TRACE(L"  Applies To Classes: ");
      for (i = m_appliestToClassesList.begin(); i != m_appliestToClassesList.end(); ++i)
      {
        TRACE(L"<%s>", (*i).c_str());
      }
      TRACE(L"\n");
    }
    m_objectTypeList.Dump();
    
  }
#endif // _DUMP


public:
  BOOL m_bSelected;

private:
  wstring m_szDescription;
  CTemplateObjectTypeList m_objectTypeList;
  list<wstring> m_appliestToClassesList;
};


////////////////////////////////////////////////////////////////////////
// CTemplateList

class CTemplateList : public CPtrList<CTemplate*>
{
public:
  CTemplateList(BOOL bOwnMem = TRUE) : CPtrList<CTemplate*>(bOwnMem) 
  {
  }
};



////////////////////////////////////////////////////////////////////////
// CTemplateManager

class CTemplateManager
{
public:
  CTemplateManager()
  {
  }
  CTemplateList* GetTemplateList() { return &m_templateList; }

  BOOL Load(LPCWSTR lpszFileName)
  {
    TRACE(L"CTemplateManager::Load(%s)\n", lpszFileName);
    m_templateList.Clear();
    CInfFile file;
    if (!file.Open(lpszFileName))
    {
      TRACE(L"CTemplateManager::Load(%s) failed on INF file open\n", lpszFileName);
      return FALSE;
    }
  
    return _LoadTemplateList(file);
  }

#ifdef _DUMP
  void Dump()
  {
    TRACE(L"TEMPLATE LIST DUMP BEGIN\n");
    m_templateList.Dump();
    TRACE(L"TEMPLATE LIST DUMP END\n");
  }
#endif // _DUMP

  BOOL HasTemplates(LPCWSTR lpszClass);
  BOOL HasSelectedTemplates();
  void DeselectAll();


private:
  HRESULT _LoadTemplatePermission(HINF InfHandle, 
                               LPCWSTR lpszPermissionSection, 
                               LPCWSTR lpszPermission,
                               CTemplateObjectType* pObjectType);

  HRESULT _LoadTemplatePermissionsSection(HINF InfHandle, 
                                       LPCWSTR lpszTemplateName,
                                       LPCWSTR lpszObject,
                                       CTemplate* pTemplate);
  void _LoadTemplate(HINF InfHandle, LPCWSTR lpszTemplateName);
  BOOL _LoadTemplateList(HINF InfHandle);


  CTemplateList m_templateList;
};

#endif // _TEMPCORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\common\_deltemp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       _deltemp.cpp
//
//--------------------------------------------------------------------------


///////////////////////////////////////////////////////////////////////
// LOCAL FUNCTIONS

CSchemaClassInfo* _FindClassByName(LPCWSTR lpszClassName, 
                                 CGrowableArr<CSchemaClassInfo>* pSchemaClassesInfoArray)
{
  int nCount = (int) pSchemaClassesInfoArray->GetCount();
  for (int k=0; k < nCount; k++)
	{
    if (wcscmp(lpszClassName, (*pSchemaClassesInfoArray)[k]->GetName()) == 0)
      return (*pSchemaClassesInfoArray)[k];
  }
  TRACE(L"_FindClassByName(%s) failed\n", lpszClassName);
  return NULL;
}



///////////////////////////////////////////////////////////////////////
// LOCAL CLASSES

////////////////////////////////////////////////////////////////////////
// CTemplateClassReferences

class CTemplateClassReferences
{
public:
  CTemplateClassReferences()
  {
    m_pClassInfo = NULL;
    m_bScopeClass = FALSE;
  }
  CSchemaClassInfo* m_pClassInfo;
  BOOL m_bScopeClass;
  CTemplateObjectTypeListRef m_templateObjectListRef;
};

////////////////////////////////////////////////////////////////////////
// CTemplateClassReferencesList

class CTemplateClassReferencesList : public CPtrList<CTemplateClassReferences*>
{
public:
  CTemplateClassReferencesList() : 
      CPtrList<CTemplateClassReferences*>(FALSE) 
  {
  }
  
  CTemplateClassReferences* FindReference(LPCWSTR lpszClassName)
  {
    CTemplateClassReferencesList::iterator i;
    for (i = begin(); i != end(); ++i)
    {
      CTemplateClassReferences* p = (*i);
      ASSERT(p != NULL);
      if (p->m_pClassInfo != NULL)
      {
        if (wcscmp(p->m_pClassInfo->GetName(),lpszClassName) == 0)
        {
          return p;
        }
      }
    }

    return NULL;
  }
  

};


///////////////////////////////////////////////////////////////////////
// CTemplateAccessPermissionsHolder

CTemplateAccessPermissionsHolder::CTemplateAccessPermissionsHolder(CSchemaClassInfo* pClassInfo,
                                                                   BOOL bScopeClass)
            : CAccessPermissionsHolderBase(FALSE)
{
  ASSERT(pClassInfo != NULL);
  m_pClassInfo = pClassInfo;
  m_bScopeClass = bScopeClass;
}

CTemplateAccessPermissionsHolder::~CTemplateAccessPermissionsHolder()
{
  Clear();
}


HRESULT CTemplateAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable( BOOL /*bIgnore*/ ,BOOL /*bIgnore*/)
{

  TRACE(L"\nCTemplateAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable()\n\n");

  for(_ACCESS_BIT_MAP* pCurrEntry = (_ACCESS_BIT_MAP*)GetTemplateAccessRightsMap(); 
                      pCurrEntry->lpsz != NULL; pCurrEntry++)
  {
    CAccessRightInfo* pInfo = new CAccessRightInfo();

    if( !pInfo )
      return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    pInfo->m_szDisplayName = pCurrEntry->lpsz;
    pInfo->m_fAccess = pCurrEntry->fMask;

    TRACE(L"Display Name = <%s>, Access = 0x%x\n", 
          pInfo->m_szDisplayName.c_str(), pInfo->m_fAccess);
    m_accessRightInfoArr.Add(pInfo);
  }

  TRACE(L"\nCTemplateAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable() exiting\n\n");
  return S_OK;
}


HRESULT CTemplateAccessPermissionsHolder::GetAccessPermissions(CAdsiObject* pADSIObj)
{
  ASSERT(m_pClassInfo != NULL);
  return ReadDataFromDS(pADSIObj, pADSIObj->GetNamingContext(), 
                        m_pClassInfo->GetName(),
                        m_pClassInfo->GetSchemaGUID(), TRUE);

}



BOOL CTemplateAccessPermissionsHolder::SetupFromClassReferences(CTemplateObjectTypeListRef* pRefList)
{
  ASSERT(pRefList != NULL);

  TRACE(L"\nStart setting up permission holder <%s> from template class references\n\n",
    m_pClassInfo->GetName());

    
  // now go through the list of object list references and set
  CTemplateObjectTypeListRef refListValidObjectTypes; // keep track of how many suceeded

  CTemplateObjectTypeListRef::iterator iObjectType;
  for (iObjectType = pRefList->begin(); iObjectType != pRefList->end(); ++iObjectType)
  {
    BOOL bSet = FALSE;
    CTemplateObjectType* pObjectType = (*iObjectType);
    ASSERT(pObjectType != NULL);

    CTemplatePermissionList* pPermissionList = pObjectType->GetPermissionList();
    CTemplatePermissionList::iterator iPermission;

    for (iPermission = pPermissionList->begin(); iPermission != pPermissionList->end(); ++iPermission)
    {
      CTemplatePermission* pTemplatePermission = (*iPermission);
      ASSERT(pTemplatePermission != NULL);

      // need to match the permission type
      if (pTemplatePermission->GetAccessMask() == 0x0)
      {
        // this is a control right
        if (_SetControlRight(pTemplatePermission->GetControlRight()))
        {
          bSet = TRUE;
        }
                         
      }
      else
      {
        if (_SetAccessMask(pTemplatePermission->GetName(),
                       pTemplatePermission->GetAccessMask()))
        {
          bSet = TRUE;
        }
      }
    } // for permission

    if (bSet)
    {
      // we succeded with the current one, so keep track of it
      refListValidObjectTypes.push_back(pObjectType);
    }

  } // for object type


  // verify we got something valid
  size_t nValidCount = refListValidObjectTypes.size();
  if (nValidCount == 0)
  {
    TRACE(L"Failed to set up permission holder: no valid references\n");
    return FALSE; // nothing was set
  }

  TRACE(L"Setting up permission holder succeeded\n");

  return TRUE; // got valid data
}


BOOL CTemplateAccessPermissionsHolder::_SetControlRight(LPCWSTR lpszControlRight)
{
  // need to find the control right and select it

  UINT nRightCount = (UINT) m_controlRightInfoArr.GetCount();
  for (UINT k=0; k < nRightCount; k++)
  {
    //TRACE(L"_SetControlRight() comparing <%s> with <%s>\n", m_controlRightInfoArr[k]->GetDisplayName(), lpszControlRight);

    //NOTICE: we try to map both the display name or raw display name,
    // just in case somebody uses one or the other in the template
    if ( (wcscmp(m_controlRightInfoArr[k]->GetLocalizedName(), lpszControlRight) == 0) ||
          (wcscmp(m_controlRightInfoArr[k]->GetLdapDisplayName(), lpszControlRight) == 0) )
    {
      TRACE(L"_SetControlRight(%s) found a match\n", lpszControlRight);
      m_controlRightInfoArr[k]->Select(TRUE);
      return TRUE;
    }
  } // for
  
  TRACE(L"_SetControlRight(%s) failed to find a match\n", lpszControlRight);
  return FALSE;
}

BOOL CTemplateAccessPermissionsHolder::_SetAccessMask(LPCWSTR lpszName, ULONG fAccessMask)
{
  // is it the @ for "this class"
  // general rights
  if (wcscmp(lpszName, g_lpszThisObject) == 0)
  {
    return _SetGeneralRighs(fAccessMask);
  }
  
  // try property rights ( read or write)
  if (_SetPropertyRight(lpszName, fAccessMask))
    return TRUE;

  // try subobject rigths (create or delete)
  if (_SetSubObjectRight(lpszName, fAccessMask))
    return TRUE;

  TRACE(L"_SetAccessMask(%s, 0x%x) failed to find a match\n", lpszName, fAccessMask);
  return FALSE; // no matching
}


BOOL CTemplateAccessPermissionsHolder::_SetGeneralRighs(ULONG fAccessMask)
{
  // if full control, just select the first item in the selection array
  if (fAccessMask == _GRANT_ALL)
  {
    TRACE(L"_SetGeneralRighs(0x%x) granting full control\n", fAccessMask);
    m_accessRightInfoArr[0]->Select(TRUE);
    return TRUE;
  }

  // try to map into the array of general rights
  BOOL bSet = FALSE;
  UINT nRightCount = (UINT) m_accessRightInfoArr.GetCount();
  for (ULONG k=0; k<nRightCount; k++)
  {
    if ((m_accessRightInfoArr[k]->GetAccess() & fAccessMask) == m_accessRightInfoArr[k]->GetAccess())
    {
      TRACE(L"_SetGeneralRighs(0x%x) granting %s (0x%x)\n", 
                                  fAccessMask, 
                                  m_accessRightInfoArr[k]->GetDisplayName(),
                                  m_accessRightInfoArr[k]->GetAccess());
      m_accessRightInfoArr[k]->Select(TRUE);
      bSet = TRUE;
    }
  } // for

  return bSet;
}

BOOL CTemplateAccessPermissionsHolder::_SetPropertyRight(LPCWSTR lpszName, ULONG fAccessMask)
{
  for (UINT i = 0; i < m_propertyRightInfoArray.GetCount(); i++)
  {
    if (wcscmp(lpszName, m_propertyRightInfoArray[i]->GetName()) == 0)
    {
      // we found a matching property name
      BOOL bSet = FALSE;
      for (UINT j=0; j< m_propertyRightInfoArray[i]->GetRightCount(); j++)
      {
        if ((fAccessMask & m_propertyRightInfoArray[i]->GetRight(j)) != 0) 
        {
          m_propertyRightInfoArray[i]->SetRight(j, TRUE);
          bSet = TRUE;
        }
      } // for j
      return bSet;
    } // if
  } // for i

  //TRACE(L"_SetPropertyRight(%s, 0x%x) failed to match\n", lpszName, fAccessMask);
  return FALSE; // did not find anything
}

BOOL CTemplateAccessPermissionsHolder::_SetSubObjectRight(LPCWSTR lpszName, ULONG fAccessMask)
{
  for (UINT i = 0; i < m_classRightInfoArray.GetCount(); i++)
  {
    if (wcscmp(lpszName, m_classRightInfoArray[i]->GetName()) == 0)
    {
      // we found a matching class name
      BOOL bSet = FALSE;
      for (UINT j=0; j< m_classRightInfoArray[i]->GetRightCount(); j++)
      {
        if ((fAccessMask & m_classRightInfoArray[i]->GetRight(j)) != 0)
        {
          // we found a matching right
          m_classRightInfoArray[i]->SetRight(j, TRUE);
          bSet = TRUE;
        }
      } // for j
      return bSet;
    } // if
  } // for i

  //TRACE(L"_SetSubObjectRight(%s, 0x%x) failed to match\n", lpszName, fAccessMask);
  return FALSE; // did not find anything
}





DWORD CTemplateAccessPermissionsHolder::UpdateAccessList(CPrincipal* pPrincipal,
                                                         LPCWSTR lpszServerName,
                                                         LPCWSTR lpszPhysicalSchemaNamingContext,
                                                         PACL *ppAcl )
{
  // just call base class function with the embedded info
  ASSERT(m_pClassInfo != NULL);

  CSchemaClassInfo* pClassInfo = m_pClassInfo;
  if (m_bScopeClass)
  {
    pClassInfo = NULL;
  }
  return CAccessPermissionsHolderBase::UpdateAccessList(pPrincipal, 
                                                        pClassInfo, 
                                                        lpszServerName,
                                                        lpszPhysicalSchemaNamingContext,
                                                        ppAcl);
}


///////////////////////////////////////////////////////////////////////
// CTemplateAccessPermissionsHolderManager


BOOL CTemplateAccessPermissionsHolderManager::LoadTemplates()
{
  // REVIEW_MARCOC: need to load from registry
  // need to ask Praerit about the details
  return m_templateManager.Load(L"delegwiz.inf");
}


BOOL CTemplateAccessPermissionsHolderManager::HasTemplates(LPCWSTR lpszClass) 
{
  return m_templateManager.HasTemplates(lpszClass);
}

BOOL CTemplateAccessPermissionsHolderManager::HasSelectedTemplates()  
{
   return m_templateManager.HasSelectedTemplates();
}

void CTemplateAccessPermissionsHolderManager::DeselectAll()
{
  m_templateManager.DeselectAll();
}


BOOL CTemplateAccessPermissionsHolderManager::
              InitPermissionHoldersFromSelectedTemplates(CGrowableArr<CSchemaClassInfo>* pSchemaClassesInfoArray,
                                                          CAdsiObject* pADSIObj)
{
  TRACE(L"\n\nInitPermissionHoldersFromSelectedTemplates()\n\n");

  // reset the array of permission holders
  m_permissionHolderArray.Clear();

  CTemplateClassReferencesList templateClassReferencesList;
  LPCWSTR lpszScopeClass = pADSIObj->GetClass();

  
  // loop on all templates that apply to this scope class and are selected
  CTemplateList::iterator iTemplate;
  CTemplateList* pTemplateList = m_templateManager.GetTemplateList();

  for (iTemplate = pTemplateList->begin(); iTemplate != pTemplateList->end(); ++iTemplate)
  {
    CTemplate* pTemplate = (*iTemplate);
    ASSERT(pTemplate != NULL);

    // the template must apply to this class and be selected
    if (pTemplate->AppliesToClass(lpszScopeClass) && pTemplate->m_bSelected)
    {
      // loop on all the pertinent object types in the template
      CTemplateObjectTypeList* pObjectTypeList = pTemplate->GetObjectTypeList();
      CTemplateObjectTypeList::iterator iObjectType;

      for (iObjectType = pObjectTypeList->begin(); 
                        iObjectType != pObjectTypeList->end(); ++iObjectType)
      {
        CTemplateObjectType* pObjectType = (*iObjectType);
        ASSERT(pObjectType != NULL);

        LPCWSTR lpszCurrentClassName = pObjectType->GetObjectName();

        // does the object type refer to the SCOPE keyword?
        BOOL bScopeClass = (wcscmp(g_lpszScope, lpszCurrentClassName) == 0);
        if (!bScopeClass)
        {
          // if not, does the object type refer to the scope class?
          bScopeClass = (wcscmp(lpszScopeClass, lpszCurrentClassName) == 0);
        }


        // see if we already have a reference to it
        CTemplateClassReferences* pClassReference = 
          templateClassReferencesList.FindReference(lpszCurrentClassName);

        if (pClassReference == NULL)
        {
          // not seen before can we find the class into the schema?
          CSchemaClassInfo* pChildClassInfo = 
              _FindClassByName(bScopeClass ? lpszScopeClass : lpszCurrentClassName, 
                                    pSchemaClassesInfoArray);

          if (pChildClassInfo != NULL)
          {
            // found the class, create a new reference
            pClassReference = new CTemplateClassReferences();
            pClassReference->m_pClassInfo = pChildClassInfo;
            pClassReference->m_bScopeClass = bScopeClass;

            // add it to the reference list
            templateClassReferencesList.push_back(pClassReference);
          }
        }

        if (pClassReference != NULL)
        {
          // we have a valid class reference
          ASSERT(pClassReference->m_bScopeClass == bScopeClass);
          ASSERT(pClassReference->m_pClassInfo != NULL);

          // add the object type
          pClassReference->m_templateObjectListRef.push_back(pObjectType);
        }
      } // for all object types

    } // if applicable template

  } // for all templates


  // now we have a list of references to work on
  // for each reference we have to create a permission holder and set it

  CTemplateClassReferencesList::iterator iClassRef;
  for (iClassRef = templateClassReferencesList.begin(); iClassRef != templateClassReferencesList.end(); ++iClassRef)
  {
    CTemplateClassReferences* pClassRef = (*iClassRef);
    ASSERT(pClassRef != NULL);

    TRACE(L"\nStart processing class references for class <%s>\n", pClassRef->m_pClassInfo->GetName());

    // for the given class reference, need to retain the class info
    CTemplateAccessPermissionsHolder* pPermissionHolder = 
                    new CTemplateAccessPermissionsHolder(pClassRef->m_pClassInfo, 
                                                         pClassRef->m_bScopeClass);

    HRESULT hr = pPermissionHolder->GetAccessPermissions(pADSIObj);
    if (SUCCEEDED(hr))
    {
      if (pPermissionHolder->SetupFromClassReferences(&(pClassRef->m_templateObjectListRef)))
      {
        // successfully set up, can add to the list
        m_permissionHolderArray.Add(pPermissionHolder);
        pPermissionHolder = NULL;
      }
    }

    if (pPermissionHolder != NULL)
    {
      TRACE(L"Invalid class references, throwing away permission holder\n");
      // invalid one, just throw away
      delete pPermissionHolder;
	  //Don't proceed if single template is in error.
	  m_permissionHolderArray.Clear();
	  break;
    }
    TRACE(L"End processing class references for class <%s>\n", pClassRef->m_pClassInfo->GetName());

  } // for each class reference
  
  
  TRACE(L"\nInitPermissionHoldersFromSelectedTemplates() has %d valid holders\n\n\n", 
    m_permissionHolderArray.GetCount());

  // we must have at least a valid and set template holder
  return m_permissionHolderArray.GetCount() > 0;
}


DWORD CTemplateAccessPermissionsHolderManager::UpdateAccessList(
                                                         CPrincipal* pPrincipal,
                                                         LPCWSTR lpszServerName,
                                                         LPCWSTR lpszPhysicalSchemaNamingContext,
                                                         PACL *ppAcl)
{
  // apply each permission holder in the list

  long nCount = (long) m_permissionHolderArray.GetCount();
  for (long k=0; k<nCount; k++)
  {
    CTemplateAccessPermissionsHolder* pCurrHolder = m_permissionHolderArray[k];
    DWORD dwErr = pCurrHolder->UpdateAccessList(pPrincipal,
                                                lpszServerName,
                                                lpszPhysicalSchemaNamingContext,
                                                ppAcl);
    if (dwErr != 0)
      return dwErr;
  }
  
  return 0;
}







///////////////// UI related operations //////////////////////////////////////////

BOOL CTemplateAccessPermissionsHolderManager::FillTemplatesListView(
                                             CCheckListViewHelper* pListViewHelper,
                                             LPCWSTR lpszClass)
{
	// clear check list
	pListViewHelper->DeleteAllItems();

  ULONG iListViewItem = 0;

  CTemplateList::iterator i;
  CTemplateList* pList = m_templateManager.GetTemplateList();
  for (i = pList->begin(); i != pList->end(); ++i)
  {
    CTemplate* p = (*i);
    ASSERT(p != NULL);
    if (p->AppliesToClass(lpszClass))
    {
      pListViewHelper->InsertItem(iListViewItem, 
                          p->GetDescription(), 
                          (LPARAM)p,
                          p->m_bSelected);
      iListViewItem++;
    }
  }

  return (iListViewItem > 0);
}



void CTemplateAccessPermissionsHolderManager::WriteSummary(CWString& szSummary, 
                                                           LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  WriteSummaryTitleLine(szSummary, IDS_DELEGWIZ_FINISH_TEMPLATE, lpszNewLine);

  CTemplateList::iterator i;
  CTemplateList* pList = m_templateManager.GetTemplateList();
  for (i = pList->begin(); i != pList->end(); ++i)
  {
    CTemplate* p = (*i);
    ASSERT(p != NULL);
    if (p->m_bSelected)
    {
      WriteSummaryLine(szSummary, p->GetDescription(), lpszIdent, lpszNewLine);
    }
  }
  szSummary += lpszNewLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\common\_tempcor.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       _tempcor.cpp
//
//--------------------------------------------------------------------------



#include "tempcore.h"




//////////////////////////////////////////////////////////////////////////////
// Keywords for the INF file format


LPCWSTR g_lpszTemplates = L"Templates";
LPCWSTR g_lpszDelegationTemplates = L"DelegationTemplates";
LPCWSTR g_lpszDescription = L"Description";
LPCWSTR g_lpszAppliesToClasses = L"AppliesToClasses";

LPCWSTR g_lpszScope = L"SCOPE";

LPCWSTR g_lpszControlRight = L"CONTROLRIGHT";
LPCWSTR g_lpszThisObject = L"@";
LPCWSTR g_lpszObjectTypes = L"ObjectTypes";


//////////////////////////////////////////////////////////////////////////////////
// parsing of access bits





const int g_nGrantAll = 0; // first in the array

const _ACCESS_BIT_MAP g_AccessBitMap[] = {

  { L"GA", _GRANT_ALL            },
  { L"CC", ACTRL_DS_CREATE_CHILD },
  { L"DC", ACTRL_DS_DELETE_CHILD },
  { L"RP", ACTRL_DS_READ_PROP    }, 
  { L"WP", ACTRL_DS_WRITE_PROP   }, 
  { L"SW", ACTRL_DS_SELF         }, 
  { L"LC", ACTRL_DS_LIST         }, 
  { L"LO", ACTRL_DS_LIST_OBJECT  },
  { L"DT", ACTRL_DS_DELETE_TREE  }, 
  { L"RC", READ_CONTROL          }, 
  { L"WD", WRITE_DAC             }, 
  { L"WO", WRITE_OWNER           }, 
  { L"SD", DELETE                }, 
  { NULL, 0x0} // end of table

};

const _ACCESS_BIT_MAP* GetTemplateAccessRightsMap()
{
  return g_AccessBitMap;
}


ULONG GetAccessMaskFromString(LPCWSTR lpszAccessBit)
{
  if (wcscmp(lpszAccessBit, g_AccessBitMap[g_nGrantAll].lpsz) == 0 )
  {
    return g_AccessBitMap[g_nGrantAll].fMask;
  }
  _ACCESS_BIT_MAP* pEntry = (_ACCESS_BIT_MAP*)g_AccessBitMap+1;
  while (pEntry->lpsz != NULL)
  {
    if (wcscmp(lpszAccessBit, pEntry->lpsz) == 0 )
    {
      return pEntry->fMask;
    }
    pEntry++;
  }
  return 0x0;
}

void GetStringFromAccessMask(ULONG fAccessMask, wstring& szAccessMask)
{
  if (fAccessMask == g_AccessBitMap[g_nGrantAll].fMask)
  {
    szAccessMask = g_AccessBitMap[g_nGrantAll].lpsz;
    return;
  }
  szAccessMask = L"";
  _ACCESS_BIT_MAP* pEntry = (_ACCESS_BIT_MAP*)(g_AccessBitMap+1);
  while (pEntry->lpsz != NULL)
  {
    if ( fAccessMask & pEntry->fMask)
    {
      szAccessMask += pEntry->lpsz;
      szAccessMask += L"";
    }
    pEntry++;
  }
}

////////////////////////////////////////////////////////////////////////
// CTemplateManager

BOOL CTemplateManager::HasTemplates(LPCWSTR lpszClass)
{
  CTemplateList::iterator i;
  for (i = m_templateList.begin(); i != m_templateList.end(); ++i)
  {
    if ((*i)->AppliesToClass(lpszClass))
    {
      return TRUE;
    }
  }
  return FALSE;
}

BOOL CTemplateManager::HasSelectedTemplates()
{
  CTemplateList::iterator i;
  for (i = m_templateList.begin(); i != m_templateList.end(); ++i)
  {
    if ((*i)->m_bSelected)
    {
      return TRUE;
    }
  }
  return FALSE;
}

void CTemplateManager::DeselectAll()
{
  CTemplateList::iterator i;
  for (i = m_templateList.begin(); i != m_templateList.end(); ++i)
  {
    (*i)->m_bSelected = FALSE;
  }
}




HRESULT 
CTemplateManager::_LoadTemplatePermission(HINF InfHandle, 
                                          LPCWSTR lpszPermissionSection, 
                                          LPCWSTR lpszPermission,
                                          CTemplateObjectType* pObjectType)
{
  CInfList permissionList(InfHandle);
  if (!permissionList.Bind(lpszPermissionSection, lpszPermission))
  {
    return E_FAIL;
  }
  
  TRACE(L"_LoadTemplatePermission(%s)\n", lpszPermission);
  
  // special case control access
  if (wcscmp(lpszPermission, g_lpszControlRight) == 0)
  {
    // read the list of controlright strings
    while(permissionList.MoveNext())
    {
      // read the rights
      TRACE(L"control right      <%s>\n", permissionList.GetBuf());
      CTemplatePermission* pCurrPermission = new CTemplatePermission();
      if(pCurrPermission)
      {
        pCurrPermission->SetControlRight(permissionList.GetBuf());
        pObjectType->GetPermissionList()->push_back(pCurrPermission);
      }
	  else
	  {
		  return E_OUTOFMEMORY;
	  }
    } // while
  }
  else
  {
    // any other access mask (including g_lpszThisObject == "@")
    ULONG fAccessMask = 0;
    while(permissionList.MoveNext())
    {
      // read the rights
      TRACE(L"right      <%s>\n", permissionList.GetBuf());
      fAccessMask |= GetAccessMaskFromString(permissionList.GetBuf());
    } // while

    TRACE(L"fAccessMask = 0x%x\n", fAccessMask);
    if (fAccessMask != 0)
    {
      CTemplatePermission* pCurrPermission = new CTemplatePermission();
      if( pCurrPermission )
      {
         pCurrPermission->SetAccessMask(lpszPermission, fAccessMask);
         pObjectType->GetPermissionList()->push_back(pCurrPermission);
      }
	  else
	  {
		  return E_OUTOFMEMORY;
	  }
    }
	else
	{
		return E_FAIL;
	}
  }

  return S_OK;
}

HRESULT CTemplateManager::_LoadTemplatePermissionsSection(HINF InfHandle,
                                                       LPCWSTR lpszTemplateName,
                                                       LPCWSTR lpszObject,
                                                       CTemplate* pCurrTemplate)

{

  WCHAR szPermissionSection[N_BUF_LEN];
  HRESULT hr = S_OK;
  hr = StringCchPrintf(szPermissionSection, N_BUF_LEN, L"%s.%s", lpszTemplateName, lpszObject);
  if(FAILED(hr))
      return hr;
  TRACE(L"  szPermissionSection = <%s>\n", szPermissionSection);
  
  
  CInfSectionKeys permissionSection(InfHandle);
  
  if (!permissionSection.Bind(szPermissionSection))
  {
    return hr;
  }
  
  CTemplateObjectType* pObjectType = NULL;

  while (permissionSection.MoveNext())
  {
    if (pObjectType == NULL)
    {
      pObjectType = new CTemplateObjectType(lpszObject);
    }

    TRACE(L"    <%s>\n", permissionSection.GetBuf());
    hr = _LoadTemplatePermission(InfHandle, szPermissionSection, permissionSection.GetBuf(), pObjectType);
	if(FAILED(hr))
	{
		delete pObjectType;
		pObjectType = NULL;
		break;
	}

  } // while


  if (pObjectType != NULL)
  {
    // need to validate template data
    if (pObjectType->GetPermissionList()->size() > 0)
    {
      pCurrTemplate->GetObjectTypeList()->push_back(pObjectType);
    }
    else
    {
      delete pObjectType;
    }
  }

  return hr;
}

void CTemplateManager::_LoadTemplate(HINF InfHandle, LPCWSTR lpszTemplateName)
{
  
  // read the template description
  CInfLine descriptionLine(InfHandle);
  if (!descriptionLine.Bind(lpszTemplateName, g_lpszDescription))
  {
    TRACE(L"Invalid Template: missing description entry\n");
    return; // missing entry
  }
  TRACE(L"  Description = <%s>\n", descriptionLine.GetBuf());
  if (lstrlen(descriptionLine.GetBuf()) == 0)
  {
    TRACE(L"Invalid Template: empty description\n");
    return; // empty description 
  }

    
  // read the object types field
  CInfList currTemplate(InfHandle);
  if (!currTemplate.Bind(lpszTemplateName, g_lpszObjectTypes))
  {
    TRACE(L"Invalid Template: no objects specified\n");
    return; // no objects specified
  }


  // load the object type sections
  CTemplate* pCurrTemplate = NULL;
  while (currTemplate.MoveNext())
  {
    if (pCurrTemplate == NULL)
      pCurrTemplate = new CTemplate(descriptionLine.GetBuf());

    if(FAILED(_LoadTemplatePermissionsSection(InfHandle, lpszTemplateName, currTemplate.GetBuf(), pCurrTemplate)))
    {
        if(pCurrTemplate)
            delete pCurrTemplate;
        pCurrTemplate = NULL;
        return;
    }

  } // while


  // add to template list, if not empty
  if (pCurrTemplate != NULL)
  {
    // need to validate template data
    if (pCurrTemplate->GetObjectTypeList()->size() > 0)
    {
      GetTemplateList()->push_back(pCurrTemplate);
    }
    else
    {
      TRACE(L"Discarding template: no valid object type sections\n");
      delete pCurrTemplate;
      pCurrTemplate = NULL;
    }
  }

  if (pCurrTemplate != NULL)
  {

    // read the applicable classes list, if any
    CInfList applicableClasses(InfHandle);
    if (applicableClasses.Bind(lpszTemplateName, g_lpszAppliesToClasses))
    {
      TRACE(L"Applicable to: ");

      while (applicableClasses.MoveNext())
      {
        TRACE(L"<%s>", applicableClasses.GetBuf());
        pCurrTemplate->AddAppliesToClass(applicableClasses.GetBuf());
      }
      TRACE(L"\n");
    }
    TRACE(L"\nTemplate successfully read into memory\n\n");
  } // if

}



BOOL CTemplateManager::_LoadTemplateList(HINF InfHandle)
{
  TRACE(L"CTemplateManager::_LoadTemplateList()\n");

  // acquire the list of templates in the file
  CInfList templatelist(InfHandle);
  if (!templatelist.Bind(g_lpszDelegationTemplates, g_lpszTemplates))
  {
    TRACE(L"CTemplateManager::_LoadTemplateList() failed: invalid template list entry\n");
    return FALSE;
  }

  // loop through the templates and load them
  while(templatelist.MoveNext())
  {
    // process
    TRACE(L"\nTemplate = <%s>\n", templatelist.GetBuf());
    _LoadTemplate(InfHandle, templatelist.GetBuf()); 

  } // while

  if (GetTemplateList()->size() == 0)
  {
    TRACE(L"CTemplateManager::_LoadTemplateList() failed no valid templates\n");
    return FALSE;
  }

#ifdef _DUMP
  TRACE(L"\n\n\n======= LOADED TEMPLATES ====================\n");
  GetTemplateList()->Dump();
  TRACE(L"\n===========================\n\n\n");
#endif // _DUMP
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\dbg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"

/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_DSA_TRACE) || defined(_USE_DSA_ASSERT) || defined(_USE_DSA_TIMER)

UINT GetInfoFromIniFile(LPCWSTR lpszSection, LPCWSTR lpszKey, INT nDefault = 0)
{
  static LPCWSTR lpszFile = L"\\system32\\dsuiwiz.ini";

  WCHAR szFilePath[2*MAX_PATH];
	UINT nLen = ::GetSystemWindowsDirectory(szFilePath, 2*MAX_PATH);
	if (nLen == 0)
		return nDefault;

  wcscat(szFilePath, lpszFile);
  return ::GetPrivateProfileInt(lpszSection, lpszKey, nDefault, szFilePath);
}
#endif


#if defined(_USE_DSA_TRACE)

#ifdef DEBUG_DSA
DWORD g_dwTrace = 0x1;
#else
DWORD g_dwTrace = ::GetInfoFromIniFile(L"Debug", L"Trace");
#endif

void DSATrace(LPCTSTR lpszFormat, ...)
{ 
  if (g_dwTrace == 0)
    return;

	va_list args;
	va_start(args, lpszFormat);

	WCHAR szBuffer[512];

	//Don't care about truncation. This is only debug spew. Lets print
	//as much as possible.
	StringCchVPrintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), lpszFormat, args);

  ::OutputDebugString(szBuffer);

	va_end(args);
}

#endif // defined(_USE_DSA_TRACE)

#if defined(_USE_DSA_ASSERT)

DWORD g_dwAssert = ::GetInfoFromIniFile(L"Debug", L"Assert");

BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine)
{ 
  if (g_dwAssert == 0)
    return FALSE;

  WCHAR szMessage[_MAX_PATH*2];

	// assume the debugger or auxiliary port. Its fine to truncate. Lets print
	//as much info as possible.
	StringCchPrintf(szMessage,sizeof(szMessage)/sizeof(WCHAR), _T("Assertion Failed: File %hs, Line %d\n"),
		lpszFileName, nLine);
	OutputDebugString(szMessage);

	// display the assert
	int nCode = ::MessageBox(NULL, szMessage, _T("Assertion Failed!"),
		MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

  OutputDebugString(L"after message box\n");
	if (nCode == IDIGNORE)
  {
		return FALSE;   // ignore
  }

	if (nCode == IDRETRY)
  {
		return TRUE;    // will cause DebugBreak
  }

	abort();     // should not return 
	return TRUE;

}
#endif // _USE_DSA_ASSERT

#if defined(_USE_DSA_TIMER)

#ifdef TIMER_DSA
DWORD g_dwTimer = 0x1;
#else
DWORD g_dwTimer = ::GetInfoFromIniFile(L"Debug", L"Timer");
#endif

DWORD StartTicks = ::GetTickCount();
DWORD LastTicks = 0;

void DSATimer(LPCTSTR lpszFormat, ...)
{
  if (g_dwTimer == 0)
    return;

	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512], szBuffer2[512];

        DWORD CurrentTicks = GetTickCount() - StartTicks;
        DWORD Interval = CurrentTicks - LastTicks;
        LastTicks = CurrentTicks;

	if(SUCCEEDED(StringCchPrintf(szBuffer2,sizeof(szBuffer2)/sizeof(WCHAR),
								 L"%d, (%d): %ws", 
								CurrentTicks,Interval, lpszFormat)))
	{
		if(SUCCEEDED(StringCchVPrintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), 
									  szBuffer2, 
									  args)))
		{
		  ::OutputDebugString(szBuffer);
		}
	}
	va_end(args);
}
#endif // _USE_DSA_TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\common\_util.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2002
//
//  File:       _util.cpp
//
//--------------------------------------------------------------------------



PWSTR g_wzRootDSE = L"RootDSE";
PWSTR g_wzSchemaNamingContext = L"schemaNamingContext";
PWSTR g_wzLDAPAbstractSchemaFormat = L"LDAP://%s/schema/%s";


//
// Attribute names:
//
PWSTR g_wzDescription = L"description"; // ADSTYPE_CASE_IGNORE_STRING
PWSTR g_wzName = L"name";               // ADSTYPE_CASE_IGNORE_STRING
PWSTR g_wzMemberAttr = L"member";       // ADSTYPE_DN_STRING


#define _WIZ_FULL_CTRL _GRANT_ALL

// turn off check for warning C4127: conditional expression is constant
#pragma warning (disable : 4127)

///////////////////////////////////////////////////////////////////////
// CWString

BOOL CWString::LoadFromResource(UINT uID)
{
  int nBufferSize = 128;
  static const int nCountMax = 4;
  int nCount = 1;

  do 
  {
    LPWSTR lpszBuffer = (LPWSTR)alloca(nCount*nBufferSize*sizeof(WCHAR));
    int iRet = ::LoadString(_Module.GetResourceInstance(), uID, 
                      lpszBuffer, nBufferSize);
    if (iRet == 0)
    {
      (*this) = L"?";
      return FALSE; // not found
    }
    if (iRet == nBufferSize-1) // truncation
    {
      if (nCount > nCountMax)
      {
        // too many reallocations
        (*this) = lpszBuffer;
        return FALSE; // truncation
      }
      // try to expand buffer
      nBufferSize *=2;
      nCount++;
    }
    else
    {
      // got it
      (*this) = lpszBuffer;
      break;
    }
  }
  while (TRUE);


    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////////

// catenate the server name and the 1779 name
// to get an LDAP path like "LDAP://myserv.foo.com./cn=host,..."
void BuildLdapPathHelper(LPCWSTR lpszServerName, LPCWSTR lpszNamingContext, CWString& szLdapPath)
{
  static LPCWSTR lpszFmt = L"LDAP://%s/%s";
  int nServerNameLen = lstrlen(lpszServerName)+1;
    int nFormatStringLen = lstrlen(lpszFmt)+1;
  int nNamingContext = lstrlen(lpszNamingContext)+1;
  
    // build the LDAP path for the schema class
    WCHAR* pwszNewObjectPath = 
        (WCHAR*)alloca(sizeof(WCHAR)*(nServerNameLen+nFormatStringLen+nNamingContext));
    wsprintf(pwszNewObjectPath, lpszFmt, lpszServerName, lpszNamingContext);

  szLdapPath = pwszNewObjectPath;
}


// catenate the server name and the 1779 name
// to get something like "\\myserv.foo.com.\cn=host,..."
void BuildWin32PathHelper(LPCWSTR lpszServerName, LPCWSTR lpszNamingContext, CWString& szWin32Path)
{
  static LPCWSTR lpszFmt = L"\\\\%s\\%s";
  int nServerNameLen = lstrlen(lpszServerName)+1;
    int nFormatStringLen = lstrlen(lpszFmt)+1;
  int nNamingContext = lstrlen(lpszNamingContext)+1;
  
    // build the LDAP path for the schema class
    WCHAR* pwszNewObjectPath = 
        (WCHAR*)alloca(sizeof(WCHAR)*(nServerNameLen+nFormatStringLen+nNamingContext));
    wsprintf(pwszNewObjectPath, lpszFmt, lpszServerName, lpszNamingContext);

  szWin32Path = pwszNewObjectPath;
}

HRESULT GetCanonicalNameFromNamingContext(LPCWSTR lpszNamingContext, CWString& szCanonicalName)
{
  szCanonicalName = L"";

  // assume in the form "cn=xyz,..."
  LPWSTR lpszCanonicalName = NULL;
  HRESULT hr = CrackName((LPWSTR)lpszNamingContext, &lpszCanonicalName, GET_OBJ_CAN_NAME);
  if (SUCCEEDED(hr) && (lpszCanonicalName != NULL))
  {
    szCanonicalName = lpszCanonicalName;
  }
  if (lpszCanonicalName != NULL)
    ::LocalFree(lpszCanonicalName);
  return hr;
}

/////////////////////////////////////////////////////////////////////////

class CContainerProxyBase
{
public:
  CContainerProxyBase() { } 
  virtual ~CContainerProxyBase() {}
  virtual BOOL Add(LPCWSTR lpsz) = 0;
};


template <class TOBJ, class TARR, class TFILTR> class CContainerProxy 
        : public CContainerProxyBase
{
public:
  CContainerProxy(TARR* pArr, TFILTR* pFilter)
  {
    m_pArr = pArr;
    m_pFilter = pFilter;
  }
  virtual BOOL Add(LPCWSTR lpsz)
  {
    ULONG filterFlags = 0x0;
    if ( (m_pFilter == NULL) || 
          (m_pFilter->CanAdd(lpsz, &filterFlags)) )
    {
      TOBJ* p = new TOBJ(filterFlags, lpsz);
      if (p == NULL)
        return FALSE;
      return m_pArr->Add(p);
    }
    return TRUE;
  }

private:
  TARR* m_pArr;
  TFILTR* m_pFilter;
};




/////////////////////////////////////////////////////////////////////////

BOOL LoadStringHelper(UINT uID, LPTSTR lpszBuffer, int nBufferMax)
{
    int iRet = ::LoadString(_Module.GetResourceInstance(), uID, 
                    lpszBuffer, nBufferMax);
    if (iRet == 0)
    {
        lpszBuffer[0] = NULL;
        return FALSE; // not found
    }
    if (iRet == nBufferMax-1)
        return FALSE; // truncation
    return TRUE;
}


BOOL GetStringFromHRESULTError(HRESULT hr, CWString& szErrorString, BOOL bTryADsIErrors)
{
  HRESULT hrGetLast = S_OK;
  DWORD status;
  PTSTR ptzSysMsg = NULL;

  // first check if we have extended ADs errors
  if ((hr != S_OK) && bTryADsIErrors) 
  {
    WCHAR Buf1[256], Buf2[256];
    hrGetLast = ::ADsGetLastError(&status, Buf1, 256, Buf2, 256);
    TRACE(_T("ADsGetLastError returned status of %lx, error: %s, name %s\n"),
          status, Buf1, Buf2);
    if ((status != ERROR_INVALID_DATA) && (status != 0)) 
    {
      hr = status;
    }
  }

  // try the system first
  int nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (PTSTR)&ptzSysMsg, 0, NULL);

  if (nChars == 0) 
  { 
    //try ads errors
    static HMODULE g_adsMod = 0;
    if (0 == g_adsMod)
      g_adsMod = GetModuleHandle (L"activeds.dll");
    nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE, g_adsMod, hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)&ptzSysMsg, 0, NULL);
  }

  if (nChars > 0)
  {
    szErrorString = ptzSysMsg;
    ::LocalFree(ptzSysMsg);
  }

  return (nChars > 0);
}



BOOL GetStringFromWin32Error(DWORD dwErr, CWString& szErrorString)
{
  return GetStringFromHRESULTError(HRESULT_FROM_WIN32(dwErr),szErrorString);
}

//
// Given a GUID struct, it returns a GUID in string format, without {}
//
BOOL FormatStringGUID(LPWSTR lpszBuf, UINT nBufSize, const GUID* pGuid)
{
  lpszBuf[0] = NULL;

  // if it is a NULL GUID*, just return an empty string
  if (pGuid == NULL)
  {
    return FALSE;
  }
  
/*
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
}

*/
  if(SUCCEEDED(StringCchPrintf(lpszBuf, nBufSize, 
            L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x", 
            pGuid->Data1, pGuid->Data2, pGuid->Data3, 
            pGuid->Data4[0], pGuid->Data4[1],
            pGuid->Data4[2], pGuid->Data4[3], pGuid->Data4[4], pGuid->Data4[5], pGuid->Data4[6], pGuid->Data4[7])))
  {
      return TRUE;
  }
  else
  {
      return FALSE;
  }
}




//
// Given a GUID in string format (without {}) it returns a GUID struct
//
// e.g. "00299570-246d-11d0-a768-00aa006e0529" to a struct form
//

BOOL GuidFromString(GUID* pGuid, LPCWSTR lpszGuidString)
{
  ZeroMemory(pGuid, sizeof(GUID));
  if (lpszGuidString == NULL)
  {
    return FALSE;
  }

  int nLen = lstrlen(lpszGuidString);
  // the string length should be 36
  if (nLen != 36)
    return FALSE;

  // add the braces to call the Win32 API
  LPWSTR lpszWithBraces = (LPWSTR)alloca((nLen+1+2)*sizeof(WCHAR)); // NULL plus {}
  wsprintf(lpszWithBraces, L"{%s}", lpszGuidString);

  return SUCCEEDED(::CLSIDFromString(lpszWithBraces, pGuid));
}




DWORD AddEntryInAcl(PEXPLICIT_ACCESS pAccessEntry, PACL* ppAcl)
{
  // add an entry in the DACL
  PACL pOldAcl = *ppAcl;

  TRACE(L"Calling SetEntriesInAcl()\n");

  DWORD dwErr = ::SetEntriesInAcl(1, pAccessEntry, pOldAcl, ppAcl);
  
  TRACE(L"SetEntriesInAcl() returned dwErr = 0x%x\n", dwErr);

  if (dwErr == ERROR_SUCCESS && NULL != pOldAcl )
  {
    ::LocalFree(pOldAcl);
  }
  return dwErr;
}

#ifdef DBG

void TraceGuid(LPCWSTR lpszMsg, const GUID* pGuid)
{
  WCHAR szGuid[128];
  FormatStringGUID(szGuid, 128, pGuid);
  TRACE(L"%s %s\n", lpszMsg, szGuid);
}

#define TRACE_GUID(msg, pGuid)\
  TraceGuid(msg, pGuid);

#else

#define TRACE_GUID(msg, pGuid)

#endif

DWORD AddObjectRightInAcl(IN      PSID pSid, 
                          IN      ULONG uAccess, 
                          IN      const GUID* pRightGUID, 
                          IN      const GUID* pInheritGUID, 
                          IN OUT  PACL* ppAcl)
{
  // trace input parameters

  TRACE(L"AddObjectRightInAcl()\n");
  TRACE(L"ULONG uAccess = 0x%x\n", uAccess);
  TRACE_GUID(L"pRightGUID =", pRightGUID);
  TRACE_GUID(L"pInheritGUID =", pInheritGUID);


  EXPLICIT_ACCESS AccessEntry;
  ZeroMemory(&AccessEntry, sizeof(EXPLICIT_ACCESS));

  if( uAccess == 0 )
    return ERROR_SUCCESS;

  // initialize EXPLICIT_ACCESS
  AccessEntry.grfAccessPermissions = uAccess;
  AccessEntry.grfAccessMode = GRANT_ACCESS;
  AccessEntry.grfInheritance = SUB_CONTAINERS_ONLY_INHERIT;
  if (pInheritGUID != NULL)
  {
      AccessEntry.grfInheritance    |= INHERIT_ONLY;
  }

  OBJECTS_AND_SID ObjectsAndSid;
  ZeroMemory(&ObjectsAndSid, sizeof(OBJECTS_AND_SID));


  TRACE(L"AccessEntry.grfAccessPermissions = 0x%x\n", AccessEntry.grfAccessPermissions);
  TRACE(L"AccessEntry.grfAccessMode = 0x%x\n", AccessEntry.grfAccessMode);
  TRACE(L"AccessEntry.grfInheritance = 0x%x\n", AccessEntry.grfInheritance);


  TRACE(L"BuildTrusteeWithObjectsAndSid()\n");

  BuildTrusteeWithObjectsAndSid(&(AccessEntry.Trustee), 
                              &ObjectsAndSid,
                              const_cast<GUID*>(pRightGUID),    // class, right or property
                              const_cast<GUID*>(pInheritGUID),  // inherit guid (class)
                              pSid                              // SID for user or group
                              );

  return ::AddEntryInAcl(&AccessEntry, ppAcl);
}


//////////////////////////////////////////////////////////////////////////////

long SafeArrayGetCount(const VARIANT& refvar)
{
    if (V_VT(&refvar) == VT_BSTR)
    {
    return (long)1;
    }
  if ( V_VT(&refvar) != ( VT_ARRAY | VT_VARIANT ) )
  {
    ASSERT(FALSE);
    return (long)0;
  }

  SAFEARRAY *saAttributes = V_ARRAY( &refvar );
  long start, end;
  HRESULT hr = SafeArrayGetLBound( saAttributes, 1, &start );
  if( FAILED(hr) )
    return (long)0;

  hr = SafeArrayGetUBound( saAttributes, 1, &end );
  if( FAILED(hr) )
    return (long)0;

  return (end - start + 1);
}

HRESULT VariantArrayToContainer(const VARIANT& refvar, CContainerProxyBase* pCont)
{
  HRESULT hr = S_OK;
  long start, end, current;

    if (V_VT(&refvar) == VT_BSTR)
    {
    //TRACE(_T("VT_BSTR: %s\n"),V_BSTR(&refvar));
    pCont->Add(V_BSTR(&refvar));
      return S_OK;
    }

  //
  // Check the VARIANT to make sure we have
  // an array of variants.
  //

  if ( V_VT(&refvar) != ( VT_ARRAY | VT_VARIANT ) )
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }
  SAFEARRAY *saAttributes = V_ARRAY( &refvar );

  //
  // Figure out the dimensions of the array.
  //

  hr = SafeArrayGetLBound( saAttributes, 1, &start );
    if( FAILED(hr) )
      return hr;

  hr = SafeArrayGetUBound( saAttributes, 1, &end );
    if( FAILED(hr) )
      return hr;

  //
  // Process the array elements.
  //
  VARIANT SingleResult;
  for ( current = start       ;
        current <= end        ;
        current++   )
  {
    ::VariantInit( &SingleResult );
    hr = SafeArrayGetElement( saAttributes, &current, &SingleResult );
    if( FAILED(hr) )
        return hr;
    if ( V_VT(&SingleResult) != VT_BSTR )
                    return E_UNEXPECTED;

    //TRACE(_T("VT_BSTR: %s\n"),V_BSTR(&SingleResult));
    pCont->Add(V_BSTR(&SingleResult));
    VariantClear( &SingleResult );
  }
  return S_OK;
}


HRESULT GetGlobalNamingContexts(LPCWSTR lpszServerName, 
                                CWString& szPhysicalSchemaNamingContext,
                                CWString& szConfigurationNamingContext)

{
  HRESULT hr = S_OK;

  CComPtr<IADs> spRootDSE;
  CWString szRootDSEPath;

  BuildLdapPathHelper(lpszServerName, g_wzRootDSE, szRootDSEPath);
  
  hr = ::ADsOpenObjectHelper(szRootDSEPath,
                  IID_IADs,
                  0,
                  (void**)&spRootDSE
                  );
  if (FAILED(hr)) 
  {
    TRACE(L"Error opening ADsOpenObjectHelper(%S), hr=%x\n", (LPCWSTR)szRootDSEPath,hr);
    return hr;
  }

  CComVariant varSchemaNamingContext;
  hr = spRootDSE->Get(CComBSTR (g_wzSchemaNamingContext),
                    &varSchemaNamingContext);
  if (FAILED(hr)) 
  {
    TRACE(_T("Error spRootDSE->Get((PWSTR)g_wzSchemaNamingContext), hr=%x\n"), hr);
    return hr;
  }

  // finally get value 
  // (e.g. "cn=schema,cn=configuration,dc=marcocdev,dc=ntdev,dc=microsoft,dc=com")
  ASSERT(varSchemaNamingContext.vt == VT_BSTR);
  szPhysicalSchemaNamingContext = varSchemaNamingContext.bstrVal;


  // get the configuration container naming context
  CComVariant varConfigurationNamingContext;
  hr = spRootDSE->Get(CComBSTR (L"configurationNamingContext"),
        &varConfigurationNamingContext);
  if (FAILED(hr))
  {
    TRACE(L"Failed spRootDSE->Get(configurationNamingContext,&varConfigurationNamingContext), returned hr = 0x%x\n", hr);
    return hr;
  }
  ASSERT(varConfigurationNamingContext.vt == VT_BSTR);
  szConfigurationNamingContext = varConfigurationNamingContext.bstrVal;

  return hr;
}





LPCWSTR g_lpszSummaryIdent = L"    ";
LPCWSTR g_lpszSummaryNewLine = L"\r\n";


void WriteSummaryTitleLine(CWString& szSummary, UINT nTitleID, LPCWSTR lpszNewLine)
{
  CWString szTemp;
  szTemp.LoadFromResource(nTitleID);
  WriteSummaryLine(szSummary, szTemp, NULL, lpszNewLine);
  szSummary += lpszNewLine;
}


void WriteSummaryLine(CWString& szSummary, LPCWSTR lpsz, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  if (lpszIdent != NULL)
    szSummary += lpszIdent;
  szSummary += lpsz;
  szSummary += lpszNewLine;
}



//////////////////////////////////////////////////////////////////////////////

LPCWSTR _GetFilePath()
{
  static LPCWSTR g_lpszFileName = L"\\system32\\dssec.dat";
  static WCHAR g_lpszFilePath[2*MAX_PATH] = L"";

  if (g_lpszFilePath[0] == NULL)
  {
    UINT nLen = ::GetSystemWindowsDirectory(g_lpszFilePath, MAX_PATH);
      if (nLen == 0)
          return NULL;
    wcscat(g_lpszFilePath, g_lpszFileName);
  }
  return g_lpszFilePath;
}




ULONG GetClassFlags(LPCWSTR lpszClassName)
{
  LPCWSTR lpszAttr = L"@";
  INT nDefault = 0;
  return ::GetPrivateProfileInt(lpszClassName, lpszAttr, nDefault, _GetFilePath());
  //return nDefault;
}



/////////////////////////////////////////////////////////////////////////////
// CFilterEntry

class CFilterEntry
{
public:
  CFilterEntry(LPWSTR lpszEntry)
  {
    m_lpszName = lpszEntry;
    m_nFlags = 0;
    Parse();
  }
  LPCWSTR m_lpszName;
  ULONG m_nFlags;

  bool operator<(CFilterEntry& x) 
  { 
      UNREFERENCED_PARAMETER (x);
      return false;
  }

private:
  void Parse()
  {
    WCHAR* p = (WCHAR*)m_lpszName;
    while (*p != NULL)
    {
      if (*p == TEXT('='))
      {
        *p = NULL;
        m_nFlags = _wtoi(p+1);
        break;
      }
      p++;
    }
  }

};

class CFilterEntryHolder
{
public:
  CFilterEntryHolder()
  {
    m_pCharBuf = NULL;
    m_dwCharBufSize = 0;
  }
  ~CFilterEntryHolder()
  {
    if (m_pCharBuf != NULL)
      free(m_pCharBuf);
  }

  ULONG GetAttributeFlags(LPCWSTR lpszClassName, LPCWSTR lpszAttr);

private:
  CWString m_szClassName;
  CGrowableArr<CFilterEntry> m_entries;
  WCHAR* m_pCharBuf;
  DWORD m_dwCharBufSize;

  BOOL _ReadFile();
  void _LoadFromFile();
  ULONG _FindInCache(LPCWSTR lpszAttr);

};


BOOL CFilterEntryHolder::_ReadFile()
{
  if (m_pCharBuf == NULL)
  {
    m_dwCharBufSize = 4096;
    m_pCharBuf = (WCHAR*)malloc(sizeof(WCHAR)*m_dwCharBufSize);
  }
  if (m_pCharBuf == NULL)
    return FALSE;

  BOOL bNeedRealloc = FALSE;
  int nReallocCount = 0;
  do
  {
    DWORD dwCharCount = ::GetPrivateProfileSection(m_szClassName, 
                        m_pCharBuf, m_dwCharBufSize,  _GetFilePath());
    if (dwCharCount == 0)
      return FALSE;
    bNeedRealloc = dwCharCount  == (m_dwCharBufSize - 2);
    if (bNeedRealloc)
    {
      if (nReallocCount > 4)
        return FALSE;
      m_dwCharBufSize = 2*m_dwCharBufSize;
      WCHAR* pCharBuf = (WCHAR*)realloc(m_pCharBuf, sizeof(WCHAR)*m_dwCharBufSize);
      if ( pCharBuf )
      {
          m_pCharBuf = pCharBuf;
      }
      else
          break;
      nReallocCount++;
    }
  }
  while (bNeedRealloc);
  return TRUE;
}

void CFilterEntryHolder::_LoadFromFile()
{
  m_entries.Clear();
  if (!_ReadFile())
    return;

  WCHAR* p = m_pCharBuf;
  WCHAR* pEntry = p;

  while ( ! (( *p == NULL ) && ( *(p+1) == NULL )) )
  {
    if (*p == NULL)
    {
      TRACE(_T("pEntry = <%s>\n"), pEntry);
      m_entries.Add(new CFilterEntry(pEntry));
      pEntry = p+1;
    }
    p++;
  }
  if ( pEntry < p)
    m_entries.Add(new CFilterEntry(pEntry)); // add the last one

  for (ULONG k=0; k<m_entries.GetCount(); k++)
  {
    TRACE(_T("k = %d, <%s> flags = %d\n"), k, m_entries[k]->m_lpszName, m_entries[k]->m_nFlags);
  }
}

ULONG CFilterEntryHolder::_FindInCache(LPCWSTR lpszAttr)
{
  for (ULONG k=0; k<m_entries.GetCount(); k++)
  {
    if (_wcsicmp(m_entries[k]->m_lpszName, lpszAttr) == 0)
      return m_entries[k]->m_nFlags;
  }
  return 0; // default
}


ULONG CFilterEntryHolder::GetAttributeFlags(LPCWSTR lpszClassName, LPCWSTR lpszAttr)
{
  if (_wcsicmp(lpszClassName, m_szClassName) != 0)
  {
    // class name changed
     m_szClassName = lpszClassName;
    _LoadFromFile();
  }
  return _FindInCache(lpszAttr);
}


ULONG GetAttributeFlags(LPCWSTR lpszClassName, LPCWSTR lpszAttr)
{
  static CFilterEntryHolder g_holder;
  return g_holder.GetAttributeFlags(lpszClassName, lpszAttr);
//  INT nDefault = 0;
//  return ::GetPrivateProfileInt(lpszClassName, lpszAttr, nDefault, _GetFilePath());
  //return nDefault;
}



///////////////////////////////////////////////////////////////////////
// CPrincipal


HRESULT CPrincipal::Initialize(PDS_SELECTION pDsSelection, HICON hClassIcon)
{

  TRACE(_T("pwzName = %s\n"), pDsSelection->pwzName);   // e.g. JoeB
  TRACE(_T("pwzADsPath = %s\n"), pDsSelection->pwzADsPath); // "LDAP:..." or "WINNT:..."
  TRACE(_T("pwzClass = %s\n"), pDsSelection->pwzClass); // e.g. "user"
  TRACE(_T("pwzUPN = %s\n"), pDsSelection->pwzUPN); // .e.g. "JoeB@acme.com."

  WCHAR  const c_szClassComputer[] = L"computer";

  // get the SID
  ASSERT(pDsSelection->pvarFetchedAttributes);
  if (pDsSelection->pvarFetchedAttributes[0].vt == VT_EMPTY)
  {
    TRACE(L"CPrincipal::Initialize() failed on VT_EMPTY sid\n");
    // fatal error, we cannot proceed
    return E_INVALIDARG;
  }
  if (pDsSelection->pvarFetchedAttributes[0].vt != (VT_ARRAY | VT_UI1))
  {
    TRACE(L"CPrincipal::Initialize() failed on (VT_ARRAY | VT_UI1) sid\n");
    // fatal error, we cannot proceed
    return E_INVALIDARG;
  }

  // make sure we have a good SID
  PSID pSid = pDsSelection->pvarFetchedAttributes[0].parray->pvData;
  HRESULT   hr = Initialize (pSid);
  if ( FAILED (hr) )
      return hr;

  // copy the icon
  m_hClassIcon = hClassIcon;
  // copy the strings
  m_szClass = pDsSelection->pwzClass;

  //Strip from Computer Name
  //16414   02/28/2000  *DS Admin snapin - DelWiz, need to strip the '$' from the end of computer names

  m_szName = pDsSelection->pwzName;
  if( m_szClass && m_szName && ( wcscmp( m_szClass, (LPWSTR)c_szClassComputer) == 0 ) )
  {
    // Strip the trailing '$'
    LPWSTR pszTemp; 
    pszTemp= (LPWSTR)(LPCWSTR)m_szName;
    int nLen = lstrlen(pszTemp);
    if (nLen && pszTemp[nLen-1] == TEXT('$'))
    {
        pszTemp[nLen-1] = TEXT('\0');
    }
  }
  
  m_szADsPath = pDsSelection->pwzADsPath;

  if( m_szClass && m_szADsPath && ( wcscmp( m_szClass, (LPWSTR)c_szClassComputer) == 0 ) )
  {
    // Strip the trailing '$'
    LPWSTR pszTemp; 
    pszTemp= (LPWSTR)(LPCWSTR)m_szADsPath;
    int nLen = lstrlen(pszTemp);
    if (nLen && pszTemp[nLen-1] == TEXT('$'))
    {
        pszTemp[nLen-1] = TEXT('\0');
    }
  }

  m_szUPN = pDsSelection->pwzUPN;
  

  // set the display name
  _ComposeDisplayName();

  return S_OK; 
}

HRESULT CPrincipal::Initialize (PSID pSid)
{
  if (!IsValidSid(pSid))
  {
    TRACE(L"CPrincipal::Initialize() failed on IsValidSid()\n");
    // fatal error, we cannot proceed
    return E_INVALIDARG;
  }

  // we have a good SID, copy it
  if (!m_sidHolder.Copy(pSid))
  {
    TRACE(L"CPrincipal::Initialize() failed on m_sidHolder.Copy(pSid)\n");
    // fatal error, we cannot proceed
    return E_OUTOFMEMORY;
  }

  return S_OK;
}

BOOL BuildSamName(LPCWSTR lpszPath, CWString& s)
{
  // strip the WINNT provider and reverse slashes
  static LPCWSTR lpszPrefix = L"WinNT://";
  int nPrefixLen = lstrlen(lpszPrefix);

  if (_wcsnicmp(lpszPath, lpszPrefix, nPrefixLen ) != 0)
  {
    // not matching
    return FALSE;
  }

  // make a copy
  LPCWSTR lpzsTemp = lpszPath+nPrefixLen; // past the prefix

  s = L"";
  for (WCHAR* pChar = const_cast<LPWSTR>(lpzsTemp); (*pChar) != NULL; pChar++)
  {
    if (*pChar == L'/')
      s += L'\\';
    else
      s += *pChar;
  }
  return TRUE;
}



void CPrincipal::_ComposeDisplayName()
{
  LPCWSTR lpszAddToName = NULL;

  // check if there is a UPN
  LPCWSTR lpszUPN = m_szUPN;
  if ( (lpszUPN != NULL) && (lstrlen(lpszUPN) > 0))
  {
    lpszAddToName = lpszUPN;
  }

  // as a second chance, add the domain\name
  LPCWSTR lpszPath = m_szADsPath;
  CWString sTemp;

  if ((lpszAddToName == NULL) && (lpszPath != NULL) && (lstrlen(lpszPath) > 0))
  {
    if (BuildSamName(lpszPath,sTemp))
    {
      lpszAddToName = sTemp;
    }
  }
  
  if (lpszAddToName != NULL)
  {
    static LPCWSTR lpszFormat = L"%s (%s)";
    size_t nLen = lstrlen(lpszAddToName) + lstrlen(lpszFormat) + m_szName.size() + 1;
    LPWSTR lpszTemp = (LPWSTR)alloca(nLen*sizeof(WCHAR));
    wsprintf(lpszTemp, lpszFormat, m_szName.c_str(), lpszAddToName);
    m_szDisplayName = lpszTemp;
  }
  else
  {
    // got nothing, just use the name
    m_szDisplayName = m_szName;
  }
}


BOOL CPrincipal::IsEqual(CPrincipal* p)
{
  return (_wcsicmp(m_szADsPath, p->m_szADsPath) == 0);
}


BOOL CPrincipalList::AddIfNotPresent(CPrincipal* p)
{
  CPrincipalList::iterator i;
  for (i = begin(); i != end(); ++i)
  {
    if ((*i)->IsEqual(p))
    {
      delete p; // duplicate
      return FALSE;
    }
  }
  push_back(p);
  return TRUE;
}


void CPrincipalList::WriteSummaryInfo(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  WriteSummaryTitleLine(szSummary, IDS_DELEGWIZ_FINISH_PRINCIPALS, lpszNewLine);

  CPrincipalList::iterator i;
  for (i = begin(); i != end(); ++i)
  {
    WriteSummaryLine(szSummary, (*i)->GetDisplayName(), lpszIdent, lpszNewLine);
  }
  szSummary += lpszNewLine;
}

///////////////////////////////////////////////////////////////////////
// CControlRightInfo

void CControlRightInfo::SetLocalizedName(UINT nLocalizationDisplayId, HMODULE hModule)
{
  WCHAR szLocalizedDisplayName[256];

  DWORD dwChars = 0;

  if (hModule != NULL)
  {
    dwChars = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                            hModule,  
                            nLocalizationDisplayId,
                            0,
                            szLocalizedDisplayName,
                            256,
                            NULL);
  }

  if (dwChars > 0)
  {
    m_szLocalizedName = szLocalizedDisplayName;
  }
  else
  {
    // failed, just use the LDAP display name
    m_szLocalizedName = m_szLdapDisplayName;
  }

  // need to set the display name
  if (IsPropertySet())
  {
    CWString szPropertySetFormat;
    szPropertySetFormat.LoadFromResource(IDS_DELEGWIZ_RW_PROPERTYSET);
    WCHAR* lpszBuffer = (WCHAR*)alloca(sizeof(WCHAR)*(szPropertySetFormat.size()+m_szLocalizedName.size()+1));

    // we have a different display name
    wsprintf(lpszBuffer, szPropertySetFormat, (LPCWSTR)m_szLocalizedName);
    m_szDisplayName = lpszBuffer;
  }
  else
  {
    // same as raw
    m_szDisplayName = m_szLocalizedName;
  }
}

///////////////////////////////////////////////////////////////////////
// CControlRightInfoArray 

class CDsSecLib
{
public:
  CDsSecLib()
  { 
    m_hInstance = ::LoadLibrary(L"dssec.dll");
  }
  ~CDsSecLib()
  { 
    if (m_hInstance != NULL)
      ::FreeLibrary(m_hInstance);
  }
  
  HINSTANCE Get() { return m_hInstance; }
private:
  HINSTANCE m_hInstance;
};


HRESULT CControlRightInfoArray::InitFromDS(CAdsiObject* pADSIObj,
                                           const GUID* pSchemaIDGUID)
{
  TRACE(L"CControlRightInfoArray::InitFromDS()\n\n");

  ASSERT(pSchemaIDGUID != NULL);

  LPWSTR lpszSchemaIDGUID = (LPWSTR)alloca(128*sizeof(WCHAR));
  if(!lpszSchemaIDGUID)
    return E_OUTOFMEMORY;
  if (!FormatStringGUID(lpszSchemaIDGUID, 128, pSchemaIDGUID))
  {
    return E_INVALIDARG;
  }

  
    // build the LDAP path for the schema class
  CWString szPhysicalSchemaPath;
  LPCWSTR lpszPhysicalSchemaNamingContext = pADSIObj->GetPhysicalSchemaNamingContext();
  BuildLdapPathHelper(pADSIObj->GetServerName(), lpszPhysicalSchemaNamingContext, szPhysicalSchemaPath);

  // build the extended rights container naming context and LDAP path
  CWString szExtendedRightsNamingContext;
  szExtendedRightsNamingContext = L"CN=Extended-Rights,";
  szExtendedRightsNamingContext += pADSIObj->GetConfigurationNamingContext();
  CWString szExtendedRightsPath;
  BuildLdapPathHelper(pADSIObj->GetServerName(), szExtendedRightsNamingContext, szExtendedRightsPath);

  // bind a query to the extended rights container
  CAdsiSearch search;
  HRESULT hr = search.Init(szExtendedRightsPath);
  TRACE(L"search.Init(%s) returned hr = 0x%x\n", (LPCWSTR)szExtendedRightsPath, hr);

  if (FAILED(hr))
  {
    return hr;
  }

  // build an LDAP query string
  static LPCWSTR lpszFilterFormat = L"(&(objectCategory=CN=Control-Access-Right,%s)(AppliesTo=%s))";

  int nFmtLen = lstrlen(lpszFilterFormat);
  int nArgumentLen = lstrlen(lpszPhysicalSchemaNamingContext) + lstrlen(lpszSchemaIDGUID);

  WCHAR* lpszFilter = (WCHAR*)alloca(sizeof(WCHAR)*(nFmtLen+nArgumentLen+1));
  wsprintf(lpszFilter, lpszFilterFormat, lpszPhysicalSchemaNamingContext, lpszSchemaIDGUID);

  // build an array of wanted columns
  static const int cAttrs = 4;
  static LPCWSTR pszAttribsArr[cAttrs] = 
  {
    L"displayName",     // e.g. "Change Password"
    L"rightsGuid",      // e.g. "ab721a53-1e2f-...." (i.e. GUID in string form w/o {})
    L"validAccesses",    // bitmask of access righs
    L"localizationDisplayId"    // bitmask of access righs
  }; 
  
  hr = search.SetSearchScope(ADS_SCOPE_ONELEVEL);
  TRACE(L"search.SetSearchScope(ADS_SCOPE_ONELEVEL) returned hr = 0x%x\n", hr);
  if (FAILED(hr))
    return hr;

  hr = search.DoQuery(lpszFilter, pszAttribsArr, cAttrs);
  TRACE(L"search.DoQuery(lpszFilter, pszAttribsArr, cAttrs) returned hr = 0x%x\n", hr);
  if (FAILED(hr))
    return hr;

  TRACE(L"\n");

  CWString szRightsGUID;
  ULONG nLocalizationDisplayId;

  // load DSSEC.DLL to provide localized
  CDsSecLib DsSecLib;

  while ((hr = search.GetNextRow()) != S_ADS_NOMORE_ROWS)
  {
    if (FAILED(hr))
      continue;

    CControlRightInfo* pInfo = new CControlRightInfo();

    HRESULT hr0 = search.GetColumnString(pszAttribsArr[0], pInfo->m_szLdapDisplayName);

    // the DS gives us the GUID in string form, but we need it in struct form
    HRESULT hr1 = search.GetColumnString(pszAttribsArr[1], szRightsGUID);
    if (SUCCEEDED(hr1))
    {
      if (!::GuidFromString(&(pInfo->m_rightsGUID), szRightsGUID.c_str()))
      {
        TRACE(L"GuidFromString(_, %s) failed!\n", szRightsGUID.c_str());
        hr1 = E_INVALIDARG;
      }
    }

    HRESULT hr2 = search.GetColumnInteger(pszAttribsArr[2], pInfo->m_fAccess);

    HRESULT hr3 = search.GetColumnInteger(pszAttribsArr[3], nLocalizationDisplayId);

    TRACE(L"Name = <%s>, \n       Guid = <%s>, Access = 0x%x, nLocalizationDisplayId = %d\n", 
            pInfo->m_szLdapDisplayName.c_str(), szRightsGUID.c_str(), pInfo->m_fAccess, nLocalizationDisplayId);
    
    if (FAILED(hr0) || FAILED(hr1) || FAILED(hr2) || FAILED(hr3))
    {
      TRACE(L"WARNING: discarding right, failed on columns: hr0 = 0x%x, hr1 = 0x%x, hr2 = 0x%x, hr3 = 0x%x\n",
                            hr0, hr1, hr2, hr3);
      delete pInfo;
    }
    else
    {
      pInfo->SetLocalizedName(nLocalizationDisplayId, DsSecLib.Get());

      Add(pInfo);
    }
  } // while

  TRACE(L"\n\n");

  if (hr == S_ADS_NOMORE_ROWS)
    hr = S_OK;

  return hr;
}


//////////////////////////////////////////////////////////////////////
// CPropertyRightInfo

const ULONG CPropertyRightInfo::m_nRightCountMax = 2;
const ULONG CPropertyRightInfo::m_nReadIndex = 0;
const ULONG CPropertyRightInfo::m_nWriteIndex = 1;


LPCWSTR CPropertyRightInfo::GetRightDisplayString(ULONG iRight)
{
  static WCHAR szReadFmt[256] = L"";
  static WCHAR szWriteFmt[256] = L"";
  static WCHAR szReadAll[256] = L"";
  static WCHAR szWriteAll[256] = L"";

  static WCHAR szDisplay[512];

  ASSERT(GetName() != NULL); // must have a name!!!

  szDisplay[0] = NULL;
  WCHAR* pFmt = NULL;

  if (iRight == m_nReadIndex)
  {
    if (szReadFmt[0] == NULL)
      LoadStringHelper(IDS_DELEGWIZ_READ_PROPERTY, szReadFmt, ARRAYSIZE(szReadFmt));
    pFmt = szReadFmt;
  }
  else if (iRight == m_nWriteIndex)
  {
    if (szWriteFmt[0] == NULL)
      LoadStringHelper(IDS_DELEGWIZ_WRITE_PROPERTY, szWriteFmt, ARRAYSIZE(szWriteFmt));
    pFmt = szWriteFmt;
  }

  if(pFmt)
  {
    if(SUCCEEDED(StringCchPrintf(szDisplay, sizeof(szDisplay)/sizeof(WCHAR), pFmt, GetDisplayName())))
    {
        return szDisplay;
    }
  }
  return NULL;
  
}

void CPropertyRightInfo::SetRight(ULONG iRight, BOOL b)
{
  switch (iRight)
  {
  case m_nReadIndex: 
    if (b)
      m_Access |= ACTRL_DS_READ_PROP;
    else
      m_Access &= ~ACTRL_DS_READ_PROP;
    break;
  case m_nWriteIndex:
    if (b)
      m_Access |= ACTRL_DS_WRITE_PROP;
    else
      m_Access &= ~ACTRL_DS_WRITE_PROP;
    break;
  default:
    ASSERT(FALSE);
  };
}

ULONG CPropertyRightInfo::GetRight(ULONG iRight)
{
  switch (iRight)
  {
  case m_nReadIndex: 
    return (ULONG)ACTRL_DS_READ_PROP;
    break;
  case m_nWriteIndex: 
    return (ULONG)ACTRL_DS_WRITE_PROP;
    break;
  default:
    ASSERT(FALSE);
  };
  return 0;
}

BOOL CPropertyRightInfo::IsRightSelected(ULONG iRight)
{
  BOOL bRes = FALSE;
  switch (iRight)
  {
  case m_nReadIndex: 
    bRes = m_Access & ACTRL_DS_READ_PROP;
    break;
  case m_nWriteIndex: 
    bRes = m_Access & ACTRL_DS_WRITE_PROP;
    break;
  default:
    ASSERT(FALSE);
  };
  return bRes;
}


//////////////////////////////////////////////////////////////////////
// CPropertyRightInfoArray

template <class T> class CClassPtr
{
public:
  CClassPtr() { m_p = NULL;}
  ~CClassPtr() { if (m_p) delete m_p;}

  CClassPtr& operator=(T* p)
  {
    m_p = p;
    return *this;
  }
  T* operator->()
  {
    return m_p;
  }
  T* operator&()
  {
    return m_p;
  }



private:
  T* m_p;
};

HRESULT CPropertyRightInfoArray::InitFromSchema(CAdsiObject* pADSIObj,
                                           IADsClass * pDsSchemaClass,
                                           LPCWSTR lpszClassName,
                                           BOOL bUseFilter)
{
  // setup
  Clear();

  CClassPtr<CPropertyRightInfoFilter> spFilter;
  if (bUseFilter)
  {
    spFilter = new CPropertyRightInfoFilter();
    spFilter->SetClassName(lpszClassName);
  }

  if (pDsSchemaClass == NULL)
  {
    ASSERT(lpszClassName == NULL);
    return S_OK;
  }

  // get data from DS for specific properties
  VARIANT MandatoryListVar, OptionalListVar;
  ::VariantInit(&MandatoryListVar);
  ::VariantInit(&OptionalListVar);
  HRESULT hr = pDsSchemaClass->get_MandatoryProperties(&MandatoryListVar);
  if (FAILED(hr))
  {
    ::VariantClear(&MandatoryListVar);
    return hr;
  }
  hr = pDsSchemaClass->get_OptionalProperties(&OptionalListVar);
  if (FAILED(hr))
  {
    ::VariantClear(&OptionalListVar);
    return hr;
  }

  // add the results to the array
  CContainerProxy<CPropertyRightInfo, CPropertyRightInfoArray, CPropertyRightInfoFilter> 
            cont(this, &spFilter);

  VariantArrayToContainer(MandatoryListVar, &cont);
  VariantArrayToContainer(OptionalListVar, &cont);

  ::VariantClear(&MandatoryListVar);
  ::VariantClear(&OptionalListVar);

  // now need to set the friendly names
  ULONG nCount = (ULONG) GetCount();
  WCHAR szFrendlyName[1024];
  HRESULT hrName;
  
  for (ULONG i=0; i<nCount; i++)
  {
    LPCWSTR lpszName = (*this)[i]->GetName();
    if (lpszName != NULL)
    {
      hrName = pADSIObj->GetFriendlyAttributeName(lpszClassName, 
                                                  lpszName, 
                                                  szFrendlyName, 1024);
      ASSERT(SUCCEEDED(hrName));
      (*this)[i]->SetDisplayName(SUCCEEDED(hrName) ? szFrendlyName : NULL);
    }
  }

  // get guids
  for (i=0; i<nCount; i++)
  {
    CPropertyRightInfo* pInfo = (*this)[i];
    LPCWSTR lpszName = pInfo->GetName();
    hr = pADSIObj->GetClassGuid(lpszName, TRUE, pInfo->m_schemaIDGUID);
    if (SUCCEEDED(hr))
    {
      WCHAR szTest[128];
      FormatStringGUID(szTest, 128, &(pInfo->m_schemaIDGUID));
      TRACE(L"name = <%s>, guid = <%s>\n", lpszName, szTest);
    }
    else
    {
      TRACE(L"GetClassGuid(%s) failed hr = 0x%x\n", lpszName, hr);
      return hr;
    }
  }

  Sort();
  return hr;
}



//////////////////////////////////////////////////////////////////////
// CClassRightInfo


const ULONG CClassRightInfo::m_nRightCountMax = 2;
const ULONG CClassRightInfo::m_nCreateIndex = 0;
const ULONG CClassRightInfo::m_nDeleteIndex = 1;


LPCWSTR CClassRightInfo::GetRightDisplayString(ULONG iRight)
{
  static WCHAR szCreateFmt[256] = L"";
  static WCHAR szDeleteFmt[256] = L"";
  static WCHAR szCreateAll[256] = L"";
  static WCHAR szDeleteAll[256] = L"";

  static WCHAR szDisplay[512];

  ASSERT(GetName() != NULL); // must have a name!!!
  
  szDisplay[0] = NULL;
  WCHAR* pFmt = NULL;

  if (iRight == m_nCreateIndex)
  {
    if (szCreateFmt[0] == NULL)
      LoadStringHelper(IDS_DELEGWIZ_CREATE_CLASS, szCreateFmt, ARRAYSIZE(szCreateFmt));
    pFmt = szCreateFmt;
  }
  else if (iRight == m_nDeleteIndex)
  {
    if (szDeleteFmt[0] == NULL)
      LoadStringHelper(IDS_DELEGWIZ_DELETE_CLASS, szDeleteFmt, ARRAYSIZE(szDeleteFmt));
    pFmt = szDeleteFmt;
  }

  if(pFmt)
  {
  
    if(SUCCEEDED(StringCchPrintf(szDisplay, 
                                 sizeof(szDisplay)/sizeof(WCHAR),
                                 pFmt, 
                                 GetDisplayName())))
    {

        return szDisplay;
    }
  }

  return NULL;
}

void CClassRightInfo::SetRight(ULONG iRight, BOOL b)
{
  switch (iRight)
  {
  case m_nCreateIndex: 
    if (b)
      m_Access |= ACTRL_DS_CREATE_CHILD;
    else
      m_Access &= ~ACTRL_DS_CREATE_CHILD;
    break;
  case m_nDeleteIndex: 
    if (b)
      m_Access |= ACTRL_DS_DELETE_CHILD;
    else
      m_Access &= ~ACTRL_DS_DELETE_CHILD;
    break;
  default:
    ASSERT(FALSE);
  };
}

ULONG CClassRightInfo::GetRight(ULONG iRight)
{
  switch (iRight)
  {
  case m_nCreateIndex: 
    return (ULONG)ACTRL_DS_CREATE_CHILD;
    break;
  case m_nDeleteIndex: 
    return (ULONG)ACTRL_DS_DELETE_CHILD;
    break;
  default:
    ASSERT(FALSE);
  };
  return 0;
}

BOOL CClassRightInfo::IsRightSelected(ULONG iRight)
{
 BOOL bRes = FALSE;
  switch (iRight)
  {
  case m_nCreateIndex: 
    bRes = m_Access & ACTRL_DS_CREATE_CHILD;
    break;
  case m_nDeleteIndex: 
    bRes = m_Access & ACTRL_DS_DELETE_CHILD;
    break;
  default:
    ASSERT(FALSE);
  };
  return bRes;
}


//////////////////////////////////////////////////////////////////////
// CClassRightInfoArray

HRESULT CClassRightInfoArray::InitFromSchema(CAdsiObject* pADSIObj, 
                                        IADsClass* pDsSchemaClass,
                                        BOOL bUseFilter)
{
  // setup
  Clear();

  if (pDsSchemaClass == NULL)
    return S_OK;

  // read from DS
  VARIANT ContainmentListVar;
  ::VariantInit(&ContainmentListVar);
  HRESULT hr = pDsSchemaClass->get_Containment(&ContainmentListVar);
  if (FAILED(hr))
  {
    ::VariantClear(&ContainmentListVar);
    return hr;
  }


  CClassPtr<CClassRightInfoFilter> spFilter;
  if (bUseFilter)
  {
    spFilter = new CClassRightInfoFilter();
  }
  
  // add to array and filter
  CContainerProxy<CClassRightInfo, CClassRightInfoArray, CClassRightInfoFilter> 
          cont(this, &spFilter);
  VariantArrayToContainer(ContainmentListVar, &cont);

  ::VariantClear(&ContainmentListVar);

  
  // now need to set the friendly names
  ULONG nCount = (ULONG) GetCount();
  WCHAR szFrendlyName[1024];
  HRESULT hrName;
  for (ULONG i=0; i<nCount; i++)
  {
    LPCWSTR lpszName = (*this)[i]->GetName();
    if (lpszName != NULL)
    {
      hrName = pADSIObj->GetFriendlyClassName(lpszName, szFrendlyName, 1024);
      ASSERT(SUCCEEDED(hrName));
      (*this)[i]->SetDisplayName(SUCCEEDED(hrName) ? szFrendlyName : NULL);
    }
  }

  // get guids
  for (i=0; i<nCount; i++)
  {
    CClassRightInfo* pInfo = (*this)[i];
    LPCWSTR lpszName = pInfo->GetName();
    hr = pADSIObj->GetClassGuid(lpszName, FALSE, pInfo->m_schemaIDGUID);
    if (SUCCEEDED(hr))
    {
      WCHAR szTest[128];
      FormatStringGUID(szTest, 128, &(pInfo->m_schemaIDGUID));
      TRACE(L"name = <%s>, guid = <%s>\n", lpszName, szTest);
    }
    else
    {
      TRACE(L"GetClassGuid(%s) failed hr = 0x%x\n", lpszName, hr);
      return hr;
    }
  }

  Sort();

  return hr;
}


///////////////////////////////////////////////////////////////////////
// CAccessPermissionsHolderBase

CAccessPermissionsHolderBase::CAccessPermissionsHolderBase(BOOL bUseFilter)
{
  m_bUseFilter = bUseFilter;
}

CAccessPermissionsHolderBase::~CAccessPermissionsHolderBase()
{
  Clear();
}

void CAccessPermissionsHolderBase::Clear()
{
  m_accessRightInfoArr.Clear();  
  m_controlRightInfoArr.Clear();  

  m_propertyRightInfoArray.Clear();
  m_classRightInfoArray.Clear();
}

BOOL CAccessPermissionsHolderBase::HasPermissionSelected()
{
  ULONG i,j;
  // check access rigths
  for (i = 0; i < m_accessRightInfoArr.GetCount(); i++)
  {
    if (m_accessRightInfoArr[i]->IsSelected())
        return TRUE;
  }
  
  // check control rigths
  for (i = 0; i < m_controlRightInfoArr.GetCount(); i++)
  {
    if (m_controlRightInfoArr[i]->IsSelected())
        return TRUE;
  }

  // subobjects rigths
  for (i = 0; i < m_classRightInfoArray.GetCount(); i++)
  {
    for (j=0; j< m_classRightInfoArray[i]->GetRightCount(); j++)
    {
      if ( m_classRightInfoArray[i]->IsRightSelected(j) )
        return TRUE;
    }
  }

  // property rights
  for (i = 0; i < m_propertyRightInfoArray.GetCount(); i++)
  {
    for (j=0; j< m_propertyRightInfoArray[i]->GetRightCount(); j++)
    {
      if ( m_propertyRightInfoArray[i]->IsRightSelected(j) )
        return TRUE;
    }
  }

  return FALSE;
}

/*
typedef struct _ACTRL_CONTROL_INFOW
{
    LPWSTR      lpControlId;
    LPWSTR      lpControlName;
} ACTRL_CONTROL_INFOW, *PACTRL_CONTROL_INFOW;

typedef struct _ACTRL_ACCESS_INFOW
{
    ULONG       fAccessPermission;
    LPWSTR      lpAccessPermissionName;
} ACTRL_ACCESS_INFOW, *PACTRL_ACCESS_INFOW;

*/



HRESULT CAccessPermissionsHolderBase::ReadDataFromDS(CAdsiObject* pADSIObj,
                                               LPCWSTR /*lpszObjectNamingContext*/, 
                                               LPCWSTR lpszClassName,
                                               const GUID* pSchemaIDGUID,
                                               BOOL bChildClass,
                                               BOOL bHideListObject)
{
#if DBG
  WCHAR szGUID[128];
  FormatStringGUID(szGUID, 128, pSchemaIDGUID);
  TRACE(L"CAccessPermissionsHolderBase::ReadDataFromDS(_, %s, %s)\n",
          lpszClassName, szGUID);
#endif


  Clear();

  HRESULT hr = S_OK;
  if (pSchemaIDGUID != NULL)
  {
    hr = m_controlRightInfoArr.InitFromDS(pADSIObj, pSchemaIDGUID);
    TRACE(L"hr = m_controlRightInfoArr.InitFromDS(...) returned hr = 0x%x\n", hr);
    if (FAILED(hr))
    {
      return hr;
    }
  }


  hr = _ReadClassInfoFromDS(pADSIObj, lpszClassName);
  if (FAILED(hr))
  {
    return hr;
  }
    
  hr = _LoadAccessRightInfoArrayFromTable(bChildClass,bHideListObject);
  return hr;
}


HRESULT CAccessPermissionsHolderBase::_ReadClassInfoFromDS(CAdsiObject* pADSIObj, 
                                                     LPCWSTR lpszClassName)
{
  HRESULT hr = S_OK;
  CComPtr<IADsClass> spSchemaObjectClass;

  if (lpszClassName != NULL)
  {
    int nServerNameLen = lstrlen(pADSIObj->GetServerName());
      int nClassNameLen = lstrlen(lpszClassName);
      int nFormatStringLen = lstrlen(g_wzLDAPAbstractSchemaFormat);
      
      // build the LDAP path for the schema class
      WCHAR* pwszSchemaObjectPath = 
          (WCHAR*)alloca(sizeof(WCHAR)*(nServerNameLen+nClassNameLen+nFormatStringLen+1));
      wsprintf(pwszSchemaObjectPath, g_wzLDAPAbstractSchemaFormat, pADSIObj->GetServerName(), lpszClassName);

      // get the schema class ADSI object
      hr = ::ADsOpenObjectHelper(pwszSchemaObjectPath, 
                      IID_IADsClass, 0,(void**)&spSchemaObjectClass);
      if (FAILED(hr))
          return hr;

  }


  //TRACE(_T("\nObject Properties\n\n"));
  hr = m_propertyRightInfoArray.InitFromSchema(pADSIObj, spSchemaObjectClass,lpszClassName, m_bUseFilter);
    if (FAILED(hr))
        return hr;

  //TRACE(_T("\nObject contained classes\n\n"));
  return m_classRightInfoArray.InitFromSchema(pADSIObj, spSchemaObjectClass, m_bUseFilter);
}



DWORD CAccessPermissionsHolderBase::UpdateAccessList( CPrincipal* pPrincipal,
                                                                        CSchemaClassInfo* pClassInfo,
                                                      LPCWSTR /*lpszServerName*/,
                                                      LPCWSTR /*lpszPhysicalSchemaNamingContext*/,
                                                                        PACL *ppAcl)
{
  TRACE(L"CAccessPermissionsHolderBase::UpdateAccessList()\n");
  const GUID* pClassGUID = NULL;

  TRACE(L"User or Group Name: %s\n", pPrincipal->GetDisplayName());
  
  BOOL bChildClass = TRUE;
  if (pClassInfo != NULL)
  {
    pClassGUID = pClassInfo->GetSchemaGUID();
    bChildClass =  (pClassInfo->m_dwChildClass != CHILD_CLASS_NOT_EXIST );
  }

  return _UpdateAccessListHelper(pPrincipal->GetSid(), pClassGUID, ppAcl,bChildClass);
}


DWORD CAccessPermissionsHolderBase::_UpdateAccessListHelper(PSID pSid, 
                                                 const GUID* pClassGUID,
                                                 PACL *ppAcl,
                                                 BOOL bChildClass)
{
  TRACE(L"CAccessPermissionsHolderBase::_UpdateAccessListHelper()\n");

  ASSERT(pSid != NULL);

  ULONG AccessAllClass = 0;
  ULONG AccessAllProperty = 0;
  
  DWORD dwErr = 0;

  // set common variables

  ULONG uAccess = 0; // to be set and reset as see fit

  if (m_accessRightInfoArr[0]->IsSelected()) // full control
    {
    uAccess = _WIZ_FULL_CTRL;
    dwErr = ::AddObjectRightInAcl(pSid, uAccess, NULL, pClassGUID, ppAcl);
    if (dwErr != ERROR_SUCCESS)
      goto exit;
    }
    else
    {
        // add an entry for all the standard access permissions:
        // OR all the selected permissions together
        uAccess = 0;
        UINT nSel = 0;
        for (UINT k=0; k < m_accessRightInfoArr.GetCount(); k++)
        {
            if (m_accessRightInfoArr[k]->IsSelected())
            {
                nSel++;
                uAccess |= m_accessRightInfoArr[k]->GetAccess();
            }
        } // for

        if( !bChildClass )
            uAccess &= (~(ACTRL_DS_CREATE_CHILD|ACTRL_DS_DELETE_CHILD));
        if (nSel > 0)
        {
          // keep track of "All" flags
            if (uAccess & ACTRL_DS_READ_PROP)
                AccessAllProperty |= ACTRL_DS_READ_PROP;
            if (uAccess &  ACTRL_DS_WRITE_PROP)
                AccessAllProperty |= ACTRL_DS_WRITE_PROP;

            if (uAccess & ACTRL_DS_CREATE_CHILD)
                AccessAllClass |= ACTRL_DS_CREATE_CHILD;
            if (uAccess &  ACTRL_DS_DELETE_CHILD)
                AccessAllClass |= ACTRL_DS_DELETE_CHILD;

            dwErr = ::AddObjectRightInAcl(pSid, uAccess, NULL, pClassGUID, ppAcl);

            if (dwErr != ERROR_SUCCESS)
                goto exit;
        }

        // add an entry for each of the control rights
        for (k=0; k < m_controlRightInfoArr.GetCount(); k++)
        {
            if (m_controlRightInfoArr[k]->IsSelected())
            {
                uAccess = m_controlRightInfoArr[k]->GetAccess();
                dwErr = ::AddObjectRightInAcl(pSid, uAccess, 
                                              m_controlRightInfoArr[k]->GetRightsGUID(), 
                                              pClassGUID,
                                              ppAcl);
            if (dwErr != ERROR_SUCCESS)
                goto exit;
            }
        } // for

        // add an entry for each of the subobjects rigths
        for (ULONG iClass = 0; iClass < m_classRightInfoArray.GetCount(); iClass++)
        {
          ULONG Access = m_classRightInfoArray[iClass]->GetAccess();
          if (Access != 0)
          {
            if (iClass > 0)
            {
              ULONG nRightCount = m_classRightInfoArray[iClass]->GetRightCount();
              for (ULONG iCurrRight=0; iCurrRight<nRightCount; iCurrRight++)
              {
                // the first entry is the Create/Delete All, no need for other permissions,
                ULONG currAccess = m_classRightInfoArray[iClass]->GetRight(iCurrRight);
                if (currAccess & AccessAllClass)
                {
                  // right already present, strip out
                  Access &= ~currAccess;
                }
              } // for
            }
            if (Access != 0)
            {
              uAccess = Access;
              dwErr = ::AddObjectRightInAcl(pSid, uAccess,  
                                            m_classRightInfoArray[iClass]->GetSchemaGUID(), 
                                            pClassGUID,
                                            ppAcl);
              if (dwErr != ERROR_SUCCESS)
                goto exit;
            }
          }
        } // for

        // add an entry for each property right to set
        for (ULONG iProperty=0; iProperty < m_propertyRightInfoArray.GetCount(); iProperty++)
        {
          ULONG Access = m_propertyRightInfoArray[iProperty]->GetAccess();
          if (Access != 0)
          {
            if (iProperty > 0)
            {
              ULONG nRightCount = m_propertyRightInfoArray[iProperty]->GetRightCount();
              for (ULONG iCurrRight=0; iCurrRight<nRightCount; iCurrRight++)
              {
                // the first entry is the Create/Delete All, no need for other permissions,
                ULONG currAccess = m_propertyRightInfoArray[iProperty]->GetRight(iCurrRight);
                if (currAccess & AccessAllProperty)
                {
                  // right already present, strip out
                  Access &= ~currAccess;
                }
              } // for
            }
            if (Access != 0)
            {
              uAccess = Access;
              dwErr = ::AddObjectRightInAcl(pSid, uAccess,  
                                            m_propertyRightInfoArray[iProperty]->GetSchemaGUID(),
                                            pClassGUID,
                                            ppAcl);
              if (dwErr != ERROR_SUCCESS)
                goto exit;
            }
          }
        }

    } // if

exit:

    return dwErr;
}




///////////////////////////////////////////////////////////////////////
// CCustomAccessPermissionsHolder

CCustomAccessPermissionsHolder::CCustomAccessPermissionsHolder()
      : CAccessPermissionsHolderBase(TRUE)
{
}

CCustomAccessPermissionsHolder::~CCustomAccessPermissionsHolder()
{
  Clear();
}

void CCustomAccessPermissionsHolder::Clear()
{
  CAccessPermissionsHolderBase::Clear();
  m_listViewItemArr.Clear();
}


struct CAccessRightTableEntry
{
  UINT m_nStringID;
  ULONG m_fAccess;
};


#define _WIZ_READ \
  (READ_CONTROL | ACTRL_DS_LIST | ACTRL_DS_READ_PROP | ACTRL_DS_LIST_OBJECT)

#define _WIZ_WRITE \
  (ACTRL_DS_SELF | ACTRL_DS_WRITE_PROP)



HRESULT CCustomAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable(BOOL bCreateDeleteChild,BOOL bHideListObject)
{
  static CAccessRightTableEntry _pTable[] = 
  {
    { IDS_DELEGWIZ_ACTRL_FULL,                 _WIZ_FULL_CTRL },
    { IDS_DELEGWIZ_ACTRL_READ,                 _WIZ_READ },
    { IDS_DELEGWIZ_ACTRL_WRITE,                _WIZ_WRITE },
/*
    { IDS_DELEGWIZ_ACTRL_SYSTEM_ACCESS,       ACCESS_SYSTEM_SECURITY },
    { IDS_DELEGWIZ_ACTRL_DELETE,              DELETE                 },
    { IDS_DELEGWIZ_ACTRL_READ_CONTROL,        READ_CONTROL           },
    { IDS_DELEGWIZ_ACTRL_CHANGE_ACCESS,       WRITE_DAC              },
    { IDS_DELEGWIZ_ACTRL_CHANGE_OWNER,        WRITE_OWNER      },
*/
    { IDS_DELEGWIZ_ACTRL_DS_CREATE_CHILD,     ACTRL_DS_CREATE_CHILD   },
    { IDS_DELEGWIZ_ACTRL_DS_DELETE_CHILD,     ACTRL_DS_DELETE_CHILD   },
/*
    { IDS_DELEGWIZ_ACTRL_DS_LIST,             ACTRL_DS_LIST           },
    { IDS_DELEGWIZ_ACTRL_DS_SELF,             ACTRL_DS_SELF           },
*/
    { IDS_DELEGWIZ_ACTRL_DS_READ_PROP,        ACTRL_DS_READ_PROP      },
    { IDS_DELEGWIZ_ACTRL_DS_WRITE_PROP,       ACTRL_DS_WRITE_PROP     },
/*
    { IDS_DELEGWIZ_ACTRL_DS_DELETE_TREE,      ACTRL_DS_DELETE_TREE    },
    { IDS_DELEGWIZ_ACTRL_DS_LIST_OBJECT,      ACTRL_DS_LIST_OBJECT    },
    { IDS_DELEGWIZ_ACTRL_DS_CONTROL_ACCESS,   ACTRL_DS_CONTROL_ACCESS },
*/
    {0, 0x0 } // end of table marker
  };

  if(bHideListObject)
  { 
      _pTable[0].m_fAccess &= ~ACTRL_DS_LIST_OBJECT;
      _pTable[1].m_fAccess &= ~ACTRL_DS_LIST_OBJECT;
  }
    



  TRACE(L"\nCCustomAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable()\n\n");

  for(CAccessRightTableEntry* pCurrEntry = (CAccessRightTableEntry*)_pTable; 
                      pCurrEntry->m_nStringID != NULL; pCurrEntry++)
  {
    if( !bCreateDeleteChild && ( 
                                (pCurrEntry->m_fAccess == ACTRL_DS_CREATE_CHILD) ||
                                (pCurrEntry->m_fAccess == ACTRL_DS_DELETE_CHILD ) ) )

        continue;
    CAccessRightInfo* pInfo = new CAccessRightInfo();
    if( !pInfo )
      return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    if (!pInfo->m_szDisplayName.LoadFromResource(pCurrEntry->m_nStringID))
    {
      delete pInfo;
      continue;
    }
    pInfo->m_fAccess = pCurrEntry->m_fAccess;

    TRACE(L"Display Name = <%s>, Access = 0x%x\n", 
          pInfo->m_szDisplayName.c_str(), pInfo->m_fAccess);
    m_accessRightInfoArr.Add(pInfo);
  }

  TRACE(L"\nCCustomAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable() exiting\n\n");

  return S_OK;
}




void CCustomAccessPermissionsHolder::_SelectAllRigths()
{
  ULONG i,j;

  // select all access rigths
  for (i = 0; i < m_accessRightInfoArr.GetCount(); i++)
  {
    m_accessRightInfoArr[i]->Select(TRUE);
  }

  // select all control rights rigths
  for (i = 0; i < m_controlRightInfoArr.GetCount(); i++)
  {
    m_controlRightInfoArr[i]->Select(TRUE);
  }

  // select all subobjects rigths
  for (i = 0; i < m_classRightInfoArray.GetCount(); i++)
  {
    for (j=0; j< m_classRightInfoArray[i]->GetRightCount(); j++)
    {
      m_classRightInfoArray[i]->SetRight(j, TRUE);
    }
  }

  // select all property rights
  for (i = 0; i < m_propertyRightInfoArray.GetCount(); i++)
  {
    for (j=0; j< m_propertyRightInfoArray[i]->GetRightCount(); j++)
    {
      m_propertyRightInfoArray[i]->SetRight(j, TRUE);
    }
  }

}


void CCustomAccessPermissionsHolder::_SelectAllPropertyRigths(ULONG fAccessPermission)
{
  for (UINT i=0; i<m_propertyRightInfoArray.GetCount(); i++)
  {
    m_propertyRightInfoArray[i]->AddAccessRight(fAccessPermission);
  }
}

void CCustomAccessPermissionsHolder::_SelectAllSubObjectRigths(ULONG fAccessPermission)
{
  for (UINT i=0; i<m_classRightInfoArray.GetCount(); i++)
  {
    m_classRightInfoArray[i]->AddAccessRight(fAccessPermission);
  }
}


void CCustomAccessPermissionsHolder::_DeselectAssociatedRights(ULONG fAccessPermission)
{
  // deselect full control first
  m_accessRightInfoArr[0]->Select(FALSE);

  if (fAccessPermission != 0)
  {
    // deselect any other basic right that contains the flag
    UINT nCount = (ULONG) m_accessRightInfoArr.GetCount();
    for (ULONG iAccess=0; iAccess<nCount; iAccess++)
    {
      if (m_accessRightInfoArr[iAccess]->GetAccess() & fAccessPermission)
        m_accessRightInfoArr[iAccess]->Select(FALSE);
    }
  }
}


void CCustomAccessPermissionsHolder::Select(IN CRigthsListViewItem* pItem,
                                            IN BOOL bSelect,
                                            OUT ULONG* pnNewFilterState)
{
  ASSERT(pItem != NULL);

  *pnNewFilterState = 0;

  switch (pItem->m_type)
  {
    case CRigthsListViewItem::access: // access rights
    case CRigthsListViewItem::ctrl: // general rights
      {
        // make the change to the entry that was passed in as argument
        if (pItem->m_type == CRigthsListViewItem::access)
        {
          m_accessRightInfoArr[pItem->m_iIndex]->Select(bSelect);
        }
        else
        {
          m_controlRightInfoArr[pItem->m_iIndex]->Select(bSelect);
        }
        
        // now see if this triggers changes to the other entries
        if (bSelect)
        {
          if  (pItem->m_type == CRigthsListViewItem::access) 
          {
            if (pItem->m_iIndex == 0)
            {
              // the user checked full control, need to select all the rigths
              _SelectAllRigths();

              // set flags to mark which set of flags is affected
              *pnNewFilterState |= FILTER_EXP_GEN;

              if (m_propertyRightInfoArray.GetCount() > 0)
                *pnNewFilterState |= FILTER_EXP_PROP;

              if (m_classRightInfoArray.GetCount() > 0)
                *pnNewFilterState |= FILTER_EXP_SUBOBJ;
            }
            else 
            {
              // check if the user selected some read/write all or create/delete all right
              UINT iAccess = pItem->m_iIndex;
              ULONG fAccessPermission = m_accessRightInfoArr[iAccess]->GetAccess();

              if ((fAccessPermission == _WIZ_READ) || (fAccessPermission == _WIZ_WRITE) )
              {
                // need to select all the Read or Write Properties entried
                // and the ACTRL_DS_READ_PROP ACTRL_DS_WRITE_PROP (Read All/Write All)
                // select all access rigths
                UINT nAssociatedAccessRight = 
                  (fAccessPermission == _WIZ_READ) ? ACTRL_DS_READ_PROP : ACTRL_DS_WRITE_PROP;
                for (UINT i = 0; i < m_accessRightInfoArr.GetCount(); i++)
                {
                  if (m_accessRightInfoArr[i]->GetAccess() == nAssociatedAccessRight)
                  {
                    m_accessRightInfoArr[i]->Select(TRUE);
                    _SelectAllPropertyRigths(nAssociatedAccessRight);
                    if (m_propertyRightInfoArray.GetCount() > 0)
                      *pnNewFilterState |= FILTER_EXP_PROP;
                    break;
                  }
                }
              }

              if ( (fAccessPermission == ACTRL_DS_CREATE_CHILD) || (fAccessPermission == ACTRL_DS_DELETE_CHILD) )
              {
                // need to select all the Create or Delete Child entries, if present
                _SelectAllSubObjectRigths(fAccessPermission);

                // set the flags
                if (m_classRightInfoArray.GetCount() > 0)
                  *pnNewFilterState |= FILTER_EXP_SUBOBJ;
              }
              else if ( (fAccessPermission == ACTRL_DS_READ_PROP) || (fAccessPermission == ACTRL_DS_WRITE_PROP) )
              {
                // need to select all the Read or Write Property entries, if present
                _SelectAllPropertyRigths(fAccessPermission);

                // set the flags
                if (m_propertyRightInfoArray.GetCount() > 0)
                  *pnNewFilterState |= FILTER_EXP_PROP;
              } // if
            } // if index zero
          } // if type is access
        }
        else // i.e. !bSelect
        {
          if (pItem->m_type == CRigthsListViewItem::access)
          {
            if (pItem->m_iIndex != 0)
            {
              // deselection on anything but full control
              _DeselectAssociatedRights(m_accessRightInfoArr[pItem->m_iIndex]->GetAccess());
            }
          }
          else if (pItem->m_type == CRigthsListViewItem::ctrl)
          {
            _DeselectAssociatedRights(m_controlRightInfoArr[pItem->m_iIndex]->GetAccess());
          }
/*
          // deselection on anything but full control
          if ( !((pItem->m_iIndex == 0) && (pItem->m_type == CRigthsListViewItem::access)) )
          {
            _DeselectAssociatedRights(0);
          }
*/
        }
      }
      break;

    case CRigthsListViewItem::prop: // property rights
      {
        ASSERT(pItem->m_iIndex < m_propertyRightInfoArray.GetCount());
        m_propertyRightInfoArray[pItem->m_iIndex]->SetRight(pItem->m_iRight, bSelect);
        if (!bSelect)
        {
          // unchecking any Read/Write property, will unckeck the Read/Write All,
          // Read and full control
          _DeselectAssociatedRights(m_propertyRightInfoArray[pItem->m_iIndex]->GetRight(pItem->m_iRight));
        }
      }
      break;

    case CRigthsListViewItem::subobj: // subobject rigths
      {
        ASSERT(pItem->m_iIndex < m_classRightInfoArray.GetCount());
        m_classRightInfoArray[pItem->m_iIndex]->SetRight(pItem->m_iRight, bSelect);
        if (!bSelect)
        {
          // unchecking any Create/Delete property, will unckeck the Create/Delete All
          // and full control
          _DeselectAssociatedRights(m_classRightInfoArray[pItem->m_iIndex]->GetRight(pItem->m_iRight));
        }
      }
      break;
    default:
      ASSERT(FALSE);
  };

}


void CCustomAccessPermissionsHolder::FillAccessRightsListView(
                       CCheckListViewHelper* pListViewHelper,
                       ULONG nFilterState)
{
  // clear the array of list view item proxies
  m_listViewItemArr.Clear();

  // enumerate the permissions and add to the checklist
  ULONG i,j;
  ULONG iListViewItem = 0;
  
  // GENERAL RIGTHS
  if (nFilterState & FILTER_EXP_GEN)
  {
    // add the list of access rights
    UINT nAccessCount = (ULONG) m_accessRightInfoArr.GetCount();
    for (i = 0; i < nAccessCount; i++)
    {
      // filter out entries with ACTRL_SYSTEM_ACCESS (auditing rigths)
      if  ( (m_accessRightInfoArr[i]->GetAccess() & ACTRL_SYSTEM_ACCESS) == 0)
      {
        CRigthsListViewItem* p = new CRigthsListViewItem(i, // index in m_accessRightInfoArr
                                                         0, // iRight
                                                         CRigthsListViewItem::access);
        m_listViewItemArr.Add(p);
        pListViewHelper->InsertItem(iListViewItem, 
                                    m_accessRightInfoArr[i]->GetDisplayName(), 
                                    (LPARAM)p,
                                    m_accessRightInfoArr[i]->IsSelected());
        iListViewItem++;
      }
    }

    // add the list of control rights
    UINT nControlCount = (ULONG) m_controlRightInfoArr.GetCount();
    for (i = 0; i < nControlCount; i++)
    {
      CRigthsListViewItem* p = new CRigthsListViewItem(i, // index in m_controlRightInfoArr
                                                        0, // iRight 
                                                        CRigthsListViewItem::ctrl);
      m_listViewItemArr.Add(p);
      pListViewHelper->InsertItem(iListViewItem, 
                                  m_controlRightInfoArr[i]->GetDisplayName(), 
                                  (LPARAM)p,
                                  m_controlRightInfoArr[i]->IsSelected());
      iListViewItem++;
    }
  }
  
  // PROPERTY RIGTHS
  if (nFilterState & FILTER_EXP_PROP)
  {
    // it expands (2x)
    for (i = 0; i < (ULONG) m_propertyRightInfoArray.GetCount(); i++)
    {
      for (j=0; j< m_propertyRightInfoArray[i]->GetRightCount(); j++)
      {
        LPCWSTR pszRightDisplayName = m_propertyRightInfoArray[i]->GetRightDisplayString(j);
        if(pszRightDisplayName)
        {
            CRigthsListViewItem* p = new CRigthsListViewItem(i,j, CRigthsListViewItem::prop);
            m_listViewItemArr.Add(p);
            pListViewHelper->InsertItem(iListViewItem, 
                                        pszRightDisplayName, 
                                        (LPARAM)p,
                                        m_propertyRightInfoArray[i]->IsRightSelected(j));
            iListViewItem++;
        }
      }
    }
  }

  // SUBOBJECT RIGTHS
  if (nFilterState & FILTER_EXP_SUBOBJ)
  {
    // it expands (2x)
    for (i = 0; i < m_classRightInfoArray.GetCount(); i++)
    {
      for (j=0; j< m_classRightInfoArray[i]->GetRightCount(); j++)
      {
        LPCWSTR pszRightDisplayName = m_classRightInfoArray[i]->GetRightDisplayString(j);
        if(pszRightDisplayName)
        {

            CRigthsListViewItem* p = new CRigthsListViewItem(i,j, CRigthsListViewItem::subobj);
            m_listViewItemArr.Add(p);
            pListViewHelper->InsertItem(iListViewItem, 
                                        pszRightDisplayName, 
                                        (LPARAM)p,
                                        m_classRightInfoArray[i]->IsRightSelected(j));
            iListViewItem++;
        }
      }
    }
  } // if

  ASSERT(iListViewItem == m_listViewItemArr.GetCount());
}

void CCustomAccessPermissionsHolder::UpdateAccessRightsListViewSelection(
                       CCheckListViewHelper* pListViewHelper,
                       ULONG /*nFilterState*/)
{
  // syncrhonize the UI with the data
  int nListViewCount = pListViewHelper->GetItemCount();

  for (int iListViewItem=0; iListViewItem < nListViewCount; iListViewItem++)
  {
    CRigthsListViewItem* pCurrItem = 
          (CRigthsListViewItem*)pListViewHelper->GetItemData(iListViewItem);

    switch (pCurrItem->m_type)
    {
      case CRigthsListViewItem::access:
        {
          pListViewHelper->SetItemCheck(iListViewItem, 
                    m_accessRightInfoArr[pCurrItem->m_iIndex]->IsSelected());
        }
        break;
      case CRigthsListViewItem::ctrl:
        {
          pListViewHelper->SetItemCheck(iListViewItem,
                m_controlRightInfoArr[pCurrItem->m_iIndex]->IsSelected());
        }
        break;
      case CRigthsListViewItem::prop:
        {
         pListViewHelper->SetItemCheck(iListViewItem,
           m_propertyRightInfoArray[pCurrItem->m_iIndex]->IsRightSelected(pCurrItem->m_iRight));
        }
        break;
      case CRigthsListViewItem::subobj:
        {
         pListViewHelper->SetItemCheck(iListViewItem,
           m_classRightInfoArray[pCurrItem->m_iIndex]->IsRightSelected(pCurrItem->m_iRight));
        }
        break;
    } // switch
  } // for

}



void CCustomAccessPermissionsHolder::WriteSummary(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  WriteSummaryTitleLine(szSummary, IDS_DELEGWIZ_FINISH_PERMISSIONS, lpszNewLine);

  if (m_accessRightInfoArr[0]->IsSelected()) // full control
    {
    WriteSummaryLine(szSummary, m_accessRightInfoArr[0]->GetDisplayName(), lpszIdent, lpszNewLine);
    }
    else
    {
    ULONG AccessAllClass = 0;
    ULONG AccessAllProperty = 0;

    UINT i,j,k;
    // add an entry for all the standard access permissions:
        for (k=0; k < m_accessRightInfoArr.GetCount(); k++)
        {
            if (m_accessRightInfoArr[k]->IsSelected())
      {
        // keep track of "All" flags
        if (m_accessRightInfoArr[k]->GetAccess() & ACTRL_DS_READ_PROP)
          AccessAllProperty |= ACTRL_DS_READ_PROP;
        if (m_accessRightInfoArr[k]->GetAccess() &  ACTRL_DS_WRITE_PROP)
          AccessAllProperty |= ACTRL_DS_WRITE_PROP;

        if (m_accessRightInfoArr[k]->GetAccess() & ACTRL_DS_CREATE_CHILD)
          AccessAllClass |= ACTRL_DS_CREATE_CHILD;
        if (m_accessRightInfoArr[k]->GetAccess() &  ACTRL_DS_DELETE_CHILD)
          AccessAllClass |= ACTRL_DS_DELETE_CHILD;

        WriteSummaryLine(szSummary, m_accessRightInfoArr[k]->GetDisplayName(), lpszIdent, lpszNewLine);
      }
    } // for

    // add an entry for each of the control rights
    for (k=0; k < m_controlRightInfoArr.GetCount(); k++)
    {
      if (m_controlRightInfoArr[k]->IsSelected())
      {
        WriteSummaryLine(szSummary, m_controlRightInfoArr[k]->GetDisplayName(), lpszIdent, lpszNewLine);
      }
    } // for

    // add an entry for each of the subobjects rigths
    for (i = 0; i < m_classRightInfoArray.GetCount(); i++)
    {
      for (j=0; j< m_classRightInfoArray[i]->GetRightCount(); j++)
      {
        if ( m_classRightInfoArray[i]->IsRightSelected(j) &&
              ((AccessAllClass & m_classRightInfoArray[i]->GetRight(j)) == 0) )
        {
          LPCWSTR pszRightDisplayString = m_classRightInfoArray[i]->GetRightDisplayString(j);
          if(pszRightDisplayString)
          {
            WriteSummaryLine(szSummary, pszRightDisplayString, lpszIdent, lpszNewLine);
          }
        }
      }
    }

    // add an entry for each property right to set
    for (i = 0; i < m_propertyRightInfoArray.GetCount(); i++)
    {
      for (j=0; j< m_propertyRightInfoArray[i]->GetRightCount(); j++)
      {
        if ( m_propertyRightInfoArray[i]->IsRightSelected(j) &&
            ((AccessAllProperty & m_propertyRightInfoArray[0]->GetRight(j)) == 0) )
        {
          LPCWSTR pszRightDisplayString = m_propertyRightInfoArray[i]->GetRightDisplayString(j);
          if(pszRightDisplayString)
          {
            WriteSummaryLine(szSummary, pszRightDisplayString, lpszIdent, lpszNewLine);
          }
        }
      }
    }

  } // if

  szSummary += lpszNewLine;
}



///////////////////////////////////////////////////////////////////////
// CCheckListViewHelper

#define CHECK_BIT(x) ((x >> 12) -1)
#define CHECK_CHANGED(pNMListView) \
    (CHECK_BIT(pNMListView->uNewState) ^ CHECK_BIT(pNMListView->uOldState))

#define LVIS_STATEIMAGEMASK_CHECK (0x2000)
#define LVIS_STATEIMAGEMASK_UNCHECK (0x1000)


BOOL CCheckListViewHelper::IsChecked(NM_LISTVIEW* pNMListView)
{
    return (CHECK_BIT(pNMListView->uNewState) != 0);
}


BOOL CCheckListViewHelper::CheckChanged(NM_LISTVIEW* pNMListView)
{
    if (pNMListView->uOldState == 0)
        return FALSE; // adding new items...
    return CHECK_CHANGED(pNMListView) ? TRUE : FALSE;
}

BOOL CCheckListViewHelper::Initialize(UINT nID, HWND hParent)
{
    m_hWnd = GetDlgItem(hParent, nID);
    if (m_hWnd == NULL)
        return FALSE;

    ListView_SetExtendedListViewStyle(m_hWnd, LVS_EX_CHECKBOXES);

    RECT r;
    ::GetClientRect(m_hWnd, &r);
    int scroll = ::GetSystemMetrics(SM_CXVSCROLL);
    LV_COLUMN col;
    ZeroMemory(&col, sizeof(LV_COLUMN));
    col.mask = LVCF_WIDTH;
    col.cx = (r.right - r.left) - scroll;
    return (0 == ListView_InsertColumn(m_hWnd,0,&col));
}

int CCheckListViewHelper::InsertItem(int iItem, LPCTSTR lpszText, LPARAM lParam, BOOL bCheck)
{
  TRACE(_T("CCheckListViewHelper::InsertItem(%d,%s,%x)\n"),iItem, lpszText, lParam);

    LV_ITEM item;
    ZeroMemory(&item, sizeof(LV_ITEM));
    item.mask = LVIF_TEXT | LVIF_PARAM;
    item.pszText = (LPTSTR)lpszText;
    item.lParam = lParam;
    item.iItem = iItem;

  int iRes = ListView_InsertItem(m_hWnd, &item);
  if ((iRes != -1) && bCheck)
    SetItemCheck(iItem, TRUE);
  return iRes;
}

BOOL CCheckListViewHelper::SetItemCheck(int iItem, BOOL bCheck)
{
    LV_ITEM item;
    ZeroMemory(&item, sizeof(LV_ITEM));
    item.mask = LVIF_STATE;
    item.state = bCheck ? LVIS_STATEIMAGEMASK_CHECK : LVIS_STATEIMAGEMASK_UNCHECK;
    item.stateMask = LVIS_STATEIMAGEMASK;
    item.iItem = iItem;
    return ListView_SetItem(m_hWnd, &item);
}

void CCheckListViewHelper::SetCheckAll(BOOL bCheck)
{
    LV_ITEM item;
    ZeroMemory(&item, sizeof(LV_ITEM));
    item.mask = LVIF_STATE;
    item.state = bCheck ? LVIS_STATEIMAGEMASK_CHECK : LVIS_STATEIMAGEMASK_UNCHECK;
    item.stateMask = LVIS_STATEIMAGEMASK;

    int nCount = ListView_GetItemCount(m_hWnd);
    for (int k = 0; k< nCount; k++)
    {
        item.iItem = k;
        ListView_SetItem(m_hWnd, &item);
    }
}

LPARAM CCheckListViewHelper::GetItemData(int iItem)
{
    LV_ITEM item;
    ZeroMemory(&item, sizeof(LV_ITEM));
    item.mask = LVIF_PARAM;
    item.iItem = iItem;
    ListView_GetItem(m_hWnd, &item);
    return item.lParam;
}

int CCheckListViewHelper::GetCheckCount()
{
    int nCount = GetItemCount();
    int nCheckCount = 0;
    for (int k=0; k<nCount; k++)
    {
        if (ListView_GetCheckState(m_hWnd,k))
            nCheckCount++;
    }
    return nCheckCount;
}

BOOL CCheckListViewHelper::IsItemChecked(int iItem)
{
  return ListView_GetCheckState(m_hWnd, iItem);
}

void CCheckListViewHelper::GetCheckedItems(int nCheckCount, int* nCheckArray)
{
    int nCount = GetItemCount();
    int nCurrentCheck = 0;
    for (int k=0; k<nCount; k++)
    {
        if (ListView_GetCheckState(m_hWnd,k) && nCurrentCheck < nCheckCount)
        {
            nCheckArray[nCurrentCheck++] = k;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
// CNamedSecurityInfo

/*
DWORD CNamedSecurityInfo::Get()
{
  Reset(); // clear previous data

  LPWSTR lpProvider = NULL; // not used
  LPWSTR lpProperty = NULL; // want all

  return ::GetNamedSecurityInfoEx(IN (LPWSTR) m_szObjectName.data(),
                        IN   SE_DS_OBJECT_ALL,
                        IN   DACL_SECURITY_INFORMATION,
                        IN   lpProvider,
                        IN   lpProperty,
                        OUT  &m_pAccessList,
                        OUT  &m_pAuditList,
                        OUT  &m_pOwner,
                        OUT  &m_pGroup);
}


DWORD CNamedSecurityInfo::Set()
{
  LPWSTR lpProvider = NULL; // not used

  dwErr = ::SetNamedSecurityInfoEx(IN   (LPWSTR) m_szObjectName.data(),
                        IN   SE_DS_OBJECT_ALL,
                        IN   DACL_SECURITY_INFORMATION,
                        IN   lpProvider,
                        IN   m_pAccessList,
                        IN   m_pAuditList,
                        IN   m_pOwner,
                        IN   m_pGroup,
                        IN   NULL); // PACTRL_OVERLAPPED pOverlapped;
}

CNamedSecurityInfo::Reset()
{
    if (m_pAuditList != NULL)
        ::LocalFree(m_pAuditList);
    if (m_pOwner != NULL)
        ::LocalFree(m_pOwner);
    if (m_pGroup != NULL)
        ::LocalFree(m_pGroup);

    if (m_pAccessList != NULL)
        ::LocalFree(m_pAccessList);
}

*/


////////////////////////////////////////////////////////////////////////////
// CAdsiObject

HRESULT CAdsiObject::Bind(LPCWSTR lpszLdapPath)
{
  _Clear();

  CComBSTR bstrNamingContext;
  CComBSTR bstrClass;


    // try to bind to the given LDAP path
  HRESULT hr = ::ADsOpenObjectHelper(lpszLdapPath,
                        IID_IADs,
                        0,
                        (void **)&m_spIADs);
  if (FAILED(hr))
    {
    TRACE(_T("Bind to DS object for IADs failed: %lx.\n"), hr);
    goto error;
  }

  // get the DNS server name
  hr = _QueryDNSServerName();
  if (FAILED(hr))
    {
    TRACE(_T("Trying to get the DNS server name failed: %lx.\n"), hr);
    goto error;
  }

  hr = _InitGlobalNamingContexts();
  if (FAILED(hr))
    {
    TRACE(_T("Trying to get the physical schema naming context failed: %lx.\n"), hr);
    goto error;
  }

  // need now to rebuild the LDAP path
  // to make sure we talk always to the same server
  hr = GetPathNameObject()->SkipPrefix(lpszLdapPath, &bstrNamingContext);
  if (FAILED(hr))
  {
    TRACE(_T("Trying to get X500 name failed: %lx.\n"), hr);
    goto error;
  }
  if ( (!bstrNamingContext ) || (!bstrNamingContext[0]))
  {
    goto error;
  }
  m_szNamingContext = bstrNamingContext;
  BuildLdapPathHelper(GetServerName(), bstrNamingContext, m_szLdapPath);

  // get the canonical name
  hr = GetCanonicalNameFromNamingContext(bstrNamingContext, m_szCanonicalName);
  if (FAILED(hr))
  {
    TRACE(_T("Trying to get canonical name failed, using naming context instead: %lx.\n"), hr);
    m_szCanonicalName = bstrNamingContext;
  }
  // get the object class
    hr = m_spIADs->get_Class(&bstrClass);
  if (FAILED(hr))
  {
    TRACE(_T("Trying to get class name failed: %lx.\n"), hr);
    goto error;
  }
  ASSERT(bstrClass != NULL);
  m_szClass = bstrClass;


  // load and set the display specifier cache
  hr = ::CoCreateInstance(CLSID_DsDisplaySpecifier,
                          NULL,
                                      CLSCTX_INPROC_SERVER,
                          IID_IDsDisplaySpecifier,
                          (void**)&m_spIDsDisplaySpecifier);
  if (FAILED(hr))
  {
    TRACE(_T("Trying to get the display specifier cache failed: %lx.\n"), hr);
    goto error;
  }

  hr = m_spIDsDisplaySpecifier->SetServer(GetServerName(), NULL, NULL, 0x0);
  if (FAILED(hr))
  {
    TRACE(_T("m_spIDsDisplaySpecifier->SetServer(%s) failed\n"), GetServerName());
    goto error;
  }

  ASSERT(SUCCEEDED(hr)); // all went fine
  return hr;

error:
  // on error condition, just reset the info, we do not
  // want a partially constructed object
  _Clear();
  return hr;
}



#define DO_TIMING

HRESULT CAdsiObject::QuerySchemaClasses(CGrowableArr<CSchemaClassInfo>* pSchemaClassesInfoArray,
                                        BOOL bGetAttributes)
{
  TRACE(L"\n==================================================\n");
  TRACE(L"CAdsiObject::QuerySchemaClasses\n\n");
#if defined (DO_TIMING)
  DWORD dwTick1 = ::GetTickCount();
#endif

  // make sure we are bound
  if (m_spIADs == NULL)
  {
    return E_INVALIDARG;
  }

    // cleanup current entries in the list
    pSchemaClassesInfoArray->Clear();

    // build the LDAP path for the schema class
  CWString szPhysicalSchemaPath;
  LPCWSTR lpszPhysicalSchemaNamingContext = GetPhysicalSchemaNamingContext();
  BuildLdapPathHelper(GetServerName(), lpszPhysicalSchemaNamingContext, szPhysicalSchemaPath);

  CAdsiSearch search;
  HRESULT hr = search.Init(szPhysicalSchemaPath);
  if (FAILED(hr))
    return hr;

  static LPCWSTR lpszClassFilterFormat = L"(&(objectCategory=CN=Class-Schema,%s)(lDAPDisplayName=*))";
  static LPCWSTR lpszAttributeFilterFormat = L"(&(objectCategory=CN=Attribute-Schema,%s)(lDAPDisplayName=*))";
  LPCWSTR lpszFilterFormat = bGetAttributes ? lpszAttributeFilterFormat : lpszClassFilterFormat;

  int nFmtLen = lstrlen(lpszFilterFormat);
  int nSchemaContextLen = lstrlen(lpszPhysicalSchemaNamingContext);

  WCHAR* lpszFilter = (WCHAR*)alloca(sizeof(WCHAR)*(nFmtLen+nSchemaContextLen+1));
  wsprintf(lpszFilter, lpszFilterFormat, lpszPhysicalSchemaNamingContext);

  static const int cAttrs = 4;
  static LPCWSTR pszAttribsArr[cAttrs] = 
  {
    L"lDAPDisplayName", // e.g. "organizationalUnit"
    L"name",             // e.g. "Organizational-Unit"
    L"schemaIDGUID",
    L"objectClassCategory", 
  }; 

  
  hr = search.SetSearchScope(ADS_SCOPE_ONELEVEL);
  if (FAILED(hr))
    return hr;
  hr = search.DoQuery(lpszFilter, pszAttribsArr, cAttrs);

  if (FAILED(hr))
    return hr;

  CWString szLDAPName, szName;
  szLDAPName = L"";
  szName = L"";
  GUID schemaIDGUID;
  ULONG iObjectClassCategory=0;

  while ((hr = search.GetNextRow()) != S_ADS_NOMORE_ROWS)
  {
    if (FAILED(hr))
      continue;

    HRESULT hr0 = search.GetColumnString(pszAttribsArr[0], szLDAPName);
    HRESULT hr1 = search.GetColumnString(pszAttribsArr[1], szName);
    HRESULT hr2 = search.GetColumnOctectStringGUID(pszAttribsArr[2], schemaIDGUID);
    HRESULT hr3 = search.GetColumnInteger(pszAttribsArr[3], iObjectClassCategory);


    if (FAILED(hr0) || FAILED(hr1) || FAILED(hr2) || FAILED(hr3))
      continue;

    ULONG fFilterFlags = ::GetClassFlags(szLDAPName);

    CSchemaClassInfo* p = new CSchemaClassInfo(szLDAPName, szName, &schemaIDGUID);
    if(!p)
        return E_OUTOFMEMORY;

    BOOL bFilter = (fFilterFlags & IDC_CLASS_NO);
    if (bFilter)
      p->SetFiltered();

    //is class Auxiallary
    if(iObjectClassCategory == 3)
        p->SetAux();

    pSchemaClassesInfoArray->Add(p);
    //TRACE(L"Class %s inserted, IsFiltered() == %d\n", (LPCWSTR)szName, p->IsFiltered());

  } // while

  TRACE(L"\n================================================\n");
#if defined (DO_TIMING)
  DWORD dwTick2 = ::GetTickCount();
  TRACE(L"Time to do Schema Query loop (mSec) = %d\n", dwTick2-dwTick1);
#endif

  _GetFriendlyClassNames(pSchemaClassesInfoArray);

#if defined (DO_TIMING)
  dwTick2 = ::GetTickCount();
#endif
  pSchemaClassesInfoArray->Sort(); // wrt friendly class name

#if defined (DO_TIMING)
  DWORD dwTick3 = ::GetTickCount();
  TRACE(L"Time to sort (mSec) = %d\n", dwTick3-dwTick2);
#endif



  TRACE(L"exiting CAdsiObject::QuerySchemaClasses()\n\n");
  return hr;
}


HRESULT CAdsiObject::GetClassGuid(LPCWSTR lpszClassLdapDisplayName, BOOL bGetAttribute, GUID& guid)
{
  //TRACE(L"CAdsiObject::GetClassGuid(%s, _)\n\n", lpszClassLdapDisplayName);

  ZeroMemory(&guid, sizeof(GUID));

  // make sure we are bound
  if (m_spIADs == NULL)
  {
    return E_INVALIDARG;
  }


    // build the LDAP path for the schema class
  CWString szPhysicalSchemaPath;
  LPCWSTR lpszPhysicalSchemaNamingContext = GetPhysicalSchemaNamingContext();
  BuildLdapPathHelper(GetServerName(), lpszPhysicalSchemaNamingContext, szPhysicalSchemaPath);

  CAdsiSearch search;
  HRESULT hr = search.Init(szPhysicalSchemaPath);
  if (FAILED(hr))
    return hr;

  static LPCWSTR lpszClassFilterFormat = L"(&(objectCategory=CN=Class-Schema,%s)(lDAPDisplayName=%s))";
  static LPCWSTR lpszAttributeFilterFormat = L"(&(objectCategory=CN=Attribute-Schema,%s)(lDAPDisplayName=%s))";
  LPCWSTR lpszFilterFormat = bGetAttribute ? lpszAttributeFilterFormat : lpszClassFilterFormat;

  int nFmtLen = lstrlen(lpszFilterFormat);
  int nSchemaContextLen = lstrlen(lpszPhysicalSchemaNamingContext);
  int nlDAPDisplayNameLen = lstrlen(lpszClassLdapDisplayName);

  WCHAR* lpszFilter = (WCHAR*)alloca(sizeof(WCHAR)*(nFmtLen+nSchemaContextLen+nlDAPDisplayNameLen+1));
  wsprintf(lpszFilter, lpszFilterFormat, lpszPhysicalSchemaNamingContext, lpszClassLdapDisplayName);


  //TRACE(L"lpszFilter = %s\n", lpszFilter);

  static const int cAttrs = 1;
  static LPCWSTR pszAttribsArr[cAttrs] = 
  {
    L"schemaIDGUID",
  }; 
  
  hr = search.SetSearchScope(ADS_SCOPE_ONELEVEL);
  if (FAILED(hr))
    return hr;
  hr = search.DoQuery(lpszFilter, pszAttribsArr, cAttrs);

  if (FAILED(hr))
    return hr;


  // expect a single result
  hr = search.GetNextRow();
  if ( hr == S_ADS_NOMORE_ROWS)
  {
    hr = E_ADS_UNKNOWN_OBJECT;
  }
  if (FAILED(hr))
    return hr;

  hr = search.GetColumnOctectStringGUID(pszAttribsArr[0], guid);

  //TRACE(L"exiting CAdsiObject::GetClassGuid()\n\n");
  return hr;
}




HRESULT CAdsiObject::_QueryDNSServerName()
{
  // make sure we are bound
  if (m_spIADs == NULL)
  {
    return E_INVALIDARG;
  }

  m_szServerName = L"";

  CComPtr<IADsObjectOptions> spIADsObjectOptions;
  HRESULT hr = m_spIADs->QueryInterface(IID_IADsObjectOptions, (void**)&spIADsObjectOptions);
  if (FAILED(hr))
    return hr;

  CComVariant var;
  hr = spIADsObjectOptions->GetOption(ADS_OPTION_SERVERNAME, &var);
  if (FAILED(hr))
    return hr;

  if(var.vt == VT_BSTR)
  {
    m_szServerName = V_BSTR(&var);
  }
  else
  {
      hr = E_INVALIDARG;
  }

  return hr;
}


HRESULT CAdsiObject::_InitGlobalNamingContexts()
{
  return ::GetGlobalNamingContexts(GetServerName(),
                                   m_szPhysicalSchemaNamingContext,
                                   m_szConfigurationNamingContext);
}



HICON CAdsiObject::GetClassIcon(LPCWSTR lpszObjectClass)
{
  ASSERT(m_spIDsDisplaySpecifier != NULL);

  return m_spIDsDisplaySpecifier->GetIcon(lpszObjectClass,
                                          DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON,
                                          32, 32);
}


HRESULT CAdsiObject::GetFriendlyClassName(LPCWSTR lpszObjectClass, 
                                          LPWSTR lpszBuffer, int cchBuffer)
{
  ASSERT(m_spIDsDisplaySpecifier != NULL);
  return m_spIDsDisplaySpecifier->GetFriendlyClassName(lpszObjectClass,
                                                       lpszBuffer,
                                                       cchBuffer);
}

HRESULT CAdsiObject::GetFriendlyAttributeName(LPCWSTR lpszObjectClass, 
                                              LPCWSTR lpszAttributeName,
                                              LPWSTR lpszBuffer, int cchBuffer)
{
  ASSERT(m_spIDsDisplaySpecifier != NULL);
  return m_spIDsDisplaySpecifier->GetFriendlyAttributeName(lpszObjectClass, 
                                                           lpszAttributeName,
                                                           lpszBuffer, cchBuffer);
}


#if (FALSE)

HRESULT CAdsiObject::_GetFriendlyClassNames(CGrowableArr<CSchemaClassInfo>* pSchemaClassesInfoArray)
{
  TRACE(L"begin _GetFriendlyClassNames() loop on all classes\n");

#if defined (DO_TIMING)
  DWORD dwTick1 = ::GetTickCount();
#endif

  // now get the friendly class name to display
  ULONG nCount = pSchemaClassesInfoArray->GetCount();
  WCHAR szFrendlyName[1024];

  for (UINT k=0; k<nCount; k++)
  {
    CSchemaClassInfo* p = (*pSchemaClassesInfoArray)[k];
    HRESULT hrFriendlyName = this->GetFriendlyClassName(p->GetName(), szFrendlyName, 1024);
    ASSERT(SUCCEEDED(hrFriendlyName));
    (*pSchemaClassesInfoArray)[k]->SetDisplayName(SUCCEEDED(hrFriendlyName) ? szFrendlyName : NULL);
  }

#if defined (DO_TIMING)
  DWORD dwTick2 = ::GetTickCount();
  TRACE(L"Time to call _GetFriendlyClassNames() loop (mSec) = %d\n", dwTick2-dwTick1);
#endif

  return S_OK;
}

#else

HRESULT CAdsiObject::_GetFriendlyClassNames(CGrowableArr<CSchemaClassInfo>* pSchemaClassesInfoArray)
{
  TRACE(L"\nbegin _GetFriendlyClassNames() using ADSI query\n");

#if defined (DO_TIMING)
  DWORD dwTick1 = ::GetTickCount();
#endif

  ASSERT(m_spIDsDisplaySpecifier != NULL);

  // get the display specifiers locale container (e.g. 409)
  CComPtr<IADs> spLocaleContainer;
  HRESULT hr = m_spIDsDisplaySpecifier->GetDisplaySpecifier(NULL, IID_IADs, (void**)&spLocaleContainer);
  if (FAILED(hr))
    return hr;

  // get distinguished name of the container
  CComVariant varLocaleContainerDN;
  hr = spLocaleContainer->Get(CComBSTR (L"distinguishedName"), &varLocaleContainerDN);
  if (FAILED(hr))
    return hr;

  // build the LDAP path for it
  CWString szLocaleContainerPath;
  BuildLdapPathHelper(GetServerName(), varLocaleContainerDN.bstrVal, szLocaleContainerPath);

    // build the LDAP path for the schema class
  CWString szPhysicalSchemaPath;
  LPCWSTR lpszPhysicalSchemaNamingContext = GetPhysicalSchemaNamingContext();
  BuildLdapPathHelper(GetServerName(), lpszPhysicalSchemaNamingContext, szPhysicalSchemaPath);

  // build an LDAP query string
  static LPCWSTR lpszFilterFormat = L"(objectCategory=CN=Display-Specifier,%s)";

  int nFmtLen = lstrlen(lpszFilterFormat);
  int nArgumentLen = lstrlen(lpszPhysicalSchemaNamingContext);

  WCHAR* lpszFilter = (WCHAR*)alloca(sizeof(WCHAR)*(nFmtLen+nArgumentLen+1));
  wsprintf(lpszFilter, lpszFilterFormat, lpszPhysicalSchemaNamingContext);


  // execute a query to get the CN and the class display name
  CAdsiSearch search;
  hr = search.Init(szLocaleContainerPath);
  if (FAILED(hr))
    return hr;

  // build an array of wanted columns
  static const int cAttrs = 2;
  static LPCWSTR pszAttribsArr[cAttrs] = 
  {
    L"cn",                  // e.g. "organizationalUnit-Display"
    L"classDisplayName",    // e.g. "Organizational Unit" (i.e. the localizable one)
  }; 
  
  hr = search.SetSearchScope(ADS_SCOPE_ONELEVEL);
  //TRACE(L"search.SetSearchScope(ADS_SCOPE_ONELEVEL) returned hr = 0x%x\n", hr);
  if (FAILED(hr))
    return hr;

  hr = search.DoQuery(lpszFilter, pszAttribsArr, cAttrs);
  //TRACE(L"search.DoQuery(lpszFilter, pszAttribsArr, cAttrs) returned hr = 0x%x\n", hr);
  if (FAILED(hr))
    return hr;

  // need to keep track of matches
  size_t nCount = pSchemaClassesInfoArray->GetCount();

  BOOL* bFoundArray = (BOOL*)alloca(nCount*sizeof(BOOL));
  ZeroMemory(bFoundArray, nCount*sizeof(BOOL));

  WCHAR szBuffer[1024];


  CWString szNamingAttribute, szClassDisplayName;

  while ((hr = search.GetNextRow()) != S_ADS_NOMORE_ROWS)
  {
    if (FAILED(hr))
      continue;

    HRESULT hr0 = search.GetColumnString(pszAttribsArr[0], szNamingAttribute);
    HRESULT hr1 = search.GetColumnString(pszAttribsArr[1], szClassDisplayName);

    //TRACE(L"szNamingAttribute = <%s>, szClassDisplayName = <%s>\n", 
    //        szNamingAttribute.c_str(), szClassDisplayName.c_str());
    
    if (FAILED(hr0) || FAILED(hr1) )
    {
      TRACE(L"WARNING: discarding right, failed on columns: hr0 = 0x%x, hr1 = 0x%x\n",
                            hr0, hr1);
      continue;
    }
    
    // got a good name, need to match with the entries in the array
    for (UINT k=0; k<nCount; k++)
    {
      if (!bFoundArray[k])
      {
        CSchemaClassInfo* p = (*pSchemaClassesInfoArray)[k];
        //If its truncate, than string comparison will fail and
        //it will be treated as if DisplayName didn't exist which
        //is fine.
        //NTRAID#NTBUG9-530206-2002/06/18-ronmart-Check return code and abort if failed
        HRESULT hres = StringCchPrintf(szBuffer,sizeof(szBuffer)/sizeof(szBuffer[0]), L"%s-Display",p->GetName());
        if(FAILED(hres))
            return hres;

        if (_wcsicmp(szBuffer, szNamingAttribute) == 0)
        {
          //TRACE(L"   matching for %s\n",p->GetName());
          p->SetDisplayName(szClassDisplayName);
          bFoundArray[k] = TRUE;
        }
      }
    } // for
  } // while

  // take care of the ones that did not have any display specifier
  for (UINT k=0; k<nCount; k++)
  {
    if (!bFoundArray[k])
    {
      (*pSchemaClassesInfoArray)[k]->SetDisplayName(NULL);
    }
  } // for

  TRACE(L"\n\n");

  if (hr == S_ADS_NOMORE_ROWS)
    hr = S_OK;

#if defined (DO_TIMING)
  DWORD dwTick2 = ::GetTickCount();
  TRACE(L"Time to call _GetFriendlyClassNames() on ADSI query (mSec) = %d\n", dwTick2-dwTick1);
#endif

  return hr;
}

#endif

bool
CAdsiObject::GetListObjectEnforced()
{
    if(m_iListObjectEnforced != -1)
        return (m_iListObjectEnforced==1);

    PADS_ATTR_INFO pAttributeInfo = NULL;
    IDirectoryObject *pDirectoryService = NULL;
    IADsPathname *pPath = NULL;
    BSTR strServicePath = NULL;
    do
    {
        m_iListObjectEnforced = 0;    // Assume "not enforced"
        HRESULT hr = S_OK;

        int i;

        // Create a path object for manipulating ADS paths
        hr = CoCreateInstance(CLSID_Pathname,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IADsPathname,
                              (LPVOID*)&pPath);
        if(FAILED(hr))
            break;

        CComBSTR bstrConfigPath = L"LDAP://";
        if(GetServerName())
        {
            bstrConfigPath += GetServerName();
            bstrConfigPath += L"/";
        }
        if(!GetConfigurationNamingContext())
            break;
        bstrConfigPath += GetConfigurationNamingContext();

        if(!bstrConfigPath.Length())
            break;

        hr = pPath->Set(bstrConfigPath, ADS_SETTYPE_FULL);
        if(FAILED(hr))
            break;


        const LPWSTR aszServicePath[] =
        {
            L"CN=Services",
            L"CN=Windows NT",
            L"CN=Directory Service",
        };

        for (i = 0; i < ARRAYSIZE(aszServicePath); i++)
        {
            hr = pPath->AddLeafElement(CComBSTR (aszServicePath[i]));
            if(FAILED(hr))
                break;
        }

        hr = pPath->Retrieve(ADS_FORMAT_WINDOWS, &strServicePath);
        if(FAILED(hr))
            break;

        hr = ADsOpenObjectHelper(strServicePath,
                                 IID_IDirectoryObject,
                                 0,
                                 (LPVOID*)&pDirectoryService);
        if(FAILED(hr))
            break;

        WCHAR const c_szDsHeuristics[] = L"dSHeuristics";
        LPWSTR pszDsHeuristics = (LPWSTR)c_szDsHeuristics;
        DWORD dwAttributesReturned = 0;
        hr = pDirectoryService->GetObjectAttributes(&pszDsHeuristics,
                                                    1,
                                                    &pAttributeInfo,
                                                    &dwAttributesReturned);
        if (FAILED(hr)|| !pAttributeInfo)
            break;

        ASSERT(ADSTYPE_DN_STRING <= pAttributeInfo->dwADsType);
        ASSERT(ADSTYPE_NUMERIC_STRING >= pAttributeInfo->dwADsType);
        ASSERT(1 == pAttributeInfo->dwNumValues);
        LPWSTR pszHeuristicString = pAttributeInfo->pADsValues->NumericString;
        if (pszHeuristicString &&
            lstrlenW(pszHeuristicString) > 2 &&
            L'0' != pszHeuristicString[2])
        {
            m_iListObjectEnforced = 1;
        }

    }while(0);

    if (pAttributeInfo)
        FreeADsMem(pAttributeInfo);

    if(pDirectoryService)
        pDirectoryService->Release();
        
    if(pPath)
        pPath->Release();
    if(strServicePath)
        SysFreeString(strServicePath);

    return (m_iListObjectEnforced==1);
}



////////////////////////////////////////////////////////////////////////////////////////
// CAdsiSearch



HRESULT CAdsiSearch::DoQuery(LPCWSTR lpszFilter, LPCWSTR* pszAttribsArr, int cAttrs)
{
  if (m_spSearchObj == NULL)
    return E_ADS_BAD_PATHNAME;

  static const int NUM_PREFS=3;
  static const int QUERY_PAGESIZE = 256;
  ADS_SEARCHPREF_INFO aSearchPref[NUM_PREFS];

  aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
  aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[0].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
  aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
  aSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[1].vValue.Integer = QUERY_PAGESIZE;
  aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
  aSearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
  aSearchPref[2].vValue.Integer = FALSE;
    
  HRESULT hr = m_spSearchObj->SetSearchPreference (aSearchPref, NUM_PREFS);
  if (FAILED(hr))
    return hr;
    
  return m_spSearchObj->ExecuteSearch((LPWSTR)lpszFilter,
                                  (LPWSTR*)pszAttribsArr,
                                  cAttrs,
                                  &m_SearchHandle);
}



//
//Functions to replace GetNamedSecurityInfo and SetNamedSecurityInfo
// 


#pragma warning (disable : 4127)

HRESULT
SetSecInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si)
{
    HRESULT hr = E_INVALIDARG;
    if (punk)
    {
        IADsObjectOptions *pOptions;
        hr = punk->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            V_VT(&var) = VT_I4;
            V_I4(&var) = si;
            hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);
            pOptions->Release();
        }
    }
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Function:   GetSDForDsObject
//  Synopsis:   Reads the security descriptor from the specied DS object
//              It only reads the DACL portion of the security descriptor
//
//  Arguments:  [IN  pDsObject] --  DS object
//              [ppDACL]            --pointer to dacl in ppSD is returned here
//              [OUT ppSD]          --  Security descriptor returned here.
//              calling API must free this by calling LocalFree                
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------

HRESULT GetSDForDsObject(IDirectoryObject* pDsObject,
                         PACL* ppDACL,
                         PSECURITY_DESCRIPTOR* ppSD)
{
    if(!pDsObject || !ppSD)
    {
        return E_POINTER;
    }
    
    *ppSD = NULL;
    if(ppDACL)
    {
       *ppDACL = NULL;
    }

    HRESULT hr = S_OK;    
    PADS_ATTR_INFO pSDAttributeInfo = NULL;
            
   do
   {
      WCHAR const c_szSDProperty[]  = L"nTSecurityDescriptor";      
      LPWSTR pszProperty = (LPWSTR)c_szSDProperty;
      
      // Set the SECURITY_INFORMATION mask to DACL_SECURITY_INFORMATION
      hr = SetSecInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
         break;

      DWORD dwAttributesReturned;
   
      // Read the security descriptor attribute
      hr = pDsObject->GetObjectAttributes(&pszProperty,
                                          1,
                                          &pSDAttributeInfo,
                                          &dwAttributesReturned);

      if(SUCCEEDED(hr) && !pSDAttributeInfo)
      {
         hr = E_FAIL;
      }

      if(FAILED(hr))
         break;


      if((ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->dwADsType) && 
         (ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->pADsValues->dwType))
      {

         *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);
         if (!*ppSD)
         {
               hr = E_OUTOFMEMORY;
               break;
         }

         CopyMemory(*ppSD,
                     pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue,
                     pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);

         if(ppDACL)
         {
               BOOL bDaclPresent,bDaclDeafulted;
               if(!GetSecurityDescriptorDacl(*ppSD,
                                             &bDaclPresent,
                                             ppDACL,
                                             &bDaclDeafulted))
               {
                  DWORD dwErr = GetLastError();
                  hr = HRESULT_FROM_WIN32(dwErr);
                  break;
               }
         }
      }
      else
      {
         hr = E_FAIL;
      }
    }while(0);



    if (pSDAttributeInfo)
        FreeADsMem(pSDAttributeInfo);

    if(FAILED(hr))
    {
        if(*ppSD)
        {
            LocalFree(*ppSD);
            *ppSD = NULL;
            if(ppDACL)
                *ppDACL = NULL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSDForDsObjectPath
//  Synopsis:   Reads the security descriptor from the specied DS object
//              It only reads the DACL portion of the security descriptor
//
//  Arguments:  [IN  pszObjectPath] --  LDAP Path of ds object
//              [ppDACL]            --pointer to dacl in ppSD is returned here
//              [OUT ppSD]          --  Security descriptor returned here.
//              calling API must free this by calling LocalFree                
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
HRESULT GetSDForDsObjectPath(LPCWSTR pszObjectPath,
                             PACL* ppDACL,
                             PSECURITY_DESCRIPTOR* ppSecurityDescriptor)
{
    if(!pszObjectPath || !ppSecurityDescriptor)
    {
        return E_POINTER;
    }

    IDirectoryObject* pDsObject = NULL;
    HRESULT hr = ADsOpenObjectHelper(pszObjectPath, IID_IDirectoryObject,0,(void**)&pDsObject);
    if(SUCCEEDED(hr))
    {
        hr = GetSDForDsObject(pDsObject,ppDACL,ppSecurityDescriptor);
    }

    if(pDsObject)
       pDsObject->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetDaclForDsObject
//  Synopsis:   Sets the  the DACL for the specified DS object
//
//  Arguments:  [IN  pDsObject] --  ds object
//              [IN pDACL]     --pointer to dacl to be set
//
//----------------------------------------------------------------------------
HRESULT SetDaclForDsObject(IDirectoryObject* pDsObject,
                           PACL pDACL)
{
    if(!pDsObject || !pDACL)
    {
        return E_POINTER;
    }
                                  
    WCHAR const c_szSDProperty[]  = L"nTSecurityDescriptor";

    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR pSDCurrent = NULL;
    HRESULT hr = S_OK;

   do
   {
      //Get the current SD for the object
      hr = GetSDForDsObject(pDsObject,NULL,&pSDCurrent);
      if(FAILED(hr))
         break;

      //Get the control for the current security descriptor
      SECURITY_DESCRIPTOR_CONTROL currentControl;
      DWORD dwRevision = 0;
      if(!GetSecurityDescriptorControl(pSDCurrent, &currentControl, &dwRevision))
      {
         DWORD dwErr = GetLastError();
         hr = HRESULT_FROM_WIN32(dwErr);
         break;
      }

      //Allocate the buffer for Security Descriptor
      pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH + pDACL->AclSize);
      if(!pSD)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      if(!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
      {
         DWORD dwErr = GetLastError();
         hr = HRESULT_FROM_WIN32(dwErr);
         break;
      }

      PISECURITY_DESCRIPTOR pISD = (PISECURITY_DESCRIPTOR)pSD;
      //
      // Finally, build the security descriptor
      //
      pISD->Control |= SE_DACL_PRESENT | SE_DACL_AUTO_INHERIT_REQ 
         | (currentControl & (SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

      if (pDACL->AclSize > 0)
      {
         pISD->Dacl = (PACL)(pISD + 1);
         CopyMemory(pISD->Dacl, pDACL, pDACL->AclSize);
      }

      //We are only setting DACL information
      hr = SetSecInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
         break;

      // Need the total size
      DWORD dwSDLength = GetSecurityDescriptorLength(pSD);

      //
      // If necessary, make a self-relative copy of the security descriptor
      //
      SECURITY_DESCRIPTOR_CONTROL sdControl = 0;
      if(!GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision))
      {
         DWORD dwErr = GetLastError();
         hr = HRESULT_FROM_WIN32(dwErr);
         break;
      }

      if (!(sdControl & SE_SELF_RELATIVE))
      {
         PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDLength);

         if (psd == NULL ||
               !MakeSelfRelativeSD(pSD, psd, &dwSDLength))
         {
               DWORD dwErr = GetLastError();
               hr = HRESULT_FROM_WIN32(dwErr);
               break;
         }

         // Point to the self-relative copy
         LocalFree(pSD);        
         pSD = psd;
      }
      
      ADSVALUE attributeValue;
      ADS_ATTR_INFO attributeInfo;

      attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeValue.SecurityDescriptor.dwLength = dwSDLength;
      attributeValue.SecurityDescriptor.lpValue = (LPBYTE)pSD;

      attributeInfo.pszAttrName = (LPWSTR)c_szSDProperty;
      attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
      attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeInfo.pADsValues = &attributeValue;
      attributeInfo.dwNumValues = 1;
   
      DWORD dwAttributesModified;

      // Write the security descriptor
      hr = pDsObject->SetObjectAttributes(&attributeInfo,
                                          1,
                                          &dwAttributesModified);

    }while(0);

   if(pSDCurrent)
   {
      LocalFree(pSDCurrent);
   }

   if(pSD)
   {
      LocalFree(pSD);
   }

    return S_OK;

}



HRESULT SetDaclForDsObjectPath(LPCWSTR pszObjectPath,
                               PACL pDACL)
{
    if(!pszObjectPath || !pDACL)
        return E_POINTER;

    IDirectoryObject* pDsObject = NULL;

    HRESULT hr = ADsOpenObjectHelper(pszObjectPath, IID_IDirectoryObject,0,(void**)&pDsObject);
    if(SUCCEEDED(hr))
    {
        hr = SetDaclForDsObject(pDsObject,pDACL);
    }

   if(pDsObject)
       pDsObject->Release();

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\atldlgs.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation, 1996 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// Original file obtained from Nenad Stefanovic (ATL Team) as
// part of WTL (Windows Template Library)
// Kept just all the property page and property sheet classes

#ifndef __ATLDLGS_H__
#define __ATLDLGS_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLWIN_H__
	#error atldlgs.h requires atlwin.h to be included first
#endif

#include <commdlg.h>
#include <commctrl.h>

// copied from the new ATLWIN.H file to work with standard ATL 2.1

#define DECLARE_EMPTY_MSG_MAP() \
public: \
	BOOL ProcessWindowMessage(HWND, UINT, WPARAM, LPARAM, LRESULT&, DWORD) \
	{ \
		return FALSE; \
	}


namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T> class CPropertySheetImpl;
class CPropertySheet;
template <class T> class CPropertyPageImpl;


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetImpl - implements a property sheet

template <class T>
class ATL_NO_VTABLE CPropertySheetImpl : public CWindowImplBase
{
public:
	PROPSHEETHEADER m_psh;

// Construction/Destruction
	CPropertySheetImpl(LPCTSTR lpszTitle = NULL, UINT uStartPage = 0)
	{
		memset(&m_psh, 0, sizeof(PROPSHEETHEADER));
		m_psh.dwSize = sizeof(PROPSHEETHEADER);
		m_psh.dwFlags = PSH_USECALLBACK;
		m_psh.phpage = NULL;
		m_psh.nPages = 0;
		m_psh.pszCaption = lpszTitle;
		m_psh.nStartPage = uStartPage;
		m_psh.hwndParent = NULL;	// will be set in DoModal/Create
		m_psh.hInstance	= _Module.GetResourceInstance();
		m_psh.pfnCallback = T::PropSheetCallback;
	}

	~CPropertySheetImpl()
	{
		if(m_psh.phpage != NULL)
			delete[] m_psh.phpage;
	}

	static int CALLBACK PropSheetCallback(HWND hWnd, UINT uMsg, LPARAM)
	{
		if(uMsg == PSCB_INITIALIZED)
		{
			_ASSERTE(hWnd != NULL);
			CWindowImplBase* pT = (CWindowImplBase*)_Module.ExtractCreateWndData();
			pT->SubclassWindow(hWnd);
		}

		return 0;
	}

	HWND Create(HWND hWndParent = NULL)
	{
		_ASSERTE(m_hWnd == NULL);

		m_psh.dwFlags |= PSH_MODELESS;
		m_psh.hwndParent = hWndParent;

		_Module.AddCreateWndData(&m_thunk.cd, (CWindowImplBase*)this);

		HWND hWnd = (HWND)::PropertySheet(&m_psh);

		_ASSERTE(m_hWnd == hWnd);

		return hWnd;
	}

	int DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		_ASSERTE(m_hWnd == NULL);

		m_psh.dwFlags &= ~PSH_MODELESS;
		m_psh.hwndParent = hWndParent;

		_Module.AddCreateWndData(&m_thunk.cd, (CWindowImplBase*)this);

		int nRet = ::PropertySheet(&m_psh);

		m_hWnd = NULL;
		return nRet;
	}

// Attributes
	UINT GetPageCount() const
	{
		if(m_hWnd == NULL)
			return m_psh.nPages;

		HWND hWndTabCtrl = GetTabControl();
		_ASSERTE(hWndTabCtrl != NULL);
		return (UINT)::SendMessage(hWndTabCtrl, TCM_GETITEMCOUNT, 0, 0L);
	}
	HWND GetActivePage() const
	{
		_ASSERTE(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, PSM_GETCURRENTPAGEHWND, 0, 0L);
	}
	UINT GetActiveIndex() const
	{
		if(m_hWnd == NULL)
			return m_psh.nStartPage;

		HWND hWndTabCtrl = GetTabControl();
		_ASSERTE(hWndTabCtrl != NULL);
		return (UINT)::SendMessage(hWndTabCtrl, TCM_GETCURSEL, 0, 0L);
	}
	HPROPSHEETPAGE GetPage(UINT uPageIndex)
	{
		_ASSERTE(uPageIndex < m_psh.nPages);

		return m_psh.phpage[uPageIndex];
	}
	UINT GetPageIndex(HPROPSHEETPAGE hPage)
	{
		for(UINT i = 0; i < m_psh.nPages; i++)
		{
			if(m_psh.phpage[i] == hPage)
				return i;
		}
		return (UINT)-1;  // hPage not found
	}
	BOOL SetActivePage(UINT uPageIndex)
	{
		if(m_hWnd == NULL)
		{
			m_psh.nStartPage = uPageIndex;
			return TRUE;
		}
		return (BOOL)SendMessage(PSM_SETCURSEL, uPageIndex);
	}
	BOOL SetActivePage(HPROPSHEETPAGE hPage)
	{
		_ASSERTE(hPage != NULL);

		UINT uPageIndex = GetPageIndex(hPage);
		if(uPageIndex == (UINT)-1)
			return FALSE;

		return SetActivePage(uPageIndex);
	}
	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0)
	{
		_ASSERTE((nStyle & ~PSH_PROPTITLE) == 0); // only PSH_PROPTITLE is valid
		_ASSERTE(lpszText == NULL);

		if(m_hWnd == NULL)
		{
			// set internal state
			m_psh.pszCaption = lpszText;
			m_psh.dwFlags &= ~PSH_PROPTITLE;
			m_psh.dwFlags |= nStyle;
		}
		else
		{
			// set external state
			SendMessage(PSM_SETTITLE, nStyle, (LPARAM)lpszText);
		}
	}
	HWND GetTabControl() const
	{
		_ASSERTE(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, PSM_GETTABCONTROL, 0, 0L);
	}
	void SetWizardMode()
	{
		m_psh.dwFlags |= PSH_WIZARD;
	}
	void SetFinishText(LPCTSTR lpszText)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText);
	}
	void SetWizardButtons(DWORD dwFlags)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
	}

// Operations
	BOOL AddPage(HPROPSHEETPAGE hPage)
	{
		_ASSERTE(hPage != NULL);

		// add page to internal list
		HPROPSHEETPAGE* php = (HPROPSHEETPAGE*)realloc(m_psh.phpage, (m_psh.nPages + 1) * sizeof(HPROPSHEETPAGE));
		if(php == NULL)
			return FALSE;

		m_psh.phpage = php;
		m_psh.phpage[m_psh.nPages] = hPage;
		m_psh.nPages++;

		if(m_hWnd != NULL)
			::SendMessage(m_hWnd, PSM_ADDPAGE, 0, (LPARAM)hPage);

		return TRUE;
	}
	BOOL AddPage(LPCPROPSHEETPAGE pPage)
	{
		_ASSERTE(pPage != NULL);

		HPROPSHEETPAGE hPSP = ::CreatePropertySheetPage(pPage);
		if(hPSP == NULL)
			return FALSE;

		AddPage(hPSP);

		return TRUE;
	}
	BOOL RemovePage(HPROPSHEETPAGE hPage)
	{
		_ASSERTE(hPage != NULL);

		int nPage = GetPageIndex(hPage);
		if(nPage == -1)
			return FALSE;

		return RemovePage(nPage);
	}
	BOOL RemovePage(UINT uPageIndex)
	{
		// remove the page externally
		if(m_hWnd != NULL)
			SendMessage(PSM_REMOVEPAGE, uPageIndex);

		// remove the page from internal list
		if(uPageIndex >= m_psh.nPages)
			return FALSE;

		if(!DestroyPropertySheetPage(m_psh.phpage[uPageIndex]))
			return FALSE;

		for(UINT i = uPageIndex; i < m_psh.nPages - 1; i++)
			m_psh.phpage[i] = m_psh.phpage[i+1];

		m_psh.phpage = (HPROPSHEETPAGE*)realloc(m_psh.phpage, (m_psh.nPages - 1) * sizeof(HPROPSHEETPAGE));
		m_psh.nPages--;

		return TRUE;
	}
	BOOL PressButton(int nButton)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_PRESSBUTTON, nButton, 0L);
	}
};

class CPropertySheet : public CPropertySheetImpl<CPropertySheet>
{
public:
	CPropertySheet(LPCTSTR lpszTitle = NULL, UINT uStartPage = 0)
		: CPropertySheetImpl<CPropertySheet>(lpszTitle, uStartPage)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageImpl - implements a property page

template <class T>
class ATL_NO_VTABLE CPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		if(uMsg == PSPCB_CREATE)
		{
			_ASSERTE(hWnd == NULL);
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		_ASSERTE(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		_ASSERTE(::IsWindow(m_hWnd));
		_ASSERTE(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		_ASSERTE(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		_ASSERTE(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	BEGIN_MSG_MAP(CPropertyPageImpl< T >)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		_ASSERTE(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = static_cast<T*>(this);
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
//? other values
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
//? other values
			lResult = pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
/**/			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	LRESULT OnWizardBack()
	{
		return 0; // default go to previous page
	}
	LRESULT OnWizardNext()
	{
		return 0; // default go to next page
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}
};

}; //namespace ATL

#endif // __ATLDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_DSA_TRACE)
  #if defined(TRACE)
    #undef TRACE
    void  DSATrace(LPCWSTR, ...);
    #define TRACE DSATrace
  #endif // defined(TRACE)
#endif // defined(_USE_DSA_TRACE)


#if defined(_USE_DSA_ASSERT)
#undef ASSERT
#undef VERIFY
#undef THIS_FILE
#define THIS_FILE          __FILE__
BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine);
#define ASSERT(f) \
	do \
	{ \
	if (!(f) && DSAAssertFailedLine(THIS_FILE, __LINE__)) \
		::DebugBreak(); \
	} while (0) \

#define VERIFY(f)          ASSERT(f)

#endif // _USE_DSA_ASSERT

#if defined (_USE_DSA_TIMER)

void DSATimer(LPCWSTR, ...);
#define TIMER DSATimer

#else

#define TIMER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\deltempl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       deltempl.cpp
//
//--------------------------------------------------------------------------



#include <pch.h>

#include "resource.h"

#include "util.h"
#include "deltempl.h"

#include <_deltemp.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\dsuiwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsuiwiz.h
//
//--------------------------------------------------------------------------


#ifndef _DSUIWIZ_H
#define _DSUIWIZ_H

extern const GUID CLSID_OuDelegWizExt;


#endif // _DSUIWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\delegwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       delegwiz.h
//
//--------------------------------------------------------------------------


#ifndef _DELEGWIZ_H
#define _DELEGWIZ_H


#include "wizbase.h"

#include "deltempl.h"


////////////////////////////////////////////////////////////////////////////
// FWD DECLARATIONS


// REVIEW_MARCOC: nuke when sure

#define _SKIP_NAME_PAGE


////////////////////////////////////////////////////////////////////////////
// CDelegWiz_StartPage

class CDelegWiz_StartPage : public CWizPageBase<CDelegWiz_StartPage>
{
public:
	CDelegWiz_StartPage(CWizardBase* pWiz) : CWizPageBase<CDelegWiz_StartPage>(pWiz) 
	{
#ifdef _SKIP_NAME_PAGE
    m_bBindOK = FALSE;
#endif
	}
	enum { IDD = IDD_DELEGWIZ_START };

private:
	BEGIN_MSG_MAP(CDelegWiz_StartPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_StartPage>)
	END_MSG_MAP()

	// message handlers
	BOOL CALLBACK OnInitDialog(UINT uMsg, WPARAM wParam, 
				   LPARAM lParam, BOOL& bHandled);

#ifdef _SKIP_NAME_PAGE
  BOOL m_bBindOK;
#endif

public:
	// standard wizard message handlers
	BOOL OnSetActive();

	LRESULT OnWizardBack() { return -1;	} // first page

#ifdef _SKIP_NAME_PAGE
  LRESULT OnWizardNext();
#endif

};

////////////////////////////////////////////////////////////////////////////
// CDelegWiz_NamePage

class CDelegWiz_NamePage : public CWizPageBase<CDelegWiz_NamePage>
{
public:
	CDelegWiz_NamePage(CWizardBase* pWiz) : CWizPageBase<CDelegWiz_NamePage>(pWiz) 
	{
		m_hwndNameEdit = NULL;
	}
	enum { IDD = IDD_DELEGWIZ_NAME };

private:
	BEGIN_MSG_MAP(CDelegWiz_NamePage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  COMMAND_HANDLER(IDC_BROWSE_BUTTON, BN_CLICKED, OnBrowse)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_NamePage>)
	END_MSG_MAP()

	// message handlers
	BOOL CALLBACK OnInitDialog(UINT uMsg, WPARAM wParam, 
				   LPARAM lParam, BOOL& bHandled);
	LRESULT OnBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

public:
	// standard wizard message handlers
	BOOL OnSetActive();

	LRESULT OnWizardNext();

private:
	HWND m_hwndNameEdit;

};

///////////////////////////////////////////////////////////////////////
// CImageListHelper

class CImageListEntry
{
public:
  CImageListEntry(LPCWSTR lpszClass, int nIndex)
  {
    m_szClass = lpszClass;
    m_nIndex = nIndex;
  }
  bool operator<(CImageListEntry& x) { return false;}
  CWString m_szClass;
  int m_nIndex;
};

class CImageListHelper
{
public:
  CImageListHelper()
  {
    m_hImageList = NULL;
  }

  HIMAGELIST GetHandle() 
  { 
    ASSERT(m_hImageList != NULL);
    return m_hImageList;
  }
  BOOL Create(HWND hWndListView)
  {
    ASSERT(m_hImageList == NULL);
    m_hImageList = ImageList_Create(16, 16, ILC_COLOR, 0, 2);
    return m_hImageList != NULL;
  }

  int GetIconIndex(LPCWSTR lpszClass)
  {
    int nCount = m_imageCacheArr.GetCount();
    for (int k=0; k<nCount; k++)
    {
      if (_wcsicmp(m_imageCacheArr[k]->m_szClass, lpszClass) == 0)
        return m_imageCacheArr[k]->m_nIndex; // got cached
    }
    return -1; // not found
  }

  int AddIcon(LPCWSTR lpszClass, HICON hIcon)
  {
    ASSERT(m_hImageList != NULL);
    int nCount = m_imageCacheArr.GetCount();
    // add to the image list
    int nRes = ImageList_AddIcon(m_hImageList, hIcon);
    if (nRes != nCount)
      return nRes;
    
    // add to the cache
    CImageListEntry* pEntry = new CImageListEntry(lpszClass, nCount);
    m_imageCacheArr.Add(pEntry);
    return nCount; // new index
  }
private:
  CGrowableArr<CImageListEntry> m_imageCacheArr;
  HIMAGELIST m_hImageList;
};

///////////////////////////////////////////////////////////////////////
// CPrincipalListViewHelper

class CPrincipalListViewHelper
{
public:

	CPrincipalListViewHelper()
	{
    m_defaultColWidth = 0;
		m_hWnd = NULL;
	}

	BOOL Initialize(UINT nID, HWND hParent);
	int InsertItem(int iItem, CPrincipal* pPrincipal);
  BOOL SelectItem(int iItem);
	CPrincipal* GetItemData(int iItem);
	int GetItemCount()
	{
		return ListView_GetItemCount(m_hWnd);
	}
  int GetSelCount()
  {
    return ListView_GetSelectedCount(m_hWnd);
  }

	BOOL DeleteAllItems()
	{
		return ListView_DeleteAllItems(m_hWnd);
	}
  void SetImageList()
  {
    ListView_SetImageList(m_hWnd, m_imageList.GetHandle(), LVSIL_SMALL);
  }
  BOOL SetWidth(int cx)
  {
    return ListView_SetColumnWidth(m_hWnd, 0, cx);		
  }
  int GetWidth()
  {
    return ListView_GetColumnWidth(m_hWnd, 0);		
  }

  void DeleteSelectedItems(CGrowableArr<CPrincipal>* pDeletedArr);
  void UpdateWidth(int cxNew);

private:
	HWND m_hWnd;
  int m_defaultColWidth;
  CImageListHelper m_imageList;
};


////////////////////////////////////////////////////////////////////////////
// CDelegWiz_PrincipalSelectionPage

class CDelegWiz_PrincipalSelectionPage : public CWizPageBase<CDelegWiz_PrincipalSelectionPage>
{
public:
	CDelegWiz_PrincipalSelectionPage(CWizardBase* pWiz) : 
		CWizPageBase<CDelegWiz_PrincipalSelectionPage>(pWiz) 
	{
		m_hwndRemoveButton = NULL;
	}
	enum { IDD = IDD_DELEGWIZ_PRINCIPALS_SEL };

private:
	BEGIN_MSG_MAP(CDelegWiz_PrincipalSelectionPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  COMMAND_HANDLER(IDC_ADD_BUTTON, BN_CLICKED, OnAdd)
	  COMMAND_HANDLER(IDC_REMOVE_BUTTON, BN_CLICKED, OnRemove)
	  NOTIFY_HANDLER(IDC_SELECTED_PRINCIPALS_LIST, LVN_ITEMCHANGED, OnListViewSelChange)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_PrincipalSelectionPage>)
	END_MSG_MAP()

	// message handlers
	BOOL CALLBACK OnInitDialog(UINT uMsg, WPARAM wParam, 
				   LPARAM lParam, BOOL& bHandled);
	LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnListViewSelChange(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

public:
	// standard wizard message handlers
	BOOL OnSetActive();
  LRESULT OnWizardNext();

private:
	CPrincipalListViewHelper	m_principalListView;
	HWND	m_hwndRemoveButton;

	void SyncButtons();
};


////////////////////////////////////////////////////////////////////////////
// CDelegWiz_DelegationTemplateSelectionPage

class CDelegWiz_DelegationTemplateSelectionPage : public CWizPageBase<CDelegWiz_DelegationTemplateSelectionPage>
{
public:
	CDelegWiz_DelegationTemplateSelectionPage(CWizardBase* pWiz) : 
		CWizPageBase<CDelegWiz_DelegationTemplateSelectionPage>(pWiz) 
	{
	  m_hwndDelegateTemplateRadio = NULL;
	  m_hwndDelegateCustomRadio = NULL;
	}
  ~CDelegWiz_DelegationTemplateSelectionPage() {}

  enum { IDD = IDD_DELEGWIZ_DELEG_TEMPLATE_SEL };

	BEGIN_MSG_MAP(CDelegWiz_DelegationTemplateSelectionPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  COMMAND_HANDLER(IDC_DELEGATE_TEMPLATE_RADIO, BN_CLICKED, OnDelegateTypeRadioChange)
	  COMMAND_HANDLER(IDC_DELEGATE_CUSTOM_RADIO, BN_CLICKED, OnDelegateTypeRadioChange)
	  NOTIFY_HANDLER(IDC_DELEGATE_TEMPLATE_LIST, LVN_ITEMCHANGED, OnListViewItemChanged)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_DelegationTemplateSelectionPage>)
	END_MSG_MAP()

	// message handlers
	BOOL CALLBACK OnInitDialog(UINT uMsg, WPARAM wParam, 
				   LPARAM lParam, BOOL& bHandled);
	LRESULT OnDelegateTypeRadioChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

public:
	// standard wizard message handlers
	BOOL OnSetActive();
	LRESULT OnWizardNext();

private:
	CCheckListViewHelper m_delegationTemplatesListView;
	HWND m_hwndDelegateTemplateRadio;
	HWND m_hwndDelegateCustomRadio;

	void SyncControlsHelper(BOOL bDelegateCustom);
	static void SetRadioControlText(HWND hwndCtrl, LPCWSTR lpszFmtText, LPCTSTR lpszText);
};






////////////////////////////////////////////////////////////////////////////
// CDelegWiz_ObjectTypeSelectionPage

class CDelegWiz_ObjectTypeSelectionPage : public CWizPageBase<CDelegWiz_ObjectTypeSelectionPage>
{
public:
	CDelegWiz_ObjectTypeSelectionPage(CWizardBase* pWiz) : 
		CWizPageBase<CDelegWiz_ObjectTypeSelectionPage>(pWiz) 
	{
		m_hwndDelegateAllRadio = NULL;
		m_hwndDelegateFollowingRadio = NULL;
	}
  ~CDelegWiz_ObjectTypeSelectionPage() {}

  enum { IDD = IDD_DELEGWIZ_OBJ_TYPE_SEL };

	BEGIN_MSG_MAP(CDelegWiz_ObjectTypeSelectionPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  COMMAND_HANDLER(IDC_DELEGATE_ALL_RADIO, BN_CLICKED, OnObjectRadioChange)
	  COMMAND_HANDLER(IDC_DELEGATE_FOLLOWING_RADIO, BN_CLICKED, OnObjectRadioChange)
          COMMAND_HANDLER(IDC_DELEGATE_CREATE_CHILD, BN_CLICKED, OnCreateDelCheckBoxChanage)
          COMMAND_HANDLER(IDC_DELEGATE_DELETE_CHILD, BN_CLICKED, OnCreateDelCheckBoxChanage)
	  NOTIFY_HANDLER(IDC_OBJ_TYPE_LIST, LVN_ITEMCHANGED, OnListViewItemChanged)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_ObjectTypeSelectionPage>)
	END_MSG_MAP()

	// message handlers
	BOOL CALLBACK OnInitDialog(UINT uMsg, WPARAM wParam, 
				   LPARAM lParam, BOOL& bHandled);
	LRESULT OnObjectRadioChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
        LRESULT OnCreateDelCheckBoxChanage(WORD wNotifyCode, WORD wID, 
													  HWND hWndCtl, BOOL& bHandled);
public:
	// standard wizard message handlers
	BOOL OnSetActive();
	LRESULT OnWizardNext();

private:
	CCheckListViewHelper m_objectTypeListView;
	HWND m_hwndDelegateAllRadio;
	HWND m_hwndDelegateFollowingRadio;
        HWND m_hwndDelegateCreateChild;
        HWND m_hwndDelegateDeleteChild;
	void SyncControlsHelper(BOOL bDelegateAll);
	static void SetRadioControlText(HWND hwndCtrl, LPCWSTR lpszFmtText, LPCTSTR lpszText);
};

////////////////////////////////////////////////////////////////////////////
// CDelegWiz_DelegatedRightsPage

class CDelegWiz_DelegatedRightsPage : public CWizPageBase<CDelegWiz_DelegatedRightsPage>
{
public:
	CDelegWiz_DelegatedRightsPage(CWizardBase* pWiz) : CWizPageBase<CDelegWiz_DelegatedRightsPage>(pWiz) 
	{
		m_hwndGeneralRigthsCheck = NULL;
		m_hwndPropertyRightsCheck = NULL;
    m_hwndSubobjectRightsCheck = NULL;

    m_bUIUpdateInProgress = FALSE;
	}
	
	enum { IDD = IDD_DELEGWIZ_DELEG_RIGHTS };
	
	BEGIN_MSG_MAP(CDelegWiz_DelegatedRightsPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  COMMAND_HANDLER(IDC_SHOW_GENERAL_CHECK, BN_CLICKED, OnFilterChange)
	  COMMAND_HANDLER(IDC_SHOW_PROPERTY_CHECK, BN_CLICKED, OnFilterChange)
          COMMAND_HANDLER(IDC_SHOW_SUBOBJ_CHECK, BN_CLICKED, OnFilterChange)
	  NOTIFY_HANDLER(IDC_DELEG_RIGHTS_LIST, LVN_ITEMCHANGED, OnListViewItemChanged)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_DelegatedRightsPage>)
	END_MSG_MAP()

	// message handlers
	BOOL CALLBACK OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnDelegateRadioChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnFilterChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	public:
	// standard wizard message handlers
	BOOL OnSetActive();
	LRESULT OnWizardNext();

private:
	CCheckListViewHelper m_delegatedRigthsListView;
	HWND m_hwndGeneralRigthsCheck;
  HWND m_hwndPropertyRightsCheck;
	HWND m_hwndSubobjectRightsCheck;

  BOOL m_bUIUpdateInProgress;

	void ResetCheckList();

  ULONG GetFilterOptions();
  void SetFilterOptions(ULONG nFilterOptions);
};

////////////////////////////////////////////////////////////////////////////
// CDelegWiz_FinishPage

class CDelegWiz_FinishPage : public CWizPageBase<CDelegWiz_FinishPage>
{
public:
	CDelegWiz_FinishPage(CWizardBase* pWiz) : 
        CWizPageBase<CDelegWiz_FinishPage>(pWiz) 
	{
    m_bNeedSetFocus = FALSE;
    m_bCustom = TRUE;
	}
	enum { IDD = IDD_DELEGWIZ_FINISH };
	BEGIN_MSG_MAP(CDelegWiz_FinishPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
 	  COMMAND_HANDLER(IDC_EDIT_SUMMARY, EN_SETFOCUS, OnSetFocusSummaryEdit)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_FinishPage>)
	END_MSG_MAP()

	// message handlers
	BOOL CALLBACK OnInitDialog(UINT uMsg, WPARAM wParam, 
				   LPARAM lParam, BOOL& bHandled);
	LRESULT OnSetFocusSummaryEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

public:
	// standard wizard message handlers
	BOOL OnSetActive();
	BOOL OnWizardFinish();

  void SetCustom() { m_bCustom = TRUE;}
  void SetTemplate() { m_bCustom = FALSE;}
  BOOL IsCustom(){ return m_bCustom; }


private:
  BOOL m_bNeedSetFocus;
  BOOL m_bCustom;
};



////////////////////////////////////////////////////////////////////////////
// CDelegWiz

class CDelegWiz : public CWizardBase
{
public:
	// construction/ destruction
	CDelegWiz();
	virtual ~CDelegWiz();

	// message map
	BEGIN_MSG_MAP(CDelegWiz)
	  CHAIN_MSG_MAP(CWizardBase)
	END_MSG_MAP()

  void InitFromLDAPPath(LPCWSTR lpszLDAPPath)
  {
    TRACE(L"CDelegWiz::InitFromLDAPPath(%s)\n", lpszLDAPPath);
    m_lpszLDAPPath = lpszLDAPPath;
  }
  LPCWSTR GetInitialLDAPPath() { return m_lpszLDAPPath;}

  BOOL CanChangeName() { return m_lpszLDAPPath == NULL;}
  LPCWSTR GetClass() { return m_adsiObject.GetClass();}
  LPCWSTR GetCanonicalName() { return m_adsiObject.GetCanonicalName();}
  void SetName(LPCWSTR lwsz)
  {
    ASSERT(FALSE); // TODO
  }


	HRESULT AddPrincipals(CPrincipalListViewHelper* pListViewHelper);
	BOOL DeletePrincipals(CPrincipalListViewHelper* pListViewHelper);

  HRESULT GetObjectInfo() 
  { 
    return m_adsiObject.Bind(GetInitialLDAPPath()); 
  }

  HRESULT GetClassInfoFromSchema() 
  { 
    return m_adsiObject.QuerySchemaClasses(&m_schemaClassInfoArray);
  }

  // ----- APIs for Custom Mode -----

	int FillCustomSchemaClassesListView(CCheckListViewHelper* pListViewHelper, BOOL bFilter);

	BOOL GetCustomAccessPermissions();
	void FillCustomAccessRightsListView(CCheckListViewHelper* pListViewHelper, 
											                ULONG nFilterState);

  void UpdateAccessRightsListViewSelection(
                       CCheckListViewHelper* pListViewHelper,
                       ULONG nFilterState);

	void OnCustomAccessRightsCheckListClick(
                        CRigthsListViewItem* pItem,
												BOOL bSelected,
                        ULONG* pnNewFilterState);

  BOOL HasPermissionSelectedCustom();

	BOOL SetSchemaClassesSelectionCustom();
  void DeselectSchemaClassesSelectionCustom();

	// finish page
	void SetSummaryInfoCustom(HWND hwndSummaryName, 
                               HWND hwndSummaryPrincipals,
                               HWND hwndSummaryRights,
                               HWND hwndSummaryObjects,
                               HWND hwndSummaryObjectsStatic);

	void WriteSummaryInfoCustom(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine); 

	BOOL FinishCustom() { return FinishHelper(TRUE);}


  // ----- APIs for Template Mode -----

  BOOL InitPermissionHoldersFromSelectedTemplates();

  // finish page
	void WriteSummaryInfoTemplate(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine); 

  BOOL FinishTemplate() { return FinishHelper(FALSE);}
  //This flag is used to create/delete childobjects of selected type.
  // Possible values are ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD
  DWORD  m_fCreateDelChild;   

  BOOL m_bAuxClass;

  BOOL HideListObjectAccess(void)
  {
    return !m_adsiObject.GetListObjectEnforced();
  }


private:

	// embedded wizard property pages
	CDelegWiz_StartPage					      m_startPage;
	CDelegWiz_NamePage					      m_namePage;
	CDelegWiz_PrincipalSelectionPage	m_userOrGroupSelectionPage;

  // page for template selection
  CDelegWiz_DelegationTemplateSelectionPage m_templateSelectionPage;

  // pages for the custom branch 
	CDelegWiz_ObjectTypeSelectionPage	m_objectTypeSelectionPage;
	CDelegWiz_DelegatedRightsPage		  m_delegatedRightsPage;

  // common finish page
  CDelegWiz_FinishPage				m_finishPage;


	// Domain/OU name data

  CAdsiObject       m_adsiObject;

  LPCWSTR           m_lpszLDAPPath; // path the wizard was initialized from

	// principals (Users and Groups)
	CPrincipalList				m_principalList;



	// schema classes info
  CGrowableArr<CSchemaClassInfo>	m_schemaClassInfoArray;

  // selection info about m_schemaClassInfoArray

  static const long nSchemaClassesSelAll;
  static const long nSchemaClassesSelMultiple;
	long						m_nSchemaClassesSel; // -1 for select all

  BOOL m_bChildClass;                 //determines if to show create/delet child objects in case of custom permission
	// custom rights
  CCustomAccessPermissionsHolder m_permissionHolder;

  CTemplateAccessPermissionsHolderManager m_templateAccessPermissionsHolderManager;
	
	// interface pointers
	CComPtr<IADsPathname>		m_spADsPath; // cached object pointer for name resolution

	// internal helpers
	HRESULT AddPrincipalsFromBrowseResults(CPrincipalListViewHelper* pListViewHelper, 
                                         PDS_SELECTION_LIST pDsSelectionList);

	DWORD BuildNewAccessListCustom(PACL *ppNewAcl);
  DWORD BuildNewAccessListTemplate(PACL *ppNewAcl);

	DWORD UpdateAccessList(CPrincipal* pPrincipal,
							CSchemaClassInfo* pClassInfo,
							PACL *ppAcl);

  void WriteSummaryInfoHelper(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine);

  BOOL FinishHelper(BOOL bCustom);

  friend class CDelegWiz_DelegationTemplateSelectionPage;
  friend class CDelegWiz_PrincipalSelectionPage;

};

//+----------------------------------------------------------------------------
//  Function:DoDisabledCheck   
//  Synopsis:Check if any of the object in pDsSelList is disabled. if yes,
//				 function displays a dialog box to user. 
//  Returns: TRUE if to add objects in list to acl else no.   
//-----------------------------------------------------------------------------
BOOL
DoDisabledCheck(IN CDelegWiz& refWiz,
				IN PDS_SELECTION_LIST pDsSelList);

#endif // _DELEGWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\dsuiwiz.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsuiwiz.cpp
//
//--------------------------------------------------------------------------



#include "pch.h"
#include "util.h"
#include "resource.h"
//#include "initguid.h"
#include "dsuiwiz.h"
#include "shfusion.h"
#include "ShellExt.h"

// {6BA3F852-23C6-11D1-B91F-00A0C9A06D2D}
static const CLSID CLSID_OuDelegWizExt = 
{ 0x6BA3F852, 0x23C6, 0x11D1, {0xB9, 0x1F, 0x00, 0xA0, 0xC9, 0xA0, 0x6D, 0x2D } };

COuDelegComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_OuDelegWizExt, CShellExt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point


extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		SHFusionInitialize(0);
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
		if (!_Module.InitClipboardFormats())
			return FALSE;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		SHFusionUninitialize();
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\delegwiz.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       delegwiz.cpp
//
//--------------------------------------------------------------------------



#include "pch.h"
#include "wizbase.h"
#include "util.h"
#include <initguid.h>
#include <cmnquery.h> // ICommonQuery
#include <dsquery.h>
#include <dsclient.h>

#include "resource.h"
#include "dsuiwiz.h"
#include "delegWiz.h"

#define GET_OU_WIZARD() ((CDelegWiz*)GetWizard())





/////////////////////////////////////////////////////////////////////////////


void InitBigBoldFont(HWND hWnd, HFONT& hFont)
{
   ASSERT(::IsWindow(hWnd));

   NONCLIENTMETRICS ncm;
   memset(&ncm, 0, sizeof(ncm));
   ncm.cbSize = sizeof(ncm);
   ::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

   LOGFONT boldLogFont = ncm.lfMessageFont;
   boldLogFont.lfWeight = FW_BOLD;

   // load big font definition from resources
   WCHAR szFontName[LF_FACESIZE];
   if (0 == ::LoadString(_Module.GetResourceInstance(), IDS_BIG_BOLD_FONT_NAME,
                boldLogFont.lfFaceName, LF_FACESIZE))
   {
     // set to default of failed to load
      wcscpy(boldLogFont.lfFaceName, L"Verdana Bold"); // LF_FACESIZE == 32
   }
   
   WCHAR szFontSize[128];
   int nFontSize = 0;
   if (0 != ::LoadString(_Module.GetResourceInstance(), IDS_BIG_BOLD_FONT_SIZE,
                szFontSize, sizeof(szFontSize)/sizeof(WCHAR)))
   {
      nFontSize = _wtoi(szFontSize);
   }
   if (nFontSize == 0)
     nFontSize = 12; // default


   HDC hdc = ::GetDC(hWnd);
   //Bug fix  447884
   if( hdc )
   {

      boldLogFont.lfHeight =
         0 - (::GetDeviceCaps(hdc, LOGPIXELSY) * nFontSize / 72);

      hFont = ::CreateFontIndirect((const LOGFONT*)(&boldLogFont));

      ::ReleaseDC(hWnd, hdc);
   }
}


void SetLargeFont(HWND hWndDialog, int nControlID)
{
   ASSERT(::IsWindow(hWndDialog));
   ASSERT(nControlID);

   static HFONT boldLogFont = 0;
   if (boldLogFont == 0)
   {
      InitBigBoldFont(hWndDialog, boldLogFont);
   }

   HWND hWndControl = ::GetDlgItem(hWndDialog, nControlID);

   if (hWndControl)
   {
     ::SendMessage(hWndControl, WM_SETFONT, (WPARAM)boldLogFont, MAKELPARAM(TRUE, 0));    
   }
}

////////////////////////////////////////////////////////////////////////////
// CDelegWiz_StartPage


BOOL CDelegWiz_StartPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();
	pWizard->SetWizardButtonsFirst(TRUE);
	return TRUE;
}

BOOL CALLBACK CDelegWiz_StartPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
  SetLargeFont(m_hWnd, IDC_STATIC_WELCOME);

  return TRUE;
}


#ifdef _SKIP_NAME_PAGE

LRESULT CDelegWiz_StartPage::OnWizardNext()
{
  BOOL bSuccess = TRUE;
  HRESULT hr = S_OK;
  CDelegWiz* pWiz = GET_OU_WIZARD();

  // if we do not have an object, we will browse from the next page
  if (!pWiz->CanChangeName() && !m_bBindOK)
  {
    // make sure it exists and it is of the right type
    {
      // scope to restore cursor
      CWaitCursor wait;
      hr = pWiz->GetObjectInfo();
    }

    if (FAILED(hr))
	  {
		  WCHAR szFmt[256];
		  LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_OBJ_NAME, szFmt, 256);
		  WCHAR szMsg[512];
		  if(SUCCEEDED(StringCchPrintf(szMsg, sizeof(szMsg)/sizeof(WCHAR),szFmt, pWiz->GetCanonicalName())))
		  {
			  pWiz->WizReportHRESULTError(szMsg, hr);
		  }
		  goto error;
	  }


    {
      // scope to restore cursor
      CWaitCursor wait;
      hr = pWiz->GetClassInfoFromSchema();
    }

	  if (FAILED(hr))
	  {
		  WCHAR szFmt[256];
		  LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_OBJ_INFO, szFmt, 256);
		  WCHAR szMsg[512];
		  if(SUCCEEDED(StringCchPrintf(szMsg, sizeof(szMsg)/sizeof(WCHAR),szFmt, pWiz->GetCanonicalName())))
		  {
			  pWiz->WizReportHRESULTError(szMsg, hr);
		  }
		  goto error;
	  }

    // all fine, we do not need to do it anymore
    m_bBindOK = TRUE;
  }


  OnWizardNextHelper();
	return 0; // all fine, go to next page

error:
  pWiz->SetWizardButtonsFirst(FALSE);
  return -1; // do not advance
}

#endif



////////////////////////////////////////////////////////////////////////////
// CDelegWiz_NamePage




BOOL CALLBACK CDelegWiz_NamePage::OnInitDialog(UINT uMsg, WPARAM wParam, 
	                            	       LPARAM lParam, BOOL& bHandled)
{
  BOOL bRes = TRUE;

  CDelegWiz* pWiz = GET_OU_WIZARD();
  m_hwndNameEdit = GetDlgItem(IDC_OBJ_NAME_EDIT);

  if (!pWiz->CanChangeName()) // called on a given object
  {
        // hide static text that gives instructions
        HWND hwndNameStatic = GetDlgItem(IDC_OBJ_NAME_STATIC);
        ::ShowWindow(hwndNameStatic, FALSE);

        // change text to the editbox 
        HWND hwndNameEditStatic = GetDlgItem(IDC_OBJ_NAME_EDIT_STATIC);
        CWString szLabel;
        szLabel.LoadFromResource(IDS_OBJ_NAME_EDIT_STATIC);
        ::SendMessage(hwndNameEditStatic, WM_SETTEXT,0 , (LPARAM)(LPCWSTR)szLabel);

        // remove the tabstop flag from the Edit Box
        LONG style = ::GetWindowLong(m_hwndNameEdit, GWL_STYLE);
        style &= ~WS_TABSTOP;
        ::SetWindowLong(m_hwndNameEdit, GWL_STYLE, style);
        // make the Edit Box Read Only
        ::SendMessage(m_hwndNameEdit, EM_SETREADONLY, TRUE, 0L);

        // disable and hide the Browse Button
        HWND hWndBrowseButton = GetDlgItem(IDC_BROWSE_BUTTON);
                    ::EnableWindow(hWndBrowseButton, FALSE);
        ::ShowWindow(hWndBrowseButton, FALSE);

        bRes = FALSE;
    }
    return bRes;
}



LRESULT CDelegWiz_NamePage::OnBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	// load resources to customize dialog
	TCHAR szCaption[256];
	LoadStringHelper(IDS_DELEGWIZ_BROWSE_CONTAINER_CAPTION, szCaption, ARRAYSIZE(szCaption));
	TCHAR szTitle[256];
	LoadStringHelper(IDS_DELEGWIZ_BROWSE_CONTAINER_TITLE, szTitle, ARRAYSIZE(szTitle));

	// set dialog struct
	TCHAR szPath[MAX_PATH+1];
	szPath[0] = NULL;
	DSBROWSEINFO dsbi;
	::ZeroMemory( &dsbi, sizeof(dsbi) );

	dsbi.cbStruct = sizeof(DSBROWSEINFO);
	dsbi.hwndOwner = m_hWnd;
	dsbi.pszCaption = szCaption;
	dsbi.pszTitle = szTitle;
	dsbi.pszRoot = NULL;		// ADS path to root (NULL == root of DS namespace)
	dsbi.pszPath = szPath;
	dsbi.cchPath = (sizeof(szPath) / sizeof(TCHAR));
	dsbi.dwFlags = DSBI_ENTIREDIRECTORY;

	// REVIEW_MARCOC: need to determine how to show/hide hidden folders
	dsbi.dwFlags |= DSBI_INCLUDEHIDDEN; //m_fBrowseHiddenFolders ? DSBI_INCLUDEHIDDEN : 0;
	
	dsbi.pfnCallback = NULL;
	dsbi.lParam = 0;

	// make the call to the dialog
	int iRet = ::DsBrowseForContainer( &dsbi );

	if ( IDOK == iRet ) 
	{ // returns -1, 0, IDOK or IDCANCEL
	  // get path from BROWSEINFO struct, put in text edit field
	  //TRACE(_T("returned from DS Browse successfully with:\n %s\n"),
		//	dsbi.pszPath);
		::SetWindowText(m_hwndNameEdit, szPath);
	} 

	return 1;
}



BOOL CDelegWiz_NamePage::OnSetActive()
{
	CDelegWiz* pWiz = GET_OU_WIZARD();

#ifdef _SKIP_NAME_PAGE
  if (!pWiz->CanChangeName())
  {
    // just cause the page to fail, so that we skip it
    return FALSE;
  }
#endif

  HRESULT hr = S_OK;
  if (pWiz->m_bFwd && !pWiz->CanChangeName()) // called on a given object
	{
    // need to bind now to get the needed data
    hr = pWiz->GetObjectInfo();
    if (SUCCEEDED(hr))
    {
      // set the name of the object in the Edit Box
      ::SendMessage(m_hwndNameEdit, WM_SETTEXT, 0, (LPARAM)pWiz->GetCanonicalName());
    }
    else
    {
		WCHAR szFmt[256];
		LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_OBJ_NAME, szFmt, 256);
		WCHAR szMsg[512];
		if(SUCCEEDED(StringCchPrintf(szMsg, sizeof(szMsg)/sizeof(WCHAR),szFmt, pWiz->GetCanonicalName())))
		{
			pWiz->WizReportHRESULTError(szMsg, hr);
		}
		
    }
  }

  pWiz->SetWizardButtonsMiddle(SUCCEEDED(hr));
	return TRUE;
}

LRESULT CDelegWiz_NamePage::OnWizardNext()
{
  BOOL bSuccess = TRUE;
  HRESULT hr = S_OK;
  CDelegWiz* pWiz = GET_OU_WIZARD();
  if (pWiz->CanChangeName())
  {
	  // retrieve name  from the edit control
	  int nEditTextLen = ::SendMessage(m_hwndNameEdit, WM_GETTEXTLENGTH,0,0) + 1;// count NULL
	  TCHAR* lpszName = (TCHAR*)alloca(sizeof(TCHAR)*(nEditTextLen));
	  ::SendMessage(m_hwndNameEdit, WM_GETTEXT, (WPARAM)nEditTextLen, (LPARAM)lpszName);

    // this will get the equivalent LDAP path
	  pWiz->SetName(lpszName);
  
    // make sure it exists and it is of the right type
    {
      // scope to restore cursor
      CWaitCursor wait;
      hr = pWiz->GetObjectInfo();
    }
	  if (FAILED(hr))
	  {
		  WCHAR szFmt[256];
		  LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_OBJ_NAME, szFmt, 256);
		  WCHAR szMsg[512];
		  if(SUCCEEDED(StringCchPrintf(szMsg, sizeof(szMsg)/sizeof(WCHAR),szFmt, pWiz->GetCanonicalName())))
		  {
			  pWiz->WizReportHRESULTError(szMsg, hr);
		  }
		  goto error;
	  }
  } // if can change name

  {
    // scope to restore cursor
    CWaitCursor wait;
    hr = pWiz->GetClassInfoFromSchema();
  }

  if (FAILED(hr))
  {
	  WCHAR szFmt[256];
	  LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_OBJ_INFO, szFmt, 256);
	  WCHAR szMsg[512];
	  if(SUCCEEDED(StringCchPrintf(szMsg, sizeof(szMsg)/sizeof(WCHAR),szFmt, pWiz->GetCanonicalName())))
	  {
		  pWiz->WizReportHRESULTError(szMsg, hr);
	  }
	  goto error;
  }

  OnWizardNextHelper();
	return 0; // all fine, go to next page

error:
  pWiz->SetWizardButtonsMiddle(FALSE);
  return -1; // do not advance
}

////////////////////////////////////////////////////////////////////////////
// CDelegWiz_DelegationTemplateSelectionPage

BOOL CALLBACK CDelegWiz_DelegationTemplateSelectionPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
	m_delegationTemplatesListView.Initialize(IDC_DELEGATE_TEMPLATE_LIST, m_hWnd);
	
	// set the correct value for radiobuttons text
	m_hwndDelegateTemplateRadio = GetDlgItem(IDC_DELEGATE_TEMPLATE_RADIO);
	_ASSERTE(m_hwndDelegateTemplateRadio != NULL);
	m_hwndDelegateCustomRadio = GetDlgItem(IDC_DELEGATE_CUSTOM_RADIO);
	_ASSERTE(m_hwndDelegateCustomRadio != NULL);
	
	// set default setting
	::SendMessage(m_hwndDelegateTemplateRadio,  BM_SETCHECK, BST_CHECKED, 0);

	return TRUE;
}

LRESULT CDelegWiz_DelegationTemplateSelectionPage::OnDelegateTypeRadioChange(WORD wNotifyCode, WORD wID, 
													  HWND hWndCtl, BOOL& bHandled)
{
	SyncControlsHelper(IDC_DELEGATE_CUSTOM_RADIO == wID);
	return 1;
}

LRESULT CDelegWiz_DelegationTemplateSelectionPage::OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pnmh;
	if (CCheckListViewHelper::CheckChanged(pNMListView))
	{
		int nSelCount = m_delegationTemplatesListView.GetCheckCount();
		GET_OU_WIZARD()->SetWizardButtonsMiddle(nSelCount > 0);
	}
	return 1;
}

BOOL CDelegWiz_DelegationTemplateSelectionPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();
	BOOL bRetVal = TRUE;
	BOOL bDelegateCustom = 
			(BST_CHECKED == ::SendMessage(m_hwndDelegateCustomRadio, BM_GETCHECK,0,0));

	if (pWizard->m_bFwd)
	{
    // need to fill in with data
    BOOL bHaveTemplates = 
        pWizard->m_templateAccessPermissionsHolderManager.FillTemplatesListView(
              &m_delegationTemplatesListView, pWizard->GetClass())> 0;
    
		if (!bDelegateCustom && !bHaveTemplates)
    {
      ::SendMessage(m_hwndDelegateCustomRadio, BM_SETCHECK,BST_CHECKED,0);
      ::SendMessage(m_hwndDelegateTemplateRadio, BM_SETCHECK,BST_UNCHECKED,0);
      bDelegateCustom = TRUE;
    }
		SyncControlsHelper(bDelegateCustom);
	}
	else
	{
		// data already in, just coming back from next page
		if (bDelegateCustom)
		{
			pWizard->SetWizardButtonsMiddle(TRUE);
		}
		else
		{
			int nSelCount = m_delegationTemplatesListView.GetCheckCount();
			pWizard->SetWizardButtonsMiddle(nSelCount > 0);
		}
	}
	return TRUE;
}

LRESULT CDelegWiz_DelegationTemplateSelectionPage::OnWizardNext()
{
  HRESULT hr = S_OK;
	int nSelCount = -1;
	int* nSelArray = NULL;
  BOOL bCanAdvance = FALSE;

  CDelegWiz* pWiz = GET_OU_WIZARD();

	// check if the delegation is on all objects
  
  BOOL bCustom = TRUE;
  UINT nNextPageID = 0;
	if (BST_CHECKED == ::SendMessage(m_hwndDelegateCustomRadio, BM_GETCHECK,0,0))
	{
    nSelCount = 0;
    nSelArray = NULL;
    bCanAdvance = TRUE;
	}
	else
	{
		ASSERT(BST_CHECKED == ::SendMessage(m_hwndDelegateTemplateRadio, BM_GETCHECK,0,0));
    bCustom = FALSE;

    nSelCount = 0;
    int nCount = m_delegationTemplatesListView.GetItemCount();
  	for (int k=0; k<nCount; k++)
  	{
      CTemplate* pTempl = (CTemplate*)m_delegationTemplatesListView.GetItemData(k);
      pTempl->m_bSelected = m_delegationTemplatesListView.IsItemChecked(k);
      if (pTempl->m_bSelected)
        nSelCount++;
    }

    bCanAdvance = (nSelCount > 0);
	}

	if (!bCanAdvance)
		goto error;

  // set branching info
  if (bCustom)
  {
    // just move to the next custom page
    nNextPageID = CDelegWiz_ObjectTypeSelectionPage::IDD;
    pWiz->m_objectTypeSelectionPage.m_nPrevPageID = IDD;
    pWiz->m_finishPage.m_nPrevPageID = CDelegWiz_DelegatedRightsPage::IDD;
    pWiz->m_finishPage.SetCustom();
  }
  else
  {
    // need to gather info for the selected templates
    {
      // scope to restore cursor
      CWaitCursor wait;

      if (!pWiz->InitPermissionHoldersFromSelectedTemplates())
      {
        // REVIEW_MARCOC: need to give a message to the user
        pWiz->WizMessageBox(IDS_DELEGWIZ_ERR_TEMPL_APPLY);
        goto error;
      }
    }

    // got info, can proceed
    nNextPageID = CDelegWiz_FinishPage::IDD;
    pWiz->m_finishPage.m_nPrevPageID = IDD;
    pWiz->m_finishPage.SetTemplate();
  }
  OnWizardNextHelper();

	return nNextPageID; // advance next

error:
  // do not advance, error
  pWiz->SetWizardButtonsMiddle(FALSE);
  return -1; 
}



void CDelegWiz_DelegationTemplateSelectionPage::SyncControlsHelper(BOOL bDelegateCustom)
{
  CDelegWiz* pWiz = GET_OU_WIZARD();
	// uncheck all items in the listview if delegating custom
	if (bDelegateCustom)
  {
		m_delegationTemplatesListView.SetCheckAll(FALSE);
    pWiz->m_templateAccessPermissionsHolderManager.DeselectAll(); // in the list templates
  }

	// disable listbox if "delegate custom"
	m_delegationTemplatesListView.EnableWindow(!bDelegateCustom);

	// enable "Wizard Next" 
  BOOL bEnableNext = bDelegateCustom ? 
                              TRUE : (m_delegationTemplatesListView.GetCheckCount() > 0);

  pWiz->SetWizardButtonsMiddle(bEnableNext);
}





////////////////////////////////////////////////////////////////////////////
// CDelegWiz_ObjectTypeSelectionPage


BOOL CALLBACK CDelegWiz_ObjectTypeSelectionPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
    m_objectTypeListView.Initialize(IDC_OBJ_TYPE_LIST, m_hWnd);
    
    // set the correct value for radiobuttons text
    m_hwndDelegateAllRadio = GetDlgItem(IDC_DELEGATE_ALL_RADIO);
    ASSERT(m_hwndDelegateAllRadio != NULL);
    m_hwndDelegateFollowingRadio = GetDlgItem(IDC_DELEGATE_FOLLOWING_RADIO);
    ASSERT(m_hwndDelegateFollowingRadio != NULL);
    m_hwndDelegateCreateChild = GetDlgItem(IDC_DELEGATE_CREATE_CHILD);
    ASSERT(m_hwndDelegateCreateChild != NULL);
    m_hwndDelegateDeleteChild = GetDlgItem(IDC_DELEGATE_DELETE_CHILD);
    ASSERT(m_hwndDelegateDeleteChild != NULL);


    // set default setting
    ::SendMessage(m_hwndDelegateAllRadio,  BM_SETCHECK, BST_CHECKED, 0);
    ::SendMessage(m_hwndDelegateCreateChild,  BM_SETCHECK, BST_UNCHECKED, 0);
    ::SendMessage(m_hwndDelegateCreateChild,  BM_SETCHECK, BST_UNCHECKED, 0);


    return TRUE;
}

LRESULT CDelegWiz_ObjectTypeSelectionPage::OnObjectRadioChange(WORD wNotifyCode, WORD wID, 
													  HWND hWndCtl, BOOL& bHandled)
{
    SyncControlsHelper(IDC_DELEGATE_ALL_RADIO == wID);
    return 1;
}

LRESULT CDelegWiz_ObjectTypeSelectionPage::OnCreateDelCheckBoxChanage(WORD wNotifyCode, WORD wID, 
													  HWND hWndCtl, BOOL& bHandled)
{
     CDelegWiz* pWiz = GET_OU_WIZARD();
     if( IDC_DELEGATE_CREATE_CHILD == wID )
     {
         if( ::SendMessage( hWndCtl, BM_GETCHECK,0,0 ) )
            pWiz->m_fCreateDelChild |= ACTRL_DS_CREATE_CHILD;
         else
            pWiz->m_fCreateDelChild &= ~ACTRL_DS_CREATE_CHILD;
     }

     if( IDC_DELEGATE_DELETE_CHILD == wID )
     {
         if( ::SendMessage( hWndCtl, BM_GETCHECK,0,0 ) )
            pWiz->m_fCreateDelChild |= ACTRL_DS_DELETE_CHILD;
         else
            pWiz->m_fCreateDelChild &= ~ACTRL_DS_DELETE_CHILD;
     }
     return 1;
}


LRESULT CDelegWiz_ObjectTypeSelectionPage::OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pnmh;
	if (CCheckListViewHelper::CheckChanged(pNMListView))
	{
		int nSelCount = m_objectTypeListView.GetCheckCount();
		GET_OU_WIZARD()->SetWizardButtonsMiddle(nSelCount > 0);
	}
	return 1;
}


void CDelegWiz_ObjectTypeSelectionPage::SyncControlsHelper(BOOL bDelegateAll)
{
  CDelegWiz* pWiz = GET_OU_WIZARD();
	
	if (bDelegateAll)
  {
    // uncheck all items in the listview if delegating all
		m_objectTypeListView.SetCheckAll(FALSE); // in the listview
      pWiz->DeselectSchemaClassesSelectionCustom(); // in the list of schama classes
      //Uncheck delete/create check boxes
      ::SendMessage(m_hwndDelegateCreateChild,BM_SETCHECK,0,0);
      ::SendMessage(m_hwndDelegateDeleteChild,BM_SETCHECK,0,0);
      pWiz->m_fCreateDelChild = 0;

  }


	// enable "Wizard Next" of "delegate all"
	pWiz->SetWizardButtonsMiddle(bDelegateAll);
    // disable listbox if "delegate all"
 	m_objectTypeListView.EnableWindow(!bDelegateAll);
   ::EnableWindow( m_hwndDelegateCreateChild, !bDelegateAll);
   ::EnableWindow( m_hwndDelegateDeleteChild, !bDelegateAll);
}


void CDelegWiz_ObjectTypeSelectionPage::SetRadioControlText(HWND hwndCtrl, LPCWSTR lpszFmtText, LPCWSTR lpszText)
{
	// format new text
	int nTextLen = lstrlen(lpszText)+1; // count NULL
	int nFmtTextLen = lstrlen(lpszFmtText)+1; // count NULL
	WCHAR* lpszNewText = (WCHAR*)alloca(sizeof(WCHAR)*(nFmtTextLen+nTextLen));
	wsprintf(lpszNewText, lpszFmtText, lpszText);

	// set back
	::SendMessage(hwndCtrl, WM_SETTEXT, 0, (WPARAM)lpszNewText);
}



BOOL CDelegWiz_ObjectTypeSelectionPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();
	BOOL bRetVal = TRUE;
	BOOL bDelegateAll = 
			(BST_CHECKED == ::SendMessage(m_hwndDelegateAllRadio, BM_GETCHECK,0,0));

	if (pWizard->m_bFwd)
	{
		// need to fill in with data
    BOOL bFilter = TRUE;
    BOOL bHaveChildClasses = pWizard->FillCustomSchemaClassesListView(&m_objectTypeListView, bFilter) > 0;
    if (!bHaveChildClasses)
    {
      ::SendMessage(m_hwndDelegateAllRadio, BM_SETCHECK,BST_CHECKED,0);
      ::SendMessage(m_hwndDelegateFollowingRadio, BM_SETCHECK,BST_UNCHECKED,0);
      ::EnableWindow(m_hwndDelegateFollowingRadio, FALSE);
      
      bDelegateAll = TRUE;
    }
		SyncControlsHelper(bDelegateAll);
	}
	else
	{
		// data already in, just coming back from next page
		if (bDelegateAll)
		{
			pWizard->SetWizardButtonsMiddle(TRUE);
		}
		else
		{
			int nSelCount = m_objectTypeListView.GetCheckCount();
			pWizard->SetWizardButtonsMiddle(nSelCount > 0);
		}
	}
	return TRUE;
}

LRESULT CDelegWiz_ObjectTypeSelectionPage::OnWizardNext()
{
	HRESULT hr = S_OK;
	BOOL bCanAdvance = FALSE;
	CDelegWiz* pWiz = GET_OU_WIZARD();
	pWiz->m_bAuxClass = false;
	// check if the delegation is on all objects
	if (BST_CHECKED == ::SendMessage(m_hwndDelegateAllRadio, BM_GETCHECK,0,0))
	{
		bCanAdvance = TRUE;
	}
	else
	{
		ASSERT(BST_CHECKED == ::SendMessage(m_hwndDelegateFollowingRadio, BM_GETCHECK,0,0));
		int nSelCount = 0;
		int nCount = m_objectTypeListView.GetItemCount();
		CSchemaClassInfo* pAuxClassInfo = NULL;
  		for (int k=0; k<nCount; k++)
  		{
			CSchemaClassInfo* pChildClassInfo = (CSchemaClassInfo*)m_objectTypeListView.GetItemData(k);
			pChildClassInfo->m_bSelected = m_objectTypeListView.IsItemChecked(k);
			if (pChildClassInfo->m_bSelected)
			{
				nSelCount++;
				if(pChildClassInfo->IsAux())
				{
					pWiz->m_bAuxClass = true;		
					if(!pAuxClassInfo)
						pAuxClassInfo = pChildClassInfo;
				}
			}
		}
		bCanAdvance = (nSelCount > 0);
		if(nSelCount > 1 && pWiz->m_bAuxClass)
		{
			LPWSTR pszMessage = NULL;
			FormatStringID(&pszMessage, IDS_DELEGWIZ_ONE_AUX_CLASS,pAuxClassInfo->GetDisplayName());
			pWiz->WizMessageBox(pszMessage);
			LocalFree(pszMessage);

			bCanAdvance = FALSE;
		}
	}

	if (!bCanAdvance)
		goto error;

	{
		// scope to restore cursor
		CWaitCursor wait;
  		bCanAdvance = pWiz->SetSchemaClassesSelectionCustom();
	}
	if (!bCanAdvance)
		goto error;
	
  // for the selected child class(es), get the access permissions
  // to display in the next page

  {
    // scope to restore cursor
    CWaitCursor wait;
    bCanAdvance = pWiz->GetCustomAccessPermissions();
  }
  if (!bCanAdvance)
    goto error;

  OnWizardNextHelper();
	return 0; // advance next

error:
  // do not advance, error
  pWiz->SetWizardButtonsMiddle(FALSE);
  return -1; 
}




///////////////////////////////////////////////////////////////////////
// CPrincipalListViewHelper

BOOL CPrincipalListViewHelper::Initialize(UINT nID, HWND hParent)
{
	m_hWnd = GetDlgItem(hParent, nID);
	if (m_hWnd == NULL)
		return FALSE;

  if (!m_imageList.Create(m_hWnd))
    return FALSE;

  SetImageList();

	RECT r;
	::GetClientRect(m_hWnd, &r);
	int scroll = ::GetSystemMetrics(SM_CXVSCROLL);
	LV_COLUMN col;
	ZeroMemory(&col, sizeof(LV_COLUMN));
	col.mask = LVCF_WIDTH;
	col.cx = (r.right - r.left) - scroll;
  m_defaultColWidth = col.cx;
	return (0 == ListView_InsertColumn(m_hWnd,0,&col));
}

int CPrincipalListViewHelper::InsertItem(int iItem, CPrincipal* pPrincipal)
{
  // need to get the icon index
  int nIconIndex = m_imageList.GetIconIndex(pPrincipal->GetClass());
  if (nIconIndex == -1)
  {
    nIconIndex = m_imageList.AddIcon(pPrincipal->GetClass(), 
                                      pPrincipal->GetClassIcon());
    if (nIconIndex != -1)
      SetImageList();
  }

	LV_ITEM item;
	ZeroMemory(&item, sizeof(LV_ITEM));
	item.mask = LVIF_TEXT | LVIF_PARAM;
	item.pszText = (LPWSTR)(LPCWSTR)(pPrincipal->GetDisplayName());
	item.lParam = (LPARAM)pPrincipal;
	item.iItem = iItem;
  
  if (nIconIndex != -1)
  {
    item.iImage = nIconIndex;
    item.mask |= LVIF_IMAGE;
  }
  int iRes = ListView_InsertItem(m_hWnd, &item);
  return iRes;
}

BOOL CPrincipalListViewHelper::SelectItem(int iItem)
{
  LV_ITEM item;
  ZeroMemory(&item, sizeof(LV_ITEM));
  item.mask = LVIF_STATE;
  item.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
  item.state = LVIS_FOCUSED | LVIS_SELECTED;
  return ListView_SetItem(m_hWnd, &item);
}


CPrincipal* CPrincipalListViewHelper::GetItemData(int iItem)
{
	LV_ITEM item;
	ZeroMemory(&item, sizeof(LV_ITEM));
	item.mask = LVIF_PARAM;
	item.iItem = iItem;
	ListView_GetItem(m_hWnd, &item);
	return (CPrincipal*)item.lParam;
}

void CPrincipalListViewHelper::DeleteSelectedItems(CGrowableArr<CPrincipal>* pDeletedArr)
{
  int nItemIndex;
  while ( (nItemIndex = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED)) != -1)
  {
    CPrincipal* pPrincipal = GetItemData(nItemIndex);
    if (ListView_DeleteItem(m_hWnd, nItemIndex))
    {
      pDeletedArr->Add(pPrincipal);
    }
	} // if
  // restore selection to first item
  if (GetItemCount() > 0)
    SelectItem(0);
}


void CPrincipalListViewHelper::UpdateWidth(int cxNew)
{
  int cx = GetWidth(); // get current col width from the control
  if (cxNew < m_defaultColWidth)
    cxNew = m_defaultColWidth;
  if (cxNew != cx)
    SetWidth(cx);
}



////////////////////////////////////////////////////////////////////////////
// CDelegWiz_PrincipalSelectionPage

BOOL CALLBACK CDelegWiz_PrincipalSelectionPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
  // initialize the list of principals
    m_principalListView.Initialize(IDC_SELECTED_PRINCIPALS_LIST, m_hWnd);

  // cache handle for the remove button
    m_hwndRemoveButton = GetDlgItem(IDC_REMOVE_BUTTON);
    return TRUE;
}


LRESULT CDelegWiz_PrincipalSelectionPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	GET_OU_WIZARD()->AddPrincipals(&m_principalListView);
	SyncButtons();
   return 1;
}

LRESULT CDelegWiz_PrincipalSelectionPage::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	GET_OU_WIZARD()->DeletePrincipals(&m_principalListView);
	SyncButtons();
	return 1;
}

LRESULT CDelegWiz_PrincipalSelectionPage::OnListViewSelChange(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	SyncButtons();
	return 1;
}

BOOL CDelegWiz_PrincipalSelectionPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();
	SyncButtons();
	return TRUE;
}


LRESULT CDelegWiz_PrincipalSelectionPage::OnWizardNext()
{
  CDelegWiz* pWiz = GET_OU_WIZARD();

  // set branching info
  UINT nNextPageID = 0;
  if (pWiz->m_templateAccessPermissionsHolderManager.HasTemplates(pWiz->GetClass()))
  {
    nNextPageID = CDelegWiz_DelegationTemplateSelectionPage::IDD;
  }
  else
  {
    nNextPageID = CDelegWiz_ObjectTypeSelectionPage::IDD;
    pWiz->m_objectTypeSelectionPage.m_nPrevPageID = IDD;
  }

  OnWizardNextHelper();
  return nNextPageID;
}


void CDelegWiz_PrincipalSelectionPage::SyncButtons()
{
	BOOL bEnable = FALSE;
  int nItemCount = m_principalListView.GetItemCount();
	if (nItemCount > 0)
	{
		bEnable = m_principalListView.GetSelCount() > 0;
	}
	::EnableWindow(m_hwndRemoveButton, bEnable);

	CDelegWiz* pWiz = GET_OU_WIZARD();
	pWiz->SetWizardButtonsMiddle(nItemCount > 0);
}


////////////////////////////////////////////////////////////////////////////
// CDelegWiz_DelegatedRightsPage


BOOL CALLBACK CDelegWiz_DelegatedRightsPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
    // initialize check list view
    m_delegatedRigthsListView.Initialize(IDC_DELEG_RIGHTS_LIST, m_hWnd);

    // get HWND's of controls
    m_hwndGeneralRigthsCheck = GetDlgItem(IDC_SHOW_GENERAL_CHECK);
    _ASSERTE(m_hwndGeneralRigthsCheck);
    m_hwndPropertyRightsCheck = GetDlgItem(IDC_SHOW_PROPERTY_CHECK);
    _ASSERTE(m_hwndPropertyRightsCheck);
    m_hwndSubobjectRightsCheck = GetDlgItem(IDC_SHOW_SUBOBJ_CHECK);
    _ASSERTE(m_hwndSubobjectRightsCheck);

    return TRUE;
}


BOOL CDelegWiz_DelegatedRightsPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();

	if (pWizard->m_bFwd)
	{
		if(pWizard->m_bAuxClass)
			SetFilterOptions(FILTER_EXP_GEN_DISABLED|FILTER_EXP_PROP);
		else
			SetFilterOptions(FILTER_EXP_GEN);

		ResetCheckList(); // will set wizard button
	}
	else
	{
		//coming back from next page, just set the wizard button
		pWizard->SetWizardButtonsMiddle(pWizard->HasPermissionSelectedCustom());
	}
	return TRUE;
}

LRESULT CDelegWiz_DelegatedRightsPage::OnWizardNext()
{
  CDelegWiz* pWiz = GET_OU_WIZARD();
	// must at least one check > 0
  if (pWiz->HasPermissionSelectedCustom())
  {
    OnWizardNextHelper();
    return 0;
  }

  pWiz->SetWizardButtonsMiddle(FALSE);
  return -1;
}


LRESULT CDelegWiz_DelegatedRightsPage::OnFilterChange(WORD wNotifyCode, WORD wID, 
											 HWND hWndCtl, BOOL& bHandled)
{
	ResetCheckList();
	return 1;
}



LRESULT CDelegWiz_DelegatedRightsPage::OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
  if (m_bUIUpdateInProgress)
    return 1;

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pnmh;
	if (CCheckListViewHelper::CheckChanged(pNMListView))
	{
		CRigthsListViewItem* pItem = (CRigthsListViewItem*)pNMListView->lParam; // item data
		CDelegWiz* pWizard = GET_OU_WIZARD();

    ULONG nCurrFilterOptions = GetFilterOptions();

    ULONG nNewFilterOptions = 0;
		pWizard->OnCustomAccessRightsCheckListClick(
                  pItem, CCheckListViewHelper::IsChecked(pNMListView),
                  &nNewFilterOptions);

    nNewFilterOptions |= nCurrFilterOptions;

    m_bUIUpdateInProgress = TRUE;
    // this call will cause a series of notifications:
    // we have to disable them to avoid reentrancy

    if (nNewFilterOptions == nCurrFilterOptions)
    {
      // no need to change filter selection, just update the checkboxes
      pWizard->UpdateAccessRightsListViewSelection(&m_delegatedRigthsListView, nNewFilterOptions);
    }
    else
    {
      // filter selection must be changed, 
      // so we have to update the check boxes and to refill the checklist
      SetFilterOptions(nNewFilterOptions);
      ResetCheckList();
    }
    m_bUIUpdateInProgress = FALSE;

		BOOL bSel = pWizard->HasPermissionSelectedCustom();
		pWizard->SetWizardButtonsMiddle(bSel);
	}

	return 1;
}


void CDelegWiz_DelegatedRightsPage::ResetCheckList()
{
  // get a new filtered list of rights in the list view
	CDelegWiz* pWizard = GET_OU_WIZARD();

  // this call will cause a series of notifications:
  // we have to disable them to avoid reentrancy
  m_bUIUpdateInProgress = TRUE;
	pWizard->FillCustomAccessRightsListView(&m_delegatedRigthsListView, GetFilterOptions());
	m_bUIUpdateInProgress = FALSE;
  
	pWizard->SetWizardButtonsMiddle(pWizard->HasPermissionSelectedCustom());
}

ULONG CDelegWiz_DelegatedRightsPage::GetFilterOptions()
{
  ULONG nFilterState = 0;
  
  // read the filtering options from checkboxes  
	if (BST_CHECKED == ::SendMessage(m_hwndGeneralRigthsCheck, BM_GETCHECK, 0, 0))
    nFilterState |= FILTER_EXP_GEN;

  if (BST_CHECKED == ::SendMessage(m_hwndPropertyRightsCheck, BM_GETCHECK, 0, 0))
    nFilterState |= FILTER_EXP_PROP;

	if (BST_CHECKED == ::SendMessage(m_hwndSubobjectRightsCheck, BM_GETCHECK, 0, 0))
    nFilterState |= FILTER_EXP_SUBOBJ;

  return nFilterState;
}



inline WPARAM _Checked(ULONG f) { return f ? BST_CHECKED : BST_UNCHECKED;}

void CDelegWiz_DelegatedRightsPage::SetFilterOptions(ULONG nFilterOptions)
{
  ::EnableWindow(m_hwndGeneralRigthsCheck,!(nFilterOptions & FILTER_EXP_GEN_DISABLED));
  ::SendMessage(m_hwndGeneralRigthsCheck, BM_SETCHECK, _Checked(nFilterOptions & FILTER_EXP_GEN), 0);
  ::SendMessage(m_hwndPropertyRightsCheck, BM_SETCHECK, _Checked(nFilterOptions & FILTER_EXP_PROP), 0);
  ::SendMessage(m_hwndSubobjectRightsCheck, BM_SETCHECK, _Checked(nFilterOptions & FILTER_EXP_SUBOBJ), 0);
}


////////////////////////////////////////////////////////////////////////////
// CDelegWiz_FinishPage

BOOL CALLBACK CDelegWiz_FinishPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					         LPARAM lParam, BOOL& bHandled)
{
  SetLargeFont(m_hWnd, IDC_STATIC_COMPLETION);
  return TRUE;
}

LRESULT CDelegWiz_FinishPage::OnSetFocusSummaryEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  ASSERT(hWndCtl == GetDlgItem(IDC_EDIT_SUMMARY));
  ::SendMessage(hWndCtl, EM_SETSEL, (WPARAM)-1, (LPARAM)0);

  if (m_bNeedSetFocus)
  {
    m_bNeedSetFocus = FALSE;
    TRACE(_T("Resetting Focus\n"));

    HWND hwndSheet = ::GetParent(m_hWnd);
    ASSERT(::IsWindow(hwndSheet));
    HWND hWndFinishCtrl =::GetDlgItem(hwndSheet, 0x3025);
    ASSERT(::IsWindow(hWndFinishCtrl));
    ::SetFocus(hWndFinishCtrl);
  }
  return 1;
}


BOOL CDelegWiz_FinishPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();
	pWizard->SetWizardButtonsLast(TRUE);

  CWString szSummary;
  if (m_bCustom)
    pWizard->WriteSummaryInfoCustom(szSummary, g_lpszSummaryIdent, g_lpszSummaryNewLine);
  else
    pWizard->WriteSummaryInfoTemplate(szSummary, g_lpszSummaryIdent, g_lpszSummaryNewLine);

  HWND hWndSummary = GetDlgItem(IDC_EDIT_SUMMARY);
  ::SetWindowText(hWndSummary, (LPCWSTR)szSummary);

  m_bNeedSetFocus = TRUE;

	return TRUE;
}


BOOL CDelegWiz_FinishPage::OnWizardFinish()
{
  CWaitCursor wait;
  BOOL bRes;
  CDelegWiz* pWizard = GET_OU_WIZARD();

  if (m_bCustom)
    bRes = GET_OU_WIZARD()->FinishCustom();
  else
	  bRes = GET_OU_WIZARD()->FinishTemplate();
	return bRes;
}



////////////////////////////////////////////////////////////////////////////
// CDelegWiz

const long CDelegWiz::nSchemaClassesSelAll = -2;
const long CDelegWiz::nSchemaClassesSelMultiple = -1;



// REVIEW_MARCOC: should probably nuke, not used
BOOL Is256ColorSupported()
{
    BOOL bRetval = FALSE;
    HDC hdc = GetDC(NULL);
    if( hdc )
    {
        if( GetDeviceCaps( hdc, BITSPIXEL ) >= 8 )
        {
            bRetval = TRUE;
        }
        ReleaseDC(NULL, hdc);
    }
    return bRetval;
}


CDelegWiz::CDelegWiz() : 
	CWizardBase(IDB_DELEG_WATER, IDB_DELEG_HD, IDS_DELEGWIZ_WIZ_TITLE),
	m_startPage(this),
	m_namePage(this),
  m_templateSelectionPage(this),
	m_userOrGroupSelectionPage(this),
	m_objectTypeSelectionPage(this),
	m_delegatedRightsPage(this),
	m_finishPage(this),
	m_bAuxClass(FALSE)
{
    m_lpszLDAPPath = NULL;

	m_nSchemaClassesSel = nSchemaClassesSelAll;
    m_fCreateDelChild = 0;


	// Add the property pages
	m_startPage.InitWiz97(TRUE);
	AddPage(m_startPage);

	m_namePage.InitWiz97(FALSE,
			IDS_DELEGWIZ_NAME_TITLE,
			IDS_DELEGWIZ_NAME_SUBTITLE);
	AddPage(m_namePage);


	m_userOrGroupSelectionPage.InitWiz97(FALSE,
			IDS_DELEGWIZ_PRINCIPALS_SEL_TITLE,
			IDS_DELEGWIZ_PRINCIPALS_SEL_SUBTITLE);
	AddPage(m_userOrGroupSelectionPage);
	
  // branching page
  m_templateSelectionPage.InitWiz97(FALSE,
 			IDS_DELEGWIZ_TEMPLATE_SEL_TITLE,
			IDS_DELEGWIZ_TEMPLATE_SEL_SUBTITLE);
  AddPage(m_templateSelectionPage);

	m_objectTypeSelectionPage.InitWiz97(FALSE,
		IDS_DELEGWIZ_OBJ_TYPE_SEL_TITLE,
		IDS_DELEGWIZ_OBJ_TYPE_SEL_SUBTITLE);
	AddPage(m_objectTypeSelectionPage);
	
	m_delegatedRightsPage.InitWiz97(FALSE,
		IDS_DELEGWIZ_DELEG_RIGHTS_TITLE,
		IDS_DELEGWIZ_DELEG_RIGHTS_SUBTITLE);
	AddPage(m_delegatedRightsPage);
	
	m_finishPage.InitWiz97(TRUE);
	AddPage(m_finishPage);


  m_templateAccessPermissionsHolderManager.LoadTemplates();
};


CDelegWiz::~CDelegWiz()
{
}


HRESULT CDelegWiz::AddPrincipalsFromBrowseResults(CPrincipalListViewHelper* pListViewHelper, 
                                                  PDS_SELECTION_LIST pDsSelectionList)
{
  TRACE(L"CDelegWiz::AddPrincipalsFromBrowseResults()\n");

	HRESULT hr = S_OK;
	if ( (pDsSelectionList == NULL) || (pDsSelectionList->cItems == 0))
  {
    TRACE(L"CDelegWiz::AddPrincipalsFromBrowseResults(), no items!!!\n");
		return E_INVALIDARG;
  }

  int nListInsertPosition = pListViewHelper->GetItemCount();
  for (int i = 0; i < pDsSelectionList->cItems; i++)
  {
    TRACE(L"For loop, pDsSelectionList->cItems = %d\n", pDsSelectionList->cItems);

		// add to list of principals
		CPrincipal* pPrincipal = new CPrincipal;
		if (pPrincipal != NULL)
		{
      HICON hClassIcon = m_adsiObject.GetClassIcon(pDsSelectionList->aDsSelection[i].pwzClass);
      HRESULT hrInit = pPrincipal->Initialize(&(pDsSelectionList->aDsSelection[i]), hClassIcon);
      if (FAILED(hrInit))
      {
        LPCWSTR lpszName = pDsSelectionList->aDsSelection[i].pwzName;
        WCHAR szFmt[256];
        LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_PRINCIPAL, szFmt, 256);
        int nNameLen = lstrlen(lpszName) + 1;

        WCHAR* lpszMsg = (WCHAR*)alloca(sizeof(WCHAR)*(nNameLen+256));
        wsprintf(lpszMsg, szFmt, lpszName);
        WizReportHRESULTError(lpszMsg, hrInit);
        delete pPrincipal;
        continue;
      }

      // add to list of principals (if not already there)
			if (m_principalList.AddIfNotPresent(pPrincipal))
      {
  			// add to listbox (assume not sorted)
        pListViewHelper->InsertItem(nListInsertPosition, pPrincipal);
        nListInsertPosition++;
      }

		} // if pPrincipal not NULL

  } // for

  // make sure there is a selection
  if ( (pListViewHelper->GetItemCount() > 0) &&
        (pListViewHelper->GetSelCount() == 0) )
  {
    // if we have items, but none is selected, make sure we set the selection
    // to the first one.
    pListViewHelper->SelectItem(0);
  }

	// update width
  //pListViewHelper->UpdateWidth(m_principalList.GetMaxListboxExtent());
	return hr;
}




/*
typedef struct _DSOP_FILTER_FLAGS
{
    DSOP_UPLEVEL_FILTER_FLAGS   Uplevel;
    ULONG                       flDownlevel;
} DSOP_FILTER_FLAGS;

  
typedef struct _DSOP_SCOPE_INIT_INFO
{
    ULONG               cbSize;
    ULONG               flType;
    ULONG               flScope;
    DSOP_FILTER_FLAGS   FilterFlags;
    PCWSTR              pwzDcName;      // OPTIONAL
    PCWSTR              pwzADsPath;     // OPTIONAL
    HRESULT             hr;
} DSOP_SCOPE_INIT_INFO, *PDSOP_SCOPE_INIT_INFO;

*/

DSOP_SCOPE_INIT_INFO g_aDSOPScopes[] =
{
#if 0
    {
        cbSize,
        flType,
        flScope,
        {
            { flBothModes, flMixedModeOnly, flNativeModeOnly },
            flDownlevel,
        },
        pwzDcName,
        pwzADsPath,
        hr // OUT
    },
#endif

    // The Global Catalog
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_GLOBAL_CATALOG,
        DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS,
        {
            { DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS | 
              DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_SE | 
              DSOP_FILTER_COMPUTERS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS, 0, 0 },
            0,
        },
        NULL,
        NULL,
        S_OK
    },

    // The domain to which the target computer is joined.
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,
        DSOP_SCOPE_FLAG_STARTING_SCOPE | 
        DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS,
        {
          // joined domain is always NT5 for DS ACLs Editor
          { 0, 
          //mixed: users, well known SIDs, local groups, builtin groups, global groups, computers
          DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS  | DSOP_FILTER_WELL_KNOWN_PRINCIPALS | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE | DSOP_FILTER_BUILTIN_GROUPS | DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_COMPUTERS , 

          //native users, well known SIDs, local groups, builtin groups, global groups, universal groups, computers
          DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS  | DSOP_FILTER_WELL_KNOWN_PRINCIPALS | 
          DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE | DSOP_FILTER_BUILTIN_GROUPS |
          DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_COMPUTERS
          },
        0, // zero for downlevel joined domain, should be DS-aware
        },
        NULL,
        NULL,
        S_OK
    },

    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,
	DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS,

        {
            { DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS | DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_COMPUTERS, 0, 0},
            0,
        },
        NULL,
        NULL,
        S_OK
    },

    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,
        DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT|        
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS,
        {
            { DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS | DSOP_FILTER_UNIVERSAL_GROUPS_SE | 				DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_COMPUTERS, 0, 0},
            DSOP_DOWNLEVEL_FILTER_USERS | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS,
        },
        NULL,
        NULL,
        S_OK
    },
};

//
// Attributes that we want the Object Picker to retrieve
//
static const LPCTSTR g_aszOPAttributes[] =
{
    TEXT("ObjectSid"),
	 TEXT("userAccountControl"),
};



HRESULT CDelegWiz::AddPrincipals(CPrincipalListViewHelper* pListViewHelper)
{
  TRACE(L"CDelegWiz::AddPrincipals()\n");

  // create object picker COM object
  CComPtr<IDsObjectPicker> spDsObjectPicker;
  HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker, (void**)&spDsObjectPicker);
  if (FAILED(hr))
  {
    TRACE(L"CoCreateInstance(CLSID_DsObjectPicker) failed, hr = 0x%x\n");
    return hr;
  }

    // set init info
  DSOP_INIT_INFO InitInfo;
  ZeroMemory(&InitInfo, sizeof(InitInfo));

  InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
  InitInfo.pwzTargetComputer = m_adsiObject.GetServerName();
  InitInfo.cDsScopeInfos = sizeof(g_aDSOPScopes)/sizeof(DSOP_SCOPE_INIT_INFO);
  InitInfo.aDsScopeInfos = g_aDSOPScopes;
  InitInfo.flOptions = DSOP_FLAG_MULTISELECT;
  InitInfo.cAttributesToFetch = 2;
  InitInfo.apwzAttributeNames = (LPCTSTR*)g_aszOPAttributes;;


  TRACE(L"InitInfo.cbSize               = %d\n",    InitInfo.cbSize);
  TRACE(L"InitInfo.pwzTargetComputer    = %s\n",    InitInfo.pwzTargetComputer);
  TRACE(L"InitInfo.cDsScopeInfos        = %d\n",    InitInfo.cDsScopeInfos);
  TRACE(L"InitInfo.aDsScopeInfos        = 0x%x\n",  InitInfo.aDsScopeInfos);
  TRACE(L"InitInfo.flOptions            = 0x%x\n",  InitInfo.flOptions);
  TRACE(L"InitInfo.cAttributesToFetch   = %d\n",    InitInfo.cAttributesToFetch);
  TRACE(L"InitInfo.apwzAttributeNames[0]= %s\n", InitInfo.apwzAttributeNames[0]);

  // initialize object picker
  hr = spDsObjectPicker->Initialize(&InitInfo);
  if (FAILED(hr))
  {
    TRACE(L"spDsObjectPicker->Initialize(...) failed, hr = 0x%x\n");
    return hr;
  }

  // invoke the dialog
  CComPtr<IDataObject> spdoSelections;

  hr = spDsObjectPicker->InvokeDialog(m_hWnd, &spdoSelections);
  if (hr == S_FALSE || !spdoSelections)
  {
      return S_FALSE;
  }

  // retrieve data from data object
  FORMATETC fmte = {(CLIPFORMAT)_Module.GetCfDsopSelectionList(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};
  PDS_SELECTION_LIST pDsSelList = NULL;

  hr = spdoSelections->GetData(&fmte, &medium);
  if (FAILED(hr))
  {
    TRACE(L"spdoSelections->GetData(...) failed, hr = 0x%x\n");
    return hr;
  }

  pDsSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

  if(!DoDisabledCheck(*this,pDsSelList))
  {
	  return S_FALSE;
  }

  hr = AddPrincipalsFromBrowseResults(pListViewHelper, pDsSelList);

  GlobalUnlock(medium.hGlobal);
  ReleaseStgMedium(&medium);

  return hr;
}


BOOL CDelegWiz::DeletePrincipals(CPrincipalListViewHelper* pListViewHelper)
{
  CGrowableArr<CPrincipal> deletedArr(FALSE); // do not own memory
  
  // remove from listview
  pListViewHelper->DeleteSelectedItems(&deletedArr);
  // remove from list of items
  int nDeletedCount = deletedArr.GetCount();
  for (int k=0; k<nDeletedCount; k++)
  {
    m_principalList.Remove(deletedArr[k]);
  }
  //pListViewHelper->UpdateWidth(m_principalList.GetMaxListboxExtent());
	return TRUE;
}


int CDelegWiz::FillCustomSchemaClassesListView(CCheckListViewHelper* pListViewHelper, BOOL bFilter)
{
	// clear old entries
	pListViewHelper->DeleteAllItems();

  int nCount = m_schemaClassInfoArray.GetCount();
  if (nCount == 0)
    return 0; // no insertions, nothing else to do

  // figure out the max len of items to get a big enough buffer
  int nMaxLen = 0;
  int nCurrLen = 0;
  for (long index = 0; index < nCount; index++)
	{
    nCurrLen = lstrlen(m_schemaClassInfoArray[index]->GetDisplayName());
    if (nCurrLen > nMaxLen)
      nMaxLen = nCurrLen;
  }

  CWString szFormat;
  szFormat.LoadFromResource(IDS_DELEGWIZ_CHILD_CLASS_FMT);

  WCHAR* pwszNewText = (WCHAR*)alloca(sizeof(WCHAR)*(szFormat.size()+nMaxLen+1));

	// add formatted entries, assume listbox not sorted
  long iListBoxItem = 0;
	for (index = 0; index < nCount; index++)
	{
    CSchemaClassInfo* pChildClassInfo = m_schemaClassInfoArray[index];
    pChildClassInfo->m_bSelected = FALSE;
    if (bFilter && pChildClassInfo->IsFiltered())
      continue;

		wsprintf(pwszNewText, (LPCWSTR)szFormat, pChildClassInfo->GetDisplayName());
		pListViewHelper->InsertItem(iListBoxItem, pwszNewText, (LPARAM)pChildClassInfo, FALSE);
    iListBoxItem++;
	}

	return iListBoxItem; // return the # of items inserted
}


BOOL CDelegWiz::SetSchemaClassesSelectionCustom()
{
  int nSelCount = 0;
  int nCount = m_schemaClassInfoArray.GetCount();
  CComPtr<IADsClass> spSchemaObjectClass;	
  
    m_bChildClass = FALSE;

    // get the selection count
    int nSingleSel = -1;
    for (int k=0; k < nCount; k++)
    {
        if (m_schemaClassInfoArray[k]->m_bSelected)
        {
            if( m_schemaClassInfoArray[k]->m_dwChildClass == CHILD_CLASS_NOT_CALCULATED )
            {
                if (m_schemaClassInfoArray[k]->GetName() != NULL)
                {
                    int nServerNameLen = lstrlen(m_adsiObject.GetServerName());
	                int nClassNameLen = lstrlen(m_schemaClassInfoArray[k]->GetName());
	                int nFormatStringLen = lstrlen(g_wzLDAPAbstractSchemaFormat);
	                VARIANT var = {0};

	                // build the LDAP path for the schema class
	                WCHAR* pwszSchemaObjectPath = 
		            (WCHAR*)alloca(sizeof(WCHAR)*(nServerNameLen+nClassNameLen+nFormatStringLen+1));
	                wsprintf(pwszSchemaObjectPath, g_wzLDAPAbstractSchemaFormat, m_adsiObject.GetServerName(), m_schemaClassInfoArray[k]->GetName());

	                // get the schema class ADSI object
	                HRESULT hr = ::ADsOpenObjectHelper(pwszSchemaObjectPath, 
                                                       IID_IADsClass, 
                                                       0,
                                                       (void**)&spSchemaObjectClass);
	                if (FAILED(hr))
                        //NTRAID#NTBUG9-530206-2002/06/18-ronmart-PREFAST: Casting HRESULT to BOOL
		                //return hr;
                        return FALSE;

                    
                    spSchemaObjectClass->get_Containment(&var);

                    if (V_VT(&var) == (VT_ARRAY | VT_VARIANT))
                    {
                        LPSAFEARRAY psa = V_ARRAY(&var);

                        ASSERT(psa && psa->cDims == 1);

                        if (psa->rgsabound[0].cElements > 0)
                        {
                            m_schemaClassInfoArray[k]->m_dwChildClass = CHILD_CLASS_EXIST;
                        }
                        else
                            m_schemaClassInfoArray[k]->m_dwChildClass = CHILD_CLASS_NOT_EXIST;
                    }
                    else if (V_VT(&var) == VT_BSTR) // single entry
                    {
                        m_schemaClassInfoArray[k]->m_dwChildClass = CHILD_CLASS_EXIST;
                    }
                    else
                        m_schemaClassInfoArray[k]->m_dwChildClass = CHILD_CLASS_NOT_EXIST;

                    VariantClear(&var);

                }
            }

            if( m_schemaClassInfoArray[k]->m_dwChildClass != CHILD_CLASS_NOT_EXIST )
                m_bChildClass = TRUE;

            if (nSingleSel == -1)
                nSingleSel = k;
            nSelCount++;
        }
    }

  
  
  if (nSelCount == 0)
  {
    m_nSchemaClassesSel = nSchemaClassesSelAll;
    m_bChildClass = TRUE;
    return TRUE; // delegate control to all types
  }

  // keep track if it is a single selection
  if (nSelCount == 1)
  {
    ASSERT(nSingleSel != -1);
		m_nSchemaClassesSel = nSingleSel;
    return TRUE;
  }
	
	// multiple selection
  m_nSchemaClassesSel = nSchemaClassesSelMultiple;

  return TRUE;
}


void CDelegWiz::DeselectSchemaClassesSelectionCustom()
{
  int nCount = m_schemaClassInfoArray.GetCount();
	
  for (int k=0; k < nCount; k++)
  {
		m_schemaClassInfoArray[k]->m_bSelected = FALSE;
  }
}


BOOL CDelegWiz::GetCustomAccessPermissions()
{
	// remove all the old entries
	m_permissionHolder.Clear();

	// retrieve the string for the child class object type (single selection)
  // for multiple selection, it will be NULL

  CSchemaClassInfo* pClassInfo = NULL;

  switch (m_nSchemaClassesSel)
  {
  case nSchemaClassesSelMultiple:
    {
      // for multiple selection, it will be NULL
      pClassInfo = NULL;
    }
    break;
  case nSchemaClassesSelAll:
    {
      // just get the class name of the object we want to delegate rights on
      // need to find matching class in the schema info array
     	for (int k=0; k < m_schemaClassInfoArray.GetCount(); k++)
			{
				if (_wcsicmp(m_schemaClassInfoArray[k]->GetName(), m_adsiObject.GetClass()) == 0)
				{
          pClassInfo = m_schemaClassInfoArray[k];
          break;
				}
			} // for k
      ASSERT(pClassInfo != NULL);
    }
    break;
  default:
    {
      // single selection
      ASSERT( (m_nSchemaClassesSel >= 0) && 
			    (m_nSchemaClassesSel < m_schemaClassInfoArray.GetCount()) );
      pClassInfo = m_schemaClassInfoArray[m_nSchemaClassesSel];
    }
  } // switch

  // get the permissions from the DS
	LPCWSTR lpszClassName = NULL;
  const GUID* pSchemaIDGUID = NULL;
  if (pClassInfo != NULL)
  {
	  lpszClassName = pClassInfo->GetName();
    pSchemaIDGUID = pClassInfo->GetSchemaGUID();
  }


  HRESULT hr = m_permissionHolder.ReadDataFromDS(&m_adsiObject, 
												 m_adsiObject.GetNamingContext(),
                                                 lpszClassName, 
												 pSchemaIDGUID, 
												 m_bChildClass,
												 HideListObjectAccess());
                                           
  if (FAILED(hr))
  {
    WizReportHRESULTError(IDS_DELEGWIZ_ERR_PERMISSIONS, hr);
    return FALSE;
  }
  return TRUE;
}




void CDelegWiz::FillCustomAccessRightsListView(CCheckListViewHelper* pListViewHelper, 
											 ULONG nFilterState)
{
	// clear check list
	pListViewHelper->DeleteAllItems();
	
  m_permissionHolder.FillAccessRightsListView(pListViewHelper, nFilterState); 
}


void CDelegWiz::UpdateAccessRightsListViewSelection(
                       CCheckListViewHelper* pListViewHelper,
                       ULONG nFilterState)
{
  m_permissionHolder.UpdateAccessRightsListViewSelection(
                        pListViewHelper, nFilterState);
}


BOOL CDelegWiz::HasPermissionSelectedCustom()
{ 
  return m_permissionHolder.HasPermissionSelected();
}


void CDelegWiz::OnCustomAccessRightsCheckListClick(
                        CRigthsListViewItem* pItem,
												BOOL bSelected,
                        ULONG* pnNewFilterState)
{

  m_permissionHolder.Select(pItem, bSelected, pnNewFilterState);
}


void CDelegWiz::WriteSummaryInfoCustom(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  // write object name and principals
  WriteSummaryInfoHelper(szSummary, lpszIdent, lpszNewLine);

  // write the list of rights
  m_permissionHolder.WriteSummary(szSummary, lpszIdent, lpszNewLine);

  // write the list of child classes (if applicable)
  if (m_nSchemaClassesSel != nSchemaClassesSelAll)
  {
    WriteSummaryTitleLine(szSummary, IDS_DELEGWIZ_FINISH_OBJECT, lpszNewLine);

	  for (int k=0; k < m_schemaClassInfoArray.GetCount(); k++)
	  {
		  if (m_schemaClassInfoArray[k]->m_bSelected)
		  {
        WriteSummaryLine(szSummary, m_schemaClassInfoArray[k]->GetDisplayName(), lpszIdent, lpszNewLine);
		  }
	  }
    szSummary += lpszNewLine;

  } // if
}



BOOL CDelegWiz::InitPermissionHoldersFromSelectedTemplates()
{
  if (!m_templateAccessPermissionsHolderManager.InitPermissionHoldersFromSelectedTemplates(
        &m_schemaClassInfoArray, &m_adsiObject))
  {
    // error: no valid and applicable data has been retrieved from the selected
    // templates
    return FALSE;
  }
  return TRUE;
}



void CDelegWiz::WriteSummaryInfoTemplate(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  // write object name and principals
  WriteSummaryInfoHelper(szSummary,lpszIdent, lpszNewLine);

  // write the list of templates
  m_templateAccessPermissionsHolderManager.WriteSummary(szSummary, lpszIdent, lpszNewLine);
}




void CDelegWiz::WriteSummaryInfoHelper(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  // set the canonical name
  WriteSummaryTitleLine(szSummary, IDS_DELEGWIZ_FINISH_FOLDER, lpszNewLine);

  WriteSummaryLine(szSummary, GetCanonicalName(), lpszIdent, lpszNewLine);
  szSummary += lpszNewLine;

  // write the list of principals
  m_principalList.WriteSummaryInfo(szSummary, lpszIdent, lpszNewLine);
}




/*
typedef struct _ACTRL_ACCESS_ENTRYW
{
    TRUSTEE_W       Trustee;
    ULONG           fAccessFlags;
    ACCESS_RIGHTS   Access;
    ACCESS_RIGHTS   ProvSpecificAccess;
    INHERIT_FLAGS   Inheritance;
    LPWSTR          lpInheritProperty;
} ACTRL_ACCESS_ENTRYW, *PACTRL_ACCESS_ENTRYW;
*/

DWORD CDelegWiz::UpdateAccessList(CPrincipal* pPrincipal,
									CSchemaClassInfo* pClassInfo,
									PACL *ppAcl)
{

  return m_permissionHolder.UpdateAccessList( 
                                            pPrincipal, pClassInfo, 
                                            m_adsiObject.GetServerName(),
                                            m_adsiObject.GetPhysicalSchemaNamingContext(),
                                            ppAcl);
}








DWORD CDelegWiz::BuildNewAccessListCustom(PACL *ppNewAcl)
{
	DWORD dwErr = 0;

  TRACE(L"BuildNewAccessListCustom()\n");

	// loop thru all the principals and classes
  CPrincipalList::iterator i;
  for (i = m_principalList.begin(); i != m_principalList.end(); ++i)
  {
    CPrincipal* pCurrPrincipal = *i;
		if (m_nSchemaClassesSel == nSchemaClassesSelAll)
    {
      // delegate on all objects
			dwErr = UpdateAccessList(
				      pCurrPrincipal, 
				      NULL, // all classes
				      ppNewAcl);
      if (dwErr != ERROR_SUCCESS)
		    return dwErr;
    }
		else if (m_nSchemaClassesSel == nSchemaClassesSelMultiple)
    {
      // delegate on multiple objects
			// multiple selection, loop thru each class to
			// add rights for each
			for (int k=0; k < m_schemaClassInfoArray.GetCount(); k++)
			{
				if (m_schemaClassInfoArray[k]->m_bSelected)
				{
					dwErr = UpdateAccessList(
						      pCurrPrincipal, 
						      m_schemaClassInfoArray[k],
						      ppNewAcl);
               if (dwErr != ERROR_SUCCESS)
        		      return dwErr;
               if( m_fCreateDelChild != 0 )
               {
                   dwErr = ::AddObjectRightInAcl( pCurrPrincipal->GetSid(),
                                                m_fCreateDelChild, 
                                                m_schemaClassInfoArray[k]->GetSchemaGUID(), 
                                                NULL,
                                                ppNewAcl);

                  if (dwErr != ERROR_SUCCESS)
        	     	      return dwErr;  
                }
  
				}
			} // for k
    }
    else
		{
			// single selection on child classes
			dwErr = UpdateAccessList(
				        pCurrPrincipal, 
				        m_schemaClassInfoArray[m_nSchemaClassesSel],
				        ppNewAcl);
         if (dwErr != ERROR_SUCCESS)
		      return dwErr;

         if( m_fCreateDelChild != 0 )
         {
            dwErr = ::AddObjectRightInAcl( pCurrPrincipal->GetSid(),
                                           m_fCreateDelChild, 
                                           m_schemaClassInfoArray[m_nSchemaClassesSel]->GetSchemaGUID(), 
                                           NULL,
                                           ppNewAcl);

            if (dwErr != ERROR_SUCCESS)
        	      return dwErr;  
         }		
      }
	} // for pCurrPrincipal

	return dwErr;
}

DWORD CDelegWiz::BuildNewAccessListTemplate(PACL *ppNewAcl)
{
	DWORD dwErr = 0;
  
  TRACE(L"BuildNewAccessListTemplate()\n");


	// loop thru all the principals and classes
  CPrincipalList::iterator i;
  for (i = m_principalList.begin(); i != m_principalList.end(); ++i)
  {
    CPrincipal* pCurrPrincipal = *i;
    dwErr = m_templateAccessPermissionsHolderManager.UpdateAccessList(
                                            pCurrPrincipal, 
                                            m_adsiObject.GetServerName(),
                                            m_adsiObject.GetPhysicalSchemaNamingContext(),
                                            ppNewAcl);

    if (dwErr != 0)
      break;
	} // for pCurrPrincipal

	return dwErr;
}



BOOL CDelegWiz::FinishHelper(BOOL bCustom)
{
	BOOL bRetVal = FALSE;
	DWORD dwErr = 0;


  PACL pDacl = NULL;
  PACL pOldAcl = NULL;
  PSECURITY_DESCRIPTOR pSD = NULL;

  LPCWSTR lpszObjectLdapPath = m_adsiObject.GetLdapPath();

  // get the security info
  TRACE(L"calling GetSDForDsObjectPath(%s, ...)\n", lpszObjectLdapPath);

  HRESULT hr  = ::GetSDForDsObjectPath(IN const_cast<LPWSTR>(lpszObjectLdapPath),
                                       &pDacl,
                                       &pSD);


	if (FAILED(hr))
	{
        TRACE(L"failed on GetSDForDsObjectPath(): hr = 0x%x\n", hr);
        WCHAR szMsg[512];
        LoadStringHelper(IDS_DELEGWIZ_ERR_GET_SEC_INFO, szMsg, 512);
		    WizReportHRESULTError(szMsg, hr);
		    goto exit;
	}


  //pOldAcl is passed to functions which free it. pDacl cannot be
  //passed as pSD should be freed , not pDacl. Instead of changing code
  //to pass pSD, i am changing it to make a copy of pDacl which can 
  //be correctly freed.
  if(pDacl)
  {
    pOldAcl = (PACL)LocalAlloc(LPTR, pDacl->AclSize);
    if(!pOldAcl)
        return FALSE;
    memcpy(pOldAcl, pDacl,pDacl->AclSize);
  }
  LocalFree(pSD);
  pSD = NULL;
  pDacl = NULL;

  

	// build the new Access List 
  if (bCustom)
  {
	  dwErr = BuildNewAccessListCustom(&pOldAcl); // in/out parameter
  }
  else
  {
    dwErr = BuildNewAccessListTemplate(&pOldAcl); // in/out parameter
  }

	if (dwErr != ERROR_SUCCESS)
	{
    TRACE(_T("failed on BuildNewAccessListXXX()\n"));
    WCHAR szMsg[512];
    LoadStringHelper(IDS_DELEGWIZ_ERR_EDIT_SEC_INFO, szMsg, 512);
		WizReportWin32Error(szMsg, dwErr);
		goto exit;
	}


	// commit changes
  TRACE(L"calling SetDaclForDsObjectPath(%s, ...)\n", lpszObjectLdapPath);

  hr  = ::SetDaclForDsObjectPath(IN const_cast<LPWSTR>(lpszObjectLdapPath),pOldAcl);


   if(FAILED(hr))
	{
		TRACE(L"failed on SetDaclForDsObjectPath(): hr = 0x%x\n", hr);
    WCHAR szMsg[512];
	if(dwErr == ERROR_ACCESS_DENIED)
		LoadStringHelper(IDS_DELEGWIZ_ERR_ACCESS_DENIED, szMsg, 512);
	else
		LoadStringHelper(IDS_DELEGWIZ_ERR_SET_SEC_INFO, szMsg, 512);
	
	WizReportHRESULTError(szMsg, hr);
    goto exit;
	}
	bRetVal = TRUE;


exit:
  // cleanup memory
	if (pOldAcl != NULL)
		::LocalFree(pOldAcl);

	return bRetVal;
}

//+----------------------------------------------------------------------------
//  Function:DoDisabledCheck   
//  Synopsis:Check if any of the object in pDsSelList is disabled. if yes,
//				 function displays a dialog box to user. 
//  Returns: TRUE if to add objects in list to acl else no.   
//-----------------------------------------------------------------------------
BOOL
DoDisabledCheck(IN CDelegWiz& refWiz,
				IN PDS_SELECTION_LIST pDsSelList)
{
	if(!pDsSelList)
	{
		return FALSE;
	}

	HRESULT hr = S_OK;
	int cNames = pDsSelList->cItems;
	BOOL bDisabled = FALSE;

	//
	//Check if account of any of the object in the list is disbled
	//
   for (int i = 0; i < cNames; i++)
   {
	  //Second element in the array is pointer to UserAccountControl
      LPVARIANT pvarUAC = pDsSelList->aDsSelection[i].pvarFetchedAttributes + 1;

      if (NULL == pvarUAC || (VT_I4 != V_VT(pvarUAC)))
		{
			continue;
		}
		if(bDisabled = V_I4(pvarUAC) & UF_ACCOUNTDISABLE)
			break;
	}

	BOOL bReturn = TRUE;
	if(bDisabled)
	{
		if(IDCANCEL == refWiz.WizMessageBox(IDS_DISABLED_USER,
											MB_OKCANCEL | MB_ICONWARNING | MB_APPLMODAL ))
		{
			bReturn = FALSE;
		}
	}

	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\pch.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       pch.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>

HRESULT WINAPI COuDelegComModule::UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister)
{
    static const WCHAR szIPS32[] = _T("InprocServer32");
    static const WCHAR szCLSID[] = _T("CLSID");

    HRESULT hRes = S_OK;

    LPOLESTR lpOleStrCLSIDValue;
    ::StringFromCLSID(clsid, &lpOleStrCLSIDValue);

    CRegKey key;
    if (bRegister)
    {
        LONG lRes = key.Open(HKEY_CLASSES_ROOT, szCLSID);
        if (lRes == ERROR_SUCCESS)
        {
            lRes = key.Create(key, lpOleStrCLSIDValue);
            if (lRes == ERROR_SUCCESS)
            {
                WCHAR szModule[_MAX_PATH+1];
                ZeroMemory(szModule,sizeof(szModule));
                if(_MAX_PATH == ::GetModuleFileName(m_hInst, szModule, _MAX_PATH))
                {
                    //GetModuleFileName truncated szModule
                    return E_FAIL;
                }

                key.SetKeyValue(szIPS32, szModule);
            }
        }
        if (lRes != ERROR_SUCCESS)
            hRes = HRESULT_FROM_WIN32(lRes);
    }
    else
    {
        key.Attach(HKEY_CLASSES_ROOT);
        if (key.Open(key, szCLSID) == ERROR_SUCCESS)
            key.RecurseDeleteKey(lpOleStrCLSIDValue);
    }
    ::CoTaskMemFree(lpOleStrCLSIDValue);
    return hRes;
}

BOOL COuDelegComModule::InitClipboardFormats()
{
    _ASSERTE(m_cfDsObjectNames == 0);
    m_cfDsObjectNames = ::RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
  _ASSERTE(m_cfParentHwnd == 0);
    m_cfParentHwnd = ::RegisterClipboardFormat(CFSTR_DS_PARENTHWND);
  _ASSERTE(m_cfDsopSelectionList == 0);
  m_cfDsopSelectionList = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

    return (m_cfDsObjectNames != 0) && (m_cfParentHwnd != 0) && (m_cfDsopSelectionList != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------


#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#define _ATL_APARTMENT_THREADED

//#define _ATL_DISABLE_NO_VTABLE



#define _DELEGWIZ



//////////////////////////////////////////////
// CRT and C++ headers

#pragma warning( disable : 4530) // REVIEW_MARCOC: need to get the -GX flag to work 

#include <xstring>
#include <list>
#include <vector>
#include <algorithm>

using namespace std;

//////////////////////////////////////////////
// Windows and ATL headers

#include <windows.h>
//#include <windowsx.h>

#include <shellapi.h>
#include <shlobj.h>

#include <objsel.h>

#include <atlbase.h>
using namespace ATL;


//////////////////////////////////////////
// macros from windowsx.h (conflict in atlwin.h)

#define GET_WM_COMMAND_ID(wp, lp)               LOWORD(wp)
#define GET_WM_COMMAND_HWND(wp, lp)             (HWND)(lp)
#define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(wp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)MAKELONG(id, cmd), (LONG)(hwnd)

#define GET_WM_VSCROLL_CODE(wp, lp)                 LOWORD(wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  HIWORD(wp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)MAKELONG(code, pos), (LONG)(hwnd)


#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif
///////////////////////////////////////////
// ASSERT's and TRACE's without debug CRT's
#if defined (DBG)
  #if !defined (_DEBUG)
    #define ASSERT
    #define TRACE

    #define _USE_DSA_TRACE
    #define _USE_DSA_ASSERT
    #define _USE_DSA_TIMER
  #else
    #ifndef ASSERT
    #define ASSERT(x) _ASSERTE(x)
    #endif

    #ifndef TRACE
    #define TRACE ATLTRACE
    #endif
  #endif
#else
    #define ASSERT
    #define TRACE
#endif

#include "dbg.h"



//////////////////////////////////////////
// Miscellanea macros
#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

//////////////////////////////////////////
// COuDelegComModule

class COuDelegComModule : public CComModule
{
public:
	COuDelegComModule()
	{
		m_cfDsObjectNames = 0;
    m_cfParentHwnd = 0;
	}
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
	BOOL InitClipboardFormats();
	UINT GetCfDsObjectNames() { return m_cfDsObjectNames;}
  UINT GetCfParentHwnd() { return m_cfParentHwnd;}
  UINT GetCfDsopSelectionList() { return m_cfDsopSelectionList;}
private:
	UINT m_cfDsObjectNames;
  UINT m_cfParentHwnd;
  UINT m_cfDsopSelectionList;
};

extern COuDelegComModule _Module;

//////////////////////////////////////////////////////////////
// further ATL and utility includes

#include <atlcom.h>
#include <atlwin.h>

#include "atldlgs.h"	// WTL sheet and ppage classes NenadS


#include <setupapi.h> // to read the .INF file

// ADS headers
#include <iads.h>
#include <activeds.h>
#include <dsclient.h>
#include <dsclintp.h>
#include <dsquery.h>
#include <dsgetdc.h>

#include <cmnquery.h>
#include <aclapi.h>
#include <aclui.h>

#include <ntdsapi.h> // DsBind/DsCrackNames
#include <lm.h>       // required for lmapibuf.h
#include <lmapibuf.h> // NetApiBufferFree

#include <propcfg.h> // from the admin\display project (clipboard format)
#include <dscmn.h>  // from the admin\display project (CrackName)

//
//strsafe apis
//
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsuiwiz.rc
//
#define IDS_BIG_BOLD_FONT_NAME          1
#define IDS_BIG_BOLD_FONT_SIZE          2
#define IDS_DELEGWIZ_WIZ_TITLE          90
#define IDS_DELEGWIZ_CONTEXT_MENU       100
#define IDS_DELEGWIZ_CONTEXT_MENU_DESCR 101
#define IDS_DELEGWIZ_BROWSE_CONTAINER_CAPTION 102
#define IDS_DELEGWIZ_BROWSE_CONTAINER_TITLE 103
#define IDS_DELEGWIZ_PRINCIPALS_SEL_TITLE 104
#define IDS_DELEGWIZ_PRINCIPALS_SEL_SUBTITLE 105
#define IDS_DELEGWIZ_OBJ_TYPE_SEL_TITLE 106
#define IDS_DELEGWIZ_OBJ_TYPE_SEL_SUBTITLE 107
#define IDS_DELEGWIZ_DELEG_RIGHTS_TITLE 108
#define IDS_DELEGWIZ_DELEG_RIGHTS_SUBTITLE 109
#define IDS_DELEGWIZ_NAME_TITLE         110
#define IDS_DELEGWIZ_NAME_SUBTITLE      111
#define IDS_DELEGWIZ_TEMPLATE_SEL_TITLE 112
#define IDS_DELEGWIZ_TEMPLATE_SEL_SUBTITLE 113
#define IDS_DELEGWIZ_READ_PROPERTY      114
#define IDS_DELEGWIZ_WRITE_PROPERTY     115
#define IDS_DELEGWIZ_CREATE_CLASS       116
#define IDS_DELEGWIZ_DELETE_CLASS       117
#define IDS_DELEGWIZ_CHILD_CLASS_FMT    118
#define IDS_DELEGWIZ_RW_PROPERTYSET     119
#define IDS_OBJ_NAME_EDIT_STATIC        120
#define IDS_DELEGWIZ_ERR_INVALID_OBJ_NAME 150
#define IDS_DELEGWIZ_ERR_INVALID_OBJ_INFO 151
#define IDS_DELEGWIZ_ERR_GET_SEC_INFO   152
#define IDS_DELEGWIZ_ERR_SET_SEC_INFO   153
#define IDS_DELEGWIZ_ERR_EDIT_SEC_INFO  154
#define IDS_DELEGWIZ_ERR_INVALID_PRINCIPAL 155
#define IDS_DELEGWIZ_ERR_PHYS_SCHEMA    156
#define IDS_DELEGWIZ_ERR_PERMISSIONS    157
#define IDS_DELEGWIZ_ERR_OBJ_PEC_PERM   158
#define IDS_DELEGWIZ_ERR_TEMPL_APPLY    159
#define IDS_DELEGWIZ_FINISH_FOLDER      180
#define IDS_DELEGWIZ_FINISH_OBJECT      181
#define IDS_DELEGWIZ_FINISH_TEMPLATE    182
#define IDS_DELEGWIZ_FINISH_PRINCIPALS  183
#define IDS_DELEGWIZ_FINISH_PERMISSIONS 184
#define IDS_DELEGWIZ_ACTRL_FULL         200
#define IDC_OBJ_NAME_EDIT               201
#define IDS_DELEGWIZ_ACTRL_SYSTEM_ACCESS 201
#define IDC_BROWSE_BUTTON               202
#define IDS_DELEGWIZ_ACTRL_DELETE       202
#define IDS_DELEGWIZ_ACTRL_READ_CONTROL 203
#define IDC_DELEGATE_ALL_RADIO          204
#define IDS_DELEGWIZ_ACTRL_CHANGE_ACCESS 204
#define IDC_DELEGATE_FOLLOWING_RADIO    205
#define IDS_DELEGWIZ_ACTRL_CHANGE_OWNER 205
#define IDC_OBJ_TYPE_LIST               206
#define IDS_DELEGWIZ_ACTRL_DS_CREATE_CHILD 206
#define IDS_DELEGWIZ_ACTRL_DS_DELETE_CHILD 207
#define IDC_SHOW_GENERAL_CHECK          208
#define IDS_DELEGWIZ_ACTRL_DS_LIST      208
#define IDC_SHOW_PROPERTY_CHECK         209
#define IDB_DELEG_HD                    209
#define IDS_DELEGWIZ_ACTRL_DS_SELF      209
#define IDC_SHOW_SUBOBJ_CHECK           210
#define IDB_DELEG_WATER                 210
#define IDS_DELEGWIZ_ACTRL_DS_READ_PROP 210
#define IDC_DELEG_RIGHTS_LIST           211
#define IDD_DELEGWIZ_PRINCIPALS_SEL     211
#define IDS_DELEGWIZ_ACTRL_DS_WRITE_PROP 211
#define IDC_SELECTED_PRINCIPALS_LIST    212
#define IDS_DELEGWIZ_ACTRL_DS_DELETE_TREE 212
#define IDC_REMOVE_BUTTON               213
#define IDS_DELEGWIZ_ACTRL_DS_LIST_OBJECT 213
#define IDC_ADD_BUTTON                  214
#define IDS_DELEGWIZ_ACTRL_DS_CONTROL_ACCESS 214
#define IDS_DELEGWIZ_ACTRL_READ         215
#define IDS_DELEGWIZ_ACTRL_WRITE        216
#define IDS_DELEGWIZ_ERR_ACCESS_DENIED  217
#define IDS_DELEGWIZ_ONE_AUX_CLASS      218
#define IDS_DISABLED_USER               219
#define IDC_STATIC_WELCOME              220
#define IDC_STATIC_COMPLETION           221
#define IDC_DELEGATE_TEMPLATE_LIST      222
#define IDC_DELEGATE_CUSTOM_RADIO       223
#define IDC_DELEGATE_TEMPLATE_RADIO     224
#define IDC_EDIT_SUMMARY                226
#define IDC_OBJ_NAME_EDIT_STATIC        227
#define IDC_OBJ_NAME_STATIC             228
#define IDC_DELEGATE_CREATE_CHILD       230
#define IDC_DELEGATE_DELETE_CHILD       231
#define IDD_DELEGWIZ_FINISH             250
#define IDD_DELEGWIZ_START              267
#define IDD_DELEGWIZ_OBJ_TYPE_SEL       268
#define IDD_DELEGWIZ_DELEG_RIGHTS       269
#define IDD_DELEGWIZ_NAME               270
#define IDD_DELEGWIZ_DELEG_TEMPLATE_SEL 271

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        212
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         232
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\tempcore.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tempcore.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"

#include <_tempcor.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\shellext.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       shellext.h
//
//--------------------------------------------------------------------------



//////////////////////////////////////////////////////////////////////
#ifndef _SHELLEXT_H
#define _SHELLEXT_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CShellExt

class CShellExt :
	public IShellExtInit,
	public IContextMenu,
	public CComObjectRoot,
	public CComCoClass<CShellExt,&CLSID_OuDelegWizExt>
{
public:
	CShellExt()
  {
    m_hParentWnd = NULL;
  }


BEGIN_COM_MAP(CShellExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IContextMenu)
END_COM_MAP()

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister);
	}


DECLARE_NOT_AGGREGATABLE(CShellExt)


// IShellExtInit methods
public:
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdtobj,
                          HKEY hkeyProgID);

// IContextMenu methods
public:
    STDMETHOD(QueryContextMenu)(HMENU hMenu, UINT indexMenu, UINT idCmdFirst,
                                UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpcmi);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uFlags, UINT FAR *reserved,
                                LPSTR pszName, UINT cchMax);

private:
  HWND m_hParentWnd;
  CWString m_szObjectLDAPPath;
};

#endif // _SHELLEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\shellext.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       shellext.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"
#include "util.h"
#include "dsuiwiz.h"
#include "shellext.h"
#include "delegwiz.h"



//#define _MMC_HACK

#ifdef _MMC_HACK

INT_PTR CALLBACK EnumThreadWndProc(HWND hwnd, /* enumerated HWND */
								   LPARAM lParam /* pass a HWND* for return value*/ )
{
	ASSERT(hwnd);
	HWND hParentWnd = GetParent(hwnd);
	// the main window of the MMC console should staitsfy this condition
	if ( ((hParentWnd == GetDesktopWindow()) || (hParentWnd == NULL))  && IsWindowVisible(hwnd) )
	{
		HWND* pH = (HWND*)lParam;
		*pH = hwnd;
		return FALSE; // stop enumerating
	}
	return TRUE;
}



HWND FindMMCMainWindow()
{
	DWORD dwThreadID = ::GetCurrentThreadId();
	ASSERT(dwThreadID != 0);
	HWND hWnd = NULL;
	BOOL bEnum = EnumThreadWindows(dwThreadID, EnumThreadWndProc,(LPARAM)&hWnd);
	ASSERT(hWnd != NULL);
	return hWnd;
}

#endif // _MMC_HACK

HWND _GetParentWindow(LPDATAOBJECT pDataObj )
{
  HWND hWnd = NULL;
	STGMEDIUM ObjMedium = {TYMED_NULL};
	FORMATETC fmte = {(CLIPFORMAT)_Module.GetCfParentHwnd(),
						NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

	if (SUCCEEDED(pDataObj->GetData(&fmte, &ObjMedium)))
	{
	  hWnd = *((HWND*)ObjMedium.hGlobal);
		::ReleaseStgMedium(&ObjMedium);
	}
#ifdef _MMC_HACK
  if (hWnd == NULL)
    hWnd = FindMMCMainWindow();
#endif
  return hWnd;
}

HRESULT _GetObjectLDAPPath(IDataObject* pDataObj, CWString& szLDAPPath)
{
  TRACE(L"entering _GetObjectLDAPPath()\n");
	if (pDataObj == NULL)
	{
		// no data object, no name
		szLDAPPath = L"";
		return E_INVALIDARG;
	}

	//crack the data object and get the name
	STGMEDIUM ObjMedium = {TYMED_NULL};
	FORMATETC fmte = {(CLIPFORMAT)_Module.GetCfDsObjectNames(),
						NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	// Get the path to the DS object from the data object.
  HRESULT hr = pDataObj->GetData(&fmte, &ObjMedium);
	if (SUCCEEDED(hr))
	{
		LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)ObjMedium.hGlobal;
		if (pDsObjectNames->cItems == 1)
		{
			LPCWSTR lpsz = (LPCWSTR)ByteOffset(pDsObjectNames,
                                 pDsObjectNames->aObjects[0].offsetName);
      if ((lpsz == NULL) || (lpsz[0] == NULL))
      {
        szLDAPPath = L"";
        hr = E_INVALIDARG;
      }
      else
      {
        szLDAPPath = lpsz;
      }
		}
    else
    {
      szLDAPPath = L"";
      hr = E_INVALIDARG;
    }
		::ReleaseStgMedium(&ObjMedium);
	}

  TRACE(L"returning from _GetObjectLDAPPath(_, %s), hr = 0x%x\n", (LPCWSTR)szLDAPPath, hr);

	return hr;
}
/////////////////////////////////////////////////////////////////////////
// IShellExtInit methods

STDMETHODIMP CShellExt::Initialize(
    LPCITEMIDLIST pidlFolder,
    LPDATAOBJECT  lpdobj,
    HKEY          hKeyProgID)
{
  if (lpdobj == NULL)
    return E_INVALIDARG;

  m_hParentWnd = _GetParentWindow(lpdobj);

  if ((m_hParentWnd == NULL) || !::IsWindow(m_hParentWnd))
    return E_INVALIDARG;

  return _GetObjectLDAPPath(lpdobj, m_szObjectLDAPPath);
}

/////////////////////////////////////////////////////////////////////////
// IContextMenu methods

STDMETHODIMP CShellExt::QueryContextMenu(
    HMENU hMenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags)
{
	// only one menu item to insert (position zero)
	TCHAR szContextMenu[128];
	LoadStringHelper(IDS_DELEGWIZ_CONTEXT_MENU, szContextMenu, ARRAYSIZE(szContextMenu));
	UINT countMenuItems = 1;
    ::InsertMenu(hMenu, indexMenu, MF_STRING | MF_BYPOSITION,
                 idCmdFirst /* + 0*/, szContextMenu);

    return MAKE_SCODE(SEVERITY_SUCCESS, 0, countMenuItems);
}



STDMETHODIMP CShellExt::GetCommandString(
    UINT_PTR idCmd,
    UINT    uFlags,
    UINT  * reserved,
    LPSTR   pszName,
    UINT    cchMax)
{
  if (uFlags != GCS_HELPTEXT) 
  {
    return S_OK;
  }

  //
  // Copy the requested string to the caller's buffer.
  //
	if (idCmd == 0) // we inserted the zero-th element
	{
    // this is really WCHAR, as Jim swears, so lets trust him...
    LPWSTR lpszHack = (LPWSTR)pszName;
    if (::LoadStringHelper(IDS_DELEGWIZ_CONTEXT_MENU_DESCR,
			  lpszHack, cchMax))
    {
      return S_OK;
    }
	}
	return E_INVALIDARG;
}





STDMETHODIMP CShellExt::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpcmi)
{
	if (lpcmi == NULL)
		return E_INVALIDARG;

    
    //Check if you have read and write permission
    if( InitCheckAccess(m_hParentWnd, m_szObjectLDAPPath) != S_OK )
    {
        return S_OK;
    }

	if (!HIWORD(lpcmi->lpVerb))
	{
		UINT iCmd = LOWORD(lpcmi->lpVerb);
		if (iCmd == 0)
		{
      ASSERT(m_hParentWnd != NULL);
			CDelegWiz delegWiz;
      delegWiz.InitFromLDAPPath(m_szObjectLDAPPath);
			delegWiz.DoModal(m_hParentWnd);
		}
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\cred.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// credentials dialog 
// 
// 03-31-98 sburns
// 10-05-00 jonn      changed to CredUIGetPassword



#ifndef CREDDLG_HPP_INCLUDED
#define CREDDLG_HPP_INCLUDED


// JonN 10/5/00 188220 use CredUIGetPassword
bool RetrieveCredentials(
   HWND             hwndParent, 
   unsigned         promptResID,
   String&          username,   
   EncryptedString& password);  


#endif   // CREDDLG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\cred.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// credentials dialog
//
// 03-31-98 sburns
// 10-05-00 jonn      changed to CredUIGetPassword
// 12-18-00 jonn      260752: changed to CredUIPromptForCredentials



#include "headers.hxx"
#include "cred.hpp"
#include "resource.h"
#include <wincred.h>  // CredUIPromptForCredentials


// JonN 10/5/00 188220
// JonN 12/18/00 260752: changed to CredUIPromptForCredentials
bool RetrieveCredentials(
   HWND             hwndParent, 
   unsigned         promptResID,
   String&          username,   
   EncryptedString& password)   
{
   ASSERT( NULL != hwndParent && 0 != promptResID );

   String strMessageText = String::load(promptResID);
   String strAppTitle = String::load(IDS_APP_TITLE);

   CREDUI_INFO uiInfo;
   ::ZeroMemory( &uiInfo, sizeof(uiInfo) );
   uiInfo.cbSize = sizeof(uiInfo);
   uiInfo.hwndParent = hwndParent;
   uiInfo.pszMessageText = strMessageText.c_str();
   uiInfo.pszCaptionText = strAppTitle.c_str();

   TCHAR achUserName[CREDUI_MAX_USERNAME_LENGTH];
   TCHAR achPassword[CREDUI_MAX_PASSWORD_LENGTH];
   ::ZeroMemory(achUserName,sizeof(achUserName));
   ::ZeroMemory(achPassword,sizeof(achPassword));

   DWORD dwErr = CredUIPromptForCredentials(
      &uiInfo,
      NULL,
      NULL,
      NO_ERROR,
      achUserName,
      CREDUI_MAX_USERNAME_LENGTH,
      achPassword,
      CREDUI_MAX_PASSWORD_LENGTH,
      NULL,
      CREDUI_FLAGS_DO_NOT_PERSIST | CREDUI_FLAGS_GENERIC_CREDENTIALS
      );
   if (NO_ERROR != dwErr) // e.g. ERROR_CANCELLED
      return false;

   username = achUserName;
   password.Encrypt(achPassword);

   // scribble out the cleartext password
   
   ::SecureZeroMemory(achPassword, sizeof(achPassword));
      
   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\wizbase.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wizbase.h
//
//--------------------------------------------------------------------------

#ifndef _WIZBASE_H
#define _WIZBASE_H

#include "util.h"

////////////////////////////////////////////////////////////////////////////
// FWD DECLARATIONS

////////////////////////////////////////////////////////////////////////////
// CWizardBase

class CWizardBase : public CPropertySheet
{
public:
	// construction/ destruction
	CWizardBase(UINT nWatermarkBitmapID, UINT nBannerBitmapID, UINT nTitleID = -1)
	{
		m_psh.hplWatermark = NULL;         
		m_psh.dwFlags |= PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
		m_psh.pszbmWatermark      = MAKEINTRESOURCE(nWatermarkBitmapID);
	    m_psh.pszbmHeader         = MAKEINTRESOURCE(nBannerBitmapID);

    m_bFwd = TRUE;
    m_nTitleID = nTitleID;
	}
	virtual ~CWizardBase(){}

	// message map
	BEGIN_MSG_MAP(CWizardBase)
      MESSAGE_HANDLER(WM_NCDESTROY, OnNcDestroy)
	END_MSG_MAP()


	// message handlers
	LRESULT OnNcDestroy(UINT uMsg, WPARAM wParam, 
						LPARAM lParam, BOOL& bHandled)
	{
		// NOTICE: important!!!. BUG workaround.
		// We have to handle this message because we use ATL 2.1
		// The DECLARE_EMPTY_MSG_MAP() macro in the new ATLWIN.H
		// works only with the modified CWindowImplBase::WindowProc()
		return DefWindowProc(uMsg, wParam, lParam);
	}

	// helpers for setting wizard buttons
	void SetWizardButtonsFirst(BOOL bValid) 
	{ 
		SetWizardButtons(bValid ? PSWIZB_NEXT : 0);
	}
	void SetWizardButtonsMiddle(BOOL bValid) 
	{ 
		SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_NEXT) : PSWIZB_BACK);
	}
	void SetWizardButtonsLast(BOOL bValid) 
	{ 
		SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_FINISH) : (PSWIZB_BACK|PSWIZB_DISABLEDFINISH));
	}

  
  // message box helpers
  int WizMessageBox(LPCTSTR lpszText, UINT nType = MB_OK)
  {
    CWString szTitle;
    szTitle.LoadFromResource(m_nTitleID);
    return MessageBox(lpszText, szTitle, nType);
  }
  int WizMessageBox(UINT nMsgID, UINT nType = MB_OK)
  {
    CWString szMsg;
    szMsg.LoadFromResource(nMsgID);
    return WizMessageBox(szMsg, nType);
  }

  // error message helpers
  void WizReportHRESULTError(LPCWSTR lpszMsg, HRESULT hr)
  {
    CWString szErrorString;
    if (GetStringFromHRESULTError(hr, szErrorString))
    {
      CWString szTemp;
      szTemp = lpszMsg;
      szTemp += L" ";
      szTemp += szErrorString;
      WizMessageBox(szTemp);
    }
    else
    {
      WizMessageBox(lpszMsg);
    }
  }
  void WizReportHRESULTError(UINT nStringID, HRESULT hr)
  {
    CWString szMsg;
    szMsg.LoadFromResource(nStringID);
    WizReportHRESULTError(szMsg, hr);
  }
  void WizReportWin32Error(LPCWSTR lpszMsg, DWORD dwErr)
  {
    CWString szErrorString;
    if (GetStringFromWin32Error(dwErr, szErrorString))
    {
      CWString szTemp;
      szTemp = lpszMsg;
      szTemp += L" ";
      szTemp += szErrorString;
      WizMessageBox(szTemp);
    }
    else
    {
      WizMessageBox(lpszMsg);
    }
  }
  void WizReportWin32Error(UINT nStringID, DWORD dwErr)
  {
    CWString szMsg;
    szMsg.LoadFromResource(nStringID);
    WizReportWin32Error(szMsg, dwErr);
  }


public:
  BOOL            m_bFwd;

private:
  UINT            m_nTitleID;
};




////////////////////////////////////////////////////////////////////////////
// CWizPageBase

template <class T>
class CWizPageBase : public CPropertyPageImpl<T>
{
public:
	CWizPageBase(CWizardBase* pWiz)
	{
		m_pWiz = pWiz;
		m_lpszHeaderTitleBuf = NULL;
		m_lpszHeaderSubTitleBuf = NULL;
    m_nPrevPageID = 0;
	}
	~CWizPageBase()
	{
		if (m_lpszHeaderTitleBuf != NULL)
			delete[] m_lpszHeaderTitleBuf;
		if (m_lpszHeaderSubTitleBuf != NULL)
			delete[] m_lpszHeaderSubTitleBuf;
	}

	CWizardBase* GetWizard() { return m_pWiz; }
	void InitWiz97(BOOL bHideHeader, UINT nTitleID=0, UINT nSubTitleID=0)
	{
		if (bHideHeader)
			m_psp.dwFlags |= PSP_HIDEHEADER;
		else
		{
			int nBufferMax = 128;
			if (nTitleID != 0)
			{
				m_lpszHeaderTitleBuf = new TCHAR[nBufferMax];
            if( m_lpszHeaderTitleBuf )
            {
				   if (LoadStringHelper(nTitleID, m_lpszHeaderTitleBuf, nBufferMax))
				   {
					   m_psp.dwFlags |= PSP_USEHEADERTITLE;
					   m_psp.pszHeaderTitle = m_lpszHeaderTitleBuf;
				   }
            }
			}
			if (nSubTitleID != 0)
			{
				m_lpszHeaderSubTitleBuf = new TCHAR[nBufferMax];
            if(m_lpszHeaderSubTitleBuf )
            {
				   LoadStringHelper(nSubTitleID, m_lpszHeaderSubTitleBuf, nBufferMax);
				   m_psp.dwFlags |= PSP_USEHEADERSUBTITLE;
				   m_psp.pszHeaderSubTitle = m_lpszHeaderSubTitleBuf;
            }
			}
		}
	}

public:
	// standard wizard message handlers
	LRESULT OnWizardBack()
  {
    m_pWiz->m_bFwd = FALSE;
    UINT nTempPrevPageID = m_nPrevPageID;
    m_nPrevPageID = 0;
    return nTempPrevPageID;
  }

	LRESULT OnWizardNext()
  {
    OnWizardNextHelper();
    return 0;
  }

  void OnWizardNextHelper()
  {
    m_pWiz->m_bFwd = TRUE;
  }


public: 
  UINT m_nPrevPageID;
  

private:
	CWizardBase*	m_pWiz;
	LPTSTR			m_lpszHeaderTitleBuf;
	LPTSTR			m_lpszHeaderSubTitleBuf;

};

#endif // _WIZBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\extens\oudeleg\util.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       util.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"

#include "resource.h"

#include "util.h"

#include "delegWiz.h"

#include <_util.cpp>

VOID DisplayMessageBox(HWND hwnd, LPWSTR lpszText)
{
    CWString szTitle;
    szTitle.LoadFromResource(IDS_DELEGWIZ_WIZ_TITLE);
    ::MessageBox(hwnd,lpszText, szTitle, MB_OK);
}


//This function checks if current user has read and write
//access to the szObjectPath. If not it shows appropriate 
//Message box.
HRESULT InitCheckAccess( HWND hwndParent, LPCWSTR pszObjectLADPPath )
{
    HRESULT hr = S_OK;
    WCHAR szSDRightsProp[]      = L"sDRightsEffective";
    LPWSTR pProp = (LPWSTR)szSDRightsProp;
    PADS_ATTR_INFO pSDRightsInfo = NULL;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD dwAttributesReturned;
    IDirectoryObject *pDsObject = NULL;
    SECURITY_INFORMATION si = 0;

    //Check Permission to "Read Permission"
    hr = ::GetSDForDsObjectPath(IN const_cast<LPWSTR>(pszObjectLADPPath),
                                NULL,
                                &pSecurityDescriptor);
  

   if(FAILED(hr))
	{
        WCHAR szMsg[512];
        LoadStringHelper(IDS_DELEGWIZ_ERR_GET_SEC_INFO, szMsg, 512);
		DisplayMessageBox(hwndParent, szMsg);
      goto exit_gracefully;
	}
    
    // Bind to the object 
    hr = ADsOpenObjectHelper(pszObjectLADPPath,
                             IID_IDirectoryObject,
                             ADS_FAST_BIND,
                             (LPVOID*)&pDsObject);
    if( hr != S_OK )
        goto exit_gracefully;

    // Read the sDRightsEffective property to determine writability
    pDsObject->GetObjectAttributes(  &pProp,
                                     1,
                                     &pSDRightsInfo,
                                     &dwAttributesReturned);
    if (pSDRightsInfo)
    {
        si = pSDRightsInfo->pADsValues->Integer;
        FreeADsMem(pSDRightsInfo);
    }
    else
    {
        //
        // Note that GetObjectAttributes commonly returns S_OK even when
        // it fails, so the HRESULT is basically useless here.
        //
        // This can fail if we don't have read_property access, which can
        // happen when an admin is trying to restore access to an object
        // that has had all access removed or denied
        //
        // Assume we can write the Owner and DACL. If not, the worst that
        // happens is the user gets an "Access Denied" message when trying
        // to save changes.
        //
        si = DACL_SECURITY_INFORMATION;
    }

    if( !(si & DACL_SECURITY_INFORMATION) )
	{
		WCHAR szMsg[512];
        LoadStringHelper(IDS_DELEGWIZ_ERR_ACCESS_DENIED, szMsg, 512);
		DisplayMessageBox(hwndParent, szMsg);
        //NTRAID#NTBUG9-530206-2002/06/18-ronmart-PREFAST: Use E_FAIL
        //hr = !S_OK;
        hr = E_FAIL;
	}


exit_gracefully:
     if( pSecurityDescriptor )
        LocalFree(pSecurityDescriptor);
    if( pDsObject )
        pDsObject->Release();
    return hr;
}


DWORD
FormatStringID(LPTSTR *ppszResult, UINT idStr , ...)
{
    va_list args;
    va_start(args, idStr);
	TCHAR szFormat[1024];
	LoadStringHelper(idStr, szFormat, ARRAYSIZE(szFormat));
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                         szFormat,
                         0,
                         0,
                         (LPTSTR)ppszResult,
                         1,
                         &args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\helpids.h ===
// Copyright (c) 1997-1999 Microsoft Corporation

#define IDH_IDENT_FULL_NAME                         5101
#define IDH_IDENT_MEMBER_OF                         5102
#define IDH_IDENT_CHANGE_BUTTON                     5103
#define IDH_IDENT_CHANGES_NEW_NAME                  5104
#define IDH_IDENT_CHANGES_PREVIEW_NAME              5105
#define IDH_IDENT_CHANGES_MORE_BUTTON               5106
#define IDH_IDENT_CHANGES_MEMBER_DOMAIN             5107
#define IDH_IDENT_CHANGES_MEMBER_DOMAIN_TEXTBOX     5108
#define IDH_IDENT_CHANGES_MEMBER_WORKGRP            5109
#define IDH_IDENT_CHANGES_MEMBER_WORKGRP_TEXTBOX    5110
#define IDH_IDENT_NAMES_DNS_NAME                    5111
#define IDH_IDENT_NAMES_CHANGE_DNS_CHECKBOX         5112
#define IDH_IDENT_NAMES_NETBIOS_NAME                5113
#define IDH_IDENT_CHANGE_ADVANCED_BUTTON            5114
#define IDH_COMPUTER_DESCRIPTION                    5115
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\iddlg.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Id changes dialog
// 
// 3-10-98 sburns



#ifndef IDDLG_HPP_INCLUDED
#define IDDLG_HPP_INCLUDED



class IDChangesDialog : public Dialog
{
   public:

   IDChangesDialog(bool isPersonal);

   virtual ~IDChangesDialog();

//    enum ExecuteResult
//    {
//       NO_CHANGES,
//       CHANGES_MADE
//    };
// 
//    // hides Dialog::ModalExecute
// 
//    ExecuteResult
//    ModalExecute(HWND parent);

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   // enum OkButtonResult
   // {
   //    VALIDATION_FAILED,
   //    CHANGES_SAVED,
   //    SAVE_FAILED
   // };

   // OkButtonResult
   bool
   OnOkButton();

   void enable(HWND hwnd);

   // no copying allowed
   IDChangesDialog(const IDChangesDialog&);
   const IDChangesDialog& operator=(const IDChangesDialog&);

   bool isInitializing;
   bool fIsPersonal;
};


void
showAndEnableWindow(HWND parent, int resID, int show);


#endif   // IDDLG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\moredlg.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// "More" dialog (spawned from IDChanges)
// 
// 3-11-98 sburns



#ifndef MOREDLG_HPP_INCLUDED
#define MOREDLG_HPP_INCLUDED



class MoreChangesDialog : public Dialog
{
   public:

   MoreChangesDialog(bool isPersonal);

   virtual ~MoreChangesDialog();

   enum ExecuteResult
   {
      NO_CHANGES,
      CHANGES_MADE
   };

   // hides Dialog::ModalExecute

   ExecuteResult
   ModalExecute(HWND parent);
   
   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   int
   OnOkButton();

   void
   enable();

   // no copying allowed
   MoreChangesDialog(const MoreChangesDialog&);
   const MoreChangesDialog& operator=(const MoreChangesDialog&);

   bool startingSyncDnsNames;
   bool fIsPersonal;
};

   

#endif   // MOREDLG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\moredlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// "More" dialog (spawned from IDChanges)
// 
// 3-11-98 sburns



#include "headers.hxx"
#include "moredlg.hpp"
#include "resource.h"
#include "helpids.h"
#include "state.hpp"
#include "iddlg.hpp"     // showAndEnableWindow



// the max length of a DNS name is 255 utf-8 bytes.  The hostname must be
// at least 1 byte.  Then there's the dot between the hostname and the
// suffix.  So 255 - 1 - 1 = 253.

// note that this is *not* Dns::MAX_NAME_LENGTH

static const int MAX_SUFFIX_LEN = DNS_MAX_NAME_LENGTH - 1 - 1;


static const DWORD HELP_MAP[] =
{
   IDC_DNS,                IDH_IDENT_NAMES_DNS_NAME,
   IDC_CHANGE,             IDH_IDENT_NAMES_CHANGE_DNS_CHECKBOX,
   IDC_NETBIOS,            IDH_IDENT_NAMES_NETBIOS_NAME,
   0, 0
};



MoreChangesDialog::MoreChangesDialog(bool isPersonal)
   :
   Dialog(IDD_MORE, HELP_MAP),
   startingSyncDnsNames(false),
   fIsPersonal(isPersonal)
{
   LOG_CTOR(MoreChangesDialog);
}



MoreChangesDialog::~MoreChangesDialog()
{
   LOG_DTOR(MoreChangesDialog);
}



void
MoreChangesDialog::enable()
{
   bool enabled = WasChanged(IDC_DNS); 

   if (WasChanged(IDC_CHANGE))
   {
      if (
            startingSyncDnsNames
         != Win::IsDlgButtonChecked(hwnd, IDC_CHANGE))
      {
         enabled = true;
      }
   }

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDOK), enabled);
}



void
MoreChangesDialog::OnInit()
{
   LOG_FUNCTION(MoreChangesDialog::OnInit);

   State& state = State::GetInstance();

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DNS),
      MAX_SUFFIX_LEN);

   Win::SetDlgItemText(
      hwnd,
      IDC_DNS,
      state.GetComputerDomainDnsName());
   Win::SetDlgItemText(hwnd, IDC_NETBIOS, state.GetNetbiosComputerName());

   startingSyncDnsNames = state.GetSyncDNSNames();
   Win::CheckDlgButton(
      hwnd,
      IDC_CHANGE,
      startingSyncDnsNames ? BST_CHECKED : BST_UNCHECKED);
   if (fIsPersonal) // JonN 10/4/00
      showAndEnableWindow( hwnd, IDC_CHANGE, SW_HIDE );

   ClearChanges();
   enable();
}



MoreChangesDialog::ExecuteResult
MoreChangesDialog::ModalExecute(HWND parent)
{
   if (Dialog::ModalExecute(parent))
   {
      return CHANGES_MADE;
   }

   return NO_CHANGES;
}



// returns
// -1 if a validation error has occurred
// 1 if a change was made
// 0 if no change was made

int
MoreChangesDialog::OnOkButton()
{
   int endCode = 0;
   State& state = State::GetInstance();

   String preconditionErrorMessage = CheckPreconditions();
   if (!preconditionErrorMessage.empty())
   {
      popup.Error(
         hwnd,
         preconditionErrorMessage);
      return -1;
   }

   if (WasChanged(IDC_CHANGE))
   {
      state.SetSyncDNSNames(
         Win::IsDlgButtonChecked(hwnd, IDC_CHANGE));
      endCode = 1;
   }
      
   if (WasChanged(IDC_DNS))
   {
      // compare the new value to the old one.  If they're different,
      // validate and save the new value

      String newDomain = Win::GetTrimmedDlgItemText(hwnd, IDC_DNS);

      if (newDomain.empty())
      {
         state.SetComputerDomainDnsName(newDomain);
         return 1;
      }

      String oldDomain = state.GetComputerDomainDnsName();

      if (newDomain.icompare(oldDomain) != 0)
      {
         switch (
            Dns::ValidateDnsNameSyntax(
               newDomain,
               MAX_SUFFIX_LEN,
               MAX_SUFFIX_LEN))
         {
            case Dns::NON_RFC:
            {
               Win::MessageBox(
                  hwnd,
                  String::format(IDS_NON_RFC_NAME, newDomain.c_str()),
                  String::load(IDS_APP_TITLE),
                  MB_OK | MB_ICONWARNING);

               //lint -e(616) fall-thru
            }
            case Dns::VALID:
            {
               state.SetComputerDomainDnsName(newDomain);
               endCode = 1;
               break;
            }
            case Dns::TOO_LONG:
            {
               endCode = -1;               
               popup.Gripe(
                  hwnd,
                  IDC_DNS,
                  String::format(
                     IDS_DNS_NAME_TOO_LONG,
                     newDomain.c_str(),
                     MAX_SUFFIX_LEN));
               break;
            }
            case Dns::NUMERIC:
            {
               endCode = -1;
               popup.Gripe(
                  hwnd,
                  IDC_DNS,
                  String::format(IDS_NUMERIC_DNS_NAME, newDomain.c_str()));
               break;
            }
            case Dns::BAD_CHARS:
            {
               endCode = -1;
               popup.Gripe(
                  hwnd,
                  IDC_DNS,
                  String::format(IDS_BAD_DNS_CHARS, newDomain.c_str()));
               break;
            }
            case Dns::INVALID:
            default:
            {
               endCode = -1;
               popup.Gripe(
                  hwnd,
                  IDC_DNS,
                  String::format(
                     IDS_BAD_DNS_SYNTAX,
                     newDomain.c_str(),
                     Dns::MAX_LABEL_LENGTH));
               break;
            }
         }
      }
   }

   return endCode;
}



bool
MoreChangesDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
   switch (controlIDFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            int endCode = OnOkButton();
            if (endCode != -1)
            {
               HRESULT unused = Win::EndDialog(hwnd, endCode);

               ASSERT(SUCCEEDED(unused));
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            // 0 => no changes made

            HRESULT unused = Win::EndDialog(hwnd, 0);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
      case IDC_CHANGE:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            enable();
         }
         break;
      }
      case IDC_DNS:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            enable();
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\dllmain.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// netid entry points
// 
// 3-2-98 sburns



#include "headers.hxx"
#include "idpage.hpp"
#include "resource.h"
#include <DiagnoseDcNotFound.hpp>
#include <DiagnoseDcNotFound.h>


HINSTANCE hResourceModuleHandle = 0;
HINSTANCE hDLLModuleHandle = 0;
const wchar_t* HELPFILE_NAME = L"\\help\\sysdm.hlp";
const wchar_t* RUNTIME_NAME = L"netid";

// default: no debugging

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_MUTE;



Popup popup(IDS_APP_TITLE);



BOOL
APIENTRY
DllMain(
   HINSTANCE   hInstance,
   DWORD       dwReason,
   PVOID       /* lpReserved */ )
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
      {
         hResourceModuleHandle = hInstance;
         hDLLModuleHandle = hInstance;

         LOG(L"DLL_PROCESS_ATTACH");

         break;
      }
      case DLL_PROCESS_DETACH:
      {
         LOG(L"DLL_PROCESS_DETACH");       

         break;
      }
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
      default:
      {
         break;
      }
   }

   return TRUE;
}



HPROPSHEETPAGE
CreateNetIDPropertyPage()
{
   LOG_FUNCTION(CreateNetIDPropertyPage);

   // CODEWORK: pass this along to the rest of the UI

   Computer c;
   HRESULT hr = c.Refresh();

   // This should always succeed, but if not, the object falls back to as
   // reasonable a default as can be expected.

   ASSERT(SUCCEEDED(hr));

   bool isWorkstation = false;
   switch (c.GetRole())
   {
      case Computer::STANDALONE_WORKSTATION:
      case Computer::MEMBER_WORKSTATION:
      {
         isWorkstation = true;
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   // JonN 10/4/00 Determine whether this is Whistler Personal
   bool isPersonal = false;
   OSVERSIONINFOEX osvi;
   ::ZeroMemory( &osvi, sizeof(osvi) );
   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
   if (GetVersionEx( (LPOSVERSIONINFO)&osvi ))
       isPersonal = !!(osvi.wSuiteMask & VER_SUITE_PERSONAL);

   // this is deleted by the proppage callback function
   return (new NetIDPage(isWorkstation,isPersonal))->Create();
}



// this exported function is also used by the net access wizard.
//
// Bring up a modal error message dialog that shows the user an error message
// and offers to run some diagnostic tests and point the user at some help to
// try to resolve the problem.
// 
// parent - in, the handle to the parent of this dialog.
// 
// domainName - in, the name of the domain for which a domain controller can't
// be located.  If this parameter is null or the empty string, then the
// function does nothing.
//
// dialogTitle - in, title string for the dialog

void
ShowDcNotFoundErrorDialog(
   HWND     parent,
   PCWSTR   domainName,
   PCWSTR   dialogTitle)
{
   LOG_FUNCTION(ShowDcNotFoundErrorDialog);
   ASSERT(Win::IsWindow(parent));
   ASSERT(domainName && domainName[0]);
   
   if (domainName && domainName[0])
   {
      ShowDcNotFoundErrorDialog(
         parent,
         -1,
         domainName,
         dialogTitle,
         String::format(IDS_GENERIC_DC_NOT_FOUND_PARAM, domainName),
         false);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\idpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// netid prop page
// 
// 3-10-98 sburns



#include "headers.hxx"
#include "idpage.hpp"
#include "resource.h"
#include "helpids.h"
#include "iddlg.hpp"
#include "state.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_IDENTIFICATION_TEXT,   NO_HELP,                         
   IDC_DESCRIPTION_EDIT,      IDH_COMPUTER_DESCRIPTION,
   IDC_FULL_NAME,             IDH_IDENT_FULL_NAME,
   IDC_FULL_NAME_STATIC,      IDH_IDENT_FULL_NAME,
   IDC_DOMAIN,                IDH_IDENT_MEMBER_OF,             
   IDC_ACCOUNT_WIZARD_BUTTON, IDH_IDENT_CHANGE_BUTTON,         
   IDC_CHANGE,                IDH_IDENT_CHANGE_ADVANCED_BUTTON,
   IDC_MEMBER_OF,             IDH_IDENT_MEMBER_OF,             
   IDC_COMPUTER_ICON,         NO_HELP,                         
   IDC_MESSAGE,               NO_HELP,
   IDC_WARNING_ICON,          NO_HELP,
   IDC_CLICK_MESSAGE1,        NO_HELP,
   IDC_CLICK_MESSAGE2,        NO_HELP,
   IDC_REBOOT_MESSAGE,        NO_HELP,
   IDC_STATIC_HELPLESS,       NO_HELP,
   0, 0                              
};



NetIDPage::NetIDPage(bool isWorkstation, bool isPersonal)
   :
   PropertyPage(isWorkstation ? (isPersonal ? IDD_NETID_PER : IDD_NETID)
                              : IDD_NETID_SRV,
                HELP_MAP),
   certsvc(L"CertSvc"),
   warnIcon(0),
   fIsPersonal(isPersonal)
{
   LOG_CTOR(NetIDPage);
}



NetIDPage::~NetIDPage()
{
   LOG_DTOR(NetIDPage);

   State::Delete();

   if (warnIcon)
   {
      Win::DestroyIcon(warnIcon);
   }
}



void
appendMessage(String& message, const String& additionalText)
{
   LOG_FUNCTION2(appendMessage, message + L"  " + additionalText);
   ASSERT(!additionalText.empty());

   if (message.empty())
   {
      // add intro first
      message = String::load(IDS_CANT_TWEAK_ID);
   }

   // then bullet items next
   message.append(L"\r\n" + additionalText);
}
      


// return false if the machine is undergoing a role change, or needs to
// be rebooted from a role change (i.e. dcpromo), true otherwise.
// If false, appends which condition to the provided string. 

bool
EvaluateRoleChangeState(String& message)
{
   LOG_FUNCTION(EvaluateRoleChangeState);

   bool result = true;

   switch (GetDsRoleChangeState())
   {
      case ::DsRoleOperationIdle:
      {
         // do nothing
         break;
      }
      case ::DsRoleOperationActive:
      {
         // a role change operation is underway
         result = false;
         appendMessage(message, String::load(IDS_ROLE_CHANGE_IN_PROGRESS));
         break;
      }
      case ::DsRoleOperationNeedReboot:
      {
         // a role change has already taken place, need to reboot before
         // attempting another.
         result = false;
         appendMessage(message, String::load(IDS_ROLE_CHANGE_NEEDS_REBOOT));
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return result;
}



// Returns true if the change and advanced buttons should be enabled, false if
// not.  As an added bonus, also composes the text to appear on the page
// indicating why the buttons are not enabled, and whether the values reflect
// current machine names or a reboot is required.  289623

bool
NetIDPage::evaluateButtonEnablingAndComposeMessageText(String& message)
{
   LOG_FUNCTION(NetIDPage::evaluateButtonEnablingAndComposeMessageText);

   State& state = State::GetInstance();

   bool result = true;

   do
   {
      if (!IsCurrentUserAdministrator())
      {
         // must be an administrator
         result = false;
         message = String::load(IDS_MUST_BE_ADMIN);

         // go no further -- more messages would reveal too much about this
         // machine to a non-admin.
         break;
      }

      // 236596: allow rename on DC's, now.
      // // if (state.IsMachineDc())
      // // {
      // //    // sorry- DCs can't be renamed
      // //    result = false;
      // //    appendMessage(message, String::load(IDS_CANT_RENAME_DC));
      // // }

      if (IsDcpromoRunning())
      {
         result = false;
         appendMessage(message, String::load(IDS_MUST_EXIT_DCPROMO));
      }
      else
      {
         // this test is redundant if dcpromo is running, so only perform
         // it when dcpromo is not running.

         if (IsUpgradingDc())
         {
            // must complete dcpromo, first.
            result = false;
            appendMessage(message, String::load(IDS_MUST_COMPLETE_DCPROMO));
         }
      }

      if (certsvc.IsInstalled())
      {
         // sorry- renaming cert issuers invalidates their certs.
         result = false;
         appendMessage(message, String::load(IDS_CANT_RENAME_CERT_SVC));
      }

      if (!state.IsNetworkingInstalled() && !state.IsMemberOfWorkgroup())
      {
         // domain members need to be able to reach a dc
         result = false;
         appendMessage(message, String::load(IDS_NETWORKING_NEEDED));
      }

      // 362770
      if (!EvaluateRoleChangeState(message))
      {
         // dcpromo is running or was just run
         result = false;

         // the message has been updated for us by EvaluateRoleChangeState
      }
   }
   while (0);

   // show the message whether changes requiring a reboot have been made
   // during this session or any other session (or even if the computer
   // name has been changed by some other entity than ourselves)

   bool show = (state.NeedsReboot() || state.ChangesMadeThisSession());
   Win::ShowWindow(
      Win::GetDlgItem(hwnd, IDC_REBOOT_MESSAGE),
      show ? SW_SHOW : SW_HIDE);
   Win::ShowWindow(
      Win::GetDlgItem(hwnd, IDC_WARNING_ICON),
      show ? SW_SHOW : SW_HIDE);

   return result;
}



void
NetIDPage::refresh()
{
   LOG_FUNCTION(NetIDPage::refresh);

   State& state = State::GetInstance();
   Win::SetDlgItemText(hwnd, IDC_FULL_NAME, state.GetFullComputerName());
   Win::SetDlgItemText(hwnd, IDC_DOMAIN, state.GetDomainName());
   Win::SetDlgItemText(
      hwnd,
      IDC_MEMBER_OF,
      String::load(
            state.IsMemberOfWorkgroup()
         ?  IDS_MEMBER_OF_WORKGROUP
         :  IDS_MEMBER_OF_DOMAIN));

   String message;
   bool enableButtons =
      evaluateButtonEnablingAndComposeMessageText(message);
   bool networkingInstalled = state.IsNetworkingInstalled();

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_CHANGE), enableButtons);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_ACCOUNT_WIZARD_BUTTON),
      enableButtons && networkingInstalled && !fIsPersonal );
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_CLICK_MESSAGE1),
      enableButtons && networkingInstalled && !fIsPersonal );
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_CLICK_MESSAGE2),
      enableButtons);

   Win::SetDlgItemText(hwnd, IDC_MESSAGE, message);

   if (!networkingInstalled)
   {
      // if networking is not installed, then domain join is not an option,
      // so replace the button text to only mention rename.  371999
      Win::SetWindowText(
         Win::GetDlgItem(hwnd, IDC_CLICK_MESSAGE2),
         String::load(IDS_RENAME_PROMPT));
   }
}



void
NetIDPage::OnInit()
{
   LOG_FUNCTION(NetIDPage::OnInit);

   State::Init();

   // JonN 10/24/00 Computer Description
   // CODEWORK It would probably be cleaner to roll the
   // computer description into ComputerState
   SERVER_INFO_101* psi101 = NULL;
   DWORD dwErr = ::NetServerGetInfo( NULL, 101, (LPBYTE*)&psi101 );
   if (0 == dwErr && NULL != psi101)
   {
      if (NULL != psi101->sv101_comment)
      {
         Win::SetDlgItemText(hwnd,
                             IDC_DESCRIPTION_EDIT,
                             psi101->sv101_comment);
         Win::PropSheet_Unchanged(Win::GetParent(hwnd), hwnd);
         ClearChanges(); // clear IDC_DESCRIPTION_EDIT flag
      }
      (void) ::NetApiBufferFree( psi101 );
   }
   else
   { 
      // If we failed to read the comment, disable this field
      Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_DESCRIPTION_EDIT), false);
   }

   // JonN 2/20/01 322286
   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DESCRIPTION_EDIT),
      MAXCOMMENTSZ);

   refresh();

   // destroyed in the dtor

   HRESULT hr = Win::LoadImage(IDI_WARN, warnIcon);

   if (SUCCEEDED(hr))
   {
      Win::SendMessage(
         Win::GetDlgItem(hwnd, IDC_WARNING_ICON),
         STM_SETICON,
         reinterpret_cast<WPARAM>(warnIcon),
         0);
   }
}



bool
NetIDPage::OnSetActive()
{
   LOG_FUNCTION(NetIDPage::OnSetActive);

   refresh();

   return true;
}



bool
NetIDPage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
   switch (controlIDFrom)
   {
      case IDC_CHANGE:
      {
         if (code == BN_CLICKED)
         {
            // JonN 4/20/01 
            // Computer Name: warn users to "prepare" computer rename
            //   prior to DC computer rename
            if (State::GetInstance().IsMachineDc())
            {
               if (
                  popup.MessageBox(
                     hwnd,
                     IDS_RENAME_DC_WARNING,
                     MB_ICONWARNING | MB_OKCANCEL | MB_DEFBUTTON2) != IDOK)
               {
                  break;
               }
            }

            IDChangesDialog dlg(fIsPersonal);
            dlg.ModalExecute(hwnd);
            if (State::GetInstance().ChangesMadeThisSession())
            {
               Win::PropSheet_RebootSystem(Win::GetParent(hwnd));
            }
            State::Refresh();
            refresh();

            // JonN 4/24/01 280197
            // wrong button has focus after joining or changing the Domain name
            Win::SetFocus(Win::GetDlgItem(hwnd, IDC_CHANGE));

         }
         break;
      }
      case IDC_ACCOUNT_WIZARD_BUTTON:
      {
         if (code == BN_CLICKED)
         {
            HINSTANCE hNetWiz = LoadLibrary(c_szWizardFilename);
            HRESULT (*pfnNetConnectWizard)(HWND, ULONG, BOOL *);
            BOOL fReboot = FALSE;

            if (hNetWiz) {
                pfnNetConnectWizard = (HRESULT (*)(HWND, ULONG, BOOL *)) GetProcAddress(
                    hNetWiz,
                    "NetAccessWizard"
                );
                
                if (pfnNetConnectWizard) {
                    pfnNetConnectWizard(windowFrom, 0, &fReboot);

                    if (fReboot) {
                        popup.Info(hwnd, IDS_MUST_REBOOT);
                        State::GetInstance().SetChangesMadeThisSession(true);      
                        Win::PropSheet_RebootSystem(Win::GetParent(hwnd));
                    } // if (fReboot)

                    State::Refresh();
                    refresh();

                } // if (pfnNetConnectWizard)

                FreeLibrary(hNetWiz);

            } // if (hNetWiz)
         } 
         break;
      }
      case IDC_DESCRIPTION_EDIT:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(IDC_DESCRIPTION_EDIT);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}
   


bool
NetIDPage::OnMessage(
   UINT     message,
   WPARAM   /* wparam */ ,
   LPARAM   /* lparam */ )
{
   bool result = false;

   switch (message)
   {
      case WM_ACTIVATE:
      {
         refresh();
         result = true;
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return result;
}

bool
NetIDPage::OnApply(bool isClosing )
{
   LOG_FUNCTION2(
      NetIDPage::OnApply,
      isClosing ? L"closing" : L"not closing");

   // JonN 10/24/00 Computer Description
   // CODEWORK It would probably be cleaner to roll the
   // computer description into ComputerState

   if (!WasChanged(IDC_DESCRIPTION_EDIT))
      return true;

   // If we got here, Win::PropSheet_Changed() must have been called
   // in OnCommand().

   String strDescription = Win::GetTrimmedDlgItemText(
         hwnd, IDC_DESCRIPTION_EDIT);
   SERVER_INFO_101 si101;
   ::ZeroMemory( &si101, sizeof(si101) );
   si101.sv101_comment = (LMSTR)strDescription.c_str();
   DWORD parmerror = 0;
   DWORD dwErr = ::NetServerSetInfo(
         NULL, 101, (LPBYTE)&si101, &parmerror );
   if (0 != dwErr)
   {
      popup.Gripe(
         hwnd,
         IDC_DESCRIPTION_EDIT,
         Win32ToHresult(dwErr),
         String::format(IDS_CHANGE_DESCRIPTION_FAILED));
      // don't dismiss the property page
      Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
      return true;
   }
   else
   {
         Win::PropSheet_Unchanged(Win::GetParent(hwnd), hwnd);
         ClearChanges(); // clear IDC_DESCRIPTION_EDIT flag
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\iddlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Id changes dialog
// 
// 3-10-98 sburns



#include "headers.hxx"
#include "iddlg.hpp"
#include "moredlg.hpp"
#include "resource.h"
#include "helpids.h"
#include "state.hpp"
#include <DiagnoseDcNotFound.hpp>
#include <DiagnoseDcNotFound.h>



static const DWORD HELP_MAP[] =
{
   IDC_MESSAGE,            NO_HELP,
   IDC_FULL_NAME,          IDH_IDENT_CHANGES_PREVIEW_NAME,
   IDC_FULL_LABEL,         IDH_IDENT_CHANGES_PREVIEW_NAME,
   IDC_NEW_NAME,           IDH_IDENT_CHANGES_NEW_NAME,
   IDC_MORE,               IDH_IDENT_CHANGES_MORE_BUTTON,
   IDC_DOMAIN_BUTTON,      IDH_IDENT_CHANGES_MEMBER_DOMAIN,
   IDC_WORKGROUP_BUTTON,   IDH_IDENT_CHANGES_MEMBER_WORKGRP,
   IDC_DOMAIN,             IDH_IDENT_CHANGES_MEMBER_DOMAIN_TEXTBOX,
   IDC_WORKGROUP,          IDH_IDENT_CHANGES_MEMBER_WORKGRP_TEXTBOX,
   IDC_FIND,               NO_HELP,
   IDC_GROUP,              NO_HELP,
   0, 0
};



IDChangesDialog::IDChangesDialog(bool isPersonal)
   :
   Dialog((isPersonal) ? IDD_CHANGES_PER : IDD_CHANGES, HELP_MAP),
   isInitializing(false),
   fIsPersonal(isPersonal)
{
   LOG_CTOR(IDChangesDialog);
}



IDChangesDialog::~IDChangesDialog()
{
   LOG_DTOR(IDChangesDialog);
}



void
IDChangesDialog::enable(HWND hwnd)
{
   State& state = State::GetInstance();
   bool networkingInstalled = state.IsNetworkingInstalled();
   bool isDc = state.IsMachineDc();
   bool workgroup = Win::IsDlgButtonChecked(hwnd, IDC_WORKGROUP_BUTTON);
   // Note that this can be called via EN_CHANGE before OnInit, so that
   // the workgroup checkbox may not have been properly enabled.

   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      !workgroup && networkingInstalled && !isDc);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_FIND),
      !workgroup && networkingInstalled && !isDc);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_WORKGROUP),
      workgroup && networkingInstalled && !isDc);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_WORKGROUP_BUTTON),
      networkingInstalled && !isDc);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_DOMAIN_BUTTON),
      networkingInstalled && !isDc);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_GROUP),
      networkingInstalled && !isDc);

   bool b = false;
   if (workgroup)
   {
      b = !Win::GetTrimmedDlgItemText(hwnd, IDC_WORKGROUP).empty();
   }
   else
   {
      b = !Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN).empty();
   }

   bool enabled =
         state.ChangesNeedSaving()
      && b
      && !Win::GetTrimmedDlgItemText(hwnd, IDC_NEW_NAME).empty();
   
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDOK), enabled);
}



void
showAndEnableWindow(HWND parent, int resID, int show)
{
   ASSERT(Win::IsWindow(parent));
   ASSERT(resID > 0);
   ASSERT(show == SW_SHOW || show == SW_HIDE);

   HWND window = Win::GetDlgItem(parent, resID);
   Win::ShowWindow(window, show);
   Win::EnableWindow(window, show == SW_SHOW ? true : false);
}



void
SetUppercaseStyle(HWND edit)
{
   LOG_FUNCTION(SetUppercaseStyle);
   ASSERT(Win::IsWindow(edit));

   LONG style = 0;
   HRESULT hr = Win::GetWindowLong(edit, GWL_STYLE, style);
   ASSERT(SUCCEEDED(hr));

   style |= ES_UPPERCASE;
   hr = Win::SetWindowLong(edit, GWL_STYLE, style);
   ASSERT(SUCCEEDED(hr));
}



void
IDChangesDialog::OnInit()
{
   LOG_FUNCTION(IDChangesDialog::OnInit);

   isInitializing = true;

   State& state = State::GetInstance();
   Win::SetDlgItemText(hwnd, IDC_FULL_NAME, state.GetFullComputerName());
   Win::SetDlgItemText(hwnd, IDC_NEW_NAME, state.GetShortComputerName());

   bool joinedToWorkgroup = state.IsMemberOfWorkgroup();
   ASSERT( joinedToWorkgroup || !fIsPersonal );
   Win::CheckDlgButton(
      hwnd,
      IDC_WORKGROUP_BUTTON,
      joinedToWorkgroup ? BST_CHECKED : BST_UNCHECKED);
   Win::CheckDlgButton(
      hwnd,
      IDC_DOMAIN_BUTTON,
      joinedToWorkgroup ? BST_UNCHECKED : BST_CHECKED);
   Win::SetDlgItemText(
      hwnd,
      joinedToWorkgroup ? IDC_WORKGROUP : IDC_DOMAIN,
      state.GetDomainName());

   bool networkingInstalled = state.IsNetworkingInstalled();
   bool tcpInstalled = networkingInstalled && IsTcpIpInstalled();

   int show = tcpInstalled ? SW_SHOW : SW_HIDE;
   showAndEnableWindow(hwnd, IDC_FULL_LABEL, show);
   showAndEnableWindow(hwnd, IDC_FULL_NAME,  show);
   showAndEnableWindow(hwnd, IDC_MORE,       show);

   HWND newNameEdit    = Win::GetDlgItem(hwnd, IDC_NEW_NAME);
   HWND domainNameEdit = Win::GetDlgItem(hwnd, IDC_DOMAIN);  

   Win::Edit_LimitText(
      domainNameEdit,
      tcpInstalled ? Dns::MAX_NAME_LENGTH : DNLEN);
   Win::Edit_LimitText(
      newNameEdit, 
      tcpInstalled ? Dns::MAX_LABEL_LENGTH : MAX_COMPUTERNAME_LENGTH);

   if (!tcpInstalled)
   {
      // Without tcp/ip, new name and domain need to look like netbios, so set
      // the uppercase style on those boxen.

      SetUppercaseStyle(newNameEdit);
      SetUppercaseStyle(domainNameEdit);
   }

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_WORKGROUP), DNLEN);

   // no networking at all further restricts the UI to just NetBIOS-like
   // computer name changes.

   if (!networkingInstalled)
   {
      // enable() will handle disabling the inapplicable ui

      Win::SetWindowText(
         Win::GetDlgItem(hwnd, IDC_MESSAGE),
         String::load(IDS_NAME_MESSAGE));
   }
   else
   {
      Win::SetWindowText(
         Win::GetDlgItem(hwnd, IDC_MESSAGE),
         String::load(IDS_NAME_AND_MEMBERSHIP_MESSAGE));
   }
                  
   ClearChanges();
   enable(hwnd);

   isInitializing = false;
}



bool
ValidateNetbiosAndFullNames(HWND dialog, const String& shortName)
{
   LOG_FUNCTION(ValidateNetbiosAndFullNames);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(!shortName.empty());

   HRESULT err = S_OK;
   String flatname = Dns::HostnameToNetbiosName(shortName, &err);
   if (flatname.empty() || FAILED(err))
   {
      // the flatname conversion failed.  
      popup.Gripe(
         dialog,
         IDC_NEW_NAME,
         err,
         String::format(
            IDS_CONVERSION_TO_NETBIOS_NAME_FAILED,
            shortName.c_str()));
      return false;
   }

   if (flatname.is_numeric())
   {
      // the truncated version may be a number. If we catch this here, it is
      // because the name was truncated.. This is because the hostname is
      // checked against being a number in ValidateComputerNames.  401076

      ASSERT(shortName.length() > flatname.length());

      popup.Gripe(
         dialog,
         IDC_NEW_NAME,
         String::format(
            IDS_NETBIOS_NAME_NUMERIC,
            flatname.c_str(),
            CNLEN));
      return false;
   }

   if (shortName.length() > flatname.length())
   {
      // warn that the netbios name will be truncated.
      popup.Info(
         dialog,
         String::format(
            IDS_NAME_TRUNCATED,
            CNLEN,
            flatname.c_str()));
   }

   // here the flatname is of the proper length in bytes (because the
   // hostname-to-flatname API guarantees that), is not a number, so the only
   // other possible syntax problem would be illegal characters.

   if (ValidateNetbiosComputerName(flatname) != VALID_NAME)
   {
      popup.Gripe(
         dialog,
         IDC_NEW_NAME,
         String::format(
            IDS_BAD_NETBIOS_CHARACTERS,
            flatname.c_str()));
      return false;
   }

   State& state = State::GetInstance();
   if (!state.IsNetworkingInstalled())
   {
      // We can't validate these names further without networking, so they
      // pass      
      return true;
   }

   if (state.WasNetbiosComputerNameChanged())
   {
      HRESULT hr = MyNetValidateName(flatname, NetSetupMachine);
      if (FAILED(hr))
      {
         // the netbios name is in use
         popup.Gripe(
            dialog,
            IDC_NEW_NAME,
            hr,
            String::format(IDS_VALIDATE_NAME_FAILED, flatname.c_str()));
         return false;
      }
   }

   // here, the netbios name has not changed with the new short name, or is
   // ok.

   if (!IsTcpIpInstalled())
   {
      // We can't validate the full DNS name of the computer without TCP/IP
      // so the name passes.
      return true;
   }

   HRESULT hr =
      MyNetValidateName(state.GetFullComputerName(), NetSetupDnsMachine);

   if (FAILED(hr) and hr != Win32ToHresult(DNS_ERROR_NON_RFC_NAME))
   {
      // the full dns name is in use
      popup.Gripe(
         dialog,
         IDC_NEW_NAME,
         hr,
         String::format(
            IDS_VALIDATE_NAME_FAILED,
            state.GetFullComputerName().c_str()));
      return false;
   }

   return true;
}



// validates the short name, the full name, and the netbios names, raising
// UI to complain on failures, returns false if any name fails, true if all
// names pass.
//
// this is also good for the tcp/ip not installed case, as the edit control
// limits the text length, and we decided not to allow '.' in netbios names
// any longer

bool
ValidateComputerNames(HWND dialog)
{
   LOG_FUNCTION(ValidateComputerNames);
   ASSERT(Win::IsWindow(dialog));

   State& state = State::GetInstance();
   if (!state.WasShortComputerNameChanged())
   {
      return true;
   }

   String shortName = state.GetShortComputerName();

   String message;
   switch (Dns::ValidateDnsLabelSyntax(shortName))
   {
      case Dns::VALID:
      {
         return ValidateNetbiosAndFullNames(dialog, shortName);
      }
      case Dns::TOO_LONG:
      {
         message =
            String::format(
               IDS_COMPUTER_NAME_TOO_LONG,
               shortName.c_str(),
               Dns::MAX_LABEL_LENGTH);
         break;
      }
      case Dns::NON_RFC:
      {
         message =
            String::format(
               IDS_NON_RFC_COMPUTER_NAME_SYNTAX,
               shortName.c_str());
         if (
            popup.MessageBox(
               dialog,
               message,
               MB_ICONWARNING | MB_YESNO) == IDYES)
         {
            return ValidateNetbiosAndFullNames(dialog, shortName);
         }

         HWND edit = Win::GetDlgItem(dialog, IDC_NEW_NAME);
         Win::SendMessage(edit, EM_SETSEL, 0, -1);
         Win::SetFocus(edit);
         return false;
      }
      case Dns::NUMERIC:
      {
         message =
            String::format(IDS_COMPUTER_NAME_NUMERIC, shortName.c_str());
         break;
      }
      case Dns::BAD_CHARS:
      {
         message =
            String::format(
               IDS_COMPUTER_NAME_HAS_BAD_CHARS,
               shortName.c_str());
         break;
      }
      case Dns::INVALID:
      {
         message =
            String::format(
               IDS_BAD_COMPUTER_NAME_SYNTAX,
               shortName.c_str());
         break;
      }
      default:
      {
         ASSERT(false);
         message =
            String::format(IDS_BAD_COMPUTER_NAME_SYNTAX, shortName.c_str());
         break;
      }
   }

   popup.Gripe(dialog, IDC_NEW_NAME, message);

   return false;
}



bool
WorkgroupNameTooLong(const String& name)
{
   LOG_FUNCTION2(WorkgroupNameTooLong, name);
   ASSERT(!name.empty());

   bool result = false;
   do
   {
      // first- cheap length test.  Since a character will never be smaller
      // than 1 byte, if the number of characters exceeds the number of
      // bytes, we know it will never fit.

      if (name.length() > DNLEN)
      {
         result = true;
         break;
      }

      // second- check length of against corresponding UTF8 string
      // utf8bytes is the number of bytes (not characters) required to hold
      // the string in the UTF-8 character set.

      size_t oemBytes = 
         static_cast<size_t>(

            // ISSUE-2002/03/26-sburns should use Win:: wrapper

            ::WideCharToMultiByte(
               CP_OEMCP,
               0,
               name.c_str(),
               static_cast<int>(name.length()),
               0,
               0,
               0,
               0));

      LOG(String::format(L"name is %1!d! oem bytes", oemBytes));

      if (oemBytes > DNLEN)
      {
         LOG(L"oem length too long");

         result = true;
         break;
      }
   }
   while (0);

   LOG(String::format(L"name %1 too long", result ? L"is" : L"is NOT" ));

   return result;
}



bool
ValidateDomainOrWorkgroupName(HWND dialog)
{
   LOG_FUNCTION(ValidateDomainOrWorkgroupName);
   ASSERT(Win::IsWindow(dialog));

   if (!State::GetInstance().WasMembershipChanged())
   {
      return true;
   }

   HRESULT hr = S_OK;
   int     nameId = 0;   
   String  name;

   if (Win::IsDlgButtonChecked(dialog, IDC_DOMAIN_BUTTON))
   {
      nameId = IDC_DOMAIN;
      name = Win::GetTrimmedDlgItemText(dialog, nameId);
      hr = MyNetValidateName(name, NetSetupDomain);

      if (hr == Win32ToHresult(DNS_ERROR_NON_RFC_NAME))
      {
         // accept non-rfc dns names.  We have to check for the reachability
         // of the domain because NetValidateName will not bother to check
         // reachability for non-rfc names.

         hr = S_OK;
         if (!IsDomainReachable(name))
         {
            hr = Win32ToHresult(ERROR_NO_SUCH_DOMAIN);
         }
      }

      if (hr == Win32ToHresult(ERROR_NO_SUCH_DOMAIN))
      {
         // domain not found.  Call the diagnostic error message dialog.

         ShowDcNotFoundErrorDialog(
            dialog,
            nameId,
            name,
            String::load(IDS_APP_TITLE),
            String::format(IDS_GENERIC_DC_NOT_FOUND_PARAM, name.c_str()),
            false,
            false);
            
         return false;
      }
   }
   else
   {
      nameId = IDC_WORKGROUP;
      name = Win::GetTrimmedDlgItemText(dialog, nameId);

      // we do our own length checking, as the NetValidateName API
      // does not return a distinct error code for length problems. 26968

      if (WorkgroupNameTooLong(name))
      {
         popup.Gripe(
            dialog,
            nameId,
            String::format(
               IDS_WORKGROUP_NAME_TOO_LONG,
               name.c_str(),
               DNLEN));
         return false;
      }

      hr = MyNetValidateName(name, NetSetupWorkgroup);
   }

   if (FAILED(hr))
   {
      popup.Gripe(
         dialog,
         nameId,
         hr,
         String::format(IDS_VALIDATE_NAME_FAILED, name.c_str()));
      return false;
   }

   return true;
}
      


bool
IDChangesDialog::OnOkButton()
{
   State& state = State::GetInstance();
   ASSERT(state.ChangesNeedSaving());

   Win::CursorSetting cursor(IDC_WAIT);

   String preconditionErrorMessage = CheckPreconditions();
   if (!preconditionErrorMessage.empty())
   {
      popup.Error(
         hwnd,
         preconditionErrorMessage);
      return false;
   }

   // computer primary DNS name has already been validated by
   // MoreChangesDialog

   state.SetShortComputerName(Win::GetTrimmedDlgItemText(hwnd, IDC_NEW_NAME));
   bool workgroup =
      Win::IsDlgButtonChecked(hwnd, IDC_WORKGROUP_BUTTON);
   state.SetIsMemberOfWorkgroup(workgroup);
   if (workgroup)
   {
      state.SetDomainName(
         Win::GetTrimmedDlgItemText(hwnd, IDC_WORKGROUP));
   }
   else
   {
      state.SetDomainName(
         Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN));
   }

   // 341483
   if (state.GetShortComputerName().icompare(state.GetDomainName()) == 0)
   {
      // can't have domain/workgroup name same as computer name
      popup.Gripe(
         hwnd,
         IDC_NEW_NAME,
            workgroup
         ?  IDS_COMPUTER_NAME_EQUALS_WORKGROUP_NAME
         :  IDS_COMPUTER_NAME_EQUALS_DOMAIN_NAME);
      return false;
   }

   if (
         !ValidateComputerNames(hwnd)
      || !ValidateDomainOrWorkgroupName(hwnd))
   {
      return false;
   }

   if (state.SaveChanges(hwnd))
   {
      popup.Info(hwnd, IDS_MUST_REBOOT);
      State::GetInstance().SetChangesMadeThisSession(true);      
      return true;
   }

   return false;
}



bool
IDChangesDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
   State& state = State::GetInstance();
   switch (controlIDFrom)
   {
      case IDC_MORE:
      {
         if (code == BN_CLICKED)
         {
            MoreChangesDialog dlg(fIsPersonal);
            if (dlg.ModalExecute(hwnd) == MoreChangesDialog::CHANGES_MADE)
            {
               Win::SetDlgItemText(
                  hwnd,
                  IDC_FULL_NAME,
                  state.GetFullComputerName());               
               enable(hwnd);
            }
         }
         break;
      }
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (OnOkButton())
            {
               HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

               ASSERT(SUCCEEDED(unused));
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
      case IDC_WORKGROUP_BUTTON:
      case IDC_DOMAIN_BUTTON:
      {
         if (code == BN_CLICKED)
         {
            bool workgroup =
               Win::IsDlgButtonChecked(hwnd, IDC_WORKGROUP_BUTTON);
            state.SetIsMemberOfWorkgroup(workgroup);
            if (workgroup)
            {
               state.SetDomainName(
                  Win::GetTrimmedDlgItemText(hwnd, IDC_WORKGROUP));
            }
            else
            {
               state.SetDomainName(
                  Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN));
            }
            enable(hwnd);
         }
         break;
      }
      case IDC_WORKGROUP:
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            state.SetDomainName(
               Win::GetTrimmedDlgItemText(hwnd, controlIDFrom));
            enable(hwnd);
         }
         break;
      }
      case IDC_NEW_NAME:
      {
         if (code == EN_CHANGE)
         {
            // the first time this path is hit, it is because of the SetText
            // in OnInit.  If that is the case, then don't overwrite the
            // short computer name, or we'll clobber the existing netbios name
            // wait till the second time thru this path (which will be due
            // do a user keypress)

            if (!isInitializing)
            {
               state.SetShortComputerName(
                  Win::GetTrimmedDlgItemText(hwnd, controlIDFrom));
               Win::SetDlgItemText(
                  hwnd,
                  IDC_FULL_NAME,
                  state.GetFullComputerName());
            }

            SetChanged(controlIDFrom);
            enable(hwnd);
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\idpage.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// netid prop page
// 
// 3-10-98 sburns



#ifndef IDPAGE_HPP_INCLUDED
#define IDPAGE_HPP_INCLUDED



class NetIDPage : public PropertyPage
{
   public:

   // isWorkstation - true if machine is running a workstation product, false
   // if the machine is running a server product.

   NetIDPage(bool isWorkstation, bool isPersonal);

   protected:

   virtual ~NetIDPage();

   // Dialog overrides

   virtual 
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();
   
   virtual
   bool
   OnApply( bool isClosing );

   private:

   // no copying allowed
   NetIDPage(const NetIDPage&);
   const NetIDPage& operator=(const NetIDPage&);

   void
   refresh();

   bool
   evaluateButtonEnablingAndComposeMessageText(String& message);

   NTService certsvc;
   HICON     warnIcon;
   bool      fIsPersonal;
};

   

#endif   // IDPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_UNKNOWN                     1
#define IDS_DEFAULT_WORKGROUP           2
#define IDS_ERROR_READING_MEMBERSHIP    3
#define IDS_APP_TITLE                   4
#define IDS_MEMBER_OF_WORKGROUP         5
#define IDS_MEMBER_OF_DOMAIN            6
#define IDS_NON_RFC_NAME                7
#define IDS_BAD_DNS_SYNTAX              8
#define IDS_DNS_NAME_TOO_LONG           9
#define IDS_COMPUTER_NAME_TOO_LONG      10
#define IDS_BAD_COMPUTER_NAME_SYNTAX    11
#define IDS_VALIDATE_NAME_FAILED        12
#define IDS_JOIN_DOMAIN_FAILED          13
#define IDS_SHORT_NAME_CHANGE_FAILED    14
#define IDS_RENAME_FAILED_JOINED_WITH_OLD_NAME 15
#define IDS_SET_DOMAIN_DNS_NAME_FAILED  16
#define IDS_UNJOIN_FAILED               17
#define IDS_JOIN_WORKGROUP_FAILED       18
#define IDS_RENAME_FAILED               19
#define IDS_COMPUTER_ACCOUNT_ORPHANED   20
#define IDS_WORKGROUP_WELCOME           22
#define IDS_DOMAIN_WELCOME              23
#define IDS_MUST_REBOOT                 24
#define IDS_NAME_AND_MEMBERSHIP_MESSAGE 25
#define IDS_NAME_MESSAGE                26
#define IDS_RENAME_CREDENTIALS          27
#define IDS_NAME_TRUNCATED              28
#define IDS_NON_RFC_COMPUTER_NAME_SYNTAX 29
#define IDS_CONVERSION_TO_NETBIOS_NAME_FAILED 30
#define IDS_BAD_NETBIOS_CHARACTERS      31
#define IDS_CHANGE_DESCRIPTION_FAILED   32
#define IDI_COMPUTER                    101
#define IDI_WARN                        102
#define IDD_CHANGES                     103
#define IDD_MORE                        104
#define IDD_CREDENTIALS                 105
#define IDD_CHANGES_PER                 106
#define IDD_NETID                       112
#define IDC_COMPUTER_ICON               113
#define IDD_NETID_PER                   114
#define IDC_CHANGE                      115
#define IDC_DOMAIN                      116
#define IDC_MEMBER_OF                   117
#define IDC_ACCOUNT_WIZARD_BUTTON       119
#define IDC_FULL_NAME_STATIC            120
#define IDC_IDENTIFICATION_TEXT         121
#define IDC_DESCRIPTION_EDIT            122
#define IDC_FULL_NAME                   1001
#define IDC_NEW_NAME                    1002
#define IDC_MORE                        1003
#define IDC_WORKGROUP_BUTTON            1004
#define IDC_WORKGROUP                   1007
#define IDC_DOMAIN_BUTTON               1008
#define IDC_FIND                        1010
#define IDC_DNS                         1011
#define IDC_NETBIOS                     1013
#define IDC_FULL_LABEL                  1016
#define IDC_MESSAGE                     1017
#define IDC_GROUP                       1018
#define IDC_REBOOT_MESSAGE              1019
#define IDD_NETID_SRV                   1020
#define IDS_MUST_BE_ADMIN               1021
#define IDS_CANT_TWEAK_ID               1022
#define IDS_CANT_RENAME_DC              1023
#define IDS_CANT_RENAME_CERT_SVC        1024
#define IDS_NETWORKING_NEEDED           1025
#define IDC_WARNING_ICON                1026
#define IDC_CLICK_MESSAGE2              1027
#define IDC_CLICK_MESSAGE1              1028
#define IDS_COMPUTER_NAME_NUMERIC       1029
#define IDS_COMPUTER_NAME_HAS_BAD_CHARS 1030
#define IDS_NUMERIC_DNS_NAME            1031
#define IDS_BAD_DNS_CHARS               1032
#define IDS_COMPUTER_NAME_EQUALS_WORKGROUP_NAME 1033
#define IDS_COMPUTER_NAME_EQUALS_DOMAIN_NAME 1034
#define IDS_ROLE_CHANGE_IN_PROGRESS     1035
#define IDS_ROLE_CHANGE_NEEDS_REBOOT    1036
#define IDS_RENAME_PROMPT               1037
#define IDS_MUST_COMPLETE_DCPROMO       1038
#define IDS_PRECHK_DCPROMO_RUNNING 1039
#define IDS_MUST_EXIT_DCPROMO 1040
#define IDS_PRECHK_MUST_COMPLETE_DCPROMO 1041
#define IDS_PRECHK_CANT_RENAME_CERT_SVC 1042
#define IDS_PRECHK_ROLE_CHANGE_IN_PROGRESS 1043
#define IDS_PRECHK_ROLE_CHANGE_NEEDS_REBOOT 1044
#define IDS_PRECHK_NETWORKING_NEEDED 1045
#define IDS_CHANGE_SYNC_FLAG_FAILED 1046
#define IDS_UNJOIN_CREDENTIALS 1047
#define IDS_NETBIOS_NAME_NUMERIC 1048
#define IDS_WORKGROUP_NAME_TOO_LONG 1049
#define IDS_DISK_FULL 1050
#define IDS_JOIN_FAILED 1051
#define IDS_JOIN_CREDENTIALS 1052
#define IDS_JOIN_DOMAIN_COULDNT_UPDATE_SPNS 1053
#define IDS_JOIN_DOMAIN_COULDNT_UPDATE_SPNS_SUFFIX 1054
#define IDS_RENAME_COULDNT_UPDATE_SPNS 1055
#define IDS_RENAME_COULDNT_UPDATE_SPNS_SUFFIX 1056
#define IDS_RENAME_JOINED_WITH_OLD_NAME_COULDNT_UPDATE_SPNS 1057
#define IDS_RENAME_JOINED_WITH_OLD_NAME_COULDNT_UPDATE_SPNS_SUFFIX 1058
#define IDS_RENAME_DC_WARNING 1059
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\auditdlg.cxx ===
/**********************************************************************/
/**	      Microsoft Windows NT				     **/
/**	   Copyright(c) Microsoft Corp., 1991			     **/
/**********************************************************************/

/*
    AuditDlg.cxx

    This file contains the implementation for the audit dialogs.

    FILE HISTORY:
	Johnl	06-Sep-1991 Created

*/
#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
    #include <ntsam.h>
    #include <ntlsa.h>
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_CC
#include <blt.hxx>
#include <fontedit.hxx>

#include <maskmap.hxx>
#include <security.hxx>
#include <ntacutil.hxx>

#include <accperm.hxx>
#include <aclconv.hxx>
#include <permstr.hxx>

#include <specdlg.hxx>

#include <permdlg.hxx>
#include <auditdlg.hxx>
#include <usrbrows.hxx>
#include <helpnums.h>

#include <uitrace.hxx>

#ifndef min
#define min(a,b)  ((a)<(b)?(a):(b))
#endif

/*******************************************************************

    NAME:	SUBJ_AUDIT_LBI::SUBJ_AUDIT_LBI

    SYNOPSIS:	Constructor for subject audit permissions.  These are
		contained in the SUBJECT_AUDIT_LISTBOX.

    ENTRY:	pauditperm - Pointer to AUDIT_PERMISSION this LBI represents

    NOTES:

    HISTORY:
	Johnl	12-Nov-1991	Created

********************************************************************/

SUBJ_AUDIT_LBI::SUBJ_AUDIT_LBI( AUDIT_PERMISSION * pauditperm )
    : SUBJ_LBI( (SUBJECT *) pauditperm->QuerySubject() ),
      _pAuditPerm( pauditperm )
{
    if ( QueryError() )
	return ;
}

SUBJ_AUDIT_LBI::~SUBJ_AUDIT_LBI()
{
    _pAuditPerm = NULL ;
}

/*******************************************************************

    NAME:	SUBJ_AUDIT_LBI::Paint

    SYNOPSIS:	This Paint method adds an "*" to the subject name if the
		permission isn't inheritted by new containers

    NOTES:

    HISTORY:
	Johnl	15-May-1992	Created

********************************************************************/

void SUBJ_AUDIT_LBI::Paint( LISTBOX * plb,
			    HDC hdc,
			    const RECT * prect,
			    GUILTT_INFO * pguiltt ) const
{
    SUBJECT_LISTBOX * plbSubj = (SUBJECT_LISTBOX *) plb ;

    /* If this subject isn't going to be inheritted by new containers, then
     * mark the subject appropriately.
     */
    APIERR err ;
    NLS_STR nlsSubjName( QuerySubject()->QueryDisplayName() ) ;
    if ( !(err = nlsSubjName.QueryError()) &&
	 !_pAuditPerm->IsContainerPermsInheritted() )
    {
	err = nlsSubjName.AppendChar(TCH('*')) ;
    }

    DM_DTE dmiddte( plbSubj->QueryDisplayMap( QuerySubject()) )  ;
    STR_DTE strdteUserName( err ? QuerySubject()->QueryDisplayName() :
				  nlsSubjName.QueryPch() ) ;
    DISPLAY_TABLE dt( 2, plbSubj->QueryColumnWidths() ) ;
    dt[0] = &dmiddte ;
    dt[1] = &strdteUserName ;

    dt.Paint( plb, hdc, prect, pguiltt ) ;
}

/*******************************************************************

    NAME:	SUBJECT_AUDIT_LISTBOX::SUBJECT_AUDIT_LISTBOX

    SYNOPSIS:	Constructor for listbox that displays SUBJ_AUDIT_LBIs

    NOTES:

    HISTORY:
	Johnl	12-Nov-1991	Created

********************************************************************/

SUBJECT_AUDIT_LISTBOX::SUBJECT_AUDIT_LISTBOX( OWNER_WINDOW * pownerwin,
					      CID cid,
					      ACCPERM * paccperm )
    : SUBJECT_LISTBOX( pownerwin, cid ),
      _paccperm( paccperm )
{
    if ( QueryError() )
	return ;

    UIASSERT( paccperm != NULL ) ;
}

SUBJECT_AUDIT_LISTBOX::~SUBJECT_AUDIT_LISTBOX()
{
    _paccperm = NULL ;
}

/*******************************************************************

    NAME:	SUBJECT_AUDIT_LISTBOX::Fill

    SYNOPSIS:	Fill the listbox with SUBJ_AUDIT_LBI objects that are
		retrieved from the accperm object.

    ENTRY:

    EXIT:

    RETURNS:	APIERR if an error occurred

    NOTES:	The listbox is first emptied of all items.

    HISTORY:
	Johnl	12-Nov-1991	Created

********************************************************************/

APIERR SUBJECT_AUDIT_LISTBOX::Fill( void )
{
    SetRedraw( FALSE ) ;
    DeleteAllItems() ;

    AUDIT_PERMISSION * pAuditPerm ;
    BOOL fFromBeginning = TRUE ;

    while ( QueryAccperm()->EnumAuditPermissions( &pAuditPerm, &fFromBeginning ) )
    {
	UIASSERT( pAuditPerm != NULL ) ;

	SUBJ_AUDIT_LBI * pPermLBI = new SUBJ_AUDIT_LBI( pAuditPerm ) ;

	if ( AddItem( pPermLBI ) < 0 )
	{
	    UIDEBUG(SZ("SUBJECT_AUDIT_LISTBOX::Fill - AddItem failed\n\r")) ;
	    SetRedraw( TRUE ) ;
	    Invalidate( TRUE ) ;
	    return ERROR_NOT_ENOUGH_MEMORY ;
	}
    }

    if ( QueryCount() > 0 )
    {
	SelectItem( 0 ) ;
    }

    SetRedraw( TRUE ) ;
    Invalidate( TRUE ) ;

    return NERR_Success ;
}


/*******************************************************************

    NAME:	SUBJECT_AUDIT_LISTBOX::DeleteCurrentItem

    SYNOPSIS:	Removes the currently selected item from the listbox

    EXIT:	Updates the listbox and combobox before exitting

    NOTES:

    HISTORY:
	Johnl	12-Nov-1991	Created

********************************************************************/

void SUBJECT_AUDIT_LISTBOX::DeleteCurrentItem( void )
{
    SUBJ_AUDIT_LBI * pPermLBI = QueryItem() ;
    UIASSERT( pPermLBI != NULL ) ;

    REQUIRE( QueryAccperm()->DeletePermission( pPermLBI->QueryAuditPerm() ) ) ;

    INT i = QueryCurrentItem() ;
    UIASSERT( i >= 0 ) ;

    DeleteItem( i ) ;
    INT cItems = QueryCount() ;

    if ( cItems > 0 )
	SelectItem( min( i, cItems - 1 ) ) ;
}

/*******************************************************************

    NAME:	SUBJ_LB_AUDIT_GROUP::SUBJ_LB_AUDIT_GROUP

    SYNOPSIS:	Subject listbox audit group constructor

    ENTRY:	plbSubj - Pointer to listbox this group will deal with
		pbuttonRemove - Pointer to remove button that is grayed
			when the listbox is empty.
		pSetOfAuditCat - Pointer to audit categories so we can
			update and disable as appropriate

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	13-Nov-1991	Created

********************************************************************/

SUBJ_LB_AUDIT_GROUP::SUBJ_LB_AUDIT_GROUP(
			      SUBJECT_AUDIT_LISTBOX   * plbSubj,
			      PUSH_BUTTON	      * pbuttonRemove,
			      SET_OF_AUDIT_CATEGORIES * psetofauditcategories )

    : _plbSubj( plbSubj ),
      _pbuttonRemove( pbuttonRemove ),
      _fEnabled( TRUE ),
      _psetofauditcategories( psetofauditcategories ),
      _psauditlbiCurrent( NULL )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( psetofauditcategories != NULL ) ;
    UIASSERT( plbSubj		    != NULL ) ;
    UIASSERT( pbuttonRemove	    != NULL ) ;

    plbSubj->SetGroup( this ) ;
}


/*******************************************************************

    NAME:	SUBJ_LB_AUDIT_GROUP::OnUserAction

    SYNOPSIS:	This method intercepts selection change messages coming
		from the listbox.  We need to update the Audit categories
		as appropriate.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	    13-Nov-1991 Created

********************************************************************/

APIERR SUBJ_LB_AUDIT_GROUP::OnUserAction(	CONTROL_WINDOW * pcw,
					  const CONTROL_EVENT  & e )
{
    APIERR err = NERR_Success ;

    if ( pcw == QuerySubjLB() )
    {
	// C7 CODEWORK - remove Glock-pacifier cast
	if ( !(pcw->QueryEventEffects( (const CONTROL_EVENT &)e ) & CVMI_VALUE_CHANGE) )
	    return GROUP_NO_CHANGE ;

	/* If the listbox is empty, then we need to disable all of the controls
	 * that operate on items in the listbox.
	 */
	if ( IsEnabled() && QuerySubjLB()->QueryCount() == 0 )
	{
	    Enable( FALSE ) ;
	    return NERR_Success ;
	}
	else if ( !IsEnabled() && QuerySubjLB()->QueryCount() > 0 )
	{
	    Enable( TRUE ) ;
	}

	if ( !(err = CommitCurrent()) )
	    SetCurrent( QuerySubjLB()->QueryItem() ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:	SUBJ_LB_AUDIT_GROUP::SetCurrent

    SYNOPSIS:	Updates the _psubjauditlbiCurrent member and sets the
		audit categories for this item.

    ENTRY:	psubjauditlbiCurrent - Pointer to the new lbi that was just
		    selected or NULL to clear.	If NULL, then the group
		    is disabled, else it is enabled.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	13-Nov-1991	Created

********************************************************************/

APIERR SUBJ_LB_AUDIT_GROUP::SetCurrent( SUBJ_AUDIT_LBI * psubjauditlbiCurrent )
{
    if ( (_psauditlbiCurrent = psubjauditlbiCurrent) == NULL )
    {
	if ( IsEnabled() )
	{
	    Enable( FALSE ) ;
	}
	return NERR_Success ;
    }
    else
    {
	if ( !IsEnabled() )
	{
	    Enable( TRUE ) ;
	}
    }

    return _psetofauditcategories->ApplyPermissionsToCheckBoxes(
	     QueryCurrentLBI()->QueryAuditPerm()->QuerySuccessAuditBits(),
	     QueryCurrentLBI()->QueryAuditPerm()->QueryFailAuditBits()	) ;
}

/*******************************************************************

    NAME:	SUBJ_LB_AUDIT_GROUP::CommitCurrent

    SYNOPSIS:	Takes the contents of the audit checkboxes and updates the
		current selection of this group (which is not necesarily
		the current selection of the checkbox).

    ENTRY:

    EXIT:	The Groups "Current" LBI will have been updated based
		on the contents of the set of audit categories object.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	13-Nov-1991	Created

********************************************************************/

APIERR SUBJ_LB_AUDIT_GROUP::CommitCurrent( void )
{
    APIERR err = NERR_Success ;

    if ( QueryCurrentLBI() != NULL )
    {
	err = _psetofauditcategories->QueryUserSelectedBits(
		  QueryCurrentLBI()->QueryAuditPerm()->QuerySuccessAuditBits(),
		  QueryCurrentLBI()->QueryAuditPerm()->QueryFailAuditBits()  ) ;
    }

    return err ;
}
/*******************************************************************

    NAME:	SUBJ_LB_AUDIT_GROUP::Enable

    SYNOPSIS:	Enables or disables the appropriate components of this
		group

    ENTRY:	fEnable - TRUE if the group should be enabled, FALSE to
			  disable the group

    EXIT:	The remove button will be grayed and the listbox will
		have its selection bar removed.  The audit checkboxes
		will be cleared and disabled.


    NOTES:

    HISTORY:
	Johnl	22-Aug-1991	Created

********************************************************************/

void SUBJ_LB_AUDIT_GROUP::Enable( BOOL fEnable )
{
    _fEnabled = fEnable ;

    if ( !fEnable )
	QuerySubjLB()->RemoveSelection() ;

    QueryRemoveButton()->Enable( fEnable ) ;
    QuerySetOfAuditCategories()->Enable( fEnable, fEnable ? FALSE : TRUE ) ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_AUDIT_BASE_DLG::MULTI_SUBJ_AUDIT_BASE_DLG

    SYNOPSIS:	This forms the base of the auditting hierarchy for
		NT objects and containers

    ENTRY:	Same as parent

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991 Created

********************************************************************/

MULTI_SUBJ_AUDIT_BASE_DLG::MULTI_SUBJ_AUDIT_BASE_DLG(
				   const TCHAR		 * pszDialogName,
				   HWND 		   hwndParent,
				   const TCHAR		 * pszDialogTitle,
				   ACL_TO_PERM_CONVERTER * paclconv,
				   const TCHAR		 * pszResourceType,
				   const TCHAR		 * pszResourceName,
				   const TCHAR		 * pszHelpFileName,
                                   ULONG                 * ahcMainDialog )
    : MULTI_SUBJ_PERM_BASE_DLG( pszDialogName,
				hwndParent,
				pszDialogTitle,
				paclconv,
				pszResourceType,
				pszResourceName,
				pszHelpFileName,
                                ahcMainDialog ),
      _subjLB	  ( this, LB_SUBJECT_PERMISSIONS, &_accperm ),
      _SetOfAudits( this,
		    SLT_CHECK_TEXT_1,
		    CHECK_AUDIT_S_1,
		    CHECK_AUDIT_F_1,
		    paclconv->QueryAuditMap(),
		    NULL,
		    NULL,
		    PERMTYPE_SPECIAL ),
      _subjlbauditGroup( &_subjLB, QueryRemoveButton(), &_SetOfAudits )
{
    if ( QueryError() )
	return ;

    APIERR err ;
    if ( (err = _subjLB.QueryError()) ||
	 (err = _SetOfAudits.QueryError()) ||
	 (err = _subjlbauditGroup.QueryError() ))
    {
	ReportError( err ) ;
	return ;
    }
}

MULTI_SUBJ_AUDIT_BASE_DLG::~MULTI_SUBJ_AUDIT_BASE_DLG()
{
    /* Nothing to do */
}

BOOL MULTI_SUBJ_AUDIT_BASE_DLG::OnOK( void )
{
    _subjlbauditGroup.CommitCurrent() ;

    if ( IsReadOnly() )
    {
	Dismiss( TRUE ) ;
	return TRUE ;
    }

    if ( WritePermissions( FALSE,
			   FALSE,
			   TREEAPPLY_AUDIT_PERMS )  )
    {
        WrnIfAuditingIsOff();
	Dismiss( TRUE ) ;
    }

    return TRUE ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_AUDIT_BASE_DLG::OnAddSubject

    SYNOPSIS:	Adds an NT Account to the auditting listbox

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Mar-1992	Integrated NT user browser

********************************************************************/

APIERR MULTI_SUBJ_AUDIT_BASE_DLG::OnAddSubject( void )
{
    _subjlbauditGroup.CommitCurrent() ;

    HWND hWnd = QueryRobustHwnd();

    NT_USER_BROWSER_DIALOG * pdlgUserBrows = new NT_USER_BROWSER_DIALOG(
		     USRBROWS_DIALOG_NAME,
		     hWnd,
		     QueryAclConverter()->QueryLocation()->QueryServer(),
                     QueryHelpArray()[HC_ADD_USER_DLG],
		     QueryAclConverter()->IsContainer() ?
			(USRBROWS_SHOW_ALL | USRBROWS_INCL_ALL) :
			(USRBROWS_SHOW_ALL |
			 (USRBROWS_INCL_ALL & ~USRBROWS_INCL_CREATOR)),
		     QueryHelpFileName(),
                     QueryHelpArray()[HC_ADD_USER_MEMBERS_GG_DLG],
                     QueryHelpArray()[HC_ADD_USER_MEMBERS_LG_DLG],
                     QueryHelpArray()[HC_ADD_USER_SEARCH_DLG] ) ;


    if ( pdlgUserBrows == NULL )
	return ERROR_NOT_ENOUGH_MEMORY ;

    APIERR err = NERR_Success ;

    InvalidateRect (hWnd, NULL, 0);
    UpdateWindow (hWnd);


    do { // error breakout

	BOOL fUserPressedOK ;
	if ( (err = pdlgUserBrows->Process( &fUserPressedOK )) ||
	     !fUserPressedOK )
	{
	    break ;
	}

	/* Get the permission name and corresponding bitfield(s) the user
	 * selected.
	 */
	UIASSERT( sizeof(ACCESS_MASK) == sizeof(ULONG)) ;
	BITFIELD bitSuccess( (ULONG) 0 ) ;
	BITFIELD bitFail( (ULONG) 0 ) ;
	NLS_STR  nlsDomainName ;
	NLS_STR  nlsDisplayName ;

	if ( ( err = bitSuccess.QueryError() )	     ||
	     ( err = bitFail.QueryError() )	     ||
	     ( err = nlsDisplayName.QueryError())    ||
	     ( err = QueryAclConverter()->QueryLoggedOnDomainInfo(
					     NULL, &nlsDomainName )) )
	{
	    break ;
	}

	/* Iterate though each item selected in the Add dialog and add
	 * it to our permission list.
	 */
	BROWSER_SUBJECT_ITER iterUserSelection( pdlgUserBrows ) ;
	BROWSER_SUBJECT * pBrowserSubject ;

	if ( ! (err = iterUserSelection.QueryError()) )
	{
	    while ( !(err = iterUserSelection.Next( &pBrowserSubject )) &&
		     pBrowserSubject != NULL )
	    {
		AUDIT_PERMISSION * pPerm ;
		SID_NAME_USE SidType = pBrowserSubject->QueryType() ;
		if ( SidType == SidTypeUser )
		{
		    /* If this is a remote account, then cast the type
		     * to our own "private" sid name use SubjTypeRemote.
		     */
		    if ( pBrowserSubject->QueryUserAccountFlags() &
					       USER_TEMP_DUPLICATE_ACCOUNT)
		    {
			SidType = (SID_NAME_USE) SubjTypeRemote ;
		    }
		}

		if ( err = pBrowserSubject->QueryQualifiedName(
						    &nlsDisplayName,
						    &nlsDomainName,
						    TRUE ))
		{
		    break ;
		}

		SUBJECT * pSubj = new NT_SUBJECT(
				       (PSID) *pBrowserSubject->QuerySid(),
				       nlsDisplayName.QueryPch(),
				       pBrowserSubject->QueryType());
		if ( err = (pSubj==NULL? ERROR_NOT_ENOUGH_MEMORY :
			    pSubj->QueryError()))
		{
		    break ;
		}

		/* Deletes the subject automatically if we fail to build the
		 * permission.
		 */
		err = QueryAclConverter()->BuildPermission(
			     (PERMISSION **)&pPerm,
			     FALSE,
			     pSubj,
			     &bitSuccess,
			     &bitFail ) ;

		if (  err ||
		     (err = _accperm.AddPermission( pPerm )) )
		{
		    break ;
		}
	    }
	}
    } while ( FALSE ) ; // error breakout loop

    delete pdlgUserBrows ;

    /* Finally, refresh the contents of the listbox.
     */
    if ( !err )
    {
	err = _subjLB.Fill() ;

	if ( _subjLB.QueryCount() > 0 )
	{
	    _subjLB.SelectItem( 0 ) ;
	    _subjlbauditGroup.SetCurrent( _subjLB.QueryItem( 0 ) ) ;
	}
	else
	{
	    _subjlbauditGroup.SetCurrent( NULL ) ;
	}
    }

    return err ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_AUDIT_BASE_DLG::OnDeleteSubject

    SYNOPSIS:	Deletes the currently selected subject from the listbox

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	26-Mar-1992	Implemented

********************************************************************/

void MULTI_SUBJ_AUDIT_BASE_DLG::OnDeleteSubject( void )
{
    //
    //	If we are about to remove the last item, then move the focus and
    //	defaultness to the OK button.
    //
    if ( _subjLB.QueryCount() == 1 )
    {
        _buttonOK.ClaimFocus() ;
        QueryRemoveButton()->MakeDefault() ;
        _buttonOK.MakeDefault() ;
    }

    _subjLB.DeleteCurrentItem() ;

    if ( _subjLB.QueryCount() > 0 )
    {
	_subjlbauditGroup.SetCurrent( _subjLB.QueryItem() ) ;
    }
    else
    {
	_subjlbauditGroup.SetCurrent( NULL ) ;
    }
}


/*******************************************************************

    NAME:	MULTI_SUBJ_AUDIT_BASE_DLG::Initialize

    SYNOPSIS:	Gets the audit permission and sets the checkboxes as
		appropriate

    ENTRY:

    EXIT:	pfUserQuit is set to TRUE if the user decided to bag out

    RETURNS:	NERR_Success if successful, error otherwise

    NOTES:

    HISTORY:
	Johnl	01-Oct-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_AUDIT_BASE_DLG::Initialize( BOOL * pfUserQuit, BOOL fAccessPerms )
{
    /* This call will initialize the accperm
     */
    APIERR err = MAIN_PERM_BASE_DLG::Initialize( pfUserQuit, fAccessPerms ) ;
    if ( err != NERR_Success || *pfUserQuit )
	return err ;

    if ( err = _subjLB.Fill() )
    {
	UIDEBUG(SZ("MULTI_SUBJ_AUDIT_BASE_DLG::ct - Permission list Fill Failed\n\r")) ;
	return err ;
    }

    _subjlbauditGroup.Enable( _subjLB.QueryCount() > 0 ) ;
    _subjLB.ClaimFocus() ;

    if ( _subjLB.QueryCount() > 0 )
    {
	_subjLB.SelectItem( 0 ) ;
	_subjlbauditGroup.SetCurrent( _subjLB.QueryItem(0) ) ;
    }
    else
    {
	_subjlbauditGroup.SetCurrent( NULL ) ;
    }

    return NERR_Success ;
}


/*******************************************************************

    NAME:	MULTI_SUBJ_AUDIT_BASE_DLG::WrnIfAuditingIsOff

    SYNOPSIS:	MsgPopup a warning if the auditing is off.

    ENTRY:

    RETURNS:	

    NOTES:

    HISTORY:
	congpay	15-Dec-1992	Created

********************************************************************/

void MULTI_SUBJ_AUDIT_BASE_DLG::WrnIfAuditingIsOff (void)
{
    LSA_POLICY lsaPolicy (QueryAclConverter()->QueryLocation()->QueryServer(),
                          POLICY_VIEW_AUDIT_INFORMATION);

    LSA_AUDIT_EVENT_INFO_MEM lsaAeim;
    APIERR err;
    if (((err = lsaPolicy.QueryError()) != NERR_Success) ||
        ((err = lsaPolicy.GetAuditEventInfo (&lsaAeim)) != NERR_Success))
    {
        DBGEOL ("MULTI_SUBJ_AUDIT_BASE_DLG::WrnIfAuditingIsOff Error" << err << "getting auditing Info.");
    }
    else
    {
        if (!lsaAeim.IsAuditingOn())
            MsgPopup (this,
                      IDS_AUDIT_OFF_WARNING,
                      MPSEV_WARNING,
                      MP_OK);
    }
}

/*******************************************************************

    NAME:	CONT_AUDIT_DLG::CONT_AUDIT_DLG

    SYNOPSIS:	NT Container Auditting dialog constructor.  Used
		items such as directories etc.	This dialog just adds
		the checkbox for applying permissions to the contents
		of this container.

    ENTRY:	See MULTI_SUBJ_AUDIT_BASE_DLG

    NOTES:	The NT Object auditting dialog uses the same dialog template,
		so we need to show and enable the container apply checkbox

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

CONT_AUDIT_DLG::CONT_AUDIT_DLG( const TCHAR *		pszDialogName,
				HWND			hwndParent,
				const TCHAR *		pszDialogTitle,
				ACL_TO_PERM_CONVERTER * paclconv,
				const TCHAR *		pszResourceType,
				const TCHAR *		pszResourceName,
				const TCHAR *		pszHelpFileName,
                                ULONG       *           ahcMainDialog,
				const TCHAR *		pszAssignToContContentsTitle,
				const TCHAR *		pszTreeApplyHelpText,
				const TCHAR *		pszTreeApplyConfirmation )
    : MULTI_SUBJ_AUDIT_BASE_DLG( pszDialogName,
				 hwndParent,
				 pszDialogTitle,
				 paclconv,
				 pszResourceType,
				 pszResourceName,
				 pszHelpFileName,
                                 ahcMainDialog ),
      _sltfontTreeApplyHelpText ( this, SLT_TREE_APPLY_HELP_TEXT ),
      _checkAssignToContContents( this, CHECK_APPLY_TO_CONT ),
      _pszTreeApplyConfirmation ( pszTreeApplyConfirmation )
{
    if ( QueryError() )
	return ;

    if ( pszAssignToContContentsTitle == NULL )
    {
	_checkAssignToContContents.Show( FALSE ) ;
	_checkAssignToContContents.Enable( FALSE ) ;
    }
    else
    {
	_checkAssignToContContents.Show( TRUE ) ;
	_checkAssignToContContents.Enable( TRUE ) ;
	_checkAssignToContContents.SetText( pszAssignToContContentsTitle ) ;

#if 0
	if ( pszTreeApplyHelpText != NULL )
	{
	    _sltfontTreeApplyHelpText.SetText( pszTreeApplyHelpText ) ;
        }
#endif
    }
}

CONT_AUDIT_DLG::~CONT_AUDIT_DLG()
{
    /* Nothing to do */
}

BOOL CONT_AUDIT_DLG::IsAssignToExistingObjChecked( void )
{
    //
    //  This dialog doesn't support object permissions
    //
    return FALSE ;
}

/*******************************************************************

    NAME:	CONT_AUDIT_DLG::OnOK

    SYNOPSIS:	Normal apply permissions dialog, adds the Apply to container checkbox

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	01-May-1992	Created

********************************************************************/

BOOL CONT_AUDIT_DLG::OnOK( void )
{
    QuerySubjLBGroup()->CommitCurrent() ;

    if ( IsReadOnly() )
    {
	Dismiss( TRUE ) ;
	return TRUE ;
    }

    APIERR err ;
    BOOL fAssignToTree = FALSE ;
    if ( IsAssignToExistingContChecked() )
    {
	NLS_STR nlsResName(40) ;
	NLS_STR nlsTreeApplyConfirmation( _pszTreeApplyConfirmation ) ;
	if ( (err = nlsResName.QueryError()) ||
	     (err = QueryResName( &nlsResName )) ||
	     (err = nlsTreeApplyConfirmation.InsertParams( 1, &nlsResName )) )
	{
	    MsgPopup( this, (MSGID) err ) ;
	    return FALSE ;
	}

	switch ( MsgPopup( this,
			   IDS_PERCENT_1,
			   MPSEV_WARNING,
			   MP_YESNO,
			   nlsTreeApplyConfirmation))
	{
	case IDYES:
	    fAssignToTree = TRUE ;
	    break ;

	default:
	    UIASSERT(FALSE) ;
	    /* fall through
	     */

	case IDNO:
	    return TRUE ;
	}
    }

    if ( WritePermissions(fAssignToTree,
                          IsAssignToExistingObjChecked(),
			  TREEAPPLY_AUDIT_PERMS) )
    {
        WrnIfAuditingIsOff();
	Dismiss( TRUE ) ;
    }
    else
    {
	//
	// Set the OK button to "Close" if the tree apply failed (ignore any
	// errors).
	//

        if ( fAssignToTree || QueryAclConverter()->IsNewObjectsSupported() )
	{
	    RESOURCE_STR nlsClose( IDS_CLOSE ) ;
	    if ( !nlsClose.QueryError() )
	    {
		_buttonCancel.SetText( nlsClose ) ;
	    }
	}
    }

    return TRUE ;
}


/*******************************************************************

    NAME:	OBJECT_AUDIT_DLG::OBJECT_AUDIT_DLG

    SYNOPSIS:	Constructor for the Object Audit Dialog class.	Used for
		Auditting NT Objects (files etc.).

    ENTRY:	See MULTI_SUBJ_AUDIT_BASE_DLG

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

OBJECT_AUDIT_DLG::OBJECT_AUDIT_DLG( const TCHAR *	    pszDialogName,
				    HWND		    hwndParent,
				    const TCHAR *	    pszDialogTitle,
				    ACL_TO_PERM_CONVERTER * paclconv,
				    const TCHAR *	    pszResourceType,
				    const TCHAR *	    pszResourceName,
				    const TCHAR *	    pszHelpFileName,
                                    ULONG       *           ahcMainDialog )
    : MULTI_SUBJ_AUDIT_BASE_DLG( pszDialogName,
				 hwndParent,
				 pszDialogTitle,
				 paclconv,
				 pszResourceType,
				 pszResourceName,
				 pszHelpFileName,
                                 ahcMainDialog )
{
    if ( QueryError() )
	return ;
}

OBJECT_AUDIT_DLG::~OBJECT_AUDIT_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:       CONT_NEWOBJ_AUDIT_DLG::CONT_NEWOBJ_AUDIT_DLG

    SYNOPSIS:   NT Container with new object Auditting dialog constructor.
                Used for directories etc.  This dialog just adds
                the checkbox for applying permissions to the existing
                contents of this container.

    ENTRY:      See CONT_AUDIT_DLG

    HISTORY:
        Johnl   01-Apr-1993     Created

********************************************************************/

CONT_NEWOBJ_AUDIT_DLG::CONT_NEWOBJ_AUDIT_DLG(
                                const TCHAR *           pszDialogName,
				HWND			hwndParent,
				const TCHAR *		pszDialogTitle,
				ACL_TO_PERM_CONVERTER * paclconv,
				const TCHAR *		pszResourceType,
				const TCHAR *		pszResourceName,
				const TCHAR *		pszHelpFileName,
                                ULONG       *           ahcMainDialog,
                                const TCHAR *           pszAssignToContContentsTitle,
                                const TCHAR *           pszAssignToObjTitle,
				const TCHAR *		pszTreeApplyHelpText,
				const TCHAR *		pszTreeApplyConfirmation )
    : CONT_AUDIT_DLG( pszDialogName,
                      hwndParent,
                      pszDialogTitle,
                      paclconv,
                      pszResourceType,
                      pszResourceName,
                      pszHelpFileName,
                      ahcMainDialog,
                      pszAssignToContContentsTitle,
                      pszTreeApplyHelpText,
                      pszTreeApplyConfirmation ),
      _checkAssignToObj( this, CHECK_APPLY_TO_OBJ )
{
    if ( QueryError() )
	return ;

    if ( pszAssignToObjTitle == NULL )
    {
        _checkAssignToObj.Show( FALSE ) ;
        _checkAssignToObj.Enable( FALSE ) ;
    }
    else
    {
        _checkAssignToObj.SetText( pszAssignToObjTitle ) ;
        _checkAssignToObj.SetCheck( TRUE ) ;
    }
}

CONT_NEWOBJ_AUDIT_DLG::~CONT_NEWOBJ_AUDIT_DLG()
{
    /* Nothing to do */
}

BOOL CONT_NEWOBJ_AUDIT_DLG::IsAssignToExistingObjChecked( void )
{
    return _checkAssignToObj.QueryCheck() ;
}



/*******************************************************************

    NAME:	LM_AUDITTING_DLG::LM_AUDITTING_DLG

    SYNOPSIS:	This is the Lan Manager File and directory auditting dialog

    ENTRY:	Same as parent
		pszAssignToContContentsTitle is the name of the checkbox.  If
		    it is NULL (as it should be for files) then the checkbox
		    will be hidden and disabled.

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991 Created

********************************************************************/

LM_AUDITTING_DLG::LM_AUDITTING_DLG( const TCHAR *    pszDialogName,
				    HWND	     hwndParent,
				    const TCHAR *    pszDialogTitle,
				    ACL_TO_PERM_CONVERTER * paclconv,
				    const TCHAR *    pszResourceType,
				    const TCHAR *    pszResourceName,
				    const TCHAR *    pszHelpFileName,
                                    ULONG       *    ahcMainDialog,
				    const TCHAR *    pszAssignToContContentsTitle,
				    const TCHAR *    pszTreeApplyHelpText,
				    const TCHAR *    pszTreeApplyConfirmation )
   : MAIN_PERM_BASE_DLG( pszDialogName,
			 hwndParent,
			 pszDialogTitle,
			 paclconv,
			 pszResourceType,
			 pszResourceName,
			 pszHelpFileName,
                         ahcMainDialog ),
     _checkAssignToContContents( this, CHECK_APPLY_TO_CONT ),
     _SetOfAudits	       ( this,
				 SLT_CHECK_TEXT_1,
				 CHECK_AUDIT_S_1,
				 CHECK_AUDIT_F_1,
				 paclconv->QueryAuditMap(),
				 NULL,
				 NULL,
				 PERMTYPE_SPECIAL ),
    _sltfontTreeApplyHelpText  ( this, SLT_TREE_APPLY_HELP_TEXT ),
    _pszTreeApplyConfirmation  ( pszTreeApplyConfirmation )
{
    if ( QueryError() )
	return ;

    if ( _SetOfAudits.QueryError() )
    {
	ReportError( _SetOfAudits.QueryError() ) ;
	return ;
    }

    if ( pszAssignToContContentsTitle == NULL )
    {
	_checkAssignToContContents.Show( FALSE ) ;
	_checkAssignToContContents.Enable( FALSE ) ;
    }
    else
    {
	_checkAssignToContContents.SetText( pszAssignToContContentsTitle ) ;

	if ( pszTreeApplyHelpText != NULL )
	{
	    _sltfontTreeApplyHelpText.SetText( pszTreeApplyHelpText ) ;
	}
    }
}

LM_AUDITTING_DLG::~LM_AUDITTING_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	LM_AUDITTING_DLG::Initialize

    SYNOPSIS:	Gets the audit permission and sets the checkboxes as
		appropriate

    ENTRY:

    EXIT:	pfUserQuit is set to TRUE if the user decided to bag out

    RETURNS:	NERR_Success if successful, error otherwise

    NOTES:

    HISTORY:
	Johnl	01-Oct-1991	Created

********************************************************************/

APIERR LM_AUDITTING_DLG::Initialize( BOOL * pfUserQuit, BOOL fAccessPerms )
{
    /* This call will initialize the accperm
     */
    APIERR err = MAIN_PERM_BASE_DLG::Initialize( pfUserQuit, fAccessPerms ) ;
    if ( err != NERR_Success || *pfUserQuit )
	return err ;

    AUDIT_PERMISSION * pAuditPerm ;
    BOOL fFromBeginning = TRUE ;
    if ( _accperm.EnumAuditPermissions( &pAuditPerm, & fFromBeginning ) )
    {
	_pbitsSuccess = pAuditPerm->QuerySuccessAuditBits() ;
	_pbitsFailed  = pAuditPerm->QueryFailAuditBits() ;
	err = _SetOfAudits.ApplyPermissionsToCheckBoxes( _pbitsSuccess, _pbitsFailed ) ;
	if ( err != NERR_Success )
	    return err ;

	/* There should only be one Audit record in the accperm
	 */
	UIASSERT( !_accperm.EnumAuditPermissions( &pAuditPerm, & fFromBeginning ) ) ;
    }
    else
    {
	/* There must be one audit permission in the accperm, if there isn't,
	 * then something is wrong.
	 */
	UIASSERT( FALSE ) ;
	return ERROR_GEN_FAILURE ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	LM_AUDITTING_DLG::OnOK( void )

    SYNOPSIS:	Typical OnOK processing - Grab the newly selected bits and
		write them out, put up an error if an error ocurred.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	30-Sep-1991	Created

********************************************************************/

BOOL LM_AUDITTING_DLG::OnOK( void )
{
    _SetOfAudits.QueryUserSelectedBits( _pbitsSuccess, _pbitsFailed ) ;

    APIERR err ;
    BOOL fAssignToTree = FALSE ;
    if ( IsAssignToExistingContChecked() )
    {
	NLS_STR nlsTreeApplyConfirmation( _pszTreeApplyConfirmation ) ;
	NLS_STR nlsResName ;
	if ( (err = nlsResName.QueryError()) ||
	     (err = QueryResName( &nlsResName )) ||
	     (err = nlsTreeApplyConfirmation.InsertParams( 1, &nlsResName )) )
	{
	    MsgPopup( this, (MSGID) err ) ;
	    return FALSE ;
	}

	switch ( MsgPopup( this,
			   IDS_PERCENT_1,
			   MPSEV_WARNING,
			   MP_YESNO,
			   nlsTreeApplyConfirmation))
	{
	case IDYES:
	    fAssignToTree = TRUE ;
	    break ;

	default:
	    UIASSERT(FALSE) ;
	    /* fall through
	     */

	case IDNO:
	    return TRUE ;
	}
    }

    if ( WritePermissions(fAssignToTree,
                          fAssignToTree,
			  TREEAPPLY_AUDIT_PERMS) )
    {
	Dismiss( TRUE ) ;
    }
    else
    {
	//
	// Set the OK button to "Close" if the tree apply failed (ignore any
	// errors).
	//

	if ( fAssignToTree )
	{
	    RESOURCE_STR nlsClose( IDS_CLOSE ) ;
	    if ( !nlsClose.QueryError() )
	    {
		_buttonCancel.SetText( nlsClose ) ;
	    }
	}
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\accperm.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    accperm.cxx
    Definition of the ACCPERM class


    The ACCPERM class provides the generic interface to network permissions
    and auditting.


    FILE HISTORY:
	johnl	05-Aug-1991	Confiscated Rustan's original & did my own

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
}

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#include <string.hxx>
#include <uiassert.hxx>
#include <uitrace.hxx>
#include <uiassert.hxx>

#include <perm.hxx>	    // Make these <> when a home is found
#include <subject.hxx>
#include <accperm.hxx>

DEFINE_SLIST_OF(ACCESS_PERMISSION)
DEFINE_SLIST_OF(AUDIT_PERMISSION)

/*******************************************************************

    NAME:	ACCPERM::ACCPERM

    SYNOPSIS:	Constructor for the ACCPERM class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	08-Aug-1991	Created

********************************************************************/

ACCPERM::ACCPERM( ACL_TO_PERM_CONVERTER * paclconv )
    : _slAccessPerms( TRUE ),
      _slAuditPerms( TRUE ),
      _iterslAccessPerms( _slAccessPerms ),
      _iterslAuditPerms( _slAuditPerms ),
      _fDidDeleteAccessPerms( FALSE ),
      _fDidDeleteAuditPerms ( FALSE ),
      _paclconverter( paclconv )
{
    UIASSERT( _paclconverter != NULL ) ;
}

/*******************************************************************

    NAME:	ACCPERM::AddPermission

    SYNOPSIS:	Adds a permssion (audit or access) to the accperm

    ENTRY:	paccessperm - points to a ACCESS_PERMISSION object that
		was created on the heap.

    RETURNS:	NERR_Success if successful, standard error code if not
		successful.

    NOTES:	Any permissions left in the ACCPERM on destruction will
		be *deleted*.

    HISTORY:
	Johnl	14-Aug-1991	Created
	Johnl	07-Jul-1992	Made adds idempotent

********************************************************************/

APIERR ACCPERM::AddPermission	( ACCESS_PERMISSION * paccessperm )
{
    UIASSERT( paccessperm->QueryError() == NERR_Success ) ;

    ITER_SL_OF(ACCESS_PERMISSION) itersl( _slAccessPerms ) ;
    ACCESS_PERMISSION * paccesspermTmp ;

    while ( (paccesspermTmp = itersl.Next()) != NULL )
    {
	if ( paccesspermTmp->QuerySubject()->IsEqual( paccessperm->QuerySubject()) )
	{
	    /* Glock chokes if you try directly deleting the
	     * return value of the Remove.
	     */
	    REQUIRE( _slAccessPerms.Remove( itersl ) != NULL ) ;
	    delete( paccesspermTmp ) ;
	    break ;
	}
    }

    return ( _slAccessPerms.Add( paccessperm ) ) ;
}

APIERR ACCPERM::AddPermission	( AUDIT_PERMISSION * pauditperm )
{
    UIASSERT( pauditperm->QueryError() == NERR_Success ) ;

    ITER_SL_OF(AUDIT_PERMISSION) itersl( _slAuditPerms ) ;
    AUDIT_PERMISSION * pauditpermTmp ;

    while ( (pauditpermTmp = itersl.Next()) != NULL )
    {
	if ( pauditpermTmp->QuerySubject()->IsEqual( pauditperm->QuerySubject()) )
	{
	    /* Glock chokes if you try directly deleting the
	     * return value of the Remove.
	     */
	    REQUIRE( _slAuditPerms.Remove( itersl ) != NULL ) ;
	    delete( pauditpermTmp ) ;
	    break ;
	}
    }

    return ( _slAuditPerms.Add( pauditperm ) ) ;
}

/*******************************************************************

    NAME:	ACCPERM::DeletePermission

    SYNOPSIS:	Removes and deletes the passed access permission from
		the permission list.  Equality is based on the address
		of the accessperm.

    ENTRY:	paccessperm - permission to remove

    EXIT:	The permission will be removed from the list

    RETURNS:	TRUE if the deletion successful, FALSE otherwise.

    NOTES:	The same comments apply for the AUDIT_PERMISSION form
		of DeletePermission

    HISTORY:
	Johnl	14-Aug-1991	Created

********************************************************************/

BOOL ACCPERM::DeletePermission( ACCESS_PERMISSION * paccessperm )
{
    ITER_SL_OF(ACCESS_PERMISSION) itersl( _slAccessPerms ) ;
    ACCESS_PERMISSION * paccesspermTmp ;

    while ( (paccesspermTmp = itersl.Next()) != NULL )
    {
	if ( paccesspermTmp == paccessperm )
	{
	    /* Glock chokes if you try directly deleting the
	     * return value of the Remove.
	     */
	    REQUIRE( _slAccessPerms.Remove( itersl ) != NULL ) ;
	    delete( paccessperm ) ;
	    _fDidDeleteAccessPerms = TRUE ;
	    return TRUE ;
	}
    }

    return FALSE ;
}

BOOL ACCPERM::DeletePermission( AUDIT_PERMISSION * pauditperm )
{
    ITER_SL_OF(AUDIT_PERMISSION) itersl( _slAuditPerms ) ;
    AUDIT_PERMISSION * pauditpermTmp ;

    while ( (pauditpermTmp = itersl.Next()) != NULL )
    {
	if ( pauditpermTmp == pauditperm )
	{
	    REQUIRE( _slAuditPerms.Remove( itersl ) != NULL ) ;
	    delete( pauditperm ) ;
	    _fDidDeleteAuditPerms = TRUE ;
	    return TRUE ;
	}
    }

    return FALSE ;
}

/*******************************************************************

    NAME:	ACCPERM::EnumAccesspermissions

    SYNOPSIS:	Retrieves all of the Access/Audit permissions in the
		ACCPERM.

    ENTRY:	See Header for explanation of parameters

    EXIT:

    RETURNS:	TRUE while valid data is returned, FALSE otherwise.

    NOTES:	The same comments apply for EnumAuditPermissions

    HISTORY:
	Johnl	14-Aug-1991	Created

********************************************************************/

BOOL ACCPERM::EnumAccessPermissions( ACCESS_PERMISSION * * ppAccessPermission,
				     BOOL * pfFromBeginning )
{
    if ( *pfFromBeginning )
    {
	_iterslAccessPerms.Reset() ;
	*pfFromBeginning = FALSE ;
	_fDidDeleteAccessPerms = FALSE ;
    }

    if ( _fDidDeleteAccessPerms )
    {
	*ppAccessPermission = _iterslAccessPerms.QueryProp() ;
	_fDidDeleteAccessPerms = FALSE ;
    }
    else
	*ppAccessPermission = _iterslAccessPerms.Next() ;

    return *ppAccessPermission != NULL ;
}

BOOL ACCPERM::EnumAuditPermissions(  AUDIT_PERMISSION * * ppAuditPermission,
				     BOOL * pfFromBeginning )
{
    if ( *pfFromBeginning )
    {
	_iterslAuditPerms.Reset() ;
	*pfFromBeginning = FALSE ;
	_fDidDeleteAuditPerms = FALSE ;
    }

    if ( _fDidDeleteAuditPerms )
    {
	*ppAuditPermission = _iterslAuditPerms.QueryProp() ;
	_fDidDeleteAuditPerms = FALSE ;
    }
    else
	*ppAuditPermission = _iterslAuditPerms.Next() ;

    return *ppAuditPermission != NULL ;
}

/*******************************************************************

    NAME:	ACCPERM::DeleteSubject

    SYNOPSIS:	Removes a subject by name from the access and audit
		permissions list

    ENTRY:	pnlsSubjName - Subject to delete

    EXIT:	The subject will be removed from _slAccessPerms and
		_slAuditPerms.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	07-Jul-1992	Implemented

********************************************************************/

APIERR ACCPERM::DeleteSubject( NLS_STR * pnlsSubjName )
{
    ACCESS_PERMISSION * paccesspermTmp ;
    ITER_SL_OF(ACCESS_PERMISSION) iterslAccess( _slAccessPerms ) ;
    while ( (paccesspermTmp = iterslAccess.Next()) != NULL )
    {
	if ( !::stricmpf( paccesspermTmp->QuerySubject()->QueryDisplayName(),
			  pnlsSubjName->QueryPch() ) )
	{
	    /* Glock chokes if you try directly deleting the
	     * return value of the Remove.
	     */
	    REQUIRE( _slAccessPerms.Remove( iterslAccess ) != NULL ) ;
	    delete( paccesspermTmp ) ;
	    break ;
	}
    }

    AUDIT_PERMISSION * pauditpermTmp ;
    ITER_SL_OF(AUDIT_PERMISSION) iterslAudit( _slAuditPerms ) ;
    while ( (pauditpermTmp = iterslAudit.Next()) != NULL )
    {
	if ( !::stricmpf( pauditpermTmp->QuerySubject()->QueryDisplayName(),
			  pnlsSubjName->QueryPch() ) )
	{
	    /* Glock chokes if you try directly deleting the
	     * return value of the Remove.
	     */
	    REQUIRE( _slAuditPerms.Remove( iterslAudit ) != NULL ) ;
	    delete( pauditpermTmp ) ;
	    break ;
	}
    }

    return NERR_Success ;
}


/*******************************************************************

    NAME:	ACCPERM::AnyDenyAllsToEveryone

    SYNOPSIS:   Checks to see if Everyone has been denied access by an
                explicit "Everyone (None)" or nobody was granted access

    RETURNS:	pfDenyAll will be set to TRUE and NERR_Success will be
		returned

    NOTES:

    HISTORY:
	Johnl	16-Oct-1992	Created

********************************************************************/

APIERR ACCPERM::AnyDenyAllsToEveryone( BOOL *pfDenyAll )
{
    ACCESS_PERMISSION * paccesspermTmp ;
    ITER_SL_OF(ACCESS_PERMISSION) iterslAccess( _slAccessPerms ) ;
    APIERR err = NERR_Success ;

    *pfDenyAll = FALSE ;
    BOOL fAnyGrants = FALSE ;
    while ( (paccesspermTmp = iterslAccess.Next()) != NULL )
    {
	if ( (err = paccesspermTmp->IsDenyAllForEveryone( pfDenyAll )) ||
	     *pfDenyAll )
	{
	    break ;
        }

        if ( paccesspermTmp->IsGrant() )
            fAnyGrants = TRUE ;
    }

    if ( !err && !fAnyGrants )
        *pfDenyAll = TRUE ;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\state.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Tab state
//
// 03-31-98 sburns
// 10-05-00 jonn      changed to CredUIGetPassword



#include "headers.hxx"
#include "state.hpp"
#include "resource.h"
#include "cred.hpp"



TCHAR const c_szWizardFilename[] = L"netplwiz.dll";



class Settings
{
   public:

   // default ctor, copy ctor, op=, dtor used

   void
   Refresh();

   String   ComputerDomainDnsName;
   String   DomainName;
   String   FullComputerName;
   String   PolicyDomainDnsName;
   String   ShortComputerName;
   String   NetbiosComputerName;

   bool     SyncDNSNames;
   bool     JoinedToWorkgroup;
   bool     NeedsReboot;
};



static State* instance            = 0;    
static bool   machineIsDc         = false;
static bool   networkingInstalled = false;
static bool   policyInEffect      = false;
static bool   mustReboot          = false;

// no static initialization worries here, as these are rebuilt when the State
// instance is constructed/initialized/refreshed.
static Settings original;
static Settings current; 

// not static String instances to avoid order of static initialization any
// problems
static const wchar_t* TCPIP_PARAMS_KEY = 
   L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters";

static const wchar_t* SYNC_VALUE =
   L"SyncDomainWithMembership";

static const wchar_t* NEW_HOSTNAME_VALUE = L"NV Hostname";
static const wchar_t* NEW_SUFFIX_VALUE   = L"NV Domain";


bool
readSyncFlag()
{
   bool retval = true;

   do
   {
      RegistryKey key;

      HRESULT hr = key.Open(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY);
      BREAK_ON_FAILED_HRESULT(hr);

      // default is to sync.
      DWORD data = 1;
      hr = key.GetValue(SYNC_VALUE, data);
      BREAK_ON_FAILED_HRESULT(hr);

      retval = data ? true : false;
   }
   while (0);

   return retval;
}


// JonN 1/03/01 106601
// When the dns suffix checkbox is unchecked,
// domain join fails with a confusing message
//
// LevonE: When Join fails with ERROR_DS_COULDNT_UPDATE_SPNS the UI must check
//       if (HKLM/System/CCS/Services/Tcpip/Parameters/SyncDomainWithMembership
//             == 0x0 &&
//       HKLM/System/CCS/Services/Tcpip/Parameters/NV Domain
//             != AD_Domain_To_Be_Joined)
bool WarnDnsSuffix( const String& refNewDomainName )
{
   if (readSyncFlag())
      return false;
   String strNVDomain;
   RegistryKey key;
   HRESULT hr2 = key.Open(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY);
   if (!SUCCEEDED(hr2))
      return false;
   hr2 = key.GetValue(NEW_SUFFIX_VALUE, strNVDomain);
   if (!SUCCEEDED(hr2))
      return false;
   return !!strNVDomain.icompare( refNewDomainName );
}



HRESULT
WriteSyncFlag(HWND dialog, bool flag)
{
   LOG_FUNCTION(WriteSyncFlag);
   ASSERT(Win::IsWindow(dialog));

   HRESULT hr = S_OK;
   do
   {
      RegistryKey key;

      hr = key.Create(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = key.SetValue(SYNC_VALUE, flag ? 1 : 0);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         dialog,
         hr,
         IDS_CHANGE_SYNC_FLAG_FAILED);
   }

   return hr;
}



// returns true if the machine is a domain controller running under ds repair
// mode, false if not
   
bool
IsDcInDsRepairMode()
{
   LOG_FUNCTION(IsDcInDsRepairMode);

   // We infer a DC in repair mode if we're told that the machine is a server
   // and the safe boot option is ds repair, and the real product type is
   // LanManNT.
   //
   // By "real" product type, I mean that which is written in the registry,
   // not that which is reported by RtlGetNtProductType.  The API gets the
   // result from shared memory which is adjusted at boot to reflect the
   // ds repair mode (from LanManNt to Server).  The registry entry is not
   // changed by repair mode.
   //
   // We have to check both because it is possible to boot a normal server
   // in ds repair mode.

   DWORD safeBoot = 0;
   NT_PRODUCT_TYPE product = NtProductWinNt;

   HRESULT hr = Computer::GetSafebootOption(HKEY_LOCAL_MACHINE, safeBoot);

   // don't assert the result: the key may not be present

   hr = Computer::GetProductTypeFromRegistry(HKEY_LOCAL_MACHINE, product);
   ASSERT(SUCCEEDED(hr));

   if (safeBoot == SAFEBOOT_DSREPAIR and product == NtProductLanManNt)
   {
      return true;
   }

   return false;
}



void
Settings::Refresh()
{
   LOG_FUNCTION(Settings::Refresh);

   String unknown = String::load(IDS_UNKNOWN);
   ComputerDomainDnsName = unknown;
   DomainName            = unknown;
   FullComputerName      = unknown;
   ShortComputerName     = unknown;
   PolicyDomainDnsName   = unknown;

   SyncDNSNames      = readSyncFlag();
   JoinedToWorkgroup = true;          

   // CODEWORK: we should reconcile this with the Computer object added
   // to idpage.cpp

   DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr))
   {
      if (info->DomainNameDns)
      {
         DomainName = info->DomainNameDns;
      }
      else if (info->DomainNameFlat)
      {
         DomainName = info->DomainNameFlat;
      }

      // this is the workgroup name iff JoinedToWorkgroup == true
      switch (info->MachineRole)
      {
         case DsRole_RoleBackupDomainController:
         case DsRole_RolePrimaryDomainController:
         {
            machineIsDc = true;
            JoinedToWorkgroup = false;
            break;
         }
         case DsRole_RoleStandaloneWorkstation:
         {
            machineIsDc = false;
            JoinedToWorkgroup = true;

            if (DomainName.empty())
            {
               LOG(L"empty domain name, using default WORKGROUP");

               DomainName = String::load(IDS_DEFAULT_WORKGROUP);
            }
            break;
         }
         case DsRole_RoleStandaloneServer:
         {
            machineIsDc = false;
            JoinedToWorkgroup = true;

            // I wonder if we're really a DC booted in ds repair mode?

            if (IsDcInDsRepairMode())
            {
               LOG(L"machine is in ds repair mode");

               machineIsDc = true;
               JoinedToWorkgroup = false;

               // we can't determine the domain name (LSA won't tell
               // us when running ds repair mode), so we fall back to
               // unknown.  This is better than "WORKGROUP" -- which is
               // what info contains.

               DomainName = unknown;
            }
            else
            {
               if (DomainName.empty())
               {
                  LOG(L"empty domain name, using default WORKGROUP");

                  DomainName = String::load(IDS_DEFAULT_WORKGROUP);
               }
            }
            break;
         }
         case DsRole_RoleMemberWorkstation:
         case DsRole_RoleMemberServer:
         {
            machineIsDc = false;
            JoinedToWorkgroup = false;
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }

      ::DsRoleFreeMemory(info);
   }
   else
   {
      popup.Error(
         Win::GetDesktopWindow(),
         hr,
         String::load(IDS_ERROR_READING_MEMBERSHIP));

      // fall back to other APIs to fill in the holes as best we can.

      JoinedToWorkgroup = false;
      machineIsDc = false;

      // workstation, server, or DC?  (imprescise, but better than a stick
      // in the eye)
      NT_PRODUCT_TYPE ntp = NtProductWinNt;
      BOOLEAN result = ::RtlGetNtProductType(&ntp);
      if (result)
      {
         switch (ntp)
         {
            case NtProductWinNt:
            {
               break;
            }
            case NtProductServer:
            {
               break;
            }
            case NtProductLanManNt:
            {
               machineIsDc = true;
               break;
            }
            default:
            {
               ASSERT(false);
            }
         }
      }
   }

   networkingInstalled = IsNetworkingInstalled();
   bool isTcpInstalled = networkingInstalled && IsTcpIpInstalled();
   String activeFullName;

   NetbiosComputerName = Computer::GetFuturePhysicalNetbiosName();

   if (isTcpInstalled)
   {
      // When TCP/IP is installed on the computer, then we are interested
      // in the computer DNS domain name suffix, and the short name is the
      // computer's DNS hostname.

      String activeShortName;
      String futureShortName;
      String activeDomainName;
      String futureDomainName;

      RegistryKey key;
      hr = key.Open(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY);
      if (SUCCEEDED(hr))
      {
         // Read these values without checking for failure, as empty string
         // is ok.
         
         activeShortName  = key.GetString(L"Hostname");
         activeDomainName = key.GetString(L"Domain");  
         futureShortName  = key.GetString(NEW_HOSTNAME_VALUE);

         ShortComputerName =
            futureShortName.empty() ? activeShortName : futureShortName;

         // here, check that the value was successfully read, because
         // it may not be present.
         
         hr = key.GetValue(NEW_SUFFIX_VALUE, futureDomainName);
         if (SUCCEEDED(hr))
         {
            ComputerDomainDnsName = futureDomainName;
         }
         else
         {
            ComputerDomainDnsName = activeDomainName;
         }
      }

      // Determine if DNS domain name policy is in effect.  This may change
      // at any moment, asynchronously, so we save the result as a setting.

      policyInEffect =
         Computer::IsDnsSuffixPolicyInEffect(PolicyDomainDnsName);

      // The full computer name is the short name + . + dns domain name
      // if policy is in effect, the policy dns domain name takes precedence
      // over the computer's dns domain name.

      FullComputerName =
         Computer::ComposeFullDnsComputerName(
            ShortComputerName,
            policyInEffect ? PolicyDomainDnsName : ComputerDomainDnsName);
      activeFullName =
         Computer::ComposeFullDnsComputerName(
            activeShortName,
            policyInEffect ? PolicyDomainDnsName : activeDomainName);
   }
   else
   {
      // 371944

      activeFullName = Computer::GetActivePhysicalNetbiosName();

      // when there is no TCP/IP, the short name is the NetBIOS name

      ShortComputerName = NetbiosComputerName;
      FullComputerName  = ShortComputerName;  
   }

   // This test does not take into account domain membership changes, as we
   // have no prior membership info to compare the current membership to.

   NeedsReboot = activeFullName != FullComputerName;
}



void
State::Delete()
{
   LOG_FUNCTION(State::Delete);

   delete instance;
   instance = 0;
}



State&
State::GetInstance()
{
   ASSERT(instance);

   return *instance;
}



void
State::Init()
{
   LOG_FUNCTION(State::Init);
   ASSERT(!instance);

   if (!instance)
   {
      instance = new State();
   }
}



void
State::Refresh()
{
   LOG_FUNCTION(State::Refresh);

   State::Delete();
   State::Init();
}



State::State()
{
   LOG_CTOR(State);

   original.Refresh();
   current = original;
}



State::~State()
{
   LOG_DTOR(State);
}



bool
State::NeedsReboot() const
{
   return original.NeedsReboot;
}



bool
State::IsMachineDc() const
{
   return machineIsDc;
}



bool
State::IsNetworkingInstalled() const
{
   return networkingInstalled;
}



String
State::GetFullComputerName() const
{
   return current.FullComputerName;
}



String
State::GetDomainName() const
{
   return current.DomainName;
}



void
State::SetDomainName(const String& name)
{
//    LOG_FUNCTION2(State::SetDomainName, name);

   current.DomainName = name;
}



bool
State::IsMemberOfWorkgroup() const
{
   return current.JoinedToWorkgroup;
}



void
State::SetIsMemberOfWorkgroup(bool yesNo)
{
   current.JoinedToWorkgroup = yesNo;
}



String
State::GetShortComputerName() const
{
   return current.ShortComputerName;
}



void
State::SetShortComputerName(const String& name)
{
   current.ShortComputerName = name;
   if (!name.empty())
   {
      current.NetbiosComputerName = Dns::HostnameToNetbiosName(name);
      SetFullComputerName();
   }
   else
   {
      // This avoids an assert in Dns::HostnameToNetbiosName and
      // Computer::ComposeFullDnsComputerName.  119901

      current.NetbiosComputerName = name;
      current.FullComputerName = name;
   }
}



bool
State::WasShortComputerNameChanged() const
{
   return
      original.ShortComputerName.icompare(current.ShortComputerName) != 0;
}



bool
State::WasNetbiosComputerNameChanged() const
{
   return
      original.NetbiosComputerName.icompare(current.NetbiosComputerName) != 0;
}



String
State::GetComputerDomainDnsName() const
{
   return current.ComputerDomainDnsName;
}



void
State::SetComputerDomainDnsName(const String& newName)
{
   current.ComputerDomainDnsName = newName;
   SetFullComputerName();
}



void
State::SetFullComputerName()
{
   current.FullComputerName =
      Computer::ComposeFullDnsComputerName(
         current.ShortComputerName,
            policyInEffect
         ?  current.PolicyDomainDnsName
         :  current.ComputerDomainDnsName);
}



bool
State::WasMembershipChanged() const
{
   if (current.DomainName.empty())
   {
      // this can happen when the domain name is not yet set or has been 
      // cleared by the user

      return true;
   }

   return
         (Dns::CompareNames(
            original.DomainName,
            current.DomainName) != DnsNameCompareEqual) // 97064
      || original.JoinedToWorkgroup != current.JoinedToWorkgroup;
}



bool
State::ChangesNeedSaving() const
{
   if (
         original.ComputerDomainDnsName.icompare(
             current.ComputerDomainDnsName) != 0
      || WasMembershipChanged()
      || WasShortComputerNameChanged()
      || SyncDNSNamesWasChanged())
   {
      return true;
   }

   return false;
}



bool
State::GetSyncDNSNames() const
{
   return current.SyncDNSNames;
}



void
State::SetSyncDNSNames(bool yesNo)
{
   current.SyncDNSNames = yesNo;
}



bool
State::SyncDNSNamesWasChanged() const
{
   return original.SyncDNSNames != current.SyncDNSNames;
}



// Prepend the domain name to the user name (making it a fully-qualified name
// in the form "domain\username") if the username does not appear to be an
// UPN, and the username does not appear to be fully-qualified already.
// 
// domainName - netbios or DNS domain name.
// 
// userName - user account name
//
// JonN 6/27/01 26151
//    Attempting to join domain with username "someone\" gives a cryptic error
//    returntype becomes HRESULT, userName becomes IN/OUT parameter
//

HRESULT
MassageUserName(const String& domainName, String& userName)
{
   LOG_FUNCTION(MassageUserName);
//   ASSERT(!userName.empty()); JonN 2/6/01 306520

   static const String UPN_DELIMITER(L"@");
   if (userName.find(UPN_DELIMITER) != String::npos)
   {
      // assume the name is a UPN: foouser@bar.com.  This is not
      // necessarily true, as account names may contain an '@' symbol.
      // If that's the case, then they had better fully-qualify the name
      // as domain\foo@bar....

      return S_OK;
   }

   if (!domainName.empty() && !userName.empty())
   {
      static const String DOMAIN_DELIMITER(L"\\");
      size_t pos = userName.find(DOMAIN_DELIMITER);

      if (pos == String::npos)
      {
         userName = domainName + DOMAIN_DELIMITER + userName;
      }
      //
      // JonN 6/27/01 26151
      // Attempting to join domain with username "someone\" gives a cryptic error
      //
      else if (pos == userName.length() - 1)
      {
         return HRESULT_FROM_WIN32(NERR_BadUsername);
      }
   }

   return S_OK;
}



// Calls NetJoinDomain.  The first call specifies the create computer account
// flag.  If that fails with an access denied error, the call is repeated
// without the flag.  (This is to cover the case where the domain
// administrator may have pre-created the computer account.)
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.
//
// domain - domain to join.  May be the netbios or DNS domain name.
//
// username - user account to be used.  If empty, the currently logged in
// user's context is used.
//
// password - password for the above account.  May be empty.

HRESULT
JoinDomain(
   HWND                   dialog,
   const String&          domainName,           
   const String&          username,             
   const EncryptedString& password,             
   const String&          computerDomainDnsName, // 106601
   bool                   deferSpn)
{
   LOG_FUNCTION(JoinDomain);
   ASSERT(!domainName.empty());
   ASSERT(Win::IsWindow(dialog));

   Win::CursorSetting cursor(IDC_WAIT);

   // first attempt without create flag in case account was precreated
   // 105306

   DWORD flags =
            NETSETUP_JOIN_DOMAIN
         |  NETSETUP_DOMAIN_JOIN_IF_JOINED
         |  NETSETUP_ACCT_DELETE;

   if (deferSpn)
   {
      flags |= NETSETUP_DEFER_SPN_SET;
   }

   HRESULT hr = MyNetJoinDomain(domainName, username, password, flags);

   if (FAILED(hr))
   {
      LOG(L"Retry with account create flag");

      flags |= NETSETUP_ACCT_CREATE;

      hr = MyNetJoinDomain(domainName, username, password, flags);
   }

   if (SUCCEEDED(hr))
   {
      popup.Info(
         dialog,
         String::format(
            IDS_DOMAIN_WELCOME,
            domainName.c_str()));

      HINSTANCE hNetWiz = LoadLibrary(c_szWizardFilename);
      if (hNetWiz) {
         HRESULT (*pfnClearAutoLogon)(VOID) = 
            (HRESULT (*)(VOID)) GetProcAddress(
               hNetWiz,
               "ClearAutoLogon"
            );

         if (pfnClearAutoLogon) {
            (*pfnClearAutoLogon)();
         }
 
         FreeLibrary(hNetWiz);
      }
   }
   else if (hr == Win32ToHresult(ERROR_DISK_FULL)) // 17367
   {
      popup.Error(
         dialog,
         String::format(IDS_DISK_FULL, domainName.c_str()));
   }
   // JonN 1/03/01 106601
   // When the dns suffix checkbox is unchecked,
   // domain join fails with a confusing message
   else if (hr == Win32ToHresult(ERROR_DS_COULDNT_UPDATE_SPNS)) // 106601
   {
      bool fWarnDnsSuffix = WarnDnsSuffix(domainName);
      popup.Error(
         dialog,
         String::format( (fWarnDnsSuffix)
                           ? IDS_JOIN_DOMAIN_COULDNT_UPDATE_SPNS_SUFFIX
                           : IDS_JOIN_DOMAIN_COULDNT_UPDATE_SPNS,
                          domainName.c_str(),
                          computerDomainDnsName.c_str()));
   }
   else // any other error
   {
      popup.Error(
         dialog,
         hr,
         String::format(IDS_JOIN_DOMAIN_FAILED, domainName.c_str()));
   }

   return hr;
}



// Changes the local computer's DNS domain suffix.
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.

HRESULT
SetDomainDnsName(HWND dialog)
{
   LOG_FUNCTION2(SetDomainDnsName, current.ComputerDomainDnsName);
   ASSERT(Win::IsWindow(dialog));

   HRESULT hr = 
      Win::SetComputerNameEx(
         ComputerNamePhysicalDnsDomain,
         current.ComputerDomainDnsName);

   if (FAILED(hr))
   {
      // 335055       
      popup.Error(
         dialog,
         hr,
         String::format(
            IDS_SET_DOMAIN_DNS_NAME_FAILED,
            current.ComputerDomainDnsName.c_str()));
   }

   return hr;
}



// Changes the local netbios computer name, and, if tcp/ip is installed,
// the local DNS hostname.
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.

HRESULT
SetShortName(HWND dialog)
{
   LOG_FUNCTION2(setShortName, current.ShortComputerName);
   ASSERT(!current.ShortComputerName.empty());

   HRESULT hr = S_OK;

   bool isTcpInstalled = networkingInstalled && IsTcpIpInstalled();
   if (isTcpInstalled)
   {
      // also sets the netbios name

      hr =
         Win::SetComputerNameEx(
            ComputerNamePhysicalDnsHostname,
            current.ShortComputerName);
   }
   else
   {
      String netbiosName =
         Dns::HostnameToNetbiosName(current.ShortComputerName);
      hr =
         Win::SetComputerNameEx(ComputerNamePhysicalNetBIOS, netbiosName);
   }

   // the only reason that this is likely to fail is if the user is not
   // a local administrator.  The other cases are that the machine is
   // in a hosed state.

   if (FAILED(hr))
   {
      popup.Error(
         dialog,
         hr,
         String::format(
            IDS_SHORT_NAME_CHANGE_FAILED,
            current.ShortComputerName.c_str()));
   }

   return hr;
}



// Returns true if a new netbios computer name has been saved, but the machine
// has not yet been rebooted.  In other words, true if the netbios computer
// name will change on next reboot.  417570

bool
ShortComputerNameHasChangedSinceReboot()
{
   LOG_FUNCTION(ShortComputerNameHasChangedSinceReboot());

   String active = Computer::GetActivePhysicalNetbiosName();
   String future = Computer::GetFuturePhysicalNetbiosName();

   return (active != future) ? true : false;
}



// Return true if all changes were successful, false if not.  Called when a
// machine is to be joined to a domain, or if a machine is changing membership
// from one domain to another.
//
// workgroup -> domain
// domain A -> domain B
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.

bool
State::DoSaveDomainChange(HWND dialog)
{
   LOG_FUNCTION(State::DoSaveDomainChange);
   ASSERT(Win::IsWindow(dialog));

   String          username;
   EncryptedString password;
   if (!RetrieveCredentials(dialog,
                            IDS_JOIN_CREDENTIALS,
                            username,
                            password))
   {
      return false;
   }

   HRESULT hr                   = S_OK; 
   bool    result               = true; 
   bool    joinFailed           = false;
   bool    changedSyncFlag      = false;
   bool    shortNameNeedsChange = false;
   bool    changedShortName     = false;
   bool    dnsSuffixNeedsChange = false;
   bool    changedDnsSuffix     = false;
   bool    isTcpInstalled       = networkingInstalled && IsTcpIpInstalled();

   do
   {
      //
      // JonN 6/27/01 26151
      // Attempting to join domain with username "someone\" gives a cryptic error
      //
      hr = MassageUserName(current.DomainName, username);
      if (FAILED(hr))
      {
         break;
      }

      // update the sync dns suffix flag, if necessary.  We do this before
      // calling NetJoinDomain, so that it will see the new flag and set the
      // DNS suffix accordingly.  This means if the join fails, we need to
      // undo the change to the flag.

      if (original.SyncDNSNames != current.SyncDNSNames)
      {
         hr = WriteSyncFlag(dialog, current.SyncDNSNames);
         if (SUCCEEDED(hr))
         {
            changedSyncFlag = true;
         }

         // we don't break on failure, as the flag is less consequential
         // than the joined state and computer name.
      }

      // update NV Hostname and NV Domain, if necessary.  This is required
      // before calling NetJoinDomain in order to fix bugs 31084 and 40496.
      // If the join fails, then we need to undo this change

      if (
            // short name changed since changes last saved in this session

            (original.ShortComputerName.icompare(
               current.ShortComputerName) != 0)
      
         or ShortComputerNameHasChangedSinceReboot() )
      {
         shortNameNeedsChange = true;
      }
         
      if (original.ComputerDomainDnsName.icompare(
         current.ComputerDomainDnsName) != 0 )
      {
         dnsSuffixNeedsChange = true;
      }

      // JonN 12/5/00 244762
      // NV Domain only applies when TCP/IP is present.
      if (isTcpInstalled && dnsSuffixNeedsChange)
      {
         RegistryKey key;
         hr = key.Open(HKEY_LOCAL_MACHINE,
                       TCPIP_PARAMS_KEY,
                       KEY_WRITE);
         BREAK_ON_FAILED_HRESULT(hr);
         hr = key.SetValue(NEW_SUFFIX_VALUE,
                           current.ComputerDomainDnsName);
         BREAK_ON_FAILED_HRESULT(hr);

         changedDnsSuffix = true;
      }

      hr =
         JoinDomain(
            dialog,
            current.DomainName,
            username,
            password,
            current.ComputerDomainDnsName,
            shortNameNeedsChange);
      if (FAILED(hr))
      {
         joinFailed = true;

         // JonN 12/5/00 244762
         // If we set NW Domain before the join attempt,
         // and the join failed, we need to undo that setting now.
         if (isTcpInstalled && changedDnsSuffix)
         {
            RegistryKey key;
            HRESULT hr2 = key.Open(HKEY_LOCAL_MACHINE,
                                   TCPIP_PARAMS_KEY,
                                   KEY_WRITE);
            ASSERT(SUCCEEDED(hr2));
            hr2 = key.SetValue(NEW_SUFFIX_VALUE,
                               original.ComputerDomainDnsName);
            ASSERT(SUCCEEDED(hr2));
         }

         // don't attempt to save any other changes.  If the machine is
         // already joined to a domain, changing the short name will cause the
         // netbios machine name to not match the machine account, and the
         // user will not be able to log in with a domain account.
         //
         // If the machine is not already joined to the domain, then it
         // is possible to change the short name and the dns suffix, and
         // emit a message that those things were changed even though
         // the join failed.

         break;
      }

      // At this point, the machine is joined to the new domain.  But, it will
      // have joined with the old netbios computer name.  So, if the user has
      // changed the name, or the name has been changed at all since the last
      // reboot, then we must rename the machine.
      //
      // ever get the feeling that NetJoinDomain is a poor API?

      if (shortNameNeedsChange)
      {
         // short name changed.

         // JonN 12/5/00 244762
         // We don't set NV Hostname until after the join succeeds.
         if (isTcpInstalled)
         {
            RegistryKey key;
            hr = key.Open(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY, KEY_WRITE);
            BREAK_ON_FAILED_HRESULT(hr);
            hr = key.SetValue(NEW_HOSTNAME_VALUE, current.ShortComputerName);
            BREAK_ON_FAILED_HRESULT(hr);

            changedShortName = true;
         }

         bool renameFailed = false;

         hr =
            MyNetRenameMachineInDomain(

               // We need to pass the hostname instead of the
               // netbios name here in order to get the correct DNS hostname
               // and SPN set on the computer object. See ntraid (ntbug9)
               // #128204

               current.ShortComputerName,
               username,
               password,
               NETSETUP_ACCT_CREATE);
         if (FAILED(hr))
         {
            renameFailed = true;

            // JonN 12/5/00 244762
            // If we set NV Hostname before the rename attempt,
            // and the rename failed, we need to undo that setting now.
            if (isTcpInstalled)
            {
               RegistryKey key;
               HRESULT hr2 = key.Open(HKEY_LOCAL_MACHINE,
                                      TCPIP_PARAMS_KEY,
                                      KEY_WRITE);
               ASSERT(SUCCEEDED(hr2));
               hr2 = key.SetValue(NEW_HOSTNAME_VALUE,
                                  original.ShortComputerName);
               ASSERT(SUCCEEDED(hr2));
            }

            // don't fail the whole operation 'cause the rename failed.
            // We make a big noise about how the join worked under the old
            // name.  We need to succeed with the operation as a whole so
            // the change dialog will close and the joined state of the
            // machine is refreshed.  Otherwise, the change dialog stays up,
            // the domain name has changed but we don't realize it, so if
            // the user types a new domain name in the still open change
            // dialog that is the same as the domain the machine was joined
            // to (matching the stale state), we don't attempt to join
            // again.  Whew.

            // JonN 1/03/01 106601
            // When the dns suffix checkbox is unchecked,
            // domain join fails with a confusing message
            if (hr == Win32ToHresult(ERROR_DS_COULDNT_UPDATE_SPNS)) // 106601
            {
               bool fWarnDnsSuffix = WarnDnsSuffix(current.DomainName);
               popup.Error(
                           dialog,
                           String::format( (fWarnDnsSuffix)
                              ? IDS_RENAME_JOINED_WITH_OLD_NAME_COULDNT_UPDATE_SPNS_SUFFIX
                              : IDS_RENAME_JOINED_WITH_OLD_NAME_COULDNT_UPDATE_SPNS,
                           current.ShortComputerName.c_str(),
                           current.DomainName.c_str(),
                           original.ShortComputerName.c_str(),
                           current.ComputerDomainDnsName.c_str()));
            } else {
               popup.Error(
                  dialog,
                  hr,
                  String::format(
                     IDS_RENAME_FAILED_JOINED_WITH_OLD_NAME,
                     current.ShortComputerName.c_str(),
                     current.DomainName.c_str(),
                     original.ShortComputerName.c_str()));
            }


            hr = S_FALSE;
         }

         // don't change the hostname if the rename failed, as this will
         // prevent the user from logging in as the new computer name will not
         // match the sam account name.

         if (!renameFailed)     // 401355
         {
            // now set the new hostname and netbios name

            hr = SetShortName(dialog);

            // this had better work...

            ASSERT(SUCCEEDED(hr));
         }
      }

      // NetJoinDomain will change the DNS suffix, if it succeeded.  If it
      // failed, then we shouldn't change the suffix anyway.  421824

      // this is only true if the sync flag is true: otherwise, we need to
      // save the suffix when join succeeds.

      if (
            !current.SyncDNSNames
         && dnsSuffixNeedsChange
         && !changedDnsSuffix)
      {
         hr = SetDomainDnsName(dialog);

         // this had better work...

         ASSERT(SUCCEEDED(hr));
      }
   }
   while (0);

   if (joinFailed)
   {
      HRESULT hr2 = S_OK;
      if (changedSyncFlag)
      {
         // change the sync flag back to its original state.

         hr2 = WriteSyncFlag(dialog, original.SyncDNSNames);

         // if we can't restore the flag (unlikely), then that's just tough
         // potatos.

         ASSERT(SUCCEEDED(hr2));
      }

   // JonN 11/27/00 233783 JoinDomain reports its own errors
   } else if (FAILED(hr))
   {
      popup.Error(dialog, hr, IDS_JOIN_FAILED);
   }

   return SUCCEEDED(hr) ? true : false;
}



// Call NetUnjoinDomain, first with the account delete flag, if that fails
// then again without it (which almost always "works").  If the first
// attempt fails, but the second succeeds, raise a message to the user
// informing him of the orphaned computer account.
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.
//
// domain - domain to unjoin, i.e. the domain the machine is currently
// a member of.
//
// username - user account to be used.  If empty, the currently logged in
// user's context is used.
//
// password - password for the above account.  May be empty.

HRESULT
UnjoinDomain(
   HWND                   dialog,
   const String&          domain,  
   const String&          username,
   const EncryptedString& password)
{
   LOG_FUNCTION(UnjoinDomain);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(!domain.empty());

   // username and password may be empty

   Win::CursorSetting cursor(IDC_WAIT);

   HRESULT hr = S_OK;

   do
   {
      hr =
         MyNetUnjoinDomain(
            username,
            password,
            NETSETUP_ACCT_DELETE);
      if (SUCCEEDED(hr))
      {
         break;
      }

      // try again: not trying to delete the computer account.  If the
      // user cancelled the credential dialog from the second attempt, then
      // this attempt will use the current context.

      LOG(L"Calling NetUnjoinDomain again, w/o account delete");

      hr =
         MyNetUnjoinDomain(
            username,
            password,
            0);
      BREAK_ON_FAILED_HRESULT(hr);

      // if we make it here, then the attempt to unjoin and remove the
      // account failed, but the attempt to unjoin and abandon the account
      // succeeded.  So we tell the user about the abandonment, and hope
      // they feel really guilty about it.

      // Don't hassle them.  They just panic.  95386

      LOG(   
         String::format(
            IDS_COMPUTER_ACCOUNT_ORPHANED,
            domain.c_str()));

      // Win::MessageBox(
      //    dialog,
      //    String::format(
      //       IDS_COMPUTER_ACCOUNT_ORPHANED,
      //       domain.c_str()),
      //    String::load(IDS_APP_TITLE),
      //    MB_OK | MB_ICONWARNING);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         dialog,
         hr,
         String::format(
            IDS_UNJOIN_FAILED,
            domain.c_str()));
   }

   return hr;
}



// Return true if all changes were successful, false if not.  Called when the
// current domain membership is to be severed, or when changing from one
// workgroup to another.
// 
// domain -> workgroup
// workgroup A -> workgroup B
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.

bool
State::DoSaveWorkgroupChange(HWND dialog)
{
   LOG_FUNCTION(State::DoSaveWorkgroupChange);
   ASSERT(Win::IsWindow(dialog));

   HRESULT hr              = S_OK; 
   bool    result          = true; 
   bool    unjoinFailed    = false;
   bool    changedSyncFlag = false;

   do
   {
      // update the sync dns suffix flag, if the user changed it.  Do this
      // before calling NetUnjoinDomain, which will clear the dns suffix
      // for us.

      if (original.SyncDNSNames != current.SyncDNSNames)
      {
         hr = WriteSyncFlag(dialog, current.SyncDNSNames);
         if (FAILED(hr))
         {
            result = false;
         }
         else
         {
            changedSyncFlag = true;
         }

         // we don't break on failure, as the flag is less consequential
         // than the joined state and computer name.
      }

      // only unjoin if we were previously joined to a domain

      if (!original.JoinedToWorkgroup and networkingInstalled)
      {
         // get credentials for removing the computer account

         String          username;
         EncryptedString password;
         if (!RetrieveCredentials(dialog,
                                  IDS_UNJOIN_CREDENTIALS,
                                  username,
                                  password))
         {
            result = false;
            unjoinFailed = true;
            break;
         }

         //
         // JonN 6/27/01 26151
         // Attempting to join domain with username "someone\" gives a cryptic error
         //
         hr = MassageUserName(original.DomainName, username);
         if (FAILED(hr))
         {
            break;
         }

         hr =
            UnjoinDomain(
               dialog,
               original.DomainName,
               username,
               password);

         // Don't try to change anything else, especially the hostname.  If
         // the unjoin failed, and we change the name locally, this will
         // prevent the user from logging in, as the new computer name will
         // not match the computer account name in the domain.

         if (FAILED(hr))
         {
            result = false;
            unjoinFailed = true;
            break;
         }
      }

      // join the workgroup

      hr = MyNetJoinDomain(current.DomainName, String(), EncryptedString(), 0);
      if (FAILED(hr))
      {
         // this is extremely unlikely to fail, and if it did, the
         // workgroup would simply be "WORKGROUP"

         result = false;
         popup.Error(
            dialog,
            hr,
            String::format(
               IDS_JOIN_WORKGROUP_FAILED,
               current.DomainName.c_str()));

         break;
      }

      popup.Info(
         dialog,
         String::format(
            IDS_WORKGROUP_WELCOME,
            current.DomainName.c_str()));

      // change the host name, if the user has changed it.

      if (
         original.ShortComputerName.icompare(
            current.ShortComputerName) != 0)
      {
         hr = SetShortName(dialog);
         if (FAILED(hr))
         {
            result = false;
         }
      }

      // change the domain name, if the user changed it.

      if (
         original.ComputerDomainDnsName.icompare(
            current.ComputerDomainDnsName) != 0 )
      {
         hr = SetDomainDnsName(dialog);
         if (FAILED(hr))
         {
            result = false;
         }
      }
   }
   while (0);

   if (unjoinFailed and changedSyncFlag)
   {
      // change the sync flag back to its original state.

      hr = WriteSyncFlag(dialog, original.SyncDNSNames);

      // if we can't restore the flag (unlikely), then that's just tough
      // potatos.

      ASSERT(SUCCEEDED(hr));
   }

   return result;
}



// Return true if all changes succeeded, false otherwise.  Called only
// when domain membership is not to be changed.
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.

bool
State::DoSaveNameChange(HWND dialog)
{
   LOG_FUNCTION(State::DoSaveNameChange);
   ASSERT(Win::IsWindow(dialog));

   bool result = true;
   HRESULT hr = S_OK;

   do
   {
      // change the hostname, if the user has made changes

      if (
         original.ShortComputerName.icompare(
            current.ShortComputerName) != 0)
      {
         if (!original.JoinedToWorkgroup and networkingInstalled)
         {
            // machine is joined to a domain -- we need to rename the
            // machine's domain account

            String          username;
            EncryptedString password;
            if (!RetrieveCredentials(dialog,
                                     IDS_RENAME_CREDENTIALS,
                                     username,
                                     password))
            {
               result = false;
               break;
            }

            //
            // JonN 6/27/01 26151
            // Attempting to join domain with username "someone\" gives a cryptic error
            //
            hr = MassageUserName(current.DomainName, username);
            if (FAILED(hr))
            {
               break;
            }

            hr =
               MyNetRenameMachineInDomain(

                  // We need to pass the full hostname instead of just the
                  // netbios name here in order to get the correct DNS
                  // hostname and SPN set on the computer object. See ntraid
                  // (ntbug9) #128204

                  current.ShortComputerName,
                  username,
                  password,
                  NETSETUP_ACCT_CREATE);
            if (FAILED(hr))
            {
               result = false;
               // JonN 1/03/01 106601
               // When the dns suffix checkbox is unchecked,
               // domain join fails with a confusing message
               if (hr == Win32ToHresult(ERROR_DS_COULDNT_UPDATE_SPNS)) // 106601
               {
                  bool fWarnDnsSuffix = WarnDnsSuffix(current.DomainName);
                  popup.Error(
                              dialog,
                              String::format( (fWarnDnsSuffix)
                                   ? IDS_RENAME_COULDNT_UPDATE_SPNS_SUFFIX
                                   : IDS_RENAME_COULDNT_UPDATE_SPNS,
                                 current.ShortComputerName.c_str(),
                                 current.DomainName.c_str(),
                                 current.ComputerDomainDnsName.c_str()));
               } else {
                  popup.Error(
                     dialog,
                     hr,
                     String::format(
                        IDS_RENAME_FAILED,
                        current.ShortComputerName.c_str()));
               }
            }

            // Don't try to change anything else, especially the netbios name.
            // If the rename failed, and we change the name locally, this will
            // prevent the user from logging in, as the new computer name will
            // not match the computer account name in the domain.

            BREAK_ON_FAILED_HRESULT(hr);
         }

         // Set the dns hostname and the netbios name.  If we called
         // NetRenameMachineInDomain, this may redundantly set netbios name
         // (as NetRenameMachineInDomain calls SetComputerNameEx with the
         // netbios name).

         hr = SetShortName(dialog);

         // Since NetRenameMachineInDomain calls SetComputerNameEx, if that
         // failed, the rename would also have failed.  So our 2nd call to
         // SetComputerNameEx in SetShortName is almost certain to succeed.
         // If it does fail, we're not going to attempt to roll back the
         // rename.

         if (FAILED(hr))
         {
            result = false;
            break;
         }
      }

      // update the sync dns suffix flag, if the user changed it

      if (original.SyncDNSNames != current.SyncDNSNames)
      {
         hr = WriteSyncFlag(dialog, current.SyncDNSNames);
         if (FAILED(hr))
         {
            result = false;
         }
      }

      // change the domain name, if the user changed it.

      if (
         original.ComputerDomainDnsName.icompare(
            current.ComputerDomainDnsName) != 0 )
      {
         hr = SetDomainDnsName(dialog);
         if (FAILED(hr))
         {
            result = false;
         }
      }
   }
   while (0);

   return result;
}



bool
State::SaveChanges(HWND dialog)
{
   LOG_FUNCTION(State::SaveChanges);
   ASSERT(Win::IsWindow(dialog));

   // Changes to domain membership are made first, then to the computer name.

   //
   // workgroup -> domain
   // domain A -> domain B
   //

   if (
         (original.JoinedToWorkgroup && !current.JoinedToWorkgroup)
      ||
         (  !original.JoinedToWorkgroup
         && !current.JoinedToWorkgroup
         && original.DomainName.icompare(current.DomainName) != 0) )
   {
      return DoSaveDomainChange(dialog);
   }

   //
   // domain -> workgroup
   // workgroup A -> workgroup B
   //

   else if (
         !original.JoinedToWorkgroup && current.JoinedToWorkgroup
      ||
         original.JoinedToWorkgroup && current.JoinedToWorkgroup
      && original.DomainName.icompare(current.DomainName) != 0)

   {
      return DoSaveWorkgroupChange(dialog);
   }

   //
   // name change only
   //

   ASSERT(original.JoinedToWorkgroup == current.JoinedToWorkgroup);
   ASSERT(original.DomainName == original.DomainName);

   return DoSaveNameChange(dialog);
}



void
State::SetChangesMadeThisSession(bool yesNo)
{
   LOG_FUNCTION2(
      State::SetChangesMadeThisSession,
      yesNo ? L"true" : L"false");

   mustReboot = yesNo;
}



bool
State::ChangesMadeThisSession() const
{
   LOG_FUNCTION2(
      State::ChangesMadeThisSession,
      mustReboot ? L"true" : L"false");

   return mustReboot;
}



String
State::GetNetbiosComputerName() const
{
   return current.NetbiosComputerName;
}



String
State::GetOriginalShortComputerName() const
{
   return original.ShortComputerName;
}



DSROLE_OPERATION_STATE
GetDsRoleChangeState()
{
   LOG_FUNCTION(GetDsRoleChangeState);

   DSROLE_OPERATION_STATE result = ::DsRoleOperationIdle;
   DSROLE_OPERATION_STATE_INFO* info = 0;
   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr))
   {
      if (info)
      {
         result = info->OperationState;
         ::DsRoleFreeMemory(info);
      }
   }

   return result;
}



bool
IsUpgradingDc()
{
   LOG_FUNCTION(IsUpgradingDc);

   bool isUpgrade = false;
   DSROLE_UPGRADE_STATUS_INFO* info = 0;

   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr))
   {
      isUpgrade = ( (info->OperationState & DSROLE_UPGRADE_IN_PROGRESS) ? true : false );
      ::DsRoleFreeMemory(info);

   }

   return isUpgrade;
}



// Evaluate a list of preconditions that must be met before a name change can
// be committed.  Return a string describing the first unmet condition, or
// an empty string if all conditions are met.
// 
// These preconditions are a subset of those checked before enabling the
// button to allow the user to enter changes.  The conditions not checked here
// are those that cannot be changed while the ui is running (logged on as
// local admin, machine is DC)
// 
// 389646

String
CheckPreconditions()
{
   LOG_FUNCTION(CheckPreconditions);

   String result;

   do
   {
      // could have started dcpromo after opening netid

      if (IsDcpromoRunning())
      {
         result = String::load(IDS_PRECHK_DCPROMO_RUNNING);
         break;
      }
      else
      {
         // this test is redundant if dcpromo is running, so only perform
         // it when dcpromo is not running.

         if (IsUpgradingDc())
         {
            result = String::load(IDS_PRECHK_MUST_COMPLETE_DCPROMO);
         }
      }

      // could have installed cert svc after opening netid

      NTService certsvc(L"CertSvc");
      if (certsvc.IsInstalled())
      {
         // sorry- renaming cert issuers invalidates their certs.
         result = String::load(IDS_PRECHK_CANT_RENAME_CERT_SVC);
      }

      // could have completed dcpromo after opening netid

      switch (GetDsRoleChangeState())
      {
         case ::DsRoleOperationIdle:
         {
            // do nothing
            break;
         }
         case ::DsRoleOperationActive:
         {
            // a role change operation is underway
            result = String::load(IDS_PRECHK_ROLE_CHANGE_IN_PROGRESS);
            break;
         }
         case ::DsRoleOperationNeedReboot:
         {
            // a role change has already taken place, need to reboot before
            // attempting another.
            result =  String::load(IDS_PRECHK_ROLE_CHANGE_NEEDS_REBOOT);
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
      if (!result.empty())
      {
         break;
      }

      // could have installed/uninstalled networking after opening
      // netid

      // re-evaluate this here again, which will be globally visible.

      networkingInstalled = IsNetworkingInstalled();

      State& state = State::GetInstance();
      if (!state.IsNetworkingInstalled() && !state.IsMemberOfWorkgroup())
      {
         // domain members need to be able to reach a dc
         result = String::load(IDS_PRECHK_NETWORKING_NEEDED);
      }
   }
   while (0);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\add_dlg.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    Add_Dlg.hxx

    This File contains the definitions for the various Add dialogs


    FILE HISTORY:
	Johnl	13-Sep-1991	Created

*/
#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
    #include <ntsam.h>
    #include <ntlsa.h>
}

#define INCL_NET
#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_NETLIB
#define INCL_NETGROUP
#define INCL_NETUSER
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>
#include <dbgstr.hxx>

#include <maskmap.hxx>

#include <perm.hxx>
#include <accperm.hxx>
#include <subject.hxx>
#include <helpnums.h>

#include <subjlb.hxx>
#include <permdlg.hxx>
#include <ntacutil.hxx>

#include <security.hxx>
#define SECURITY_EDITOR
#include <usrbrows.hxx>

#include <add_dlg.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>


/*******************************************************************

    NAME:	ADD_DIALOG::ADD_DIALOG

    SYNOPSIS:	Constructor for the basic ADD_DIALOG, calls out to virtual
		Fill and Remove.

    ENTRY:	pszDialogName - Name of dialog in resource file
		hwndParent - Window parent
		pchResType - Type of resource
		pchResName - Name of resource
		pslRemoveSubjList - List of subjects that should be
			removed from the Add listbox
		pchEnumFromLocation - Where to get the users from

    NOTES:

    HISTORY:
	Johnl	13-Sep-1991	Created

********************************************************************/


ADD_DIALOG::ADD_DIALOG( const TCHAR * pszDialogName,
			HWND hwndParent,
			const TCHAR * pchResType,
			const TCHAR * pchResName,
                        const TCHAR * pszHelpFileName,
                        ULONG       * ahcHelp,
			const TCHAR * pchDialogTitle,
			LOCATION & EnumLocation )
    : PERM_BASE_DLG( pszDialogName,
		     hwndParent,
		     pchDialogTitle,
		     pchResType,
		     pchResName,
		     pszHelpFileName,
                     ahcHelp ),
      _lbSubjects( this, LB_ADD_SUBJECT_LISTBOX ),
      _buffLBSelection( 0 )
{
    if ( QueryError() != NERR_Success )
	return ;

    if ( !_buffLBSelection )
    {
	ReportError( _buffLBSelection.QueryError() ) ;
	return ;
    }

    APIERR err ;
    if ( ( err = _lbSubjects.Fill( EnumLocation ))   != NERR_Success )
    {
	ReportError( err ) ;
	return ;
    }
}

/*******************************************************************

    NAME:	ADD_DIALOG::RemoveSubject

    SYNOPSIS:	This dialog returns the nth selection of the subject
		listbox.  The caller is subsequently responsible for
		deleting the removed subject

    ENTRY:	iSelection - index of the selected item to return

    EXIT:

    RETURNS:	A pointer to the SUBJECT requested (that should be added
		to the main permission dialog).

    NOTES:	You can only remove each selection once, an assertion error
		will occur if you try and remove an item more then once.

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

SUBJECT * ADD_DIALOG::RemoveSubject( int iSelection )
{
    UIASSERT( iSelection < QuerySelectedSubjectCount() ) ;
    int * aiSelection = (INT *) _buffLBSelection.QueryPtr() ;
    SUBJ_LBI * pSubjLBI = (SUBJ_LBI*)_lbSubjects.QueryItem( aiSelection[iSelection]) ;
    SUBJECT  * pSubj = pSubjLBI->QuerySubject() ;

    /* If the extracted subject is NULL, then it was most likely removed
     * twice, which is a no-no.
     */
    UIASSERT( pSubj != NULL ) ;

    /* Set the subject pointer to NULL so when the LBI is destructed, the
     * subject won't be deleted.
     */
    pSubjLBI->SetSubject( NULL ) ;

    return pSubj ;
}

/*******************************************************************

    NAME:	ADD_DIALOG::OnOK

    SYNOPSIS:	Typical OnOK.  Fills in the selection buffer with the indices
		of all of the items the user selected from the listbox.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

BOOL ADD_DIALOG::OnOK( void )
{
    APIERR err ;

    if ( _lbSubjects.QuerySelCount() > 0 )
    {
	/* Fill the selection buffer with the indices of the selected items
	 */
	if ( ( err = _buffLBSelection.Resize(sizeof(INT) * _lbSubjects.QuerySelCount()) ) ||
	     ( err = _lbSubjects.QuerySelItems( (INT *) _buffLBSelection.QueryPtr(),
						_buffLBSelection.QuerySize() / sizeof(INT))) )
	{
	    MsgPopup( this, (MSGID) err, MPSEV_ERROR ) ;
	    return TRUE ;
	}
    }

    Dismiss( TRUE ) ;
    return TRUE ;
}

ULONG ADD_DIALOG::QueryHelpContext( void )
{
    return QueryHelpArray()[HC_ADD_USER_DLG] ;
}

/*******************************************************************

    NAME:	ADD_PERM_DIALOG::ADD_PERM_DIALOG

    SYNOPSIS:	Add permission dialog constructor

    ENTRY:

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

ADD_PERM_DIALOG::ADD_PERM_DIALOG( const TCHAR * pszDialogName,
			HWND hwndParent,
			const TCHAR * pchResType,
			const TCHAR * pchResName,
                        const TCHAR * pszHelpFileName,
                        ULONG       * ahcHelp,
			const TCHAR * pchDialogTitle,
			MASK_MAP * pmaskmapPermNames,
			LOCATION & EnumLocation,
			const TCHAR * pszDefaultPermName  )
    : ADD_DIALOG( pszDialogName,
		  hwndParent,
		  pchResType,
		  pchResName,
                  pszHelpFileName,
                  ahcHelp,
		  pchDialogTitle,
		  EnumLocation ),
      _cbPermNames( this, CB_ADD_PERMNAME ),
      _pmaskmapPermNames( pmaskmapPermNames )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( _pmaskmapPermNames != NULL ) ;
    UIASSERT( _pmaskmapPermNames->QueryError() == NERR_Success ) ;

    /* Fill the combo-box with all of the common permission names.
     */
    BOOL fFromBeginning = TRUE ;
    BOOL fMoreData ;
    NLS_STR nlsPermName( 40 ) ;
    APIERR err ;

    while ( (err = pmaskmapPermNames->EnumStrings( &nlsPermName,
						   &fMoreData,
						   &fFromBeginning,
						   PERMTYPE_GENERAL ))
		   == NERR_Success &&
	    fMoreData )
    {
	if ( _cbPermNames.AddItem( nlsPermName.QueryPch() ) < 0 )
	{
	    ReportError( (APIERR) ERROR_NOT_ENOUGH_MEMORY ) ;
	    return ;
	}
    }

    if ( err != NERR_Success )
    {
	ReportError( err ) ;
	return ;
    }

    /* Select the default permission name as the currently selected item.
     */
    INT iDefaultPos = _cbPermNames.FindItemExact( pszDefaultPermName ) ;
    if ( iDefaultPos < 0 )
    {
	/* Ooops, somebody messed up so select the first item as the default
	 */
	UIASSERT( FALSE ) ;
	iDefaultPos = 0 ;
    }
    _cbPermNames.SelectItem( iDefaultPos ) ;
}

/*******************************************************************

    NAME:	ADD_PERM_DIALOG::QueryPermBitMask

    SYNOPSIS:	Gets the bitfield associated with the current permission
		name selection

    ENTRY:	pPermBits - bitfield that receives mask

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	18-Sep-1991	Created

********************************************************************/

APIERR ADD_PERM_DIALOG::QueryPermBitMask( BITFIELD * pPermBits )
{
    NLS_STR nlsPermName( 48 ) ;
    APIERR err ;
    if ( ( err = nlsPermName.QueryError() ) != NERR_Success ||
	 ( err = _cbPermNames.QueryItemText( &nlsPermName ))  )
    {
	return err ;
    }

    err = _pmaskmapPermNames->StringToBits( nlsPermName, pPermBits, PERMTYPE_GENERAL ) ;

    ASSERT( err != ERROR_NO_ITEMS ) ;

    return err ;
}


/*******************************************************************

    NAME:	SED_NT_USER_BROWSER_DIALOG::SED_NT_USER_BROWSER_DIALOG

    SYNOPSIS:	Regular constructor destructor the this class

    ENTRY:	hwndOwner - Owner window handle
		pszServeResourceLivesOn - Server name ("\\server") the
		    resource we are focused on resides (or NULL if local)
		pmaskmapGenPerms - Pointer to permissions maskmap, used
		    for filling in the permname combo
		fIsContainer - TRUE if we are looking at a container, FALSE
		    otherwise.	Determines what ALIASes to show
		pszDefaultPermName - Default permission name to select in the
		    combo.  Must be a general permission in the access mask

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	11-Mar-1992	Created

********************************************************************/


SED_NT_USER_BROWSER_DIALOG::SED_NT_USER_BROWSER_DIALOG(
			    HWND	  hwndOwner,
			    const TCHAR * pszServerResourceLivesOn,
			    MASK_MAP	* pmaskmapGenPerms,
			    BOOL	  fIsContainer,
			    const TCHAR * pszDefaultPermName,
                            const TCHAR * pszHelpFileName,
                            ULONG       * ahcHelp )
    : NT_USER_BROWSER_DIALOG( USRBROWS_SED_DIALOG_NAME,
			      hwndOwner,
			      pszServerResourceLivesOn,
                              ahcHelp[HC_ADD_USER_DLG],
			      fIsContainer ? USRBROWS_SHOW_ALL |
					     USRBROWS_INCL_ALL
					   :
					     USRBROWS_SHOW_ALL |
					     (USRBROWS_INCL_ALL &
					      ~USRBROWS_INCL_CREATOR),
                              pszHelpFileName,
                              ahcHelp[HC_ADD_USER_MEMBERS_GG_DLG],
                              ahcHelp[HC_ADD_USER_MEMBERS_LG_DLG],
                              ahcHelp[HC_ADD_USER_SEARCH_DLG] ),
      _pmaskmapGenPerms( pmaskmapGenPerms ),
      _cbPermNames( this, CB_PERMNAMES )
{
    if ( QueryError() )
	return ;

    ASSERT( pmaskmapGenPerms != NULL ) ;


    BOOL fFromBeginning = TRUE ;
    BOOL fMoreData ;
    NLS_STR nlsPermName( 48 ) ;
    APIERR err ;

    while ( (err = pmaskmapGenPerms->EnumStrings( &nlsPermName,
						  &fMoreData,
						  &fFromBeginning,
						  PERMTYPE_GENERAL ))
		   == NERR_Success &&
	    fMoreData )
    {
	if ( _cbPermNames.AddItem( nlsPermName.QueryPch() ) < 0 )
	{
	    ReportError( (APIERR) ERROR_NOT_ENOUGH_MEMORY ) ;
	    return ;
	}
    }

    if ( err != NERR_Success )
    {
	ReportError( err ) ;
	return ;
    }

    /* Select the default permission name as the currently selected item.
     */
    if ( pszDefaultPermName != NULL )
    {
	INT iDefaultPos = _cbPermNames.FindItemExact( pszDefaultPermName ) ;
	if ( iDefaultPos < 0 )
	{
	    /* Ooops, somebody messed up so select the first item as the default
	     */
	    DBGEOL("SED_NT_USER_BROWSER_DIALOG::ct - Bad default permission name - " << pszDefaultPermName ) ;
	    iDefaultPos = 0 ;
	}
	_cbPermNames.SelectItem( iDefaultPos ) ;
    }
    else
    {
	_cbPermNames.SelectItem( 0 ) ;
    }
}

SED_NT_USER_BROWSER_DIALOG::~SED_NT_USER_BROWSER_DIALOG()
{
    _pmaskmapGenPerms = NULL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netid\state.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Tab state
// 
// 3-11-98 sburns



#ifndef STATE_HPP_INCLUDED
#define STATE_HPP_INCLUDED

extern TCHAR const c_szWizardFilename[];



String
CheckPreconditions();



// Returns the dc role change status of the machine.

DSROLE_OPERATION_STATE
GetDsRoleChangeState();



// Return false if the machine is undergoing a DC upgrade, true otherwise.
// 388578

bool
IsUpgradingDc();






// Singleton state of the UI.

class State
{
   public:

   static
   void
   Delete();

   static
   State&
   GetInstance();

   static
   void
   Init();

   static
   void
   Refresh();

   bool
   ChangesNeedSaving() const;

   bool
   IsMachineDc() const;

   bool
   IsMemberOfWorkgroup() const;

   bool
   IsNetworkingInstalled() const;

   void
   SetIsMemberOfWorkgroup(bool yesNo);

   String
   GetComputerDomainDnsName() const;

   void
   SetComputerDomainDnsName(const String& newName);

   bool
   ComputerDomainDnsNameWasChanged() const;

   String
   GetFullComputerName() const;

   String
   GetNetbiosComputerName() const;

   String
   GetShortComputerName() const;

   void
   SetShortComputerName(const String& name);

   bool
   WasShortComputerNameChanged() const;

   bool
   WasNetbiosComputerNameChanged() const;

   String
   GetOriginalShortComputerName() const;

   String
   GetDomainName() const;

   void
   SetDomainName(const String& name);

   bool
   WasMembershipChanged() const;

   bool
   GetSyncDNSNames() const;

   void
   SetSyncDNSNames(bool yesNo);

   bool
   SyncDNSNamesWasChanged() const;

   bool
   SaveChanges(HWND dialog);

   // indicates that changes have been made in this session.

   bool
   ChangesMadeThisSession() const;

   void
   SetChangesMadeThisSession(bool yesNo);

   // indicates that changes have been made in this or prior sessions, or
   // the computer name has been changed by some other means than ourselves.

   bool
   NeedsReboot() const;

   private:

   // Init() actually builds the instance
   State();

   // Delete destroys the instance
   ~State();

   // not implemented:  no copying allowed
   State(const State&);
   const State& operator=(const State&);

   bool
   DoSaveDomainChange(HWND dialog);

   bool
   DoSaveWorkgroupChange(HWND dialog);

   bool
   DoSaveNameChange(HWND dialog);

   void
   SetFullComputerName();
};



#endif   // STATE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\fmxproc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    fmxproc.cxx
    This file contains FMExtensionProcW.

    FILE HISTORY:
        rustanl     02-May-1991     Created
        Yi-HsinS    12-Sept-1991    Make it fit into the real world
        Yi-HsinS    12-Sept-1991    Unicode Work
        JonN        10-July-2000    130459: Disabled this capability for _WIN64;
                                    the FMExtensionProcW interface is not
                                    64-bit compatible.

*/
#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
    #include <ntioapi.h>
}

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#define INCL_NETCONS
#define INCL_NETUSER
#define INCL_NETGROUP
#define INCL_NETACCESS
#define INCL_NETAUDIT
#define INCL_NETUSE
#include <lmui.hxx>

extern "C"
{
    #include <helpnums.h>
    #include <netlib.h>
    #include <mpr.h>
    #include <npapi.h>
}
#include <wfext.h>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MENU
#include <blt.hxx>
#include <fontedit.hxx>
#include <dbgstr.hxx>
#include <string.hxx>
#include <strnumer.hxx>
#include <uibuffer.hxx>
#include <uitrace.hxx>
#include <lmobj.hxx>
#include <lmodev.hxx>
#include <security.hxx>
#include <netname.hxx>
#include <maskmap.hxx>
#include <fmx.hxx>
#include <fsenum.hxx>
#include <uiassert.hxx>
#include <errmap.hxx>

#include <permstr.hxx>

#include <accperm.hxx>
#include <ipermapi.hxx>
#include <permprg.hxx>

#include <ntfsacl.hxx>


// this must lack the SZ for string concat to work
#define FMXPROC "FMExtensionProcW:  "

// This load-by-name is permissible, since BLT never sees it
#define FMX_MENU SZ("FMXMenu")

EXT_BUTTON aExtButton[] = { IDM_PERMISSION, 0, 0 } ;


extern HINSTANCE hModule; // Exported from libmain

APIERR CheckMenuAccess( HWND          hwndFMX,
                        BOOL *        pfPerm,
                        BOOL *        pfAudit,
                        BOOL *        pfOwner ) ;

//
//  Help context array.  Do lookups by using the following formula:
//
//       IsNT << 2 |  IsDir << 1 | !IsPerms
//
//  And use the index for the lookup
//
ULONG ahc[8] = {   HC_SED_LM_FILE_PERMS_DLG,
                   HC_SED_LM_FILE_AUDITS_DLG,
                   HC_SED_LM_DIR_PERMS_DLG,
                   HC_SED_LM_DIR_AUDITS_DLG,
                   HC_SED_NT_FILE_PERMS_DLG,
                   HC_SED_NT_FILE_AUDITS_DLG,
                   HC_SED_NT_DIR_PERMS_DLG,
                   HC_SED_NT_DIR_AUDITS_DLG
               } ;
inline ULONG LookupHC( BOOL fIsNT, BOOL fIsDir, BOOL fIsPerms )
{
    return ahc[(fIsNT << 2) |  (fIsDir << 1) | !fIsPerms] ;
}

/*******************************************************************

    NAME:       FMExtensionProcW

    SYNOPSIS:   File Manager Extension Procedure

    ENTRY:      hwnd        See FMX spec for details
                wEvent
                lParam

    EXIT:       See FMX spec for details

    RETURNS:    See FMX spec for details

    NOTES:

    HISTORY:
        rustanl     02-May-1991     Created
        yi-hsins    12-Sept-1991    Make it fit the real world
        JohnL       21-Jan-1991     Added Permissions stuff
        JonN        10-July-2000    130459: Disabled this capability for _WIN64;
                                    the FMExtensionProcW interface is not
                                    64-bit compatible.

********************************************************************/

LONG FMExtensionProcW( HWND hwnd, WORD wEvent, LONG lParam )
{
	// NTRAID#NTBUG9-584127-2002/03/22-artm  Need to validate parms for robustness.
	// See description in RAID.
#ifndef _WIN64 // 130459
    static HWND vhwnd = NULL;
    static UINT vwMenuDelta = 0;
#ifdef ACLEDIT_IS_REAL_EXTENSION
    static HMENU vhMenu = NULL;
#endif

    if ( wEvent != FMEVENT_UNLOAD && vhwnd != NULL )
    {
        //  vhwnd is assumed to be hwnd
        if ( vhwnd != hwnd )
        {
            DBGEOL( FMXPROC "hwnd != vhwnd: hwnd = "
                    << (UINT_PTR)hwnd << ", vhwnd = " << (UINT_PTR)vhwnd );
        }
    }

    if ( wEvent < 100 )
    {
        switch ( wEvent )
        {
        case IDM_PERMISSION:
            {
                EditPermissionInfo( hwnd ) ;
            }
            break ;

        case IDM_AUDITING:
            {
                EditAuditInfo( hwnd ) ;
            }
            break ;

        case IDM_OWNER:
            {
                EditOwnerInfo( hwnd ) ;
            }
            break ;

        default:
            DBGEOL(FMXPROC "Unexpected menu ID");
            break;
        }
        return 0;
    }

    switch ( wEvent )
    {
    case FMEVENT_LOAD:
        {
            FMS_LOAD * pfmsload = (FMS_LOAD *)lParam;

            if ( vhwnd != NULL )
            {
                //  This should not happen, but don't assert, since this
                //  is File Man's code.  This will happen, for example,
                //  if File Man GPs without giving the FMEVENT_UNLOAD
                //  notification.
                DBGEOL(FMXPROC "Multiple initializations!");
            }
            vhwnd = hwnd;
            vwMenuDelta = pfmsload->wMenuDelta;

            pfmsload->dwSize = sizeof( FMS_LOAD );

#ifdef ACLEDIT_IS_REAL_EXTENSION
//
//  Winfile loads Acledit as a hybrid extension that knows our menu.  It
//  passes us the menu on the menu item init so we don't need to do this
//  work.
//

            RESOURCE_STR nlsMenuName( IDS_NETWORK_NAME ) ;
            if ( nlsMenuName.QueryError() != NERR_Success )
            {
                DBGEOL(FMXPROC "NLS_STR::Load failed");
                return FALSE;       // failed to install FMX
            }

            // MENU_TEXT_LEN is defined in wfext.h, in BYTES
            if ( nlsMenuName.QueryTextSize() > sizeof(pfmsload->szMenuName) )
            {
                DBGEOL(FMXPROC "Menu item too long for FM's buffer");
                return FALSE;       // failed to install FMX
            }

            APIERR err ;
            if ( err = nlsMenuName.MapCopyTo( pfmsload->szMenuName,
                                              sizeof(pfmsload->szMenuName)))
            {
                DBGEOL(FMXPROC "MapCopyTo failed with error " << err ) ;
                return FALSE ;
            }

            //  Compute hMenu
            HMENU hMenu = ::LoadMenu( ::hModule, FMX_MENU );
            if ( hMenu == NULL )
            {
                DBGEOL(FMXPROC "LoadMenu failed");
                return FALSE;       // failed to install FMX
            }

            pfmsload->hMenu = hMenu;
            vhMenu = hMenu;
#endif //!ACLEDIT_IS_REAL_EXTENSION
        }
        return TRUE;        // success

    case FMEVENT_UNLOAD:
        vhwnd = NULL;
        vwMenuDelta = 0;
        return 0;

    case FMEVENT_INITMENU:
        {
            #define PERM_MENU_ITEM_OFFSET     0
            #define AUDIT_MENU_ITEM_OFFSET    1
            #define OWNER_MENU_ITEM_OFFSET    2

            BOOL fPerm  = TRUE,
                 fAudit = TRUE,
                 fOwner = TRUE ;
            (void) ::CheckMenuAccess(  hwnd, &fPerm, &fAudit, &fOwner ) ;

            //
            //  Enable (by default) if an error occurred in CheckMenuAccess
            //
            POPUP_MENU menu( (HMENU) lParam /*vhMenu*/ ) ;
            menu.EnableItem( PERM_MENU_ITEM_OFFSET,  fPerm,  MF_BYPOSITION ) ;
            menu.EnableItem( AUDIT_MENU_ITEM_OFFSET, fAudit, MF_BYPOSITION ) ;
            menu.EnableItem( OWNER_MENU_ITEM_OFFSET, fOwner, MF_BYPOSITION ) ;
        }
        return 0;

    case FMEVENT_TOOLBARLOAD:
        {
            FMS_TOOLBARLOAD  * pfmstoolbarload = (FMS_TOOLBARLOAD *)lParam;
            pfmstoolbarload->dwSize = sizeof(FMS_TOOLBARLOAD) ;
            pfmstoolbarload->lpButtons = aExtButton ;
            pfmstoolbarload->cButtons = 1 ;
            pfmstoolbarload->cBitmaps = 1 ;
	    pfmstoolbarload->idBitmap = BMID_SECURITY_TOOLBAR ;
	    pfmstoolbarload->hBitmap  = NULL ;
        }
        return TRUE ;

#ifdef ACLEDIT_IS_REAL_EXTENSION
    case FMEVENT_HELPSTRING:
	{
	    FMS_HELPSTRING * pfmshelp = (FMS_HELPSTRING *) lParam ;
	    MSGID msgHelp ;
	    switch ( pfmshelp->idCommand )
	    {
	    case IDM_PERMISSION:
		msgHelp = IDS_FM_HELP_PERMISSION_MENU_ITEM ;
		break ;

	    case IDM_AUDITING:
		msgHelp = IDS_FM_HELP_AUDITING_MENU_ITEM ;
		break ;

	    case IDM_OWNER:
		msgHelp = IDS_FM_HELP_OWNER_MENU_ITEM ;
		break ;

	    case ( -1 ):
	    default:
		msgHelp = IDS_FM_HELP_SECURITY_MENU ;
		break ;
	    }

	    RESOURCE_STR nlsHelp( msgHelp ) ;
	    if ( !nlsHelp.QueryError() )
	    {
		(void) nlsHelp.MapCopyTo( pfmshelp->szHelp,
					  sizeof( pfmshelp->szHelp )) ;
	    }
	}
	break ;
#endif

    //
    //  Somebody's pressed F1 on the security menu item selection
    //
    case FMEVENT_HELPMENUITEM:
        {
            APIERR err = NERR_Success ;
            BOOL   fIsFile ;
            BOOL   fIsNT ;
            BOOL   fIsLocal ;
            NLS_STR nlsSelItem;
            NLS_STR nlsServer ;
            RESOURCE_STR nlsHelpFile( IDS_FILE_PERM_HELP_FILE ) ;

            if ( (err = nlsSelItem.QueryError())  ||
                 (err = nlsServer.QueryError())   ||
                 (err = nlsHelpFile.QueryError()) ||
                 (err = ::GetSelItem( hwnd, 0, &nlsSelItem, &fIsFile )))
            {
                DBGEOL("Acledit FMExtensionProcW - Error " << err << " getting "
                       << " server path") ;
                break ;
            }


            err = ::TargetServerFromDosPath( nlsSelItem, &fIsLocal, &nlsServer );
            if (  ( err != NERR_Success )
               && ( err != NERR_InvalidDevice )
               )
            {
                DBGEOL("Acledit FMExtensionProcW - Error " << err << " getting "
                       << " server path") ;
                break ;
            }
            else if ( err == NERR_InvalidDevice )
            {
                //
                // Since LM can't determine the path, we will try all
                // providers to see if any one of them supports the
                // drive.
                //

                NLS_STR nlsDrive( nlsSelItem );
                ISTR istr( nlsDrive );
                BUFFER buffer( MAX_PATH );
                DWORD cbBufferSize;
                DWORD nDialogType;
                DWORD nHelpContext;

                if (  ( err = nlsDrive.QueryError())
                   || ( err = buffer.QueryError())
                   )
                {
                    break;
                }

                //
                // Get the drive letter of the selected item
                //
                istr += 2;
                nlsDrive.DelSubStr( istr ); 

                switch ( lParam )
                {
                case IDM_OWNER:
                    nDialogType = WNPERM_DLG_OWNER;
                    break;

                case IDM_AUDITING:
                    nDialogType = WNPERM_DLG_AUDIT;
                    break;

                case IDM_PERMISSION:
                    nDialogType = WNPERM_DLG_PERM;
                    break;
                }

                cbBufferSize = buffer.QuerySize();

                err = WNetFMXGetPermHelp( (LPWSTR) nlsDrive.QueryPch(),
                                          nDialogType,
                                          !fIsFile,
                                          buffer.QueryPtr(),
                                          &cbBufferSize,
                                          &nHelpContext );

                if ( err == WN_MORE_DATA )
                {
                    err = buffer.Resize( cbBufferSize );
                    err = err ? err : WNetFMXGetPermHelp( 
                                          (LPWSTR) nlsDrive.QueryPch(),
                                          nDialogType,
                                          !fIsFile,
                                          buffer.QueryPtr(),
                                          &cbBufferSize,
                                          &nHelpContext );
                }

                if ( err == NERR_Success )
                {
                    ::WinHelp( hwnd,
                               (LPTSTR) buffer.QueryPtr(),
                               HELP_CONTEXT,
                               nHelpContext );
                }

                break;
            }

            //
            //  If the partition is local, then we must be on NT
            //
            if ( fIsLocal )
                fIsNT = TRUE ;
            else
            {
                LOCATION locDrive( nlsServer, FALSE ) ;
                if ( (err = locDrive.QueryError()) ||
                     (err = locDrive.CheckIfNT( &fIsNT )) )
                {
                    DBGEOL("Acledit FMExtensionProcW - Error " << err << " getting "
                          << " location info") ;
                    break ;
                }
            }

            ULONG hc = HC_SED_LM_FILE_PERMS_DLG;
            switch ( lParam )
            {
            case IDM_OWNER:
                hc = HC_TAKEOWNERSHIP_DIALOG ;
                break ;

            case IDM_AUDITING:
            case IDM_PERMISSION:
                hc = LookupHC( fIsNT, !fIsFile, lParam == IDM_PERMISSION) ;
                break ;
            }

            DBGEOL("Calling help on context " << (HEX_STR) hc) ;
            ::WinHelp( hwnd, nlsHelpFile, HELP_CONTEXT, hc ) ;
        }
        break ;


    default:
        DBGEOL(FMXPROC "Unexpected wEvent param: " << (HEX_STR)wEvent );
        break;
    }
#endif // 130459

    return 0;

}  // FMExtensionProcW



/*******************************************************************

    NAME:       CheckMenuAccess

    SYNOPSIS:   Checks to see if the user would be able to do anything
                with the current selection (i.e., can read the DACL,
                write the SACL etc.)

    ENTRY:      hwndFMX - FMX hwnd
                pfPerm
                pfAudit - If TRUE the menu item should be enabled, FALSE if
                pfOwner     disabled

    RETURNS:    NERR_Success if succesful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   13-Jan-1992     Created

********************************************************************/

APIERR CheckMenuAccess( HWND          hwndFMX,
                        BOOL *        pfPerm,
                        BOOL *        pfAudit,
                        BOOL *        pfOwner )
{
    APIERR err = NERR_Success ;
    *pfPerm = *pfAudit = *pfOwner = TRUE ;
    FMX fmx( hwndFMX );
    BOOL   fIsFile ;
    NLS_STR nlsSelItem;
    BOOL   fRC = TRUE,    // Read control
           fWD = TRUE,    // Write DAC
           fWO = TRUE,    // Write Owner
           fWS = TRUE ;   // Read/Write SACL

    do { // error breakout

        //
        //  Something must be selected
        //
        if ( fmx.QuerySelCount() == 0 )
        {
            *pfPerm = *pfAudit = *pfOwner = FALSE ;
            break ;
        }

        if ( (err = nlsSelItem.QueryError()) ||
             (err = ::GetSelItem( hwndFMX, 0, &nlsSelItem, &fIsFile )))
        {
            break ;
        }

        BOOL fIsLocal ;
        NLS_STR  nlsServer( RMLEN ) ;
        if (err = nlsServer.QueryError())
            break;

        err = ::TargetServerFromDosPath( nlsSelItem,
                                         &fIsLocal,
                                         &nlsServer );


        if ( err == NERR_InvalidDevice )
        {
            //
            // Try other providers, nPermCap will be 0 if no provider
            // supports this drive and all menu items will be grayed out.
            //
            NLS_STR nlsDrive( nlsSelItem );
            ISTR istr( nlsDrive );

            if ( err = nlsDrive.QueryError() )
                break;

            istr += 2;
            nlsDrive.DelSubStr( istr );

            DWORD nPermCap = WNetFMXGetPermCaps( (LPWSTR) nlsDrive.QueryPch());
            *pfPerm = !!( nPermCap & WNPERMC_PERM );
            *pfAudit = !!( nPermCap & WNPERMC_AUDIT );
            *pfOwner = !!( nPermCap & WNPERMC_OWNER );

            err = NERR_Success;
            break;
        }


        BOOL fIsNT ;
        BOOL fIsMultiSelect = (fmx.QuerySelCount() > 1 ) ;
        LOCATION locDrive( fIsLocal ? NULL : nlsServer.QueryPch(), FALSE ) ;
        if ( (err = locDrive.QueryError()) ||
             (err = locDrive.CheckIfNT( &fIsNT ))  )
        {
            UIDEBUG(SZ("::EditFSAcl - locDrive failed to construct\n\r")) ;
            break ;
        }

        if ( !fIsNT )
        {
            //
            //  If LM (or something else), disable the owner but leave the
            //  Audit/Permission menu items enabled (we don't check to see
            //  if the share is share level or user level).
            //
            *pfOwner = FALSE ;
            break ;
        }

        //
        //  We know it's NT, but is the resource on an NTFS partition?
        //
        BOOL  fIsNTFS ;
        if ( err = IsNTFS( nlsSelItem, &fIsNTFS ))
        {
            break ;
        }

        if ( !fIsNTFS )
        {
            *pfPerm  = FALSE ;
            *pfAudit = FALSE ;
            *pfOwner = FALSE ;
            break ;
        }

        //
        //  Leave the menu items alone if we're on an NTFS partition but there
        //  is a multi-selection
        //
        if ( fIsMultiSelect )
            break ;

        //
        //  Check to see if we have permission/privilege to read the security
        //  descriptors
        //
        if ( (err = ::CheckFileSecurity( nlsSelItem,
                                         READ_CONTROL,
                                         &fRC )) )
        {
            fRC = TRUE ;
            TRACEEOL("CheckMenuAccess - READ_CONTROL_ACCESS check failed with error " << ::GetLastError() ) ;
        }

        //
        //  How about to write the security descriptor?
        //
        if ( (err = ::CheckFileSecurity( nlsSelItem,
                                         WRITE_DAC,
                                         &fWD )) )
        {
            fWD = TRUE ;
        }

        if ( !fRC && !fWD )
        {
            *pfPerm = FALSE ;
        }

        //
        //  Check to see if the user can write to the owner SID
        //

        BOOL fOwnerPrivAdjusted = FALSE ;
        ULONG ulOwnerPriv = SE_TAKE_OWNERSHIP_PRIVILEGE ;
        if ( ! ::NetpGetPrivilege( 1, &ulOwnerPriv ) )
        {
            fOwnerPrivAdjusted = TRUE ;
        }

        if ( (err = ::CheckFileSecurity( nlsSelItem,
                                         WRITE_OWNER,
                                         &fWO )) )
        {
            fWO = TRUE ;
        }

        if ( !fWO && !fRC )
        {
            *pfOwner = FALSE ;
        }

        if ( fOwnerPrivAdjusted )
            ::NetpReleasePrivilege() ;

        //
        //  Check to see if the user can read/write the SACL
        //

        BOOL fAuditPrivAdjusted = FALSE ;
        ULONG ulAuditPriv = SE_SECURITY_PRIVILEGE ;
        if ( ! ::NetpGetPrivilege( 1, &ulAuditPriv ) )
        {
            fAuditPrivAdjusted = TRUE ;
        }

        if ( (err = ::CheckFileSecurity( nlsSelItem,
                                         ACCESS_SYSTEM_SECURITY,
                                         &fWS )) )
        {
            *pfAudit = TRUE ;
            DBGEOL("CheckMenuAccess - ACCESS_SYSTEM_SECURITY check failed with error " << ::GetLastError() ) ;
        }
        else
            *pfAudit = fWS ;

        if ( fAuditPrivAdjusted )
            ::NetpReleasePrivilege() ;

    } while (FALSE) ;


    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\ipermapi.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    IPermAPI.cxx


    Internal generic permission edittor API implementation

    FILE HISTORY:
	Johnl	07-Aug-1991	Created

*/
#include <ntincl.hxx>
#include <ntseapi.h>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#include <blt.hxx>
#include <fontedit.hxx>

#include <maskmap.hxx>
#include <accperm.hxx>
#include <aclconv.hxx>
#include <permdlg.hxx>
#include <auditdlg.hxx>

#include <dbgstr.hxx>
#include <uiassert.hxx>

#include <ipermapi.hxx>

/*******************************************************************

    NAME:	I_GenericSecurityEditor

    SYNOPSIS:	This function creates the main permission editor or auditting
		editor dialogs.

    ENTRY:	See ipermapi.hxx for a complete explanation of all
		parameters.

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Updated with real dialogs

********************************************************************/

APIERR I_GenericSecurityEditor(
    HWND		    hwndParent,
    ACL_TO_PERM_CONVERTER * paclconv,
    enum SED_PERM_TYPE	    permType,
    BOOL		    fIsNT,
    BOOL		    fIsContainer,
    BOOL		    fSupportsNewObjectPerms,
    const TCHAR		  * pszDialogTitle,
    const TCHAR		  * pszResType,
    const TCHAR		  * pszResName,
    const TCHAR 	  * pszSpecialAccessName,
    const TCHAR 	  * pszDefaultPermName,
    const TCHAR           * pszHelpFileName,
    ULONG                 * ahcHelp,
    const TCHAR		  * pszNewObjectSpecialAccessName,
    const TCHAR           * pszAssignToExistingContTitle,
    const TCHAR           * pszAssignToExistingObjTitle,
    const TCHAR 	  * pszTreeApplyHelpText,
    const TCHAR 	  * pszTreeApplyConfirmation )
{
    UIASSERT( hwndParent != NULL ) ;
    UIASSERT( paclconv != NULL && paclconv->QueryError() == NERR_Success ) ;
    UIASSERT( (permType == SED_AUDITS) || (permType == SED_ACCESSES) ) ;

    MAIN_PERM_BASE_DLG * ppermdlg = NULL ;

    /* Here we determine which dialog we want to show the user.  Note that
     * the Initialize and destructor methods are virtual.
     */
    if ( !fIsNT )
    {
	if ( permType == SED_ACCESSES )
	{
	    if ( fIsContainer )
	    {
		/* LM Directory permissions.  Note there is no difference
		 * in the dialogs thus we can use the same dialog template
		 */
		ppermdlg = new CONT_ACCESS_PERM_DLG(
						  MAKEINTRESOURCE(IDD_SED_LM_CONT_PERM),
						  hwndParent,
						  pszDialogTitle,
						  paclconv,
						  pszResType,
						  pszResName,
						  pszHelpFileName,
						  pszSpecialAccessName,
                                                  pszDefaultPermName,
                                                  ahcHelp,
						  pszAssignToExistingContTitle,
						  pszTreeApplyHelpText,
						  pszTreeApplyConfirmation );

	    }
	    else
	    {
		/* LM Single object non-container access permissions dialog
		 */
		ppermdlg = new OBJECT_ACCESS_PERMISSION_DLG(
							  MAKEINTRESOURCE(IDD_SED_OBJECT_PERM),
							  hwndParent,
							  pszDialogTitle,
							  paclconv,
							  pszResType,
							  pszResName,
							  pszHelpFileName,
							  pszSpecialAccessName,
							  pszDefaultPermName,
                                                          ahcHelp ) ;


	    }
	}
	else
	{
	    /* LM Auditting - Uses the same dialog, the only variation
	     * is that for files, the checkbox title should be NULL, this
	     * will hide and disable checkbox.
	     */
	    ppermdlg = new LM_AUDITTING_DLG( MAKEINTRESOURCE(IDD_SED_LM_AUDITING_DLG),
					     hwndParent,
					     pszDialogTitle,
					     paclconv,
					     pszResType,
					     pszResName,
					     pszHelpFileName,
                                             ahcHelp,
					     pszAssignToExistingContTitle,
					     pszTreeApplyHelpText,
					     pszTreeApplyConfirmation ) ;
	}
    }
    else
    {
	/* This is an NT ACL we will be dealing with
	 */

	if ( permType == SED_ACCESSES )
	{
	    if ( fIsContainer )
	    {
		if ( fSupportsNewObjectPerms )
		{
		    //
		    //	NT Container object that supports New Object
		    //	permissions
		    //
		    ppermdlg = new NT_CONT_ACCESS_PERM_DLG(
                                                MAKEINTRESOURCE(IDD_SED_NT_CONT_NEWOBJ_PERM_DLG),
						hwndParent,
						pszDialogTitle,
						paclconv,
						pszResType,
						pszResName,
						pszHelpFileName,
						pszSpecialAccessName,
						pszDefaultPermName,
                                                ahcHelp,
						pszNewObjectSpecialAccessName,
                                                pszAssignToExistingContTitle,
                                                pszAssignToExistingObjTitle,
						pszTreeApplyHelpText,
						pszTreeApplyConfirmation ) ;
		}
		else
		{
		    //
		    //	NT Container object that does not support New Object
		    //	permissions
		    //
		    ppermdlg = new NT_CONT_NO_OBJ_ACCESS_PERM_DLG(
						MAKEINTRESOURCE(IDD_SED_NT_CONT_PERM),
						hwndParent,
						pszDialogTitle,
						paclconv,
						pszResType,
						pszResName,
						pszHelpFileName,
						pszSpecialAccessName,
						pszDefaultPermName,
                                                ahcHelp,
						pszAssignToExistingContTitle,
						pszTreeApplyHelpText,
						pszTreeApplyConfirmation ) ;
		}
	    }
	    else
	    {
		/* NT Object access permissions dialog
		 */
		ppermdlg = new NT_OBJECT_ACCESS_PERMISSION_DLG(
							  MAKEINTRESOURCE(IDD_SED_NT_OBJECT_PERM),
							  hwndParent,
							  pszDialogTitle,
							  paclconv,
							  pszResType,
							  pszResName,
							  pszHelpFileName,
							  pszSpecialAccessName,
                                                          pszDefaultPermName,
                                                          ahcHelp ) ;

	    }
	}
	else
	{
	    if ( fIsContainer )
            {
		if ( fSupportsNewObjectPerms )
		{
                    /* NT Container and object auditting dialog
                     */
                    ppermdlg = new CONT_NEWOBJ_AUDIT_DLG(
                                           MAKEINTRESOURCE(IDD_SED_NT_CONT_NEWOBJ_AUDITING_DLG),
                                           hwndParent,
                                           pszDialogTitle,
                                           paclconv,
                                           pszResType,
                                           pszResName,
                                           pszHelpFileName,
                                           ahcHelp,
                                           pszAssignToExistingContTitle,
                                           pszAssignToExistingObjTitle,
                                           pszTreeApplyHelpText,
                                           pszTreeApplyConfirmation ) ;
                }
                else
                {
                    /* NT Container auditting dialog
                     */
                    ppermdlg = new CONT_AUDIT_DLG( MAKEINTRESOURCE(IDD_SED_NT_CONT_AUDITING_DLG),
                                           hwndParent,
                                           pszDialogTitle,
                                           paclconv,
                                           pszResType,
                                           pszResName,
                                           pszHelpFileName,
                                           ahcHelp,
                                           pszAssignToExistingContTitle,
                                           pszTreeApplyHelpText,
                                           pszTreeApplyConfirmation ) ;
                }
	    }
	    else
	    {
		/* NT Object auditting dialog
		 */
		ppermdlg = new OBJECT_AUDIT_DLG( MAKEINTRESOURCE(IDD_SED_NT_CONT_AUDITING_DLG),
						 hwndParent,
						 pszDialogTitle,
						 paclconv,
						 pszResType,
						 pszResName,
						 pszHelpFileName,
                                                 ahcHelp ) ;
	    }
	}
    }

    if ( ppermdlg == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY ;
    }
    else if ( ppermdlg->QueryError() != NERR_Success )
    {
	DBGEOL("::I_GenericSecurityEditor - permission dialog failed to construct") ;
	return ppermdlg->QueryError() ;
    }

    APIERR err ;
    BOOL fUserQuit ;
    if ( !(err = ppermdlg->Initialize( &fUserQuit,
				       (permType == SED_ACCESSES) )) &&
	 !fUserQuit )
    {
	err = ppermdlg->Process() ;
    }

    delete ppermdlg ;

    return err ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\libmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    Libmain.cxx

    Library initialization for the Acl Editor



    FILE HISTORY:
        JohnL   15-Apr-1992     Scavenged from Shell's Libmain

*/

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETLIB
#include <lmui.hxx>

extern "C"
{
    #include <dos.h>

    #include <uimsg.h>
    #include <uirsrc.h>
}


#define INCL_BLT_CONTROL
#define INCL_BLT_DIALOG
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <ellipsis.hxx>

#include <uitrace.hxx>
#include <string.hxx>

/*      Local prototypes         */

// reorged these for Glock
extern "C"
{
    BOOL NEAR PASCAL LIBMAIN              ( HINSTANCE hInst,
                                            UINT   wDataSeg,
                                            UINT   wHeapSize,
                                            LPSTR  lpCmdLine  );

/* Under Win32, DllMain simply calls LIBMAIN.
 */
BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved ) ;


INT FAR PASCAL WEP                    ( UINT   wWord      );
}

#define FAR_HEAPS_DLL 5  /* Maximum numbe of far heaps for ::new */

HINSTANCE  hModule = NULL;     // exported


/*****
 *
 *  LIBMAIN
 *
 *  Purpose:
 *      Initialize DLL, which includes:
 *        - save away instance handle
 *        - set current capabilities
 *
 *  Parameters:
 *      hInst           Instance handle of DLL
 *
 *  Returns:
 *      TRUE            Init OK
 *      FALSE           Init failed
 */

BOOL /* NEAR PASCAL */ LIBMAIN    ( HINSTANCE          hInst,
                                    UINT            wDataSeg,
                                    UINT            wHeapSize,
                                    LPSTR           lpCmdLine       )
{
    UNREFERENCED (wDataSeg);
    UNREFERENCED (lpCmdLine);
    UNREFERENCED( wHeapSize ) ;

    ::hModule = hInst;

    APIERR err ;
    if ( (err = BLT::Init(hInst,
                          IDRSRC_ACLEDIT_BASE, IDRSRC_ACLEDIT_LAST,
                          IDS_UI_ACLEDIT_BASE, IDS_UI_ACLEDIT_LAST)) ||
         (err = BASE_ELLIPSIS::Init()) )
    {
        return FALSE ;
    }

    /*
     * BLT functionality not available until after this comment
     */

    return TRUE;
}  /* LIBMAIN */

/*******************************************************************

    NAME:       DllMain

    SYNOPSIS:   Win32 DLL Entry point.  This function gets called when
                a process or thread attaches/detaches itself to this DLL.
                We simply call the Win3 appropriate DLL function.

    ENTRY:      hDll - DLL Module handle
                dwReason - Indicates attach/detach
                lpvReserved - Not used

    EXIT:

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:      This is the typical Win32 DLL entry style.

                This is Win32 only.

    HISTORY:
        Johnl   01-Nov-1991     Created

********************************************************************/

#ifdef WIN32
BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    UNREFERENCED( lpvReserved ) ;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        return LIBMAIN( hDll, 0, 0, NULL ) ;

    case DLL_PROCESS_DETACH:
        return WEP( 0 ) ;

    default:
        break ;
    }

    return TRUE ;
}
#endif //WIN32

/*
 *  WEP   (Windows Export Proc--short and cryptic name because
 *         this function is not given an ordinal)
 *
 *  When Windows unloads a driver, it calls this function so that
 *  the driver can do any last minute clean-ups.  Then, Windows
 *  calls the WEP function.  All Windows libraries are required to
 *  contain this function.  It should be included in the .def file
 *  but should not be given an ordinal.
 *
 */

INT WEP ( UINT wWord )
{
#ifdef WIN32
    UNREFERENCED( wWord ) ;
#endif

    BASE_ELLIPSIS::Term() ;
    BLT::Term( ::hModule ) ;

#ifndef WIN32
    MEM_MASTER::Term();    /*  Terminate use of the global heap  */
#endif //!WIN32
    return 1;
}  /* WEP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\lmaclcon.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    LMACLCon.cxx

    This file contains the Lanman LM_ACL_TO_PERM_CONVERTER code.



    FILE HISTORY:
        Johnl   02-Aug-1991     Created

*/
#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
}

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_WINDOWS
#define INCL_NETLIB
#define INCL_NETWKSTA
#include <lmui.hxx>

#include <base.hxx>
#include <maskmap.hxx>
#include <lmoacces.hxx>
#include <fsenum.hxx>
#include <strnumer.hxx>

extern "C"
{
    #include <lmaudit.h>
    #include <mnet.h>
}

#include <uiassert.hxx>
#include <uitrace.hxx>
#include <lmodom.hxx>
#include <lmowks.hxx>
#include <accperm.hxx>
#include <aclconv.hxx>
#include <subject.hxx>
#include <perm.hxx>
#include <security.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <ipermapi.hxx>
#include <permprg.hxx>
#include <permstr.hxx>
#include <ntfsacl.hxx>      // For the tree apply dialogs

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::ACL_TO_PERM_CONVERTER

    SYNOPSIS:

    ENTRY:      pszLocation - NULL for local workstation
                              "\\server" for server
                              "Domain"   for domain name



    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   18-Aug-1991     Created
        Johnl   25-Sep-1991     Added Location object

********************************************************************/

ACL_TO_PERM_CONVERTER::ACL_TO_PERM_CONVERTER( const TCHAR * pszServer,
                                              MASK_MAP * paccessmap,
                                              MASK_MAP * pauditmap,
                                              BOOL fIsNT,
                                              BOOL fIsContainer,
                                              BOOL fIsNewObjectsSupported,
                                              BOOL fShowMnemonics )
    : _location              ( pszServer ),
      _fReadOnly             ( FALSE ),
      _fIsNT                 ( fIsNT ),
      _fIsContainer          ( fIsContainer ),
      _fIsNewObjectsSupported( fIsNewObjectsSupported ),
      _fShowMnemonics        ( fShowMnemonics ),
      _paccmaskmap           ( paccessmap ),
      _pauditmaskmap         ( pauditmap ),
      _hwndErrorParent       ( NULL ),
      _nlsLoggedOnDC         ( (const TCHAR *)NULL ),
      _nlsLoggedOnDomain     ( (const TCHAR *)NULL )
{
    APIERR err ;
    if ( (err = _location.QueryError()) ||
         (err = _nlsLoggedOnDC.QueryError()) )
    {
        ReportError( err ) ;
        return ;
    }
}

ACL_TO_PERM_CONVERTER::~ACL_TO_PERM_CONVERTER()
{
    _paccmaskmap = NULL ;
    _pauditmaskmap = NULL ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::QueryNewObjectAccessMap

    SYNOPSIS:   Returns the New object access map

    RETURNS:    The default is to return NULL which indicates new
                objects are not supported.

    NOTES:      This will only be implemented for NT objects that are
                containers and support new sub-object permissions

    HISTORY:
        Johnl   27-Sep-1991     Created

********************************************************************/

MASK_MAP * ACL_TO_PERM_CONVERTER::QueryNewObjectAccessMap( void ) const
{
    return NULL ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::BuildPermission

    SYNOPSIS:   Builds the appropriate permission object based on the
                environment (i.e., NT, NT Cont, LM etc.).

    ENTRY:      See Header for parameter details

    EXIT:       *ppPerm will point to a newly allocated permission of the
                appropriate type

    RETURNS:    NERR_Success of successful

    NOTES:      The subject will automatically be deleted if an error
                occurred

    HISTORY:
        Johnl   18-Sep-1991     Moved from LM_ACL_TO_PERM_CONVERTER

********************************************************************/

APIERR ACL_TO_PERM_CONVERTER::BuildPermission(
                                   PERMISSION * * ppPerm,
                                   BOOL fAccessPermission,
                                   SUBJECT  * pSubj,
                                   BITFIELD * pbits1,
                                   BITFIELD * pbits2,
                                   BOOL       fContainerPermsInheritted )
{
    ASSERT( pSubj != NULL ) ;
    ASSERT( pSubj->QueryError() == NERR_Success ) ;
    ASSERT( pbits1 != NULL ) ;

    /* Allocate the correct PERMISSION object
     */
    if ( fAccessPermission )
    {
        if ( IsNewObjectsSupported() )
        {
            UIASSERT( IsNT() ) ;

            BOOL fIsMapped =  QueryAccessMap()->IsPresent( pbits1 ) &&
                              (pbits2 != NULL ?
                                QueryNewObjectAccessMap()->IsPresent( pbits2 ) :
                                TRUE) ;
#ifdef TRACE
            if ( !fIsMapped )
                TRACEEOL("\tBuildPermission: Warning - Adding Non-Mapped access mask\n") ;
#endif
            *ppPerm = new NT_CONT_ACCESS_PERMISSION( pSubj,
                                                     pbits1,
                                                     pbits2,
                                                     fContainerPermsInheritted,
                                                     fIsMapped ) ;
        }
        else
        {
            /* Regular old permission.  Check whether we are
             * looking at an NT system or a LM system.
             */
            UIASSERT( pbits2 == NULL ) ;

            if ( IsNT() )
            {
                *ppPerm = new ACCESS_PERMISSION( pSubj,
                                                 pbits1,
                                                 fContainerPermsInheritted,
                                                 QueryAccessMap()->IsPresent( pbits1 ) ) ;
            }
            else
            {
                *ppPerm = new LM_ACCESS_PERMISSION( pSubj,
                                                    pbits1,
                                                    !IsContainer() ) ;
            }
        }

    }
    else
    {
        *ppPerm = new AUDIT_PERMISSION( pSubj, pbits1, pbits2, fContainerPermsInheritted,
                                        QueryAuditMap()->IsPresent( pbits1 ) &&
                                        QueryAuditMap()->IsPresent( pbits2 ) ) ;
    }

    APIERR err = ERROR_NOT_ENOUGH_MEMORY ;
    if ( ppPerm == NULL ||
         (err = (*ppPerm)->QueryError()) )
    {
        if ( ppPerm == NULL )
            delete pSubj ;
        else
            delete *ppPerm ;

		// NTRAID#NTBUG9-573701-2002/03/07-artm  Prefast bug.
		// This line of code can be executed if ppPerm == NULL.
		// This will lead to an access violation.
		//
		// There is a related problem with dereferencing ppPerm
		// in multiple places earlier in the function since there
		// is no validation check at the beginning of the function.
		// Prefast does not catch these, however.
		// 
		// I don't think this can be removed; it is part of a base class
		// used in acledit.
        *ppPerm = NULL ;
    }

    return err ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo

    SYNOPSIS:   Gets a DC from the domain the current user is logged onto or
                /and the domain the user is currently logged onto

    ENTRY:      pnlsDC - String to receive the DC name (maybe NULL)
                pnlsDomain - String to receive the domain name (maybe NULL)

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   10-Sep-1992     Created

********************************************************************/

APIERR ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo( NLS_STR * pnlsDC,
                                                       NLS_STR * pnlsDomain )
{
    APIERR err = NERR_Success ;
    err = ::QueryLoggedOnDomainInfo( pnlsDC,
                                     pnlsDomain,
                                     QueryWritePermHwnd() ) ;

#ifdef DEBUG
    if ( !err )
    {
        if ( pnlsDomain != NULL )
            TRACEEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo - User is logged onto " << pnlsDomain->QueryPch() ) ;

        if ( pnlsDC != NULL )
            TRACEEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo - User is logged onto "
                 << " DC " << pnlsDC->QueryPch() ) ;
    }
#endif  // DEBUG

    return err ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::QueryInherittingResource

    SYNOPSIS:   Default implementation - Asserts out if not redefined.
                Only LM needs this since only LM has the concept of
                inheritting permissions.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

APIERR ACL_TO_PERM_CONVERTER::QueryInherittingResource(
                                             NLS_STR * pnlsInherittingResName )
{
    UNREFERENCED( pnlsInherittingResName ) ;
    UIASSERT(!SZ("Not Implemented!\n\r")) ;
    return ERROR_GEN_FAILURE ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::QueryOwnerName

    SYNOPSIS:   The default implmentation returns NULL (indicating this
                object doesn't support an owner).

    HISTORY:    Johnl   16-Nov-1992     Created

********************************************************************/

const TCHAR * ACL_TO_PERM_CONVERTER::QueryOwnerName( void ) const
{
    return NULL ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::LM_ACL_TO_PERM_CONVERTER

    SYNOPSIS:   Constructor for the LM acl converter

    ENTRY:      pchServer - What server this resource is on (NULL if local)
                pchResourceName - Name of resource suitable for passing
                    to NetAccess APIs
                paccessmap - Pointer to access perm. MAP_MASK object
                pauditmap  - Pointer to audit perm. MAP_MASK object

    EXIT:       If a construction error occurs, Report error will be called
                appropriately.

    NOTES:      If one of the MASK_MAPs are NULL, then no conversion
                will be performed on the corresponding ACE type (i.e.,
                if paccessmap is NULL, then no Access permission ACEs will
                be interpreted).  They will be stored internally so they
                can be written back out, but they won't be publicly
                available.


    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

LM_ACL_TO_PERM_CONVERTER::LM_ACL_TO_PERM_CONVERTER(
                          const TCHAR * pszServer,
                          const TCHAR * pchResourceName,
                          MASK_MAP    * paccessmap,
                          MASK_MAP    * pauditmap,
                          BOOL          fIsContainer,
                          PSED_FUNC_APPLY_SEC_CALLBACK pfuncCallback,
                          ULONG_PTR     ulCallbackContext,
                          BOOL          fIsBadIntersection )
    : ACL_TO_PERM_CONVERTER( pszServer, paccessmap, pauditmap, FALSE,
                             fIsContainer, FALSE ),
      _lmobjNetAccess1     ( pszServer, pchResourceName ),
     _pfuncCallback        ( pfuncCallback ),
     _ulCallbackContext    ( ulCallbackContext ),
     _fIsBadIntersection   ( fIsBadIntersection )
{
    if ( QueryError() != NERR_Success )
        return ;

    if ( _lmobjNetAccess1.QueryError() != NERR_Success )
    {
        ReportError( _lmobjNetAccess1.QueryError() ) ;
        return ;
    }

    /* There are no read only resources in LM, either you have access or you
     * don't.
     */
    SetReadOnlyFlag( FALSE ) ;
}

LM_ACL_TO_PERM_CONVERTER::~LM_ACL_TO_PERM_CONVERTER()
{
    _pfuncCallback = NULL;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERT::GetPermissions

    SYNOPSIS:   Fills in the passed ACCPERM object with the appropriate
                permission information

    ENTRY:      pAccperm - Pointer to the ACCPERM that will receive the
                    permissions.
                fAccessPerms - TRUE if the Access permissions should be
                    retrieved, FALSE if Audit permissions should be retrieved

    EXIT:

    RETURNS:

    NOTES:      If the resource is inheritting its ACL, then we get the
                inheritting permissions *automatically*, the only overhead
                that might be avoidable is the work of converting the
                ACL to an ACCPERM (should be very small when compared to
                the network calls).  If performance is a problem, we may
                want to consider changing this.

    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::GetPermissions( ACCPERM * pAccperm,
                                                 BOOL      fAccessPerms )
{
    UNREFERENCED( fAccessPerms ) ;
    UIDEBUG( SZ("LM_ACL_TO_PERM_CONVERTER::GetPermissions\n\r")) ;
    UIASSERT( pAccperm != NULL ) ;

    APIERR err ;

    err = _lmobjNetAccess1.GetInfo() ;
    BOOL fInherittingPermissions = FALSE ;
    if ( err != NERR_Success )
    {
        UIDEBUG(SZ("LM_ACL_TO_PERM_CONVERTER::GetPermissions - Failed on GetInfo - resource:\n\r")) ;
        UIDEBUG( _lmobjNetAccess1.QueryName() ) ;
        UIDEBUG(SZ("\n\r")) ;

        switch ( err )
        {
        case NERR_ResourceNotFound:
            {
                //
                //  Audits never inherit from the parent dir but we
                //  still need to pick up the access permissions that
                //  me be inherited
                //

                /* No ACL was found on this resource, so try and find
                 * the resource we are inheritting from (if any).
                 */
                err = FindInherittingResource() ;
                switch ( err )
                {
                case NERR_ResourceNotFound:
                    //
                    //  We just show a blank dialog if this is a bad
                    //  intersection
                    //
                    if ( _fIsBadIntersection )
                        break ;

                    return IERR_ACLCONV_LM_NO_ACL ;

                case NERR_Success:
                    fInherittingPermissions = TRUE ;
                    break ;

                default:
                    return err ;
                }
            }
            break ;

        case ERROR_NOT_SUPPORTED:
            return IERR_ACLCONV_CANT_EDIT_PERM_ON_LM_SHARE_LEVEL;

        default:
            return err ;
        }

    }

    //
    //  If we have a bad intersection, then wipe the slate clean and start
    //  with a blank permission set.
    //
    if ( _fIsBadIntersection || err == NERR_ResourceNotFound )
    {
        fInherittingPermissions = FALSE ;
        if ( err = _lmobjNetAccess1.CreateNew() )
            return err ;
    }

    /* Fill in the auditting permissions
     *
     *  For LM, the auditting permissions don't apply to a subject, only to
     *  the resource, so a dummy LM_SUBJECT is created.
     *
     *  Note that there will only ever be one audit permission created for
     *  LM auditting.
     */
    {
        /* Map AA_AUDIT_ALL to AA_S_ALL (i.e., implicit all to explicit all).
         */
        //
        //  If the access permissions are inherited, then there weren't any
        //  audits set on the resource.
        //
        USHORT usSuccessAuditFlags = 0;
        if ( !fInherittingPermissions )
        {
            usSuccessAuditFlags =
                             _lmobjNetAccess1.QueryAuditFlags() & AA_AUDIT_ALL ?
                             AA_S_ALL :
                             _lmobjNetAccess1.QueryAuditFlags() & AA_S_ALL ;
        }

        BITFIELD bitSuccess( usSuccessAuditFlags  ) ;
        if ( bitSuccess.QueryError() != NERR_Success )
            return bitSuccess.QueryError() ;

        USHORT usFailAuditFlags = 0 ;
        if ( !fInherittingPermissions )
        {
            usFailAuditFlags= _lmobjNetAccess1.QueryAuditFlags() & AA_AUDIT_ALL ?
                             AA_F_ALL :
                             _lmobjNetAccess1.QueryAuditFlags() & AA_F_ALL ;
        }

        BITFIELD bitFailure( FailToSuccessAuditFlags( usFailAuditFlags ) ) ;

        if ( bitFailure.QueryError() != NERR_Success )
            return bitSuccess.QueryError() ;

        SUBJECT * pSubj = new LM_SUBJECT( NULL, FALSE ) ;
        if ( pSubj == NULL )
            return ERROR_NOT_ENOUGH_MEMORY ;
        else if ( pSubj->QueryError() != NERR_Success )
        {
            err = pSubj->QueryError() ;
            delete pSubj ;
            return err ;
        }

        AUDIT_PERMISSION * pPermAudit ;
        err = BuildPermission( (PERMISSION **)&pPermAudit,
                               FALSE,   // Audit permission
                               pSubj,   // No subject name
                               &bitSuccess,
                               &bitFailure ) ;
        if ( err != NERR_Success )
            return err ;

        if ( (err = pAccperm->AddPermission( pPermAudit )) != NERR_Success )
        {
            delete pPermAudit ;
            return err ;
        }
    }

    /* Get the access permissions
     */
    for ( int i = 0 ; i < (int)_lmobjNetAccess1.QueryACECount() ; i++ )
    {
        access_list * paccess_list = _lmobjNetAccess1.QueryACE( i ) ;
        UIASSERT( paccess_list != NULL ) ;

        /* We have to mask out the group bit from the access permissions.
         */
        BITFIELD bitAccessPerm((USHORT)(paccess_list->acl_access & ACCESS_ALL));
        if ( bitAccessPerm.QueryError() != NERR_Success )
            return bitAccessPerm.QueryError() ;

        SUBJECT * pSubj = new LM_SUBJECT( paccess_list->acl_ugname,
                                       paccess_list->acl_access & ACCESS_GROUP);
        if ( pSubj == NULL )
            return ERROR_NOT_ENOUGH_MEMORY ;
        else if ( pSubj->QueryError() != NERR_Success )
        {
            err = pSubj->QueryError() ;
            delete pSubj ;
            return err ;
        }

        ACCESS_PERMISSION * pPermAccess ;
        err = BuildPermission( (PERMISSION **) &pPermAccess,
                               TRUE,    // Access permission
                               pSubj,
                               &bitAccessPerm,
                               NULL ) ;

        if ( err != NERR_Success )
            return err ;

        if ( (err = pAccperm->AddPermission( pPermAccess )) != NERR_Success )
        {
            delete pPermAccess ;
            return err ;
        }
    }

    if ( ( err == NERR_Success ) && ( fInherittingPermissions ) )
        return IERR_ACLCONV_LM_INHERITING_PERMS ;

    return err ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::GetBlankPermissions

    SYNOPSIS:   Initializes the ACCPERM object with the "default"
                blank permission

    ENTRY:      pAccperm - Pointer to accperm object

    EXIT:       The Access permission list will be empty, and the audit
                permission list will contain a single audit permission
                with no bits enabled.

    RETURNS:    NERR_Success or some standard error code.

    NOTES:

    HISTORY:
        Johnl   Aug-21-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::GetBlankPermissions( ACCPERM * pAccperm )
{
    pAccperm->QueryAccessPermissionList()->Clear() ;
    pAccperm->QueryAuditPermissionList()->Clear() ;

    /* Fill in the auditting permissions
     *
     *  Note that there will only ever be one audit permission created for
     *  LM auditting.
     */
    {
        BITFIELD bitSuccess( (USHORT) 0 ) ;
        if ( bitSuccess.QueryError() != NERR_Success )
            return bitSuccess.QueryError() ;

        BITFIELD bitFailure( (USHORT) 0 ) ;
        if ( bitFailure.QueryError() != NERR_Success )
            return bitSuccess.QueryError() ;

        SUBJECT * pSubj = new LM_SUBJECT( NULL, FALSE ) ;
        if ( pSubj == NULL )
            return ERROR_NOT_ENOUGH_MEMORY ;
        else if ( pSubj->QueryError() != NERR_Success )
        {
            APIERR err = pSubj->QueryError() ;
            delete pSubj ;
            return err ;
        }

        /* Build permission will delete the subject if it fails
         */
        AUDIT_PERMISSION * pPermAudit ;
        APIERR err = BuildPermission( (PERMISSION **)&pPermAudit,
                                      FALSE,   // Audit permission
                                      pSubj,   // No subject name
                                      &bitSuccess,
                                      &bitFailure ) ;
        if ( err != NERR_Success )
            return err ;

        if ( (err = pAccperm->AddPermission( pPermAudit )) != NERR_Success )
        {
            delete pPermAudit ;
            return err ;
        }
    }

    /* We have to validate the net access object because we may not have
     * called GetInfo on it.  This also empties it of all permissions.
     */
    APIERR err = _lmobjNetAccess1.CreateNew() ;
    return err ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::WritePermissions

    SYNOPSIS:   Apply the permissions to the requested resources

    ENTRY:      accperm - List of permissions (audit & access) to be
                        applied to the designated resource
                fApplyToSubContainers - TRUE if subdirs should have perms set
                fApplyToSubObjects - TRUE if files should have perms set
                applyflags - specifies whether Audit/Access/Both permissions
                        should be set.
                pfReportError - Indicates if the caller should notify the
                        user in case of error

    EXIT:

    RETURNS:

    NOTES:      accperm can't be const because the Enum* methods can't be
                const.

    HISTORY:
        Johnl   29-Aug-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::WritePermissions(
                         ACCPERM &        accperm,
                         BOOL             fApplyToSubContainers,
                         BOOL             fApplyToSubObjects,
                         TREE_APPLY_FLAGS applyflags,
                         BOOL            *pfReportError )
{
    UIASSERT( sizeof( short ) == sizeof( USHORT ) ) ;
    UNREFERENCED( applyflags ) ;

    *pfReportError = TRUE ;
    _lmobjNetAccess1.ClearPerms() ;

    /* Set the audit flags
     */
    BOOL fFromBeginning = TRUE ;
    AUDIT_PERMISSION *pAuditPerm ;

    /* If there is no audit permission for this ACL, then we will assume
     * that means no auditting on this resource.
     */
    short sAuditFlags = 0 ;
    if ( accperm.EnumAuditPermissions( &pAuditPerm, & fFromBeginning ) )
    {
        sAuditFlags = (USHORT) *pAuditPerm->QuerySuccessAuditBits() ;

        sAuditFlags |= SuccessToFailAuditFlags(
                                    (USHORT)*pAuditPerm->QueryFailAuditBits()) ;

        /* There should only be one Audit record in the accperm
         */
        UIASSERT( !accperm.EnumAuditPermissions( &pAuditPerm,
                                                 &fFromBeginning ) ) ;
    }

    APIERR err = _lmobjNetAccess1.SetAuditFlags( sAuditFlags ) ;
    if ( err != NERR_Success )
        return err ;

    /* Iterate through the permissions and set them appropriately
     */
    fFromBeginning = TRUE ;
    ACCESS_PERMISSION *pAccessPerm ;
    while ( accperm.EnumAccessPermissions( &pAccessPerm, &fFromBeginning ) )
    {
        UIASSERT( pAccessPerm->QuerySubject()->IsGroup() ||
                  pAccessPerm->QuerySubject()->IsUser()    ) ;

        short sAccessMask = (USHORT) *pAccessPerm->QueryAccessBits() ;
        err = _lmobjNetAccess1.SetPerm(
                                   pAccessPerm->QuerySubject()->QueryDisplayName(),
                                   (pAccessPerm->QuerySubject()->IsGroup() ?
                                            PERMNAME_GROUP :
                                            PERMNAME_USER),
                                   sAccessMask ) ;
        if ( err != NERR_Success )
            return err ;
    }

    DWORD dwReturnStatus; // just a dummy
    if ( !err &&  _pfuncCallback != NULL )
    {
        //
        //  Sorta hack, hack
        //
        if ( _ulCallbackContext )
        {
            LM_CALLBACK_INFO *pLMCtxt = (LM_CALLBACK_INFO *) _ulCallbackContext ;
            pLMCtxt->plmobjNetAccess1 = &_lmobjNetAccess1 ;
        }

        if ( err = _pfuncCallback( QueryWritePermHwnd(),
                                   NULL,
                                   _ulCallbackContext,
                                   NULL,
                                   NULL,
                                   (BOOLEAN)fApplyToSubContainers,
                                   (BOOLEAN)fApplyToSubObjects,
                                   &dwReturnStatus ) )
        {
            *pfReportError = FALSE ;
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::FindInherittingResource

    SYNOPSIS:   Finds what resource, if any, the current resource is
                inheritting its permissions from.

    ENTRY:      pnlsInherittingResName - Pointer to string that will
                contain the resource name the permissions are being
                inheritted from

                The data member _lmobjNetAccess1 should be pointing to
                the resource we are interested in.

    RETURNS:    NERR_ResourceNotFound if there are no inheritting resources.

    NOTES:      Assumes the resident NET_ACCESS_1 object already contains
                a valid resource (that doesn't have an ACL on it).

                Currently, we are assuming the resource is a drive path.

                The _lmobjNetAccess1 member will be restored to its
                original value before exitting (i.e., resource name).

                We check the parent directory, then the drive permissions.

    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::FindInherittingResource( void )
{
    UIASSERT( _lmobjNetAccess1.QueryError() == NERR_Success ) ;

    NLS_STR nlsResName = _lmobjNetAccess1.QueryName() ;
    NLS_STR nlsResNameSave = nlsResName ;

    APIERR err ;
    if ( (err = nlsResName.QueryError() ) != NERR_Success ||
         (err = nlsResNameSave.QueryError() ) != NERR_Success )
    {
        return err ;
    }

    ISTR istrResName( nlsResName ) ;

    BOOL fDone  = FALSE ;
    BOOL fCheckParentDir = TRUE ;
    while ( !fDone )
    {
        if ( fCheckParentDir )
        {
            /* Check the parent directory by removing the last component
             */
            if ( nlsResName.strrchr( &istrResName, TCH('\\') ) )
            {
                /* Found a '\\', truncate the
                 * string starting with the found '\\'
                 */
                nlsResName.DelSubStr( istrResName ) ;
            }
            else
            {
                /* We were passed an "X:" which we aren't ever expecting
                 */
                UIASSERT(FALSE) ;
            }
            fCheckParentDir = FALSE ;
        }
        else
        {
            /* Truncate everything after the ':' and check the drive
             * permissions
             */
            ISTR istrColon( nlsResName ) ;
            REQUIRE( nlsResName.strchr( &istrColon, TCH(':') ) ) ;
            nlsResName.DelSubStr( ++istrColon ) ;
            fDone = TRUE ;
        }

        /* We now have a candidate for resources to be inheritted from,
         * attempt to get the ACL and watch for any errors.
         */

        err = _lmobjNetAccess1.SetName( nlsResName ) ;
        if ( err != NERR_Success )
        {
            REQUIRE( _lmobjNetAccess1.SetName( nlsResNameSave ) ==NERR_Success);
            break ;
        }

        err = _lmobjNetAccess1.GetInfo() ;
        switch ( err )
        {
        case NERR_Success:
            _nlsInherittingResName = nlsResName ;
            REQUIRE( _lmobjNetAccess1.SetName( nlsResNameSave ) ==NERR_Success);
            UIDEBUG(SZ("LM_ACL_TO_PERM_CONVERTER::FindInherittingResource - Found inheritting resource\n\r")) ;
            return _nlsInherittingResName.QueryError() ;

        case NERR_ResourceNotFound:     // No ACL on this resource
            if ( fDone )
            {
                REQUIRE( _lmobjNetAccess1.SetName( nlsResNameSave )
                                                             == NERR_Success ) ;
                UIDEBUG(SZ("LM_ACL_TO_PERM_CONVERTER::FindInherittingResource - No resource to inherit from\n\r")) ;
                return err ;
            }
            break ;

        default:
            REQUIRE( _lmobjNetAccess1.SetName( nlsResNameSave ) ==NERR_Success);
            return err ;
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::QueryInherittingResource

    SYNOPSIS:   Simple access method to saved inheritting resource name

    ENTRY:      pnlsInherittingResName

    RETURNS:    Error code of copy

    NOTES:

    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::QueryInherittingResource(
                                              NLS_STR * pnlsInherittingResName )
{
    *pnlsInherittingResName = _nlsInherittingResName ;
    return pnlsInherittingResName->QueryError() ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::QueryFailingSubject

    SYNOPSIS:   Returns the first User/Group that is currently in the
                ACL but is no longer in the UAS of the server.

    ENTRY:      pnlsSubjUniqueName - Pointer to NLS_STR that will receive the
                    subject.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      This should be called immediately after WritePermissions and
                only if WritePermissions returned NERR_UserNotFound.

    HISTORY:
        Johnl   24-Oct-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::QueryFailingSubject(
                                                  NLS_STR * pnlsSubjUniqueName )
{
    enum PERMNAME_TYPE nametype ;
    return _lmobjNetAccess1.QueryFailingName( pnlsSubjUniqueName, &nametype ) ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::FailToSuccessAuditFlags

    SYNOPSIS:   Maps the failed audit bits to the success audit bits.
                This is necessary because the failed audit bits in the
                acl editor or represented by the success audit bits (i.e.,
                both success and fail use the same mask map).

    ENTRY:      usFailAuditMask - Mask of failed audit bits

    RETURNS:    A mask of success audit bits that correspond to the
                failed audit bits

    NOTES:      The Write and Create audit mask have the same value, so we
                will assert they are the same and use one of them.

    HISTORY:
        Johnl   01-Oct-1991     Created

********************************************************************/

USHORT LM_ACL_TO_PERM_CONVERTER::FailToSuccessAuditFlags(USHORT usFailAuditMask)
{
    UIASSERT( AA_F_WRITE == AA_F_CREATE ) ;

    USHORT usSuccessMask = 0 ;

    usSuccessMask |= (usFailAuditMask & AA_F_OPEN   ? AA_S_OPEN : 0 ) ;
    usSuccessMask |= (usFailAuditMask & AA_F_WRITE  ? AA_S_WRITE : 0 ) ;
    usSuccessMask |= (usFailAuditMask & AA_F_DELETE ? AA_S_DELETE : 0 ) ;
    usSuccessMask |= (usFailAuditMask & AA_F_ACL    ? AA_S_ACL : 0 ) ;

    return usSuccessMask ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::SuccessFailAuditFlags

    SYNOPSIS:   Same as FailToSuccessAuditFlags only in reverse.

    NOTES:

    HISTORY:
        Johnl   01-Oct-1991     Created

********************************************************************/

USHORT LM_ACL_TO_PERM_CONVERTER::SuccessToFailAuditFlags(
                                                     USHORT usSuccessAuditMask )
{
    UIASSERT( AA_S_WRITE == AA_S_CREATE ) ;

    USHORT usFailedMask = 0 ;

    usFailedMask |= (usSuccessAuditMask & AA_S_OPEN   ? AA_F_OPEN : 0 ) ;
    usFailedMask |= (usSuccessAuditMask & AA_S_WRITE  ? AA_F_WRITE : 0 ) ;
    usFailedMask |= (usSuccessAuditMask & AA_S_DELETE ? AA_F_DELETE : 0 ) ;
    usFailedMask |= (usSuccessAuditMask & AA_S_ACL    ? AA_F_ACL : 0 ) ;

    return usFailedMask ;
}

/*******************************************************************

    NAME:       LM_CANCEL_TREE_APPLY::WriteSecurity

    SYNOPSIS:   Writes permission/audit info to a LM server

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Note that we have to check for existing info since LM doesn't
                support setting audit and permissions separately.

    HISTORY:
        Johnl   24-Oct-1992     Created

********************************************************************/

APIERR LM_CANCEL_TREE_APPLY::WriteSecurity( ULONG_PTR     ulContext,
                                            const TCHAR * pszFileName,
                                            BOOL          fIsFile,
                                            BOOL        * pfContinue  )
{
    LM_TREE_APPLY_CONTEXT * pCtxt = (LM_TREE_APPLY_CONTEXT*) ulContext ;
    APIERR err ;
    *pfContinue = TRUE ;

    NET_ACCESS_1 lmobjNewRes( pCtxt->plmobjNetAccess1->QueryServerName(),
                              pszFileName ) ;

    if ( !(err = lmobjNewRes.QueryError() ) )
    {
        BOOL fWriteNew = TRUE ;
        BOOL fWillInheritFromParent = FALSE ;

        switch ( err = lmobjNewRes.GetInfo() )
        {
        case NERR_Success:
            fWriteNew = FALSE ;
            // Fall through

        case NERR_ResourceNotFound:
            if ( err )
            {
                if ( (err = lmobjNewRes.CreateNew()) ||
                     (err = lmobjNewRes.SetAuditFlags( 0 )) )
                {
                    break ;
                }
            }
            err = NERR_Success ;

            /* If we are dealing with permissions (not auditting)
             *     and we are in tree apply mode (thus the parent dir will
             *         have the permission and this file will inherit from it)
             *     and the resource is a file
             *     and nothing is auditted
             * then set the flag indicating the ACL should be deleted
             * from the resource
             */
            if ( (pCtxt->fApplyToSubContainers ||
                  pCtxt->fApplyToDirContents     ) &&
                 pCtxt->sedpermtype != SED_AUDITS  &&
                 fIsFile                           &&
                 !pCtxt->plmobjNetAccess1->QueryAuditFlags())
            {
                fWillInheritFromParent = TRUE ;
                break ;
            }

            if ( pCtxt->sedpermtype == SED_AUDITS )
            {
                err = lmobjNewRes.SetAuditFlags(
                                   (short)pCtxt->plmobjNetAccess1->QueryAuditFlags() ) ;
            }
            else
            {
                UIASSERT( pCtxt->sedpermtype == SED_ACCESSES ) ;
                err = lmobjNewRes.CopyAccessPerms( *pCtxt->plmobjNetAccess1 ) ;
            }
            break ;

        default:
            break ;
        }


        if ( !err )
        {
            if ( fWillInheritFromParent )
            {
                /* Only delete the ACL if an ACL exists on the file
                 */
                if ( !fWriteNew )
                    err = lmobjNewRes.Delete() ;
            }
            else if ( fWriteNew )
                err = lmobjNewRes.WriteNew() ;
            else
                err = lmobjNewRes.Write() ;
        }
    }

    return err ;
}




/*******************************************************************

    NAME:       QueryLoggedOnDomainInfo

    SYNOPSIS:   Gets a DC from the domain the current user is logged onto or
                /and the domain the user is currently logged onto

    ENTRY:      pnlsDC - String to receive the DC name (may be NULL)
                pnlsDomain - String to receive the domain name (may be NULL)
                hwnd - Window handle to use for reporting non-fatal errors

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      If the workstation is not started or the user is logged on
                locally, then *pnlsDC will be set to the empty string.

    HISTORY:
        Johnl   10-Sep-1992     Created

********************************************************************/

APIERR QueryLoggedOnDomainInfo( NLS_STR * pnlsDC,
                                NLS_STR * pnlsDomain,
                                HWND      hwnd )
{
    APIERR err = NERR_Success ;
    NLS_STR nlsLoggedOnDomain( DNLEN+1 ) ;
    NLS_STR nlsLoggedOnDC( RMLEN+1 ) ;      // Default to the empty string

    do { // error break out
        TCHAR achComputerName[MAX_COMPUTERNAME_LENGTH+1] ;
        DWORD cchComputerName = MAX_COMPUTERNAME_LENGTH;
        WKSTA_10 wksta10( NULL ) ;

        // get the computer name
        if ( !::GetComputerName( achComputerName, &cchComputerName ))
        {
            err = ::GetLastError() ;
            DBGEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo, " <<
                   "error getting the computer name, error " << err ) ;
            break ;
        }

        //
        // get the logon domain info from a WKSTA object
        //
        if ( (err = wksta10.QueryError()) ||
             (err = nlsLoggedOnDomain.QueryError()) ||
             (err = nlsLoggedOnDC.QueryError())     ||
             (err = wksta10.GetInfo())    ||
             (err = nlsLoggedOnDomain.CopyFrom( wksta10.QueryLogonDomain())) )
        {
            //
            //   If the network isn't started, then we have to be logged on
            //   locally.
            //

            if ( (err == ERROR_NO_NETWORK) ||
                 (err == NERR_WkstaNotStarted) )
            {
                err = NERR_Success ;
            }
            else
            {
                break ;
            }

            ALIAS_STR nlsComputer( achComputerName ) ;
            if ( (err = nlsLoggedOnDomain.CopyFrom( nlsComputer )) )
            {
                ;
            }

            /* Don't need to continue. The wksta is not started, so we
             * use logged on domain==localmachine and empty string for the
             * DC name.
             */
            break ;
        }

        /* Check if the logged on domain is the same as the computer
         * name.  If it is, then the user is logged on locally.
         */
        if ( !::I_MNetComputerNameCompare( achComputerName,
                                           wksta10.QueryLogonDomain()))
        {
            TRACEEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo, " <<
                     " user is logged on locally") ;
            ALIAS_STR nlsComputer( achComputerName ) ;
            if ( (err = nlsLoggedOnDomain.CopyFrom( nlsComputer )))
            {
                break ;
            }

            /* Don't need to continue since the logged on domain is
             * the local machine.
             */
            break ;
        }

        //
        //   If not interested in a DC, then don't get one
        //
        if ( pnlsDC == NULL )
            break ;

        DOMAIN_WITH_DC_CACHE domLoggedOn( wksta10.QueryLogonDomain(),
                                          TRUE ) ;
        TRACEEOL("::QueryLoggedOnDomainInfo - About to get logged on DC @ " << ::GetTickCount() / 100) ;
        if ( (err = domLoggedOn.GetInfo()) ||
             (err = nlsLoggedOnDC.CopyFrom( domLoggedOn.QueryAnyDC())) )
        {
            DBGEOL("::QueryLoggedOnDomainInfo, " <<
                   " error " << err << " on domain get info for " <<
                   wksta10.QueryLogonDomain() ) ;

            //
            //  There are some errors which we will just warn the user
            //  but allow them to continue though the "focused" dc will
            //  switch to the local machine.
            //
            if ( err == NERR_DCNotFound )
            {
                RESOURCE_STR nlsError( err ) ;
                if ( nlsError.QueryError() )
                {
                    DEC_STR numStr( err ) ;
                    if ( (err = numStr.QueryError()) ||
                         (err = nlsError.CopyFrom( numStr )) )
                    {
                        break ;
                    }
                }

                ::MsgPopup( hwnd,
                            IDS_CANT_FOCUS_ON_LOGGED_ON_DOMAIN,
                            MPSEV_WARNING,
                            MP_OK,
                            wksta10.QueryLogonDomain(),
                            nlsError ) ;

                err = NERR_Success ;
                //
                // Leave nlsLoggedOnDC empty for the local machine
                //
            }
            else
            {
                break ;
            }
        }
        TRACEEOL("::QueryLoggedOnDomainInfo - Done getting logged on DC @ " << ::GetTickCount() / 100) ;
    } while (FALSE) ;


    if ( !err )
    {
        if ( pnlsDC != NULL )
            err = pnlsDC->CopyFrom( nlsLoggedOnDC ) ;

        if ( !err && pnlsDomain != NULL )
            err = pnlsDomain->CopyFrom( nlsLoggedOnDomain ) ;
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\owner.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*

    Owner.cxx

    This file contains the implementation for the Set Ownership dialog.


    FILE HISTORY:
        Johnl   12-Feb-1992     Created

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
    #include <ntsam.h>
    #include <ntlsa.h>
}

#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_DIALOG
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

extern "C"
{
    #include <netlib.h>         // For NetpGetPrivilege
    #include <mnet.h>
    #include <lmuidbcs.h>       // NETUI_IsDBCS()
}

#include <stdlib.h>
#include <dbgstr.hxx>
#include <uiassert.hxx>
#include <uitrace.hxx>
#include <security.hxx>
#include <subject.hxx>
#include <permstr.hxx>
#include <ntacutil.hxx>
#include <uintlsa.hxx>
#include <uintsam.hxx>
#include <strnumer.hxx>
#include <apisess.hxx>

#include <accperm.hxx>
#include <aclconv.hxx>
#include <subject.hxx>
#include <perm.hxx>

#include <helpnums.h>
#include <owner.hxx>



/*******************************************************************

    NAME:       TAKE_OWNERSHIP_DLG::TAKE_OWNERSHIP_DLG

    SYNOPSIS:   Constructor for the Take ownership dialog

    ENTRY:      pszDialogName - Resource template
                hwndParent    - Parent window handle
                uiCount       - Number of objects we are about to take
                                ownership of
                pchResourceType - Name of the resource type ("File" etc.)
                pchResourceName - Name of the resource ("C:\status.doc")
                psecdesc        - Pointer to security descriptor that contains
                                  the owner sid.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   12-Feb-1992     Created
        beng    06-Apr-1992     Replaced ltoa

********************************************************************/


TAKE_OWNERSHIP_DLG::TAKE_OWNERSHIP_DLG(
                    const TCHAR * pszDialogName,
                    HWND          hwndParent,
                    const TCHAR * pszServer,
                    UINT          uiCount,
                    const TCHAR * pchResourceType,
                    const TCHAR * pchResourceName,
                    PSECURITY_DESCRIPTOR psecdesc,
                    PSED_HELP_INFO psedhelpinfo
                   )
    : DIALOG_WINDOW       ( pszDialogName, hwndParent ),
      _sltResourceType    ( this, SLT_OWNER_RESOURCE_TYPE ),
      _sleResourceName    ( this, SLE_OWNER_RESOURCE_NAME ),
      _sltOwner           ( this, SLT_OWNER ),
      _sleOwnerName       ( this, SLE_OWNER_NAME ),
      _sltXObjectsSelected( this, SLT_X_OBJECTS_SELECTED ),
      _buttonTakeOwnership( this, BUTTON_TAKE_OWNERSHIP ),
      _buttonOK           ( this, IDOK ),
      _pszServer          ( pszServer  ),
      _nlsHelpFileName    ( psedhelpinfo->pszHelpFileName ),
      _ulHelpContext      ( psedhelpinfo->aulHelpContext[HC_MAIN_DLG] )
{
    APIERR err ;
    AUTO_CURSOR niftycursor ;

    if ( QueryError() )
        return ;

    if ( err = _nlsHelpFileName.QueryError() )
    {
        ReportError( err ) ;
        return ;
    }

    /* If more then one object is selected, then the dialog only displays
     * the message: "%d Files/Directories Selected", thus we need to
     * disable the other controls and enable the X-Objects selected SLT.
     */
    if ( uiCount > 1 )
    {
        _sltResourceType.Show( FALSE ) ;
        _sltResourceType.Enable( FALSE ) ;
        _sleResourceName.Show( FALSE ) ;
        _sleResourceName.Enable( FALSE ) ;
        _sltOwner.Show( FALSE ) ;
        _sltOwner.Enable( FALSE ) ;
        _sleOwnerName.Show( FALSE ) ;
        _sleOwnerName.Enable( FALSE ) ;

        _sltXObjectsSelected.Enable( TRUE ) ;
        _sltXObjectsSelected.Show( TRUE ) ;

        RESOURCE_STR nlsXObjSelectedTitle( IDS_X_OBJECTS_SELECTED ) ;
        ALIAS_STR    nlsResType( pchResourceType ) ;
        const NLS_STR *    apnlsInsertParams[3] ;
        DEC_STR      nlsCount( uiCount );

        apnlsInsertParams[0] = &nlsCount ;
        apnlsInsertParams[1] = &nlsResType ;
        apnlsInsertParams[2] = NULL ;

        if ( (err = nlsXObjSelectedTitle.QueryError()) ||
             (err = nlsCount.QueryError())  ||
             (err = nlsXObjSelectedTitle.InsertParams( apnlsInsertParams )))
        {
            ReportError( err ) ;
            return ;
        }

        _sltXObjectsSelected.SetText( nlsXObjSelectedTitle ) ;
    }
    else
    {
        /* Need to put together the resource name field which will look
         * something like: "File Name:"
         */
        RESOURCE_STR nlsResourceTitle( IDS_RESOURCE_TITLE ) ;
        ALIAS_STR    nlsResourceType( pchResourceType ) ;
        const NLS_STR    * apnlsInsertParams[2] ;

        apnlsInsertParams[0] = &nlsResourceType ;
        apnlsInsertParams[1] = NULL ;

        if ( (err = nlsResourceTitle.QueryError()) ||
             (err = nlsResourceTitle.InsertParams( apnlsInsertParams )))
        {
            ReportError( err ) ;
            return ;
        }

    /* Watch for any "(&?)" accelerators in the resource title
     * and move it to end of title
     * like this "file(&f) name:" --> "file name(&f):"
     *
     * Note that this will work only if there exists 1 left paren.
     */
    ISTR istrAccelStart( nlsResourceTitle ) ;
    if (   NETUI_IsDBCS() /* #2894 22-Oct-93 v-katsuy */
        && nlsResourceTitle.strchr( &istrAccelStart, TCH('(') ))
    {
    /* We found an "(", if next is not "&", then ignore it
     */
    ISTR istrAccelNext( istrAccelStart ) ;
    if ( nlsResourceTitle.QueryChar( ++istrAccelNext ) == TCH('&'))
    {
        /* We found an "&", if it is doubled, then ignore it, else restore it
         */
        if ( nlsResourceTitle.QueryChar( ++istrAccelNext ) != TCH('&'))
        {
        NLS_STR nlsAccelWork(64) ;
        ISTR istrAccelWork( nlsAccelWork) ;
        ISTR istrAccelWork2( nlsAccelWork) ;
        ISTR istrAccelRestore( istrAccelStart) ;

        /* save Accelerators
         */
        nlsAccelWork.CopyFrom( nlsResourceTitle ) ;
        nlsAccelWork.strchr( &istrAccelWork2, TCH('(') ) ;
            nlsAccelWork.DelSubStr( istrAccelWork, istrAccelWork2 ) ;
        nlsAccelWork.strchr( &istrAccelWork, TCH(')') ) ;
        nlsAccelWork.strchr( &istrAccelWork2, TCH(':') ) ;
            nlsAccelWork.DelSubStr( ++istrAccelWork, ++istrAccelWork2 ) ;

        /* remove "(&?)"
         */
        istrAccelNext += 2 ;
            nlsResourceTitle.DelSubStr( istrAccelStart, istrAccelNext ) ;
        
        /* restore Accelerators
         */
        nlsResourceTitle.strchr( &istrAccelRestore, TCH(':') ) ;
        nlsResourceTitle.InsertStr( nlsAccelWork, istrAccelRestore ) ;
        }
    }
    }

        _sltResourceType.SetText( nlsResourceTitle ) ;
        _sleResourceName.SetText( pchResourceName ) ;


        /* Now figure out the owner name from the security descriptor
         */
        OS_SECURITY_DESCRIPTOR osSecDescOwner( psecdesc ) ;
        OS_SID * possidOwner ;
        BOOL     fOwnerPresent ;

        if ( ( err = osSecDescOwner.QueryError() ) ||
             ( err = osSecDescOwner.QueryOwner( &fOwnerPresent, &possidOwner )))
        {
            ReportError( err ) ;
            return ;
        }

        /* If the owner's not present in the security descriptor, then we
         * will display "No current owner" or some such in the owner field.
         */
        if ( !fOwnerPresent )
        {
            DBGEOL(SZ("TAKE_OWNERSHIP_DLG::ct - Security descriptor doesn't have an owner SID.")) ;
            RESOURCE_STR nlsNoOwnerTitle( IDS_NO_OWNER ) ;
            if ( err = nlsNoOwnerTitle.QueryError() )
            {
                ReportError( err ) ;
                return ;
            }

            _sleOwnerName.SetText( nlsNoOwnerTitle ) ;
        }
        else
        {
            NLS_STR nlsOwnerName ;
            if ( (err = nlsOwnerName.QueryError())  ||
                 (err = possidOwner->QueryName( &nlsOwnerName,
                                                pszServer,
                                                NULL )) )
            {
                ReportError( err ) ;
                return ;
            }

            _sleOwnerName.SetText( nlsOwnerName ) ;
        }
    }

    _buttonOK.ClaimFocus() ;
}

TAKE_OWNERSHIP_DLG::~TAKE_OWNERSHIP_DLG()
{
    /* Nothing to do
     */
}


/*******************************************************************

    NAME:       TAKE_OWNERSHIP_DLG::OnCommand

    SYNOPSIS:   Watches for the user pressing the "Take Ownership" button
                and does the call out appropriately.

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   12-Feb-1992     Created
        ChuckC  07-May-1993     Special case lookup of "None"

********************************************************************/

BOOL TAKE_OWNERSHIP_DLG::OnCommand( const CONTROL_EVENT & event )
{
    APIERR err = NERR_Success ;
    BOOL   fDismiss = TRUE ;
    BOOL fPrivAdjusted = FALSE ;    // Only used when the take ownership button is
                                    // pressed

    switch ( event.QueryCid() )
    {
    case BUTTON_TAKE_OWNERSHIP:
        {

            /* To build the new security descriptor we do the folloing:
             *
             *  0) See if the current process SIDs are recognized on the
             *     remote machine (by doing TranslateSidsToNames), if that
             *     succeeds, use those, otherwise do steps 1-4
             *     and popup a message with who the new owner/group is.
             *  1) Look up owner/primary group SID on the local machine
             *     If necessary, special case the None primary group.
             *  2) Look up the names from the SIDs we just looked up locally
             *  3) Look up the SIDs on the remote machine with the names we
             *          we just looked up
             *  4) Put these SIDs into the security security descriptor
             */
            OS_SECURITY_DESCRIPTOR ossecdescNew ;
            API_SESSION            APISession( _pszServer, TRUE ) ;
            LSA_POLICY             LSAPolicyLocalMachine( NULL ) ;
            LSA_POLICY             LSAPolicyRemoteMachine( _pszServer ) ;
            LSA_TRANSLATED_SID_MEM LSATransSidMem ;
            LSA_REF_DOMAIN_MEM     LSARefDomainMem ;
            LSA_TRANSLATED_NAME_MEM LSATransNameMem ;
            OS_SID ossidOwner ;
            OS_SID ossidGroup ;
            NLS_STR nlsNewOwner ;
            NLS_STR nlsNewOwnerDom ;
            NLS_STR nlsNewGroup ;
            NLS_STR nlsNewGroupDom ;
            NLS_STR nlsQualifiedOwner ;
            NLS_STR nlsQualifiedGroup ;


            do {    // error break out, not a loop

                AUTO_CURSOR niftycursor ;

                //
                //  Enable the SeTakeOwnershipPrivilege
                //
                ULONG ulTakeOwnershipPriv = SE_TAKE_OWNERSHIP_PRIVILEGE ;
                if ( err = ::NetpGetPrivilege( 1, &ulTakeOwnershipPriv ))
                {
                    if ( err != ERROR_PRIVILEGE_NOT_HELD )
                    {
                        break ;
                    }
                    //
                    // The user doesn't have the privilege but they may have
                    // permission, so go ahead and try it anyway
                    //
                    err = NERR_Success ;
                    TRACEEOL("TAKE_OWNERSHIP_DLG::OnCommand - Take Ownership Privilege not held by user") ;
                }
                else
                {
                    fPrivAdjusted = TRUE ;
                }

                if ( (err = ossecdescNew.QueryError())              ||
                     (err = ossidOwner.QueryError())                ||
                     (err = ossidGroup.QueryError())                ||
                     (err = APISession.QueryError())                ||
                     (err = LSAPolicyLocalMachine.QueryError())     ||
                     (err = LSAPolicyRemoteMachine.QueryError())    ||
                     (err = LSATransSidMem.QueryError())            ||
                     (err = LSARefDomainMem.QueryError())           ||
                     (err = LSATransNameMem.QueryError())           ||
                     (err = nlsNewOwner.QueryError())               ||
                     (err = nlsNewOwnerDom.QueryError())            ||
                     (err = nlsQualifiedOwner.QueryError())         ||
                     (err = nlsNewGroup.QueryError())               ||
                     (err = nlsNewGroupDom.QueryError())            ||
                     (err = nlsQualifiedGroup.QueryError())         ||
                     (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                     UI_SID_CurrentProcessOwner,
                                     &ossidOwner ))                 ||
                     (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                     UI_SID_CurrentProcessPrimaryGroup,
                                     &ossidGroup ))    )
                {
                    DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Error " << err <<
                            " constructing LSA stuff.") ;
                    break ;
                }

                PSID apsid[2] ;
                apsid[0] = ossidOwner.QueryPSID() ;
                apsid[1] = ossidGroup.QueryPSID() ;

                /* Try looking up the SIDs on the remote machine.  If this
                 * succeeds, then use these
                 */
                if (!_pszServer) // local
                {
                    if ( (err = LSAPolicyLocalMachine.TranslateSidsToNames(
                                                        apsid,
                                                        2,
                                                        &LSATransNameMem,
                                                        &LSARefDomainMem)))
                    {
                        DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Error " << err <<
                               " calling TranslateSidsToNames on remote machine") ;
                        break ;
                    } 
                } // local

                //
                // stick them new SIDs into the the security descriptor
                if ( !_pszServer && (LSATransNameMem.QueryUse(0) != SidTypeInvalid) &&
                     (LSATransNameMem.QueryUse(0) != SidTypeUnknown) &&
                     (LSATransNameMem.QueryUse(1) != SidTypeInvalid) &&
                     (LSATransNameMem.QueryUse(1) != SidTypeUnknown)   )
                {
                    /* Local lookup succeeded, we can use these
                     * for the owner and group SIDs
                     *
                     * Fall through...
                     */
                }
                else
                {
                    /* We have to do it the hard way.
                     */
                    UINT nSids = 2 ;           // number of sids we need resolve
                    BOOL fLookupGroup = TRUE ; // initially, we need both
                    PULONG pulGroupRID = 0 ;
                    OS_SID ossidUseThisGroup ;
                    LSA_ACCT_DOM_INFO_MEM RemoteDomain ;

                    if ((err = ossidGroup.QueryLastSubAuthority(&pulGroupRID))||
                        (err = ossidUseThisGroup.QueryError()) ||
                        (err = RemoteDomain.QueryError()))
                    {
                        break ;
                    }

                    //
                    //  get the account domain SID on remote machine
                    //
                    if (err = LSAPolicyRemoteMachine.GetAccountDomain(
                                   &RemoteDomain))
                    {
                        break ;
                    }

                    if (*pulGroupRID == DOMAIN_GROUP_RID_USERS)
                    {
                        //
                        // we have a "None" or "Domain Users" as primary group
                        // they both have the same RID, but if we translated
                        // it to its name and looked up the name None on a DC,
                        // it wont be found (since it will be "Domain Users"
                        // instead). so we build the SID up by hand
                        // instead of looking it up.
                        //

                        //
                        //  build up the SID
                        //
                        OS_SID ossidDomainUsers( RemoteDomain.QueryPSID(),
                                           (ULONG) DOMAIN_GROUP_RID_USERS );
                        if ((err = ossidDomainUsers.QueryError()) ||
                            (err = ossidUseThisGroup.Copy(ossidDomainUsers)))
                        {
                            break ;
                        }


                        //
                        // dont bother looking up the group.
                        //
                        nSids = 1 ;
                        fLookupGroup = FALSE ;
                    } // DOMAIN_GROUP_RID_USERS


                    if (_pszServer == NULL) 
                    {
                        // the domain lookup failed and this is on the 
                        // local machine so use the local machine sids
                        //
                        if ( (err = LSAPolicyLocalMachine.TranslateSidsToNames(
                                                          apsid,
                                                          nSids,
                                                          &LSATransNameMem,
                                                          &LSARefDomainMem)))
                            break ;
                        if ( (err = LSATransNameMem.QueryName( 0, &nlsNewOwner )) ||
                             (err = LSARefDomainMem.QueryName(
                                           LSATransNameMem.QueryDomainIndex( 0 ),
                                           &nlsNewOwnerDom)))
                            break ;
                        if ( fLookupGroup && (
                                (err = LSATransNameMem.QueryName( 1, &nlsNewGroup )) ||
                                (err = LSARefDomainMem.QueryName(
                                           LSATransNameMem.QueryDomainIndex( 1 ),
                                           &nlsNewGroupDom))))
                            break ;

                    }
                    else // this is a remote connection - find out who owns the session
                    {
                        PUNICODE_STRING pwszNewOwner = NULL;
                        PUNICODE_STRING pwszNewOwnerDom = NULL;
                        UNICODE_STRING wszServer;

                        wszServer.Length = (UINT) (sizeof (WCHAR) * wcslen (_pszServer));  // bytes w/o NULL
                        wszServer.MaximumLength = wszServer.Length + sizeof (WCHAR);       // bytes w/ NULL
                        wszServer.Buffer = (PWSTR) _pszServer;

                        if (err = LsaGetRemoteUserName(&wszServer,
                                                   &pwszNewOwner, 
                                                   &pwszNewOwnerDom))
                            break;

                        if (err = nlsNewOwner.MapCopyFrom(pwszNewOwner->Buffer))
                            break;
                        if (err = nlsNewOwnerDom.MapCopyFrom(pwszNewOwnerDom->Buffer))
                            break;
                        RtlFreeUnicodeString(pwszNewOwner);
                        RtlFreeUnicodeString(pwszNewOwnerDom);

                        //
                        // dont bother looking up the group.
                        //
                        ossidUseThisGroup = ossidGroup;
                        nSids = 1 ;
                        fLookupGroup = FALSE ;
                    }

                    //
                    //  If the domain name matches the local domain name
                    //  (indicating the accounts exist on the local machine),
                    //  substitute the remote machine name for the local domain
                    //  name and continue, otherwise use the real domain name.
                    //

                    NLS_STR nlsLocalDomain ;
                    LSA_ACCT_DOM_INFO_MEM LocalDomain ;

                    if ((err = nlsLocalDomain.QueryError()) ||
                        (err = LocalDomain.QueryError())    ||
                        (err = LSAPolicyLocalMachine.GetAccountDomain(
                                   &LocalDomain)) ||
                        (err = LocalDomain.QueryName( &nlsLocalDomain )))
                    {
                        break ;
                    }

                    if( !::I_MNetComputerNameCompare( nlsNewOwnerDom,
                                                      nlsLocalDomain ))
                    {
                        if (err = RemoteDomain.QueryName(&nlsNewOwnerDom))
                            break ;
                    }

                    if( fLookupGroup && !::I_MNetComputerNameCompare( nlsNewGroupDom,
                                                                          nlsLocalDomain))
                    {
                        if (err = RemoteDomain.QueryName(&nlsNewGroupDom))
                            break ;
                    }

                    if ((err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                       &nlsQualifiedOwner,
                                       nlsNewOwner,
                                       nlsNewOwnerDom )) ||
                        (fLookupGroup && (err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                       &nlsQualifiedGroup,
                                       nlsNewGroup,
                                       nlsNewGroupDom ))) )
                    {
                        DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Error " << err <<
                               " calling TranslateSidsToNames on local machine") ;
                        break ;
                    }

                    TRACEEOL("TAKE_OWNERSHIP_DLG::OnCommand - qualified owner "
                              << " and group: " << nlsQualifiedOwner << "  "
                              << nlsQualifiedGroup ) ;

                    //
                    //  Now we have the names of the user and group.  Lookup the
                    //  sids on the remote machine
                    //
                    const TCHAR * apsz[2] ;
                    apsz[0] = nlsQualifiedOwner.QueryPch() ;
                    apsz[1] = nlsQualifiedGroup.QueryPch() ;
                    ULONG ulDummy = 0xffffffff ;
                    if ( (err = LSAPolicyRemoteMachine.TranslateNamesToSids(
                                                         apsz,
                                                         nSids,
                                                         &LSATransSidMem,
                                                         &LSARefDomainMem)) ||
                         LSATransSidMem.QueryFailingNameIndex( &ulDummy ) )
                    {
                        DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Error " << err <<
                               " calling TranslateNamesToSids or QueryFailingNameIndex failed") ;

                        //
                        //  Map any partial lookups or "Group not found" error
                        //  to "Account not found"
                        //

						// NTRAID#NTBUG9-576955-2002/03/07-artm  Prefast: accidental assignment in if()
						// Should probably be err == NERR_GroupNotFound
                        if ( (ulDummy != 0xffffffff) ||
                             (err = NERR_GroupNotFound) )
                        {
                            err = IDS_OWNER_ACCOUNT_NOT_FOUND ;
                        }

                        RESOURCE_STR nlsError( (MSGID) err ) ;
                        if ( err = nlsError.QueryError() )
                        {
                            DEC_STR decStr( err ) ;
                            if ( (err = decStr.QueryError() ) ||
                                 (err = nlsError.CopyFrom( decStr )) )
                            {
                                break ;
                            }
                        }

                        NLS_STR * apnls[3] ;

                        //
                        //  If ulDummy is 1, then the group account wasnt found,
                        //  else it will be either 0 or -1, in which case we
                        //  will always display the primary group name
                        //
                        apnls[0] = (fLookupGroup && (ulDummy == 1)) ?
                                   &nlsQualifiedGroup :
                                   &nlsQualifiedOwner ;
                        apnls[1] = &nlsError ;
                        apnls[2] = NULL ;

                        MsgPopup( this,
                                  IDS_OWNER_CANT_FIND_OWNR_OR_GRP,
                                  MPSEV_ERROR,
                                  HC_DEFAULT_HELP,
                                  MP_OK,
                                  apnls ) ;
                        fDismiss = FALSE ;
                        break ;
                    } // remote lookup failure

                    //
                    // now build the new owner SID based on looked up info
                    //
                    OS_SID ossidNewOwner( LSARefDomainMem.QueryPSID(
                                          LSATransSidMem.QueryDomainIndex(0) ),
                                          LSATransSidMem.QueryRID( 0 )  ) ;

                    if ( (err = ossidNewOwner.QueryError()) ||
                         (err = ossidOwner.Copy( ossidNewOwner )) )
                    {
                        break ;
                    }

                    //
                    // either build the new group SID based on looked up info
                    // or copy from the one we built ourselves if it is the
                    // None group.
                    //
                    if (fLookupGroup)
                    {
                        OS_SID ossidNewGroup( LSARefDomainMem.QueryPSID(
                                          LSATransSidMem.QueryDomainIndex(1) ),
                                          LSATransSidMem.QueryRID( 1 )  ) ;

                        if ((err = ossidNewGroup.QueryError()) ||
                            (err = ossidGroup.Copy( ossidNewGroup )) )
                        {
                            break ;
                        }
                    }
                    else
                    {
                        if (err = ossidGroup.Copy( ossidUseThisGroup ))
                            break ;
                    }
                } // "doing it the hard way"

                //
                // stick them new SIDs into the the security descriptor
                //
                if (err = ossecdescNew.SetOwner( ossidOwner ))
                {
                    break;
                }
                if (err = ossecdescNew.SetGroup( ossidGroup ))
                {
                    break ;
                }

                //
                // User error messages are handled by the callback method
                // We only dismiss if the OnTakeOwnership was successful
                // (we don't display an error if it fails).
                //
                APIERR errOnTakeOwner ;
                if ( errOnTakeOwner =  OnTakeOwnership( ossecdescNew ))
                {
                    DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - OnTakeOwnership "
                           << "returned " << errOnTakeOwner ) ;
                    fDismiss = FALSE ;
                }

            } while (FALSE) ;

            if ( err )
            {
                DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Error " << err <<
                       " returned from OnTakeOwnership") ;
                MsgPopup( this, err ) ;
                fDismiss = FALSE ;
            }

            if ( fDismiss )
            {
                Dismiss() ;
            }

            //
            // Restore the original token if we successfully got the privilege
            //
            if ( fPrivAdjusted )
            {
                APIERR errTmp = NetpReleasePrivilege() ;
                if ( errTmp )
                {
                    DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Warning: NetpReleasePrivilege return error "
                           << errTmp ) ;
                }
            }
            return TRUE ;

        }

        default:
            break ;
    }

    return DIALOG_WINDOW::OnCommand( event ) ;
}


/*******************************************************************

    NAME:       TAKE_OWNERSHIP_DLG::OnTakeOwnership

    SYNOPSIS:   Called when the user presses the TakeOwnership button

    ENTRY:      ossecdescNew - Security descriptor that contains the currently
                    logged on user as the new owner

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   12-Feb-1992     Created

********************************************************************/

APIERR TAKE_OWNERSHIP_DLG::OnTakeOwnership( const OS_SECURITY_DESCRIPTOR & ossecdescNewOwner )
{
    UNREFERENCED( ossecdescNewOwner ) ;
    DBGEOL(SZ("TAKE_OWNERSHIP_DLG::OnTakeOwnership Called")) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       TAKE_OWNERSHIP_DLG::QueryHelpContext

    SYNOPSIS:   Standard QueryHelpContext

    HISTORY:
        Johnl   12-Feb-1992     Created

********************************************************************/

ULONG TAKE_OWNERSHIP_DLG::QueryHelpContext( void )
{
    return _ulHelpContext;
}

/*******************************************************************

    NAME:       TAKE_OWNERSHIP_DLG::QueryHelpFile

    SYNOPSIS:   Returns the help file to use for this dialog

    HISTORY:
        Johnl   11-Sep-1992     Created

********************************************************************/

const TCHAR * TAKE_OWNERSHIP_DLG::QueryHelpFile( ULONG ulHelpContext )
{
    UNREFERENCED( ulHelpContext ) ;
    return _nlsHelpFileName.QueryPch() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\ntaclcon.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    NTACLCon.cxx

    This file contains the NT NT_ACL_TO_PERM_CONVERTER code.



    FILE HISTORY:
        Johnl   27-Sep-1991     Created

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
    #include <ntsam.h>
    #include <ntlsa.h>
}

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_WINDOWS
#include <lmui.hxx>
#include <base.hxx>
#include <maskmap.hxx>
#include <lmoacces.hxx>
#include <errmap.hxx>
#include <string.hxx>
#include <strnumer.hxx>
#include <strlst.hxx>

#define  INCL_BLT_CONTROL
#define  INCL_BLT_DIALOG
#include <blt.hxx>

extern "C"
{
    #include <lmaudit.h>
}

#include <fsenum.hxx>
#include <uiassert.hxx>
#include <uitrace.hxx>
#include <accperm.hxx>
#include <aclconv.hxx>
#include <subject.hxx>
#include <perm.hxx>
#include <ipermapi.hxx>
#include <permstr.hxx>

#include <security.hxx>
#include <uintsam.hxx>
#include <uintlsa.hxx>
#include <ntfsacl.hxx>
#include <ntacutil.hxx>

#include <dbgstr.hxx>


/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::NT_ACL_TO_PERM_CONVERTER

    SYNOPSIS:   Constructor for the NT acl converter

    ENTRY:      pchServer - What server this resource is on (NULL if local)
                pchResourceName - Name of resource suitable for passing
                    to NetAccess APIs
                paccessmap - Pointer to access perm. MAP_MASK object
                paccessmapNewObject - Pointer to new object access perm
                                      MAP_MASK object
                pauditmap  - Pointer to audit perm. MAP_MASK object

    NOTES:

    HISTORY:
        Johnl   27-Sep-1991     Created

********************************************************************/

NT_ACL_TO_PERM_CONVERTER::NT_ACL_TO_PERM_CONVERTER(
                          const TCHAR * pszServer,
                          const TCHAR * pchResourceName,
                          MASK_MAP    * paccessmap,
                          MASK_MAP    * paccessmapNewObject,
                          MASK_MAP    * pauditmap,
                          BOOL          fIsContainer,
                          BOOL          fIsNewObjectsSupported,
                          PSECURITY_DESCRIPTOR psecdesc,
                          PGENERIC_MAPPING pGenericMapping,
                          PGENERIC_MAPPING pGenericMappingNewObjects,
                          BOOL          fMapSpecificToGeneric,
                          BOOL          fCantReadACL,
                          BOOL          fCantWriteACL,
                          PSED_FUNC_APPLY_SEC_CALLBACK pfuncCallback,
                          ULONG_PTR     ulCallbackContext,
                          HANDLE        hInstance,
                          LPDWORD       lpdwReturnStatus,
                          BOOL          fShowMnemonics    )
    : ACL_TO_PERM_CONVERTER( pszServer,
                             paccessmap,
                             pauditmap,
                             TRUE,
                             fIsContainer,
                             fIsNewObjectsSupported,
                             fShowMnemonics ),
      _pmaskmapNewObject     ( paccessmapNewObject ),
      _psecuritydesc         ( psecdesc ),
      _fCantReadACL          ( fCantReadACL ),
      _pfuncCallback         ( pfuncCallback ),
      _ulCallbackContext     ( ulCallbackContext ),
      _pGenericMapping       ( pGenericMapping ),
      _pGenericMappingNewObjects( pGenericMappingNewObjects ),
      _fMapSpecificToGeneric ( fMapSpecificToGeneric ),
      _hInstance             ( hInstance ),
      _lpdwReturnStatus      ( lpdwReturnStatus ),
      _possecdescNewItemPerms( NULL ),
      _nlsOwner              ()
{
    if ( QueryError() != NERR_Success )
        return ;

    UNREFERENCED( pchResourceName ) ;

    if ( pfuncCallback == NULL )
    {
        DBGEOL("NT_ACL_TO_PERM_CONVERT::ct - NULL callback") ;
        ReportError( ERROR_INVALID_PARAMETER ) ;
        return ;
    }

    if ( _nlsOwner.QueryError() )
    {
        ReportError( _nlsOwner.QueryError() ) ;
        return ;
    }

    SetReadOnlyFlag( fCantWriteACL ) ;
}

NT_ACL_TO_PERM_CONVERTER::~NT_ACL_TO_PERM_CONVERTER()
{
    _pmaskmapNewObject = NULL ;
    _psecuritydesc = NULL ;
    _pfuncCallback = NULL ;

    delete _possecdescNewItemPerms ;
    _possecdescNewItemPerms = NULL ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::QueryNewObjectAccessMap

    SYNOPSIS:   Returns the new object maskmap

    NOTES:

    HISTORY:
        Johnl   27-Sep-1991     Created

********************************************************************/

MASK_MAP * NT_ACL_TO_PERM_CONVERTER::QueryNewObjectAccessMap( void ) const
{
    return _pmaskmapNewObject ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::QueryOwnerName

    SYNOPSIS:   Returns the owner of this security descriptor

    RETURNS:    Pointer to the owner

    NOTES:      _nlsOwner is initialized in SidsToNames

    HISTORY:
        Johnl   16-Nov-1992     Created

********************************************************************/

const TCHAR * NT_ACL_TO_PERM_CONVERTER::QueryOwnerName( void ) const
{
    return _nlsOwner.QueryPch() ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::GetPermissions

    SYNOPSIS:   Fills in the passed ACCPERM object with the appropriate
                permission information

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::GetPermissions( ACCPERM * pAccperm,
                                                 BOOL      fAccessPerm )
{
    if ( IsNonReadable() )
    {
        //
        //  If we are editing Audit info and we couldn't read it, then we
        //  can't write it (it is privilege based).
        //
        return  fAccessPerm ?
                    IERR_ACLCONV_CANT_VIEW_CAN_EDIT :
                    ERROR_PRIVILEGE_NOT_HELD ;
    }

    APIERR err = SecurityDesc2Accperm( _psecuritydesc, pAccperm, fAccessPerm );

    BOOL fRecognizedAcl = TRUE ;
    if ( err == IERR_UNRECOGNIZED_ACL )
    {
        /* If it's unrecognized, find out if the user can write it before
         * returning an error
         */
        err = NERR_Success ;
        fRecognizedAcl = FALSE ;
    }

    if ( !err )
    {
        if ( IsReadOnly() )
        {
            err = fRecognizedAcl ? IERR_ACLCONV_READ_ONLY :
                                   IERR_ACLCONV_NONST_ACL_CANT_EDIT ;
        }
        else
        {
            err = fRecognizedAcl ? NERR_Success :
                                   IERR_ACLCONV_NONST_ACL_CAN_EDIT ;
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::GetBlankPermissions

    SYNOPSIS:   Initializes the ACCPERM object with the "default"
                blank permission

    ENTRY:      pAccperm - Pointer to accperm object

    EXIT:       The accperm will contain the default empty permission set

    RETURNS:    NERR_Success or some standard error code.

    NOTES:

    HISTORY:
        Johnl   Aug-21-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::GetBlankPermissions( ACCPERM * pAccperm )
{
    pAccperm->QueryAccessPermissionList()->Clear() ;
    pAccperm->QueryAuditPermissionList()->Clear() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::WritePermissions

    SYNOPSIS:   Apply the permissions to the requested resources

    ENTRY:      accperm - List of permissions (audit & access) to be
                        applied to the designated resource

    EXIT:

    RETURNS:

    NOTES:      accperm can't be const because the Enum* methods can't be
                const.

    HISTORY:
        Johnl   29-Aug-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::WritePermissions(
                         ACCPERM & accperm,
                         BOOL  fApplyToSubContainers,
                         BOOL  fApplyToSubObjects,
                         enum  TREE_APPLY_FLAGS applyflags,
                         BOOL *pfReportError )
{
    APIERR err ;
    OS_SECURITY_DESCRIPTOR ossecdescNew ;
    OS_ACL osaclSaclOrDaclTemp ;

    *pfReportError = TRUE ;
    if ( ( err = ossecdescNew.QueryError() ) ||
         ( err = osaclSaclOrDaclTemp.QueryError()  ))
    {
        return err ;
    }

    /* Check which type of security we are applying and set the appropriate
     * ACL (the ACL is copied so we don't care about it anymore)
     */
    switch ( applyflags )
    {
    case TREEAPPLY_ACCESS_PERMS:
        err = ossecdescNew.SetDACL( TRUE, &osaclSaclOrDaclTemp ) ;
        break ;
    case TREEAPPLY_AUDIT_PERMS:
        err = ossecdescNew.SetSACL( TRUE, &osaclSaclOrDaclTemp ) ;
        break ;
    default:
        UIASSERT(FALSE) ;
        err = ERROR_INVALID_PARAMETER ;
        break ;
    }

    if ( (err ) ||
         (err = Accperm2SecurityDesc( &accperm,
                                &ossecdescNew,
                                applyflags == TREEAPPLY_ACCESS_PERMS )) )
    {
        return err ;
    }

    /* Only build the new object security descriptor if necessary
     */
    if ( IsContainer() &&
         (err = BuildNewObjectPerms( ossecdescNew )) )
    {
        return err ;
    }

    PSECURITY_DESCRIPTOR psecdescNew = (PSECURITY_DESCRIPTOR) ossecdescNew ;

#ifdef TRACE
    DBGEOL(SZ("WritePermissions calling callback with the following security descriptor:"));
    ossecdescNew.DbgPrint() ;

    if ( fApplyToSubObjects )
    {
        DBGEOL(SZ("WritePermissions calling callback with the following New Item security descriptor:"));
        QueryNewObjectPerms()->DbgPrint() ;
    }
#endif

    /* Any errors returned by the callback should have been reported by the
     * callback.  So ignore the error return.
     */
    if ( err = _pfuncCallback( QueryWritePermHwnd(),
                          _hInstance,
                          _ulCallbackContext,
                          psecdescNew,
                          IsContainer() ?
                                QueryNewObjectPerms()->QueryDescriptor() :
                                NULL,
                          (BOOLEAN)fApplyToSubContainers,
                          (BOOLEAN)fApplyToSubObjects,
                          _lpdwReturnStatus ) )
    {
        TRACEEOL("WritePermissions - Callback returned error code " << (ULONG) err ) ;
        *pfReportError = FALSE ;
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::QueryFailingSubject

    SYNOPSIS:   Returns the first User/Group that is currently in the
                ACL but is no longer in the UAS of the server.

    ENTRY:      pnlsSubjUniqueName - Pointer to NLS_STR that will receive the
                    subject.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      This should be called immediately after WritePermissions and
                only if WritePermissions returned NERR_UserNotFound.

    HISTORY:
        Johnl   24-Oct-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::QueryFailingSubject( NLS_STR * pnlsSubjUniqueName )
{
    UIASSERT(!SZ("Not implemented")) ;
    UNREFERENCED( pnlsSubjUniqueName ) ;
    //enum PERMNAME_TYPE nametype ;
    //return _accperm.QueryFailingName( pnlsSubjUniqueName, &nametype ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::SecurityDesc2Accperm

    SYNOPSIS:   Converts a security descriptor to an ACCPERM object

    ENTRY:      psecdesc - Pointer to security descriptor to convert
                pAccperm - Pointer to accperm to receive the security
                    descriptor's information
                fAccessPerm - TRUE if the Access permissions should be
                    retrieved, FALSE if the Audit permissions should be
                    retrieved.

    EXIT:       The Accperm will contain the information stored in the
                security descriptor

    RETURNS:    NERR_Success if successful, error code otherwise including
                the IERR_ACLCONV_* manifests.

    NOTES:      psecdesc can be NULL (gives World full access if DACL).

                The Passed Accperm should be empty.

    HISTORY:
        Johnl   20-Dec-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::SecurityDesc2Accperm(
                                     const PSECURITY_DESCRIPTOR psecdesc,
                                           ACCPERM *            pAccperm,
                                           BOOL                 fAccessPerm )
{
    TRACEEOL( SZ("NT_ACL_TO_PERM_CONVERTER::SecurityDesc2Accperm - Entered") ) ;
    APIERR err = NERR_Success ;

    if ( psecdesc == NULL )
    {
        DBGEOL(SZ("SecurityDesc2Accperm - Warning, Passed NULL security descriptor")) ;
    }

    OS_SECURITY_DESCRIPTOR ossecdesc( psecdesc ) ;
    if ( ossecdesc.QueryError() )
        return ossecdesc.QueryError() ;

    if ( fAccessPerm )
    {
        OS_ACL * posaclDACL = NULL ;
        BOOL     fDACLPresent ;
        if ( (err = ossecdesc.QueryDACL( &fDACLPresent,
                                         &posaclDACL )) )
        {
            return err ;
        }

        /* If the user is editting the DACL and it isn't present, then
         * it means "World" Full access.
         */
        if ( !fDACLPresent || ( fDACLPresent && (posaclDACL == NULL)) )
        {
            ACCESS_PERMISSION * pPermAccess = NULL ;
            OS_SID ossidWorld( NULL ) ;
            if ((err = ossidWorld.QueryError()) ||
                (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_World,
                                                            &ossidWorld )) ||
                (err = CreateNewPermission( (PERMISSION **) &pPermAccess,
                                            TRUE,
                                            (PSID) ossidWorld,
                                            GENERIC_ALL,
                                            FALSE,
                                            0,
                                            FALSE ))
                || (err = pAccperm->AddPermission( pPermAccess )))
            {
                DBGEOL("SecurityDesc2Accperm - Build permission or QuerySystemSid Failed, error code "
                        << (ULONG) err ) ;

                /* CreateNewPermission will set this to NULL if it fails
                 */
                delete pPermAccess ;
                return err ;
            }

        }
        else
        {
            UIASSERT( fDACLPresent && posaclDACL != NULL ) ;

            OS_DACL_SUBJECT_ITER subjiterDacl( posaclDACL,
                                               _pGenericMapping,
                                               _pGenericMappingNewObjects,
                                               !_fMapSpecificToGeneric,
                                               pAccperm->IsContainer() ) ;
            if ( subjiterDacl.QueryError() )
                return subjiterDacl.QueryError() ;

            /* Loop through each SID and create a subject and permission
             * as appropriate.
             */
            while ( subjiterDacl.Next( &err ) )
            {
                /* Check for some of the permission combinations that we
                 * don't handle
                 */
                /* If the permission is a Deny all permission, then the access
                 * mask should be all zeros.  This is important because an all
                 * zero bitfield indicates a deny all permissions in the permission
                 * scheme.
                 */
                if ( ( subjiterDacl.HasThisAce() &&
                      (!subjiterDacl.IsDenyAll()  &&
                       subjiterDacl.QueryAccessMask() == 0)) ||
                     pAccperm->IsContainer() &&
                     (( subjiterDacl.HasNewObjectAce() &&
                       (!subjiterDacl.IsNewObjectDenyAll()  &&
                        subjiterDacl.QueryNewObjectAccessMask() == 0)) ||
                      ( subjiterDacl.HasNewContainerAce() &&
                       (!subjiterDacl.IsNewContainerDenyAll()  &&
                        subjiterDacl.QueryNewContainerAccessMask() == 0)))   )
                {
                    UIDEBUG(SZ("SecurityDesc2Accperm - Partial Denies or internal error encountered\n\r")) ;
                    return IERR_UNRECOGNIZED_ACL ;
                }

                //
                //  If the container isn't inheriting anything then we can't
                //  process this ACL.
                //
		if ( pAccperm->IsContainer() &&
		     !subjiterDacl.HasThisAce() )
		{
		    UIDEBUG(SZ("SecurityDesc2Accperm - Inherit only ACE found\n\r")) ;
                    return IERR_UNRECOGNIZED_ACL ;
                }


                ACCESS_PERMISSION * pPermAccess ;
                if ( (err = CreateNewPermission(
                                    (PERMISSION **) &pPermAccess,
                                    TRUE,
                                    (PSID) *(subjiterDacl.QuerySID()),
                                    subjiterDacl.QueryAccessMask(),
                                    pAccperm->QueryAclConverter()->IsNewObjectsSupported() &&
                                          subjiterDacl.HasNewObjectAce(),
                                    subjiterDacl.QueryNewObjectAccessMask(),
                                    pAccperm->IsContainer() &&
                                         subjiterDacl.HasNewContainerAce()))
                    || (err = pAccperm->AddPermission( pPermAccess )))
                {
                    DBGEOL(SZ("SecurityDesc2Accperm - Build permission failed, error code ") << (ULONG) err ) ;

                    /* CreateNewPermission will set this to NULL if it fails
                     */
                    delete pPermAccess ;
                    return err ;
                }
            }
        }
    }

    /* Get the SACL from the security descriptor
     */
    if ( !err &&
         !fAccessPerm &&
         ossecdesc.QueryControl()->IsSACLPresent() )
    {
        OS_ACL * posaclSACL = NULL ;
        BOOL     fSACLPresent ;

        if ( (err = ossecdesc.QuerySACL( &fSACLPresent, &posaclSACL )) )
            return err ;
        UIASSERT( fSACLPresent ) ;

        /* If the ACL is NULL, then no one is granted permissions.
         */
        if ( posaclSACL != NULL )
        {
            OS_SACL_SUBJECT_ITER subjiterSacl( posaclSACL,
                                               _pGenericMapping,
                                               _pGenericMappingNewObjects,
                                               !_fMapSpecificToGeneric,
                                               pAccperm->IsContainer() ) ;
            if ( subjiterSacl.QueryError() )
                return subjiterSacl.QueryError() ;

            /* Loop through each SID and create a subject and permission
             * as appropriate.
             */
            while ( subjiterSacl.Next( &err ) )
            {
                /* If this subject only has alarm ACEs, then skip him because
                 * we are only interested in Audit Aces.
                 */
                if ( !subjiterSacl.HasAuditAces() )
                    continue ;

                BOOL fNotPropagated = pAccperm->IsContainer() &&
                           (
                            //
                            //  Either there isn't a success audit ace
                            //  else there is a success audit ace but it
                            //  only applies to this and not to new objects
                            //  or containers
                            //
                            ( !subjiterSacl.HasThisAuditAce_S() ||
                               (subjiterSacl.HasThisAuditAce_S()         &&
                                !subjiterSacl.HasNewObjectAuditAce_S()   &&
                                !subjiterSacl.HasNewContainerAuditAce_S()
                               )
                            )
                            &&
                            (
                              !subjiterSacl.HasThisAuditAce_F() ||
                               (subjiterSacl.HasThisAuditAce_F()         &&
                                !subjiterSacl.HasNewObjectAuditAce_F()   &&
                                !subjiterSacl.HasNewContainerAuditAce_F()
                               )
                            )
                           ) ;

                /* Check for some of the permission combinations that we
                 * don't handle, these are (in order):
                 *
                 * 1) Success inherit bits must have "This", New Object,
                 *      New Container and not Inherit only set
                 *
                 * 2) Same rule for Failed inherit bits as for Success
                 * 3) The access mask for the different inherit options
                 *      must be the same (if mask will be 0 if no audit, so
                 *      we don't have to check if an audit actually exists).
                 *
                 * OR
                 *    The container doesn't propragate object/container audits
                 *    (as in an inherited owner)
                 */
                if ( pAccperm->IsContainer() &&
                     !(
                        (
                           //
                           //  Either there are isn't a success ACE else it has
                           //  a success for this, objects and containers
                           //
                           (!subjiterSacl.HasThisAuditAce_S() ||
                             (subjiterSacl.HasThisAuditAce_S()         &&
                              subjiterSacl.HasNewObjectAuditAce_S()    &&
                              subjiterSacl.HasNewContainerAuditAce_S()
                             )
                           ) &&

                           //
                           //  Either there are isn't a failure ACE else it has
                           //  a failure for this, objects and containers
                           //
                           (!subjiterSacl.HasThisAuditAce_F() ||
                             (subjiterSacl.HasThisAuditAce_F()         &&
                              subjiterSacl.HasNewObjectAuditAce_F()    &&
                              subjiterSacl.HasNewContainerAuditAce_F()
                             )
                           ) &&

                         //
                         //  The access masks must be equal between success
                         //  and failure
                         //
                         (subjiterSacl.QueryAuditAccessMask_S() ==
                              subjiterSacl.QueryNewObjectAuditAccessMask_S()) &&
                         (subjiterSacl.QueryAuditAccessMask_F() ==
                              subjiterSacl.QueryNewObjectAuditAccessMask_F()) &&
                         (subjiterSacl.QueryAuditAccessMask_S() ==
                              subjiterSacl.QueryNewContainerAuditAccessMask_S()) &&
                         (subjiterSacl.QueryAuditAccessMask_F() ==
                              subjiterSacl.QueryNewContainerAuditAccessMask_F())

                        ) ||
                        (
                           fNotPropagated
                        )
                      )
                   )
                {
                    UIDEBUG(SZ("SecurityDesc2Accperm - Bad mix of inheritance flags or Audit bits do not match\n\r")) ;
                    return IERR_UNRECOGNIZED_ACL ;
                }

                AUDIT_PERMISSION * pPermAccess ;
                if ( (err = CreateNewPermission( (PERMISSION **) &pPermAccess,
                                                FALSE,
                                                (PSID) *(subjiterSacl.QuerySID()),
                                                subjiterSacl.QueryAuditAccessMask_S(),
                                                TRUE,
                                                subjiterSacl.QueryAuditAccessMask_F(),
                                                !fNotPropagated ))
                    || (err = pAccperm->AddPermission( pPermAccess )))
                {
                    DBGEOL(SZ("SecurityDesc2Accperm - Build permission failed, error code ") << (ULONG) err ) ;

                    /* CreateNewPermission will set this to NULL if it fails
                     */
                    delete pPermAccess ;
                    return err ;
                }
            }
        }
    }

    //
    //  Now retrieve the owner SID
    //
    OS_SID * possidOwner ;
    BOOL fPresent ;
    PSID psidOwner = NULL ;
    if ( !err &&
         fAccessPerm &&
         !(err = ossecdesc.QueryOwner( &fPresent, &possidOwner )) &&
         fPresent &&
         possidOwner != NULL )
    {
        psidOwner = possidOwner->QueryPSID() ;
    }

    if ( !err )
        err = SidsToNames( pAccperm, fAccessPerm, psidOwner ) ;

    TRACEEOL(SZ("SecurityDesc2Accperm - returning error code ") << (ULONG) err ) ;
    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::CreateNewPermission

    SYNOPSIS:   Helper routine.  Creates a new subject and calls build
                permission with the appropriate parameters.

    ENTRY:      ppPermission - Pointer to ACCESS_PERMISSION or AUDIT_PERMISSION
                    that will receive the newly allocated permission
                fAccess - TRUE if access permissions, FALSE if audit perms
                psidSubject - SID of the new permission
                Mask1 - Access mask for this or success audit mask
                fMask2Used - TRUE if the Mask2 parameter is used
                Mask2 - Access mask for new items or failed audit mask
                fContainerPermsInheritted - TRUE if the container perms are
                    inheritted, FALSE otherwise

    EXIT:       ppPermission will point to a newly created permission suitable
                for adding to the permission list or audit list

    RETURNS:    NERR_Success if successful, error code otherwise.  If an error
                occurs, then all memory will be deleted by this method.

    NOTES:

    HISTORY:
        Johnl   10-Mar-1992     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::CreateNewPermission(
                                        PERMISSION ** ppPermission,
                                        BOOL          fAccess,
                                        PSID          psidSubject,
                                        ACCESS_MASK   Mask1,
                                        BOOL          fMask2Used,
                                        ACCESS_MASK   Mask2,
                                        BOOL          fContainerPermsInheritted )
{
    APIERR err = NERR_Success ;

    SUBJECT * pSubj = new NT_SUBJECT( (PSID) psidSubject ) ;

    if ( pSubj == NULL )
        return ERROR_NOT_ENOUGH_MEMORY ;
    else if ( pSubj->QueryError() != NERR_Success )
    {
        err =  pSubj->QueryError() ;
        delete pSubj ;
        return err ;
    }

    UIASSERT( sizeof(ULONG) == sizeof(ACCESS_MASK) ) ;
    BITFIELD bitsThis( (ULONG) Mask1 ) ;
    BITFIELD bitsMask2( (ULONG) Mask2 ) ;
    if ( (err = bitsThis.QueryError()) ||
         (err = bitsMask2.QueryError()) )
    {
        return err ;
    }

    //
    //  If this isn't a container, then we effectively ignore the container
    //  flag by always setting it to TRUE
    //

    if ( !IsContainer() )
        fContainerPermsInheritted = TRUE ;

#ifdef TRACE
    TRACEEOL("CreateNewPermission - Building the following permission:") ;
    TRACEEOL("\t" << (fAccess ? "Access Permission" : "Audit Permission") ) ;
    OS_SID ossidSubj( psidSubject ) ;
    ossidSubj.DbgPrint() ;

    TRACEEOL("\tMask 1 (Container/Success) = " << (HEX_STR) Mask1) ;
    HEX_STR hexstrMask2( Mask2 ) ;
    TRACEEOL("\tMask 2 (Object/Fail)       = " << (fMask2Used ? hexstrMask2.QueryPch() :
                                                             SZ("Not Used")) ) ;
    TRACEEOL("\tfContainerPermsInheritted   = " << (fContainerPermsInheritted ?
                                                   "TRUE" : "FALSE")) ;
    TRACEEOL("=====================================================") ;
#endif //TRACE

    err = BuildPermission( ppPermission,
                           fAccess,    // Access or Audit permission
                           pSubj,
                           &bitsThis,
                           fMask2Used ? &bitsMask2 : NULL,
                           fContainerPermsInheritted ) ;
    if ( err != NERR_Success )
    {
        DBGEOL(SZ("SecurityDesc2Accperm - Build permission failed, error code ") << (ULONG) err ) ;
        return err ;
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::Accperm2SecurityDesc

    SYNOPSIS:   Converts an ACCPERM to an NT Security Descriptor

    ENTRY:      pAccperm - Pointer to the accperm to convert
                psecdesc - Pointer to security descriptor that will
                    receive the converted accperm
                fAccessPerm - TRUE if the Access permissions should be
                    converted, FALSE if the Audit permissions should be
                    converted.

    EXIT:       The security descriptor will contain the permissions reflected
                in the ACCPERM


    RETURNS:    NERR_Success if successful, error code otherwise


    NOTES:      An all zero access mask for access permissions is assumed
                to indicate Deny All permissions.

                The Deny All access permissions will be put into the DACL
                before any grants.

    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::Accperm2SecurityDesc(
                                 ACCPERM * pAccperm,
                                 OS_SECURITY_DESCRIPTOR * possecdescNew,
                                 BOOL    fAccessPerms )

{
    APIERR err = NERR_Success ;

    OS_SECURITY_DESCRIPTOR ossecdescOld( _psecuritydesc ) ;
    if ( ossecdescOld.QueryError() )
        return ossecdescOld.QueryError() ;

    /* Copy the Owner and primary group from the original security descriptor
     */
    OS_SID * possidOwner ;
    OS_SID * possidGroup ;
    BOOL fContainsOwner, fContainsGroup ;

    if ( (err = ossecdescOld.QueryOwner( &fContainsOwner, &possidOwner )) ||
         (err = ossecdescOld.QueryGroup( &fContainsGroup, &possidGroup ))   )
    {
        DBGEOL(SZ("Accperm2SecurityDesc - Error ") << (ULONG) err << SZ(" constructing owner & group")) ;
        return err ;
    }

    if ( fContainsOwner )
    {
        if ( err = possecdescNew->SetOwner( *possidOwner ) )
        {
            DBGEOL(SZ("Accperm2SecurityDesc - Error ") << (ULONG) err << SZ(" during SetOwner")) ;
            return err ;
        }
    }
    else
        UIDEBUG(SZ("NT_ACL_..._CONVERTER::Accperm2SecurityDesc - Warning - client supplied Sec. Desc. has no Owner\n\r")) ;

    if ( fContainsGroup )
    {
        if ( err = possecdescNew->SetGroup( *possidGroup ) )
        {
            DBGEOL(SZ("Accperm2SecurityDesc - Error ") << (ULONG) err << SZ(" during SetGroup")) ;
            return err ;
        }
    }
    else
    {
        UIDEBUG(SZ("NT_ACL_..._CONVERTER::Accperm2SecurityDesc - Warning - client supplied Sec. Desc. has no Group\n\r")) ;
    }

    /* We assume the access mask is a ULONG in various places in the following
     * code.
     */
    UIASSERT( sizeof(ACCESS_MASK) == sizeof(ULONG)) ;
    OS_ACE osace ;
    if ( osace.QueryError() )
        return osace.QueryError() ;

    /* Set the security descriptor to contain the correct items (DACL or SACL)
     * based on fAccessPerms.
     */
    if ( fAccessPerms )
    {
        OS_ACL * posaclDACL ;
        BOOL fDaclPresent ;
        if ( err = possecdescNew->QueryDACL( &fDaclPresent, &posaclDACL ))
            return err ;
        UIASSERT( fDaclPresent ) ;

        /* If the DACL is NULL, create an empty dummy one
         */
        if ( posaclDACL == NULL )
        {
            OS_ACL osaclDACL ;
            if ( (err = osaclDACL.QueryError()) ||
                 (err = possecdescNew->SetDACL( TRUE, &osaclDACL )) ||
                 (err = possecdescNew->QueryDACL( &fDaclPresent, &posaclDACL )))
            {
                return err ;
            }
            UIASSERT( posaclDACL != NULL ) ;
        }

        if ( (err = ConvertDenyAllAccessPerms( pAccperm, posaclDACL )) ||
             (err = ConvertAllowAccessPerms( pAccperm, posaclDACL))      )
        {
            DBGEOL(SZ("Accperm2SecurityDesc - Error ") << (ULONG) err << SZ(" during Convert*AccessPerms")) ;
        }
    }
    else
    {
        /* Convert the Auditting information into an NT Security descriptor.
         */
        OS_ACL * posaclSACL ;
        BOOL fSaclPresent ;
        if ( err = possecdescNew->QuerySACL( &fSaclPresent, &posaclSACL ))
            return err ;
        UIASSERT( fSaclPresent ) ;
        UIASSERT( posaclSACL != NULL ) ;

        osace.SetType( SYSTEM_AUDIT_ACE_TYPE ) ;
        AUDIT_PERMISSION * pAuditPerm ;
        BOOL fStartFromBeginning = TRUE ;

        /* Enumerate all audit permissions in the accperm, then scan the
         * original security descriptor and copy all Alarms in the
         * SACL into our new security descriptor.
         */
        while ( pAccperm->EnumAuditPermissions( &pAuditPerm,
                                                &fStartFromBeginning ) )
        {
            /* We may need to add this subject twice, once for success and
             * once for failure if the access masks aren't the same.
             */
            const OS_SID * possidSubject =
               ((NT_SUBJECT*)pAuditPerm->QuerySubject())->QuerySID() ;

            UIASSERT( possidSubject->IsValid() ) ;
            if ( err = osace.SetSID( *possidSubject ) )
                break ;

            if ( pAccperm->IsContainer() )
            {
                osace.SetInheritFlags( pAuditPerm->IsContainerPermsInheritted()?
                                       OBJECT_INHERIT_ACE |
                                           CONTAINER_INHERIT_ACE :
                                       0 ) ;

            }


            BITFIELD * pbitsSuccess = pAuditPerm->QuerySuccessAuditBits() ;
            BITFIELD * pbitsFail = pAuditPerm->QueryFailAuditBits() ;

            osace.SetAccessMask( (ACCESS_MASK) *pbitsSuccess ) ;

            //
            // If the bitfields are equal and non-zero, then we can optimize away one of
            // the ACEs by setting this ACE as both success and failed
            //
            if ( *pbitsSuccess == *pbitsFail &&
                 osace.QueryAccessMask() != 0 )
            {
                osace.SetAceFlags((osace.QueryAceFlags() & VALID_INHERIT_FLAGS)|
                                   SUCCESSFUL_ACCESS_ACE_FLAG |
                                   FAILED_ACCESS_ACE_FLAG       ) ;
                if ( err = posaclSACL->AddACE( MAXULONG, osace ) )
                    break ;
            }
            else
            {
                osace.SetAceFlags((osace.QueryAceFlags() & VALID_INHERIT_FLAGS)|
                                  SUCCESSFUL_ACCESS_ACE_FLAG ) ;
                if ( osace.QueryAccessMask() != 0 &&
                     (err = posaclSACL->AddACE( MAXULONG, osace )) )
                    break ;

                osace.SetAccessMask( (ACCESS_MASK) *pbitsFail ) ;
                osace.SetAceFlags( (osace.QueryAceFlags() & VALID_INHERIT_FLAGS)|
                                   FAILED_ACCESS_ACE_FLAG ) ;
                if ( osace.QueryAccessMask() != 0 &&
                     (err = posaclSACL->AddACE( MAXULONG, osace )) )
                    break ;
            }
        }

#if 0
        //
        // Don't support alarm ACEs in this build
        //

        if ( err )
            return err ;

        /* Now copy all of the ALARM aces in the original security descriptor
         * to our new security descriptor that will be passed to the client.
         */
        OS_ACL * posaclOldSACL ;
        BOOL     fSACLPresent ;
        ULONG cAces ;
        OS_SECURITY_DESCRIPTOR ossecdescOld( _psecuritydesc ) ;
        if ( ossecdescOld.QueryError() )
            return ossecdescOld.QueryError() ;

        if ( (err = ossecdescOld.QuerySACL( &fSACLPresent, &posaclOldSACL )) ||
             !fSACLPresent ||
             (err = posaclOldSACL->QueryACECount( &cAces )) )
        {
            return err ;
        }

        for ( ULONG iAce = 0 ; iAce < cAces ; iAce++ )
        {
            if ( (err = posaclOldSACL->QueryACE( iAce, &osace )))
                break ;

            if ( osace.QueryType() == SYSTEM_ALARM_ACE_TYPE )
            {
                if ( err = posaclSACL->AddACE( MAXULONG, osace ))
                    break ;
            }
        }
#endif
    }

    //
    //  One of the above AddAces may return this if we fill the security
    //  descriptor.
    //
    if ( err == ERROR_INSUFFICIENT_BUFFER )
    {
        DBGEOL("Accperm2SecDesc - Mapping ERROR_INSUFFICIENT_BUFFER to " <<
               "IERR_TOO_MANY_USERS") ;

        err = IERR_TOO_MANY_USERS ;
    }

    if ( err )
        TRACEEOL(SZ("Accperm2SecDesc returning error ") << (ULONG) err ) ;

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::ConvertDenyAllAccessPerms

    SYNOPSIS:   Finds all of they deny all permissions in the passed
                accperm and appends them as aces to the passed DACL.

    ENTRY:      pAccperm - Pointer to the accperm to convert
                psecdesc - Pointer to security descriptor that will
                    receive the converted accperm

    EXIT:       The security descriptor will contain the permissions reflected
                in the ACCPERM

    RETURNS:    NERR_Success if successful, error code otherwise


    NOTES:      An all zero access mask for access permissions is assumed
                to indicate Deny All permissions.

                The deny all aces have the generic all bit set.


    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::ConvertDenyAllAccessPerms(
                                                        ACCPERM * pAccperm,
                                                        OS_ACL  * posaclDACL )
{
    APIERR err ;
    OS_ACE osace ;
    BITFIELD bitsPerms( (ULONG) 0 ) ;
    BITFIELD bitsNewObjPerms( (ULONG) 0 ) ;
    if ( (err = bitsNewObjPerms.QueryError()) ||
         (err = bitsNewObjPerms.QueryError())        ||
         (err = osace.QueryError())             )
    {
        return err ;
    }

    osace.SetType( ACCESS_DENIED_ACE_TYPE ) ;
    osace.SetAccessMask( GENERIC_ALL ) ;

    ACCESS_PERMISSION * pPerm ;
    BOOL fFromBeginning = TRUE ;
    while ( pAccperm->EnumAccessPermissions( &pPerm,
                                             &fFromBeginning )  )
    {
        BOOL fThisIsDeny = (0 == (ULONG)*pPerm->QueryAccessBits());
        BOOL fNewObjIsDeny = ( pPerm->IsNewObjectPermsSupported() &&
                               pPerm->IsNewObjectPermsSpecified() &&
                             (0 == (ULONG)*pPerm->QueryNewObjectAccessBits())) ;

        /* If this isn't a deny all permission for either this resource or
         * new objects, then ignore it.
         */
        if ( fThisIsDeny || fNewObjIsDeny )
        {
            const OS_SID * possidSubject =
                ((NT_SUBJECT*)pPerm->QuerySubject())->QuerySID() ;

            UIASSERT( possidSubject->IsValid() ) ;
            if ( err = osace.SetSID( *possidSubject ) )
                break ;

            if ( fNewObjIsDeny )
            {
                /* New items should only have OI and IO set.  If you set CI,
                 * then when the DACL is inheritted, the new object permission
                 * would get applied to the container.
                 */
                osace.SetInheritFlags( OBJECT_INHERIT_ACE    |
                                       INHERIT_ONLY_ACE ) ;
                if ( err = posaclDACL->AddACE( MAXULONG, osace ) )
                    break ;
            }

            if ( fThisIsDeny )
            {
                if ( pAccperm->IsContainer() &&
                     pPerm->IsContainerPermsInheritted() )
                {
                    osace.SetInheritFlags( CONTAINER_INHERIT_ACE ) ;
                }
                else
                {
                    osace.SetInheritFlags( 0 ) ;
                }

                if ( err = posaclDACL->AddACE( MAXULONG, osace ) )
                    break ;
            }
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::ConvertAllowAccessPerms

    SYNOPSIS:   Finds all Access allowed permissions in the accperm and
                appends them to the DACL.


    ENTRY:      pAccperm - Pointer to the accperm to convert
                psecdesc - Pointer to security descriptor that will
                    receive the converted accperm

    EXIT:       The security descriptor will contain the permissions reflected
                in the ACCPERM


    RETURNS:    NERR_Success if successful, error code otherwise


    NOTES:      We treat aliases as groups

    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::ConvertAllowAccessPerms(
                                                   ACCPERM * pAccperm,
                                                   OS_ACL  * posaclDACL )
{
    APIERR err ;
    OS_ACE osace ;
    BITFIELD bitsPerms( (ULONG) 0 ) ;
    BITFIELD bitsNewObjPerms( (ULONG) 0 ) ;
    if ( (err = bitsPerms.QueryError())       ||
         (err = bitsNewObjPerms.QueryError()) ||
         (err = osace.QueryError())             )
    {
        return err ;
    }

    osace.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;

    ACCESS_PERMISSION * pPerm ;
    BOOL fFromBeginning = TRUE ;
    while ( pAccperm->EnumAccessPermissions( &pPerm,
                                             &fFromBeginning )  )
    {
        BOOL fThisIsDeny = (0 == (ULONG)*pPerm->QueryAccessBits());
        BOOL fNewObjIsDeny = ( pPerm->IsNewObjectPermsSupported() &&
                               pPerm->IsNewObjectPermsSpecified() &&
                             (0 == (ULONG)*pPerm->QueryNewObjectAccessBits())) ;

        /* Ignore any Deny All permissions
         *
         */
        if ( (!fThisIsDeny ||
             (pPerm->IsNewObjectPermsSupported() && !fNewObjIsDeny )))
        {
            const OS_SID * possidSubject =
                  ((NT_SUBJECT*)pPerm->QuerySubject())->QuerySID() ;

            UIASSERT( possidSubject->IsValid() ) ;
            if ( err = osace.SetSID( *possidSubject ) )
            {
                DBGEOL(SZ("NT ACL Conv::ConvertAllowAccessPerms - error ") <<
                       (ULONG) err << SZ(" on osace.SetSID")) ;
                break ;
            }

            /* If the object supports new object permissions and this isn't
             * a deny permission, then add a new object ace.
             */
            if ( pPerm->IsNewObjectPermsSupported() &&
                 pPerm->IsNewObjectPermsSpecified() &&
                 !fNewObjIsDeny )
            {
                TRACEEOL(SZ("ConvertAllowAccessPerms - Added New Object Permission")) ;
                osace.SetAccessMask( *pPerm->QueryNewObjectAccessBits()) ;

                /* New items should only have OI and IO set.  If you set CI,
                 * then when the DACL is inheritted, the new object permission
                 * would get applied to the container.
                 */
                osace.SetInheritFlags( OBJECT_INHERIT_ACE    |
                                       INHERIT_ONLY_ACE ) ;
                if ( err = posaclDACL->AddACE( MAXULONG, osace ) )
                {
                    DBGEOL(SZ("NT ACL Conv::ConvertAllowAccessPerms - error ") <<
                           (ULONG) err << SZ(" on New Obj. Add ACE")) ;
                    break ;
                }
            }

            if ( !fThisIsDeny )
            {
                TRACEEOL(SZ("ConvertAllowAccessPerms - Adding This/container Permission")) ;
                osace.SetAccessMask( (ULONG)*pPerm->QueryAccessBits()) ;

                if ( pAccperm->IsContainer() &&
                     pPerm->IsContainerPermsInheritted() )
                {
                    osace.SetInheritFlags( CONTAINER_INHERIT_ACE ) ;
                }
                else
                {
                    osace.SetInheritFlags( 0 ) ;
                }

                if ( err = posaclDACL->AddACE( MAXULONG, osace ) )
                {
                    DBGEOL(SZ("NT ACL Conv::ConvertAllowAccessPerms - error ") <<
                           (ULONG) err << SZ(" on Add ACE")) ;
                    osace.DbgPrint() ;
                    posaclDACL->DbgPrint() ;
                    break ;
                }
            }
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::BuildNewObjectPerms

    SYNOPSIS:   Given a security descriptor for the container, this method
                selects all of the permissions that should be applied
                to objects and builds a security descriptor suitable for
                applying directly to existing objects.

    ENTRY:      ossecContainer - Continer security descriptor

    EXIT:       _possecdescNewItemPerms will be set to the newly built
                   security descriptor with the appropriate item permissions

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   06-May-1992     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::BuildNewObjectPerms(
                                const OS_SECURITY_DESCRIPTOR & ossecContainer )
{
    UIASSERT( ossecContainer.IsValid() ) ;
    APIERR err = NERR_Success ;

    /* If we are doing this a second time, delete the old one
     */
    if ( _possecdescNewItemPerms != NULL )
    {
        delete _possecdescNewItemPerms ;
        _possecdescNewItemPerms = NULL ;
    }

    do { // Error breakout

        _possecdescNewItemPerms = new OS_SECURITY_DESCRIPTOR ;

        err = ERROR_NOT_ENOUGH_MEMORY ;
        if ( (_possecdescNewItemPerms == NULL) ||
             (err = _possecdescNewItemPerms->QueryError()) ||
             (err = _possecdescNewItemPerms->Copy( ossecContainer )) )
        {
            break ;
        }

        //
        //  Now look for any Creator Owner or Creator Group SIDs and remove
        //  them if present
        //
        OS_ACL * posacl ;
        BOOL     fACLPresent ;
        if ( (err = _possecdescNewItemPerms->QueryDACL( &fACLPresent,
                                                        &posacl )) ||
             (fACLPresent &&
              posacl != NULL &&
             (err = RemoveUndesirableACEs( posacl ))) )
        {
            break ;
        }

        if ( (err = _possecdescNewItemPerms->QuerySACL( &fACLPresent,
                                                        &posacl )) ||
             (fACLPresent &&
             (err = RemoveUndesirableACEs( posacl ))) )
        {
            break ;
        }

    } while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::RemoveUndesirableACEs

    SYNOPSIS:	Removes any ACEs from the passed *container* ACL that
                we don't want to get inheritted onto objects

    ENTRY:      posacl - ACL to remove ACEs from (SACL or DACL)

    EXIT:       posacl will have all ACEs removed that contain the Creator
                Owner SID

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      posacl is assumed to belong to a container (directory etc.).

    HISTORY:
        Johnl   28-Aug-1992     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::RemoveUndesirableACEs( OS_ACL * posacl )
{
    UIASSERT( posacl != NULL ) ;
    APIERR err = NERR_Success ;

    do { // error breakout

        OS_ACE osace ;
        OS_SID * possid ;
        OS_SID ossidCreatorOwner ;
        OS_SID ossidCreatorGroup ;
        ULONG cAces ;
        if ( (err = osace.QueryError()) ||
             (err = posacl->QueryACECount( &cAces)) ||
             (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorOwner,
                                                         &ossidCreatorOwner )) ||
             (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorGroup,
                                                         &ossidCreatorGroup )))
        {
            break ;
        }

        for ( ; cAces > 0 ; cAces-- )
        {
            if ( (err = posacl->QueryACE( cAces-1, &osace )) ||
                 (err = osace.QuerySID( &possid )) )
            {
                break ;
            }

            /* We only remove ACEs that contain the creator owner/group SID
             * or are not inheritted by new objects
             */
            if ( !osace.IsInherittedByNewObjects() ||
                 *possid == ossidCreatorOwner      ||
                 *possid == ossidCreatorGroup        )
            {
                if ( (err = posacl->DeleteACE( cAces-1 )))
                {
                    break ;
                }
            }
            else
            {
                /* Clear the inherit flags since they have no meaning
                 * for non-containers
                 */
                osace.SetInheritFlags( 0 ) ;
            }
        }
    } while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::SidsToNames

    SYNOPSIS:   This method converts all of the SIDs in the passed Accperm
                to displayable subject names

    ENTRY:      pAccperm - Pointer to ACCPERM class containing the list of
                    Access and Audit permissions
                fAccessPerms - TRUE if we are dealing with Access permissions,
                    FALSE for audit permissions
                psidOwner - Pointer to the owner SID.  If this is NULL, then
                    the owner will not be retrieved and _nlsOwner will be the
                    empty string.

    EXIT:       All NT subjects in the accperm will have their name set to
                the account name and account type

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   30-Apr-1992     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::SidsToNames( ACCPERM * pAccperm,
                                              BOOL      fAccessPerms,
                                              PSID      psidOwner )
{
    APIERR err = NERR_Success ;
    ULONG  cSids = fAccessPerms ? pAccperm->QueryAccessPermCount() :
                                  pAccperm->QueryAuditPermCount() ;

    //
    //  Add one in case we are going to get the owner's name
    //
    BUFFER buffPSIDs( (UINT) (sizeof( PSID ) * (cSids + 1 )) ) ;
    if ( err = buffPSIDs.QueryError() )
    {
        return err ;
    }

    PSID * apsid = (PSID *) buffPSIDs.QueryPtr() ;
    PERMISSION * pPerm ;
    BOOL fFromBeginning = TRUE ;
    BOOL fDone = FALSE ;
    UINT i = 0 ;

    //
    //  Build the array of PSIDs suitable for passing to LSATranslateSidsToNames
    //
    while ( TRUE )
    {
        if ( fAccessPerms )
        {
            fDone = !pAccperm->EnumAccessPermissions( (ACCESS_PERMISSION**)&pPerm,
                                                      &fFromBeginning ) ;
        }
        else
        {
            fDone = !pAccperm->EnumAuditPermissions( (AUDIT_PERMISSION**)&pPerm,
                                                    &fFromBeginning ) ;
        }

        if ( fDone )
            break ;

        NT_SUBJECT * pNTSubj = (NT_SUBJECT *) pPerm->QuerySubject() ;
        apsid[i++] = pNTSubj->QuerySID()->QuerySid() ;
    }

    //
    //  Include the owner SID (for the "Owner:" field in the dialog) if
    //  requested
    //

    if ( psidOwner != NULL )
    {
        apsid[i++] = psidOwner ;
    }

    //
    //  If no names to convert, then just return
    //
    if ( i == 0 )
    {
        return NERR_Success ;
    }

    BUFFER buffUserFlags( i * sizeof( ULONG )) ;
    BUFFER buffSidNameUse( i* sizeof( SID_NAME_USE )) ;
    STRLIST strlistNames ;
    const TCHAR * pszServer = pAccperm->QueryAclConverter()->
                                                QueryLocation()->QueryServer() ;
    API_SESSION APISession( pszServer, TRUE ) ;
    LSA_POLICY LSAPolicyTarget( pszServer ) ;
    OS_SID ossidUsersDomain ;

    if ( err ||
        (err = APISession.QueryError())        ||
        (err = buffUserFlags.QueryError())     ||
        (err = buffSidNameUse.QueryError())    ||
        (err = LSAPolicyTarget.QueryError())      ||
        (err = ossidUsersDomain.QueryError())     ||
	(err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CurrentProcessUser,
                                                    &ossidUsersDomain )) ||
        (err = ossidUsersDomain.TrimLastSubAuthority()) )
    {
        DBGEOL("NT_ACL_TO_PERM_CONVERTER::SidsToNames - Error " << (ULONG) err
                << " returned from SAMServer or GetAccountDomain") ;
        return err ;
    }

    if ((err = NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                                      LSAPolicyTarget,
                                      ossidUsersDomain.QueryPSID(),
                                      apsid,
                                      i,
                                      TRUE,
                                      &strlistNames,
                                      (ULONG*) buffUserFlags.QueryPtr(),
                                      (SID_NAME_USE*) buffSidNameUse.QueryPtr(),
                                      NULL,
                                      pszServer )))
    {
        DBGEOL("NT_ACL_TO_PERM_CONVERTER::SidsToNames - Error " << (ULONG) err
                << " returned from GetQualifiedAccountNames") ;
        return err ;
    }

    /* Set each of the account names to the looked up name
     */
    fDone = FALSE ;
    fFromBeginning = TRUE ;
    i = 0 ;
    SID_NAME_USE * aSidNameUse = (SID_NAME_USE*) buffSidNameUse.QueryPtr() ;
    ULONG *        aUserFlags  = (ULONG *) buffUserFlags.QueryPtr() ;
    ITER_STRLIST iterNames( strlistNames ) ;
    NLS_STR * pnlsName ;
    while ( TRUE )
    {
        if ( fAccessPerms )
        {
            fDone = !pAccperm->EnumAccessPermissions( (ACCESS_PERMISSION**)&pPerm,
                                                     &fFromBeginning ) ;
        }
        else
        {
            fDone = !pAccperm->EnumAuditPermissions( (AUDIT_PERMISSION**)&pPerm,
                                                    &fFromBeginning ) ;
        }

        if ( fDone )
            break ;

        NT_SUBJECT * pNTSubj = (NT_SUBJECT *) pPerm->QuerySubject() ;
	REQUIRE( (pnlsName = iterNames.Next()) != NULL ) ;
	SID_NAME_USE SidUse = aSidNameUse[i] ;

	if ( SidUse == SidTypeDeletedAccount )
	{
	    //
	    //	If this is a deleted account, then just filter it from the
	    //	user list
	    //
	    if ( fAccessPerms )
	    {
		REQUIRE( pAccperm->DeletePermission( (ACCESS_PERMISSION*) pPerm )) ;
	    }
	    else
	    {
		REQUIRE( pAccperm->DeletePermission( (AUDIT_PERMISSION*) pPerm )) ;
	    }
	}
	else
	{
	    if ( SidUse == SidTypeUser &&
		 aUserFlags[i] & USER_TEMP_DUPLICATE_ACCOUNT )
	    {
		SidUse = (SID_NAME_USE) SubjTypeRemote ;
	    }
	    pNTSubj->SetNameUse( SidUse ) ;

	    if ( (err = pNTSubj->SetDisplayName( *pnlsName )))
	    {
		break ;
	    }
	}

        i++ ;
    }

    //
    //  Fill in the owner string if it was requested
    //
    if ( !err && psidOwner != NULL )
    {
        REQUIRE( (pnlsName = iterNames.Next()) != NULL ) ;
        err = _nlsOwner.CopyFrom( *pnlsName ) ;
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\ntfsacl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*

    NTFSAcl.cxx

    This file contains the implementation for the NT File System ACL
    Editor.  It is just a front end for the Generic ACL Editor that is
    specific to the NTFS.

    FILE HISTORY:
        Johnl   30-Dec-1991     Created

*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntioapi.h>
    #include <ntseapi.h>
}

#include <ntmasks.hxx>

#define INCL_NETCONS
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETACCESS      // For NET_ACCESS_1 reference
#define INCL_NETUSE
#include <lmui.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_DIALOG
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <dbgstr.hxx>

#include <string.hxx>
#include <strnumer.hxx>
#include <security.hxx>
#include <ntacutil.hxx>
#include <uibuffer.hxx>
#include <strlst.hxx>
#include <fsenum.hxx>
#include <errmap.hxx>

#include <lmodev.hxx>
#include <lmoacces.hxx>


extern "C"
{
    #include <netlib.h>         // For NetpGetPrivilege
    #include <mpr.h>
    #include <npapi.h>
}
#include <wfext.h>
#include <fmx.hxx>

extern "C"
{
    #include <sedapi.h>
    #include <helpnums.h>
}


#include <cncltask.hxx>
#include <uiassert.hxx>
#include <ipermapi.hxx>
#include <permprg.hxx>
#include <permstr.hxx>
#include <ntfsacl.hxx>

DWORD SedCallback( HWND                   hwndParent,
                   HANDLE                 hInstance,
                   ULONG_PTR              ulCallbackContext,
                   PSECURITY_DESCRIPTOR   psecdesc,
                   PSECURITY_DESCRIPTOR   psecdescNewObjects,
                   BOOLEAN                fApplyToSubContainers,
                   BOOLEAN                fApplyToSubObjects,
                   LPDWORD                StatusReturn
                 ) ;


typedef struct _NTFS_CALLBACK_INFO
{
    HWND hwndFMXOwner ;
    enum SED_PERM_TYPE  sedpermtype ;
} NTFS_CALLBACK_INFO ;

void InitializeNTFSGenericMapping( PGENERIC_MAPPING pNTFSGenericMapping,
                                   BOOL fIsDirectory ) ;

APIERR GetSecurity( const TCHAR *      pszFileName,
                    BUFFER *           pbuffSecDescData,
                    enum SED_PERM_TYPE sedpermtype,
                    BOOL  *            pfAuditPrivAdjusted ) ;

APIERR CompareNTFSSecurityIntersection( HWND hwndFMX,
                                        enum SED_PERM_TYPE sedpermtype,
                                        PSECURITY_DESCRIPTOR psecdesc,
                                        BOOL *           pfOwnerEqual,
                                        BOOL *           pfACLEqual,
                                        NLS_STR *        pnlsFailingFile,
                                        PGENERIC_MAPPING pGenericMapping,
                                        PGENERIC_MAPPING pGenericMappingObjects,
                                        BOOL             fMapGenAll,
                                        BOOL             fIsContainer ) ;

/* The following two arrays define the permission names for NT Files.  Note
 * that each index in one array corresponds to the index in the other array.
 * The second array will be modifed to contain a string pointer pointing to
 * the corresponding IDS_* in the first array.
 */
MSGID msgidFilePermNames[] =
{
    IDS_FILE_PERM_SPEC_READ,
    IDS_FILE_PERM_SPEC_WRITE,
    IDS_FILE_PERM_SPEC_EXECUTE,

    IDS_FILE_PERM_SPEC_DELETE,
    IDS_FILE_PERM_SPEC_CHANGE_PERM,
    IDS_FILE_PERM_SPEC_CHANGE_OWNER,

    IDS_FILE_PERM_GEN_NO_ACCESS,
    IDS_FILE_PERM_GEN_READ,
    IDS_FILE_PERM_GEN_MODIFY,
    IDS_FILE_PERM_GEN_ALL
} ;

SED_APPLICATION_ACCESS sedappaccessFilePerms[] =
    {
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_READ,         0, NULL },
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_WRITE,        0, NULL },
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_EXECUTE,      0, NULL },
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_DELETE,       0, NULL },
      //{ SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_READ_PERM,    0, NULL },
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_CHANGE_PERM,  0, NULL },
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_CHANGE_OWNER, 0, NULL },

      { SED_DESC_TYPE_RESOURCE,         FILE_PERM_GEN_NO_ACCESS,    0, NULL },
      { SED_DESC_TYPE_RESOURCE,         FILE_PERM_GEN_READ,         0, NULL },
      { SED_DESC_TYPE_RESOURCE,         FILE_PERM_GEN_MODIFY,       0, NULL }
      ,
      { SED_DESC_TYPE_RESOURCE,         FILE_PERM_GEN_ALL,          0, NULL }
    } ;

#define COUNT_FILEPERMS_ARRAY   (sizeof(sedappaccessFilePerms)/sizeof(SED_APPLICATION_ACCESS))

/* The following two arrays define the permission names for NT directories.  Note
 * that each index in one array corresponds to the index in the other array.
 * The second array will be modifed to contain a string pointer pointing to
 * the corresponding IDS_* in the first array.
 */
MSGID msgidDirPermNames[] =
{
    IDS_DIR_PERM_SPEC_READ,
    IDS_DIR_PERM_SPEC_WRITE,
    IDS_DIR_PERM_SPEC_EXECUTE,
    IDS_DIR_PERM_SPEC_DELETE,
    IDS_DIR_PERM_SPEC_CHANGE_PERM,
    IDS_DIR_PERM_SPEC_CHANGE_OWNER,

    IDS_DIR_PERM_GEN_NO_ACCESS,
    IDS_DIR_PERM_GEN_LIST,
    IDS_DIR_PERM_GEN_READ,
    IDS_DIR_PERM_GEN_DEPOSIT,
    IDS_DIR_PERM_GEN_PUBLISH,
    IDS_DIR_PERM_GEN_MODIFY,
    IDS_DIR_PERM_GEN_ALL,

    IDS_NEWFILE_PERM_SPEC_READ,
    IDS_NEWFILE_PERM_SPEC_WRITE,
    IDS_NEWFILE_PERM_SPEC_EXECUTE,
    IDS_NEWFILE_PERM_SPEC_DELETE,
    IDS_NEWFILE_PERM_SPEC_CHANGE_PERM,
    IDS_NEWFILE_PERM_SPEC_CHANGE_OWNER
} ;

SED_APPLICATION_ACCESS sedappaccessDirPerms[] =
{
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_READ,        0, NULL },
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_WRITE,       0, NULL },
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_EXECUTE,     0, NULL },
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_DELETE,      0, NULL },
  //{ SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_READ_PERM,   0, NULL },
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_CHANGE_PERM, 0, NULL },
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_CHANGE_OWNER,0, NULL },

  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_NO_ACCESS,NEWFILE_PERM_GEN_NO_ACCESS, NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_LIST,     NEWFILE_PERM_GEN_LIST,      NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_READ,     NEWFILE_PERM_GEN_READ,      NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_DEPOSIT,  NEWFILE_PERM_GEN_DEPOSIT,   NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_PUBLISH,  NEWFILE_PERM_GEN_PUBLISH,   NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_MODIFY,   NEWFILE_PERM_GEN_MODIFY,    NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_ALL,      NEWFILE_PERM_GEN_ALL,       NULL },

  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_READ,         0, NULL },
  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_WRITE,        0, NULL },
  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_EXECUTE,      0, NULL },
  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_DELETE,       0, NULL },
  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_CHANGE_PERM,  0, NULL },
  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_CHANGE_OWNER, 0, NULL }
} ;

#define COUNT_DIRPERMS_ARRAY    (sizeof(sedappaccessDirPerms)/sizeof(SED_APPLICATION_ACCESS))

/* The following two arrays define the auditting names for NT directories and
 * directories.
 */
MSGID msgidFileAuditNames[] =
{
    IDS_FILE_AUDIT_READ,
    IDS_FILE_AUDIT_WRITE,
    IDS_FILE_AUDIT_EXECUTE,
    IDS_FILE_AUDIT_DELETE,
    IDS_FILE_AUDIT_CHANGE_PERM,
    IDS_FILE_AUDIT_CHANGE_OWNER
} ;

SED_APPLICATION_ACCESS sedappaccessFileAudits[] =
    {
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_READ,        0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_WRITE,       0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_EXECUTE,     0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_DELETE,      0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_CHANGE_PERM, 0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_CHANGE_OWNER,0, NULL }
    } ;

#define COUNT_FILE_AUDITPERMS_ARRAY   (sizeof(sedappaccessFileAudits)/sizeof(SED_APPLICATION_ACCESS))


/* The following two arrays define the auditting names for NT directories and
 * directories.
 */
MSGID msgidDirAuditNames[] =
{
    IDS_DIR_AUDIT_READ,
    IDS_DIR_AUDIT_WRITE,
    IDS_DIR_AUDIT_EXECUTE,
    IDS_DIR_AUDIT_DELETE,
    IDS_DIR_AUDIT_CHANGE_PERM,
    IDS_DIR_AUDIT_CHANGE_OWNER
} ;

SED_APPLICATION_ACCESS sedappaccessDirAudits[] =
    {
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_READ,        0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_WRITE,       0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_EXECUTE,     0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_DELETE,      0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_CHANGE_PERM, 0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_CHANGE_OWNER,0, NULL }
    } ;

#define COUNT_DIR_AUDITPERMS_ARRAY   (sizeof(sedappaccessDirAudits)/sizeof(SED_APPLICATION_ACCESS))


extern HINSTANCE hModule; // Exported from libmain


/*******************************************************************

    NAME:       EditNTFSAcl

    SYNOPSIS:   This Procedure prepares the structures necessary for the
                generic ACL editor, specifically for NT FS (FileSystem)
                ACLs.

    ENTRY:      hwndParent - Parent window handle, this should be the
                    FMX Window handle
                pszServer - Name of server the resource resides on
                    (in the form "\\server")
                pszResource - Fully qualified name of resource we will
                    edit (suitable for passing to GetFileSecurity)
                sedpermtype - either SED_ACCESSES or SED_AUDITS
                fIsFile - TRUE if the resource is a file, FALSE if the
                    resource is a directory

    EXIT:

    RETURNS:

    NOTES:      We assume we are dealing with an NTFS volume by the time
                this function is called.

    HISTORY:
        Johnl   25-Dec-1992     Created

********************************************************************/

APIERR EditNTFSAcl( HWND                hwndParent,
                    const TCHAR *       pszServer,
                    const TCHAR *       pszResource,
                    enum SED_PERM_TYPE  sedpermtype,
                    BOOL                fIsFile )
{
    APIERR err ;
    BUFFER buffSecDescData( 1024 ) ;
    BOOL   fCantRead     = FALSE ;      // Did we read the Owner?
    BOOL   fCantWrite    = FALSE ;      // Is it read only?
    BOOL   fPrivAdjusted = FALSE ;      // Do we need to restore our token?
    BOOL   fCheckSecurity= TRUE ;       // Check security unless bad intersection
    const TCHAR * pszSecCheckFile = pszResource ;

    do { // error breakout

        PSECURITY_DESCRIPTOR pSecurityDesc = NULL ;

        switch ( err = ::GetSecurity( pszResource,
                                      &buffSecDescData,
                                      sedpermtype,
                                      &fPrivAdjusted ) )
        {
        case ERROR_ACCESS_DENIED:
            fCantRead = TRUE ;

            //
            //  If they can't read the SACL then they don't have the privilege
            //
            if ( sedpermtype == SED_AUDITS )
            {
                err = ERROR_PRIVILEGE_NOT_HELD ;
                break ;
            }

            err = NERR_Success ;
            break ;

        case NO_ERROR:
            pSecurityDesc = (PSECURITY_DESCRIPTOR) buffSecDescData.QueryPtr() ;
            break ;

        default:
            break ;
        }
        if ( err )
            break ;

        GENERIC_MAPPING NTFSGenericMapping ;
        InitializeNTFSGenericMapping( &NTFSGenericMapping, !fIsFile ) ;

        FMX  fmx( hwndParent ) ;
        BOOL fIsMultiSelect = fmx.QuerySelCount() > 1 ;

        //
        //  We may need to substitute our own security descriptor here
        //  depending on the intersection of security descriptors because
        //  we can't set a NULL owner on a self relative security descriptor
        //  (which we will most likely get).
        //
        OS_SECURITY_DESCRIPTOR ossecdesc( fIsMultiSelect ?
                                          pSecurityDesc : NULL, TRUE ) ;
        OS_ACL osacl( NULL ) ;
        DEC_STR nlsSelectCount( fmx.QuerySelCount() ) ;
        if ( fIsMultiSelect )
        {
            BOOL fOwnerEqual = FALSE, fACLEqual = FALSE ;
            NLS_STR nlsFailingFile ;
            MSGID idsPromptToContinue = IDS_BAD_INTERSECTION ;
            if ( fCantRead                      ||
                 (err = ossecdesc.QueryError()) ||
                 (err = nlsSelectCount.QueryError()) ||
                 (err = CompareNTFSSecurityIntersection( hwndParent,
                                                         sedpermtype,
                                                         pSecurityDesc,
                                                         &fOwnerEqual,
                                                         &fACLEqual,
                                                         &nlsFailingFile,
                                                         &NTFSGenericMapping,
                                                         &NTFSGenericMapping,
                                                         TRUE,
                                                         !fIsFile )) )
            {
                //
                //  If we didn't have access to read one of the security
                //  descriptors, then give the user the option of continuing
                //
                if ( fCantRead || err == ERROR_ACCESS_DENIED )
                {
                    pszResource = fCantRead ? pszResource :
                                              nlsFailingFile.QueryPch() ;
                    idsPromptToContinue = IERR_MULTI_SELECT_AND_CANT_READ ;
                    fCantRead = TRUE ;
                    err = NERR_Success ;
                }
                else
                {
                    break ;
                }
            }

            //
            // Substitute the blank security descriptor only if we need to
            //
            if ( !fACLEqual || !fOwnerEqual || fCantRead )
            {
                pSecurityDesc = ossecdesc.QueryDescriptor() ;
            }

            if ( !fACLEqual || fCantRead )
            {
                switch ( ::MsgPopup( hwndParent,
                                     (MSGID) idsPromptToContinue,
                                     MPSEV_WARNING,
                                     MP_YESNO,
                                     pszResource,
                                     nlsFailingFile,
                                     MP_YES ))
                {
                case IDYES:
                    {
                        if ( (err = ossecdesc.SetDACL( TRUE, &osacl )) ||
                             (err = ossecdesc.SetSACL( TRUE, &osacl )) ||
                             (err = ossecdesc.SetOwner( FALSE, NULL, 0 )) ||
                             (err = ossecdesc.SetGroup( FALSE, NULL, 0 ))   )
                        {
                            break ;
                        }

                        //
                        //  We've just made the ACL equal.  Note that we don't
                        //  check the security if the ACLs aren't equal (some
                        //  may allow access, others may not).
                        //
                        fACLEqual = TRUE ;
                        fCantRead = FALSE ;
                        fCheckSecurity = FALSE ;
                    }
                    break ;

                case IDNO:
                default:
                    break ;
                }
            }
            if ( err || !fACLEqual || fCantRead )
                break ;

            if ( !fOwnerEqual &&
                 (err = ossecdesc.SetOwner( FALSE, NULL, 0 )) )
            {
                break ;
            }
        } // if IsMultiSelect


        /* Retrieve the resource strings appropriate for the type of object we
         * are looking at
         */

        MSGID msgidTypeName = fIsFile ? IDS_FILE : IDS_DIRECTORY ;
        MSGID msgidApplySubCont = sedpermtype == SED_ACCESSES ?
                                       IDS_NT_ASSIGN_PERM_TITLE:
                                       IDS_NT_ASSIGN_AUDITS_TITLE ;
        MSGID msgidApplySubObj   =sedpermtype == SED_ACCESSES ?
                                       IDS_NT_ASSIGN_FILE_PERM_TITLE :
                                       IDS_NT_ASSIGN_FILE_AUDITS_TITLE ;

        RESOURCE_STR nlsTypeName( msgidTypeName ) ;
        RESOURCE_STR nlsSpecial( fIsFile ? IDS_NT_FILE_SPECIAL_ACCESS :
                                           IDS_NT_DIR_SPECIAL_ACCESS ) ;
        RESOURCE_STR nlsDefaultPermName( fIsFile ? IDS_FILE_PERM_GEN_READ :
                                                   IDS_DIR_PERM_GEN_READ   ) ;
        RESOURCE_STR nlsHelpFileName   ( IDS_FILE_PERM_HELP_FILE ) ;
        RESOURCE_STR nlsResourceName   ( fIsFile ? IDS_FILE_MULTI_SEL :
                                                   IDS_DIRECTORY_MULTI_SEL ) ;

        NLS_STR  nlsApplyToSubCont ;
        NLS_STR  nlsApplyToSubObj ;
        NLS_STR  nlsSpecialNewObj ;
        NLS_STR  nlsApplyToSubContConfirmation ;

        /* We only need the ApplyTo title and the NewObjSpecial strings if
         * this resource is a directory.
         */
        if ( !fIsFile )
        {
            if ( (err = nlsApplyToSubCont.Load( msgidApplySubCont )) ||
                 (err = nlsApplyToSubObj.Load(  msgidApplySubObj  )) ||
                 (err = nlsSpecialNewObj.Load(IDS_NT_NEWOBJ_SPECIAL_ACCESS)) ||
                 (err = nlsApplyToSubContConfirmation.Load( IDS_TREE_APPLY_WARNING )))
            {
                /* Fall through
                 */
            }
        }

        if ( err ||
             ( err = nlsTypeName.QueryError() ) ||
             ( err = nlsSpecial.QueryError() )  ||
             ( err = nlsDefaultPermName.QueryError()) ||
             ( err = nlsHelpFileName.QueryError()) )
        {
            break ;
        }

        //
        //  Replace the resource name with the "X files selected" string
        //  if we are in a multi-select situation
        //
        if ( fIsMultiSelect )
        {
            if ( (err = nlsResourceName.QueryError()) ||
                 (err = nlsResourceName.InsertParams( nlsSelectCount )))
            {
                break ;
            }
            pszResource = nlsResourceName.QueryPch() ;
        }

        SED_OBJECT_TYPE_DESCRIPTOR sedobjdesc ;
        SED_HELP_INFO sedhelpinfo ;

        sedhelpinfo.pszHelpFileName = (LPWSTR) nlsHelpFileName.QueryPch() ;

        sedobjdesc.Revision                    = SED_REVISION1 ;
        sedobjdesc.IsContainer                 = !fIsFile ;
        sedobjdesc.AllowNewObjectPerms         = !fIsFile ;
        sedobjdesc.MapSpecificPermsToGeneric   = TRUE ;
        sedobjdesc.GenericMapping              = &NTFSGenericMapping ;
        sedobjdesc.GenericMappingNewObjects    = &NTFSGenericMapping ;
        sedobjdesc.HelpInfo                    = &sedhelpinfo ;
        sedobjdesc.ObjectTypeName              = (LPTSTR) nlsTypeName.QueryPch() ;
        sedobjdesc.ApplyToSubContainerTitle    = (LPTSTR) nlsApplyToSubCont.QueryPch() ;
        sedobjdesc.ApplyToObjectsTitle         = (LPTSTR) nlsApplyToSubObj.QueryPch() ;
        sedobjdesc.ApplyToSubContainerConfirmation
                                               = (LPTSTR) nlsApplyToSubContConfirmation.QueryPch() ;
        sedobjdesc.SpecialObjectAccessTitle    = (LPTSTR) nlsSpecial.QueryPch() ;
        sedobjdesc.SpecialNewObjectAccessTitle = (LPTSTR) nlsSpecialNewObj.QueryPch() ;

        /* Now we need to load the global arrays with the permission names
         * from the resource file.
         */
        UINT cArrayItems ;
        MSGID * msgidPermNames ;
        PSED_APPLICATION_ACCESS pappaccess ;
        ULONG hcMainDlg, hcSpecial, hcNewItemSpecial, hcAddUser,
                         hcAddMemberLG, hcAddMemberGG, hcAddSearch ;
        ACCESS_MASK WriteAccessReq ;
		
		// NTRAID#NTBUG9-574280-2002/03/07-artm  Prefast: Local declaration hides function level declaration.
		// A little tricky to figure out, but this declaration probably is unintentional.  The code
		// outside the scope of the do{}while() loop that checks fPrivAdjusted will never be
		// executed b/c fPrivAdjusted is always set to FALSE outside the loop.
		//
		// This function appears to be used.
        BOOL fPrivAdjusted = FALSE;
        ULONG ulAuditPriv  = SE_SECURITY_PRIVILEGE ;

        switch ( sedpermtype )
        {
        case SED_ACCESSES:
            hcAddUser        = HC_SED_USER_BROWSER_DIALOG ;
            hcAddMemberLG    = HC_SED_USER_BROWSER_LOCALGROUP ;
            hcAddMemberGG    = HC_SED_USER_BROWSER_GLOBALGROUP ;
            hcAddSearch      = HC_SED_USER_BROWSER_FINDUSER ;
            WriteAccessReq   = WRITE_DAC ;

            if ( fIsFile )
            {
                cArrayItems = COUNT_FILEPERMS_ARRAY ;
                msgidPermNames = msgidFilePermNames ;
                pappaccess = sedappaccessFilePerms ;
                hcMainDlg        = HC_SED_NT_FILE_PERMS_DLG ;
                hcSpecial        = HC_SED_NT_SPECIAL_FILES_FM ;
            }
            else
            {
                cArrayItems = COUNT_DIRPERMS_ARRAY ;
                msgidPermNames = msgidDirPermNames ;
                pappaccess = sedappaccessDirPerms ;
                hcMainDlg        = HC_SED_NT_DIR_PERMS_DLG ;
                hcSpecial        = HC_SED_NT_SPECIAL_DIRS_FM ;
                hcNewItemSpecial = HC_SED_NT_SPECIAL_NEW_FILES_FM ;
            }
            break ;

        case SED_AUDITS:
            hcAddUser        = HC_SED_USER_BROWSER_AUDIT_DLG ;
            hcAddMemberLG    = HC_SED_USER_BR_AUDIT_LOCALGROUP ;
            hcAddMemberGG    = HC_SED_USER_BR_AUDIT_GLOBALGROUP ;
            hcAddSearch      = HC_SED_USER_BR_AUDIT_FINDUSER ;
            WriteAccessReq   = ACCESS_SYSTEM_SECURITY ;

            if ( fCheckSecurity )
            {
                if (err = ::NetpGetPrivilege( 1, &ulAuditPriv ) )
                {
                    break ;
                }
                else
                    fPrivAdjusted = TRUE ;
            }

            if ( fIsFile )
            {
                cArrayItems = COUNT_FILE_AUDITPERMS_ARRAY ;
                msgidPermNames = msgidFileAuditNames ;
                pappaccess = sedappaccessFileAudits ;
                hcMainDlg        = HC_SED_NT_FILE_AUDITS_DLG ;
            }
            else
            {
                cArrayItems = COUNT_DIR_AUDITPERMS_ARRAY ;
                msgidPermNames = msgidDirAuditNames ;
                pappaccess = sedappaccessDirAudits ;
                hcMainDlg        = HC_SED_NT_DIR_AUDITS_DLG ;
            }
            break ;

        default:
            UIASSERT(!SZ("Bad permission type")) ;
            err = ERROR_GEN_FAILURE ;
            break ;
        }
        if ( err )
            break ;

        if ( fCheckSecurity )
        {
            BOOL fCanWrite ;
            if ( err = ::CheckFileSecurity( pszSecCheckFile,
                                            WriteAccessReq,
                                            &fCanWrite ) )
            {
                break ;
            }
            fCantWrite = !fCanWrite ;

            if ( fPrivAdjusted )
                NetpReleasePrivilege() ;
        }

        /* Loop through each permission title retrieving the text from the
         * resource file and setting the pointer in the array.  The memory
         * will be deleted when strlistPermNames is destructed.
         */
        STRLIST strlistPermNames ;
        for ( UINT i = 0 ; i < cArrayItems ; i++ )
        {
            RESOURCE_STR * pnlsPermName = new RESOURCE_STR( msgidPermNames[i]) ;
            err = (pnlsPermName==NULL) ? ERROR_NOT_ENOUGH_MEMORY :
                                         pnlsPermName->QueryError() ;
            if (  err ||
                 (err = strlistPermNames.Add( pnlsPermName )) )
            {
                delete pnlsPermName ;
                break ;
            }
            pappaccess[i].PermissionTitle = (LPTSTR) pnlsPermName->QueryPch() ;
        }
        if ( err )
            break ;

        SED_APPLICATION_ACCESSES SedAppAccesses ;
        SedAppAccesses.Count           = cArrayItems ;
        SedAppAccesses.AccessGroup     = pappaccess ;
        SedAppAccesses.DefaultPermName = (LPTSTR) nlsDefaultPermName.QueryPch() ;
        sedhelpinfo.aulHelpContext[HC_MAIN_DLG]                    = hcMainDlg ;
        sedhelpinfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG]          = hcSpecial ;
        sedhelpinfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = hcNewItemSpecial ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_DLG]                = hcAddUser ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG]     = hcAddMemberLG ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG]     = hcAddMemberGG ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] = hcAddSearch ;



        DWORD dwSedReturnStatus ;
        NTFS_CALLBACK_INFO callbackinfo ;
        callbackinfo.hwndFMXOwner = hwndParent ;

        switch ( sedpermtype )
        {
        case SED_ACCESSES:
            callbackinfo.sedpermtype= SED_ACCESSES ;
            err = SedDiscretionaryAclEditor( hwndParent,
                                            ::hModule,
                                            (LPTSTR) pszServer,
                                            &sedobjdesc,
                                            &SedAppAccesses,
                                            (LPTSTR) pszResource,
                                            (PSED_FUNC_APPLY_SEC_CALLBACK) SedCallback,
                                            (ULONG_PTR) &callbackinfo,
                                            pSecurityDesc,
                                            (BOOLEAN)fCantRead,
                                            (BOOLEAN)fCantWrite,
                                            &dwSedReturnStatus,
                                            0 ) ;
            break ;

        case SED_AUDITS:
            callbackinfo.sedpermtype = SED_AUDITS ;
            err = SedSystemAclEditor( hwndParent,
                                     ::hModule,
                                     (LPTSTR) pszServer,
                                     &sedobjdesc,
                                     &SedAppAccesses,
                                     (LPTSTR) pszResource,
                                     (PSED_FUNC_APPLY_SEC_CALLBACK) SedCallback,
                                     (ULONG_PTR) &callbackinfo,
                                     pSecurityDesc,
                                     fCantRead || fCantWrite,
                                     &dwSedReturnStatus,
                                     0 ) ;
            break ;

        default:
            UIASSERT(!SZ("Bad type") ) ;
            err = ERROR_GEN_FAILURE ;
            break ;
        }
        if ( err )
            break ;

    } while (FALSE) ;

    /* We need to revert to ourselves if we were doing auditting
     */
    if ( fPrivAdjusted )
    {
        APIERR errTmp = NetpReleasePrivilege() ;
        if ( errTmp )
        {
            DBGEOL("::EditNTFSAcl - Warning: NetpReleasePrivilege return error "
                   << errTmp ) ;
        }
    }

    TRACEEOL(SZ("::EditNTFSAcl returning error code ") << (ULONG) err ) ;

    if ( err )
    {
        ::MsgPopup( hwndParent, (MSGID) err ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:       SedCallback

    SYNOPSIS:   Security Editor callback for the NTFS ACL Editor

    ENTRY:      See sedapi.hxx

    EXIT:

    RETURNS:

    NOTES:      The callback context should be the FMX Window handle.  This
                is so we can support setting permissions on multiple files/
                directories if we ever decide to do that.

    HISTORY:
        Johnl   17-Mar-1992     Filled out

********************************************************************/


DWORD SedCallback( HWND                   hwndParent,
                   HANDLE                 hInstance,
                   ULONG_PTR              ulCallbackContext,
                   PSECURITY_DESCRIPTOR   psecdesc,
                   PSECURITY_DESCRIPTOR   psecdescNewObjects,
                   BOOLEAN                fApplyToSubContainers,
                   BOOLEAN                fApplyToSubObjects,
                   LPDWORD                StatusReturn
                 )
{
    UNREFERENCED( hInstance ) ;
    APIERR err = NO_ERROR ;
    NTFS_CALLBACK_INFO *pcallbackinfo = (NTFS_CALLBACK_INFO *)ulCallbackContext;
    HWND hwndFMXWindow = pcallbackinfo->hwndFMXOwner ;
    OS_SECURITY_INFORMATION osSecInfo ;
    BOOL fDepthFirstTraversal = TRUE ;
    BOOL fApplyToDirContents  = FALSE ;
    BOOL fIsFile ;
    BOOL fBlowAwayDACLOnCont  = FALSE ;
    NLS_STR nlsSelItem( 128 ) ;
    RESOURCE_STR nlsCancelDialogTitle( IDS_CANCEL_TASK_APPLY_DLG_TITLE ) ;
    BOOL fPrivAdjusted = FALSE;

    if ( (err = nlsSelItem.QueryError()) ||
         (err = nlsCancelDialogTitle.QueryError()) ||
         (err = ::GetSelItem( hwndFMXWindow, 0, &nlsSelItem, &fIsFile )) )
    {
        *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
        ::MsgPopup( hwndParent, (MSGID) err ) ;
        return err ;
    }

    switch ( pcallbackinfo->sedpermtype )
    {
    case SED_ACCESSES:
        osSecInfo.SetDACLReference( TRUE ) ;
        fApplyToDirContents = !fIsFile && fApplyToSubObjects ;

        //
        //  Check to see if we should do a depth first or breadth first
        //  traversal of the selected directory.  If we have traverse
        //  on the directory already, then do depth first.  If we don't,
        //  then do a breadth first and hope we are granting ourselves
        //  traverse.
        //
        if ( fApplyToSubContainers || fApplyToDirContents )
        {
            if ( err = ::CheckFileSecurity( nlsSelItem,
                                            FILE_TRAVERSE | FILE_LIST_DIRECTORY,
                                            &fDepthFirstTraversal ))
            {
                DBGEOL("SedCallBack - ::CheckFileSecurity failed with error " << err ) ;
                *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
                ::MsgPopup( hwndParent, (MSGID) err ) ;
                return err ;
            }
            TRACEEOL("SedCallBack - Depth first = " << fDepthFirstTraversal ) ;
        }
        break ;

    case SED_AUDITS:
        {
            osSecInfo.SetSACLReference( TRUE ) ;
            fApplyToDirContents = !fIsFile && fApplyToSubObjects ;;
            ULONG ulAuditPriv  = SE_SECURITY_PRIVILEGE ;

            if (err = ::NetpGetPrivilege( 1, &ulAuditPriv ) )
            {
                break ;
            }
            else
                fPrivAdjusted = TRUE ;
        }
        break ;

    case SED_OWNER:

        osSecInfo.SetOwnerReference( TRUE ) ;

        //
        //  Do a breadth first traversal since taking ownership grants
        //  additional privileges
        //
        fDepthFirstTraversal = FALSE ;

        //
        //  Containers and objects get the same security descriptor
        //
        psecdescNewObjects = psecdesc ;

        if ( !fIsFile )
        {
            switch ( ::MsgPopup( hwndParent,
                                 IDS_OWNER_APPLY_TO_DIR_PROMPT,
                                 MPSEV_INFO,
                                 MP_YESNOCANCEL ))
            {
            case IDYES:
                fApplyToSubContainers = TRUE ;
                fApplyToSubObjects    = TRUE ;
                fBlowAwayDACLOnCont   = TRUE ;
                fApplyToDirContents   = TRUE ;
                break ;

            case IDNO:
                fApplyToSubContainers = FALSE ;
                fApplyToSubObjects    = FALSE ;
                fBlowAwayDACLOnCont   = FALSE ;
                fApplyToDirContents   = FALSE ;
                break ;

            case IDCANCEL:
            default:
                *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
                return ERROR_GEN_FAILURE ;  // any nonzero error code
            }
        }

        break ;

    default:
        UIASSERT( FALSE ) ;
        *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
        return ERROR_GEN_FAILURE ;
    }

    FMX fmx( hwndFMXWindow );
    UINT uiCount = fmx.QuerySelCount() ;
    BOOL fDismissDlg = TRUE ;

    //
    //  QuerySelCount only returns the number of selections in the files window,
    //  thus if the focus is in the directory window, then we will just make
    //  the selection count one for out "for" loop.
    //
    if ( fmx.QueryFocus() == FMFOCUS_TREE )
    {
        uiCount = 1 ;
    }

    //
    //  If we only have to apply permissions to a single item or we are
    //  taking ownership of a file, then just
    //  do it w/o bringing up the cancel task dialog.
    //
    if (  uiCount == 1 &&
          !fApplyToSubContainers &&
          !fApplyToSubObjects    &&
          !fApplyToDirContents )
    {
        // Try Admins Group First
        OS_SECURITY_DESCRIPTOR osSecAdmin;
        OS_SID ossidAdmins;

        NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Admins,
                                             &ossidAdmins );
        osSecAdmin.SetOwner(ossidAdmins);
        osSecAdmin.SetGroup(ossidAdmins);

        //
        // CODEWORK We skip this hack unless taking ownership.  Note that the
        // osSecAdmin and ossidAdmins should also be removed.
        //
        if ( SED_OWNER != pcallbackinfo->sedpermtype
          || !::SetFileSecurity( (LPTSTR) nlsSelItem.QueryPch(),
                                          osSecInfo,
                                          osSecAdmin.QueryDescriptor() ) )
        {// if it fails try owner account
            if ( !::SetFileSecurity( (LPTSTR) nlsSelItem.QueryPch(),
                                              osSecInfo,
                                              psecdesc ) )
            {
                err = ::GetLastError() ;
            }
        }
        if ( err )
        {
            DBGEOL("NTFS SedCallback - Error " << (ULONG)err << " applying security to " <<
               nlsSelItem ) ;
            ::MsgPopup( hwndParent, (MSGID) err ) ;
            *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
        }
    }
    else
    {
        NTFS_TREE_APPLY_CONTEXT Ctxt( nlsSelItem, osSecInfo ) ;
        Ctxt.State                = APPLY_SEC_FMX_SELECTION ;
        Ctxt.hwndFMXWindow        = hwndFMXWindow ;
        Ctxt.sedpermtype          = pcallbackinfo->sedpermtype ;
        Ctxt.iCurrent             = 0 ;
        Ctxt.uiCount              = uiCount ;
        Ctxt.fDepthFirstTraversal = fDepthFirstTraversal ;
        Ctxt.fApplyToDirContents  = fApplyToDirContents ;
        Ctxt.fBlowAwayDACLOnCont  = fBlowAwayDACLOnCont ;
        Ctxt.StatusReturn         = StatusReturn ;
        Ctxt.psecdesc             = psecdesc ;
        Ctxt.psecdescNewObjects   = psecdescNewObjects ;
        Ctxt.fApplyToSubContainers= fApplyToSubContainers ;
        Ctxt.fApplyToSubObjects   = fApplyToSubObjects ;

        NTFS_CANCEL_TREE_APPLY CancelTreeApply( hwndParent,
                                                &Ctxt,
                                                nlsCancelDialogTitle ) ;

        if ( (err = CancelTreeApply.QueryError()) ||
             (err = CancelTreeApply.Process( &fDismissDlg )) )
        {
            *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
            ::MsgPopup( hwndParent, (MSGID) err ) ;
        }
    }

    if ( !err )
    {
        //
        // Refresh the file manager window if permissions is updated
        // (Take ownership of a tree also writes a new DACL)
        //
        if ( pcallbackinfo->sedpermtype == SED_ACCESSES ||
             pcallbackinfo->sedpermtype == SED_OWNER )
        {
            fmx.Refresh();
        }

        if ( *StatusReturn == 0 )
            *StatusReturn = SED_STATUS_MODIFIED ;
    }

    if ( fPrivAdjusted )
    {
        APIERR errTmp = NetpReleasePrivilege() ;
        if ( errTmp )
        {
            DBGEOL("::EditNTFSAcl - Warning: NetpReleasePrivilege return error "
                   << errTmp ) ;
        }
    }

    if ( !err && !fDismissDlg )
    {
        //
        //  Don't dismiss the dialog if the user canceled the tree
        //  apply.  This tells the ACL editor not to dismiss the permissions
        //  dialog (or auditing or owner).
        //
        err = ERROR_GEN_FAILURE ;
    }

    return err ;
}

/*******************************************************************

    NAME:       CANCEL_TREE_APPLY::DoOneItem

    SYNOPSIS:   This is the time slice call for the tree apply

    ENTRY:      ulContext - Context passed to the constructor

    RETURNS:    NERR_Success if this time slice was successful, error
                code otherwise (which will be displayed to the user).

    NOTES:

    HISTORY:
        Johnl   22-Oct-1992     Created

********************************************************************/

APIERR CANCEL_TREE_APPLY::DoOneItem( ULONG_PTR ulContext,
                                     BOOL  *pfContinue,
                                     BOOL  *pfDisplayErrors,
                                     MSGID *pmsgidAlternateMessage )
{
    TREE_APPLY_CONTEXT * pCtxt = (TREE_APPLY_CONTEXT*) ulContext ;
    *pfDisplayErrors = TRUE ;
    *pfContinue      = TRUE ;
    APIERR err = NERR_Success ;
    APIERR errTrav = NERR_Success;
    BOOL fSuccess ;

    switch ( pCtxt->State )
    {
    case APPLY_SEC_IN_FS_ENUM:
        {
            UIASSERT( pCtxt->pfsenum != NULL ) ;

            fSuccess = pCtxt->pfsenum->Next() ;

            NLS_STR nlsFileName ;
            if ( (err = nlsFileName.QueryError()) ||
                 (err = pCtxt->pfsenum->QueryName( &nlsFileName )))
            {
                break ;
            }

            REQUIRE( UpdateStatus( nlsFileName ) == NERR_Success ) ;

            //
            //  Only write the security if the enumeration was successful
            //
            if ( fSuccess )
            {
ApplySecurity:
                err = WriteSecurity( ulContext,
                                     nlsFileName,
                                     !(pCtxt->pfsenum->QueryAttr()&_A_SUBDIR),
                                     pfContinue ) ;
                if ( !*pfContinue )
                {
                    delete pCtxt->pfsenum ;
                    pCtxt->pfsenum = NULL ;
                }

                //
                //  Report any traversal errors after attempting to apply
                //  security to the container we failed to traverse
                //

                if ( errTrav )
                    err = errTrav;

                break ;
            }
            else if ((err = pCtxt->pfsenum->QueryLastError()) != ERROR_NO_MORE_FILES)
            {
                *pmsgidAlternateMessage = IDS_CANCEL_TASK_TRAV_ERROR_MSG ;

                //
                //  Apply security even in the error case if we're not at the
                //  selected directory.  This handles the case of hitting a no
                //  access directory as the only selection
                //

                if ( pCtxt->pfsenum->QueryTotalFiles() )
                {
                    errTrav = err;
                    goto ApplySecurity;
                }

                //
                //  falls through and deletes the enumerator
                //
            }
            else
            {
                //
                //  Running out of files is a success error code
                //
                err = NERR_Success ;
                TRACEEOL("SedCallBack - Traversed " << pCtxt->pfsenum->QueryTotalFiles() <<
                        " files and directories") ;
            }
            delete pCtxt->pfsenum ;
            pCtxt->pfsenum = NULL ;
            pCtxt->State = APPLY_SEC_FMX_POST_FS_ENUM ;
        }
        break ;


    case APPLY_SEC_FMX_POST_FS_ENUM:
        //
        //  Apply security to the container after everything under this has
        //  been applied if we are doing a depth first traversal.
        //
        if ( pCtxt->fDepthFirstTraversal )
        {
            UpdateStatus( pCtxt->nlsSelItem ) ;
            if ( err = WriteSecurity( ulContext,
                                      pCtxt->nlsSelItem,
                                      pCtxt->fIsSelFile,
                                      pfContinue ))
            {
                // Fall through
            }
        }
        pCtxt->State = APPLY_SEC_FMX_SELECTION ;
        break ;

    case APPLY_SEC_FMX_SELECTION:

        /* Have we went through all of the selected items?
         */
        if ( pCtxt->iCurrent >= pCtxt->uiCount )
        {
            *pfContinue = FALSE ;
            break ;
        }

        /* Get the current selection and apply the permissions
         */
        if (err = ::GetSelItem( pCtxt->hwndFMXWindow,
                                pCtxt->iCurrent++,
                                &pCtxt->nlsSelItem,
                                &pCtxt->fIsSelFile ) )
        {
            break ;
        }

        //
        //  If we're doing the breadthfirst traversal, then apply to the
        //  container before traversing, else apply after traversing.
        //  If it's a file, then always apply.
        //
        if (( !pCtxt->fDepthFirstTraversal || pCtxt->fIsSelFile ) ||
            ( (!pCtxt->fApplyToSubContainers && !pCtxt->fApplyToDirContents) &&
              !pCtxt->fIsSelFile ))
        {
            UpdateStatus( pCtxt->nlsSelItem ) ;
            if ( err = WriteSecurity( ulContext,
                                      pCtxt->nlsSelItem,
                                      pCtxt->fIsSelFile,
                                      pfContinue ))
            {
                break ;
            }
        }

        //
        //  If the user checked the apply to tree box or apply to existing file
        //  checkbox and this is a container then apply the
        //  permissions down the sub-tree optionally to files
        //
        if ( (pCtxt->fApplyToSubContainers || pCtxt->fApplyToDirContents)
             && !pCtxt->fIsSelFile )
        {
            UpdateStatus( pCtxt->nlsSelItem ) ;

            //
            //  Determine whether we should apply permissions to both
            //  directories and files, directories only or files only
            //
            enum FILE_TYPE filetype ;
            switch ((pCtxt->fApplyToSubContainers << 1) + pCtxt->fApplyToDirContents )
            {
            case 3:
                filetype = FILTYP_ALL_FILES ;
                break ;

            case 2:
                filetype = FILTYP_DIRS ;
                break ;

            case 1:
                filetype = FILTYP_FILES ;
                break ;

            default:
                UIASSERT( FALSE ) ;
            }

            pCtxt->pfsenum = new W32_FS_ENUM( pCtxt->nlsSelItem,
                                              SZ("*.*"),
                                              filetype,
                                              pCtxt->fDepthFirstTraversal,
                                              pCtxt->fApplyToSubContainers ?
                                                      0xffffffff : 0 ) ;
            err = ERROR_NOT_ENOUGH_MEMORY ;
            if ( pCtxt == NULL ||
                 (err = pCtxt->pfsenum->QueryError() ))
            {
                break ;
            }
            //
            //  Next time around, start doing the enumeration
            //
            pCtxt->State = APPLY_SEC_IN_FS_ENUM ;
        }
        break ;
    }

    if ( err && *pCtxt->StatusReturn == 0 )
    {
        *pCtxt->StatusReturn = (pCtxt->iCurrent-1 ? SED_STATUS_NOT_ALL_MODIFIED :
                                SED_STATUS_FAILED_TO_MODIFY);
    }

    return err ;
}

/*******************************************************************

    NAME:       NTFS_CANCEL_TREE_APPLY::WriteSecurity

    SYNOPSIS:   Write security to an NTFS volume

    ENTRY:      ulContext - Pointer to NTFS_TREE_APPLY_CONTEXT
                pszFileName - File to apply to
                fIsFile - TRUE if object, FALSE if container
                pfContinue - Set to FALSE if the apply should be
                    terminated.

    RETURNS:    NERR_Success if successful, error code otherwise

    HISTORY:
        Johnl   23-Oct-1992     Created

********************************************************************/

APIERR NTFS_CANCEL_TREE_APPLY::WriteSecurity( ULONG_PTR     ulContext,
                                              const TCHAR * pszFileName,
                                              BOOL          fIsFile,
                                              BOOL        * pfContinue )
{
    APIERR err = NERR_Success ;
    NTFS_TREE_APPLY_CONTEXT * pCtxt = (NTFS_TREE_APPLY_CONTEXT*) ulContext ;
    SECURITY_INFORMATION SecInfoTmp = (SECURITY_INFORMATION) pCtxt->osSecInfo ;
    *pfContinue = TRUE ;

    //
    //  If any of the "container" flags are set and we are looking at a
    //  file, then use the object security descriptor, else use the container
    //  /object security descriptor.
    //
    PSECURITY_DESCRIPTOR psecdescTmp =  fIsFile &&
                                       (pCtxt->fApplyToSubContainers ||
                                        pCtxt->fApplyToSubObjects    ||
                                        pCtxt->fApplyToDirContents) ?
                                          pCtxt->psecdescNewObjects :
                                          pCtxt->psecdesc ;

    //
    //  Taking ownership also optionally blows away the DACL at the user's
    //  request
    //
    if ( !fIsFile && (pCtxt->sedpermtype == SED_OWNER) )
    {
        OS_ACL osDACL ;
        OS_ACE osACE ;
        OS_SID ossidUser ;
        OS_SECURITY_DESCRIPTOR ossecdesc( psecdescTmp, TRUE ) ;

        if ( (err = osDACL.QueryError())    ||
             (err = osACE.QueryError())     ||
             (err = ossidUser.QueryError()) ||
             (err = ossecdesc.QueryError()) ||
             (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CurrentProcessOwner,
                                                         &ossidUser )) )
        {
            // Fall through
        }

        if ( !err )
        {
            //
            //  Put an ACE that grants full control and that will be
            //  inherited to new objects and new containers on this
            //  container.  The SID is the currently logged on user.
            //
            osACE.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;
            osACE.SetInheritFlags( OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ) ;
            osACE.SetAccessMask( GENERIC_ALL ) ;

            if ( (err = osACE.SetSID( ossidUser )) ||
                 (err = osDACL.AddACE( 0, osACE )) ||
                 (err = ossecdesc.SetDACL( TRUE, &osDACL )) )
            {
                // Fall through
            }
        }

        if ( !err)
        {
            OS_SECURITY_DESCRIPTOR osSecAdmin;
            OS_SID ossidAdmins;
            NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Admins,
                                                 &ossidAdmins );
            osSecAdmin.SetOwner(ossidAdmins);
            osSecAdmin.SetGroup(ossidAdmins);
            osSecAdmin.SetDACL( TRUE, &osDACL );
            // Try Admins Group First
            if ( !::SetFileSecurity( (LPTSTR) pszFileName,
                                              SecInfoTmp,
                                              osSecAdmin.QueryDescriptor() ) )
            {
                // if it fails try owner account
                if (!::SetFileSecurity( (LPTSTR) pszFileName,  // Take ownership
                                      SecInfoTmp,
                                      ossecdesc ))
                {
                    err = ::GetLastError() ;
                }
            }
        }
        //
        //  Now check if they have traversal permission.  If they do, then
        //  leave the ACL alone, else ask them if they want to blow away the
        //  DACL
        //
        BOOL fCanTraverse ;
        if ( !err &&
             !(err = ::CheckFileSecurity( (LPTSTR) pszFileName,
                                           FILE_TRAVERSE | FILE_LIST_DIRECTORY,
                                           &fCanTraverse )) &&
             !fCanTraverse )
        {
            switch ( ::MsgPopup( this,
                                 IDS_OWNER_NUKE_DACL_WARNING,
                                 MPSEV_INFO,
                                 MP_YES| MP_CANCEL,
                                 pszFileName ))
            {
            case IDYES:


                if ( !::SetFileSecurity( (LPTSTR) pszFileName,  // Blow away DACL
                                         DACL_SECURITY_INFORMATION,
                                         ossecdesc ))
                {
                    err = ::GetLastError() ;
                }
                break ;

            default:
            case IDNO:
            case IDCANCEL:
                *pfContinue = FALSE ;
                break ;
            }
        }
    }
    else    // if ( !fIsFile && (pCtxt->sedpermtype == SED_OWNER) )
    {
        if ((pCtxt->sedpermtype == SED_OWNER))
        {
            OS_SECURITY_DESCRIPTOR osSecAdmin;
            OS_SID ossidAdmins;
            NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Admins,
                                                 &ossidAdmins );
            osSecAdmin.SetOwner(ossidAdmins);
            osSecAdmin.SetGroup(ossidAdmins);

            // Try Admins Group First
            if ( !::SetFileSecurity( (LPTSTR) pszFileName,
                                          SecInfoTmp,
                                          osSecAdmin.QueryDescriptor() ) )
            {
                // if it fails try owner account
                if ( !::SetFileSecurity( (LPTSTR) pszFileName,
                                      SecInfoTmp,
                                      psecdescTmp ))
                {
                    err = ::GetLastError() ;
                }
            }
        }
        else if ( !::SetFileSecurity( (LPTSTR) pszFileName,
                                      SecInfoTmp,
                                      psecdescTmp ))
            {
                err = ::GetLastError() ;
            }
    }
    return err ;
}

/*******************************************************************

    NAME:       CompareNTFSSecurityIntersection

    SYNOPSIS:   Determines if the files/dirs currently selected have
                equivalent security descriptors

    ENTRY:      hwndFMX - FMX Hwnd used for getting selection
                sedpermtype - Interested in DACL or SACL
                psecdesc - Baseline security descriptor to compare against
                pfOwnerEqual - Set to TRUE if all the owners are equal
                pfACLEqual - Set to TRUE if all of the DACLs/SACLs are
                    equal.  If FALSE, then pfOwnerEqual should be ignored

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The first non-equal ACL causes the function to exit.

                On a 20e with 499 files selected locally, it took 35.2 minutes
                to read the security descriptors from the disk and 14 seconds
                to determine the intersection.  So even though the Compare
                method uses an n^2 algorithm, it only takes up 0.6% of the
                wait time.

    HISTORY:
        Johnl   05-Nov-1992      Created

********************************************************************/

APIERR CompareNTFSSecurityIntersection( HWND hwndFMX,
                                        enum SED_PERM_TYPE sedpermtype,
                                        PSECURITY_DESCRIPTOR psecdesc,
                                        BOOL * pfOwnerEqual,
                                        BOOL * pfACLEqual,
                                        NLS_STR *        pnlsFailingFile,
                                        PGENERIC_MAPPING pGenericMapping,
                                        PGENERIC_MAPPING pGenericMappingObjects,
                                        BOOL             fMapGenAll,
                                        BOOL             fIsContainer )
{
    TRACEEOL("::CompareNTFSSecurityIntersection - Entered @ " << ::GetTickCount()/100) ;

    FMX fmx( hwndFMX );
    UIASSERT( fmx.QuerySelCount() > 1 ) ;
    APIERR err ;
    OS_SECURITY_DESCRIPTOR ossecdesc1( psecdesc ) ;
    UINT cSel = fmx.QuerySelCount() ;

    NLS_STR nlsSel( PATHLEN ) ;
    BUFFER  buffSecDescData( 1024 ) ;
    if ( (err = nlsSel.QueryError()) ||
         (err = buffSecDescData.QueryError()) )
    {
        return err ;
    }

    *pfOwnerEqual = TRUE ;
    *pfACLEqual = TRUE ;

    for ( UINT i = 1 ; i < cSel ; i++ )
    {
        if ( (err = ::GetSelItem( hwndFMX, i, &nlsSel, NULL )) ||
             (err = ::GetSecurity( nlsSel,
                                   &buffSecDescData,
                                   sedpermtype,
                                   NULL )) )
        {
            break ;
        }

        BOOL fACLEqual = FALSE ;
        BOOL fOwnerEqual = FALSE ;
        PSECURITY_DESCRIPTOR psecdesc2 = (PSECURITY_DESCRIPTOR)
                                                  buffSecDescData.QueryPtr() ;

        OS_SECURITY_DESCRIPTOR ossecdesc2( psecdesc2 ) ;
        if ( (err = ossecdesc2.QueryError()) ||
             (err = ossecdesc1.Compare( &ossecdesc2,
                                        &fOwnerEqual,
                                         NULL,
                                        sedpermtype == SED_ACCESSES ?
                                                &fACLEqual : NULL,
                                        sedpermtype == SED_AUDITS   ?
                                                &fACLEqual : NULL ,
                                        pGenericMapping,
                                        pGenericMappingObjects,
                                        fMapGenAll,
                                        fIsContainer )) )

        {
            break ;
        }

        if ( !fACLEqual )
        {
            *pfACLEqual = FALSE ;
            return pnlsFailingFile->CopyFrom( nlsSel ) ;
        }

        if ( *pfOwnerEqual && !fOwnerEqual )
        {
            *pfOwnerEqual = FALSE ;
        }
    }

    //
    //  Some errors aren't fatal (like ERROR_ACCESS_DENIED)
    //
    APIERR errtmp = pnlsFailingFile->CopyFrom( nlsSel ) ;
    if ( errtmp )
        err = errtmp ;

    TRACEEOL("::CompareNTFSSecurityIntersection - Left    @ " << ::GetTickCount()/100) ;
    return err ;
}



/*******************************************************************

    NAME:       EditOwnerInfo

    SYNOPSIS:   This function sets up the parameters for calling the
                SedTakeOwnership API.

    ENTRY:      hwndFMXWindow - Window handle received by the File manager
                extensions.

    NOTES:

    HISTORY:
        Johnl   13-Feb-1992     Implemented with real code

********************************************************************/

void EditOwnerInfo( HWND  hwndFMXWindow )
{
    AUTO_CURSOR cursorHourGlass ;

    APIERR err = NERR_Success;
    BOOL   fIsFile ;
    BOOL   fCantRead  = FALSE ;                   // Did we read the Owner?
    BOOL   fCantWrite = FALSE ;                   // Can we write the owner?
    UINT   uiCount ;
    NLS_STR nlsSelItem;


    PSECURITY_DESCRIPTOR psecdesc = NULL ;
    BUFFER buffSecDescData( 1024 ) ;
    RESOURCE_STR nlsHelpFileName( IDS_FILE_PERM_HELP_FILE ) ;

    if (  ( err = buffSecDescData.QueryError() )
       || ( err = nlsHelpFileName.QueryError() )
       )
    {
        ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
        return ;
    }

    FMX fmx( hwndFMXWindow );

    /* If the focus is in tree portion of the filemanager (left pane) then
     * one directory is selected.
     */
    uiCount = (fmx.QueryFocus() == FMFOCUS_TREE ? 1 : fmx.QuerySelCount()) ;
    DBGEOL( SZ("::EditOwnerInfo - ") << uiCount << SZ(" files selected")) ;

    BOOL fIsNTFS ;
    BOOL fIsLocal ;
    NLS_STR  nlsServer( RMLEN ) ;
    if ( (err = ::GetSelItem( hwndFMXWindow, 0, &nlsSelItem, &fIsFile )) ||
         (err = ::IsNTFS( nlsSelItem, &fIsNTFS ))                        ||
         (err = nlsServer.QueryError()))
    {
        ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
        return ;
    }

    err = ::TargetServerFromDosPath( nlsSelItem,
                                     &fIsLocal,
                                     &nlsServer );

    if ( err == NERR_InvalidDevice )
    {
        NLS_STR nlsDrive( nlsSelItem );
        ISTR istr( nlsDrive );

        err = nlsDrive.QueryError();
        if ( err == NERR_Success )
        {
            istr += 2;
            nlsDrive.DelSubStr( istr );

            err = WNetFMXEditPerm( (LPWSTR) nlsDrive.QueryPch(),
                                   hwndFMXWindow,
                                   WNPERM_DLG_OWNER );
        }
    }

    if ( err != NERR_Success )
    {
        ::MsgPopup( hwndFMXWindow, (MSGID) err );
        return;
    }

    if ( !fIsNTFS )
    {
        ::MsgPopup( hwndFMXWindow, (MSGID) IERR_OWNER_NOT_NTFS_VOLUME ) ;
        return ;
    }

    /* We display the filename and get the security descriptor
     * if there is only 1 item selected
     */
    if ( uiCount == 1)
    {
        switch ( err = ::GetSecurity( nlsSelItem,
                                          &buffSecDescData,
                                          SED_OWNER,
                                          NULL ) )
        {
        case NO_ERROR:
            psecdesc = (PSECURITY_DESCRIPTOR) buffSecDescData.QueryPtr() ;
            break ;

        case ERROR_ACCESS_DENIED:
            err = NERR_Success ;
            fCantRead = TRUE ;
            psecdesc  = NULL ;
            break ;

        default:
            {
                ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
                return ;
            }
        }

    }

    MSGID  msgidObjType = 0, msgidObjName = 0 ;
    if ( uiCount > 1 )
    {
        msgidObjType = IDS_FILES_AND_DIRS ;
    }
    else
    {
        if ( fIsFile )
            msgidObjType = IDS_FILE ;
        else
            msgidObjType = IDS_DIRECTORY ;

        BOOL fPrivAdjusted = FALSE;
        ULONG ulOwnerPriv  = SE_TAKE_OWNERSHIP_PRIVILEGE ;

        if ( (err = ::NetpGetPrivilege( 1, &ulOwnerPriv )) &&
             (err != ERROR_PRIVILEGE_NOT_HELD) )
        {
            ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
            return ;
        }
        else
        {
            BOOL fCanWrite ;
            if ( err = ::CheckFileSecurity( nlsSelItem,
                                            WRITE_OWNER,
                                            &fCanWrite ))
            {
                ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
                ::NetpReleasePrivilege() ;
                return ;
            }

            fCantWrite = !fCanWrite ;
            ::NetpReleasePrivilege() ;
        }
    }

    RESOURCE_STR nlsTypeName( msgidObjType ) ;
    if ( (err = nlsSelItem.QueryError() ) ||
         (err = nlsTypeName.QueryError())   )
    {
        ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
        return ;
    }

    NTFS_CALLBACK_INFO callbackinfo ;
    callbackinfo.hwndFMXOwner = hwndFMXWindow ;
    callbackinfo.sedpermtype= SED_OWNER ;

    DWORD dwSedStatus ;

    SED_HELP_INFO sedhelpinfo ;
    sedhelpinfo.pszHelpFileName = (LPWSTR) nlsHelpFileName.QueryPch() ;
    sedhelpinfo.aulHelpContext[HC_MAIN_DLG] = HC_TAKEOWNERSHIP_DIALOG ;

    err = SedTakeOwnership(  hwndFMXWindow,
                             ::hModule,
                             fIsLocal ? NULL : (LPTSTR) nlsServer.QueryPch(),
                             (LPTSTR) nlsTypeName.QueryPch(),
                             uiCount==1 ? (LPTSTR)nlsSelItem.QueryPch() : NULL,
                             uiCount,
                             SedCallback,
                             (ULONG_PTR) &callbackinfo,
                             psecdesc,
                             (BOOLEAN)fCantRead,
                             (BOOLEAN)fCantWrite,
                             &dwSedStatus,
                             &sedhelpinfo,
                             0
                             ) ;
}

/*******************************************************************

    NAME:       ::GetSecurity

    SYNOPSIS:   Retrieves a security descriptor from an NTFS file/directory

    ENTRY:      pszFileName - Name of file/dir to get security desc. for
                pbuffSecDescData - Buffer to store the data into
                sedpermtype - Are we getting audit/access info
                pfAuditPrivAdjusted - Set to TRUE if audit priv was enabled.
                    Set this to NULL if the privilege has already been adjusted

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   05-Nov-1992     Broke out

********************************************************************/

APIERR GetSecurity( const TCHAR *      pszFileName,
                        BUFFER *           pbuffSecDescData,
                        enum SED_PERM_TYPE sedpermtype,
                        BOOL  *            pfAuditPrivAdjusted )
{
    OS_SECURITY_INFORMATION osSecInfo ;
    DWORD dwLengthNeeded ;
    APIERR err = NERR_Success ;

    if ( pfAuditPrivAdjusted )
        *pfAuditPrivAdjusted = FALSE ;

    do { // error breakout
        if ( (err = pbuffSecDescData->QueryError()) )
        {
            break ;
        }

        switch ( sedpermtype )
        {
        case SED_ACCESSES:
            osSecInfo.SetDACLReference() ;
            //
            //  Fall through, we want the owner and group if we are getting
            //  the DACL
            //

        case SED_OWNER:
            osSecInfo.SetOwnerReference() ;
            osSecInfo.SetGroupReference() ;
            break ;

        case SED_AUDITS:
            osSecInfo.SetSACLReference() ;

            if ( pfAuditPrivAdjusted != NULL )
            {
                /* We will need to enable the SeAuditPrivilege to read/write the
                 * SACL for NT.
                 */
                ULONG ulAuditPriv = SE_SECURITY_PRIVILEGE ;
                if ( err = ::NetpGetPrivilege( 1, &ulAuditPriv ))
                {
                    break ;
                }
                *pfAuditPrivAdjusted = TRUE ;
            }
            break ;

        default:
            UIASSERT(FALSE) ;
            err = ERROR_GEN_FAILURE ;
            break ;
        }
        if ( err )
            break ;

        //
        //  Try once with a 1k buffer, if it doesn't fit then we will try again
        //  with the known required size which should succeed unless another
        //  error occurs, in which case we bail.
        //
        BOOL  fCantRead = FALSE ;                   // Did we read the ACL?
        PSECURITY_DESCRIPTOR pSecurityDesc = NULL ;
        if (!::GetFileSecurity( (LPTSTR) pszFileName,
                                osSecInfo,
                                (PSECURITY_DESCRIPTOR)pbuffSecDescData->QueryPtr(),
                                pbuffSecDescData->QuerySize(),
                                &dwLengthNeeded ))
        {
            err = ::GetLastError() ;
            switch ( err )
            {
            case ERROR_INSUFFICIENT_BUFFER:
                {
                    err = pbuffSecDescData->Resize( (UINT) dwLengthNeeded ) ;
                    if ( err )
                        break ;

                    /* If this guy fails then we bail
                     */
                    if (!::GetFileSecurity( (LPTSTR) pszFileName,
                                            osSecInfo,
                                            (PSECURITY_DESCRIPTOR)pbuffSecDescData->QueryPtr(),
                                            pbuffSecDescData->QuerySize(),
                                            &dwLengthNeeded ))
                    {
                        err = ::GetLastError() ;
                        break ;
                    }
                }
                break ;

            default:
                /* Fall through to the next switch statement which is the error
                 * handler for this block
                 */
                break ;
            }
        }
    } while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       InitializeNTFSGenericMapping

    SYNOPSIS:   Initializes the passed generic mapping structure
                appropriately depending on whether this is a file
                or a directory.

    ENTRY:      pNTFSGenericMapping - Pointer to GENERIC_MAPPING to be init.
                fIsDirectory - TRUE if directory, FALSE if file

    EXIT:

    RETURNS:

    NOTES:      Note that Delete Child was removed from Generic Write.

    HISTORY:
        Johnl   27-Feb-1992     Created

********************************************************************/

void InitializeNTFSGenericMapping( PGENERIC_MAPPING pNTFSGenericMapping,
                                   BOOL fIsDirectory )
{
    UNREFERENCED( fIsDirectory ) ;
    pNTFSGenericMapping->GenericRead    = FILE_GENERIC_READ ;
    pNTFSGenericMapping->GenericWrite   = FILE_GENERIC_WRITE ;
    pNTFSGenericMapping->GenericExecute = FILE_GENERIC_EXECUTE ;
    pNTFSGenericMapping->GenericAll     = FILE_ALL_ACCESS ;

}


/*******************************************************************

    NAME:       ::IsNTFS

    SYNOPSIS:   This function checks the given resource and attempts to
                determine if it points to an NTFS partition.

    ENTRY:      pszResource - Pointer to file/directory name (may be UNC)

                pfIsNTFS - Pointer to BOOL that will receive the results

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   08-May-1992     Created

********************************************************************/

APIERR IsNTFS( const TCHAR * pszResource, BOOL * pfIsNTFS )
{
    UIASSERT( pszResource != NULL && pfIsNTFS != NULL ) ;

    *pfIsNTFS = FALSE ;
    APIERR err    = NERR_Success ;
    DWORD dwAttributes;
    TCHAR szResourceTemp[2 * MAX_PATH]; // Allow for long computer and share names

    do { // error breakout
        lstrcpyn( szResourceTemp, pszResource, sizeof(szResourceTemp) / sizeof(TCHAR) );

        // Strip the path to root form, acceptable to GetVolumeInformation
        if ((szResourceTemp[0] == TEXT('\\')) && (szResourceTemp[1] == TEXT('\\')))
        {
            // It's a UNC path.  Find the fourth backslash (if there is
            // one) and truncate after that character
            int     cBackslashes = 2;
            TCHAR*  pChar = &(szResourceTemp[2]);

            while ((*pChar) && (cBackslashes < 4))
            {
                if (*pChar == TEXT('\\'))
                {
                    cBackslashes++;
                }

                pChar = CharNext(pChar);
            }

            if (*pChar)
            {
                *pChar = TEXT('\0');
            }
            else
            {
                // A bogus path was passed in
                err = ERROR_FILE_NOT_FOUND;
                break;
            }
        }
        else
        {
            // It's a drive-based path.  Truncate after the first three
            // characters ("x:\")
            szResourceTemp[3] = TEXT('\0');
        }

        if ( FALSE == GetVolumeInformation( szResourceTemp,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &dwAttributes,
                                            NULL,
                                            NULL))
        {
            // If we failed because we were denied access, then
            // we can probably assume the filesystem supports ACLs
            if ( GetLastError() == ERROR_ACCESS_DENIED )
            {
                DBGEOL("::IsNTFS - Unable to determine volume information "
                        << " (access denied) assuming the file system is NTFS") ;
                *pfIsNTFS = TRUE;
                break;
            }

            // Otherwise, set an error code and break out
            err = GetLastError();
            DBGEOL("::IsNTFS - GetVolumeInformation failed with error "
                     << (ULONG) err ) ;
            break;
        }

        TRACEEOL("::IsNTFS - File system attributes are " << (HEX_STR) dwAttributes ) ;

        if ( dwAttributes & FS_PERSISTENT_ACLS )
        {
            *pfIsNTFS = TRUE;
        }

    } while ( FALSE );

    return err ;
}

/*******************************************************************

    NAME:       CheckFileSecurity

    SYNOPSIS:   Checks to see if the current user has access to the file or
                directory

    ENTRY:      pszFileName - File or directory name
                DesiredAccess - Access to check for
                pfAccessGranted - Set to TRUE if access was granted

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      If the check requires enabled privileges, they must be enabled
                before this call.

    HISTORY:
        Johnl   15-Jan-1993     Created

********************************************************************/

APIERR CheckFileSecurity( const TCHAR * pszFileName,
                          ACCESS_MASK   DesiredAccess,
                          BOOL        * pfAccessGranted )
{
    APIERR err = NERR_Success ;
    *pfAccessGranted = TRUE ;

    do { // error breakout

        //
        // Convert the DOS device name ("X:\") to an NT device name
        // (looks something like "\dosdevices\X:\")
        //
        int cbFileName = strlenf( pszFileName ) * sizeof( TCHAR ) ;
        UNICODE_STRING  UniStrNtFileName ;
        ::memsetf( (PVOID)&UniStrNtFileName, '\0', sizeof(UniStrNtFileName) );

        if (!RtlDosPathNameToNtPathName_U( pszFileName,
                                           &UniStrNtFileName,
                                           NULL,
                                           NULL))
        {
            UIASSERT( FALSE ) ;
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        OBJECT_ATTRIBUTES           oa ;
        IO_STATUS_BLOCK             StatusBlock ;
        InitializeObjectAttributes( &oa,
                                    &UniStrNtFileName,
                                    OBJ_CASE_INSENSITIVE,
                                    0,
                                    0 );


        //
        //  Check to see if we have permission/privilege to read the security
        //
        HANDLE hFile ;
        if ( (err = ERRMAP::MapNTStatus(::NtOpenFile(
                               &hFile,
                               DesiredAccess,
                               &oa,
                               &StatusBlock,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               0 ))) )
        {

            TRACEEOL("CheckFileSecurity - check failed with error " << err <<
                     " with desired access " << (HEX_STR) DesiredAccess ) ;

            if ( err == ERROR_ACCESS_DENIED )
            {
                *pfAccessGranted = FALSE ;
                err = NERR_Success ;
            }
        }
        else
            ::NtClose( hFile ) ;

        if (UniStrNtFileName.Buffer != 0)
            RtlFreeUnicodeString( &UniStrNtFileName );

    } while ( FALSE ) ;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\perm.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    perm.cxx

    This file contains the implementation for the PERMISSION class and
    the derived classes.



    FILE HISTORY:
	Johnl	05-Aug-1991	Created

*/
#include <ntincl.hxx>

#define INCL_DOSERRORS
#define INCL_NETERRORS
#include <lmui.hxx>
#include <base.hxx>
#include <bitfield.hxx>
#include <accperm.hxx>


#include <uiassert.hxx>
#include <uitrace.hxx>

#include <perm.hxx>

/*******************************************************************

    NAME:	PERMISSION::PERMISSION

    SYNOPSIS:	Constructor for PERMISSION class

    ENTRY:	psubject - Client allocated SUBJECT object (we will free)
		bitsInitPerm - Initial bitflags

    EXIT:

    RETURNS:

    NOTES:	psubject will be freed on destruction by this class using
		delete.

		pbitsInitPerm cannot be NULL.

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/


PERMISSION::PERMISSION(  SUBJECT  * psubject,
                         BITFIELD * pbitsInitPerm,
                         BOOL       fContainerPermsInheritted,
                         BOOL       fIsMapped )
    : _psubject                 ( psubject ),
      _bitsPermFlags            ( *pbitsInitPerm ),
      _fContainerPermsInheritted( fContainerPermsInheritted ),
      _fIsMapped                ( fIsMapped ),
      _bitsSpecialFlags         ( *pbitsInitPerm ),
      _fSpecialContInheritted   ( fContainerPermsInheritted ),
      _fSpecialIsMapped         ( fIsMapped )
{

    APIERR err ;
    if ( ((err = _psubject->QueryError()) != NERR_Success) ||
	 ((err = _bitsPermFlags.QueryError() != NERR_Success )) ||
	 ((err = _bitsSpecialFlags.QueryError() != NERR_Success ))   )
    {
	ReportError( err ) ;
	return ;
    }

}

/*******************************************************************

    NAME:	PERMISSION::~PERMISSION

    SYNOPSIS:	Typical destructor

    NOTES:	Deletes the subject when destructed

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

PERMISSION::~PERMISSION()
{
    delete _psubject ;
    _psubject = NULL ;
}

BITFIELD * PERMISSION::QueryPermBits( void )
{
    return &_bitsPermFlags ;
}

/*******************************************************************

    NAME:	PERMISSION::SetPermission

    SYNOPSIS:	Given the mask map and permission name, set the permission
		bits appropriately

    ENTRY:	nlsPermName - Name to set permission to (looked up in
		     mask maps)
		pmapThis - Mask map object that tells us how to interpret
		     the permission name
		pmapNewObj - Not used here, will be used by NT derived
		     permissions

    EXIT:	The permission bits of this permission will be set if
		a match is found, else the special bits will be restored
		if no permission name in the mask map matches the passed
		permission name.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

APIERR PERMISSION::SetPermission( const NLS_STR & nlsPermName,
				  MASK_MAP * pmapThis,
				  MASK_MAP * pmapNewObj )
{
    UNREFERENCED( pmapNewObj ) ;
    ASSERT( pmapThis != NULL ) ;

    /* Lookup the bits associated with the new permission name
     */
    APIERR err = pmapThis->StringToBits( nlsPermName,
					 QueryPermBits(),
					 PERMTYPE_GENERAL ) ;

    /* The preceding call should always succeed, unless this is a special
     * permission.
     */
    switch ( err )
    {
    case ERROR_NO_ITEMS:
       err = RestoreSpecial() ;
       break ;

    case NERR_Success:
        SetMappedStatus( TRUE ) ;
        SetContainerPermsInheritted( TRUE ) ;
	break ;
    }

    return err ;
}

/*******************************************************************

    NAME:	PERMISSION::SaveSpecial

    SYNOPSIS:	Store away the current bitfields so they can be restored
		at some later time.

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	25-Sep-1991	Created

********************************************************************/

APIERR PERMISSION::SaveSpecial( void )
{
    APIERR err = _bitsSpecialFlags.Resize( _bitsPermFlags.QueryCount() ) ;
    if ( err != NERR_Success )
	return err ;

    _fSpecialContInheritted = _fContainerPermsInheritted ;
    _fSpecialIsMapped       = _fIsMapped ;
    _bitsSpecialFlags       = _bitsPermFlags ;
    UIASSERT( _bitsSpecialFlags.QueryError() == NERR_Success ) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	PERMISSION::RestoreSpecial

    SYNOPSIS:	Restores the bits that were saved as special bits

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	25-Sep-1991	Created

********************************************************************/

APIERR PERMISSION::RestoreSpecial( void )
{
    APIERR err = _bitsPermFlags.Resize( _bitsSpecialFlags.QueryCount() ) ;
    if ( err != NERR_Success )
	return err ;

    _bitsPermFlags             = _bitsSpecialFlags ;
    _fContainerPermsInheritted = _fSpecialContInheritted ;
    _fIsMapped                 = _fSpecialIsMapped ;
    UIASSERT( _bitsPermFlags.QueryError() == NERR_Success ) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	PERMISSION::IsNewObjectPermsSupported

    SYNOPSIS:	Defaults for several query functions

    NOTES:	These are all virtual.

    HISTORY:
	Johnl	14-May-1992	Created

********************************************************************/

BOOL PERMISSION::IsNewObjectPermsSupported( void ) const
{
    return FALSE ;
}

BITFIELD * PERMISSION::QueryNewObjectAccessBits( void )
{
    return NULL ;
}

BOOL PERMISSION::IsNewObjectPermsSpecified( void ) const
{
    return FALSE ;
}

/*******************************************************************

    NAME:	ACCESS_PERMISSION::ACCESS_PERMISSION

    SYNOPSIS:	Constructor for Access permission

    ENTRY:	Same as parent

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

ACCESS_PERMISSION::ACCESS_PERMISSION(  SUBJECT  * psubject,
                                       BITFIELD * pbitsInitPerm,
                                       BOOL       fContainerPermsInheritted,
                                       BOOL       fIsMapped )
    : PERMISSION( psubject, pbitsInitPerm, fContainerPermsInheritted, fIsMapped )
{
    if ( QueryError() != NERR_Success )
	return ;
}

ACCESS_PERMISSION::~ACCESS_PERMISSION()
{
    /*Nothing to do*/
}

BITFIELD * ACCESS_PERMISSION::QueryAccessBits( void )
{
    return ((ACCESS_PERMISSION *) this)->QueryPermBits() ;
}

/*******************************************************************

    NAME:	ACCESS_PERMISSION::IsGrantAll
		ACCESS_PERMISSION::IsDenyAll

    SYNOPSIS:	Returns TRUE if the passed access permission is a grant all or
		deny all (respectively).

    ENTRY:	bitsPermMask - Bitfield containing the access mask to check

    NOTES:	This is assumed to be an NT style permission

    HISTORY:
	Johnl	16-May-1992	Created

********************************************************************/

BOOL ACCESS_PERMISSION::IsGrantAll( const BITFIELD & bitsPermMask ) const
{
    /* Cast away the warning about operator::ULONG being a non-const
     * member - this should be fixed in the bitfield class
     */
    return (GENERIC_ALL & (ULONG) ((BITFIELD &) bitsPermMask )) ;
}

BOOL ACCESS_PERMISSION::IsDenyAll( const BITFIELD & bitsPermMask ) const
{
    return ( 0 == (ULONG) ((BITFIELD &)bitsPermMask )) ;
}


APIERR ACCESS_PERMISSION::IsDenyAllForEveryone( BOOL * pfDenyAll ) const
{
    APIERR err ;
    if ( err = QuerySubject()->IsEveryoneGroup( pfDenyAll ) )
	return err ;

    BITFIELD * pbf = (BITFIELD *) ((ACCESS_PERMISSION *) this)->QueryAccessBits() ;

    *pfDenyAll = *pfDenyAll && (0 == (ULONG) *pbf) ;
    return NERR_Success ;
}

BOOL ACCESS_PERMISSION::IsGrant( void ) const
{
    BITFIELD * pbf = (BITFIELD *) ((ACCESS_PERMISSION *) this)->QueryAccessBits() ;
    return 0 != (ULONG) *pbf ;
}

/*******************************************************************

    NAME:	LM_ACCESS_PERMISSION::LM_ACCESS_PERMISSION

    SYNOPSIS:	Constructor for Access permission

    ENTRY:	Same as parent
		fIsFile - Is this permission for a file?

    NOTES:

    HISTORY:
	Johnl	26-May-1992	Created

********************************************************************/

LM_ACCESS_PERMISSION::LM_ACCESS_PERMISSION( SUBJECT  * psubject,
					    BITFIELD * pbitsInitPerm,
					    BOOL       fIsFile )
    : ACCESS_PERMISSION( psubject, pbitsInitPerm, TRUE ),
      _fIsFile	       ( fIsFile )
{
    if ( QueryError() != NERR_Success )
	return ;

    /* Strip the Create bit if this is for a file
     */
    if ( fIsFile )
    {
	*QueryPermBits() &= (USHORT) ~ACCESS_CREATE ;
    }
}

LM_ACCESS_PERMISSION::~LM_ACCESS_PERMISSION()
{
    /*Nothing to do*/
}

/*******************************************************************

    NAME:	LM_ACCESS_PERMISSION::IsGrantAll
		LM_ACCESS_PERMISSION::IsDenyAll

    SYNOPSIS:	Returns TRUE if the passed access permission is a grant all or
		deny all (respectively).

    ENTRY:	bitfield - Bitfield containing the access mask to check

    NOTES:	This is assumed to be a LAN Manager style permission

    HISTORY:
	Johnl	26-May-1992	Created

********************************************************************/

BOOL LM_ACCESS_PERMISSION::IsGrantAll( const BITFIELD & bitsPermMask ) const
{
    return (!_fIsFile) ?
	   ( ACCESS_ALL == (USHORT) ((BITFIELD &)bitsPermMask)) :
	   ( (ACCESS_ALL & ~ACCESS_CREATE) ==
				 ((USHORT) ((BITFIELD &)bitsPermMask))) ;
}

BOOL LM_ACCESS_PERMISSION::IsDenyAll( const BITFIELD & bitsPermMask ) const
{
    return ( 0 == (USHORT) ((BITFIELD &)bitsPermMask )) ;
}

APIERR LM_ACCESS_PERMISSION::IsDenyAllForEveryone( BOOL * pfDenyAll ) const
{
    //
    //	You can't deny everyone under LM
    //
    *pfDenyAll = FALSE ;
    return NERR_Success ;
}

BOOL LM_ACCESS_PERMISSION::IsGrant( void ) const
{
    //
    // Everything is grant under LM
    //
    return TRUE ;
}

/*******************************************************************

    NAME:	AUDIT_PERMISSION::AUDIT_PERMISSION

    SYNOPSIS:	Audit permission constructor

    ENTRY:	Same as parent except bitsFailFlags indicate the failed
		audit bits

    NOTES:	pbitsFailFlags cannot be NULL.

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

AUDIT_PERMISSION::AUDIT_PERMISSION(   SUBJECT  * psubject,
				      BITFIELD * pbitsSuccessFlags,
                                      BITFIELD * pbitsFailFlags,
                                      BOOL       fPermsInherited,
                                      BOOL       fIsMapped )
    : PERMISSION( psubject, pbitsSuccessFlags, fPermsInherited, fIsMapped ),
      _bitsFailAuditFlags( *pbitsFailFlags )
{
    if ( QueryError() != NERR_Success )
	return ;

    APIERR err = _bitsFailAuditFlags.QueryError() ;
    if ( err != NERR_Success )
    {
	ReportError( err ) ;
	return ;
    }
}

AUDIT_PERMISSION::~AUDIT_PERMISSION()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERMISSION::NT_CONT_ACCESS_PERMISSION

    SYNOPSIS:	NT Container access permission object

    ENTRY:	Same as parent except pbitsInitNewObjectPerm are the access
		bits for newly created objects contained in this
		container

    NOTES:	pbitsInitNewObj maybe NULL, in which case the
		_fNewObjectPermsSpecified flag will be set to FALSE.

    HISTORY:
	Johnl	05-Aug-1991	Created
	Johnl	07-Jan-1992	Changed const & bit fields to pointers
				to allow for NULL parameters

********************************************************************/

NT_CONT_ACCESS_PERMISSION::NT_CONT_ACCESS_PERMISSION(
					    SUBJECT  * psubject,
					    BITFIELD * pbitsInitPerm,
					    BITFIELD * pbitsInitNewObjectPerm,
                                            BOOL       fIsInherittedByContainers,
                                            BOOL       fIsMapped )
    : ACCESS_PERMISSION         ( psubject,
                                  pbitsInitPerm,
                                  fIsInherittedByContainers,
                                  fIsMapped),
      _bitsNewObjectPerm	( (ULONG) 0 ),
      _fNewObjectPermsSpecified ( pbitsInitNewObjectPerm==NULL ? FALSE : TRUE ),
      _bitsSpecialNewFlags	( (ULONG) 0 ),
      _fSpecialNewPermsSpecified( _fNewObjectPermsSpecified )
{
    if ( QueryError() != NERR_Success )
	return ;

    APIERR err ;
    if ( (err = _bitsNewObjectPerm.QueryError())  ||
	 (err = _bitsSpecialNewFlags.QueryError())  )
    {
	ReportError( err ) ;
	return ;
    }

    if ( pbitsInitNewObjectPerm != NULL )
    {
	if ( (err = _bitsNewObjectPerm.Resize( pbitsInitNewObjectPerm->QueryCount())) ||
	     (err = _bitsSpecialNewFlags.Resize( pbitsInitNewObjectPerm->QueryCount())) )
	{
	    ReportError( err ) ;
	    return ;
	}

	/* These will always succeed
	 */
	_bitsNewObjectPerm = *pbitsInitNewObjectPerm ;
	_bitsSpecialNewFlags = *pbitsInitNewObjectPerm ;
    }
}

NT_CONT_ACCESS_PERMISSION::~NT_CONT_ACCESS_PERMISSION()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERMISSION::SetPermission

    SYNOPSIS:	Given the mask map and permission name, set the permission
		bits appropriately

    ENTRY:	nlsPermName - Name to set permission to (looked up in
		     mask maps)
		pmapThis - Mask map object that tells us how to interpret
		     the permission name
		pmapNewObj - Not used here, will be used by NT derived
		     permissions

    EXIT:	The permission bits of this permission will be set if
		a match is found, else the special bits will be restored
		if no permission name in the mask map matches the passed
		permission name.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_ACCESS_PERMISSION::SetPermission( const NLS_STR & nlsPermName,
				  MASK_MAP * pmapThis,
				  MASK_MAP * pmapNewObj )
{
    ASSERT( pmapNewObj != NULL ) ;

    /* Lookup the bits associated with the new permission name
     */
    APIERR err = pmapNewObj->StringToBits( nlsPermName,
					   QueryNewObjectAccessBits(),
					   PERMTYPE_GENERAL ) ;

    /* The preceding call should always succeed, unless this is a special
     * permission or the new object permissions are not specified.
     */
    switch ( err )
    {
    case ERROR_NO_ITEMS:
	SetNewObjectPermsSpecified( FALSE ) ;
	if (err = PERMISSION::SetPermission( nlsPermName, pmapThis, pmapNewObj))
	{
	    if ( err == ERROR_NO_ITEMS )
	    {
		err = RestoreSpecial() ;
	    }
	}
	else
	{
	    SetContainerPermsInheritted( TRUE ) ;
	}
	break ;

    case NERR_Success:
	SetNewObjectPermsSpecified( TRUE ) ;
	SetContainerPermsInheritted( TRUE ) ;
	err = PERMISSION::SetPermission( nlsPermName, pmapThis, pmapNewObj ) ;
	break ;
    }

    return err ;
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERMISSION::SaveSpecial

    SYNOPSIS:	Store away the current bitfields so they can be restored
		at some later time.

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	25-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_ACCESS_PERMISSION::SaveSpecial( void )
{
    APIERR err = _bitsSpecialNewFlags.Resize( _bitsNewObjectPerm.QueryCount() ) ;
    if ( err != NERR_Success )
	return err ;

    _fSpecialNewPermsSpecified = IsNewObjectPermsSpecified() ;
    _bitsSpecialNewFlags = _bitsNewObjectPerm ;
    UIASSERT( _bitsSpecialNewFlags.QueryError() == NERR_Success ) ;

    return ACCESS_PERMISSION::SaveSpecial() ;
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERMISSION::RestoreSpecial

    SYNOPSIS:	Restores the bits that were saved as special bits

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	25-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_ACCESS_PERMISSION::RestoreSpecial( void )
{
    APIERR err = _bitsNewObjectPerm.Resize( _bitsSpecialNewFlags.QueryCount() ) ;
    if ( err != NERR_Success )
	return err ;

    _bitsNewObjectPerm = _bitsSpecialNewFlags ;
    UIASSERT( _bitsNewObjectPerm.QueryError() == NERR_Success ) ;
    SetNewObjectPermsSpecified( _fSpecialNewPermsSpecified ) ;

    return ACCESS_PERMISSION::RestoreSpecial() ;
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERMISSION::IsNewObjectPermsSupported

    SYNOPSIS:	Defaults for several query functions

    NOTES:	These are all virtual.

    HISTORY:
	Johnl	14-May-1992	Created

********************************************************************/

BOOL NT_CONT_ACCESS_PERMISSION::IsNewObjectPermsSupported( void ) const
{
    return TRUE ;
}

BITFIELD * NT_CONT_ACCESS_PERMISSION::QueryNewObjectAccessBits( void )
{
    return &_bitsNewObjectPerm ;
}

BOOL NT_CONT_ACCESS_PERMISSION::IsNewObjectPermsSpecified( void ) const
{
    return _fNewObjectPermsSpecified ;
}

APIERR NT_CONT_ACCESS_PERMISSION::IsDenyAllForEveryone( BOOL * pfDenyAll ) const
{
    //
    //	If the container permissions are deny all and either the new object
    //	permissions aren't specified or they are specified and they are
    //	0, then return TRUE.
    //
    APIERR err = ACCESS_PERMISSION::IsDenyAllForEveryone( pfDenyAll ) ;
    BITFIELD * pbf = (BITFIELD *) ((NT_CONT_ACCESS_PERMISSION *) this)->QueryNewObjectAccessBits() ;

    if ( ! err && *pfDenyAll )
    {
	*pfDenyAll = (!IsNewObjectPermsSpecified()) ||
		     (0 == (ULONG) *pbf) ;
    }

    return err ;
}

BOOL NT_CONT_ACCESS_PERMISSION::IsGrant( void ) const
{
    BITFIELD * pbf = (BITFIELD *) ((NT_CONT_ACCESS_PERMISSION *) this)->QueryNewObjectAccessBits() ;

    return ACCESS_PERMISSION::IsGrant() ||
            (IsNewObjectPermsSpecified() && (0 != (ULONG) *pbf) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\permprg.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    permprg.cxx
    Sample ACCPERM class client


    FILE HISTORY:
        rustanl     22-May-1991     Created
        Johnl       12-Aug-1991     Modified for new generic scheme

*/
#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
    #include <ntioapi.h>
}

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#define INCL_NETCONS
#define INCL_NETUSER
#define INCL_NETGROUP
#define INCL_NETACCESS
#define INCL_NETAUDIT
#define INCL_NETUSE
#include <lmui.hxx>

extern "C"
{
    #include <helpnums.h>
    #include <mpr.h>
    #include <npapi.h>
}
#include <wfext.h>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>
#include <dbgstr.hxx>
#include <string.hxx>
#include <strnumer.hxx>
#include <uibuffer.hxx>
#include <uitrace.hxx>
#include <lmobj.hxx>
#include <lmodev.hxx>
#include <security.hxx>
#include <netname.hxx>
#include <maskmap.hxx>
#include <fmx.hxx>
#include <fsenum.hxx>

#include <permstr.hxx>

#include <accperm.hxx>
#include <ipermapi.hxx>
#include <permprg.hxx>

#include <ntfsacl.hxx>

/* Local prototypes
 */
APIERR EditFSACL( HWND               hwndParent,
		  enum SED_PERM_TYPE sedpermtype  ) ;

APIERR CompareLMSecurityIntersection( HWND		 hwndFMX,
				      const TCHAR *	 pszServer,
				      enum SED_PERM_TYPE sedpermtype,
				      BOOL *		 pfACLEqual,
				      NLS_STR * 	 pnlsFailingFile ) ;

DWORD SedLMCallback( HWND                   hwndParent,
                     HANDLE                 hInstance,
                     ULONG_PTR              ulCallbackContext,
                     PSECURITY_DESCRIPTOR   psecdesc,
                     PSECURITY_DESCRIPTOR   psecdescNewObjects,
                     BOOLEAN                fApplyToSubContainers,
                     BOOLEAN                fApplyToSubObjects,
                     LPDWORD                StatusReturn
                   ) ;

/* Lanman permissions:
 */
#define ACCESS_GEN_NONE          (ACCESS_NONE)
#define ACCESS_GEN_SEE_USE       (ACCESS_READ|ACCESS_EXEC)

#define ACCESS_GEN_CHANGES_FILE  (ACCESS_GEN_SEE_USE|ACCESS_WRITE|ACCESS_ATRIB|ACCESS_DELETE)
#define ACCESS_GEN_FULL_FILE     (ACCESS_GEN_CHANGES_FILE|ACCESS_PERM)

#define ACCESS_GEN_CHANGES_DIR   (ACCESS_GEN_SEE_USE|ACCESS_WRITE|ACCESS_CREATE|ACCESS_ATRIB|ACCESS_DELETE)
#define ACCESS_GEN_FULL_DIR      (ACCESS_GEN_CHANGES_DIR|ACCESS_PERM)

US_IDS_PAIRS aLMDirAccessIdsPairs[] =
{
    { ACCESS_GEN_NONE,        IDS_GEN_LM_ACCESSNAME_DENY_ALL, PERMTYPE_GENERAL },
    { ACCESS_GEN_SEE_USE,     IDS_GEN_LM_ACCESSNAME_SEE_USE,  PERMTYPE_GENERAL },
    { ACCESS_GEN_CHANGES_DIR, IDS_GEN_LM_ACCESSNAME_CHANGES,  PERMTYPE_GENERAL },
    { ACCESS_GEN_FULL_DIR,    IDS_GEN_LM_ACCESSNAME_FULL,     PERMTYPE_GENERAL },

    { ACCESS_READ,               IDS_LM_ACCESSNAME_READ,   PERMTYPE_SPECIAL },
    { ACCESS_WRITE,              IDS_LM_ACCESSNAME_WRITE,  PERMTYPE_SPECIAL },
    { ACCESS_EXEC,               IDS_LM_ACCESSNAME_EXEC,   PERMTYPE_SPECIAL },
    { ACCESS_DELETE,             IDS_LM_ACCESSNAME_DELETE, PERMTYPE_SPECIAL },
    { ACCESS_ATRIB,              IDS_LM_ACCESSNAME_ATRIB,  PERMTYPE_SPECIAL },
    { ACCESS_PERM,               IDS_LM_ACCESSNAME_PERM,   PERMTYPE_SPECIAL },
    { ACCESS_CREATE,             IDS_LM_ACCESSNAME_CREATE, PERMTYPE_SPECIAL },
} ;
#define SIZEOF_LM_DIR_ACCESSPAIRS   11  // Items in above array

US_IDS_PAIRS aLMFileAccessIdsPairs[] =
{
    { ACCESS_GEN_NONE,        IDS_GEN_LM_ACCESSNAME_DENY_ALL, PERMTYPE_GENERAL },
    { ACCESS_GEN_SEE_USE,     IDS_GEN_LM_ACCESSNAME_SEE_USE,  PERMTYPE_GENERAL },
    { ACCESS_GEN_CHANGES_FILE,IDS_GEN_LM_ACCESSNAME_CHANGES,  PERMTYPE_GENERAL },
    { ACCESS_GEN_FULL_FILE,   IDS_GEN_LM_ACCESSNAME_FULL,     PERMTYPE_GENERAL },

    { ACCESS_READ,               IDS_LM_ACCESSNAME_READ,   PERMTYPE_SPECIAL },
    { ACCESS_WRITE,              IDS_LM_ACCESSNAME_WRITE,  PERMTYPE_SPECIAL },
    { ACCESS_EXEC,               IDS_LM_ACCESSNAME_EXEC,   PERMTYPE_SPECIAL },
    { ACCESS_DELETE,             IDS_LM_ACCESSNAME_DELETE, PERMTYPE_SPECIAL },
    { ACCESS_ATRIB,              IDS_LM_ACCESSNAME_ATRIB,  PERMTYPE_SPECIAL },
    { ACCESS_PERM,               IDS_LM_ACCESSNAME_PERM,   PERMTYPE_SPECIAL },
} ;
#define SIZEOF_LM_FILE_ACCESSPAIRS   10  // Items in above array

/* The Lanman audit flags that we will deal with look like:
 *
 * We always use the Success form of the flag.  To differentiate between
 * success and failure, two bitfields are used.  When the ACL is written
 * out to the resource, the aclconverter will substitute the success bitfield
 * with the corresponding failed bitfields.
 *
 *      Flag               Applies To
 *    -----------         ------------
 *    AA_S_OPEN           // FILE
 *    AA_S_WRITE          // FILE
 *    AA_S_CREATE         //      DIR
 *    AA_S_DELETE         // FILE DIR
 *    AA_S_ACL            // FILE DIR
 *    AA_F_OPEN           // FILE
 *    AA_F_WRITE          // FILE
 *    AA_F_CREATE         //      DIR
 *    AA_F_DELETE         // FILE DIR
 *    AA_F_ACL            // FILE DIR
 */

/* Auditting mask map for LM Files:
 *
 * Note: When the permissions are written back out to disk, the failure
 *       Audit mask manifests will need to be substituted (we only use
 *       the success audit masks while processing, we just keep two
 *       bitfield objects for success and failure).
 */
US_IDS_PAIRS aLMFileAuditSidPairs[] =
            {   { AA_S_OPEN,    IDS_LM_AUDIT_NAME_OPEN,   PERMTYPE_SPECIAL },
                { AA_S_WRITE,   IDS_LM_AUDIT_NAME_WRITE,  PERMTYPE_SPECIAL },
                { AA_S_DELETE,  IDS_LM_AUDIT_NAME_DELETE, PERMTYPE_SPECIAL },
                { AA_S_ACL,     IDS_LM_AUDIT_NAME_ACL,    PERMTYPE_SPECIAL },
            } ;
#define SIZEOF_LM_FILE_AUDITPAIRS  4

/* Auditting mask map for LM Directories:
 */
US_IDS_PAIRS aLMDirAuditSidPairs[] =
            {   { AA_S_OPEN,             IDS_LM_AUDIT_NAME_OPEN,         PERMTYPE_SPECIAL },
                { AA_S_CREATE|AA_S_WRITE,IDS_LM_AUDIT_NAME_CREATE_WRITE, PERMTYPE_SPECIAL },
                { AA_S_DELETE,           IDS_LM_AUDIT_NAME_DELETE,       PERMTYPE_SPECIAL },
                { AA_S_ACL,              IDS_LM_AUDIT_NAME_ACL,          PERMTYPE_SPECIAL },
            } ;
#define SIZEOF_LM_DIR_AUDITPAIRS  4


/*******************************************************************

    NAME:       EditFSACL

    SYNOPSIS:   This internal function is called when the user selects
                the Permissions or Auditting menu item from the file
                manager.

                It builds the appropriate objects depending
                on the target file system.

    ENTRY:      hwndParent - Handle to parent window
                sedpermtype - Indicates if we want to edit permissions or
                        Audits

    EXIT:

    RETURNS:    NERR_Success if successful, appropriate error code otherwise
                (we will display any errors that occur).

    NOTES:

    HISTORY:
        Johnl   16-Aug-1991     Created

********************************************************************/

APIERR EditFSACL( HWND hwndParent,
                  enum SED_PERM_TYPE sedpermtype )
{
    AUTO_CURSOR cursorHourGlass ;

    APIERR err = NERR_Success;
    APIERR errSecondary = NERR_Success ;  // Don't report there errors
    BOOL   fIsNT ;
    ACL_TO_PERM_CONVERTER * paclconverter = NULL ; // gets deleted

    do { // error breakout

	FMX fmx( hwndParent );
        BOOL   fIsFile ;
        NLS_STR nlsSelItem;

        if ( fmx.QuerySelCount() == 0 )
        {
            err = IERR_NOTHING_SELECTED ;
            break ;
        }

        if ( (err = nlsSelItem.QueryError()) ||
	     (err = ::GetSelItem( hwndParent, 0, &nlsSelItem, &fIsFile )))
        {
            break ;
        }

        UIDEBUG(SZ("::EditFSACL - Called on file/dir: ")) ;
        UIDEBUG( nlsSelItem.QueryPch() ) ;
        UIDEBUG(SZ("\n\r")) ;

	BOOL fIsLocal ;
	NLS_STR  nlsServer( RMLEN ) ;
	if ( (err = nlsServer.QueryError()) ||
	     (err = ::TargetServerFromDosPath( nlsSelItem,
					       &fIsLocal,
					       &nlsServer )) )

        {
            //
            // have better error message for devices we dont support
            //
            if ( err == NERR_InvalidDevice )
            {
                NLS_STR nlsDrive( nlsSelItem );
                ISTR istr( nlsDrive );

                if ( err = nlsDrive.QueryError())
                    break;

                istr += 2;
                nlsDrive.DelSubStr( istr );

                err = WNetFMXEditPerm( (LPWSTR) nlsDrive.QueryPch(),
                                       hwndParent,
                                       sedpermtype == SED_AUDITS
                                       ? WNPERM_DLG_AUDIT
                                       : WNPERM_DLG_PERM );

            }
            break ;
        }


	//
	//  We only support multi-select if the selection is homogenous
	//
	BOOL fIsMultiSelect = (fmx.QuerySelCount() > 1 ) ;
	if ( fIsMultiSelect )
	{
	    if ( fmx.IsHeterogeneousSelection( &fIsFile ) )
	    {
		err = IERR_MIXED_MULTI_SEL ;
		break ;
	    }
	}

	LOCATION locDrive( fIsLocal ? NULL : nlsServer.QueryPch() ) ;
        if ( (err = locDrive.QueryError()) ||
             (err = locDrive.CheckIfNT( &fIsNT ))  )
        {
            UIDEBUG(SZ("::EditFSAcl - locDrive failed to construct\n\r")) ;
            break ;
        }

        /* If we are looking at an NT resource, then we will go through the
         * front door.  If we are looking at a Lanman ACL, then we will go
         * through the back door.
         */
        if ( fIsNT )
        {
            /* We know it's NT, but is the resource on an NTFS partition?
             */
            BOOL  fIsNTFS ;
            if ( err = IsNTFS( nlsSelItem, &fIsNTFS ))
            {
                break ;
            }

            if ( !fIsNTFS )
            {
                err = IERR_NOT_NTFS_VOLUME ;
            }
            else
	    {
		if ( errSecondary= ::EditNTFSAcl(
					hwndParent,
					locDrive.QueryServer(),
                                        nlsSelItem.QueryPch(),
                                        sedpermtype,
                                        fIsFile ) )
                {
                    DBGEOL(SZ("::EditFSAcl - Error returned from EditNTFSAcl - error code: ") << (ULONG) errSecondary ) ;
                }
            }

            /* We return here even on success
             */
            break ;
	}

	//
	//  If this is a multi-selection, determine if the intersection of
	//  ACLs is the same.
	//

	BOOL fIsBadIntersection = FALSE ;
	BOOL fACLEqual = TRUE ;
	DEC_STR nlsSelectCount( fmx.QuerySelCount() ) ;
	if ( fIsMultiSelect )
	{
	    NLS_STR nlsFailingFile ;
	    if ( (err = nlsFailingFile.QueryError() ) ||
		 (err = nlsSelectCount.QueryError() ) ||
		 (err = CompareLMSecurityIntersection( hwndParent,
						       nlsServer,
						       sedpermtype,
						       &fACLEqual,
						       &nlsFailingFile )) )
	    {
		break ;
	    }

	    if ( !fACLEqual )
	    {
		switch ( ::MsgPopup( hwndParent,
				     (MSGID) IDS_BAD_INTERSECTION,
				     MPSEV_WARNING,
				     MP_YESNO,
				     nlsSelItem,
				     nlsFailingFile,
				     MP_YES ))
		{
		case IDYES:
		    fACLEqual = TRUE ;	// Will use empty ACL
		    fIsBadIntersection = TRUE ;
		    break ;

		case IDNO:
		default:
		    return NERR_Success ;
		}
	    }
	}
	if ( err || !fACLEqual )
	    break ;

        /* Get all of the stuff that is specific for Lan Manager
         */
        MASK_MAP maskmapAccess, maskmapNewObjectAccess, maskmapAudit ;
        NLS_STR  nlsDialogTitle,
                 nlsSpecialAccessName,
                 nlsNewObjectSpecialAccessName,
                 nlsAssignToExistingContTitle,
                 nlsAssignNewObjToExistingTitle,
		 nlsHelpFileName,
                 nlsAssignToTreeConfirmation,
                 nlsDefaultPermName ;

        if ( ( err = maskmapAccess.QueryError() )                  ||
             ( err = maskmapNewObjectAccess.QueryError() )         ||
             ( err = maskmapAudit.QueryError() )                   ||
             ( err = nlsDialogTitle.QueryError() )                 ||
             ( err = nlsSpecialAccessName.QueryError() )           ||
             ( err = nlsNewObjectSpecialAccessName.QueryError() )  ||
             ( err = nlsAssignToExistingContTitle.QueryError() )   ||
	     ( err = nlsHelpFileName.QueryError() )		   ||
             ( err = nlsAssignToTreeConfirmation.QueryError() )    ||
             ( err = nlsAssignNewObjToExistingTitle.QueryError() ) ||
             ( err = nlsDefaultPermName.QueryError() )               )
        {
            UIDEBUG(SZ("::EditFSAcl - Failed to construct basic objects\n\r")) ;
            break ;
        }

        US_IDS_PAIRS * pusidspairAccess = NULL,
                     * pusidspairAudit = NULL ;
        UINT cAccessPairs = 0, cAuditPairs = 0 ;
        MSGID msgIDSDialogTitle,
              msgIDSSpecialAccessName,
              msgIDDefaultPermName ;
        ULONG ahc[7] ;

        /* Based on what we are doing, choose and build the correct
         * task oriented object set of MASK_MAPs, acl converters and resource
         * strings.
         */
        if ( fIsFile )
        {
            pusidspairAccess = (US_IDS_PAIRS *) &aLMFileAccessIdsPairs ;
            cAccessPairs     = (UINT) SIZEOF_LM_FILE_ACCESSPAIRS ;
            pusidspairAudit  = (US_IDS_PAIRS *) &aLMFileAuditSidPairs ;
            cAuditPairs      = (UINT) SIZEOF_LM_FILE_AUDITPAIRS ;

            msgIDSSpecialAccessName = (MSGID) IDS_LM_FILE_SPECIAL_ACCESS_NAME ;
            msgIDSDialogTitle = (MSGID) sedpermtype == SED_ACCESSES ?
                                   IDS_LM_FILE_PERMISSIONS_TITLE :
                                   IDS_LM_FILE_AUDITS_TITLE ;
            msgIDDefaultPermName = IDS_FILE_PERM_GEN_READ ;

            ahc[HC_MAIN_DLG] = sedpermtype == SED_ACCESSES ?
                                  HC_SED_LM_FILE_PERMS_DLG :
                                  HC_SED_LM_FILE_AUDITS_DLG ;
            ahc[HC_SPECIAL_ACCESS_DLG] = HC_SED_LM_SPECIAL_FILES_FM ;
        }
        else
        {
            pusidspairAccess = (US_IDS_PAIRS *) &aLMDirAccessIdsPairs ;
            cAccessPairs     = (UINT) SIZEOF_LM_DIR_ACCESSPAIRS ;
            pusidspairAudit  = (US_IDS_PAIRS *) &aLMDirAuditSidPairs ;
            cAuditPairs      = (UINT) SIZEOF_LM_DIR_AUDITPAIRS ;

            msgIDSSpecialAccessName = (MSGID) IDS_LM_DIR_SPECIAL_ACCESS_NAME ;
            msgIDSDialogTitle = (MSGID) sedpermtype == SED_ACCESSES ?
                                  IDS_LM_DIR_PERMISSIONS_TITLE :
                                  IDS_LM_DIR_AUDITS_TITLE  ;
            msgIDDefaultPermName = IDS_DIR_PERM_GEN_READ ;

            ahc[HC_MAIN_DLG] = sedpermtype == SED_ACCESSES ?
                                  HC_SED_LM_DIR_PERMS_DLG :
                                  HC_SED_LM_DIR_AUDITS_DLG ;
            ahc[HC_SPECIAL_ACCESS_DLG] = HC_SED_LM_SPECIAL_DIRS_FM ;

            if ( ( err = nlsAssignToExistingContTitle.Load((MSGID)
                              sedpermtype == SED_ACCESSES ?
                                   IDS_LM_DIR_ASSIGN_PERM_TITLE :
                                   IDS_LM_DIR_ASSIGN_AUDIT_TITLE)) ||
                 ( err = nlsAssignToTreeConfirmation.Load(
                                   IDS_TREE_APPLY_WARNING ))         )
            {
                break ;
            }
        }
        ahc[HC_ADD_USER_DLG] = HC_SED_LANMAN_ADD_USER_DIALOG ;

        if ( ( err = maskmapAccess.Add( pusidspairAccess, (USHORT)cAccessPairs ) )||
             ( err = maskmapAudit.Add( pusidspairAudit, (USHORT)cAuditPairs ) )   ||
             ( err = nlsDialogTitle.Load( msgIDSDialogTitle ))            ||
             ( err = nlsSpecialAccessName.Load( msgIDSSpecialAccessName ))||
	     ( err = nlsDefaultPermName.Load( msgIDDefaultPermName ))	  ||
	     ( err = nlsHelpFileName.Load( IDS_FILE_PERM_HELP_FILE )) )
        {
            break ;
	}

        LM_CALLBACK_INFO callbackinfo;
        callbackinfo.hwndFMXOwner = hwndParent;
        callbackinfo.sedpermtype = sedpermtype;

	paclconverter = new LM_ACL_TO_PERM_CONVERTER( locDrive.QueryServer(),
                               nlsSelItem,
                               &maskmapAccess,
                               &maskmapAudit,
                               !fIsFile,
                               (PSED_FUNC_APPLY_SEC_CALLBACK) SedLMCallback,
			       (ULONG_PTR) &callbackinfo,
			       fIsBadIntersection );

        err = (paclconverter == NULL ? ERROR_NOT_ENOUGH_MEMORY :
                                       paclconverter->QueryError()) ;

        if ( err )
        {
            break ;
        }

	RESOURCE_STR nlsResType((MSGID)( fIsFile ? IDS_FILE : IDS_DIRECTORY)) ;


	RESOURCE_STR nlsResourceName( fIsFile ? IDS_FILE_MULTI_SEL :
						IDS_DIRECTORY_MULTI_SEL ) ;

        if ( nlsResType.QueryError() != NERR_Success )
        {
            UIDEBUG(SZ("EditFSAcl - Unable to Load Resource type strings\n\r")) ;
            break ;
	}

	//
	//  Replace the resource name with the "X files selected" string
	//  if we are in a multi-select situation
	//
	const TCHAR * pszResource = nlsSelItem ;
	if ( fIsMultiSelect )
	{
	    if ( (err = nlsResourceName.QueryError()) ||
		 (err = nlsResourceName.InsertParams( nlsSelectCount )))
	    {
		break ;
	    }
	    pszResource = nlsResourceName.QueryPch() ;
	}

        //
        //  Finally, call the real ACL editor with all of the parameters we have
        //  just prepared.
        //
        err = I_GenericSecurityEditor( hwndParent,
                                       paclconverter,
                                       sedpermtype,
                                       fIsNT,
                                       !fIsFile,
                                       FALSE,
                                       nlsDialogTitle,
                                       nlsResType,
				       pszResource,
                                       nlsSpecialAccessName,
				       nlsDefaultPermName,
                                       nlsHelpFileName,
                                       ahc,
                                       nlsNewObjectSpecialAccessName,
                                       fIsFile ? NULL :
                                          nlsAssignToExistingContTitle.QueryPch(),
                                       NULL,
                                       NULL,
                                       nlsAssignToTreeConfirmation ) ;

        if ( err != NERR_Success )
        {
            UIDEBUG(SZ("::EditFSAcl - I_GenericSecurityEditor failed\n\r")) ;
            break ;
        }

    } while (FALSE) ;

    delete paclconverter ;

    if ( err )
    {
        MsgPopup( hwndParent, (MSGID) err ) ;
    }

    return err ? err : errSecondary ;
}


void EditAuditInfo( HWND  hwndFMXWindow )
{
    (void) EditFSACL( hwndFMXWindow,
                      SED_AUDITS ) ;
}

void EditPermissionInfo( HWND  hwndFMXWindow )
{
    (void) EditFSACL( hwndFMXWindow,
                      SED_ACCESSES ) ;
}

/*******************************************************************

    NAME:       SedLMCallback

    SYNOPSIS:   Security Editor callback for the LM ACL Editor

    ENTRY:      See sedapi.hxx

    EXIT:

    RETURNS:

    NOTES:      The callback context should be the FMX Window handle.  This
                is so we can support setting permissions on multiple files/
                directories if we ever decide to do that.

    HISTORY:
        Yi-HsinS   17-Sept-1992     Filled out

********************************************************************/


DWORD SedLMCallback( HWND                   hwndParent,
                     HANDLE                 hInstance,
                     ULONG_PTR              ulCallbackContext,
                     PSECURITY_DESCRIPTOR   psecdesc,
                     PSECURITY_DESCRIPTOR   psecdescNewObjects,
                     BOOLEAN                fApplyToSubContainers,
                     BOOLEAN                fApplyToSubObjects,
                     LPDWORD                StatusReturn
                   )
{
    UNREFERENCED( hInstance ) ;
    UNREFERENCED( psecdesc ) ;
    UNREFERENCED( psecdescNewObjects ) ;

    APIERR err ;
    LM_CALLBACK_INFO *pcallbackinfo = (LM_CALLBACK_INFO *) ulCallbackContext;
    HWND hwndFMXWindow = pcallbackinfo->hwndFMXOwner ;

    FMX fmx( hwndFMXWindow );
    UINT uiCount = fmx.QuerySelCount() ;
    BOOL fDismissDlg = TRUE ;
    BOOL fDepthFirstTraversal = FALSE ;

    NLS_STR nlsSelItem( 128 ) ;
    RESOURCE_STR nlsCancelDialogTitle( IDS_CANCEL_TASK_APPLY_DLG_TITLE ) ;
    if ( (err = nlsSelItem.QueryError()) ||
	 (err = nlsCancelDialogTitle.QueryError()) )
    {
	*StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	::MsgPopup( hwndParent, (MSGID) err ) ;
        return err ;
    }

    //
    //	QuerySelCount only returns the number of selections in the files window,
    //	thus if the focus is in the directory window, then we will just make
    //	the selection count one for out "for" loop.
    //
    if ( fmx.QueryFocus() == FMFOCUS_TREE )
    {
	uiCount = 1 ;
    }

    BOOL fIsFile ;
    if ( err = ::GetSelItem( hwndFMXWindow, 0, &nlsSelItem, &fIsFile ) )
    {
	::MsgPopup( hwndParent, (MSGID) err ) ;
	*StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return err ;
    }

    //
    //	If we only have to apply permissions to a single item or we are
    //	taking ownership of a file, then just
    //	do it w/o bringing up the cancel task dialog.
    //
    if (  uiCount == 1 &&
	  !fApplyToSubContainers &&
	  !fApplyToSubObjects)
    {
	err = pcallbackinfo->plmobjNetAccess1->Write() ;

	if ( err )
	{
	    DBGEOL("LM SedCallback - Error " << (ULONG)err << " applying security to " <<
	       nlsSelItem ) ;
	    ::MsgPopup( hwndParent, (MSGID) err ) ;
	    *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	}
    }
    else
    {
        //
        //  Note that the LM Perm & Audit dialogs only have a single checkbox
        //  for applying permissions to the whole tree (and all items in
        //  the tree).
        //
	LM_TREE_APPLY_CONTEXT Ctxt( nlsSelItem ) ;
	Ctxt.State		  = APPLY_SEC_FMX_SELECTION ;
	Ctxt.hwndFMXWindow	  = hwndFMXWindow ;
	Ctxt.sedpermtype	  = pcallbackinfo->sedpermtype ;
	Ctxt.iCurrent		  = 0 ;
	Ctxt.uiCount		  = uiCount ;
	Ctxt.fDepthFirstTraversal = fDepthFirstTraversal ;
        Ctxt.fApplyToDirContents  = fApplyToSubContainers ;
	Ctxt.StatusReturn	  = StatusReturn ;
	Ctxt.fApplyToSubContainers= fApplyToSubContainers ;
	Ctxt.fApplyToSubObjects   = fApplyToSubObjects ;
	Ctxt.plmobjNetAccess1	  = pcallbackinfo->plmobjNetAccess1 ;

	LM_CANCEL_TREE_APPLY CancelTreeApply( hwndParent,
					      &Ctxt,
					      nlsCancelDialogTitle ) ;
	if ( (err = CancelTreeApply.QueryError()) ||
	     (err = CancelTreeApply.Process( &fDismissDlg )) )
	{
	    *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	    ::MsgPopup( hwndParent, (MSGID) err ) ;
	}
    }

    if ( !err )
    {
        // Refresh the file manager window if permissions is updated
        if ( pcallbackinfo->sedpermtype == SED_ACCESSES )
	    fmx.Refresh();

	if ( *StatusReturn == 0 )
	    *StatusReturn = SED_STATUS_MODIFIED ;
    }

    if ( !err && !fDismissDlg )
    {
	//
	//  Don't dismiss the dialog if the user canceled the tree
	//  apply.  This tells the ACL editor not to dismiss the permissions
	//  dialog (or auditing or owner).
	//
	err = ERROR_GEN_FAILURE ;
    }

    return err ;
}

/*******************************************************************

    NAME:	TargetServerFromDosPath

    SYNOPSIS:	Given a DOS path, gets the server name the path lives on

    ENTRY:	nlsDosPath - Dos path to get server for
		pfIsLocal  - Set to TRUE if the path is on the local machine
		pnlsTargetServer - Receives server path is on

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	If the workstation isn't started, then the path is assumed
		to be on the local machine.

    HISTORY:
	Johnl	12-Oct-1992	Broke out as a function

********************************************************************/

APIERR TargetServerFromDosPath( const NLS_STR & nlsDosPath,
				BOOL	* pfIsLocal,
				NLS_STR * pnlsTargetServer )
{
    UIASSERT( pfIsLocal != NULL && pnlsTargetServer != NULL ) ;

    *pfIsLocal = FALSE;

    APIERR err = NERR_Success ;
    do { // error breakout

        NLS_STR nlsDriveName;
        if (  ( err = nlsDriveName.QueryError())
           || ( err = nlsDriveName.CopyFrom( nlsDosPath, 4 ))
           )
        {
            break;
        }

        UINT nDriveType = ::GetDriveType( nlsDriveName );

        if (  ( nDriveType == DRIVE_REMOVABLE )
           || ( nDriveType == DRIVE_FIXED )
           || ( nDriveType == DRIVE_CDROM )
           || ( nDriveType == DRIVE_RAMDISK )
           )
        {
            *pfIsLocal = TRUE;
            *pnlsTargetServer = SZ("");
            break;
        }

	NET_NAME netnameSelItem( nlsDosPath ) ;
	if ( (err = netnameSelItem.QueryError()))
        {
            break ;
        }

	err = netnameSelItem.QueryComputerName( pnlsTargetServer );

    } while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:	CompareLMSecurityIntersection

    SYNOPSIS:	Determines if the files/dirs currently selected have
		equivalent security descriptors

    ENTRY:	hwndFMX - FMX Hwnd used for getting selection
		pszServer - The server the resource lives
		sedpermtype - Interested in DACL or SACL
		pfACLEqual - Set to TRUE if all of the DACLs/SACLs are
		    equal.  If FALSE, then pfOwnerEqual should be ignored
		pnlsFailingFile - Filled with the first file name found to
		    be not equal

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	The first non-equal ACL causes the function to exit.

		On a 20e with 499 files selected locally, it took 35.2 minutes
		to read the security descriptors from the disk and 14 seconds
		to determine the intersection.	So even though the Compare
		method uses an n^2 algorithm, it only takes up 0.6% of the
		wait time.

    HISTORY:
	Johnl	05-Nov-1992	 Created

********************************************************************/

APIERR CompareLMSecurityIntersection( HWND		 hwndFMX,
				      const TCHAR *	 pszServer,
				      enum SED_PERM_TYPE sedpermtype,
				      BOOL *		 pfACLEqual,
				      NLS_STR * 	 pnlsFailingFile )
{
    TRACEEOL("::CompareLMSecurityIntersection - Entered @ " << ::GetTickCount()/100) ;
    FMX fmx( hwndFMX );
    UIASSERT( fmx.QuerySelCount() > 1 ) ;

    APIERR err ;
    UINT cSel = fmx.QuerySelCount() ;
    BOOL fNoACE = FALSE ;	    // Set to TRUE if the resource has no ACE

    NLS_STR nlsSel( PATHLEN ) ;
    if ( (err = nlsSel.QueryError()) ||
	 (err = ::GetSelItem( hwndFMX, 0, &nlsSel, NULL )))
    {
	return err ;
    }

    //
    //	Get the first ACL and use it to compare against
    //
    NET_ACCESS_1 netacc1Base( pszServer, nlsSel ) ;
    switch ( err = netacc1Base.GetInfo() )
    {
    case NERR_ResourceNotFound:
	fNoACE = TRUE ;
	if ( err = netacc1Base.CreateNew() )
	    return err ;
	break ;

    case NERR_Success:
	break ;

    case ERROR_NOT_SUPPORTED: // This will only be returned by LM2.x Share-level
                              // server
        return IERR_ACLCONV_CANT_EDIT_PERM_ON_LM_SHARE_LEVEL;

    default:
	return err ;
    }

    *pfACLEqual = TRUE ;

    for ( UINT i = 1 ; i < cSel ; i++ )
    {
	if ( (err = ::GetSelItem( hwndFMX, i, &nlsSel, NULL )) )
	{
	    break ;
	}

	NET_ACCESS_1 netacc1( pszServer, nlsSel ) ;
	switch ( err = netacc1.GetInfo() )
	{
	case NERR_ResourceNotFound:
	    if ( fNoACE )
	    {
		err = NERR_Success ;
		continue ;  // Ignore the error
	    }
	    else
	    {
		*pfACLEqual = FALSE ;
	    }
	    break ;

	default:
	    break ;
	}
	if ( err || !*pfACLEqual )
	    break ;

	if ( sedpermtype == SED_AUDITS )
	{
	    if ( netacc1Base.QueryAuditFlags() != netacc1.QueryAuditFlags() )
	    {
		*pfACLEqual = FALSE ;
		break ;
	    }
	}
	else
	{
	    UIASSERT( sedpermtype == SED_ACCESSES ) ;

	    if ( !netacc1Base.CompareACL( &netacc1 ) )
	    {
		*pfACLEqual = FALSE ;
		break ;
	    }
	}
    }

    if ( !*pfACLEqual )
    {
	err = pnlsFailingFile->CopyFrom( nlsSel ) ;
    }

    TRACEEOL("::CompareLMSecurityIntersection - Left    @ " << ::GetTickCount()/100) ;
    return err ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\permdlg.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    PermDlg.cxx

    This file contains the implementation for the access permission dialogs.

    FILE HISTORY:
	Johnl	06-Aug-1991	Created

*/
#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
    #include <ntlsa.h>
    #include <ntioapi.h>
    #include <ntsam.h>
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>
#include <dbgstr.hxx>

#include <security.hxx>
#include <lmodom.hxx>
#include <uintsam.hxx>
#include <uintlsa.hxx>
#include <ntacutil.hxx>
#include <maskmap.hxx>
#include <apisess.hxx>

#include <accperm.hxx>
#include <aclconv.hxx>
#include <permstr.hxx>

#include <specdlg.hxx>
#include <add_dlg.hxx>
#include <permdlg.hxx>
#include <perm.hxx>

#define  SECURITY_EDITOR
#include <usrbrows.hxx>

#include <uitrace.hxx>

/*******************************************************************

    NAME:	PERM_BASE_DLG::PERM_BASE_DLG

    SYNOPSIS:	Base permission dialog (for both access and audit permissions)

    ENTRY:	pszDialogName - Resource file name of dialog
		hwndParent - handle of parent window
		paclconv - pointer to aclconverter
		pchResType - UI string to use for resource type name (if NULL,
			     resource name is blank)  A colon will be
			     appended to this name (if it doesn't already
			     *contain* a colon).
		pchResName - UI string to use for resource name (if NULL,
			     resource name is blank).
		hcMainDialog - Help context for this dialog

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	07-Aug-1991	Created

********************************************************************/

PERM_BASE_DLG::PERM_BASE_DLG(const TCHAR * pszDialogName,
			     HWND hwndParent,
			     const TCHAR * pszDialogTitle,
			     const TCHAR * pchResType,
			     const TCHAR * pchResName,
			     const TCHAR * pszHelpFileName,
                             ULONG       * ahcMainDialog  )
    : DIALOG_WINDOW   ( pszDialogName, hwndParent ),
      _sltResourceType( this, SLT_RESOURCE_TYPE ),
      _sleResourceName( this, SLE_RESOURCE_NAME ),
      _pszHelpFileName( pszHelpFileName ),
      _ahcDialogHelp  ( ahcMainDialog ),
      _buttonOK       ( this, IDOK ),
      _buttonCancel   ( this, IDCANCEL ),
      _nlsResName     ( pchResName ),
      _nlsResType     ( pchResType )
{
    if ( QueryError() != NERR_Success )
    {
	UIDEBUG(SZ("PERM_BASE_DLG::ct - Parent or control returned error\n\r")) ;
	UIASSERT(FALSE);     // For debugging purposes
	return ;
    }

    UIASSERT( pszDialogTitle != NULL ) ;
    SetText( pszDialogTitle ) ;

    /* We need to resize the Resource type field and reposition the
     * resource name field.  We also append a colon after the resource
     * type.
     */
    ALIAS_STR	 nlsResName( pchResName == NULL ? SZ("") : pchResName ) ;
    NLS_STR	 nlsResType( pchResType ) ;
    RESOURCE_STR nlsColon( (USHORT) IDS_OBJTYPE_OBJNAME_SEPARATOR ) ;

    APIERR err ;
    if ( ( err = nlsResType.QueryError() ) ||
	 ( err = nlsColon.QueryError() )     )
    {
	ReportError( err ) ;
	return ;
    }


    /* If the resource name doesn't already have a colon, then
     * append one on.
     */
    ISTR istrDummy( nlsResType ) ;
    if ( nlsResType.strlen() > 0 && !nlsResType.strstr( &istrDummy, nlsColon ))
    {
	nlsResType += nlsColon ;
	if ( nlsResType.QueryError() )
	{
	    ReportError( nlsResType.QueryError() ) ;
	    return ;
	}
    }

    _sltResourceType.SetText( nlsResType ) ;
    _sleResourceName.SetText( nlsResName ) ;

    XYPOINT xyResType = _sltResourceType.QueryPos() ;
    UINT uiStartOfResName = xyResType.QueryX() ;

    /* Find out where the end of the Resource Type field is and resize the
     * control window to the correct size.
     */
    {
	DISPLAY_CONTEXT dcResType( _sltResourceType.QueryHwnd() ) ;

        // kkntbug#11847
        // Select appropriate font into the specified DC before get text extent.
        // Unless this process, text extent might not be correct.
        EVENT event(WM_GETFONT, 0, 0L);
        HFONT hFont = (HFONT)event.SendTo(_sltResourceType.QueryHwnd());
        if (hFont)
        {
            hFont = dcResType.SelectFont(hFont);
        }

	XYDIMENSION dxyResType = dcResType.QueryTextExtent( nlsResType ) ;
	_sltResourceType.SetSize( dxyResType ) ;
	uiStartOfResName += dxyResType.QueryWidth() ;

        // kkntbug#11847
        // +10 is just looks nice... (of course, it works w/o this.)
        // e.g. "Label: Name" is looks better than "Label:Name"
        uiStartOfResName += 10;
        // restore object.
        if (hFont)
        {
            dcResType.SelectFont(hFont);
        }

    }

    /* Place the Resource name in the appropriate place and resize the field
     * appropriately.  We assume the right edge of the control is in the
     * correct place (i.e., the rightmost position).
     */
    XYPOINT xypointResName = _sleResourceName.QueryPos() ;
    UINT xOldPos = xypointResName.QueryX() ;
    xypointResName.SetX( uiStartOfResName ) ;
    _sleResourceName.SetPos( xypointResName ) ;

    XYDIMENSION dxyResName = _sleResourceName.QuerySize() ;
    dxyResName.SetWidth( dxyResName.QueryWidth() -
			  ( xOldPos > (UINT)xypointResName.QueryX() ?
			    xOldPos - xypointResName.QueryX() :
			    xypointResName.QueryX() - xOldPos) ) ;

    _sleResourceName.SetSize( dxyResName.QueryWidth(),
				  dxyResName.QueryHeight() ) ;

    _buttonOK.ClaimFocus() ;
}

PERM_BASE_DLG::~PERM_BASE_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	PERM_BASE_DLG::QueryHelpContext

    SYNOPSIS:	Typical help context for the main dialog

    HISTORY:
	Johnl	28-Apr-1992	Created

********************************************************************/

ULONG PERM_BASE_DLG::QueryHelpContext( void )
{
    return QueryHelpArray()[HC_MAIN_DLG] ;
}

/*******************************************************************

    NAME:	PERM_BASE_DLG::QueryHelpFile

    SYNOPSIS:	Returns the client specific help file name

    NOTES:

    HISTORY:
	Johnl	02-Sep-1992	Created

********************************************************************/

const TCHAR * PERM_BASE_DLG::QueryHelpFile( ULONG ulHelpContext )
{
    UNREFERENCED( ulHelpContext ) ;
    return _pszHelpFileName ;
}

/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::MAIN_PERM_BASE_DLG

    SYNOPSIS:	Base permission dialog (for both access and audit permissions)

    ENTRY:	pszDialogName - Resource file name of dialog
		hwndParent - handle of parent window
		paclconv - pointer to aclconverter
		pchResType - UI string to use for resource type name (if NULL,
			     resource name is blank)
		pchResName - UI string to use for resource name (if NULL,
			     resource name is blank).
		hcMainDialog - Help context for the main dialog

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	07-Aug-1991	Created

********************************************************************/

MAIN_PERM_BASE_DLG::MAIN_PERM_BASE_DLG(  const TCHAR * pszDialogName,
					 HWND	       hwndParent,
					 const TCHAR * pszDialogTitle,
					 ACL_TO_PERM_CONVERTER * paclconv,
					 const TCHAR * pchResType,
					 const TCHAR * pchResName,
					 const TCHAR * pszHelpFileName,
                                         ULONG       * ahcMainDialog   )
    : PERM_BASE_DLG( pszDialogName,
		     hwndParent,
		     pszDialogTitle,
		     pchResType,
		     pchResName,
		     pszHelpFileName,
                     ahcMainDialog ),
      _accperm	   ( paclconv )
{
    if ( QueryError() != NERR_Success )
	return ;

    if ( _accperm.QueryError() != NERR_Success )
    {
	ReportError( _accperm.QueryError() ) ;
	return ;
    }

    /* This gives the ACL converter a window handle to use when
     * calling the callback (or if we can't get the logged on domain).
     */
    QueryAclConverter()->SetWritePermHwnd( QueryRobustHwnd() ) ;
}

MAIN_PERM_BASE_DLG::~MAIN_PERM_BASE_DLG()
{
    /* Nothing to do */
}


/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::GetPermissions

    SYNOPSIS:	Gets the network resources and gives the user the
		option to cancel if appropriate.

    ENTRY:      pfUserQuit indicates if the user aborted, is only
		    valid if NERR_Success is returned
		fAccessPerms - Is TRUE if the access permissions should
		    be retrieved, FALSE if the Audit permissions should
		    be retrieved.


    EXIT:

    NOTES:

    HISTORY:
	Johnl	29-Aug-1991	Broke from constructor

********************************************************************/

APIERR MAIN_PERM_BASE_DLG::GetPermissions( BOOL * pfUserQuit, BOOL fAccessPerms )
{
    /* Assume the user didn't quit
     */
    *pfUserQuit = FALSE ;

    APIERR err = _accperm.GetPermissions( fAccessPerms ) ;
    switch ( err )
    {
    case NERR_Success:
	break ;

    case IERR_ACLCONV_NONST_ACL_CANT_EDIT:
	{
	    MsgPopup( this,
		      (MSGID) IERR_ACLCONV_NONST_ACL_CANT_EDIT,
		      MPSEV_WARNING,
		      MP_OK,
		      QueryResName(),
		      NULL,
		      MP_OK ) ;

	    *pfUserQuit = TRUE ;
	    err = NERR_Success ;
	}
	break ;

    case IERR_ACLCONV_READ_ONLY:
	{
	    MsgPopup( this,
		      (MSGID) IERR_ACLCONV_READ_ONLY,
                      MPSEV_INFO,
		      MP_OK,
		      QueryResName(),
		      NULL,
		      MP_OK ) ;

	    err = NERR_Success ;
	}
	break ;

    case IERR_ACLCONV_NONST_ACL_CAN_EDIT:
    case IERR_ACLCONV_CANT_VIEW_CAN_EDIT:
    case IERR_ACLCONV_LM_NO_ACL:
	{
	    if ( IDNO == MsgPopup( this,
				   (MSGID) err,
				   MPSEV_WARNING,
				   MP_YESNO,
				   QueryResName(),
				   NULL,
				   MP_NO ) )

	    {
		err = NERR_Success ;
		*pfUserQuit = TRUE ;
		break ;
	    }

	    /* They answered "Yes" to overwriting the current permissions,
	     * so go ahead and get a blank permission set.
	     */
	    err = _accperm.GetBlankPermissions() ;
	    if ( err != NERR_Success )
	    {
		return err ;
	    }

	}
	break ;

    case IERR_ACLCONV_LM_INHERITING_PERMS:
	{
	    NLS_STR nlsInherittingResName ;
	    if ( nlsInherittingResName.QueryError() != NERR_Success )
	    {
		return nlsInherittingResName.QueryError() ;
	    }

	    err = _accperm.QueryAclConverter()->
			       QueryInherittingResource( &nlsInherittingResName ) ;
	    if ( err != NERR_Success )
	    {
		break ;
	    }

	    if ( IDNO == MsgPopup( QueryOwnerHwnd(),
				   (USHORT) IERR_ACLCONV_LM_INHERITING_PERMS,
				   MPSEV_WARNING,
				   MP_YESNO,
				   QueryResName(),
				   nlsInherittingResName.QueryPch(),
				   MP_NO ) )
	    {
		*pfUserQuit = TRUE ;
		err = NERR_Success ;
	    }

	    /* They answered "Yes" to explicitly assigning the current permissions,
	     * which are now stored in the accperm object
	     */
	}
	break ;

    default:
	break ;
    }

    return err ;
}

/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::WritePermissions

    SYNOPSIS:	Attempts to write the permissions, displays
		errors and gets user input as necessary.

    ENTRY:	_accperm should be set to the interested resource

		fApplyToExistingCont - Same meaning as
			       ACL_TO_PERM_CONVERTER::WritePermissions
                fApplyToObj - Same...

    EXIT:


    NOTES:

    HISTORY:
	Johnl	29-Aug-1991	Broke from constructor

********************************************************************/

BOOL MAIN_PERM_BASE_DLG::WritePermissions( BOOL fApplyToExistingCont,
                                           BOOL fApplyToObj,
					   enum TREE_APPLY_FLAGS applyflags )
{
    APIERR err = NERR_Success ;
    BOOL fRet = FALSE ;
    BOOL fDone = FALSE ;
    BOOL fReportErrors = TRUE ;

    while ( !fDone )
    {
	AUTO_CURSOR cursHourGlass ;

	err = _accperm.WritePermissions( fApplyToExistingCont,
                                         fApplyToObj,
					 applyflags,
					 &fReportErrors ) ;

	switch ( err )
	{
	case NERR_Success:
	    fRet = TRUE ;
	    fDone = TRUE ;
	    break ;

	/* Somebody has deleted a user/group out from under us, thus we can
	 * no longer write the ACL.  Tell the user which subject failed and
	 * ask if they want to remove it and try again.
	 */
	case NERR_UserNotFound:
	    {
		NLS_STR nlsUniqueSubjectID ;
		if ( err = _accperm.QueryFailingSubject( &nlsUniqueSubjectID ) )
		    break ;

		switch ( MsgPopup( this, (MSGID) IERR_CONTINUE_AFTER_USERGROUP_NOT_FOUND,
				   MPSEV_WARNING, MP_YESNO, nlsUniqueSubjectID ) )
		{
		case IDNO:
		    fDone = TRUE ;
		    break ;

		/* Note that the if an error occured while trying to delete
		 * the subject, the continue will take us back to the top
		 * of the while loop, which will then fall out because
		 * err is non-zero.
		 */
		case IDYES:
		    err = _accperm.DeleteSubject( &nlsUniqueSubjectID ) ;
		    continue ;

		default:
		    UIASSERT(!SZ("How the heck did we get here?") ) ;
		    break ;
		}
	    }

	default:
	    /* Some other error occurred, we will fall out of the loop.
	     */
	    fDone = TRUE ;
	    break ;
	}
    }

    //
    // Some of our clients may have already reported the error to the user, if so,
    // simply return
    //
    if ( err && fReportErrors )
    {
	MsgPopup( this, (MSGID) err ) ;
    }

    return fRet ;
}

/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::OnOK

    SYNOPSIS:	Attempts to write out new permissions when the user
		presses the OK button.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	29-Aug-1991	Created

********************************************************************/

BOOL MAIN_PERM_BASE_DLG::OnOK( void )
{
    if ( IsReadOnly() )
    {
	Dismiss( TRUE ) ;
	return TRUE ;
    }

    //
    //  If nothing is granted, warn the user.  Note that you
    //  can't deny everyone access under LM
    //
    APIERR err ;
    BOOL fIsDenyAll = FALSE ;
    if ( IsNT() &&
         (err = _accperm.AnyDenyAllsToEveryone( &fIsDenyAll )) )
    {
	::MsgPopup( this, (MSGID) err ) ;
	return TRUE ;
    }

    if (  fIsDenyAll )
    {
	switch ( ::MsgPopup( this,
			     IDS_DENY_ALL_EVERYONE_WARNING,
			     MPSEV_WARNING,
			     MP_YESNO,
			     QueryResName(),
			     MP_NO ))
	{
	case IDYES:
	    break ;

	case IDNO:
	default:
	    return TRUE ;
	}
    }

    if ( WritePermissions( FALSE, FALSE ) )
	Dismiss() ;

    return TRUE ;
}

/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::Initialize

    SYNOPSIS:	Gets the permissions from the resource

    EXIT:	The accperm will be initialized and ready to go else
		the user quit and the user quit flag is set.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

APIERR MAIN_PERM_BASE_DLG::Initialize( BOOL * pfUserQuit, BOOL fAccessPerms )
{
    return GetPermissions( pfUserQuit, fAccessPerms ) ;
}

/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::MayRun

    SYNOPSIS:	Updates window hwnd so correct window will get locked down


    NOTES:

    HISTORY:
	Johnl	30-Oct-1992	Created

********************************************************************/

BOOL MAIN_PERM_BASE_DLG::MayRun( void )
{
    //
    //	Reset the hwnd so it points to this dialog
    //
    QueryAclConverter()->SetWritePermHwnd( QueryHwnd() ) ;
    return TRUE ;
}


/*******************************************************************

    NAME:	MULTI_SUBJ_PERM_BASE_DLG::MULTI_SUBJ_PERM_BASE_DLG

    SYNOPSIS:	Place holder constructor for this class, passes all of
		the parameters along.

    NOTES:	Note that at construction time, we don't know if this dialog
		is read only or not.  The read only flag is set during the
		Initialize call.

    HISTORY:
	Johnl	27-Aug-1991	Created

********************************************************************/

MULTI_SUBJ_PERM_BASE_DLG::MULTI_SUBJ_PERM_BASE_DLG(
			  const TCHAR * 	   pszDialogName,
			  HWND			   hwndParent,
			  const TCHAR * 	   pszDialogTitle,
			  ACL_TO_PERM_CONVERTER  * paclconv,
			  const TCHAR * 	   pszResourceType,
			  const TCHAR * 	   pszResourceName,
			  const TCHAR * 	   pszHelpFileName,
                          ULONG       *            ahcMainDialog )
    : MAIN_PERM_BASE_DLG   ( pszDialogName,
			     hwndParent,
			     pszDialogTitle,
			     paclconv,
			     pszResourceType,
			     pszResourceName,
			     pszHelpFileName,
                             ahcMainDialog ),
      _buttonAdd	   ( this, BUTTON_ADD ),
      _buttonRemove        ( this, BUTTON_REMOVE )
{
    if ( QueryError() )
    {
	UIDEBUG(SZ("MULTI_SUBJ_PERM_BASE_DLG::ct - Parent returned error\n\r")) ;
	return ;
    }
}

MULTI_SUBJ_PERM_BASE_DLG::~MULTI_SUBJ_PERM_BASE_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::Initialize

    SYNOPSIS:	Gets the permissions, fills the listbox and combobox

    EXIT:	The dialog should be ready to go or an error will have
		occurred.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	The Add button will be disabled if this dialog is read only

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_ACCESS_PERM_BASE_DLG::Initialize( BOOL * pfUserQuit,
						    BOOL fAccessPerms )
{
    APIERR err = MAIN_PERM_BASE_DLG::Initialize( pfUserQuit, fAccessPerms ) ;
    if ( err != NERR_Success )
	return err ;
    else if ( *pfUserQuit )
	return NERR_Success ;

    if ( (err = _plbPermissionList->Fill() ) != NERR_Success )
    {
	UIDEBUG(SZ("MULTI_SUBJ_ACCESS_PERM_BASE_DLG::ct - Permission list Fill Failed\n\r")) ;
	return err ;
    }


    if ( !IsReadOnly() )
    {
	/* Fill the combo-box with all of the common permission names.
	 */
	MASK_MAP * pmaskmapPermNames = _accperm.QueryAclConverter()->QueryAccessMap() ;
	BOOL fFromBeginning = TRUE ;
	BOOL fMoreData ;
	NLS_STR nlsPermName( 40 ) ;
	INT iPermPosition = 0 ;

	/* Insert each of the permissions into the permission combo.  The
	 * permissions are inserted in the order they exist in the
	 * MaskMap and alwas at the beginning of the combo box
	 * (i.e., before any "Special Access...").  This is what
	 * iPermPosition is used for.
	 */
	while ( (err = pmaskmapPermNames->EnumStrings( &nlsPermName,
						       &fMoreData,
						       &fFromBeginning,
						       PERMTYPE_GENERAL ))
		       == NERR_Success &&
		fMoreData )
	{
	    if ( _cbPermissionName.InsertItem( iPermPosition++,
					       nlsPermName.QueryPch() ) < 0 )
	    {
		return ERROR_NOT_ENOUGH_MEMORY ;
	    }
	}

	if ( err != NERR_Success )
	    return err ;
    }
    else
    {
	QueryRemoveButton()->Enable( FALSE ) ;
	QueryAddButton()->Enable( FALSE ) ;
    }

    /* If the listbox is empty, then we need to disable the combo box,
     * else initialize it to the currently selected permission in the
     * listbox.  Order is important.
     */
    _psubjlbGroup->UpdateSubjectListbox() ;

    return NERR_Success ;
}


/*******************************************************************

    NAME:	MULTI_SUBJ_PERM_BASE_DLG::OnCommand

    SYNOPSIS:	Looks for the Add or remove button getting pressed

    NOTES:

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

BOOL MULTI_SUBJ_PERM_BASE_DLG::OnCommand( const CONTROL_EVENT & e )
{
    switch ( e.QueryCid() )
    {
    case BUTTON_REMOVE:
	OnDeleteSubject() ;
	break ;

    case BUTTON_ADD:
        {
	    APIERR err = OnAddSubject() ;
	    if ( err != NERR_Success )
	         ::MsgPopup( this, (MSGID) err ) ;
        }
	break ;

    default:
	return MAIN_PERM_BASE_DLG::OnCommand( e ) ;
    }

    return TRUE ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_PERM_BASE_DLG::OnDeleteSubject

    SYNOPSIS:	Default definition for OnDeleteSubject
		and OnAddSubject (does nothing).

    NOTES:

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

void MULTI_SUBJ_PERM_BASE_DLG::OnDeleteSubject( void )
{
    UIASSERT(!SZ("For show only!")) ;
}

APIERR MULTI_SUBJ_PERM_BASE_DLG::OnAddSubject( void )
{
    return NERR_Success ;
}



/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::MULTI_SUBJ_ACCESS_PERM_BASE_DLG

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	Don't do anything with the listbox pointer and the
		group pointer because they haven't been fully constructed
		yet!!

    HISTORY:
	Johnl	6-Aug-1991	Created

********************************************************************/

MULTI_SUBJ_ACCESS_PERM_BASE_DLG::MULTI_SUBJ_ACCESS_PERM_BASE_DLG(
			   const TCHAR *	    pszDialogName,
			   HWND 		    hwndParent,
			   const TCHAR *	    pszDialogTitle,
			   ACL_TO_PERM_CONVERTER *  paclconv,
			   const TCHAR *	    pszResourceType,
			   const TCHAR *	    pszResourceName,
			   const TCHAR *	    pszHelpFileName,
			   SUBJECT_PERM_LISTBOX *   plbPermissionList,
			   SUBJ_LB_GROUP *	    psubjlbGroup,
			   const TCHAR *	    pszSpecialAccessName,
			   const TCHAR *	    pszDefaultPermName,
                           ULONG       *            ahcMainDialog )
    : MULTI_SUBJ_PERM_BASE_DLG( pszDialogName,
				hwndParent,
				pszDialogTitle,
				paclconv,
				pszResourceType,
				pszResourceName,
				pszHelpFileName,
                                ahcMainDialog ),
      _plbPermissionList      ( plbPermissionList ),
      _psubjlbGroup	      ( psubjlbGroup ),
      _cbPermissionName       ( this, CB_PERM_NAME ),
      _sltCBTitle             ( this, SLT_PERM_NAME_TITLE ),
      _pszDefaultPermName     ( pszDefaultPermName )
{
    if ( QueryError() != NERR_Success )
    {
	UIDEBUG(SZ("MULTI_SUBJ_ACCESS_PERM_BASE_DLG::ct - Parent returned error\n\r")) ;
	return ;
    }

    ASSERT( plbPermissionList != NULL ) ;
    ASSERT( psubjlbGroup      != NULL ) ;

    if ( (pszSpecialAccessName != NULL) &&
	 (_cbPermissionName.InsertItem( _cbPermissionName.QueryCount(),
					pszSpecialAccessName )) < 0 )
    {
	ReportError( (APIERR) ERROR_NOT_ENOUGH_MEMORY ) ;
	return ;
    }
}

MULTI_SUBJ_ACCESS_PERM_BASE_DLG::~MULTI_SUBJ_ACCESS_PERM_BASE_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnCommand

    SYNOPSIS:	Typcial OnCommand, catches the Special permission Double-Click

    NOTES:

    HISTORY:
	Johnl		    Created

********************************************************************/

BOOL MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnCommand( const CONTROL_EVENT & e )
{
    switch ( e.QueryCid() )
    {

    /* Double clicking in the Subject listbox brings up the container
     * permissions dialog.  However we do not want to bring it up if the
     * client doesn't allow access to the special permissions dialog
     */
    case LB_SUBJECT_PERMISSIONS:
	if ( e.QueryCode() == LBN_DBLCLK )
	{
	    if ( _plbPermissionList->QuerySpecialAccessName().strlen() > 0 )
	    {
		APIERR err = OnSpecial( _plbPermissionList->QueryItem() ) ;
		if ( err != NERR_Success )
		    ::MsgPopup( this, (MSGID) err ) ;
		_psubjlbGroup->UpdateSubjectListbox() ;
	    }
	}
	break ;


    default:
	return MULTI_SUBJ_PERM_BASE_DLG::OnCommand( e ) ;
    }

    return TRUE ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnDeleteSubject

    SYNOPSIS:	Deletes the current item from the Permission listbox

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

void MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnDeleteSubject( void )
{
    //
    //	If we are about to remove the last item, then move the focus and
    //	defaultness to the OK button.
    //
    if ( _psubjlbGroup->QuerySubjLB()->QueryCount() == 1 )
    {
	_buttonOK.ClaimFocus() ;
        QueryRemoveButton()->MakeDefault() ;
        _buttonOK.MakeDefault() ;
    }

    _plbPermissionList->DeleteCurrentItem() ;
    _psubjlbGroup->UpdateSubjectListbox() ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnAddSubject

    SYNOPSIS:	This method gets called when the user presses the
		"Add" button.  It displays the permission Add dialog.

    RETURNS:	NERR_Success if successful, error code otherwise.

    NOTES:	This puts up the correct dialog based on whether we are looking
		at an NT machine or a Lanman machine.

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnAddSubject( void )
{
    APIERR err = NERR_Success ;
    HWND hWnd = QueryRobustHwnd();

    if ( IsNT() )
    {
	SED_NT_USER_BROWSER_DIALOG * pdlgUserBrows = new
		SED_NT_USER_BROWSER_DIALOG( hWnd,
			 QueryAclConverter()->QueryLocation()->QueryServer(),
			 QueryAclConverter()->QueryAccessMap(),
			 QueryAclConverter()->IsContainer(),
			 QueryDefaultPermName(),
			 QueryHelpFileName(),
                         QueryHelpArray() ) ;


	if ( pdlgUserBrows == NULL )
	    return ERROR_NOT_ENOUGH_MEMORY ;

        InvalidateRect (hWnd, NULL, 0);
        UpdateWindow (hWnd);

	do { // error breakout

	    BOOL fUserPressedOK ;
	    if ( (err = pdlgUserBrows->Process( &fUserPressedOK )) ||
		 !fUserPressedOK )
	    {
		break ;
	    }

	    AUTO_CURSOR niftycursor ;

	    /* Get the permission name and corresponding bitfield(s) the user
	     * selected.
	     */
	    AUTO_CURSOR cursHourGlass ;
	    NLS_STR nlsPermName( 48 ) ;
	    NLS_STR nlsDisplayName( 50 ) ;
	    NLS_STR nlsDomainName( DNLEN ) ;
	    UIASSERT( sizeof(ACCESS_MASK) == sizeof(ULONG)) ;
	    BITFIELD bitPerms( (ULONG) 0 ) ;
	    BITFIELD bitNewObjPerms( (ULONG) 0 ) ;

	    if ( ( err = nlsPermName.QueryError() )    ||
		 ( err = nlsDisplayName.QueryError())  ||
		 ( err = nlsDomainName.QueryError())   ||
		 ( err = bitPerms.QueryError() )       ||
		 ( err = bitNewObjPerms.QueryError() ) ||
		 ( err = pdlgUserBrows->QuerySelectedPermName( &nlsPermName ))||
		 ( err = QueryAclConverter()->QueryLoggedOnDomainInfo(
						   NULL, &nlsDomainName ))    ||
		 ( err = QueryAclConverter()->QueryAccessMap()->
		   StringToBits( nlsPermName, &bitPerms, PERMTYPE_GENERAL )))
	    {
		break ;
	    }

	    BOOL fIsNewPermsSpecified = TRUE ;
	    if ( QueryAclConverter()->IsNewObjectsSupported() )
	    {
		if ( err = QueryAclConverter()->QueryNewObjectAccessMap()->
		   StringToBits( nlsPermName, &bitNewObjPerms, PERMTYPE_GENERAL ))
		{
		    //
		    //	If the object permissions doesn't have this permission
		    //	category, then it should be marked as not specified
		    //
		    if ( err == ERROR_NO_ITEMS )
		    {
			fIsNewPermsSpecified = FALSE ;
			err = NERR_Success ;
		    }
		    else
		    {
			break ;
		    }
		}
	    }

	    /* Iterate though each item selected in the Add dialog and add
	     * it to our permission list.
	     */
	    BROWSER_SUBJECT_ITER iterUserSelection( pdlgUserBrows ) ;
	    BROWSER_SUBJECT * pBrowserSubject ;

	    if ( ! (err = iterUserSelection.QueryError()) )
	    {
		while ( !(err = iterUserSelection.Next( &pBrowserSubject )) &&
			 pBrowserSubject != NULL )
		{
		    ACCESS_PERMISSION * pPerm ;
		    SID_NAME_USE SidType = pBrowserSubject->QueryType() ;
		    if ( SidType == SidTypeUser )
		    {
			/* If this is a remote account, then cast the type
			 * to our own "private" sid name use SubjTypeRemote.
			 */
			if ( pBrowserSubject->QueryUserAccountFlags() &
						   USER_TEMP_DUPLICATE_ACCOUNT)
			{
			    SidType = (SID_NAME_USE) SubjTypeRemote ;
			}
		    }

		    if ( err = pBrowserSubject->QueryQualifiedName(
							&nlsDisplayName,
							&nlsDomainName,
							TRUE ))
		    {
			break ;
		    }

		    SUBJECT * pSubj = new NT_SUBJECT(
					   (PSID) *pBrowserSubject->QuerySid(),
					   nlsDisplayName,
					   SidType,
					   pBrowserSubject->QuerySystemSidType() );
		    if ( err = (pSubj==NULL? ERROR_NOT_ENOUGH_MEMORY :
				pSubj->QueryError()))
		    {
			break ;
		    }

		    /* Deletes the subject automatically if we fail to build the
		     * permission.
		     */
		    err = QueryAclConverter()->BuildPermission(
				 (PERMISSION **)&pPerm,
				 TRUE,
				 pSubj,
				 &bitPerms,
				 QueryAclConverter()->IsNewObjectsSupported() &&
				    fIsNewPermsSpecified ?
				    &bitNewObjPerms : NULL ) ;
		    if (  err ||
			 (err = _accperm.AddPermission( pPerm )) )
		    {
			break ;
		    }
		}
	    }
	} while ( FALSE ) ; // error breakout loop

	delete pdlgUserBrows ;
    }
    else
    {
	/* The following is for Lanman (downlevel) only.
	 */
	RESOURCE_STR nlsDialogTitle( IDS_ADD_PERM_DIALOG_TITLE ) ;
	if ( err = nlsDialogTitle.QueryError() )
	{
	    return err ;
	}

	AUTO_CURSOR autoHourGlass ;
	ADD_PERM_DIALOG *pdlgAddPerm = new ADD_PERM_DIALOG( MAKEINTRESOURCE(IDD_SED_LM_ADD_PERM_DLG),
							    QueryRobustHwnd(),
							    QueryResType(),
							    QueryResName(),
                                                            QueryHelpFileName(),
                                                            QueryHelpArray(),
							    nlsDialogTitle,
							    QueryAccessMap(),
							    *((LOCATION *)QueryAclConverter()->QueryLocation()),
							    QueryDefaultPermName() ) ;

	if ( pdlgAddPerm == NULL )
	    return ERROR_NOT_ENOUGH_MEMORY ;

	BOOL fUserPressedOK ;
	err = pdlgAddPerm->Process( &fUserPressedOK ) ;

	if ( err == NERR_Success && fUserPressedOK )
	{
	    AUTO_CURSOR cursHourGlass ;

	    /* Get the access mask
	     */
	    BITFIELD bitPermMask( (ULONG) 0 ) ;

	    err = pdlgAddPerm->QueryPermBitMask( &bitPermMask ) ;
	    if ( err != NERR_Success )
	    {
		delete pdlgAddPerm ;
		return err ;
	    }

	    /* Grab all of the selections from listbox and add them with the
	     * appropriate permissions to the Add Dialog.
	     */
	    for ( int iNewSubj = 0 ;
		  iNewSubj < pdlgAddPerm->QuerySelectedSubjectCount() ;
		  iNewSubj++ )
	    {
		ACCESS_PERMISSION * pPerm ;

		/* Deletes the subject automatically if we fail to build the
		 * permission.
		 */
		err = QueryAclConverter()->BuildPermission( (PERMISSION **)&pPerm,
							    TRUE,
							    pdlgAddPerm->RemoveSubject(iNewSubj),
							    &bitPermMask ) ;

		if (  err ||
		     (err = _accperm.AddPermission( pPerm )) )
		{
		    break ;
		}
	    }
	}

	delete pdlgAddPerm ;
    }

    /* Now replenish the listbox with the newly added items
     */
    if ( err ||
	 (err = _plbPermissionList->Fill() ) != NERR_Success )
    {
	return err ;
    }

    _psubjlbGroup->UpdateSubjectListbox() ;

    return err ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnSpecial

    SYNOPSIS:	Brings up the default special dialog

    ENTRY:	pAccessPermLBI - the access item to display in the special
		    dialog.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnSpecial( SUBJ_PERM_LBI * pAccessPermLBI )
{
    APIERR err ;

    if ( !pAccessPermLBI->QueryAccessPerm()->IsMapped() )
    {
        ::MsgPopup( this,
                    IDS_NOT_MAPPED_WARNING,
                    MPSEV_WARNING,
                    MP_OK ) ;
        return NERR_Success ;
    }

    NLS_STR nlsDialogTitle( _plbPermissionList->QuerySpecialAccessName() ) ;

    if ( (err = nlsDialogTitle.QueryError() ))
    {
	return err ;
    }

    UIASSERT( pAccessPermLBI != NULL ) ;

    /* If the dialog title has an "..." following it, then strip it (the dialog
     * title is derived from the special access name which generally looks
     * like ("Special Access..." or "Special NEW File Access..." etc.).
     */
    ISTR istrEllipsis( nlsDialogTitle ) ;
    ALIAS_STR nlsEllipsis( SZ("..." ) ) ;
    if ( nlsDialogTitle.strstr( &istrEllipsis, nlsEllipsis ))
    {
	/* Check to make sure the ellipsis is at the end of the string
	 */
	ISTR istrEllipsisEnd( istrEllipsis ) ;
	istrEllipsisEnd += nlsEllipsis.QueryTextLength() ;

	if ( nlsDialogTitle.QueryChar( istrEllipsisEnd ) == TCH('\0'))
	{
	    nlsDialogTitle.DelSubStr( istrEllipsis ) ;
	}
    }

    SPECIAL_DIALOG * pSpecDialog ;
    if ( IsNT() )
    {
	pSpecDialog = new NT_SPECIAL_DIALOG(
			      MAKEINTRESOURCE(IDD_SPECIAL_PERM_DLG),
			      QueryHwnd(),
			      QueryResType(),
			      QueryResName(),
			      QueryHelpFileName(),
			      nlsDialogTitle,
			      pAccessPermLBI->QueryAccessPerm()->QueryAccessBits(),
			      pAccessPermLBI->QueryMaskMap(),
			      pAccessPermLBI->QuerySubject()->QueryDisplayName(),
                              QueryHelpArray(),
			      IsReadOnly() ) ;
    }
    else
    {
	/* This is a downlevel Lanman client
	 */
	pSpecDialog = new SPECIAL_DIALOG(
			      MAKEINTRESOURCE(IDD_SED_LM_SPECIAL_PERM_DLG),
			      QueryHwnd(),
			      QueryResType(),
			      QueryResName(),
			      QueryHelpFileName(),
			      nlsDialogTitle,
			      pAccessPermLBI->QueryAccessPerm()->QueryAccessBits(),
			      pAccessPermLBI->QueryMaskMap(),
			      pAccessPermLBI->QuerySubject()->QueryDisplayName(),
                              QueryHelpArray(),
			      IsReadOnly() ) ;
    }

    if ( pSpecDialog == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY ;
    }

    do { // error breakout loop

	BOOL fUserPressedOK ;
	if ( (err = pSpecDialog->QueryError()) ||
	     (err = pSpecDialog->Process( &fUserPressedOK )))
	{
	    break ;
	}

	_plbPermissionList->InvalidateItem( _plbPermissionList->QueryCurrentItem() ) ;
    } while (FALSE) ;

    delete pSpecDialog ;

    /* We have to refresh the permission name even if an error occurred,
     * otherwise the "Special Accessname" hangs around in the combo box
     */
    pAccessPermLBI->RefreshPermName() ;
    return err ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnNewObjectSpecial

    SYNOPSIS:	Default implementation (does nothing).

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnNewObjectSpecial( SUBJ_PERM_LBI * pSubjPermLBI )
{
    UNREFERENCED( pSubjPermLBI ) ;
    ASSERT(!SZ("For show only!"));
    return NERR_Success ;
}

/*******************************************************************

    NAME:	OBJECT_ACCESS_PERMISSION_DLG::OBJECT_ACCESS_PERMISSION_DLG

    SYNOPSIS:	Basic constructor for Object Access Permission dialog
		This is a real dialog

    ENTRY:	Same as parent

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

OBJECT_ACCESS_PERMISSION_DLG::OBJECT_ACCESS_PERMISSION_DLG(
			   const TCHAR *	    pszDialogName,
			   HWND 		    hwndParent,
			   const TCHAR *	    pszDialogTitle,
			   ACL_TO_PERM_CONVERTER *  paclconv,
			   const TCHAR *	    pszResourceType,
			   const TCHAR *	    pszResourceName,
			   const TCHAR *	    pszHelpFileName,
			   const TCHAR *	    pszSpecialAccessName,
			   const TCHAR *	    pszDefaultPermName,
                           ULONG       *            ahcMainDialog )
    : MULTI_SUBJ_ACCESS_PERM_BASE_DLG( pszDialogName,
				       hwndParent,
				       pszDialogTitle,
				       paclconv,
				       pszResourceType,
				       pszResourceName,
				       pszHelpFileName,
				       &_lbPermissionList,
				       &_subjlbGroup,
				       pszSpecialAccessName,
				       pszDefaultPermName,
                                       ahcMainDialog ),
      _lbPermissionList( this,
			 LB_SUBJECT_PERMISSIONS,
			 &_accperm,
			 pszSpecialAccessName ),
      _subjlbGroup     ((MULTI_SUBJ_ACCESS_PERM_BASE_DLG *) this,
			 &_lbPermissionList,
			 QueryPermNameCombo(),
                         QueryRemoveButton(),
                         QueryComboBoxTitle() )
{
    if ( QueryError() )
    {
	UIDEBUG(SZ("OBJECT_ACCESS_PERMISSION_DLG::ct - Parent or control returned error\n\r")) ;
	UIASSERT(FALSE);     // For debugging purposes
	return ;
    }

    if ( _subjlbGroup.QueryError() )
    {
	ReportError( _subjlbGroup.QueryError() ) ;
	UIDEBUG(SZ("OBJECT_ACCESS_PERMISSION_DLG::ct - _subjlbGroup report error\n\r")) ;
	return ;
    }
}

OBJECT_ACCESS_PERMISSION_DLG::~OBJECT_ACCESS_PERMISSION_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_OBJECT_ACCESS_PERMISSION_DLG::NT_OBJECT_ACCESS_PERMISSION_DLG

    SYNOPSIS:	Basic constructor for Object Access Permission dialog
		This is a real dialog

    ENTRY:	Same as parent

    NOTES:

    HISTORY:
	Johnl	16-Nov-1992	Created

********************************************************************/

NT_OBJECT_ACCESS_PERMISSION_DLG::NT_OBJECT_ACCESS_PERMISSION_DLG(
			   const TCHAR *	    pszDialogName,
			   HWND 		    hwndParent,
			   const TCHAR *	    pszDialogTitle,
			   ACL_TO_PERM_CONVERTER *  paclconv,
			   const TCHAR *	    pszResourceType,
			   const TCHAR *	    pszResourceName,
			   const TCHAR *	    pszHelpFileName,
			   const TCHAR *	    pszSpecialAccessName,
			   const TCHAR *	    pszDefaultPermName,
                           ULONG       *            ahcMainDialog )
    : OBJECT_ACCESS_PERMISSION_DLG( pszDialogName,
				    hwndParent,
				    pszDialogTitle,
				    paclconv,
				    pszResourceType,
				    pszResourceName,
				    pszHelpFileName,
				    pszSpecialAccessName,
				    pszDefaultPermName,
                                    ahcMainDialog ),
      _sleOwner( this, SLE_OWNER )
{
    if ( QueryError() )
    {
	UIDEBUG(SZ("NT_OBJECT_ACCESS_PERMISSION_DLG::ct - Parent or control returned error\n\r")) ;
	return ;
    }
}

NT_OBJECT_ACCESS_PERMISSION_DLG::~NT_OBJECT_ACCESS_PERMISSION_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_OBJECT_ACCESS_PERMISSION_DLG::Initialize

    SYNOPSIS:	Fills in the owner field after we have gotten the
		permissions

    ENTRY:	Same as base Initialize

    HISTORY:
	Johnl	16-Nov-1992	Created

********************************************************************/

APIERR NT_OBJECT_ACCESS_PERMISSION_DLG::Initialize( BOOL * pfUserQuit,
						    BOOL fAccessPerms )
{
    APIERR err = OBJECT_ACCESS_PERMISSION_DLG::Initialize( pfUserQuit,
							    fAccessPerms ) ;
    if ( !err && QueryAclConverter()->QueryOwnerName() != NULL )
    {
	_sleOwner.SetText( QueryAclConverter()->QueryOwnerName() ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_CONT_ACCESS_PERM_BASE::MULTI_SUBJ_CONT_ACCESS_PERM_BASE

    SYNOPSIS:	Basic constructor of the Container access permissions dialog

    NOTES:	If the checkbox title is NULL, then we will disable and hide
		the checkbox.

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

MULTI_SUBJ_CONT_ACCESS_PERM_BASE::MULTI_SUBJ_CONT_ACCESS_PERM_BASE(
		      const TCHAR *	       pszDialogName,
		      HWND		       hwndParent,
		      const TCHAR *	       pszDialogTitle,
		      ACL_TO_PERM_CONVERTER *  paclconv,
		      const TCHAR *	       pszResourceType,
		      const TCHAR *	       pszResourceName,
		      const TCHAR *	       pszHelpFileName,
		      SUBJECT_PERM_LISTBOX *   plbPermissionList,
		      SUBJ_LB_GROUP *	       psubjlbGroup,
		      const TCHAR *	       pszSpecialAccessName,
		      const TCHAR *	       pszDefaultPermName,
                      ULONG       *            ahcMainDialog,
		      const TCHAR *	       pszAssignToExistingContTitle,
		      const TCHAR *	       pszTreeApplyHelpText,
		      const TCHAR *	       pszTreeApplyConfirmation )
    : MULTI_SUBJ_ACCESS_PERM_BASE_DLG( pszDialogName,
				       hwndParent,
				       pszDialogTitle,
				       paclconv,
				       pszResourceType,
				       pszResourceName,
				       pszHelpFileName,
				       plbPermissionList,
				       psubjlbGroup,
				       pszSpecialAccessName,
				       pszDefaultPermName,
                                       ahcMainDialog ),
      _checkAssignToExistingContainers( this, CHECK_APPLY_TO_CONT ),
      _sltfontTreeApplyHelpText       ( this, SLT_TREE_APPLY_HELP_TEXT ),
      _pszTreeApplyConfirmation       ( pszTreeApplyConfirmation )
{
    if ( QueryError() )
	return ;

    if ( pszAssignToExistingContTitle != NULL )
    {
	_checkAssignToExistingContainers.SetText( pszAssignToExistingContTitle ) ;

#if 0
	if ( pszTreeApplyHelpText != NULL )
	{
	    _sltfontTreeApplyHelpText.SetText( pszTreeApplyHelpText ) ;
        }
#endif
    }
    else
    {
	_checkAssignToExistingContainers.Show( FALSE ) ;
	_checkAssignToExistingContainers.Enable( FALSE ) ;
    }
}

/*******************************************************************

    NAME:	MULTI_SUBJ_CONT_ACCESS_PERM_BASE::OnOK

    SYNOPSIS:	Write the permissions out and check the apply to flags
		as appropriate.

    EXIT:	A message will be displayed to the user if an error
		occurred.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

BOOL MULTI_SUBJ_CONT_ACCESS_PERM_BASE::OnOK( void )
{
    APIERR err ;
    BOOL fAssignToTree = FALSE ;

    if ( IsReadOnly() )
    {
	Dismiss( TRUE ) ;
	return TRUE ;
    }

    //
    //  If no grants, warn the user.
    //
    BOOL fIsDenyAll = FALSE ;
    if (  IsNT() &&
          (err = _accperm.AnyDenyAllsToEveryone( &fIsDenyAll )) )
    {
	::MsgPopup( this, (MSGID) err ) ;
	return TRUE ;
    }

    if (  fIsDenyAll )
    {
	switch ( ::MsgPopup( this,
			     IDS_DENY_ALL_EVERYONE_WARNING,
			     MPSEV_WARNING,
			     MP_YESNO,
			     QueryResName(),
			     MP_NO ))
	{
	case IDYES:
	    break ;

	case IDNO:
	default:
	    return TRUE ;
	}
    }


    if ( IsAssignToExistingContChecked() )
    {
	NLS_STR nlsResName(40) ;
	NLS_STR nlsTreeApplyConfirmation( _pszTreeApplyConfirmation ) ;
	if ( (err = nlsResName.QueryError()) ||
	     (err = QueryResName( &nlsResName )) ||
	     (err = nlsTreeApplyConfirmation.InsertParams( 1, &nlsResName )) )
	{
	    ::MsgPopup( this, (MSGID) err ) ;
	    return FALSE ;
	}

	switch ( MsgPopup( this,
			   IDS_PERCENT_1,
			   MPSEV_WARNING,
			   MP_YESNO,
			   nlsTreeApplyConfirmation ))
	{
	case IDYES:
	    fAssignToTree = TRUE ;
	    break ;

	default:
	    UIASSERT(FALSE) ;
	    /* fall through
	     */

	case IDNO:
	    return TRUE ;
	}
    }

    if ( WritePermissions(fAssignToTree,
                          IsAssignToExistingObjChecked(),
			  TREEAPPLY_ACCESS_PERMS ) )
    {
	Dismiss( TRUE ) ;
    }
    else
    {
	//
	// Set the OK button to "Close" if the tree apply failed (ignore any
	// errors).
	//

        if ( fAssignToTree || QueryAclConverter()->IsNewObjectsSupported() )
	{
	    RESOURCE_STR nlsClose( IDS_CLOSE ) ;
	    if ( !nlsClose.QueryError() )
	    {
		_buttonCancel.SetText( nlsClose ) ;
	    }
	}
    }

    return TRUE ;
}

MULTI_SUBJ_CONT_ACCESS_PERM_BASE::~MULTI_SUBJ_CONT_ACCESS_PERM_BASE()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	MULTI_SUBJ_CONT_ACCESS_PERM_BASE::Initialize

    SYNOPSIS:	Disables the tree apply checkbox if we are readonly

    EXIT:	The dialog should be ready to go or an error will have
		occurred.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	The Remove button will be disabled if this dialog is read only

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_CONT_ACCESS_PERM_BASE::Initialize( BOOL * pfUserQuit,
						     BOOL fAccessPerms )
{
    APIERR err = MULTI_SUBJ_ACCESS_PERM_BASE_DLG::Initialize( pfUserQuit,
							      fAccessPerms ) ;

    /* Note that this gets called even if the user cancelled an intermediate
     * message dialog
     */
    if ( !err && IsReadOnly() )
    {
	_checkAssignToExistingContainers.Enable( FALSE ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:       MULTI_SUBJ_CONT_ACCESS_PERM_BASE::IsAssignToExistingObjChecked

    SYNOPSIS:   Returns TRUE if permissions should be applied to existing
                objects, FALSE otherwise

    HISTORY:
        Johnl   31-Mar-1993     Created

********************************************************************/

BOOL MULTI_SUBJ_CONT_ACCESS_PERM_BASE::IsAssignToExistingObjChecked( void )
{
    return FALSE ;
}

/*******************************************************************

    NAME:	CONT_ACCESS_PERM_DLG::CONT_ACCESS_PERM_DLG

    SYNOPSIS:	Basic constructor for the Container access permission dialog
		This is a real dialog.

    ENTRY:	Same as parent

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

CONT_ACCESS_PERM_DLG::CONT_ACCESS_PERM_DLG(
		       const TCHAR *		   pszDialogName,
		       HWND			   hwndParent,
		       const TCHAR *		   pszDialogTitle,
		       ACL_TO_PERM_CONVERTER *	   paclconv,
		       const TCHAR *		   pszResourceType,
		       const TCHAR *		   pszResourceName,
		       const TCHAR *		   pszHelpFileName,
		       const TCHAR *		   pszSpecialAccessName,
		       const TCHAR *		   pszDefaultPermName,
                       ULONG       *               ahcMainDialog,
		       const TCHAR *		   pszAssignToExistingContTitle,
		       const TCHAR *		   pszTreeApplyHelpText,
		       const TCHAR *		   pszTreeApplyConfirmation )
    : MULTI_SUBJ_CONT_ACCESS_PERM_BASE( pszDialogName,
					hwndParent,
					pszDialogTitle,
					paclconv,
					pszResourceType,
					pszResourceName,
					pszHelpFileName,
					&_lbPermissionList,
					&_subjlbGroup,
					pszSpecialAccessName,
					pszDefaultPermName,
                                        ahcMainDialog,
					pszAssignToExistingContTitle,
					pszTreeApplyHelpText,
					pszTreeApplyConfirmation ),
      _lbPermissionList( this, LB_SUBJECT_PERMISSIONS, &_accperm, pszSpecialAccessName ),
      _subjlbGroup( ( MULTI_SUBJ_ACCESS_PERM_BASE_DLG *) this,
		    &_lbPermissionList,
		    QueryPermNameCombo(),
                    QueryRemoveButton(),
                    QueryComboBoxTitle() )
{
    if ( QueryError() )
	return ;
}

/*******************************************************************

    NAME:	CONT_ACCESS_PERM_DLG::OnOK

    SYNOPSIS:	Write the permissions out and check the apply to flags
		as appropriate.

    EXIT:	A message will be displayed to the user if an error
		occurred.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

BOOL CONT_ACCESS_PERM_DLG::OnOK( void )
{
    APIERR err ;
    BOOL fDismissDialog ;
    if ( err = _subjlbGroup.OnEnter( &fDismissDialog ) )
    {
	return err ;
    }

    if ( fDismissDialog )
    {
	return MULTI_SUBJ_CONT_ACCESS_PERM_BASE::OnOK() ;
    }

    return TRUE ;
}

CONT_ACCESS_PERM_DLG::~CONT_ACCESS_PERM_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_CONT_NO_OBJ_ACCESS_PERM_DLG::NT_CONT_NO_OBJ_ACCESS_PERM_DLG

    SYNOPSIS:	Basic constructor for the Container access permission dialog
		This is a real dialog.

    ENTRY:	Same as parent

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

NT_CONT_NO_OBJ_ACCESS_PERM_DLG::NT_CONT_NO_OBJ_ACCESS_PERM_DLG(
		       const TCHAR *		   pszDialogName,
		       HWND			   hwndParent,
		       const TCHAR *		   pszDialogTitle,
		       ACL_TO_PERM_CONVERTER *	   paclconv,
		       const TCHAR *		   pszResourceType,
		       const TCHAR *		   pszResourceName,
		       const TCHAR *		   pszHelpFileName,
		       const TCHAR *		   pszSpecialAccessName,
		       const TCHAR *		   pszDefaultPermName,
                       ULONG       *               ahcMainDialog,
                       const TCHAR *               pszAssignToExistingContTitle,
		       const TCHAR *		   pszTreeApplyHelpText,
		       const TCHAR *		   pszTreeApplyConfirmation )
    : CONT_ACCESS_PERM_DLG( pszDialogName,
			    hwndParent,
			    pszDialogTitle,
			    paclconv,
			    pszResourceType,
			    pszResourceName,
			    pszHelpFileName,
			    pszSpecialAccessName,
			    pszDefaultPermName,
                            ahcMainDialog,
			    pszAssignToExistingContTitle,
			    pszTreeApplyHelpText,
                            pszTreeApplyConfirmation ),
    _sleOwner( this, SLE_OWNER )
{
    if ( QueryError() )
	return ;
}

NT_CONT_NO_OBJ_ACCESS_PERM_DLG::~NT_CONT_NO_OBJ_ACCESS_PERM_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_CONT_NO_OBJ_ACCESS_PERM_DLG::Initialize

    SYNOPSIS:	Fills in the owner field after we have gotten the
		permissions

    ENTRY:	Same as base Initialize

    HISTORY:
	Johnl	16-Nov-1992	Created

********************************************************************/

APIERR NT_CONT_NO_OBJ_ACCESS_PERM_DLG::Initialize( BOOL * pfUserQuit,
						   BOOL fAccessPerms )
{
    APIERR err = CONT_ACCESS_PERM_DLG::Initialize( pfUserQuit,
						   fAccessPerms ) ;
    if ( !err && QueryAclConverter()->QueryOwnerName() != NULL )
    {
	_sleOwner.SetText( QueryAclConverter()->QueryOwnerName() ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERM_DLG::NT_CONT_ACCESS_PERM_DLG

    SYNOPSIS:	Basic constructor for the NT Container access permission dialog
		This is a real dialog.

    ENTRY:	Same as parent

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

NT_CONT_ACCESS_PERM_DLG::NT_CONT_ACCESS_PERM_DLG(
		       const TCHAR *		   pszDialogName,
		       HWND			   hwndParent,
		       const TCHAR *		   pszDialogTitle,
		       ACL_TO_PERM_CONVERTER *	   paclconv,
		       const TCHAR *		   pszResourceType,
		       const TCHAR *		   pszResourceName,
		       const TCHAR *		   pszHelpFileName,
		       const TCHAR *		   pszSpecialAccessName,
		       const TCHAR *		   pszDefaultPermName,
                       ULONG       *               ahcMainDialog,
		       const TCHAR *		   pszNewObjectSpecialAccessName,
		       const TCHAR *		   pszAssignToExistingContTitle,
                       const TCHAR *               pszAssignToExistingObjTitle,
		       const TCHAR *		   pszTreeApplyHelpText,
		       const TCHAR *		   pszTreeApplyConfirmation )
    : MULTI_SUBJ_CONT_ACCESS_PERM_BASE( pszDialogName,
					hwndParent,
					pszDialogTitle,
					paclconv,
					pszResourceType,
					pszResourceName,
					pszHelpFileName,
					&_lbPermissionList,
					&_subjlbGroup,
					pszSpecialAccessName,
					pszDefaultPermName,
                                        ahcMainDialog,
					pszAssignToExistingContTitle,
					pszTreeApplyHelpText,
					pszTreeApplyConfirmation ),
      _lbPermissionList( this, LB_SUBJECT_PERMISSIONS, &_accperm,
			 pszSpecialAccessName, pszNewObjectSpecialAccessName ),
      _subjlbGroup( this,
		    &_lbPermissionList,
		    QueryPermNameCombo(),
                    QueryRemoveButton(),
                    QueryComboBoxTitle() ),
      _sleOwner( this, SLE_OWNER ),
      _checkApplyToExistingObjects( this, CHECK_APPLY_TO_OBJ )
{
    if ( QueryError() )
	return ;

    //
    //  Add the New Object Special Access item to the combo box
    //
    if ( (pszNewObjectSpecialAccessName != NULL) &&
	 (QueryPermNameCombo()->InsertItem( QueryPermNameCombo()->QueryCount(),
					    pszNewObjectSpecialAccessName ) < 0) )
    {
	ReportError( (APIERR) ERROR_NOT_ENOUGH_MEMORY ) ;
	return ;
    }

    //
    //  Set the assign to existing objects checkbox if the string is non-NULL
    //
    if ( pszAssignToExistingObjTitle != NULL )
    {
        _checkApplyToExistingObjects.SetText( pszAssignToExistingObjTitle ) ;
        _checkApplyToExistingObjects.SetCheck( TRUE ) ;
    }
    else
    {
        _checkApplyToExistingObjects.Enable( FALSE ) ;
        _checkApplyToExistingObjects.Show( FALSE ) ;
    }

}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERM_DLG::OnOK

    SYNOPSIS:	Write the permissions out and check the apply to flags
		as appropriate.

    EXIT:	A message will be displayed to the user if an error
		occurred.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

BOOL NT_CONT_ACCESS_PERM_DLG::OnOK( void )
{
    APIERR err ;
    BOOL fDismissDialog ;
    if ( err = _subjlbGroup.OnEnter( &fDismissDialog ) )
    {
	return err ;
    }

    if ( fDismissDialog )
    {
	return MULTI_SUBJ_CONT_ACCESS_PERM_BASE::OnOK() ;
    }

    return TRUE ;
}

NT_CONT_ACCESS_PERM_DLG::~NT_CONT_ACCESS_PERM_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERM_DLG::OnNewObjectSpecial

    SYNOPSIS:	Brings up the New Object special dialog

    ENTRY:	pAccessPermLBI - the access item to display in the special
		    dialog.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_ACCESS_PERM_DLG::OnNewObjectSpecial( SUBJ_PERM_LBI * pAccessPermLBI )
{
    if ( !pAccessPermLBI->QueryAccessPerm()->IsMapped() )
    {
        ::MsgPopup( this,
                    IDS_NOT_MAPPED_WARNING,
                    MPSEV_WARNING,
                    MP_OK ) ;
        return NERR_Success ;
    }

    NLS_STR nlsDialogTitle( ((NT_CONT_SUBJECT_PERM_LISTBOX*)
			    QuerySubjectPermListbox())->
			     QuerySpecialNewObjectAccessName() ) ;
    APIERR err ;

    if ( (err = nlsDialogTitle.QueryError() ))
    {
	return err ;
    }

    UIASSERT( pAccessPermLBI != NULL ) ;

    /* If the dialog title has an "..." following it, then strip it (the dialog
     * title is derived from the special access name which generally looks
     * like ("Special Access..." or "Special File Access..." etc.).
     */
    ISTR istrEllipsis( nlsDialogTitle ) ;
    ALIAS_STR nlsEllipsis( SZ("..." ) ) ;
    if ( nlsDialogTitle.strstr( &istrEllipsis, nlsEllipsis ))
    {
	/* Check to make sure the ellipsis is at the end of the string
	 */
	ISTR istrEllipsisEnd( istrEllipsis ) ;
	istrEllipsisEnd += nlsEllipsis.QueryTextLength() ;

	if ( nlsDialogTitle.QueryChar( istrEllipsisEnd ) == TCH('\0'))
	{
	    nlsDialogTitle.DelSubStr( istrEllipsis ) ;
	}
    }

    NT_CONT_ACCESS_PERMISSION * pntcontperm = (NT_CONT_ACCESS_PERMISSION*)
					    pAccessPermLBI->QueryAccessPerm() ;

    NEW_OBJ_SPECIAL_DIALOG * pSpecDialog = new NEW_OBJ_SPECIAL_DIALOG(
				      MAKEINTRESOURCE(IDD_SED_NEW_OBJ_SPECIAL_PERM_DLG),
				      QueryHwnd(),
				      QueryResType(),
				      QueryResName(),
				      QueryHelpFileName(),
				      nlsDialogTitle,
				      pntcontperm->QueryNewObjectAccessBits(),
				      pAccessPermLBI->QueryNewObjectMaskMap(),
				      pAccessPermLBI->QuerySubject()->QueryDisplayName(),
                                      QueryHelpArray(),
				      IsReadOnly(),
				      pntcontperm->IsNewObjectPermsSpecified() ) ;

    if ( pSpecDialog == NULL )
	return ERROR_NOT_ENOUGH_MEMORY ;

    BOOL fUserPressedOK ;
    if ( ( err = pSpecDialog->QueryError()) ||
	 ( err = pSpecDialog->Process( &fUserPressedOK )))
    {
	return err ;
    }

    if ( fUserPressedOK )
    {
	pntcontperm->SetNewObjectPermsSpecified( !pSpecDialog->IsNotSpecified());

	err = pAccessPermLBI->RefreshPermName() ;
	if ( err != NERR_Success )
	    return err ;

	QuerySubjectPermListbox()->InvalidateItem( QuerySubjectPermListbox()->QueryCurrentItem() ) ;
    }

    delete pSpecDialog ;

    /* We have to refresh the permission name even if an error occurred,
     * otherwise the "Special Accessname" hangs around in the combo box
     */
    pAccessPermLBI->RefreshPermName() ;
    return NERR_Success ;

}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERM_DLG::Initialize

    SYNOPSIS:	Fills in the owner field after we have gotten the
		permissions

    ENTRY:	Same as base Initialize

    HISTORY:
	Johnl	16-Nov-1992	Created

********************************************************************/

APIERR NT_CONT_ACCESS_PERM_DLG::Initialize( BOOL * pfUserQuit,
						    BOOL fAccessPerms )
{
    APIERR err = MULTI_SUBJ_CONT_ACCESS_PERM_BASE::Initialize( pfUserQuit,
							       fAccessPerms ) ;
    if ( !err && QueryAclConverter()->QueryOwnerName() != NULL )
    {
	_sleOwner.SetText( QueryAclConverter()->QueryOwnerName() ) ;
    }

    if ( !err && IsReadOnly() )
        _checkApplyToExistingObjects.Enable( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       MULTI_SUBJ_CONT_ACCESS_PERM_BASE::IsAssignToExistingObjChecked

    SYNOPSIS:   Returns TRUE if permissions should be applied to existing
                objects, FALSE otherwise

    HISTORY:
        Johnl   31-Mar-1993     Created

********************************************************************/

BOOL NT_CONT_ACCESS_PERM_DLG::IsAssignToExistingObjChecked( void )
{
    return _checkApplyToExistingObjects.QueryCheck() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\bin\dummy.cxx ===
extern i ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\subjlb.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    SubjLB.cxx

    This File contains the implementation for the subject and permission
    listboxes.



    FILE HISTORY:
	Johnl	20-Aug-1991	Created
        JonN        14-Oct-1994 Draws bitmaps from SUBJECT_BITMAP_BLOCK

*/
#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
    #include <ntsam.h>
    #include <ntlsa.h>
}

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETLIB
#define INCL_NETGROUP
#define INCL_NETUSER
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>

#include <maskmap.hxx>
#include <colwidth.hxx>

#include <lmouser.hxx>
#include <lmoeusr.hxx>
#include <lmogroup.hxx>
#include <slist.hxx>
#include <security.hxx>
#include <ntacutil.hxx>

#ifndef min
#define min(a,b)  ((a)<(b)?(a):(b))
#endif

#include <permstr.hxx>
#include <perm.hxx>
#include <accperm.hxx>
#include <subject.hxx>
#include <permdlg.hxx>

#include <subjlb.hxx>
#include <usrbrows.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>

extern "C"
{
    #include <lmuidbcs.h>       // NETUI_IsDBCS()
}

DEFINE_SLIST_OF( SUBJECT )

/*******************************************************************

    NAME:	SUBJECT_LISTBOX::SUBJECT_LISTBOX

    SYNOPSIS:	Constructor for Subject listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991
        JonN        14-Oct-1994 Draws bitmaps from SUBJECT_BITMAP_BLOCK

********************************************************************/

SUBJECT_LISTBOX::SUBJECT_LISTBOX( OWNER_WINDOW * pownerwin, CID cid )
    : BLT_LISTBOX( pownerwin, cid ),
      _bmpblock()
{
    if ( QueryError() != NERR_Success )
	return ;

    APIERR err ;
    if ( (err = _bmpblock.QueryError()) != NERR_Success )
    {
	DBGEOL("SUBJECT_LISTBOX::ct - Display maps failed to construct " << err) ;
	ReportError( err ) ;
	return ;
    }

    _anColWidth[0] = _bmpblock.QueryDisplayMap(SidTypeAlias)->QueryWidth() + 2 ;
    _anColWidth[1] = COL_WIDTH_SUBJECT_NAME ;
}

SUBJECT_LISTBOX::~SUBJECT_LISTBOX()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	SUBJECT_LISTBOX::Fill

    SYNOPSIS:	Fill the listbox with SUBJ_PERM_LBI objects, by default, we
		fill the listbox with all of the subjects in the domain.

    ENTRY:	location - Where to get the list of users & groups

    EXIT:

    RETURNS:

    NOTES:	The listbox is first emptied of all items.

		At this level in the hierarchy, we expect to be used only
		for a LM resource.

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/

APIERR SUBJECT_LISTBOX::Fill( LOCATION & location )
{
    AUTO_CURSOR autocursor ;
    BOOL fIsNT ;

    APIERR err = location.CheckIfNT( &fIsNT ) ;
    if ( err )
    {
	return err ;
    }

    if ( fIsNT )
    {
	UIASSERT( FALSE ) ;
	return NERR_Success ;
    }

    DeleteAllItems() ;

    /* Add all of the users to the listbox
     */
    {
	USER0_ENUM user0enum( location ) ;
	// NTRAID#NTBUG9-574280-2002/03/07-artm  Prefast: err declaration hides function level decl.
	// I see no reason why this code needs to hide the variable at the outer scope.
	// Also, why is there an explicit nested scope??
	APIERR err = user0enum.GetInfo() ;
	if ( err != NERR_Success )
	    return err ;

	USER0_ENUM_ITER ue0( user0enum ) ;
	const USER0_ENUM_OBJ * puser0 ;

	while ( (puser0 = ue0( &err )) != NULL )
	{
            if ( err != NERR_Success )
                break;

	    SUBJECT * psubj = new LM_SUBJECT( puser0->QueryName(), FALSE ) ;

	    if ( psubj == NULL )
		return ERROR_NOT_ENOUGH_MEMORY ;

	    err = AddSubject( psubj, TRUE ) ;
	    if ( err != NERR_Success )
	    {
		delete psubj ;
		break;
	    }
	}

        if ( err != NERR_Success )
            return err;
    }

    /* Add all of the groups to the listbox
     */
    {
	GROUP0_ENUM group0enum( location ) ;
	// NTRAID#NTBUG9-574280-2002/03/07-artm  Prefast: err declaration hides function level decl.
	// I see no reason why this code needs to hide the variable at the outer scope.
	// Also, why is there an explicit nested scope??
	APIERR err = group0enum.GetInfo() ;
	if ( err != NERR_Success )
	    return err ;

	GROUP0_ENUM_ITER ue0( group0enum ) ;
	const GROUP0_ENUM_OBJ * pgroup0 ;

	while ( (pgroup0 = ue0()) != NULL )
	{
	    SUBJECT * psubj = new LM_SUBJECT( pgroup0->QueryName(), TRUE ) ;

	    if ( psubj == NULL )
		return ERROR_NOT_ENOUGH_MEMORY ;


	    err = AddSubject( psubj, TRUE ) ;
	    if ( err != NERR_Success )
	    {
		delete psubj ;
		return err ;
	    }
	}
    }

    if ( QueryCount() > 0 )
	SelectItem( 0 ) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJECT_LISTBOX::AddSubject

    SYNOPSIS:	Adds a SUBJECT object to the subject listbox

    ENTRY:	psubj - Pointer to newly created subject

    RETURNS:	Returns NERR_Success if successful, error code otherwise

    NOTES:	If *psubj has its error variable set, then this method
		simply returns that error value

    HISTORY:
	Johnl	13-Aug-1991	Created

********************************************************************/

APIERR SUBJECT_LISTBOX::AddSubject( SUBJECT * psubj,
				    BOOL fDeleteContentsOnDestruction  )
{
    UIASSERT( psubj != NULL ) ;
    if ( psubj->QueryError() != NERR_Success )
	return psubj->QueryError() ;

    SUBJ_LBI * pSubjLBI = new SUBJ_LBI( psubj, fDeleteContentsOnDestruction ) ;
    if ( pSubjLBI == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY ;
    }
    else if ( psubj->QueryError() != NERR_Success )
    {
	APIERR err = psubj->QueryError() ;
	return err ;
    }

    if ( AddItem( pSubjLBI ) < 0 )
    {
	DBGEOL( "SUBJECT_LISTBOX::Fill - AddItem failed" ) ;
	return ERROR_NOT_ENOUGH_MEMORY ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJECT_LISTBOX::QueryDisplayMap

    SYNOPSIS:	Chooses the correct displaymap (group or user) based
		on the passed subject

    ENTRY:	psubj - Pointer to SUBJECT

    RETURNS:	Pointer to appropriate display map

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991	Created
	JohnL	03-Jun-1992	Updated for well known subjects
        DavidHov 22-Mar-1193    Update for c8.  Returned non-const
                                ptr because DM_DTE constructor
                                requires non-const array.
        JonN        14-Oct-1994 Draws bitmaps from SUBJECT_BITMAP_BLOCK

********************************************************************/

DISPLAY_MAP * SUBJECT_LISTBOX::QueryDisplayMap( SUBJECT * psubj )

{
    BOOL fRemote = FALSE;
    SUBJECT_TYPE subjtype = psubj->QueryType();
    if (subjtype == SubjTypeRemote)
    {
        subjtype = SubjTypeUser;
        fRemote = TRUE;
    }

    return _bmpblock.QueryDisplayMap( (SID_NAME_USE)subjtype,
                                      psubj->QuerySystemSubjectType(),
                                      fRemote );
}

/*******************************************************************

    NAME:	SUBJECT_LISTBOX::Remove

    SYNOPSIS:	This method removes all of the subjects contained in the
		passed slist.

    ENTRY:	pslSubjects - Pointer to slist of items to remove

    EXIT:	This subject listbox will no longer contain the passed
		subjects

    RETURNS:	NERR_Success if successful, failure code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

APIERR SUBJECT_LISTBOX::Remove( SLIST_OF( SUBJECT ) * pslSubjects )
{
    ITER_SL_OF( SUBJECT ) itersl( *pslSubjects ) ;
    SUBJECT * pSubj ;

    while ( (pSubj = itersl.Next()) != NULL )
    {
	SUBJ_LBI subjlbiTemp( pSubj, FALSE ) ;

	INT iSearchItem = FindItem( subjlbiTemp ) ;
	if ( iSearchItem >= 0 )
	{
	    DeleteItem( iSearchItem ) ;
	}
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJ_LBI::SUBJ_LBI

    SYNOPSIS:	LBIs that go into the SUBJECT_LISTBOX constructor

    ENTRY:	psubj - Pointer to subject this SUBJ_LBI represents

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/

SUBJ_LBI::SUBJ_LBI( SUBJECT * psubj, BOOL fDeleteContentsOnDestruction )
    : _psubj( psubj ),
      _fDeleteContentsOnDest( fDeleteContentsOnDestruction )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( _psubj != NULL ) ;
}

SUBJ_LBI::~SUBJ_LBI()
{
    if ( _fDeleteContentsOnDest )
	delete _psubj ;

    _psubj = NULL ;
}

/*******************************************************************

    NAME:	SUBJ_LBI::Paint

    SYNOPSIS:	Typical LBI paint method for Subject Permission LBIs

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	    13-Sep-1991 Created
	beng	    08-Oct-1991 Win32 conversion

********************************************************************/

void SUBJ_LBI::Paint( LISTBOX * plb, HDC hdc, const RECT * prect, GUILTT_INFO * pguiltt ) const
{
    SUBJECT_LISTBOX * plbSubj = (SUBJECT_LISTBOX *) plb ;

    DM_DTE dmiddte( plbSubj->QueryDisplayMap( QuerySubject()) )  ;
    STR_DTE strdteUserName( QuerySubject()->QueryDisplayName() ) ;

    DISPLAY_TABLE dt( 2, plbSubj->QueryColumnWidths() ) ;
    dt[0] = &dmiddte ;
    dt[1] = &strdteUserName ;

    dt.Paint( plb, hdc, prect, pguiltt ) ;
}

/*******************************************************************

    NAME:	SUBJ_LBI::Compare

    SYNOPSIS:	Typical LBI compare for sorting purposes

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	Names are sorted on the display names of the subjects

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/

int SUBJ_LBI::Compare( const LBI * plbi ) const
{
    SUBJ_LBI * psubjpermlbi = (SUBJ_LBI *) plbi ;

    return ::strcmpf( QuerySubject()->QueryDisplayName(),
		      psubjpermlbi->QuerySubject()->QueryDisplayName() ) ;
}

WCHAR SUBJ_LBI::QueryLeadingChar( void ) const
{
    ALIAS_STR nls( QuerySubject()->QueryDisplayName() ) ;
    ISTR istr( nls ) ;

    return nls.QueryChar( istr ) ;
}











/*******************************************************************

    NAME:	SUBJECT_PERM_LISTBOX::SUBJECT_PERM_LISTBOX

    SYNOPSIS:	Constructor for permissions listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991

********************************************************************/

SUBJECT_PERM_LISTBOX::SUBJECT_PERM_LISTBOX( OWNER_WINDOW * pownerwin,
					    CID cid,
					    ACCPERM * paccperm,
					    const TCHAR * pszSpecialAccessName )
    : SUBJECT_LISTBOX( pownerwin, cid ),
      _paccperm( paccperm ),
      _nlsSpecialPermName( (MSGID) IDS_GEN_ACCESSNAME_SPECIAL ),
      _nlsSpecialAccessName( pszSpecialAccessName == NULL ? SZ("") : pszSpecialAccessName )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( _paccperm != NULL ) ;

    APIERR err ;
    if ( ( err = _nlsSpecialPermName.QueryError() ) ||
	 ( err = _nlsSpecialAccessName.QueryError() )  )
    {
	DBGEOL( "SUBJECT_PERM_LISTBOX::ct - Display maps failed to construct " << err ) ;
	ReportError( err ) ;
	return ;
    }

    /* This is the permission name field
     */
    _anColWidth[ QueryNextUnusedColumn() ] = COL_WIDTH_AWAP ;

}

SUBJECT_PERM_LISTBOX::~SUBJECT_PERM_LISTBOX()
{
    _paccperm = NULL ;
}

/*******************************************************************

    NAME:	SUBJECT_PERM_LISTBOX::Fill

    SYNOPSIS:	Fill the listbox with SUBJ_PERM_LBI objects that are
		retrieved from the accperm object.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	The listbox is first emptied of all items.

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/

APIERR SUBJECT_PERM_LISTBOX::Fill( void )
{
    SetRedraw( FALSE ) ;
    DeleteAllItems() ;

    ACCESS_PERMISSION * pAccessPerm ;
    BOOL fFromBeginning = TRUE ;

    while ( QueryAccperm()->EnumAccessPermissions( &pAccessPerm, &fFromBeginning ) )
    {
	UIASSERT( pAccessPerm != NULL ) ;

	SUBJ_PERM_LBI * pPermLBI = new SUBJ_PERM_LBI( pAccessPerm,
		       QueryAccperm()->QueryAclConverter()->QueryAccessMap() ) ;

	if ( AddItem( pPermLBI ) < 0 )
	{
	    DBGEOL( "SUBJECT_PERM_LISTBOX::Fill - AddItem failed" ) ;
	    SetRedraw( TRUE ) ;
	    Invalidate( TRUE ) ;
	    return ERROR_NOT_ENOUGH_MEMORY ;
	}
    }

    if ( QueryCount() > 0 )
	SelectItem( 0 ) ;

    SetRedraw( TRUE ) ;
    Invalidate( TRUE ) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJECT_PERM_LISTBOX::SetCurrentPermission

    SYNOPSIS:	The currently selected SUBJ_PERM_LBI will get its
		permission bits set to the name corresponding
		to the passed permission name (must belong to
		the access mask map).

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/


APIERR SUBJECT_PERM_LISTBOX::SetCurrentPermission( const NLS_STR & nlsPermName )
{
    SUBJ_PERM_LBI * pPermLBI = QueryItem() ;

    /* Can't call this method if nothing is selected (Combo should be disabled)
     */
    UIASSERT( pPermLBI != NULL ) ;

    return pPermLBI->SetPermission( nlsPermName ) ;
}

/*******************************************************************

    NAME:	SUBJECT_PERM_LISTBOX::QueryCurrentPermName

    SYNOPSIS:	Gets the string of the currently selected SUBJ_PERM_LBI

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991	Created
********************************************************************/

APIERR SUBJECT_PERM_LISTBOX::QueryCurrentPermName( NLS_STR * pnlsPermName ) const
{
    SUBJ_PERM_LBI * pPermLBI = QueryItem() ;

    /* Can't call this method if nothing is selected (Combo should be disabled)
     */
    UIASSERT( pPermLBI != NULL ) ;

    *pnlsPermName = pPermLBI->QueryPermName() ;

    return pnlsPermName->QueryError() ;
}

/*******************************************************************

    NAME:	SUBJECT_PERM_LISTBOX::DeleteCurrentItem

    SYNOPSIS:	Removes the currently selected item from the listbox

    EXIT:	Updates the listbox and combobox before exitting

    NOTES:

    HISTORY:
	Johnl	21-Aug-1991	Created

********************************************************************/

void SUBJECT_PERM_LISTBOX::DeleteCurrentItem( void )
{
    SUBJ_PERM_LBI * pPermLBI = QueryItem() ;
    UIASSERT( pPermLBI != NULL ) ;

    REQUIRE( QueryAccperm()->DeletePermission( pPermLBI->QueryAccessPerm() ) ) ;

    INT i = QueryCurrentItem() ;
    UIASSERT( i >= 0 ) ;

    DeleteItem( i ) ;
    INT cItems = QueryCount() ;

    if ( cItems > 0 )
	SelectItem( min( i, cItems - 1 ) ) ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::SUBJ_PERM_LBI_BASE

    SYNOPSIS:	LBIs that go into the SUBJECT_PERM_LISTBOX constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	DON'T CALL RefreshPermName from this constructor!!  It will
		call this->RefreshPermName and not the derived refreshpermname

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/

SUBJ_PERM_LBI_BASE::SUBJ_PERM_LBI_BASE( SUBJECT * pSubj, MASK_MAP * pmaskmap )
    : SUBJ_LBI( pSubj ),
      _pMaskMap( pmaskmap ),
      _nlsPermName( 48 )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( _pMaskMap != NULL ) ;

    if ( _nlsPermName.QueryError() != NERR_Success )
    {
	ReportError( _nlsPermName.QueryError() ) ;
	return ;
    }
}

SUBJ_PERM_LBI_BASE::~SUBJ_PERM_LBI_BASE()
{
    _pMaskMap = NULL ;
}

ACCESS_PERMISSION * SUBJ_PERM_LBI_BASE::QueryAccessPerm( void ) const
{
    UIASSERT(!SZ("Did you forget to redefine derived QueryAccessPerm?") ) ;
    return NULL ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::Paint

    SYNOPSIS:	Typical LBI paint method for Subject Permission LBIs

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	    20-Aug-1991 Created
	beng	    08-Oct-1991 Win32 conversion

********************************************************************/

void SUBJ_PERM_LBI_BASE::Paint( LISTBOX * plb, HDC hdc, const RECT * prect, GUILTT_INFO * pguiltt ) const
{
    SUBJECT_PERM_LISTBOX * plbperm = (SUBJECT_PERM_LISTBOX *) plb ;

    NLS_STR nlsPermName( _nlsPermName ) ;
    NLS_STR nlsMnemonics( 15 ) ;

    APIERR err = NERR_Success ;
    if ( (err = nlsPermName.QueryError())  ||
         (err = nlsMnemonics.QueryError()) ||
         !plbperm->IsMnemonicsDisplayed()           ||
	 (err = BuildPermMnemonic( QueryAccessPerm(),
				   QueryMaskMap(),
				   &nlsMnemonics )) ||
	 (err = nlsPermName.AppendChar( TCH(' ')))  ||
	 (err = nlsPermName.Append( nlsMnemonics ))   )
    {
	/* Non-Fatal error, fall through
	 */
    }

    //
    //	Get the new item permission mnemonics if they are supported
    //	and the container mnemonics aren't empty
    //
    if ( !err &&
         QueryAccessPerm()->IsNewObjectPermsSupported() &&
         (nlsMnemonics.strlen() > 0) &&
         plbperm->IsMnemonicsDisplayed() )
    {
	if ((err = BuildPermMnemonic( QueryAccessPerm(),
				      QueryNewObjectMaskMap(),
				      &nlsMnemonics,
				      TRUE	    )) ||
	    (err = nlsPermName.AppendChar( TCH(' ')))  ||
	    (err = nlsPermName.Append( nlsMnemonics ))	 )
	{
	    /* Non-Fatal error, fall through
	     */
	}
    }

    DM_DTE dmiddte( plbperm->QueryDisplayMap( QuerySubject() ) ) ;
    STR_DTE strdteUserName( QuerySubject()->QueryDisplayName() ) ;
    STR_DTE strdtePermName( err ? _nlsPermName : nlsPermName ) ;

    DISPLAY_TABLE dt( 3, plbperm->QueryColumnWidths() ) ;
    dt[0] = &dmiddte ;
    dt[1] = &strdteUserName ;
    dt[2] = &strdtePermName ;

    dt.Paint( plb, hdc, prect, pguiltt ) ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::RefreshPermName

    SYNOPSIS:	After the bitmask has been changed, call this to update
		its permission string.

    EXIT:	The lbi will be updated with the appropriate permission name

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

APIERR SUBJ_PERM_LBI_BASE::RefreshPermName( void )
{
    APIERR err ;

    err = QueryMaskMap()->BitsToString( *(QueryAccessPerm()->QueryAccessBits()),
					&_nlsPermName,
					PERMTYPE_GENERAL ) ;

    if ( (err != NERR_Success) && (err != ERROR_NO_ITEMS) )
    {
	DBGEOL( "SUBJ_PERM_LBI_BASE::ct - BitsToString Failed" << err ) ;
	return err ;
    }

    /* If the bitmask doesn't correspond to a PERMTYPE_GENERAL permission,
     * (thus it wasn't found by BitsToString) we will assign the "Special"
     * keyword to this bitmask.
     */
    if ( err == ERROR_NO_ITEMS )
    {

	if ( (err = _nlsPermName.Load( (MSGID) IDS_GEN_ACCESSNAME_SPECIAL)) ||
	     (err = QueryAccessPerm()->SaveSpecial())				     )
	{
	    return err ;
	}
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::SetPermission

    SYNOPSIS:	This method sets the bits of this permission based
		on the passed string.  The string should correspond
		to a string in the mask map.

    ENTRY:	nlsPermName - Permission name to set the permission bits to.

    EXIT:	The permission bits will be changed to the bits that
		correspond to the permission name.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	26-Sep-1991	Created

********************************************************************/

APIERR SUBJ_PERM_LBI_BASE::SetPermission( const NLS_STR & nlsPermName )
{
    APIERR err = QueryAccessPerm()->SetPermission( nlsPermName,
						   QueryMaskMap(),
						   QueryNewObjectMaskMap() ) ;
    if ( !err )
	err = SetPermName( nlsPermName ) ;

    return err ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::QueryNewObjectMaskMap

    SYNOPSIS:	Return the new object mask map

    RETURNS:	Pointer to this LBI's mask map object

    NOTES:	At this level we don't have a mask map so we return NULL

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

MASK_MAP * SUBJ_PERM_LBI_BASE::QueryNewObjectMaskMap( void ) const
{
    return NULL ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI::SUBJ_PERM_LBI

    SYNOPSIS:	Basic constructor

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

SUBJ_PERM_LBI::SUBJ_PERM_LBI( ACCESS_PERMISSION * pAccessPerm,
			      MASK_MAP * pmaskmap )
	: SUBJ_PERM_LBI_BASE( (SUBJECT *) pAccessPerm->QuerySubject(), pmaskmap ),
	  _pAccessPerm( pAccessPerm )
{
    APIERR err = RefreshPermName() ;
    if ( err )
    {
	ReportError( err ) ;
	return ;
    }
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI::QueryAccessPerm

    SYNOPSIS:	Virtual access method to get to the underlying ACCESS_PERMISSION
		object

    RETURNS:	Pointer to the access permission

    NOTES:

    HISTORY:
	Johnl	26-Sep-1991	Created

********************************************************************/

ACCESS_PERMISSION * SUBJ_PERM_LBI::QueryAccessPerm( void ) const
{
    return _pAccessPerm ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI::~SUBJ_PERM_LBI

    SYNOPSIS:	Small destructor

    NOTES:

    HISTORY:
	Johnl	26-Sep-1991	Created

********************************************************************/

SUBJ_PERM_LBI::~SUBJ_PERM_LBI()
{
    _pAccessPerm = NULL ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJECT_PERM_LISTBOX::NT_CONT_SUBJECT_PERM_LISTBOX

    SYNOPSIS:	Typical constructor for the NT Container subject permission
		listbox.

    ENTRY:	Same as parent
		pszSpecialNewObjectAccessName - String that brings up the
		New Sub-Object Special dialog

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

NT_CONT_SUBJECT_PERM_LISTBOX::NT_CONT_SUBJECT_PERM_LISTBOX( OWNER_WINDOW * pownerwin,
					    CID cid,
					    ACCPERM * paccperm,
					    const TCHAR * pszSpecialAccessName,
					    const TCHAR * pszSpecialNewObjectAccessName )
    : SUBJECT_PERM_LISTBOX( pownerwin, cid, paccperm, pszSpecialAccessName ),
      _nlsSpecialNewObjectAccessName( pszSpecialNewObjectAccessName == NULL ? SZ("")
					       : pszSpecialNewObjectAccessName )
{
    if ( QueryError() != NERR_Success )
	return ;

    /* _nlsSpecialNewObjectAccessName is an ALIAS_STR
     */
    UIASSERT( !_nlsSpecialNewObjectAccessName.QueryError() ) ;
}

NT_CONT_SUBJECT_PERM_LISTBOX::~NT_CONT_SUBJECT_PERM_LISTBOX()
{
    /* Nothing to do */
}


/*******************************************************************

    NAME:	NT_CONT_SUBJECT_PERM_LISTBOX::Fill

    SYNOPSIS:	Fill the listbox with NT_CONT_SUBJ_PERM_LBI objects that are
		retrieved from the accperm object.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	The listbox is first emptied of all items.

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_SUBJECT_PERM_LISTBOX::Fill( void )
{
    SetRedraw( FALSE ) ;
    DeleteAllItems() ;

    NT_CONT_ACCESS_PERMISSION * pAccessPerm ;
    BOOL fFromBeginning = TRUE ;

    while ( QueryAccperm()->EnumAccessPermissions( (ACCESS_PERMISSION **)&pAccessPerm, &fFromBeginning ) )
    {
	UIASSERT( pAccessPerm != NULL ) ;

	NT_CONT_SUBJ_PERM_LBI * pPermLBI = new NT_CONT_SUBJ_PERM_LBI( pAccessPerm,
		       QueryAccperm()->QueryAclConverter()->QueryAccessMap(),
		       QueryAccperm()->QueryAclConverter()->QueryNewObjectAccessMap() ) ;

	if ( AddItem( pPermLBI ) < 0 )
	{
	    DBGEOL( "NT_CONT_SUBJECT_PERM_LISTBOX::Fill - AddItem failed" ) ;
	    SetRedraw( TRUE ) ;
	    Invalidate( TRUE ) ;
	    return ERROR_NOT_ENOUGH_MEMORY ;
	}
    }

    if ( QueryCount() > 0 )
	SelectItem( 0 ) ;

    SetRedraw( TRUE ) ;
    Invalidate( TRUE ) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_PERM_LBI::NT_CONT_SUBJ_PERM_LBI

    SYNOPSIS:	Basic constructor

    ENTRY:	Same as parent
		pNTContAccessPerm - Access permission this LBI will
		    display
		pNewObjectMaskMap - Mask map to use for the new object
		    permissions

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

NT_CONT_SUBJ_PERM_LBI::NT_CONT_SUBJ_PERM_LBI(
			   NT_CONT_ACCESS_PERMISSION * pNTContAccessPerm,
			   MASK_MAP * pmaskmap,
			   MASK_MAP * pNewObjectMaskMap )
    : SUBJ_PERM_LBI_BASE( (SUBJECT *) pNTContAccessPerm->QuerySubject(), pmaskmap ),
      _pNTContAccessPerm( pNTContAccessPerm ),
      _pNewObjectMaskMap( pNewObjectMaskMap )
{
    APIERR err = RefreshPermName() ;
    if ( err )
    {
	ReportError( err ) ;
	return ;
    }
}


/*******************************************************************

    NAME:	NT_CONT_SUBJ_PERM_LBI::RefreshPermName

    SYNOPSIS:	Updates this LBI's permission name based on the current
		access bits

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created
	Johnl	16-Jan-1991	Changed to not call parent (have to check
				strings resolve to same name).

********************************************************************/

APIERR NT_CONT_SUBJ_PERM_LBI::RefreshPermName( void )
{
    APIERR err	    = NERR_Success ;
    BOOL   fFound   = FALSE ;
    int    nID ;
    BITFIELD bitContPerm( (ULONG) 0 ) ;
    BITFIELD bitNewObjPerm( (ULONG) 0 ) ;

    if ( (err = bitContPerm.QueryError()) ||
	 (err = bitNewObjPerm.QueryError()) )
    {
	return err ;
    }

    //
    //  If the permissions aren't propagated, then this is automatically a
    //  special permission
    //

    if ( !QueryAccessPerm()->IsContainerPermsInheritted() )
    {
        fFound = FALSE ;
    }
    else
    {
        /* Loop through each high level container permission looking for a match
         * between the container permission and the mask map entry.  If a match
         * is found, then check for a match with the new object permissions.  If
         * they match, then we have found the correct permissions name, otherwise
         * keep looking.  If none match, then this is a special permission.
         */
        UINT cTotalItems = QueryMaskMap()->QueryCount() ;
        for ( UINT i = 0 ; i < cTotalItems && !fFound && !err ; i++ )
        {

            if ( !(err = QueryMaskMap()->QueryBits( i,
                                                    &bitContPerm,
                                                    &_nlsPermName,
                                                    &nID ))            &&
                 (nID == PERMTYPE_GENERAL)                             &&
                 (bitContPerm == *QueryAccessPerm()->QueryAccessBits())  )
            {
                /* The container permissions match, but do the new object
                 * permissions?
                 */

                if ( err = QueryNewObjectMaskMap()->StringToBits(
                                                              _nlsPermName,
                                                              &bitNewObjPerm,
                                                              PERMTYPE_GENERAL))
                {
                    /* If err is ERROR_NO_ITEMS then assume the permission category
                     * didn't specify New object permissions.  Which means
                     * we may match if this subject doesn't have new object
                     * permissions specified
                     */
                    if ( err == ERROR_NO_ITEMS )
                    {
                        err = NERR_Success ;

                        if ( !_pNTContAccessPerm->IsNewObjectPermsSpecified() )
                        {
                            fFound = TRUE ;
                        }
                    }
                }
                else if ( _pNTContAccessPerm->IsNewObjectPermsSpecified() &&
                          (bitNewObjPerm == *_pNTContAccessPerm->
                                              QueryNewObjectAccessBits()))
                {
                    fFound = TRUE ;
                }
            }
        }
    }

    if ( !err )
    {
	if ( !fFound )
	{
	    if ( (err = _nlsPermName.Load( (MSGID) IDS_GEN_ACCESSNAME_SPECIAL)) ||
		 (err = QueryAccessPerm()->SaveSpecial()) )
	    {
		/* Fall through and return */
	    }
	}
    }

    return err ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::::BuildPermMnemonic

    SYNOPSIS:	Builds a string that contains the letter mnemonics
		contained in the special permission strings.

    ENTRY:	pAccessPerm - Access permission to build the mnemonic for
		pmaskmapPerms - Mask Map to use for retrieving the mnemonics
		pnlsMnemonics - Pointer to the string that will receive the
		    Mnemonic
		fIsNewPerm - TRUE if we should build the mnemonic for the
		    new item permissions specified for this access permission

    EXIT:	*pnlsMnemonics will contain one of:

		    1) A valid mnemonic such as "(RWX)"
		    2) The empty string if no mnemonics were found
		    3) "(Not Specified)" if New perms are not specified
		    4) "(None)" if no perms are granted
                    5) "(All)" if all perms are granted
                    6) "(Partial)" if we can't represent this perm

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	We expect the permission names in the mask map to look
		like:  "Perm Name (P)"

    HISTORY:
	Johnl	09-Mar-1992	Created

********************************************************************/

APIERR SUBJ_PERM_LBI_BASE::BuildPermMnemonic(
				       ACCESS_PERMISSION * pAccessPerm,
				       MASK_MAP 	 * pmaskmapPerms,
				       NLS_STR		 * pnlsMnemonics,
				       BOOL		   fIsNewPerm ) const
{
    UIASSERT( pnlsMnemonics != NULL && !(pnlsMnemonics->QueryError()) ) ;
    UIASSERT( !fIsNewPerm ||
	      (fIsNewPerm && pAccessPerm->IsNewObjectPermsSupported()) ) ;

    BITFIELD * pBits = !fIsNewPerm ? pAccessPerm->QueryAccessBits() :
				     pAccessPerm->QueryNewObjectAccessBits() ;
    UIASSERT( pBits != NULL ) ;
    APIERR err = NERR_Success ;

    //
    //  Special case the Not specified, No Access, Partial and All cases
    //
    if ( !pAccessPerm->IsMapped() )
    {
        //
        //  Only supply a mnemonic for the container if this is a container
        //
        if ( !pAccessPerm->IsNewObjectPermsSupported() ||
             !fIsNewPerm )
        {
            err = pnlsMnemonics->Load( IDS_NOT_MAPPED_MNEMONIC ) ;
        }
        else
            *pnlsMnemonics = SZ("") ;
    }
    else if (  pAccessPerm->IsNewObjectPermsSupported() &&
               fIsNewPerm                               &&
               !pAccessPerm->IsNewObjectPermsSpecified() )
    {
	err = pnlsMnemonics->Load( IDS_NOT_SPECIFIED_MNEMONIC ) ;
    }
    else if ( pAccessPerm->IsDenyAll( *pBits ) )
    {
	err = pnlsMnemonics->Load( IDS_NO_ACCESS_MNEMONIC ) ;
    }
    else if ( pAccessPerm->IsGrantAll( *pBits ) )
    {
	err = pnlsMnemonics->Load( IDS_FULL_ACCESS_MNEMONIC ) ;
    }
    else
    {
	/* Need to build the mnemonic by hand
	 */
	NLS_STR  nlsPermName( 32 ) ;
	BITFIELD bitsMask   ( *pBits ) ;  // Initialize size
	BITFIELD bitsScratch( *pBits ) ;
	BITFIELD bitsPerm   ( *pBits ) ;
	int	 nPermID ;

	*pnlsMnemonics = SZ("") ;
	if ( (err = pnlsMnemonics->AppendChar(MNEMONIC_START_CHAR)) ||
	     (err = nlsPermName.QueryError() )		   ||
	     (err = bitsMask.QueryError() )		   ||
	     (err = bitsPerm.QueryError() )		     )
	{
	    return err ;
	}

	UINT cNumElem = pmaskmapPerms->QueryCount() ;
	for ( UINT i = 0 ; i < cNumElem ; i++ )
	{
	    if ( err = pmaskmapPerms->QueryBits( i,
						 &bitsMask,
						 &nlsPermName,
						 &nPermID ))
	    {
		return err ;
	    }

	    /* If the permission we are looking at in the mask map is a
	     *	  special permission and the access mask contains all
	     *	  of the bits in this special permission, then append the
	     *	  letter mnemonic.
	     */
	    bitsScratch =  bitsMask ;
	    bitsScratch &= bitsPerm ;
	    if ( (nPermID == PERMTYPE_SPECIAL)	  &&
		 ( bitsScratch == bitsMask)   )
	    {
		ISTR istrMnemonicStart( nlsPermName ) ;
		if ( nlsPermName.strchr( &istrMnemonicStart,
					 MNEMONIC_SEARCH_CHAR ))
		{
		    /* Loop through the mnemonic character list appending to
		     * the end of the mnemonic string.
		     */
		    while ((nlsPermName.QueryChar(++istrMnemonicStart )
							     !=TCH('\0')) &&
			   (nlsPermName.QueryChar(  istrMnemonicStart )
						     != MNEMONIC_END_CHAR ))
		    {
                        /* #2687 23-Oct-93 v-katsuy */
		        /* In Japan, accelerators format is "File(&F)".
		         * And in this case, resource strings as "File(&F) (F)".
		         * OK, We use accelerators for nemonic strings without '&'.
		         */
		        if (   NETUI_IsDBCS()
                            && nlsPermName.QueryChar( istrMnemonicStart ) == TCH('&'))
                        {
		            continue;
                        }
			if ( err = pnlsMnemonics->AppendChar(
				  nlsPermName.QueryChar( istrMnemonicStart )))

			{
			    return err ;
			}
		    } // while
		}
	    }
	} // for

	/* If we actually added any mnemonics (other then the openning "("),
	 *     then close the string.
	 * Otherwise
	 *     Make the string the empty string.
	 */
	if ( pnlsMnemonics->QueryNumChar() > 1 )
	{
	    err = pnlsMnemonics->AppendChar(MNEMONIC_END_CHAR) ;
	}
	else
	{
	    *pnlsMnemonics = SZ("") ;
	    err = pnlsMnemonics->QueryError() ;
	}
    }

    //
    //  Lastly, we may need to append a marker indicating this permission
    //  will not be propagated to new containers.
    //
    //   if (    this is the new perm mnemonic and Object perms supported
    //        OR Object perms are not supported
    //        AND container perms aren't inheritted
    //
    if ( !err )
    {
        if ( ( (!fIsNewPerm &&
                pAccessPerm->IsNewObjectPermsSupported()
               ) ||
               (!pAccessPerm->IsNewObjectPermsSupported())
             ) &&
	     !pAccessPerm->IsContainerPermsInheritted() )
	{
	    err = pnlsMnemonics->AppendChar(MNEMONIC_NOT_INHERITTED_MARKER) ;
	}
    }

    return err ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_PERM_LBI::QueryAccessPerm

    SYNOPSIS:	Virtual access method to get to the underlying ACCESS_PERMISSION
		object

    RETURNS:	Pointer to the access permission

    NOTES:

    HISTORY:
	Johnl	26-Sep-1991	Created

********************************************************************/

ACCESS_PERMISSION * NT_CONT_SUBJ_PERM_LBI::QueryAccessPerm( void ) const
{
    return _pNTContAccessPerm ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_PERM_LBI::QueryNewObjectMaskMap

    SYNOPSIS:	Return the new object mask map

    RETURNS:	Pointer to this LBI's mask map object

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

MASK_MAP * NT_CONT_SUBJ_PERM_LBI::QueryNewObjectMaskMap( void ) const
{
    return _pNewObjectMaskMap ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_PERM_LBI::~NT_CONT_SUBJ_PERM_LBI

    SYNOPSIS:	Small destructor

    NOTES:

    HISTORY:
	Johnl	26-Sep-1991	Created

********************************************************************/

NT_CONT_SUBJ_PERM_LBI::~NT_CONT_SUBJ_PERM_LBI()
{
    _pNewObjectMaskMap = NULL ;
    _pNTContAccessPerm= NULL ;
}

/*******************************************************************

    NAME:	SUBJ_LB_GROUP::SUBJ_LB_GROUP

    SYNOPSIS:	Subject listbox group constructor

    ENTRY:	pOwnerDlg - Pointer to dialog that owns us.  This is so
			    we have access to the OnSpecial and
			    OnNewObjectSpecial methods.
		plbSubj - Pointer to listbox this group will deal with
		pcbPermName - Pointer to combobox that is linked to the
			listbox
		pbuttonRemove - Pointer to remove button that is grayed
                        when the listbox is empty.
                psltCBTitle - Combo box title (grayed when combo is disabled)

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

SUBJ_LB_GROUP::SUBJ_LB_GROUP( MULTI_SUBJ_ACCESS_PERM_BASE_DLG * pOwnerDlg,
			      SUBJECT_PERM_LISTBOX * plbSubj,
			      COMBOBOX		   * pcbPermName,
                              PUSH_BUTTON          * pbuttonRemove,
                              SLT                  * psltCBTitle )

    : _pOwnerDlg        ( pOwnerDlg ),
      _plbSubj          ( plbSubj ),
      _pcbPermName      ( pcbPermName ),
      _pbuttonRemove    ( pbuttonRemove ),
      _psltCBTitle      ( psltCBTitle ),
      _fEnabled         ( TRUE ),
      _fIsDropped       ( FALSE ),
      _fOnSpecialHandled( TRUE )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( pOwnerDlg      != NULL ) ;
    UIASSERT( plbSubj	     != NULL ) ;
    UIASSERT( pcbPermName    != NULL ) ;
    UIASSERT( pbuttonRemove  != NULL ) ;

    /* We don't set the buttons to be part of this group since we don't
     * care if they "change" state.  We only need to disable them if the
     * listbox is emptied or is readonly.
     */
    plbSubj->SetGroup( this ) ;
    pcbPermName->SetGroup( this ) ;
}


/*******************************************************************

    NAME:	SUBJ_LB_GROUP::OnUserAction

    SYNOPSIS:	This method handles the cooridination of information between
		the Permissions combo-box and the permissions listbox.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	If the combo is dropped down and the message is a selection
		change method, then ignore it.

    HISTORY:
	Johnl	    20-Aug-1991 Created
	beng	    08-Oct-1991 Win32 conversion

********************************************************************/

APIERR SUBJ_LB_GROUP::OnUserAction( CONTROL_WINDOW * pcw,
				    const CONTROL_EVENT & e )
{
    if ( pcw == QueryPermNameCombo() )
    {
	/* We can never become enabled by the combobox, only the listbox
	 * changing can enable us
	 */
	if ( !IsEnabled() )
	    return GROUP_NO_CHANGE ;

	switch ( e.QueryCode() )
	{
	case CBN_DROPDOWN:
	    SetDropDownFlag( TRUE ) ;
	    break ;

        case CBN_CLOSEUP:
            SetDropDownFlag( FALSE ) ;
            if ( !IsOnSpecialHandled() )
	    {
		NLS_STR nlsPermName( 40 ) ;
		APIERR err = QueryPermNameCombo()->QueryItemText( &nlsPermName ) ;
		if ( err != NERR_Success )
		    return err ;
		return UpdatePermNameCombo( nlsPermName ) ;
            }
            else
            {
                SetOnSpecialHandled( FALSE ) ;
            }
	    break ;

	case CBN_SELCHANGE:
	    if ( IsDroppedDown() )
	    {
		break ;
	    }
	    else
	    {
		NLS_STR nlsPermName( 40 ) ;
		APIERR err = QueryPermNameCombo()->QueryItemText( &nlsPermName ) ;
		if ( err != NERR_Success )
		    return err ;
		return UpdatePermNameCombo( nlsPermName ) ;
	    }
	    break ;

	default:
	    break ;
	}
    }
    else
    {
	UIASSERT( pcw == QuerySubjLB() ) ;
	// C7 CODEWORK - remove Glock-pacifier cast
	if ( pcw->QueryEventEffects( (const CONTROL_EVENT &)e ) & CVMI_VALUE_CHANGE )
	    return UpdateSubjectListbox() ;
    }

    return GROUP_NO_CHANGE ;
}

/*******************************************************************

    NAME:	SUBJ_LB_GROUP::UpdateSubjectListbox

    SYNOPSIS:	The listbox has changed so we need to update the listbox
		and update the associated combo box.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	22-Aug-1991	Created

********************************************************************/

APIERR SUBJ_LB_GROUP::UpdateSubjectListbox( void )
{
    /* If the listbox is empty, then we need to disable all of the controls
     * that operate on items in the listbox.
     */
    if ( QuerySubjLB()->QueryCount() == 0 )
    {
	if ( IsEnabled() )
	{
	    Enable( FALSE ) ;
	}

	return NERR_Success ;
    }
    else if ( !IsEnabled() && QuerySubjLB()->QueryCount() > 0 )
    {
	Enable( TRUE ) ;
    }

    APIERR err ;
    NLS_STR nlsPermName( 40 ) ;

    if ( (err = nlsPermName.QueryError()) ||
	 (err = QuerySubjLB()->QueryCurrentPermName( &nlsPermName )))
    {
	return err ;
    }

    /* If the dialog is read only, then we need to add and remove the
     * permission names in the combo as opposed to just selecting
     * existing names.
     */
    if ( IsReadOnly() )
    {
	/* If the new selection is the same as the old selection, then leave
	 * it, else remove the old selection and put in the new selection.
	 */
	if ( nlsPermName != *QueryLastROSelection() )
	{
	    INT i = QueryPermNameCombo()->FindItemExact( *QueryLastROSelection() ) ;

	    /* Only delete it if we found it (we won't find it the first
	     * time through here)
	     */
	    if ( i >= 0 )
	    {
		QueryPermNameCombo()->DeleteItem( i ) ;
	    }

	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    if ( ((i = QueryPermNameCombo()->InsertItem( 0, nlsPermName )) <0) ||
		 (err = SetLastROSelection( nlsPermName )) )
	    {
		// fall through
	    }
	}

	/* Reset the combo to the correct permission name
	 */
	INT i = QueryPermNameCombo()->FindItemExact( nlsPermName ) ;
	if ( i >= 0 )
	{
	    QueryPermNameCombo()->SelectItem( i ) ;
	}

	return err ;
    }

    /* The user just changed the listbox, so reflect the changes in
     * the combo box by selecting the corresponding permission name
     */
    INT i = QueryPermNameCombo()->FindItemExact( nlsPermName ) ;
    if ( i >= 0 )
    {
	QueryPermNameCombo()->SelectItem( i ) ;

	/* If the new permission name is not the "Special" permission name,
	 * then we need to remove the "Special" permission name if it was
	 * there from the previous selection.
	 */
	if ( nlsPermName != QuerySubjLB()->QuerySpecialPermName() )
	{
	    INT iSpec = QueryPermNameCombo()->FindItemExact(
			      QuerySubjLB()->QuerySpecialPermName() ) ;
	    if ( iSpec >= 0 )
		REQUIRE( QueryPermNameCombo()->DeleteItem( iSpec ) ) ;
	}
    }
    else
    {
	/* The user selected "Special" in the listbox, which isn't in
	 * the combo box, so we need to add it.
	 */

	UIASSERT( nlsPermName == QuerySubjLB()->QuerySpecialPermName() ) ;

	if ( QueryPermNameCombo()->AddItem( nlsPermName ) < 0 )
	    return ERROR_NOT_ENOUGH_MEMORY ;

	i = QueryPermNameCombo()->FindItemExact( QuerySubjLB()->QuerySpecialPermName() ) ;
	UIASSERT( i >= 0 ) ;
	QueryPermNameCombo()->SelectItem( i ) ;

	/* Since the current permission is a special permission, save it
	 */
	SUBJ_PERM_LBI * pPermLBI = QuerySubjLB()->QueryItem() ;
	UIASSERT( pPermLBI != NULL ) ;
	err = pPermLBI->QueryAccessPerm()->SaveSpecial() ;
	if ( err != NERR_Success )
	    return err ;

    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJ_LB_GROUP::UpdatePermNameCombo

    SYNOPSIS:	The permission name combo has been twiddled, so we need
		to update the listbox appropriately

    ENTRY:	nlsPermName - New permission name the user just selected in
		the combo

    EXIT:

    RETURNS:

    CAVEATS:	The name is slightly misleading, it should more appropriately
		read UpdateListboxFromPermNameCombo

    NOTES:	This will only be called when we truly wish to change the
		selection (i.e., not when we are dropped down).

    HISTORY:
	Johnl	22-Aug-1991	Created

********************************************************************/

APIERR SUBJ_LB_GROUP::UpdatePermNameCombo( const NLS_STR & nlsPermName )
{
    APIERR err ;

    /* The combobox changed so we need to update the listbox.
     */

    if ( nlsPermName == QuerySubjLB()->QuerySpecialAccessName() )
    {
	/* Throw up the special access dialog
	 */
	SUBJ_PERM_LBI * pPermLBI = QuerySubjLB()->QueryItem() ;
	if ( (err = QueryOwnerDlg()->OnSpecial( pPermLBI )) == NERR_Success )
	{
	    if ( (err = pPermLBI->RefreshPermName()) == NERR_Success )
		err = UpdateSubjectListbox() ;
	}
	return err ;
    }

    err = QuerySubjLB()->SetCurrentPermission( nlsPermName ) ;
    if ( err != NERR_Success )
	return err ;

    QuerySubjLB()->InvalidateItem( QuerySubjLB()->QueryCurrentItem() ) ;

    return NERR_Success ;
}


/*******************************************************************

    NAME:	SUBJ_LB_GROUP::OnEnter

    SYNOPSIS:	Notifies the group the user hit enter (thus the dialog is
		about to be dismissed).  This method gives us a chance
		to say "Hey! Don't do that!" and bring up a dialog if
		necessary.

		This method implements the behaviour of the user dropping
		the permission combo, selecting a "Special ..." permission
		and hitting enter, which brings up the dialog.

    ENTRY:

    EXIT:	pfDismissDialog is set to TRUE if it is OK to go ahead and
		dismiss the dialog, else it is set to FALSE because we have
		brought up our own dialog.

    RETURNS:	NERR_Success if successful, error code otherwise (if an
		error occurred, then pfDismissDialog should be ignored).

    NOTES:

    HISTORY:
	Johnl	30-Sep-1991	Created

********************************************************************/

APIERR SUBJ_LB_GROUP::OnEnter( BOOL * pfDismissDialog )
{
    /* If the permname combo isn't dropped down, then we don't need
     * to do anything.
     */
    if ( !IsDroppedDown() )
    {
	*pfDismissDialog = TRUE ;
	return NERR_Success ;
    }

    /* They have the permission combo dropped down, if it is just a permission
     * selection, then we will set the permission and return, otherwise it
     * is a "Special ..." selection, thus we need to bring up a dialog
     * as appropriate.
     */
    NLS_STR nlsComboSelection ;
    APIERR err = QueryPermNameCombo()->QueryItemText( &nlsComboSelection ) ;
    if ( err != NERR_Success )
	return err ;

    if ( nlsComboSelection == QuerySubjLB()->QuerySpecialAccessName() )
    {
	/* Throw up the special access dialog
	 */
	SUBJ_PERM_LBI * pPermLBI = QuerySubjLB()->QueryItem() ;
	if ( (err = QueryOwnerDlg()->OnSpecial( pPermLBI )) == NERR_Success )
	{
	    if ( (err = pPermLBI->RefreshPermName()) == NERR_Success )
		err = UpdateSubjectListbox() ;
        }

        SetOnSpecialHandled( TRUE ) ;
	*pfDismissDialog = FALSE ;
        return err ;
    }

    err = QuerySubjLB()->SetCurrentPermission( nlsComboSelection ) ;
    if ( err != NERR_Success )
	return err ;

    QuerySubjLB()->InvalidateItem( QuerySubjLB()->QueryCurrentItem() ) ;

    *pfDismissDialog = TRUE ;
    return NERR_Success ;
}


/*******************************************************************

    NAME:	SUBJ_LB_GROUP::Enable

    SYNOPSIS:	Enables or disables the appropriate components of this
		group

    ENTRY:	fEnable - TRUE if the group should be enabled, FALSE to
			  disable the group

    EXIT:	The remove button will be grayed, the perm. combo will
		be disabled and have its selection removed.

    NOTES:	If the data is read only, then this method will disable the
		the Remove buttons also.

    HISTORY:
	Johnl	22-Aug-1991	Created

********************************************************************/


void SUBJ_LB_GROUP::Enable( BOOL fEnable )
{
    _fEnabled = fEnable ;

    if ( !fEnable )
    {
	QueryPermNameCombo()->RemoveSelection() ;
    }

    QueryPermNameCombo()->Enable( fEnable ) ;
    QueryPermNameLabel()->Enable( fEnable ) ;
    QueryRemoveButton()->Enable( !IsReadOnly() && fEnable ) ;
}


/*******************************************************************

    NAME:	SUBJ_LB_GROUP::IsReadOnly

    SYNOPSIS:	Returns TRUE if the dialog this group is contained in is
		read only.

    NOTES:

    HISTORY:
	Johnl	05-May-1992	Moved from header because of circular
				dependencies.

********************************************************************/

BOOL SUBJ_LB_GROUP::IsReadOnly( void ) const
{
    return (((SUBJ_LB_GROUP *) this)->QueryOwnerDlg())->IsReadOnly() ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_LB_GROUP::UpdatePermNameCombo

    SYNOPSIS:	We just check to see if the new selection is the
		New Object Access choice, if so, we bring up the new
		object access dialog, otherwise we just pass the
		message on to the parent.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	This will only be called when we truly wish to change the
		selection (i.e., not when we are dropped down).

    HISTORY:
	Johnl	22-Aug-1991	Created

********************************************************************/

APIERR NT_CONT_SUBJ_LB_GROUP::UpdatePermNameCombo( const NLS_STR & nlsNewPermName )
{
    if ( nlsNewPermName == QueryNTContSubjLB()->QuerySpecialNewObjectAccessName() )
    {
	/* Throw up the new object special access dialog
	 */
	SUBJ_PERM_LBI * pPermLBI = QuerySubjLB()->QueryItem() ;
	APIERR err = QueryOwnerDlg()->OnNewObjectSpecial( pPermLBI ) ;
	if ( err == NERR_Success )
	{
	     if ( (err = pPermLBI->RefreshPermName()) == NERR_Success )
		err = UpdateSubjectListbox() ;
	}
	return err ;
    }

    return SUBJ_LB_GROUP::UpdatePermNameCombo( nlsNewPermName ) ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_LB_GROUP::OnEnter

    SYNOPSIS:	Notifies the group the user hit enter (thus the dialog is
		about to be dismissed).  This method gives us a chance
		to say "Hey! Don't do that!" and bring up a dialog if
		necessary.

		This method implements the behaviour of the user dropping
		the permission combo, selecting a "Special ..." permission
		and hitting enter, which brings up the dialog.

    ENTRY:

    EXIT:	pfDismissDialog is set to TRUE if it is OK to go ahead and
		dismiss the dialog, else it is set to FALSE because we have
		brought up our own dialog.

    RETURNS:	NERR_Success if successful, error code otherwise (if an
		error occurred, then pfDismissDialog should be ignored).

    NOTES:

    HISTORY:
	Johnl	30-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_SUBJ_LB_GROUP::OnEnter( BOOL * pfDismissDialog )
{
    /* If the permname combo isn't dropped down, then we don't need
     * to do anything.
     */
    if ( !IsDroppedDown() )
    {
	*pfDismissDialog = TRUE ;
	return NERR_Success ;
    }

    /* They have the permission combo dropped down, if it is just a permission
     * selection, then we will set the permission and return, otherwise it
     * is a "Special ..." selection, thus we need to bring up a dialog
     * as appropriate.
     */
    NLS_STR nlsComboSelection ;
    APIERR err = QueryPermNameCombo()->QueryItemText( &nlsComboSelection ) ;
    if ( err != NERR_Success )
	return err ;

    if ( nlsComboSelection == QueryNTContSubjLB()->QuerySpecialNewObjectAccessName() )
    {
	/* Throw up the special access dialog
	 */
	SUBJ_PERM_LBI * pPermLBI = QuerySubjLB()->QueryItem() ;
	if ( (err = QueryOwnerDlg()->OnNewObjectSpecial( pPermLBI )) == NERR_Success )
	{
	    if ( (err = pPermLBI->RefreshPermName()) == NERR_Success )
		err = UpdateSubjectListbox() ;
        }

        SetOnSpecialHandled( TRUE ) ;
	*pfDismissDialog = FALSE ;
	return err ;
    }

    return SUBJ_LB_GROUP::OnEnter( pfDismissDialog ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\sedapi.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    SEDApi.cxx

    This file contains the public security editor APIs.



    FILE HISTORY:
	Johnl	26-Dec-1991	Created

*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
    #include <ntlsa.h>
    #include <ntioapi.h>
    #include <ntsam.h>
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>
#include <dbgstr.hxx>

#include <security.hxx>
#include <lmodom.hxx>
#include <uintsam.hxx>
#include <uintlsa.hxx>
#include <ntacutil.hxx>
#include <maskmap.hxx>

#include <accperm.hxx>
#include <aclconv.hxx>
#include <permstr.hxx>

#include <specdlg.hxx>
#include <add_dlg.hxx>
#include <permdlg.hxx>
#include <perm.hxx>
#include <uitrace.hxx>

#include <owner.hxx>

extern "C"
{
    #include <sedapi.h>
    #include <lmuidbcs.h>       // NETUI_IsDBCS()
}

#include <ipermapi.hxx>

/* Private prototype
 */
DWORD
I_NTAclEditor(
	HWND			     Owner,
	HANDLE			     Instance,
	LPTSTR			     Server,
	PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
	PSED_APPLICATION_ACCESSES    ApplicationAccesses,
	LPTSTR			     ObjectName,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR		     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntReadAcl,
        BOOLEAN                      CantWriteDacl,
	LPDWORD 		     SEDStatusReturn,
        BOOLEAN                      fAccessPerms,
        DWORD                        dwFlags
	) ;

/*************************************************************************

    NAME:	TAKE_OWNERSHIP_WITH_CALLOUT

    SYNOPSIS:	Simple derived class that simply calls the passed callback
		function when the user presses the Take Ownership button.

    INTERFACE:

    PARENT:	TAKE_OWNERSHIP_DLG

    USES:

    CAVEATS:

    NOTES:

    HISTORY:
	Johnl	13-Feb-1992	Created

**************************************************************************/

class TAKE_OWNERSHIP_WITH_CALLOUT : public TAKE_OWNERSHIP_DLG
{
private:
    PSED_FUNC_APPLY_SEC_CALLBACK _pfuncApplySecurityCallbackRoutine ;
    ULONG_PTR   	 _ulCallbackContext ;
    HWND			 _hwndParent ;
    HANDLE			 _hInstance ;

    /* Stores the status returned by the security callback during dialog
     * processing.
     */
    DWORD			 _dwStatus ;

public:
    TAKE_OWNERSHIP_WITH_CALLOUT(
			HWND	      hwndParent,
			HANDLE	      hInstance,
			const TCHAR * pszServer,
			UINT	      uiCount,
			const TCHAR * pchResourceType,
			const TCHAR * pchResourceName,
			PSECURITY_DESCRIPTOR psecdesc,
			ULONG_PTR     ulCallbackContext,
			PSED_FUNC_APPLY_SEC_CALLBACK pfuncApplySecurityCallback,
                        PSED_HELP_INFO psedhelpinfo
			       ) ;

    virtual APIERR OnTakeOwnership( const OS_SECURITY_DESCRIPTOR & ossecdescNewOwner ) ;

    DWORD QuerySEDStatus( void ) const
	{ return _dwStatus ; }
} ;

/*******************************************************************

    NAME:	SedTakeOwnership

    SYNOPSIS:	Displays the current owner of the passed security
		descriptor and allows the user to set the owner to
		themselves.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	JohnL	12-Feb-1992	Created

********************************************************************/

DWORD
SedTakeOwnership(
	HWND			     Owner,
	HANDLE			     Instance,
	LPTSTR			     Server,
	LPTSTR			     ObjectTypeName,
	LPTSTR			     ObjectName,
	UINT			     CountOfObjects,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR			     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntReadOwner,
        BOOLEAN                      CantWriteOwner,
	LPDWORD 		     SEDStatusReturn,
        PSED_HELP_INFO               HelpInfo,
        DWORD                        Flags
	)
{
	// NTRAID#NTBUG9-584127-2002/03/22-artm  Need to validate parms for robustness.
	// See description in RAID.
    APIERR err = NERR_Success ;

    if ( (ObjectTypeName == NULL		) ||
         (ApplySecurityCallbackRoutine == NULL  ) ||
         (Flags != 0)  )

    {
	UIDEBUG(SZ("::SedTakeOwnership - Invalid parameter\n\r")) ;
	*SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return ERROR_INVALID_PARAMETER ;
    }

    if ( CouldntReadOwner && CantWriteOwner )
    {
        err = ERROR_ACCESS_DENIED ;
        ::MsgPopup( Owner, (MSGID) err ) ;
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
        return err ;
    }

    if ( CouldntReadOwner && !CantWriteOwner )
    {
	switch (MsgPopup( Owner,
			  (MSGID)IERR_OWNER_CANT_VIEW_CAN_EDIT,
			  MPSEV_WARNING,
			  MP_YESNO ))
	{
	case IDYES:
	    break ;

	case IDNO:
	    *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	    return NO_ERROR ;

	default:
	    UIASSERT(FALSE) ;
	    break ;
	}
    }

    TAKE_OWNERSHIP_WITH_CALLOUT dlgTakeOwner( Owner,
					      Instance,
					      Server,
					      CountOfObjects,
					      ObjectTypeName,
					      ObjectName,
					      SecurityDescriptor,
					      CallbackContext,
					      ApplySecurityCallbackRoutine,
                                              HelpInfo ) ;

    if ( err = dlgTakeOwner.Process() )
    {
	DBGEOL(SZ("::SedTakeOwnerShip - dlgTakeOwner failed to construct, error code ") << (ULONG) err ) ;
	MsgPopup( Owner, (MSGID) err ) ;
	*SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return err ;
    }

    *SEDStatusReturn = dlgTakeOwner.QuerySEDStatus() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SedDiscretionaryAclEditor

    SYNOPSIS:	Public API for DACL editting.  See SEDAPI.H for a complete
		description of the parameters.

    RETURNS:	One of the SED_STATUS_* return codes

    NOTES:

    HISTORY:
	Johnl	27-Dec-1991	Created

********************************************************************/

DWORD
SedDiscretionaryAclEditor(
	HWND			     Owner,
	HANDLE			     Instance,
	LPTSTR			     Server,
	PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
	PSED_APPLICATION_ACCESSES    ApplicationAccesses,
	LPTSTR			     ObjectName,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR			     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntReadDacl,
        BOOLEAN                      CantWriteDacl,
        LPDWORD                      SEDStatusReturn,
        DWORD                        Flags
	)
{
    return I_NTAclEditor( Owner,
			  Instance,
			  Server,
			  ObjectType,
			  ApplicationAccesses,
			  ObjectName,
			  ApplySecurityCallbackRoutine,
			  CallbackContext,
			  SecurityDescriptor,
                          CouldntReadDacl,
                          CantWriteDacl,
			  SEDStatusReturn,
                          TRUE,
                          Flags ) ;
}

/*******************************************************************

    NAME:	SedSystemAclEditor

    SYNOPSIS:	Public API for SACL editting.  See SEDAPI.H for a complete
		description of the parameters.

    RETURNS:	One of the SED_STATUS_* return codes

    NOTES:

    HISTORY:
	Johnl	27-Dec-1991	Created

********************************************************************/

DWORD
SedSystemAclEditor(
	HWND			     Owner,
	HANDLE			     Instance,
	LPTSTR			     Server,
	PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
	PSED_APPLICATION_ACCESSES    ApplicationAccesses,
	LPTSTR			     ObjectName,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR			     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntReadWriteSacl,
        LPDWORD                      SEDStatusReturn,
        DWORD                        Flags
	)
{
    return I_NTAclEditor( Owner,
			  Instance,
			  Server,
			  ObjectType,
			  ApplicationAccesses,
			  ObjectName,
			  ApplySecurityCallbackRoutine,
			  CallbackContext,
			  SecurityDescriptor,
                          CouldntReadWriteSacl,
                          CouldntReadWriteSacl,
			  SEDStatusReturn,
                          FALSE,
                          Flags ) ;
}

/*******************************************************************

    NAME:	I_NTAclEditor

    SYNOPSIS:   Private API for ACL editting.  The parameters are the
		same as SedDiscretionaryAclEditor and SedSystemAclEditor
		except for one additional parameter, which is:

		fAccessPerms - TRUE if we are going to edit a DACL, FALSE
		    if we are going to edit a SACL

    RETURNS:	NERR_Success if successful, error code otherwise.

    NOTES:	If the ObjectType Name contains an accelerator, then it will
		be removed from the title of the dialog (i.e., "&File" will
		be changed to "File" for the dialog title).

    HISTORY:
	Johnl	27-Dec-1991	Created

********************************************************************/

DWORD
I_NTAclEditor(
	HWND			     Owner,
	HANDLE			     Instance,
	LPTSTR			     Server,
	PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
	PSED_APPLICATION_ACCESSES    ApplicationAccesses,
	LPTSTR			     ObjectName,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR			     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntReadAcl,
        BOOLEAN                      CantWriteAcl,
	LPDWORD 		     SEDStatusReturn,
        BOOLEAN                      fAccessPerms,
        DWORD                        Flags
	)
{
	// NTRAID#NTBUG9-584127-2002/03/22-artm  Need to validate parms for robustness.
	// See description in RAID.
    APIERR err ;
    AUTO_CURSOR niftycursor ;

    if ( (ApplicationAccesses == NULL		) ||
	 (ApplySecurityCallbackRoutine == NULL	) ||
         (ObjectType->Revision != SED_REVISION1 ) ||
         (Flags != 0)  )
    {
	UIDEBUG(SZ("::AclEditor - ApplicationAccesses Ptr, SedCallBack or revision\n\r")) ;
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return ERROR_INVALID_PARAMETER ;
    }

    //
    //  Kick 'em out if they can't read or write the resource
    //
    if ( CouldntReadAcl && CantWriteAcl )
    {
        err = fAccessPerms ? ERROR_ACCESS_DENIED : ERROR_PRIVILEGE_NOT_HELD ;
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
        return err ;
    }

#ifdef DEBUG
    {
	UIDEBUG(SZ("::AclEditor - Converting the following Security Descriptor:\n\r")) ;
	OS_SECURITY_DESCRIPTOR tmp( SecurityDescriptor ) ;
	UIASSERT( tmp.IsValid() ) ;
	tmp.DbgPrint() ;
    }
#endif

    /* Build the access masks from the array of permission mappings the
     * client passed in.
     */
    MASK_MAP AccessMap, NewObjectAccessMap, AuditAccessMap ;
    UIASSERT( sizeof( ACCESS_MASK ) == sizeof( ULONG ) ) ;
    BITFIELD bitAccess1( (ULONG) 0 ),
             bitAccess2( (ULONG) 0 ) ;
    BOOL fUseMnemonics = FALSE ;

    if ( ( err = AccessMap.QueryError() )	  ||
	 ( err = NewObjectAccessMap.QueryError()) ||
	 ( err = AuditAccessMap.QueryError())	  ||
	 ( err = bitAccess1.QueryError() )	   ||
	 ( err = bitAccess2.QueryError() )  )
    {
	UIDEBUG(SZ("::AclEditor - Mask map construction failure\n\r")) ;
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return err ;
    }

    for ( ULONG i = 0 ; (i < ApplicationAccesses->Count) && !err ; i++ )
    {
	bitAccess1 = (ULONG) ApplicationAccesses->AccessGroup[i].AccessMask1 ;
	bitAccess2 = (ULONG) ApplicationAccesses->AccessGroup[i].AccessMask2 ;
	UIASSERT( !bitAccess1.QueryError() && !bitAccess2.QueryError() ) ;
        UIASSERT( ApplicationAccesses->AccessGroup[i].PermissionTitle != NULL ) ;

        if ( ApplicationAccesses->AccessGroup[i].PermissionTitle == NULL )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }
        ALIAS_STR nlsPermName( ApplicationAccesses->AccessGroup[i].PermissionTitle ) ;
        ISTR istrStartMnem( nlsPermName ) ;

        //
        //  If the client doesn't specify any mnemonics, then we don't want
        //  to show "(All)", "(None)" etc.
        //
        if ( !fUseMnemonics &&
             nlsPermName.strchr( &istrStartMnem, MNEMONIC_START_CHAR ) )
        {
            fUseMnemonics = TRUE ;
        }


	if ( (fAccessPerms &&
	      ApplicationAccesses->AccessGroup[i].Type == SED_DESC_TYPE_AUDIT)||
	     (ApplicationAccesses->AccessGroup[i].AccessMask1 ==
					   ACCESS_MASK_NEW_OBJ_NOT_SPECIFIED))
	{
	    DBGEOL("::AclEditor - Audit type for access permission or "
		   << " not specified access mask for container/object perms") ;
	    err = ERROR_INVALID_PARAMETER ;
	    continue ;
	}

	switch ( ApplicationAccesses->AccessGroup[i].Type )
	{
	case SED_DESC_TYPE_RESOURCE:
	    /* We don't allow this type of permission description if new
	     * objects are supported.
	     */
	    if ( ObjectType->AllowNewObjectPerms )
	    {
		UIASSERT(!SZ("Invalid object description")) ;
		err = ERROR_INVALID_PARAMETER ;
		break ;
	    }

	    err = AccessMap.Add( bitAccess1, nlsPermName, PERMTYPE_GENERAL ) ;
	    break ;

	case SED_DESC_TYPE_RESOURCE_SPECIAL:
	    err = AccessMap.Add( bitAccess1, nlsPermName, PERMTYPE_SPECIAL ) ;
	    break ;

	case SED_DESC_TYPE_NEW_OBJECT_SPECIAL:
	    err = NewObjectAccessMap.Add( bitAccess1,
					  nlsPermName,
					  PERMTYPE_SPECIAL ) ;
	    break ;

	case SED_DESC_TYPE_AUDIT:
	    err = AuditAccessMap.Add( bitAccess1,
				      nlsPermName,
				      PERMTYPE_SPECIAL ) ;
	    break ;

	case SED_DESC_TYPE_CONT_AND_NEW_OBJECT:
	    err = AccessMap.Add( bitAccess1, nlsPermName, PERMTYPE_GENERAL ) ;
	    if ( !err &&
		 ACCESS_MASK_NEW_OBJ_NOT_SPECIFIED != (ULONG) bitAccess2 )
	    {
		err = NewObjectAccessMap.Add( bitAccess2,
					      nlsPermName,
					      PERMTYPE_GENERAL ) ;
	    }
	    break ;

	default:
	    UIASSERT(!SZ("::AclEditor - Bad permission description")) ;
	    err = ERROR_INVALID_PARAMETER ;
	}
    }


    if ( err )
    {
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return err;
    }

    NT_ACL_TO_PERM_CONVERTER ntaclconv(
			  (const TCHAR *) Server,
			  (const TCHAR *) ObjectName,
			  fAccessPerms ? &AccessMap : NULL,
			  (fAccessPerms && ObjectType->AllowNewObjectPerms?
				  &NewObjectAccessMap : NULL),
			  !fAccessPerms ? &AuditAccessMap : NULL,
			  ObjectType->IsContainer,
			  ObjectType->AllowNewObjectPerms,
			  SecurityDescriptor,
                          ObjectType->GenericMapping,
                          ObjectType->AllowNewObjectPerms ?
                              ObjectType->GenericMappingNewObjects :
                              ObjectType->GenericMapping,
			  ObjectType->MapSpecificPermsToGeneric,
                          CouldntReadAcl,
                          CantWriteAcl,
			  ApplySecurityCallbackRoutine,
			  CallbackContext,
                          Instance,
                          SEDStatusReturn,
                          fUseMnemonics  ) ;

    /* We construct nlsObjectType using an NLS_STR (as opposed to an ALIAS_STR)
     * because nlsObjectType might be NULL.  We need to insert the correct
     * object tile into the dialog's title (i.e., "NT Directory Permissions").
     */
    NLS_STR	 nlsObjectType( (const TCHAR *) ObjectType->ObjectTypeName ) ;
    RESOURCE_STR nlsDialogTitle( fAccessPerms ? IDS_NT_OBJECT_PERMISSIONS_TITLE:
						IDS_NT_OBJECT_AUDITS_TITLE  ) ;

    if ( (err = ntaclconv.QueryError())      ||
	 (err = nlsDialogTitle.QueryError()) ||
	 (err = nlsObjectType.QueryError())  ||
	 (err = nlsDialogTitle.InsertParams( nlsObjectType ))  )
    {
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return err ;
    }

    /* Watch for any "(&?)" accelerators in the object type and remove them if
     * found (we don't want the ampersand to show up in the dialog title box).
     * In Japan, accelerators format is "(&?)".
	 */
    ISTR istrAccelStart( nlsDialogTitle ) ;
    if (   NETUI_IsDBCS() /* #2894 22-Oct-93 v-katsuy */
        && nlsDialogTitle.strchr( &istrAccelStart, TCH('(') ))
    {
	/* We found an "(", if next is not "&", then ignore it
	 */
	ISTR istrAccelNext( istrAccelStart ) ;
	if ( nlsDialogTitle.QueryChar( ++istrAccelNext ) == TCH('&'))
	{
	    /* We found an "&", if it is doubled, then ignore it, else remove these
	     */
	    if ( nlsDialogTitle.QueryChar( ++istrAccelNext ) != TCH('&'))
	    {
	    	/* we don't want "(&?) " (include space)
	    	 */
	    	istrAccelNext += 3 ;
	        nlsDialogTitle.DelSubStr( istrAccelStart, istrAccelNext ) ;
	    }
	}
    }
    /* Watch for any "&" accelerators in the object type and remove them if
     * found (we don't want the ampersand to show up in the dialog title box).
     */
    else if (   !NETUI_IsDBCS() /* #2894 22-Oct-93 v-katsuy */
             && nlsDialogTitle.strchr( &istrAccelStart, TCH('&') ))
    {
	/* We found an "&", if it is doubled, then ignore it, else remove it
	 */
	ISTR istrAmpersand( istrAccelStart ) ;
	if ( nlsDialogTitle.QueryChar( ++istrAmpersand ) != TCH('&'))
	{
	    nlsDialogTitle.DelSubStr( istrAccelStart, istrAmpersand ) ;
	}
    }

    err = I_GenericSecurityEditor(
	    Owner,
	    &ntaclconv,
	    fAccessPerms ? SED_ACCESSES : SED_AUDITS,
	    TRUE,
	    ObjectType->IsContainer,
	    ObjectType->AllowNewObjectPerms,
	    nlsDialogTitle,
	    ObjectType->ObjectTypeName,
	    ObjectName,
	    ObjectType->SpecialObjectAccessTitle,
	    ApplicationAccesses->DefaultPermName,
	    ObjectType->HelpInfo->pszHelpFileName,
            ObjectType->HelpInfo->aulHelpContext,
	    ObjectType->SpecialNewObjectAccessTitle,
            ObjectType->ApplyToSubContainerTitle,
            ObjectType->ApplyToObjectsTitle,
            NULL,
	    ObjectType->ApplyToSubContainerConfirmation ) ;

    if ( err )
    {
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
    }

    return err ;
}


/*******************************************************************

    NAME:	TAKE_OWNERSHIP_WITH_CALLOUT::TAKE_OWNERSHIP_WITH_CALLOUT

    SYNOPSIS:	Simply constructor for ownership with callback dialog

    ENTRY:	ulCallbackContext - Callback context to be passed to the
		    callback function
		pfuncApplySecurityCallback - Pointer to function to apply
		    the new owner security descriptor to.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	13-Feb-1992	Created

********************************************************************/

TAKE_OWNERSHIP_WITH_CALLOUT::TAKE_OWNERSHIP_WITH_CALLOUT(
		    HWND	  hwndParent,
		    HANDLE	  hInstance,
		    const TCHAR * pszServer,
		    UINT	  uiCount,
		    const TCHAR * pchResourceType,
		    const TCHAR * pchResourceName,
		    PSECURITY_DESCRIPTOR psecdesc,
		    ULONG_PTR 	 ulCallbackContext,
		    PSED_FUNC_APPLY_SEC_CALLBACK pfuncApplySecurityCallback,
                    PSED_HELP_INFO psedhelpinfo
			   )
    : TAKE_OWNERSHIP_DLG( MAKEINTRESOURCE(IDD_SED_TAKE_OWNER),
			  hwndParent,
			  pszServer,
			  uiCount,
			  pchResourceType,
			  pchResourceName,
			  psecdesc,
                          psedhelpinfo ),
      _pfuncApplySecurityCallbackRoutine( pfuncApplySecurityCallback ),
      _ulCallbackContext		( ulCallbackContext ),
      _dwStatus 			( SED_STATUS_NOT_MODIFIED ),
      _hwndParent			( hwndParent ),
      _hInstance			( hInstance )
{
    if ( QueryError() )
	return ;

    if ( pfuncApplySecurityCallback == NULL )
    {
	ReportError( ERROR_INVALID_PARAMETER ) ;
	return ;
    }
}

/*******************************************************************

    NAME:	TAKE_OWNERSHIP_WITH_CALLOUT::OnTakeOwnership

    SYNOPSIS:	Simply calls the function callback member with the
		passed security descriptor.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	13-Feb-1992	Created

********************************************************************/

APIERR TAKE_OWNERSHIP_WITH_CALLOUT::OnTakeOwnership(
			  const OS_SECURITY_DESCRIPTOR & ossecdescNewOwner )
{
    APIERR err = _pfuncApplySecurityCallbackRoutine(
		   QueryHwnd(),
		   _hInstance,
		   _ulCallbackContext,
		   (PSECURITY_DESCRIPTOR) ossecdescNewOwner,
		   NULL,
		   FALSE,
		   FALSE,
		   &_dwStatus ) ;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\specdlg.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*

    SpecDlg.cxx

    This dialog contains the implementation for the Permissions Special
    dialog.

    The Special Dialog is a dialog that contains a set of check boxes
    that the user can select.  Each check box is associated with a
    particular bitfield.




    FILE HISTORY:
	Johnl	29-Aug-1991	Created

*/
#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>

#include <maskmap.hxx>

#include <accperm.hxx>
#include <aclconv.hxx>
#include <permstr.hxx>

#include <subjlb.hxx>
#include <perm.hxx>

#include <permdlg.hxx>
#include <specdlg.hxx>

#include <dbgstr.hxx>
#include <uitrace.hxx>

/*******************************************************************

    NAME:	SPECIAL_DIALOG::SPECIAL_DIALOG

    SYNOPSIS:	Special dialog constructor

    ENTRY:	pszDialogName - Resource name of dialog
		hwndParent - Owner window handle
		pszResourceType - UI string of resource type
		pszResourceName - UI string of resource type
		pAccessPerm - Pointer to access permission we are going
			to display
		pAccessMaskMap - Pointer to MASK_MAP object the pAccessPerm
			is using.

    EXIT:	The checkbox names will be set and the appropriate check
		boxes selected based on the current permissions mask

    NOTES:	It is assumed there are up to COUNT_OF_CHECKBOXES check boxes
		in the dialog and they should all be disabled and hidden
		by default.  This class enables and displays all used
		checkboxes automatically.


    HISTORY:
	Johnl	29-Aug-1991	Created

********************************************************************/

SPECIAL_DIALOG::SPECIAL_DIALOG( const TCHAR * pszDialogName,
				HWND	      hwndParent,
				const TCHAR * pszResourceType,
				const TCHAR * pszResourceName,
				const TCHAR * pszHelpFileName,
				const TCHAR * pszDialogTitle,
				BITFIELD    * pbitsAccessPerm,
				MASK_MAP    * pAccessMaskMap,
				const TCHAR * pszSubjName,
                                ULONG       * ahcHelp,
				BOOL	      fIsReadOnly )
    : PERM_BASE_DLG	     ( pszDialogName,
			       hwndParent,
			       pszDialogTitle,
			       pszResourceType,
			       pszResourceName,
			       pszHelpFileName,
                               ahcHelp ),
      _sleSubjectName        ( this, SLE_SUBJECT_NAME ),
      _cwinPermFrame	     ( this, FRAME_PERMISSION_BOX ),
      _pbitsAccessPerm	     ( pbitsAccessPerm ),
      _pAccessMaskMap	     ( pAccessMaskMap ),
      _cUsedCheckBoxes	     ( 0 ),
      _pAccessPermCheckBox   ( NULL ),
      _fIsReadOnly	     ( fIsReadOnly )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( _pAccessMaskMap != NULL ) ;

    _sleSubjectName.SetText( pszSubjName ) ;

    _pAccessPermCheckBox = (ACCESS_PERM_CHECKBOX *) new BYTE[COUNT_OF_CHECKBOXES*sizeof(ACCESS_PERM_CHECKBOX)] ;
    if ( _pAccessPermCheckBox == NULL )
    {
	ReportError( (APIERR) ERROR_NOT_ENOUGH_MEMORY ) ;
	return ;
    }

    APIERR err ;
    if ( (err = SetCheckBoxNames( _pAccessMaskMap, IsReadOnly() )) ||
	 (err = ApplyPermissionsToCheckBoxes( QueryAccessBits() )) )
    {
	ReportError( err ) ;
	return ;
    }

    /* After setting the names, resize the dialog and reposition the
     * controls so it looks nice.
     */
    Resize() ;

}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::~SPECIAL_DIALOG

    SYNOPSIS:	Standard destructor

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

SPECIAL_DIALOG::~SPECIAL_DIALOG()
{
    _pAccessMaskMap = NULL ;

    // UPDATED for C++ V 2.0; old version:
    //   delete [_cUsedCheckBoxes] _pAccessPermCheckBox ;
    //

    for ( INT i = 0 ; i < (INT)_cUsedCheckBoxes ; i++ )
    {
        _pAccessPermCheckBox[i].ACCESS_PERM_CHECKBOX::~ACCESS_PERM_CHECKBOX() ;
    }
    delete (void *) _pAccessPermCheckBox ;

    _pAccessPermCheckBox = NULL ;
}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::OnOK

    SYNOPSIS:	Gets the access mask the user selected and dismisses the dialog

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

BOOL SPECIAL_DIALOG::OnOK( void )
{
    if ( !IsReadOnly() )
    {
	QueryUserSelectedBits( QueryAccessBits() ) ;
    }

    Dismiss( TRUE ) ;

    return TRUE ;
}

ULONG SPECIAL_DIALOG::QueryHelpContext( void )
{
    return QueryHelpArray()[HC_SPECIAL_ACCESS_DLG] ;
}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::SetCheckBoxNames

    SYNOPSIS:	Constructs each checkbox with its bitfield and permission name

    ENTRY:	pAccessMap - Pointer to the MASK_MAP the ACCESS_PERMISSION
		    is using
		fReadOnly - TRUE if the checkboxes are read only (i.e., visible
		    but disabled).

    EXIT:	Each used dialog will have its name set and be enabled
		and visible.  The _cUsedCheckboxes will be set to the
		number of checkboxes that were successfully constructed.

    RETURNS:	An APIERR if an error occurred

    NOTES:	This is a *construction* method (i.e., meant to be called
		from the constructor).

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

APIERR SPECIAL_DIALOG::SetCheckBoxNames( MASK_MAP * pAccessMaskMap,
					 BOOL	    fReadOnly )
{
    BOOL fMoreData ;
    BOOL fFromBeginning = TRUE ;
    NLS_STR nlsSpecialPermName( 40 ) ;
    BITFIELD bitMask( *QueryAccessBits() ) ;
    APIERR err ;

    if ( bitMask.QueryError() )
	return bitMask.QueryError() ;

    ACCESS_PERM_CHECKBOX * pcheckTemp = (ACCESS_PERM_CHECKBOX *) _pAccessPermCheckBox ;

    /* Loop through all of the special permission names and construct
     * each checkbox with the permission name and assocated bitmap.
     */
    while ( ( err = pAccessMaskMap->EnumStrings( &nlsSpecialPermName,
						 &fMoreData,
						 &fFromBeginning,
						 PERMTYPE_SPECIAL ) ) == NERR_Success
	    && fMoreData
	    && _cUsedCheckBoxes < COUNT_OF_CHECKBOXES )
    {
	err = pAccessMaskMap->StringToBits( nlsSpecialPermName,
					    &bitMask,
					    PERMTYPE_SPECIAL ) ;
	if ( err != NERR_Success )
	    return err ;

	new (pcheckTemp) ACCESS_PERM_CHECKBOX( this, CHECK_PERM_1 + _cUsedCheckBoxes,
					       nlsSpecialPermName,
					       bitMask ) ;
	if ( pcheckTemp->QueryError() != NERR_Success )
	    return pcheckTemp->QueryError() ;

	pcheckTemp->Show( TRUE ) ;
	pcheckTemp->Enable( !fReadOnly ) ;

	_cUsedCheckBoxes++ ;
	pcheckTemp++ ;
    }

    if ( err != NERR_Success )
    {
	return err ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::Resize

    SYNOPSIS:	This method looks at the size of this dialog and resizes
		it appropriately (i.e., takes up the slack if only one
		column of buttons is used.

    ENTRY:	It is assumed the dialog is as it will be displayed (i.e.,
		the text of the buttons set etc.  It doesn't matter if the
		checkboxes are checked or not.

    EXIT:	The dialog will be resized as appropriate and the controls
		that need to be moved will be moved.

    RETURNS:	NERR_Success if successful, otherwise a standard error code

    NOTES:

    HISTORY:
	Johnl	04-Aug-1991	Created

********************************************************************/

void SPECIAL_DIALOG::Resize( void )
{
#if 0  // We don't currently support resizing

    /* We don't need to resize vertically if the whole column is full.
     */
    if ( !IsFilledVertically() )
    {
	/* Get the current size and positions of the components we are
	 * interested in.
	 */
	XYDIMENSION xydimFrame = _cwinPermFrame.QuerySize() ;
	XYDIMENSION xydimDialog = QuerySize() ;
	XYPOINT     xyptFrame  = _cwinPermFrame.QueryPos() ;
	XYRECT	    rectBottomChkBox( QueryCheckBox(QueryCount()-1), FALSE );

#if 0
	XYDIMENSION xydimBottomChkBox = QueryCheckBox( QueryCount() - 1 )->QuerySize() ;
	XYPOINT     xyptBottomChkBox =
#endif

	rectBottomChkBox.ConvertScreenToClient( QueryOwnerHwnd() );

#if 0
	cdebug << SZ("Frame dimensions: (") << xydimFrame.QueryHeight() << SZ(",") << xydimFrame.QueryWidth() << SZ(")") << dbgEOL ;
	cdebug << SZ("Frame Pos:        (") << xyptFrame.QueryX() << SZ(",") << xyptFrame.QueryY() << SZ(")") << dbgEOL ;
	cdebug << SZ("Check Box dim:    (") << xydimBottomChkBox.QueryHeight() << SZ(",") << xydimBottomChkBox.QueryWidth() << SZ(")") << dbgEOL ;
	cdebug << SZ("Check Box Pos:    (") << xyptBottomChkBox.QueryX() << SZ(",") << xyptBottomChkBox.QueryY() << SZ(")") << dbgEOL ;
	cdebug << SZ("Dialog dim:       (") << xydimDialog.QueryHeight() << SZ(",") << xydimDialog.QueryWidth() << SZ(")") << dbgEOL ;
#endif

	INT dyCheckBox = rectBottomChkBox.CalcHeight();

	/* Size the bottom of the frame so it is 1/2 the height of a checkbox
	 * from the bottom of the lowest checkbox and size the bottom of the
	 * dialog so it is 3/4 the height of a checkbox from the bottom of
	 * the frame.
	 */
	xydimFrame.SetHeight( rectBottomChkBox.QueryBottom() + dyCheckBox / 2 ) ;
	xydimDialog.SetHeight( xydimFrame.QueryHeight() + 3 * dyCheckBox / 4 ) ;

	/* Set the new sizes
	 */
#if 0
	cdebug << dbgEOL << dbgEOL << SZ("New dimensions:") << dbgEOL ;
	cdebug << SZ("Frame dimensions: (") << xydimFrame.QueryHeight() << SZ(",") << xydimFrame.QueryWidth() << SZ(")") << dbgEOL ;
	cdebug << SZ("Dialog dim:       (") << xydimDialog.QueryHeight() << SZ(",") << xydimDialog.QueryWidth() << SZ(")") << dbgEOL ;
#endif
	//_cwinPermFrame.SetSize( xydimFrame ) ;
	//SetSize( xydimDialog ) ;
    }
#endif
}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::ApplyPermissionsToCheckBoxes

    SYNOPSIS:	This method checks all of the checkboxes that have the
		same bits set as the passed bitfield.

    ENTRY:	pBitField - Pointer to bitfield which contains the checkmark
		    criteria.

    EXIT:	All appropriate checkboxes will be selected or deselected
		as appropriate.

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

APIERR SPECIAL_DIALOG::ApplyPermissionsToCheckBoxes( BITFIELD * pBitField )
{
    for ( int i = 0 ; i < (int)QueryCount() ; i++ )
    {
	BITFIELD bitTemp( *pBitField ) ;
	if ( bitTemp.QueryError() != NERR_Success )
	    return bitTemp.QueryError() ;

	/* Mask out all of the bits except for the ones we care about then
	 * check the box if the masks are equal.
	 */
	bitTemp &= *QueryCheckBox(i)->QueryBitMask() ;
	QueryCheckBox(i)->SetCheck( *QueryCheckBox(i)->QueryBitMask() == bitTemp ) ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::QueryUserSelectedBits

    SYNOPSIS:	Builds a bitfield by examining all of the selected
		checkboxes and the associated bitfields.

    ENTRY:	pbitsUserSelected - Pointer to bitfield that will receive
		    the built bitfield.

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

void SPECIAL_DIALOG::QueryUserSelectedBits( BITFIELD * pbitsUserSelected )
{
    pbitsUserSelected->SetAllBits( OFF ) ;

    for ( int i = 0 ; i < (int)QueryCount() ; i++ )
    {
	if ( QueryCheckBox(i)->QueryCheck() )
	    *pbitsUserSelected |= *QueryCheckBox(i)->QueryBitMask() ;
    }
}

/*******************************************************************

    NAME:	ACCESS_PERM_CHECKBOX::ACCESS_PERM_CHECKBOX

    SYNOPSIS:	Constructor for the ACCESS_PERM_CHECKBOX

    ENTRY:	powin - Pointer to owner window
		cid - Control ID of this checkbox
		nlsPermName - Name of this checkbox
		bitsMask - The bitfield this checkbox is associated with

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

ACCESS_PERM_CHECKBOX::ACCESS_PERM_CHECKBOX( OWNER_WINDOW * powin, CID cid,
					    const NLS_STR & nlsPermName,
					    BITFIELD & bitsMask )
    : CHECKBOX( powin, cid ),
      _bitsMask( bitsMask )
{
    if ( QueryError() != NERR_Success )
	return ;

    SetText( nlsPermName ) ;
}

/*******************************************************************

    NAME:	NT_SPECIAL_DIALOG::NT_SPECIAL_DIALOG

    SYNOPSIS:	Constructor for the new object special dialog

    ENTRY:	Same as parent

    EXIT:	The checkboxes of the special dialog will be associated
		with the "Permit" button in the magic group.

    RETURNS:

    NOTES:	If the default button is BUTTON_PERMIT then the permission
		will be checked against GENERIC_ALL and ALL will be selected
		if appropriate.

    HISTORY:
	Johnl	18-Nov-1991	Created

********************************************************************/

NT_SPECIAL_DIALOG::NT_SPECIAL_DIALOG(
			 const TCHAR * pszDialogName,
			 HWND	       hwndParent,
			 const TCHAR * pszResourceType,
			 const TCHAR * pszResourceName,
			 const TCHAR * pszHelpFileName,
			 const TCHAR * pszDialogTitle,
			 BITFIELD    * pbitsAccessPerm,
			 MASK_MAP    * pAccessMaskMap,
			 const TCHAR * pszSubjectName,
                         ULONG       * ahcHelp,
			 BOOL	       fIsReadOnly,
			 INT	       cMagicGroupButtons,
			 CID	       cidDefaultMagicGroupButton )
    : SPECIAL_DIALOG( pszDialogName,
		      hwndParent,
		      pszResourceType,
		      pszResourceName,
		      pszHelpFileName,
		      pszDialogTitle,
		      pbitsAccessPerm,
		      pAccessMaskMap,
		      pszSubjectName,
                      ahcHelp,
		      fIsReadOnly ),
      _mgrpSelectionOptions( this,
			     BUTTON_PERMIT,
			     cMagicGroupButtons,
			     cidDefaultMagicGroupButton )
{
    if ( QueryError() )
	return ;

    APIERR err ;
    if ( err = _mgrpSelectionOptions.QueryError() )
    {
	ReportError( err ) ;
	return ;
    }

    /* Check if the GENERIC_ALL is set so we should set the "All" button
     */
    if ( (cidDefaultMagicGroupButton == BUTTON_PERMIT) &&
	 (GENERIC_ALL & (ULONG) *pbitsAccessPerm ))
    {
	_mgrpSelectionOptions.SetSelection( BUTTON_ALL ) ;
    }


    /* We need to associate the check boxes with the Permit/Not specified
     * magic group.
     */
    for ( UINT i = 0 ; i < QueryCount() ; i++ )
    {
        //
        //  Temporary necessary to keep x86 cfront form faulting
        //
	ACCESS_PERM_CHECKBOX * pcbYuck = QueryCheckBox( i );
	
	err = _mgrpSelectionOptions.AddAssociation( BUTTON_PERMIT, pcbYuck );
	
	if( err != NERR_Success )
	{
	    ReportError( err );
	    return;
	}
    }

    if ( fIsReadOnly )
    {
	_mgrpSelectionOptions.Enable( FALSE ) ;
    }
}

NT_SPECIAL_DIALOG::~NT_SPECIAL_DIALOG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_SPECIAL_DIALOG::OnOK

    SYNOPSIS:	Redefines the base OK.	Sets the bits if the permit
		radio button is selected

    RETURNS:

    NOTES:

    HISTORY:
	JohnL	31-Mar-1992	Created

********************************************************************/

BOOL NT_SPECIAL_DIALOG::OnOK( void )
{
    if ( !IsReadOnly() )
    {
	if ( IsAllSpecified() )
	{
	    *QueryAccessBits() = (ULONG) GENERIC_ALL ;
	}
	else
	{
	    QueryUserSelectedBits( QueryAccessBits() ) ;
	}
    }

    Dismiss( TRUE ) ;

    return TRUE ;
}

/*******************************************************************

    NAME:	NEW_OBJ_SPECIAL_DIALOG::NEW_OBJ_SPECIAL_DIALOG

    SYNOPSIS:	Constructor for the new object special dialog

    ENTRY:	Same as parent

    EXIT:	The checkboxes of the special dialog will be associated
		with the "Permit" button in the magic group.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	18-Nov-1991	Created

********************************************************************/

NEW_OBJ_SPECIAL_DIALOG::NEW_OBJ_SPECIAL_DIALOG(
			 const TCHAR * pszDialogName,
			 HWND	       hwndParent,
			 const TCHAR * pszResourceType,
			 const TCHAR * pszResourceName,
			 const TCHAR * pszHelpFileName,
			 const TCHAR * pszDialogTitle,
			 BITFIELD    * pbitsAccessPerm,
			 MASK_MAP    * pAccessMaskMap,
			 const TCHAR * pszSubjectName,
                         ULONG       * ahcHelp,
			 BOOL	       fIsReadOnly,
			 BOOL	       fPermsSpecified )
    : NT_SPECIAL_DIALOG( pszDialogName,
			 hwndParent,
			 pszResourceType,
			 pszResourceName,
			 pszHelpFileName,
			 pszDialogTitle,
			 pbitsAccessPerm,
			 pAccessMaskMap,
			 pszSubjectName,
                         ahcHelp,
			 fIsReadOnly,
			 3,
			 fPermsSpecified ? BUTTON_PERMIT : BUTTON_NOT_SPECIFIED  )
{
    if ( QueryError() )
    {
	return ;
    }
}

NEW_OBJ_SPECIAL_DIALOG::~NEW_OBJ_SPECIAL_DIALOG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NEW_OBJ_SPECIAL_DIALOG::OnOK

    SYNOPSIS:	Redefines the base OK.	Sets the bits if the permit
		radio button is selected

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	18-Nov-1991	Created
	JohnL	31-Mar-1992	Added Generic All case

********************************************************************/

BOOL NEW_OBJ_SPECIAL_DIALOG::OnOK( void )
{
    if ( !IsReadOnly() )
    {
	if ( IsAllSpecified() )
	{
	    *QueryAccessBits() = (ULONG) GENERIC_ALL ;
	}
	else if ( !IsNotSpecified() )
	{
	    QueryUserSelectedBits( QueryAccessBits() ) ;
	}
	else
	{
	    ASSERT("FALSE") ;
	}
    }

    Dismiss( TRUE ) ;

    return TRUE ;
}


ULONG NEW_OBJ_SPECIAL_DIALOG::QueryHelpContext( void )
{
    return QueryHelpArray()[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\h\errornum.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*

    ErrorNum.h - Defines base manifests for error numbers and string IDs


    FILE HISTORY:
	Johnl	15-Apr-1992	Created


*/

#ifndef _ERRORNUM_H_
#define _ERRORNUM_H_

#define










#endif // _ERRORNUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\bin\makefile.inc ===
build_def:
    @echo del ntlanman.def
    -del ntlanman.def

ntlanman.def: 
    @echo Build ntlanman.def
    cp ntlmnpx.def ntlanman.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\acledit\subject.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*

    Subject.cxx

    This file contains the implementation for the SUBJECT class


    FILE HISTORY:
	Johnl	05-Aug-1991	Created

*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
}

#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>
#include <uiassert.hxx>
#include <string.hxx>
#include <security.hxx>
#include <ntacutil.hxx>

#include <subject.hxx>

#ifndef max
    #define max(a,b)  ( (a) > (b) ? (a) : (b) )
#endif //!max
/*******************************************************************

    NAME:	SUBJECT::SUBJECT

    SYNOPSIS:	Base SUBJECT class constructor

    ENTRY:	pszUserGroupDispName is the display name for this user/group
		fIsGroup is TRUE if this is a group, FALSE if a user

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

SUBJECT::SUBJECT( SUBJECT_TYPE SubjType )
    : _SubjType( SubjType )
{
    /* Nothing to do */
}

SUBJECT::~SUBJECT()
{
}

enum UI_SystemSid SUBJECT::QuerySystemSubjectType( void ) const
{
    return UI_SID_Invalid ;
}

APIERR SUBJECT::IsEveryoneGroup( BOOL * pfIsEveryone ) const
{
    UIASSERT( pfIsEveryone != NULL ) ;
    *pfIsEveryone = FALSE ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:	LM_SUBJECT::LM_SUBJECT

    SYNOPSIS:	Lanman subject constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

LM_SUBJECT::LM_SUBJECT( const TCHAR * pszUserGroupName, BOOL fIsGroup )
    : SUBJECT( fIsGroup ? SubjTypeGroup : SubjTypeUser ),
      _nlsDisplayName( pszUserGroupName )
{
    if ( _nlsDisplayName.QueryError() != NERR_Success )
    {
	ReportError( _nlsDisplayName.QueryError() ) ;
	return ;
    }
}

LM_SUBJECT::~LM_SUBJECT()
{
}

/*******************************************************************

    NAME:	LM_SUBJECT::QueryDisplayName

    SYNOPSIS:	Returns the name the user will see when looking at this
		subject

    ENTRY:

    EXIT:

    RETURNS:	Pointer to the string for display

    NOTES:

    HISTORY:
	Johnl	26-Dec-1991	Broke out from SUBJECT base class

********************************************************************/

const TCHAR * LM_SUBJECT::QueryDisplayName( void ) const
{
    return _nlsDisplayName.QueryPch() ;
}

/*******************************************************************

    NAME:	LM_SUBJECT::IsEqual

    SYNOPSIS:	Compares the account names for this LM subject

    ENTRY:	psubj - Pointer to subject to compare with

    RETURNS:	TRUE if equal, FALSE if not equal.

    NOTES:

    HISTORY:
	Johnl	09-Jul-1992	Created

********************************************************************/

BOOL LM_SUBJECT::IsEqual( const SUBJECT * psubj ) const
{
    return !::stricmpf( QueryDisplayName(), psubj->QueryDisplayName() ) ;
}

/*******************************************************************

    NAME:	NT_SUBJECT::NT_SUBJECT

    SYNOPSIS:	NT Subject constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	We copy the SID so we can modify it without any problems.

    HISTORY:
	Johnl	26-Dec-1991	Created

********************************************************************/

UCHAR NT_SUBJECT::_cMaxWellKnownSubAuthorities = 0 ;

NT_SUBJECT::NT_SUBJECT( PSID		  psidSubject,
			const TCHAR *	  pszDisplayName,
			SID_NAME_USE	  type,
			enum UI_SystemSid SystemSidType )
    : SUBJECT	     ( (SUBJECT_TYPE) type ),
      _ossid	     ( psidSubject, TRUE ),
      _nlsDisplayName( pszDisplayName ),
      _SystemSidType ( SystemSidType )
{
    APIERR err ;

    if ( (err = _nlsDisplayName.QueryError()) ||
	 (err = _ossid.QueryError()) )
    {
	ReportError( err ) ;
	return ;
    }

    /* If this is the first time through, initialize
     * _cMaxWellKnownSubAuthorities
     */
    if ( _cMaxWellKnownSubAuthorities == 0 )
    {
	do { // error break out

	    UCHAR cMaxSubAuthorities = 0, *pcSubAuthorities = 0 ;
	    OS_SID ossidWellKnown ;

	    if ( (err = ossidWellKnown.QueryError()) ||
		 (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_World,
							     &ossidWellKnown)) ||
		 (err = ossidWellKnown.QuerySubAuthorityCount( &pcSubAuthorities )))
	    {
		break ;
	    }
	    cMaxSubAuthorities = *pcSubAuthorities ;

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorOwner,
							     &ossidWellKnown)) ||
		 (err = ossidWellKnown.QuerySubAuthorityCount( &pcSubAuthorities )))
	    {
		break ;
	    }
	    cMaxSubAuthorities = max( cMaxSubAuthorities, *pcSubAuthorities ) ;

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Interactive,
							     &ossidWellKnown)) ||
		 (err = ossidWellKnown.QuerySubAuthorityCount( &pcSubAuthorities )))
	    {
		break ;
	    }
	    cMaxSubAuthorities = max( cMaxSubAuthorities, *pcSubAuthorities ) ;

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Network,
							     &ossidWellKnown)) ||
		 (err = ossidWellKnown.QuerySubAuthorityCount( &pcSubAuthorities )))
	    {
		break ;
	    }
	    cMaxSubAuthorities = max( cMaxSubAuthorities, *pcSubAuthorities ) ;

	    /* There is nothing else to fail on so set the static variable
	     */
	    _cMaxWellKnownSubAuthorities = cMaxSubAuthorities ;

	} while (FALSE) ;

	if ( err )
	{
	    ReportError( err ) ;
	    return ;
	}
    }

    /* Check the sub-authority count and if it is less then or equal to
     * our max count, compare the SID to the special cased well known sids.
     */
    UCHAR * pcSubAuthorities ;
    if ( (err = _ossid.QuerySubAuthorityCount( &pcSubAuthorities )) )
    {
	ReportError( err ) ;
	return ;
    }

    if ( *pcSubAuthorities <= _cMaxWellKnownSubAuthorities )
    {
	do { // error break out

	    OS_SID ossidWellKnown ;
	    if ( (err = ossidWellKnown.QueryError()) ||
		 (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_World,
							     &ossidWellKnown)) )
	    {
		break ;
	    }
	    if ( ossidWellKnown == _ossid )
	    {
		_SystemSidType = UI_SID_World ;
		break ;
	    }

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Interactive,
							     &ossidWellKnown)) )
	    {
		break ;
	    }
	    if ( ossidWellKnown == _ossid )
	    {
		_SystemSidType = UI_SID_Interactive ;
		break ;
	    }

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorOwner,
							     &ossidWellKnown)) )
	    {
		break ;
	    }
	    if ( ossidWellKnown == _ossid )
	    {
		_SystemSidType = UI_SID_CreatorOwner ;
		break ;
	    }

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Network,
							     &ossidWellKnown)) )
	    {
		break ;
	    }
	    if ( ossidWellKnown == _ossid )
	    {
		_SystemSidType = UI_SID_Network ;
		break ;
	    }

	} while (FALSE) ;

	if ( err )
	{
	    ReportError( err ) ;
	    return ;
	}
    }
}

NT_SUBJECT::~NT_SUBJECT()
{
}

/*******************************************************************

    NAME:	NT_SUBJECT::QueryDisplayName

    SYNOPSIS:	Returns the name the user will see when looking at this
		subject

    ENTRY:

    EXIT:

    RETURNS:	Pointer to the string for display

    NOTES:

    HISTORY:
	Johnl	26-Dec-1991	Created

********************************************************************/

const TCHAR * NT_SUBJECT::QueryDisplayName( void ) const
{
    return _nlsDisplayName.QueryPch() ;
}

/*******************************************************************

    NAME:	NT_SUBJECT::QuerySystemSubjectType

    SYNOPSIS:	Returns the type of SID if the sid is a well known SID

    RETURNS:	A UI_SystemSid

    NOTES:

    HISTORY:
	Johnl	3-Jun-1992	Created

********************************************************************/

enum UI_SystemSid NT_SUBJECT::QuerySystemSubjectType( void ) const
{
    return _SystemSidType ;
}

/*******************************************************************

    NAME:	NT_SUBJECT::IsEqual

    SYNOPSIS:	Compares the account names for this LM subject

    ENTRY:	psubj - Pointer to subject to compare with

    RETURNS:	TRUE if equal, FALSE if not equal.

    NOTES:

    HISTORY:
	Johnl	09-Jul-1992	Created

********************************************************************/

BOOL NT_SUBJECT::IsEqual( const SUBJECT * psubj ) const
{
    NT_SUBJECT * pntsubj = (NT_SUBJECT *) psubj ;

    return *QuerySID() == *pntsubj->QuerySID() ;
}

/*******************************************************************

    NAME:	NT_SUBJECT::IsEveryoneGroup

    SYNOPSIS:	Checks to see if this subject contains the "World" well
		known sid.

    ENTRY:	pfIsEveryone - Set to TRUE if this is the Everyone sid,
		    FALSE otherwise.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1992	Created

********************************************************************/

APIERR NT_SUBJECT::IsEveryoneGroup( BOOL * pfIsEveryone ) const
{
    UIASSERT( pfIsEveryone != NULL ) ;

    APIERR err ;
    OS_SID ossidEveryone ;
    if ( (err = ossidEveryone.QueryError()) ||
	 (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_World,
						     &ossidEveryone )) )
    {
	return err ;
    }

    *pfIsEveryone = ::EqualSid( ossidEveryone.QueryPSID(), QuerySID()->QueryPSID() ) ;
    return NERR_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\acledit\h\helpnums.h ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
    HelpNums.h
    Help context context codes


    FILE HISTORY:
    Johnl	15-Apr-1992	Created


*/

/*
 * Take Ownership dialog help
 */
#define HC_TAKEOWNERSHIP_DIALOG 	4201

/*
 * Security dialogs
 */
#define HC_SED_USER_BROWSER_DIALOG      4300  // NT File/Dir user browser dialog
#define HC_SED_USER_BROWSER_LOCALGROUP  4301  // NT File/Dir user browser dialog
#define HC_SED_USER_BROWSER_GLOBALGROUP 4302  // NT File/Dir user browser dialog
#define HC_SED_USER_BROWSER_FINDUSER    4303  // NT File/Dir user browser dialog

#define HC_SED_LANMAN_ADD_USER_DIALOG   4311  // LM Add user dialog

#define HC_SED_NT_FILE_PERMS_DLG        4312  // Main NT File Perm dialog
#define HC_SED_NT_DIR_PERMS_DLG         4313  // Main NT Directory perm dialog
#define HC_SED_NT_SPECIAL_FILES_FM      4314
#define HC_SED_NT_SPECIAL_DIRS_FM       4315
#define HC_SED_NT_SPECIAL_NEW_FILES_FM  4316

#define HC_SED_NT_FILE_AUDITS_DLG       4317  // Main NT File Audits dialog
#define HC_SED_NT_DIR_AUDITS_DLG        4318  // Main NT Directory Audits dialog

#define HC_SED_LM_FILE_PERMS_DLG        4319  // Main LM File Perm dialog
#define HC_SED_LM_DIR_PERMS_DLG         4320  // Main LM Directory perm dialog
#define HC_SED_LM_SPECIAL_FILES_FM      4321
#define HC_SED_LM_SPECIAL_DIRS_FM       4322

#define HC_SED_LM_FILE_AUDITS_DLG       4323  // Main LM File Audits dialog
#define HC_SED_LM_DIR_AUDITS_DLG        4324  // Main LM Directory Audits dialog

#define HC_SED_USER_BROWSER_AUDIT_DLG    4325
#define HC_SED_USER_BR_AUDIT_LOCALGROUP  4326  // NT File/Dir user browser dialog
#define HC_SED_USER_BR_AUDIT_GLOBALGROUP 4327  // NT File/Dir user browser dialog
#define HC_SED_USER_BR_AUDIT_FINDUSER    4328  // NT File/Dir user browser dialog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\acctypes.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1990		**/ 
/*****************************************************************/ 
/****  ACCTYPES.H  *****  Definition Module for BACKACC/RESTACC Utility
 *
 *	BACKACC/RESTACC
 *
 *	This file was compiled from LTYPES.H and DEFS.H originally in
 *	the UI\ACCUTIL\ACCUTIL directory.  This file is referenced by
 *	both the acc utilities and the LM 2.1 setup program.
 *
 *	History:
 *		April 9, 1991	thomaspa	created from ltypes.h and defs.h
 */


#define FILEHDR		0x08111961	/* All File created by backacc
                                           start with this header.
                                           ATTENTION when change FILEHEADER
					   controll his size and eventually
					   change HEADERSIZE definition 
					   in ltypes.h                 */

#define NINDEX		64		/* # MAX in index_table        */

#define MAX_KEY_LEN	24              /* Dimension of a key */
#define MAX_LIST        0x01400         /* # max in list  */
#define MAXDYNBUFFER	20		/* # buffer of BUFFILE size */



#define VOL_LABEL_SIZE	64		/* Max size of a volume label */
					/* There is no def about how long 
					   should be this label. Normally
					   it is 11 characters */
#define K32BYTE 	0x8000
#define K64BYTE		0xFFFF
#define BYTE256		0x0100
#define BUFLEN		K64BYTE
#define BUFFILE		K32BYTE
#define MAXMSGLEN	256

#define WBSL		0
#define NOBSL		1

/* define file attribute */
#define NORMAL		0x0000
#define R_ONLY		0x0001
#define HIDDEN		0x0002
#define SYSTEM		0x0004
#define SUBDIR		0x0010
#define ARCHIV		0x0020

#define ALL		HIDDEN + SYSTEM + SUBDIR
#define NOSUBDIR	HIDDEN + SYSTEM

#define YES		1		/* Yes state for PromptFlag */
#define NO		2		/* No state for PromptFlag */


/* buffer to pass to DoQFSInfo  */

struct label_buf {
	ULONG	ulVSN;
	UCHAR	cbVolLabel;
	UCHAR	VolLabel[VOL_LABEL_SIZE+1];
};

/* heeader of backacc/restacc file */

struct backacc_header {
	ULONG	back_id;
	UCHAR	vol_name[VOL_LABEL_SIZE + 1];
	USHORT  nindex;
	USHORT 	nentries;
	USHORT 	level;
	ULONG	nresource;
}; 

#define HEADERSIZE	sizeof(struct backacc_header)

struct resource_info {
	USHORT namelen;
	USHORT  acc1_attr;
	USHORT  acc1_count;
	UCHAR  name[MAXPATHLEN];
};

#define RESHDRLEN	6

struct index {
	UCHAR key [MAX_KEY_LEN];
	ULONG offset;
};

#define HEADER 	HEADERSIZE + NINDEX * sizeof(struct index)

struct list {
	struct list *next;
	struct list *prev;
	struct resource_info *ptr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\bltstyle.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltstyle.h
    Style bits for BLT custom controls

    This file defines and coordinates the style bits of all BLT custom
    controls.

    FILE HISTORY:
        beng    21-Feb-1992 Separated from bltrc.h
*/

#ifndef _BLTSTYLE_H_
#define _BLTSTYLE_H_

// if defined, the SPIN_SLE_NUM will add zero in front of the number to
// be display. The number of zero is equal to the length of the max output
// number - the current number's length
//
#define SPIN_SSN_ADD_ZERO   0x1000L

// if the style is defined, the GRAPHICAL_BUTTON_WITH_DISABLE will be 3D.
// otherwise, it will be 2 d.
//
#define GB_3D               0x1000L


#endif // _BLTSTYLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\bltcons.h ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    bltcons.h
    BLT constants

    FILE HISTORY:
    Rustan M. Leino   21-Nov-1990   Created
    Johnl	      12-Feb-1991   Added MsgPopup manifests
    rustanl	      19-Feb-1991   Added COL_WIDTH manifests
    Johnl	       5-Mar-1991   Removed DMID stuff

*/


/*  The following manifests are for drawing listbox items.
 */

//  number of pixels within a listbox column that are unused to separate
//  columns
#define DISP_TBL_COLUMN_DELIM_SIZE	(2)

//  width of a display map in pixels
#define COL_WIDTH_DM			( 16 + DISP_TBL_COLUMN_DELIM_SIZE )

//  width of a wide display map in pixels
#define COL_WIDTH_WIDE_DM		( 32 + DISP_TBL_COLUMN_DELIM_SIZE )

//  The width of the last column always streches to the right edge of the
//  listbox.  The client should, as a good programmer, still fill in
//  the last column width specified in the array of column widths passed
//  to the DISPLAY_TABLE constructor.  Rather than that the client pulls
//  up some number from a hat, he can assign the following manifest.  The
//  manifest is defined as 0, but could actually be assigned any number
//  (except negative ones, because no column width should be negative).
//  AWAP stands for As Wide As Possible.
#define COL_WIDTH_AWAP			( 0 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\applibrc.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    applibrc.h
    APPLIB resource header file.

    This file defines and coordinates the resource IDs of all resources
    used by APPLIB components.

    APPLIB reserves for its own use all resource IDs above 15000, inclusive,
    but less than 20000 (where the BLT range begins).  All clients of APPLIB
    therefore should use IDs of less than 15000.

    FILE HISTORY:
        beng        21-Feb-1992 Created
        beng        04-Aug-1992 Added user browser definitions

        jonn    29-Jul-1992 Changed domain bitmap IDs
*/

#ifndef _APPLIBRC_H_
#define _APPLIBRC_H_

#include "uimsg.h"

/*
 * string IDs
 */
#define IDS_APPLIB_DOMAINS      (IDS_UI_APPLIB_BASE+0)
#define IDS_APPLIB_SERVERS      (IDS_UI_APPLIB_BASE+1)
#define IDS_APPLIB_DOM_AND_SRV  (IDS_UI_APPLIB_BASE+2)
#define IDS_APPLIB_NO_SELECTION (IDS_UI_APPLIB_BASE+3)
#define IDS_APPLIB_WORKING_TEXT (IDS_UI_APPLIB_BASE+4)

//
//   User browser error messages
//
#define IDS_CANT_BROWSE_DOMAINS              (IDS_UI_APPLIB_BASE+5)
#define IDS_CANT_BROWSE_DOMAIN		     (IDS_UI_APPLIB_BASE+20)
#define IDS_CANT_FIND_ACCOUNT		     (IDS_UI_APPLIB_BASE+21)
#define IDS_GETTING_DOMAIN_INFO 	     (IDS_UI_APPLIB_BASE+22)
#define IDS_WONT_GET_DOMAIN_INFO 	     (IDS_UI_APPLIB_BASE+23)

#define IDS_CANT_ADD_USERS		     (IDS_UI_APPLIB_BASE+40)
#define IDS_CANT_ADD_GROUPS		     (IDS_UI_APPLIB_BASE+41)
#define IDS_CANT_ADD_ALIASES		     (IDS_UI_APPLIB_BASE+42)
#define IDS_CANT_ADD_WELL_KNOWN_GROUPS	     (IDS_UI_APPLIB_BASE+43)
#define IDS_WKSTA_OR_BROWSER_NOT_STARTED     (IDS_UI_APPLIB_BASE+44)

/*
 * This error message is used when the user browser Localgroup Membership
 * dialog tries to load the membership of a globalgroup in that localgroup,
 * but the globalgroup was not in the dropdown list of domains in the main
 * User Browser dialog.  This can happen e.g. if a new trusted domain is
 * added while the User Browser dialog is running.
 */
#define IDS_CANT_BROWSE_GLOBAL_GROUP         (IDS_UI_APPLIB_BASE+7)

/*  Message used when prompting for a known DC.
 */
#define IDS_APPLIB_PROMPT_FOR_ANY_DC         (IDS_UI_APPLIB_BASE+8)
#define IDS_APPLIB_PROMPT_DC_INVALID_SERVER  (IDS_UI_APPLIB_BASE+9)

/* Message used when the Find Accounts dialog cannot find any matches
 */
#define IDS_APPLIB_NO_MATCHES                (IDS_UI_APPLIB_BASE+10)

/* Well known Sid comment manifests used in the userbrowser
 */
#define IDS_USRBROWS_EVERYONE_SID_COMMENT    (IDS_UI_APPLIB_BASE+11)
#define IDS_USRBROWS_REMOTE_SID_COMMENT      (IDS_UI_APPLIB_BASE+13)
#define IDS_USRBROWS_INTERACTIVE_SID_COMMENT (IDS_UI_APPLIB_BASE+15)
#define IDS_USRBROWS_CREATOR_SID_COMMENT     (IDS_UI_APPLIB_BASE+17)
#define IDS_USRBROWS_SYSTEM_SID_COMMENT      (IDS_UI_APPLIB_BASE+18)
#define IDS_USRBROWS_RESTRICTED_SID_COMMENT  (IDS_UI_APPLIB_BASE+19)

/* caption for userbrows dialog */
#define IDS_USRBROWS_ADD_USER                (IDS_UI_APPLIB_BASE+25)
#define IDS_USRBROWS_ADD_USERS               (IDS_UI_APPLIB_BASE+26)
#define IDS_USRBROWS_ADD_GROUP               (IDS_UI_APPLIB_BASE+27)
#define IDS_USRBROWS_ADD_GROUPS              (IDS_UI_APPLIB_BASE+28)
#define IDS_USRBROWS_ADD_USERS_AND_GROUPS    (IDS_UI_APPLIB_BASE+29)
#define IDS_USRBROWS_ADD_USER_OR_GROUP       (IDS_UI_APPLIB_BASE+30)


/*
 * This error message indicates that the Global Group Membership dialog
 * is not available for the Domain Users global group.
 * This is disallowed because the Domain Users global group contains
 * workstation, server and interdomain trust accounts, which are not
 * exposed to the user.
 */
#define IDS_USRBROWS_CANT_SHOW_DOMAIN_USERS  (IDS_UI_APPLIB_BASE+35)

/* Strings used in the Set Focus dialog */
#define IDS_SETFOCUS_SERVER_SLOW             (IDS_UI_APPLIB_BASE+36)
#define IDS_SETFOCUS_SERVER_FAST             (IDS_UI_APPLIB_BASE+37)
#define IDS_SETFOCUS_DOMAIN_SLOW             (IDS_UI_APPLIB_BASE+38)
#define IDS_SETFOCUS_DOMAIN_FAST             (IDS_UI_APPLIB_BASE+39)


/*
 * define other IDs
 */
#define BASE_APPLIB_IDD         15000
#define IDD_SETFOCUS_DLG        15001
#define IDD_SELECTCOMPUTER_DLG  15002
#define IDD_SELECTDOMAIN_DLG    15003
#define IDD_PASSWORD_DLG	15004
#define IDD_CANCEL_TASK 	15018

#define BASE_APPLIB_BMID          16000
#define BMID_DOMAIN_EXPANDED      16001
#define BMID_DOMAIN_NOT_EXPANDED  16002
#define BMID_DOMAIN_CANNOT_EXPAND 16003
#define BMID_ENTERPRISE           16004
#define BMID_SERVER               16005

/* For the User Browser */
#define DMID_GROUP                  15010
#define DMID_USER                   15011
#define DMID_ALIAS                  15012
#define DMID_UNKNOWN                15013
#define DMID_SYSTEM                 15014
#define DMID_REMOTE                 15015
#define DMID_WORLD                  15016
#define DMID_CREATOR_OWNER          15017
#define DMID_NETWORK                15018
#define DMID_INTERACTIVE            15019
#define DMID_RESTRICTED             15021

#define DMID_DELETEDACCOUNT         15024

#define IDD_USRBROWS_DLG            15005
#define IDD_SINGLE_USRBROWS_DLG     15006
#define IDD_SED_USRBROWS_DLG        15007
#define IDD_PROMPT_FOR_ANY_DC_DLG   15008

#define IDD_LGRPBROWS_DLG           15020
#define IDD_GGRPBROWS_DLG           15021
#define IDD_LGRPBROWS_1SEL_DLG      15022
#define IDD_GGRPBROWS_1SEL_DLG      15023

#define IDD_BROWS_FIND_ACCOUNT      15030
#define IDD_BROWS_FIND_ACCOUNT_1SEL 15031

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\bltrc.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltrc.h
    BLT resource header file.

    This file defines and coordinates the resource IDs of all resources
    used by BLT components.

    BLT reserves for its own use all resource IDs above 20000, inclusive.
    All clients of BLT therefore should use IDs of less than 20000.

    FILE HISTORY:
        terryk  08-Apr-91   created
        terryk  10-Jul-91   Add SPIN_SSN_ADD_ZERO and IDS_K -> IDS_TB
        terryk  19-Jul-91   Add GB_3D as style for GRAPHICAL_BUTTON_WITH_DISABLE
        beng    20-Feb-1992 Add BASE_BLT_IDD for global dialogs
        beng    21-Feb-1992 BASE_APPLIB_IDD reloc'd to applibrc.h;
                            bltstyle.h split off for custom control styles
                            resource ID namespace partitioned
        chuckc  26-Feb-1992 converted string base to use <uimsg.h>
        beng    05-Mar-1992 Added ID_CURS_BLT_TIMEx
        beng    29-Mar-1992 Change IDHC_MSG_TO_HELP to numeric resource ID
        beng    04-Aug-1992 Added BMIDs for arrow-button bitmaps
        jonn    25-Aug-1992 Added IDs for new MsgPopup form
        jonn    22-Oct-1993 Added splitter-bar cursor
*/

#ifndef _BLTRC_H_
#define _BLTRC_H_

// Style bits for BLT custom controls.

#include "bltstyle.h"
#include "uimsg.h"


// Base for all BLT global dialogs.
// NOTE - rc 3.20/1.252.1 doesn't perform math on DIALOG statements.
//
#define BASE_BLT_IDD            20000
#define IDD_BLT_HELPMSG         20001

// Cursor IDs for the default TIME_CURSOR object.
//
#define ID_CURS_BLT_TIME0       21000
#define ID_CURS_BLT_TIME1       21001
#define ID_CURS_BLT_TIME2       21002
#define ID_CURS_BLT_TIME3       21003
#define ID_CURS_BLT_TIME4       21004
#define ID_CURS_BLT_TIME5       21005
#define ID_CURS_BLT_TIME6       21006
#define ID_CURS_BLT_TIME7       21007

#define ID_CURS_BLT_VSPLIT      21008


// Base for all BLT strings.
//
#define BASE_BLT_IDS            (IDS_UI_BLT_BASE)

/* The following strings currently live in bltmsgp.dlg
 */
#define IDS_BLT_TEXT_MSGP       (BASE_BLT_IDS+1)  // Strings to display when we
#define IDS_BLT_CAPT_MSGP       (BASE_BLT_IDS+2)  // run out of memory or resources
                                                  // (loaded at startup time by InitMsgPopup)
#define IDS_BLT_OutOfMemory     (BASE_BLT_IDS+3)  // BLT out of memory error message
#define IDS_BLT_WinHelpError    (BASE_BLT_IDS+4)  // BLT can't load win help error


#define IDS_BLT_30_WinHelpFile  (BASE_BLT_IDS+5)  // Win 3.0 help file name
#define IDS_BLT_31_WinHelpFile  (BASE_BLT_IDS+6)  // Win 3.1 & greater Help file name

#define IDS_BLT_DOSERROR_MSGP   (BASE_BLT_IDS+8)
#define IDS_BLT_NETERROR_MSGP   (BASE_BLT_IDS+9)
#define IDS_BLT_WINNET_ERROR_MSGP (BASE_BLT_IDS+10)

#define IDS_BLT_ELLIPSIS_TEXT   ( BASE_BLT_IDS + 11 )

#define IDS_BLT_NTSTATUS_ERROR_MSGP (BASE_BLT_IDS+12)

#define IDS_BLT_SB_SLENUM_OUTRANGE  ( BASE_BLT_IDS + 18 )

#define IDS_DAY_TOO_BIG         ( BASE_BLT_IDS + 22 )
#define IDS_FEBRUARY_LEAP       ( BASE_BLT_IDS + 23 )
#define IDS_FEBRUARY_NOT_LEAP   ( BASE_BLT_IDS + 24 )

#define IDS_MONTH               ( BASE_BLT_IDS + 25 )
#define IDS_DAY                 ( BASE_BLT_IDS + 26 )
#define IDS_YEAR                ( BASE_BLT_IDS + 27 )
#define IDS_HOUR                ( BASE_BLT_IDS + 28 )
#define IDS_MIN                 ( BASE_BLT_IDS + 29 )
#define IDS_SEC                 ( BASE_BLT_IDS + 30 )

#define IDS_K                   ( BASE_BLT_IDS + 36 )
#define IDS_MB                  ( BASE_BLT_IDS + 37 )
#define IDS_GB                  ( BASE_BLT_IDS + 38 )
#define IDS_TB                  ( BASE_BLT_IDS + 39 )

#define IDS_FIELD               ( BASE_BLT_IDS + 40 )

#define IDS_BLT_FMT_SYS_error   ( BASE_BLT_IDS + 41 )
#define IDS_BLT_FMT_NET_error   ( BASE_BLT_IDS + 42 )
#define IDS_BLT_FMT_other_error ( BASE_BLT_IDS + 43 )

#define IDS_BLT_UNKNOWN_ERROR   ( BASE_BLT_IDS + 44 )

#define IDS_FIXED_TYPEFACE_NAME ( BASE_BLT_IDS + 45 )

/* MsgPopup manifests
 */
#define IDHELPBLT           (80)
#define IDC_MSGPOPUPICON    (81)        // Icon control ID on message popup dialog
#define IDC_MSGPOPUPTEXT    (82)        // Static message text in message box
#define IDHC_MSG_TO_HELP    22000       // Name of Help context lookup table

#define BMID_UP             20000
#define BMID_UP_INV         20001
#define BMID_UP_DIS         20002
#define BMID_DOWN           20003
#define BMID_DOWN_INV       20004
#define BMID_DOWN_DIS       20005
#define BMID_LEFT           20006
#define BMID_LEFT_INV       20007
#define BMID_RIGHT          20008
#define BMID_RIGHT_INV      20009


#endif // _BLTRC_H_ - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\declspec.h ===
//
//  DECLSPEC.H:  Define the DLL_BASED and DLL_CLASS manifests for
//               DLL export/import decoration
//

//  BUGBUG:  Temporarily DISABLED until __declspec works better
//
//  If a fixed header files is needed, define _DECLSPEC_WORKS_ and this 
//  header file will work correctly.
//
#if !defined(_DECLSPEC_WORKS_)
#if !defined(_DECLSPEC_H_)

#define _DECLSPEC_H_

//   Create benign definitions for __declspec macros.
#define DLL_TEMPLATE
#define DLL_CLASS class
#define DLL_BASED

#endif
#endif

#if !defined(_DECLSPEC_H_)

#define _DECLSPEC_H_

//
//  DECLSPEC.H:  Define the DLL_BASED and DLL_CLASS manifests for
//               DLL export/import decoration
//
//   This file is based upon the following macro definitions:
//
//        _CFRONT_PASS_     defined in MAKEFILE.DEF for CFRONT preprocessing;
//
//        _cplusplus        defined for all C++ compilation;
//
//        NETUI_DLL         defined in $(UI)\COMMON\SRC\DLLRULES.MK, which is
//                          included by all components which live in NETUI DLLs.
//
//        DLL_BASED_DEFEAT  optional manifest that suppresses __declspec;
//
//  This file generates two definitions:
//
//        DLL_BASED         which indicates that the external function, data item
//                          or class lives in a NETUI DLL; expands to nothing,
//                          "_declspec(dllimport)", or "_declspec(dllexport)"
//                          depending upon the manifest above.
//
//        DLL_CLASS         which expands to "class", "class _declspec(dllimport)",
//                          or "class _declspec(dllexport)" depending on the
//                          manifests above.
//
//        DLL_TEMPLATE      expands to nothing outside of the DLLs; expands to
//                          DLL_BASED inside the DLLs.   In other words, the standard
//                          template is local to the defining link scope.  To
//                          declare a template as "dllimport", another set of
//                          macros exists which allows direct specification of the
//                          desired decoration.
//

#if defined(_CFRONT_PASS_)
  #define DLL_BASED_DEFEAT
#endif

  //  Define DLL_BASED for all compiles

#if defined(DLL_BASED_DEFEAT)
  //  If CFront, no decoration allowed
  #define DLL_BASED
#else
  #if defined(NETUI_DLL)
    // If C8 and inside DLL, export stuff
    #define DLL_BASED __declspec(dllexport)
  #else
    // If C8 and inside DLL, import stuff
    #define DLL_BASED __declspec(dllimport)
  #endif
#endif

  //  If C++, define the DLL_CLASS and DLL_TEMPLATE macros

#if defined(__cplusplus)

  #if defined(DLL_BASED_DEFEAT)
    //  If CFRONT, no decoration allowed
    #define DLL_CLASS class
    #define DLL_TEMPLATE
  #else
    #define DLL_CLASS class DLL_BASED
    #if defined(NETUI_DLL)
      //  Templates expanded in the DLL are exported
      #define DLL_TEMPLATE DLL_BASED
    #else
      #define DLL_TEMPLATE
    #endif
  #endif

#endif

#endif  //  !_DECLSPEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\focusdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    focusdlg.h
    Header file for focus dialog IDC values.

    FILE HISTORY:
        terryk  18-Nov-1991 Created
        beng    20-Feb-1992 Uses BASE_APPLIB_IDD
        beng    21-Feb-1992 Uses applibrc.h
*/

#ifndef _FOCUSDLG_H_
#define _FOCUSDLG_H_

#include "applibrc.h"

#define IDC_FOCUS_PATH      104
#define IDC_DOMAIN_LB       106
#define IDC_SEL_LB_TITLE    107
#define IDC_BOUNDARY        108
#define IDC_LINK            109
#define IDC_SLE_GETINFO     110
#define IDC_LINK_MESSAGE    111

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\domenum.h ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    domenum.h
    This file contains the bitflags used to control the BROWSE_DOMAIN_ENUM
    domain enumerator.


    FILE HISTORY:
        KeithMo     22-Jul-1992     Created.

*/

#ifndef _DOMENUM_H
#define _DOMENUM_H


#define BROWSE_LOGON_DOMAIN         0x00000001
#define BROWSE_WKSTA_DOMAIN         0x00000002
#define BROWSE_OTHER_DOMAINS        0x00000004
#define BROWSE_TRUSTING_DOMAINS     0x00000008
#define BROWSE_WORKGROUP_DOMAINS    0x00000010


//
//  Some handy combinations of flags.
//

//
//  BROWSE_LM2X_DOMAINS will return only the domains available
//  from a LanMan 2.x workstation.  This returns just the logon,
//  workstation, and other domains.
//

#define BROWSE_LM2X_DOMAINS         ( BROWSE_LOGON_DOMAIN       | \
                                      BROWSE_WKSTA_DOMAIN       | \
                                      BROWSE_OTHER_DOMAINS )

//
//  BROWSE_LOCAL_DOMAINS will return only the domains available
//  to the local machine.  This returns the logon, workstation,
//  and other, plus the domains that trust "us".
//

#define BROWSE_LOCAL_DOMAINS        ( BROWSE_LM2X_DOMAINS       | \
                                      BROWSE_TRUSTING_DOMAINS )

//
//  BROWSE_ALL_DOMAINS is a conglomeration of all potential domain
//  sources available to the domain enumerator.
//

#define BROWSE_ALL_DOMAINS          ( BROWSE_LOCAL_DOMAINS      | \
                                      BROWSE_WORKGROUP_DOMAINS )

//
//  BROWSE_RESERVED contains the reserved bits in the domain enumerator
//  control flags.  Nobody should be passing in any of these bits.
//

#define BROWSE_RESERVED             ( ~BROWSE_ALL_DOMAINS )


#endif  // _DOMENUM_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\llsterm.h ===
// this header is included/shared by LLS resource

#define LLS_HELP_TERM    "For complete terms and conditions governing the use of this product, see the applicable license agreements, which may include those that can be found under Help, and which for volume licensing customers include the volume licensing product use rights."
#define LLS_AGREE_TERM   "I have read and agree to be bound by the license agreements for this product."
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\lmuidbcs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    lmuidbcs.h

    FILE HISTORY:
        JonN        11-Sep-1995     Created

*/



#ifndef _LMUIDBCS_H_
#define _LMUIDBCS_H_

BOOL NETUI_IsDBCS();

#endif  // _LMUIDBCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\lmobjrc.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmobjrc.h
    LMOBJ resource header file.

    This file defines and coordinates the resource IDs of all resources
    used by LMOBJ components.

    LMOBJ reserves for its own use all resource IDs above 15000, inclusive,
    but less than 20000 (where the BLT range begins).  All clients of APPLIB
    therefore should use IDs of less than 15000.

    FILE HISTORY:
        thomaspa    9-July-1992 Created
*/

#ifndef _LMOBJRC_H_
#define _LMOBJRC_H_

#include "uimsg.h"

/*
 * string IDs
 */
#define IDS_LMOBJ_SIDUNKNOWN	(IDS_UI_LMOBJ_BASE+0)
#define IDS_LMOBJ_SIDDELETED	(IDS_UI_LMOBJ_BASE+1)

//
// JonN 9/20/96
// NETUI2.DLL keeps these strings on behalf of PROFEXT.DLL.
//
#define IDS_PROFEXT_NOADAPTERS	(IDS_UI_LMOBJ_BASE+2)
#define IDS_PROFEXT_ERROR	(IDS_UI_LMOBJ_BASE+3)
#define IDS_CFGMGR32_BASE   (IDS_UI_LMOBJ_BASE+10)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\lmuiwarn.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmuiwarn.hxx:

        This file contains #pragmas which suppress warnings
        we deem to be unnecessary.

        History:

            DavidHov    9/24/93     Created
                                    Disabled C4003: not enough parameters
                                            for preprocessor macro
                                    Disabled C4355: 'this' used in base
                                            member initializer.

*/

#if !defined(_LMUIWARN_HXX_)
#  define _LMUIWARN_HXX_
#  if !defined(_CFRONT_PASS_)
#     pragma warning( disable: 4003 4355 )
#  endif  // !_CFRONT_PASS_
#endif  // _LMUIWARN_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\lmuitype.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmuitype.h
    Basic types (int, char, etc.) for LM UI apps

    Sad, but true: OS/2 and Windows don't agree on basic type
    definitions such as pointer-to-char, etc.  This file attempts
    to strike a compromise between both camps (and hence will
    certainly please nobody).

    There are incompatibilities with both OS/2 and Win in this file:

    .  OS/2 expects all its "Ptype" definitions to be FAR;
       hence including this file and os2.h in a small- or medium-
       model program will break API prototypes.  However, as only
       Windows programs need default near data, this probably will
       never bite us.

    .  A couple of OS/2 PM definitions - ODPOINT, VioPresentationSpace -
       seem to use TCHAR as a signed quantity, where we use TCHAR as
       unsigned always, for consistency with PCH/PSZ and good NLS
       behavior.

    .  OS/2 BOOL is USHORT, where on Win it is INT.

    .  Most of the Win basic types hardcode near-data assumptions
       in their "Ptype" definitions.  We define those pointers as
       default-data-model; this does not break API definitions only
       because those definitions prototypes use the LP or NP forms.

    Two auxiliary sed scripts excise these definitions from windows.h
    and os2def.h, in order to avoid conflicts.  See $(UI)\common\hack.


    FILE HISTORY
        beng        05-Feb-1991 Added this file to $(UI)\common\h
        beng        15-Mar-1991 Added UNREFERENCED macro
        beng        21-Mar-1991 Added WCHAR type
        beng        18-Apr-1991 Added APIERR type
        beng        26-Apr-1991 Removed PB, IB, CB types
        jonn        12-Sep-1991 Changes to support WIN32
        jonn        29-Sep-1991 More changes to support WIN32
        beng        07-Oct-1991 Added MSGID
        KeithMo     08-Oct-1991 Changed APIERR from USHORT to UINT
        beng        09-Oct-1991 Further Win32 work - incorporate ptypes%d
        beng        14-Oct-1991 ptypes relocated to lmui.hxx
        jonn        19-Oct-1991 Added LPTSTR
        jonn        20-Oct-1991 Added SZ(), removed LPTSTR
        beng        23-Oct-1991 WORD now unsigned short; CCH_INT for Win32
        beng        19-Nov-1991 APIERR delta (pacify paranoid NT compiler)
        jonn        09-Dec-1991 updated windows.h
        jonn        26-Dec-1991 Fixed compiler warning from MAKEINTRESOURCE
        jonn        04-Jan-1992 MIPS build is large-model
        beng        22-Feb-1992 CHAR->TCHAR; merge winnt types
        beng        18-Mar-1992 Fix HFILE on NT (thanks David)
        beng        28-Mar-1992 Fix SZ def'n, add TCH
        KeithMo     01-Apr-1992 Null out cdecl & _cdecl under MIPS.
        beng        01-Apr-1992 Fix HFILE on NT, for sure this time
        beng        01-Jul-1992 Emasculated Win32 version to use system defns
        KeithMo     25-Aug-1992 #define MSGID instead of typedef (warnings...)
*/

#if !defined(_LMUITYPE_H_)
#define _LMUITYPE_H_

#define NOBASICTYPES /* this to override windows.h, os2def.h basic types */

#ifndef NULL
#define NULL            0
#endif

#define VOID            void

// These keywords do not apply to NT builds
//
#if defined(WIN32)
// FAR, NEAR, PASCAL already supplied
#define CDECL
#define LOADDS
#define _LOADDS
#define _EXPORT
#define MFARPROC ULONG_PTR
#if defined(_MIPS_) || defined(_PPC_)
#define cdecl
#define _cdecl
#endif  // MIPS
#else
#define NEAR            _near
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#define LOADDS          _loadds
#define _LOADDS         _loadds
#define _EXPORT         _export
#define MFARPROC        FARPROC
#endif // WIN32

// TCHAR is the "transmutable char" type of NT.
// SZ is netui's transmutable text macro.  TEXT is its NT equivalent.
//
#if !defined(WIN32)
#if defined(UNICODE)
#define TCHAR           WCHAR
#define SZ(quote)       (WCHAR*)L##quote
#define TCH(quote)      L##quote
#define TEXT(quote)     L##quote
#else
#define TCHAR           CHAR
#define SZ(quote)       quote
#define TCH(quote)      quote
#define TEXT(quote)     quote
#endif
#else
#if defined(UNICODE)
#define SZ(quote)       (WCHAR*)L##quote
#define TCH(quote)      L##quote
#else
#define SZ(quote)       quote
#define TCH(quote)      quote
#endif
#endif


// The basics
//
// CHAR is defined with a macro so that the compiler can init a static
// array of it with a static string.
//

#if defined(WIN32)

// These are typedef'ed by winnt.h iff VOID is not defined
#define CHAR char
typedef short           SHORT;
typedef long            LONG;
// typedef unsigned int    UINT;

#else

typedef unsigned short  WCHAR;
typedef int             INT;
typedef short           SHORT;
typedef long            LONG;
typedef unsigned int    UINT;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef int             BOOL;
# define FALSE 0
# define TRUE  1
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned long   DWORD;

typedef CHAR *          PCHAR;
typedef INT *           PINT;
typedef UINT *          PUINT;
typedef USHORT *        PUSHORT;
typedef ULONG *         PULONG;
typedef BOOL *          PBOOL;
typedef BYTE *          PBYTE;
typedef WORD *          PWORD;
typedef DWORD *         PDWORD;

typedef VOID *          PVOID;
typedef LONG *          PLONG;
typedef SHORT *         PSHORT;

/* Added for NT builds */

typedef float           FLOAT;
typedef FLOAT *         PFLOAT;
typedef BOOL FAR *      LPBOOL;


// Note: Glock says "f682: signed not implemented.0"  NT's C++ does not
// implement "signed", so remove it to prevent compiler warnings.
//
#if defined(__cplusplus)
extern void * operator new ( size_t sz, void * pv ) ;
typedef char            SCHAR;
#else
# if defined(WIN32)
typedef char            SCHAR;
# else
typedef signed char     SCHAR;
# endif
#endif


/* OS/2 style definitions (for OS/2 API prototypes) - DO NOT USE! */

typedef USHORT          SEL;
typedef SEL *           PSEL;

typedef unsigned char   UCHAR;
typedef UCHAR *         PUCHAR;

typedef CHAR *          PSZ;
typedef CHAR *          PCH;

typedef int (PASCAL FAR  *PFN)();
typedef int (PASCAL NEAR *NPFN)();
typedef PFN FAR *         PPFN;

#define EXPENTRY PASCAL FAR LOADDS
#define APIENTRY PASCAL FAR

typedef unsigned short  SHANDLE;    // defining these here makes the sed pass
typedef void FAR *      LHANDLE;    //  over os2def.h very much simpler

#if defined(WIN32)
typedef UINT            HFILE;
#else
typedef SHANDLE         HFILE;
#endif
typedef HFILE FAR *     PHFILE;


/* OS/2 LM style definitions (for LAN Manager prototypes) - DO NOT USE! */

typedef const CHAR *    CPSZ;  // BUGBUG: bad Hungarian


/* Windows style definitions (for Win API prototypes only) */

typedef CHAR *          PSTR;
typedef WCHAR *         PWSTR;
typedef WCHAR *         PWCH;


/* NEAR and FAR versions (for Windows prototypes) */

// These definitions use preprocessor macros so that Glockenspiel
// can see type equivalence between (e.g.) LPSTR and PCHAR.  They
// elide NEAR and FAR where possible to reduce complaints from its
// flat-model-only (ha!) C++.  So it's all Glock's fault, as always.

// CODEWORK This will break X86 16-bit build
// #if (defined(M_I86SM) || defined(M_I86MM))
#if !defined(_MIPS_) && !defined(_PPC_)
#define NPTSTR          TCHAR *
#define LPTSTR          TCHAR FAR *
#define NPSTR           CHAR *
#define LPSTR           CHAR FAR *
#define NPWSTR          WCHAR *
#define LPWSTR          WCHAR FAR *
#define NPBYTE          BYTE *
#define LPBYTE          BYTE FAR *
#define NPINT           INT *
#define LPINT           INT FAR *
#define NPWORD          WORD *
#define LPWORD          WORD FAR *
#define NPLONG          LONG *
#define LPLONG          LONG FAR *
#define NPDWORD         DWORD *
#define LPDWORD         DWORD FAR *
#define NPVOID          VOID *
#define LPVOID          VOID FAR *
// #elif (defined(M_I86CM) || defined(M_I86LM) || defined(MIPS))
#else
#define NPTSTR          TCHAR NEAR *
#define LPTSTR          TCHAR *
#define NPSTR           CHAR NEAR *
#define LPSTR           CHAR *
#define NPWSTR          WCHAR NEAR *
#define LPWSTR          WCHAR *
#define NPBYTE          BYTE NEAR *
#define LPBYTE          BYTE *
#define NPINT           INT NEAR *
#define LPINT           INT *
#define NPWORD          WORD NEAR *
#define LPWORD          WORD *
#define NPLONG          LONG NEAR *
#define LPLONG          LONG *
#define NPDWORD         DWORD NEAR *
#define LPDWORD         DWORD *
#define NPVOID          VOID NEAR *
#define LPVOID          VOID *
// #else
// #error Memory model unknown - no recognized M_I86xM symbol defined
#endif

#define LPCSTR          const CHAR *


/* Useful helper macros */

#define MAKEP(sel, off) ((PVOID)MAKEULONG(off, sel))

#define SELECTOROF(p)   (((PUSHORT)&(p))[1])
#define OFFSETOF(p)     (((PUSHORT)&(p))[0])

#define MAKEULONG(l, h) ((ULONG)(((USHORT)(l)) | ((ULONG)((USHORT)(h))) << 16))
#define MAKELONG(l, h)  ((LONG)MAKEULONG(l, h))

#define MAKELP(sel, off) ((void *)MAKELONG((off),(sel)))
#define FIELDOFFSET(type, field)  ((int)(&((type NEAR*)1)->field)-1)

#define MAKEUSHORT(l, h) (((USHORT)(l)) | ((USHORT)(h)) << 8)
#define MAKESHORT(l, h)  ((SHORT)MAKEUSHORT(l, h))

#define LOBYTE(w)       LOUCHAR(w)
#define HIBYTE(w)       HIUCHAR(w)
#define LOUCHAR(w)      ((UCHAR)(USHORT)(w))
#define HIUCHAR(w)      ((UCHAR)(((USHORT)(w) >> 8) & 0xff))
#define LOUSHORT(l)     ((USHORT)(ULONG)(l))
#define HIUSHORT(l)     ((USHORT)(((ULONG)(l) >> 16) & 0xffff))

#define LOWORD LOUSHORT
#define HIWORD HIUSHORT

#endif // !WIN32


/* NETUI private types */

/* Error type - what the system APIs return.

   On Win32, this is defined as signed long, in order to pacify the
   compiler, which complains when you assign a long constant
   to an unsigned int (never mind that they're the same size). */

#if defined(WIN32)
typedef LONG    APIERR; // err
#else
typedef UINT    APIERR; // err
#endif // WIN32

/* String resource ID type */

#define MSGID   APIERR

//-ckm #if defined(WIN32)
//-ckm typedef unsigned int   MSGID;  // msg
//-ckm #else
//-ckm typedef UINT           MSGID;  // msg
//-ckm #endif // WIN32

/* Silence the compiler for unreferenced formals. */

#define UNREFERENCED(x) ((void)(x))


/* These define buffer sizes (in TCHAR, no terminators) for rendering
   signed integers into strings, decimal format. */

#define CCH_SHORT   6
#define CCH_LONG    11
#if defined(WIN32)
#define CCH_INT     11
#else
#define CCH_INT     6
#endif
#define CCH_INT64   21

#endif // _LMUITYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\lmuicmn.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmuicmn.h
    Definitions for the common LMUI libraries

    This file must remain C-includable.

    FILE HISTORY:
        beng        30-Jul-1992 Created
*/

extern "C"
{
    // BLT corresponds to the module handle for lmuicmn0.dll,
    // which contains (or attempts to contain) all the GUI components.

    extern HMODULE hmodBlt;

    // BASE corresponds to the module handle for lmuicmn1.dll,
    // which contains LMOBJ, the registry classes, etc.

    extern HMODULE hmodBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\locheap2.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

#ifndef WINDOWS
#error "Only use these APIs under Windows!"
#endif

/****************************************************************************\

	LOCHEAP2.h
	Local-heap management helper routines

	These utility routines provide access to Windows local heaps in
	segments other than DS (the data segment).  They are exactly
	like the LocalInit, LocalAlloc, LocalFree, LocalLock, 
	LocalUnlock, Local handle and LocalSize APIs, except that they
	act on the heap in segment wHeapDS instead of the heap in DS.

	These routines are used primarily by the heap management system
	(see heap.cxx).  They are also used by the
	HEAP_HANDLE/ELEMENT_HANDLE module (see loclheap.hxx).

	USAGE:

	HANDLE hGlobal = GlobalAlloc( GMEM_MOVEABLE, 1024 );
	if ( !hGlobal )
	    error();

	LPSTR lpGlobal = GlobalLock( hGlobal );
	if ( !lpGlobal )
	    error();

	{
	    if ( !DoLocalInit( hGlobal, 1024 ) )
	        error();

	    HANDLE hLocal = DoLocalAlloc( HIWORD(lpGlobal), 128 );
	    if ( !hLocal )
		error();

	    LPSTR lpLocal = DoLocalLock( HIWORD(lpGlobal), hLocal );
	    if ( !lpLocal )
		error();

	    {
		HANDLE hLocal2 = DoLocalHandle(
			HIWORD(lpGlobal), LOWORD(lpLocal) );
		if (hLocal2 != hLocal)
		    error();

		WORD wSize = DoLocalSize( HIWORD(lpGlobal), hLocal );
	        if ( !wSize )
		    error();
	    }

	    DoLocalUnlock( HIWORD(lpGlobal), hLocal );

	    if ( DoLocalFree( HIWORD(lpGlobal), hLocal ) )
		error();
	}

	GlobalUnlock( hGlobal );

	GlobalFree( hGlobal );


	FILE HISTORY:

	jonn	24-Jan-1991	Created
	jonn	21-Mar-1991	Code review changes from 2/20/91 (attended
				by JonN, RustanL, ?)

\****************************************************************************/


#ifndef _LOCHEAP2_H_
#define _LOCHEAP2_H_


BOOL DoLocalInit(WORD wHeapDS, WORD wBytes);

HANDLE DoLocalAlloc(WORD wHeapDS, WORD wFlags, WORD wBytes);

HANDLE DoLocalFree(WORD wHeapDS, HANDLE handleFree);

LPSTR DoLocalLock(WORD wHeapDS, HANDLE handleLocal);

VOID DoLocalUnlock(WORD wHeapDS, HANDLE handleLocal);

HANDLE DoLocalHandle(WORD wHeapDS, WORD wMem);

WORD DoLocalSize(WORD wHeapDS, HANDLE handleLocal);


#endif // _LOCHEAP2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\mbcs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MBCS.H

Abstract:

    Contains mapping functions which transform Unicode strings
    (used by the NT Net APIs) into MBCS strings (used by the
    command-line interface program).

    Prototypes.  See MBCS.C.

Author:

    Ben Goetter     (beng)  26-Aug-1991

Environment:

    User Mode - Win32

Revision History:

    26-Aug-1991     beng
        Created

--*/


/*

The SAVEARGS structure holds the client-supplied field values which
the mapping layer has replaced, so that it may restore them before
returning the buffer to the client.  (The client may wish to reuse
the buffer, and so may expect the previous contents to remain invariant
across calls.  In particular, clients may replace single parameters,
such as passwords deemed incorrect, and try to call again with the
remaining structure left alone.)

An instance of SAVEARGS is accessed but twice in its lifetime: once
when it is built and once when it is freed.

*/

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _MXSAVEARG // mxsav
{
    UINT    offThis;     // offset of this arg within buffer, in bytes
    LPSTR   pszOriginal; // original value of arg
} MXSAVEARG;

typedef struct _MXSAVELIST // mxsavlst
{
    INT         cmxsav; // number of elements in vector
    MXSAVEARG * pmxsav; // pointer to first element in vector
} MXSAVELIST;



// Function prototypes

DLL_BASED
UINT MxAllocUnicode(       LPSTR         pszAscii,
                           LPWSTR *      ppwszUnicode );

DLL_BASED
VOID MxFreeUnicode(        LPWSTR        pwszUnicodeAllocated );

DLL_BASED
UINT MxAllocUnicodeVector( LPSTR *       ppszAscii,
                           LPWSTR *      ppwszUnicode,
                           UINT          c );

DLL_BASED
VOID MxFreeUnicodeVector(  LPWSTR *      ppwsz,
                           UINT          cpwsz );

DLL_BASED
UINT MxAllocUnicodeBuffer( LPBYTE        pbAscii,
                           LPWCH *       ppwchUnicode,
                           UINT          cbAscii );

#define MxFreeUnicodeBuffer(buf) (MxFreeUnicode((LPWSTR)(buf)))

#define MxUnicodeBufferSize(size) (sizeof(WCHAR)/sizeof(CHAR)*(size))

DLL_BASED
UINT MxAsciifyInplace(     LPWSTR        pwszUnicode );

DLL_BASED
UINT MxAllocSaveargs(      UINT          cmxsav,
                           MXSAVELIST ** ppmxsavlst );

DLL_BASED
VOID MxFreeSaveargs(       MXSAVELIST *  ppmxsavlst );

DLL_BASED
UINT MxJoinSaveargs(       MXSAVELIST *  pmxsavlstMain,
                           MXSAVELIST *  pmxsavlstAux,
                           UINT          dbAuxFixup,
                           MXSAVELIST ** ppmxsavlstOut );

DLL_BASED
UINT MxMapParameters(      UINT          cParam,
                           LPWSTR*       ppwszUnicode,
                           ... );

DLL_BASED
UINT MxMapClientBuffer(    BYTE *        pbInput,
                           MXSAVELIST ** ppmxsavlst,
                           UINT          cRecords,
                           CHAR *        pszDesc );

DLL_BASED
UINT MxMapClientBufferAux( BYTE *        pbInput,
                           CHAR *        pszDesc,
                           BYTE *        pbInputAux,
                           UINT          cRecordsAux,
                           CHAR *        pszDescAux,
                           MXSAVELIST ** ppmxsavlst );

DLL_BASED
VOID MxRestoreClientBuffer(BYTE *        pbBuffer,
                           MXSAVELIST *  pmxsavlst );

DLL_BASED
UINT MxMapSetinfoBuffer(   BYTE * *      ppbInput,
                           MXSAVELIST ** ppmxsavlst,
                           CHAR *        pszDesc,
                           CHAR *        pszRealDesc,
                           UINT          nField );

DLL_BASED
UINT MxRestoreSetinfoBuffer( BYTE * *     ppbBuffer,
                             MXSAVELIST * pmxsavlst,
                             CHAR *       pszDesc,
                             UINT         nField );

DLL_BASED
UINT MxAsciifyRpcBuffer(     BYTE *      pbInput,
                             DWORD       cRecords,
                             CHAR *      pszDesc );

DLL_BASED
UINT MxAsciifyRpcBufferAux(  BYTE *      pbInput,
                             CHAR *      pszDesc,
                             BYTE *      pbInputAux,
                             DWORD       cRecordsAux,
                             CHAR *      pszDescAux );

DLL_BASED
UINT MxAsciifyRpcEnumBufferAux( BYTE *  pbInput,
                                DWORD   cRecords,
                                CHAR *  pszDesc,
                                CHAR *  pszDescAux );

DLL_BASED
UINT MxCalcNewInfoFromOldParm( UINT nLevelOld,
                               UINT nParmnumOld );

// These macros are used by all the functions which use the canonicalization
// routines. They are used to optionally translate Ascii to Unicode, without
// asking for more memory if no conversion is necessary.

#ifdef UNICODE

#define MxAllocTString(pszAscii, pptszTString) \
    MxAllocUnicode((pszAscii), (pptszTString))
#define MxFreeTString(ptszTString) \
    MxFreeUnicode((ptszTString))

#else

#define MxAllocTString(pszAscii, pptszTString) \
    ((*(pptszTString) = (pszAscii)), 0)
#define MxFreeTString(ptszTString)

#endif

DLL_BASED
UINT MxMapStringsToTStrings(      UINT          cStrings,
                                  ... );

DLL_BASED
UINT MxFreeTStrings(              UINT          cStrings,
                                  ... );

#ifdef __cplusplus
}       // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\mnet32.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    mnet32.h
    <Single line synopsis>

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
	KeithMo	    13-Oct-1991	Created from DanHi's private port1632.h.
	terryk	    21-Oct-1991	change SERVER_INFO and USER_LOGON
	terryk	    31-Oct-1991	add use_info_2
	Yi-HsinS     5-Feb-1992	add the missing ae_resaccess
*/


#ifndef _MNET32_H_
#define _MNET32_H_


//
//  The following items are necessary under Windows NT.  These
//  were ripped off from DanHi's PORT1632.H.
//

#ifdef WIN32

// #define LPWSTR			LPSTR	    // Until proven otherwise...

 #define MAXPATHLEN		MAX_PATH

 #define WORKBUFSIZE		4096
 #define MAXWORKSTATIONS	8

 //
 // Temporary hacks.
 //

 #define AE_GENERIC		AE_GENERIC_TYPE
 #define GRP1_PARMNUM_COMMENT	GROUP_COMMENT_PARMNUM

 //
 // End of temporary hacks.
 //
 // (Wishful thinking, eh?)
 //

 #define MAXPREFERREDLENGTH	MAX_PREFERRED_LENGTH

 //
 // The naming convention for structures is different in NT than in LM 2.x.
 //

 #define audit_entry		_AUDIT_ENTRY
 #define ae_srvstatus		_AE_SRVSTATUS
 #define ae_sesslogon		_AE_SESSLOGON
 #define ae_sesslogoff		_AE_SESSLOGOFF
 #define ae_sesspwerr		_AE_SESSPWERR
 #define ae_connstart		_AE_CONNSTART
 #define ae_connstop		_AE_CONNSTOP
 #define ae_connrej		_AE_CONNREJ
 #define ae_resaccess		_AE_RESACCESS
 #define ae_resaccess2		_AE_RESACCESS
 
 #define ae_ra2_compname	ae_ra_compname
 #define ae_ra2_username	ae_ra_username
 #define ae_ra2_resname		ae_ra_resname
 #define ae_ra2_operation	ae_ra_operation
 #define ae_ra2_returncode	ae_ra_returncode
 #define ae_ra2_restype		ae_ra_restype
 #define ae_ra2_fileid		ae_ra_fileid
 
 #define ae_resaccessrej	_AE_RESACCESSREJ
 #define ae_closefile		_AE_CLOSEFILE
 #define ae_servicestat		_AE_SERVICESTAT
 #define ae_aclmod		_AE_ACLMOD
 #define ae_uasmod		_AE_UASMOD
 #define ae_netlogon		_AE_NETLOGON
 #define ae_netlogoff		_AE_NETLOGOFF
 #define ae_acclim		_AE_ACCLIM
 #define ae_lockout             _AE_LOCKOUT
 #define ae_generic		_AE_GENERIC
 #define error_log		_ERROR_LOG
 #define user_info_0		_USER_INFO_0
 #define user_info_1		_USER_INFO_1
 #define user_info_2		_USER_INFO_2
 #define user_info_10		_USER_INFO_10
 #define user_info_11		_USER_INFO_11
 #define user_modals_info_0	_USER_MODALS_INFO_0
 #define user_modals_info_1	_USER_MODALS_INFO_1
 #define user_logon_req_1	_USER_LOGON_REQ_1
 #define user_logon_info_0	_USER_LOGON_INFO_0
 // WIN32BUGBUG
 // should be INFO_1
 #define user_logon_info_1	_USER_LOGON_INFO_2
 #define user_logon_info_2	_USER_LOGON_INFO_2
 #define user_logoff_req_1	_USER_LOGOFF_REQ_1
 #define user_logoff_info_1	_USER_LOGOFF_INFO_1
 #define group_info_0		_GROUP_INFO_0
 #define group_info_1		_GROUP_INFO_1
 #define group_users_info_0	_GROUP_USERS_INFO_0
 #define access_list		_ACCESS_LIST
 #define access_info_0		_ACCESS_INFO_0
 #define access_info_1		_ACCESS_INFO_1
 #define chardev_info_0		_CHARDEV_INFO_0
 #define chardev_info_1		_CHARDEV_INFO_1
 #define chardevQ_info_0	_CHARDEVQ_INFO_0
 #define chardevQ_info_1	_CHARDEVQ_INFO_1
 #define msg_info_0		_MSG_INFO_0
 #define msg_info_1		_MSG_INFO_1
 #define statistics_info_0	_STATISTICS_INFO_0
 #define stat_workstation_0	_STAT_WORKSTATION_0
 #define stat_server_0		_STAT_SERVER_0
 #define service_info_0		_SERVICE_INFO_0
 #define service_info_1		_SERVICE_INFO_1
 #define service_info_2		_SERVICE_INFO_2
 #define share_info_0		_SHARE_INFO_0
 #define share_info_1		_SHARE_INFO_1
 #define share_info_2		_SHARE_INFO_2
 #define session_info_0		_SESSION_INFO_0
 #define session_info_1		_SESSION_INFO_1
 #define session_info_2		_SESSION_INFO_2
 #define session_info_10	_SESSION_INFO_10
 #define connection_info_0	_CONNECTION_INFO_0
 #define connection_info_1	_CONNECTION_INFO_1
 #define file_info_0		_FILE_INFO_0
 #define file_info_1		_FILE_INFO_1
 #define file_info_2		_FILE_INFO_2
 #define file_info_3		_FILE_INFO_3
 #define res_file_enum_2	_RES_FILE_ENUM_2
 #define res_file_enum_2	_RES_FILE_ENUM_2
 #define use_info_0		_USE_INFO_0
 #define use_info_1		_USE_INFO_1
 #define use_info_2		_USE_INFO_2
 #define time_of_day_info	_TIME_OF_DAY_INFO
 
 //
 // Macros to support old style resume keys.
 //

 typedef DWORD		FRK;
 #define FRK_INIT(x)	(x) = 0

#endif	// WIN32


#endif	// _MNET32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\mnettype.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    mnettype.h
    <Single line synopsis>

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        JonN        22-Oct-1991 Split from mnet.h
        KeithMo     29-Oct-1991 Added HLOG_INIT.
        KeithMo     25-Aug-1992 Removed bogus typedefs & #defines.

*/


#ifndef _MNETTYPE_H_
#define _MNETTYPE_H_


//
//  These items vary depending on WIN16/WIN32.  These were ripped-off
//  from ptypes[16|32].h and plan[16|32].h.
//
//  Note that we assume that if WIN32 is *not* defined, then
//  we're building for a 16-bit environment, either DOS Win16
//  or OS/2.
//

#ifdef WIN32

 #ifndef COPYTOARRAY
  #define COPYTOARRAY(pDest, pSource)     (pDest) = (pSource)
 #endif

#else   // !WIN32

 #ifndef COPYTOARRAY
  #define COPYTOARRAY(pDest, pSource)     strcpyf((pDest), (pSource))
 #endif

 //
 //  We need this so we can kludge together a
 //  MNetWkstaUserEnum for the 16-bit side of the world.
 //

 typedef struct _WKSTA_USER_INFO_1 {
     TCHAR FAR * wkui1_username;
     TCHAR FAR * wkui1_logon_domain;
     TCHAR FAR * wkui1_logon_server;
 } WKSTA_USER_INFO_1, *PWKSTA_USER_INFO_1, *LPWKSTA_USER_INFO_1;


#endif  // WIN32


#if defined( INCL_NETAUDIT ) || defined( INCL_NETERRORLOG )

//
//  This macro is defined here just because LanMan (and NT)
//  audit/error log handle initialization is SOOOO gross.
//
//  Note that this macro currently depends on the actual
//  field names of the HLOG structure.  We may need to
//  change this in the future...
//

#define HLOG_INIT(x)    if( 1 )                                             \
                        {                                                   \
                            (x).time       = 0;                             \
                            (x).last_flags = 0;                             \
                            (x).offset     = -1;                            \
                            (x).rec_offset = -1;                            \
                        }                                                   \
                            else

#endif  // INCL_NETAUDIT || INCL_NETERRORLOG


#endif  // _MNETTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\mnet.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    mnet.h
    <Single line synopsis>

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     13-Oct-1991 Created from DanHi's private port1632.h.
        JonN        22-Oct-1991 Split off mnettype.h
        KeithMo     28-Oct-1991 Changed to "sane" typedefs.
        KeithMo     30-Oct-1991 Added MNetApiBufferReAlloc and
                                MNetApiBufferSize, removed obsolete
                                MNetAuditOpen() and MNetErrorLogOpen() API.
        KeithMo     25-Feb-1992 Added NetReplXxx APIs.
        KeithMo     08-Feb-1993 Added I_MNetComputerNameCompare API.

        CongpaY     10-March-1993 Add IsNetSlow.
*/


#ifndef _MNET_H_
#define _MNET_H_


#include "mnettype.h"

#define NAMETYPE_COMMENT   500

#ifdef __cplusplus
extern "C" {
#endif

//
//  API buffer manipulation.
//

DLL_BASED
BYTE FAR * MNetApiBufferAlloc(
        UINT               cbBuffer );

DLL_BASED
VOID MNetApiBufferFree(
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetApiBufferReAlloc(
        BYTE FAR        ** ppbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetApiBufferSize(
        BYTE FAR         * pbBuffer,
        UINT FAR         * pcbBuffer );


//
//  Internal API.
//

DLL_BASED
APIERR I_MNetNameCanonicalize(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        TCHAR FAR        * pszOutput,
        UINT               cbOutput,
        UINT               NameType,
        ULONG              flFlags );

DLL_BASED
APIERR I_MNetNameCompare(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath1,
        const TCHAR FAR  * pszPath2,
        UINT               NameType,
        ULONG              flFlags );

DLL_BASED
APIERR I_MNetNameValidate(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszName,
        UINT               NameType,
        ULONG              flFlags );

DLL_BASED
APIERR I_MNetPathCanonicalize(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        TCHAR FAR        * pszOutput,
        UINT               cbOutput,
        const TCHAR FAR  * pszPrefix,
        ULONG FAR        * pflPathType,
        ULONG              flFlags );

DLL_BASED
APIERR I_MNetPathCompare(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath1,
        const TCHAR FAR  * pszPath2,
        ULONG              flPathType,
        ULONG              flFlags );

DLL_BASED
APIERR I_MNetPathType(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        ULONG FAR        * pflPathType,
        ULONG              flFlags );

DLL_BASED
INT I_MNetComputerNameCompare(
        const TCHAR FAR  * pszComputer1,
        const TCHAR FAR  * pszComputer2 );


//
//  BUGBUG!
//
//  This API is pretty bogus, but 16-bit SrvMgr needs it,
//  so here it is.  Handling this API correctly under NT
//  will be a real challenge.
//

DLL_BASED
APIERR MDosPrintQEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppBuffer,
        UINT FAR         * pcEntriesRead );


//
//  Access API.
//

#ifdef  INCL_NETACCESS

DLL_BASED
APIERR MNetAccessAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetAccessCheck(
        TCHAR FAR        * pszReserved,
        TCHAR FAR        * pszUserName,
        TCHAR FAR        * pszResource,
        UINT               Operation,
        UINT FAR         * pResult );

DLL_BASED
APIERR MNetAccessDel(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszResource );

DLL_BASED
APIERR MNetAccessEnum(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszBasePath,
        UINT               fRecursive,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetAccessGetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszResource,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetAccessGetUserPerms(
        TCHAR FAR        * pszServer,
        TCHAR FAR        * pszUgName,
        TCHAR FAR        * pszResource,
        UINT FAR         * pPerms );

DLL_BASED
APIERR MNetAccessSetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszResource,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

#endif  // INCL_NETACCESS


//
//  Alert API.
//

#ifdef INCL_NETALERT

DLL_BASED
APIERR MNetAlertRaise(
        const TCHAR FAR  * pszEvent,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        ULONG              ulTimeout );

DLL_BASED
APIERR MNetAlertStart(
        const TCHAR FAR  * pszEvent,
        const TCHAR FAR  * pszRecipient,
        UINT               cbMaxData );

DLL_BASED
APIERR MNetAlertStop(
        const TCHAR FAR  * pszEvent,
        const TCHAR FAR  * pszRecipient );

#endif  // INCL_NETALERT


//
//  Audit API.
//

#ifdef INCL_NETAUDIT

DLL_BASED
APIERR MNetAuditClear(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszBackupFile,
        TCHAR FAR        * pszService );

DLL_BASED
APIERR MNetAuditRead(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszService,
        HLOG FAR         * phAuditLog,
        ULONG              ulOffset,
        UINT FAR         * pReserved2,
        ULONG              ulReserved3,
        ULONG              flOffset,
        BYTE FAR        ** ppbBuffer,
        ULONG              ulMaxPreferred,
        UINT FAR         * pcbReturned,
        UINT FAR         * pcbTotalAvail );

DLL_BASED
APIERR MNetAuditWrite(
        UINT               Type,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        TCHAR FAR        * pszService,
        TCHAR FAR        * pszReserved );

#endif  // INCL_NETAUDIT


//
//  NetBIOS API.
//

#ifdef INCL_NETBIOS

struct ncb;         // forward declaration

DLL_BASED
APIERR MNetBiosClose(
        UINT               hDevName,
        UINT               Reserved );

DLL_BASED
APIERR MNetBiosEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** pbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetBiosGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszNetBiosName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetBiosOpen(
        TCHAR FAR        * pszDevName,
        TCHAR FAR        * pszReserved,
        UINT               OpenOpt,
        UINT FAR         * phDevName );

DLL_BASED
APIERR MNetBiosSubmit(
        UINT               hDevName,
        UINT               NcbOpt,
        struct ncb FAR   * pNCB );

#endif  // INCL_NETBIOS


//
//  CharDev API.
//

#ifdef INCL_NETCHARDEV

DLL_BASED
APIERR MNetCharDevControl(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDevName,
        UINT               OpCode );

DLL_BASED
APIERR MNetCharDevEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetCharDevGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDevName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetCharDevQEnum(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszUserName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetCharDevQGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszQueueName,
        const TCHAR FAR  * pszUserName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetCharDevQPurge(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszQueueName );

DLL_BASED
APIERR MNetCharDevQPurgeSelf(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszQueueName,
        const TCHAR FAR  * pszComputerName );

DLL_BASED
APIERR MNetCharDevQSetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszQueueName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

#endif  // INCL_NETCHARDEV


//
// Configuration API.
//

#ifdef INCL_NETCONFIG

DLL_BASED
APIERR MNetConfigGet(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszReserved,
        const TCHAR FAR  * pszComponent,
        const TCHAR FAR  * pszParameter,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetConfigGetAll(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszReserved,
        const TCHAR FAR  * pszComponent,
        BYTE FAR        ** ppbBuffer);

DLL_BASED
APIERR MNetConfigSet(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszComponent,
        const TCHAR FAR  * pszKey,
        const TCHAR FAR  * pszData );

#endif  // INCL_NETCONFIG


//
// Connection API.
//

#ifdef INCL_NETCONNECTION

DLL_BASED
APIERR MNetConnectionEnum(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszQualifier,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

#endif  // INCL_NETCONNECTION


//
// Domain API.
//

#ifdef INCL_NETDOMAIN

DLL_BASED
APIERR MNetGetDCName(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDomain,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetLogonEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR I_MNetLogonControl(
        const TCHAR FAR  * pszServer,
        ULONG              FunctionCode,
        ULONG              Level,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETDOMAIN


//
// ErrorLog API.
//

#ifdef INCL_NETERRORLOG

DLL_BASED
APIERR MNetErrorLogClear(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszBackupFile,
        TCHAR FAR        * pszReserved );

DLL_BASED
APIERR MNetErrorLogRead(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszReserved1,
        HLOG FAR         * phErrorLog,
        ULONG              ulOffset,
        UINT FAR         * pReserved2,
        ULONG              ulReserved3,
        ULONG              flOffset,
        BYTE FAR        ** ppbBuffer,
        ULONG              ulMaxPreferred,
        UINT FAR         * pcbReturned,
        UINT FAR         * pcbTotalAvail );

DLL_BASED
APIERR MNetErrorLogWrite(
        TCHAR FAR        * pszReserved1,
        UINT               Code,
        const TCHAR FAR  * pszComponent,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        const TCHAR FAR  * pszStrBuf,
        UINT               cStrBuf,
        TCHAR FAR        * pszReserved2 );

#endif  // INCL_NETERRORLOG


//
// File API.
//

#ifdef INCL_NETFILE

DLL_BASED
APIERR MNetFileClose(
        const TCHAR FAR  * pszServer,
        ULONG              ulFileId );

DLL_BASED
APIERR MNetFileEnum(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszBasePath,
        const TCHAR FAR  * pszUserName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        ULONG              ulMaxPreferred,
        UINT FAR         * pcEntriesRead,
        UINT FAR         * pcTotalAvail,
        VOID FAR         * pResumeKey );

DLL_BASED
APIERR MNetFileGetInfo(
        const TCHAR FAR  * pszServer,
        ULONG              ulFileId,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETFILE


//
// Group API.
//

#ifdef INCL_NETGROUP

DLL_BASED
APIERR MNetGroupAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetGroupAddUser(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        TCHAR FAR        * pszUserName );

DLL_BASED
APIERR MNetGroupDel(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName );

DLL_BASED
APIERR MNetGroupDelUser(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        TCHAR FAR        * pszUserName );

DLL_BASED
APIERR MNetGroupEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetGroupGetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetGroupGetUsers(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetGroupSetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

DLL_BASED
APIERR MNetGroupSetUsers(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               cEntries );

DLL_BASED
APIERR MNetLocalGroupAddMember(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        PSID               psidMember );

#endif  // INCL_NETGROUP


//
// Handle API.
//

#ifdef INCL_NETHANDLE

DLL_BASED
APIERR MNetHandleGetInfo(
        UINT               hHandle,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetHandleSetInfo(
        UINT               hHandle,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

#endif  // INCL_NETHANDLE


//
// Message API.
//

#ifdef INCL_NETMESSAGE

DLL_BASED
APIERR MNetMessageBufferSend(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszRecipient,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetMessageFileSend(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszRecipient,
        TCHAR FAR        * pszFileSpec );

DLL_BASED
APIERR MNetMessageLogFileGet(
        const TCHAR FAR  * pszServer,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pfsEnabled );

DLL_BASED
APIERR MNetMessageLogFileSet(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszFileSpec,
        UINT               fsEnabled );

DLL_BASED
APIERR MNetMessageNameAdd(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszMessageName,
        UINT               fsFwdAction );

DLL_BASED
APIERR MNetMessageNameDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszMessageName,
        UINT               fsFwdAction );

DLL_BASED
APIERR MNetMessageNameEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetMessageNameFwd(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszMessageName,
        const TCHAR FAR  * pszForwardName,
        UINT               fsDelFwdName );

DLL_BASED
APIERR MNetMessageNameGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszMessageName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetMessageNameUnFwd(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszMessageName );

#endif  // INCL_NETMESSAGE


//
// Remote API.
//

#ifdef INCL_NETREMUTIL

DLL_BASED
APIERR MNetRemoteCopy(
        const TCHAR FAR  * pszSourcePath,
        const TCHAR FAR  * pszDestPath,
        const TCHAR FAR  * pszSourcePasswd,
        const TCHAR FAR  * pszDestPasswd,
        UINT               fsOpen,
        UINT               fsCopy,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetRemoteMove(
        const TCHAR FAR  * pszSourcePath,
        const TCHAR FAR  * pszDestPath,
        const TCHAR FAR  * pszSourcePasswd,
        const TCHAR FAR  * pszDestPasswd,
        UINT               fsOpen,
        UINT               fsMove,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetRemoteTOD(
        const TCHAR FAR  * pszServer,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETREMUTIL


// 585780-2002/04/17-JonN MNetRepl APIs no longer used
/*
//
//  Replicator API.
//

#ifdef INCL_NETREPL

DLL_BASED
APIERR MNetReplGetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetReplSetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer );

DLL_BASED
APIERR MNetReplExportDirAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer );

DLL_BASED
APIERR MNetReplExportDirDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory );

DLL_BASED
APIERR MNetReplExportDirEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetReplExportDirGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetReplExportDirSetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR         * pbBuffer );

DLL_BASED
APIERR MNetReplExportDirLock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory );

DLL_BASED
APIERR MNetReplExportDirUnlock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Force );

DLL_BASED
APIERR MNetReplImportDirAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer );

DLL_BASED
APIERR MNetReplImportDirDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory );

DLL_BASED
APIERR MNetReplImportDirEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetReplImportDirGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetReplImportDirLock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory );

DLL_BASED
APIERR MNetReplImportDirUnlock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Force );

#endif  // INCL_NETREPL
*/


//
// Server API.
//

#ifdef INCL_NETSERVER

DLL_BASED
APIERR MNetServerAdminCommand(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszCommand,
        UINT FAR         * psResult,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT FAR         * pcbReturned,
        UINT FAR         * pcbTotalAvail );

DLL_BASED
APIERR MNetServerDiskEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetServerEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead,
        ULONG              flServerType,
        TCHAR FAR        * pszDomain );

DLL_BASED
APIERR MNetServerGetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetServerSetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

#endif  // INCL_NETSERVER


//
// Service API.
//

#ifdef INCL_NETSERVICE

DLL_BASED
APIERR MNetServiceControl(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszService,
        UINT               OpCode,
        UINT               Arg,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetServiceEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetServiceGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszService,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetServiceInstall(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszService,
        const TCHAR FAR  * pszCmdArgs,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetServiceStatus(
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

#endif  // INCL_NETSERVICE


//
// Session API.
//

#ifdef INCL_NETSESSION

DLL_BASED
APIERR MNetSessionDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszClientName,
        const TCHAR FAR  * pszUserName );

DLL_BASED
APIERR MNetSessionEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetSessionGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszClientName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETSESSION


//
// Share API.
//

#ifdef INCL_NETSHARE

DLL_BASED
APIERR MNetShareAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetShareCheck(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDeviceName,
        UINT FAR         * pType );

DLL_BASED
APIERR MNetShareDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszNetName,
        UINT               Reserved );

DLL_BASED
APIERR MNetShareDelSticky(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszNetName,
        UINT               Reserved );

DLL_BASED
APIERR MNetShareEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetShareEnumSticky(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetShareGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszNetName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetShareSetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszNetName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

#endif  // INCL_NETSHARE


//
// Statistics API.
//

#ifdef INCL_NETSTATS

DLL_BASED
APIERR MNetStatisticsClear(
        const TCHAR FAR  * pszServer );

DLL_BASED
APIERR MNetStatisticsGet(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszService,
        ULONG              ulReserved,
        UINT               Level,
        ULONG              flOptions,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETSTATS


//
// Use API.
//

#ifdef INCL_NETUSE

DLL_BASED
APIERR MNetUseAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetUseDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDeviceName,
        UINT               Force );

DLL_BASED
APIERR MNetUseEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetUseGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszUseName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETUSE


//
// User API.
//

#ifdef INCL_NETUSER

DLL_BASED
APIERR MNetUserAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetUserDel(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszUserName );

DLL_BASED
APIERR MNetUserEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        UINT               Filter,
        BYTE FAR        ** ppbBuffer,
        ULONG              ulMaxPreferred,
        UINT FAR         * pcEntriesRead,
        UINT FAR         * pcTotalEntries,
        VOID FAR         * pResumeKey );

DLL_BASED
APIERR MNetUserGetGroups(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszUserName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetUserGetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszUserName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetUserModalsGet(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetUserModalsSet(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

DLL_BASED
APIERR MNetUserPasswordSet(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszUserName,
        TCHAR FAR        * pszOldPassword,
        TCHAR FAR        * pszNewPassword );

DLL_BASED
APIERR MNetUserSetGroups(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszUserName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               cEntries );

DLL_BASED
APIERR MNetUserSetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszUserName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum );

DLL_BASED
APIERR MNetUserValidate(
        TCHAR FAR        * pszReserved1,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT               Reserved2 );

#endif  // INCL_NETUSER


//
// Workstation API.
//

#ifdef INCL_NETWKSTA

DLL_BASED
APIERR MNetWkstaGetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

DLL_BASED
APIERR MNetWkstaSetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer );

DLL_BASED
APIERR MNetWkstaSetUID(
        TCHAR FAR        * pszReserved,
        TCHAR FAR        * pszDomain,
        TCHAR FAR        * pszUserName,
        TCHAR FAR        * pszPassword,
        TCHAR FAR        * pszParms,
        UINT               LogoffForce,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT FAR         * pcbTotalAvail );

DLL_BASED
APIERR MNetWkstaUserEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead );

DLL_BASED
APIERR MNetWkstaUserGetInfo(
        const TCHAR FAR  * pszReserved, // Must Be Zero
        UINT               Level,
        BYTE FAR        ** ppbBuffer );

#endif  // INCL_NETWKSTA

DLL_BASED
APIERR IsSlowTransport (
        const TCHAR FAR  * pszServer,
        BOOL FAR         * pfSlowTransport );

#ifdef __cplusplus
}
#endif

#endif  // _MNET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\newprof.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990,1991          **/
/********************************************************************/

/*
    newprof.h
    C-language wrappers for ini-file-handling classes


    FILE HISTORY:
    10/11/90  jonn	created
    01/10/91  jonn	removed PSHORT, PUSHORT
    01/27/91  jonn	changed from CFGFILE, added UserProfileInit/Free
    02/02/91  jonn	added UserProfileWrite/Clear, removed Confirm, 
  			redefined Set.
    02/04/91  jonn	added cpszUsername param to Query, Enum, Set
    03/08/91  chuckc	added UserPreferenceXXX() calls. 
    04/16/91  jonn	added USERPREF_CONFIRMATION and USERPREF_ADMINMENUS
    05/08/91  jonn	Added canonicalization of netnames, canonicalize
  			on read
    05/28/91  jonn	Restructured to allow preferences in LMUSER.INI
*/

#ifndef _NEWPROF_H_
#define _NEWPROF_H_

/****************************************************************************

    MODULE: NewProf.h

    PURPOSE: Handles low-level manipulation of user preference files

    FUNCTIONS:

	UserPreferenceRead() - Reads the preferences from permanent storage
			    into a file image, for future UserPreference or
			    UserPref calls.
	UserPreferenceWrite() - Writes the preferences from a file image
			    into permanent storage.
	UserPreferenceFree() - Frees memory claimed by a file image.

	UserPrefStringQuery() - queries a single user preference string.
	UserPrefStringSet() - saves a single user preference string.
			    It is generally advisable to immediately precede
			    this call with UserPreferenceRead, and to
			    immediately follow it with UserPreferenceSet.

	UserPrefBoolQuery() - queries a single user preference bool value.
	UserPrefBoolSet() - saves a single user preference bool value.
			    Same usage recommendations as UserPrefStringSet.

	UserPrefProfileQuery() - Returns one device connection from a file
			    image.
	UserPrefProfileEnum() - Lists all device connections in a file image.
	UserPrefProfileSet() - Changes a device connection in a file image.
			    Same usage recommendations as UserPrefStringSet.
	UserPrefProfileTrim() - Trims all components in a file image
			    which are not relevant to device connections.


    COMMENTS:

      These APIs are wrappers to the C++ INI-file handling classes defined
      in newprof.hxx.  Most clients will prefer to use the wrapper APIs,
      including all C clients.  These wrapper APIs provide almost all
      the functionality of the C++ APIs.  The C++ APIs are more subject to
      change with changing implementation (NT configuration manager, DS)
      than are these C-language wrappers.

      UserPreference routines:

	Under LM21, these routines read and write the local LMUSER.INI.
	These sticky values are therefore all local to the workstation;
	this mechanism is not intended for values associated with a user.

	Under LM30, the preferences in LMUSER.INI will only be used if the
	preferences stored in the DS (NT Configuration Manager?) are
	unavailable.  Some preferences, such as default username, will be
	stored in LMUSER.INI regardless.

	UserPreferenceRead returns a PFILEIMAGE which the UserPreference APIs
	can interpret as an image of the LMUSER.INI file.  This PFILEIMAGE
	must be passed through to UserPreferenceWrite and to the
	UserPrefProfile, UserPrefBool etc. APIs.  When this image is no
	longer needed, it should be freed with UserPreferenceFree.

	Remember that a user may be logged on from several different
	machines, and that the cached profile is not automatically
	updated.  When the profile is to be changed in permanent
	storage, it is generally advisable to reread the profile from
	permanent storage with UserPreferenceRead, make the change in the
	cache with UserPrefBoolSet (et al), and immediately rewrite the
	profile with UserPreferenceWrite; this reduces the chance that
	another user's changes will be lost.

	When successful, these APIs return NERR_Success (0).  The following
	are the error codes returned by the UserPref APIs:

	NERR_CfgCompNotFound: the specified component is not in the file
	NERR_CfgParamNotFound: the specified parameter is not in the file,
		or it is in the file but is not valid for a parameter of
		this type.
	NERR_InvalidDevice: bad devicename argument
	ERROR_BAD_NET_NAME: bad remotename argument
	ERROR_NOT_ENOUGH_MEMORY:  lack of global memory
	other file read and file write errors


      UserPref routines:

	These routines read and write one particular type of sticky
	values.  For example, the UserPrefProfile APIs read and write
	device profile entries, while UserPrefBool APis read and write
	boolean-valued entries.  Client programs must still read the file
	image first with UserPreferenceRead, save the changes with
	UserPreferenceWrite, and free the file image with UserPreferenceFree.

	Use UserPrefProfileTrim when you intend to keep the file image
	around for a long time (e.g. in a cache), and are not iterested
	in entries other than device connections.  Do not write such a
	trimmed file image, you will lose the other entries!

	Use UserPrefStringSet(pfileimage,usKey,NULL) to remove both
	string-valued parameters and boolean-valued parameters.


    CAVEATS:

	These routines take PSZ and CPSZ buffers because these are
	explicitly far for C programs (in particular lui\profile.c), but
	do not generate errors under C++.


****************************************************************************/



/* returncodes: */



/* global macros */
#include <newprofc.h>


/* typedefs: */

typedef PVOID PFILEIMAGE;
typedef PFILEIMAGE FAR * PPFILEIMAGE;


/* functions: */


/*************************************************************************

    NAME:	UserPreferenceRead

    SYNOPSIS:	UserPreferenceRead attempts to read the user's profile from
    		permanent storage (<cpszLanroot>\LMUSER.INI for LM21).
		It returns a PFILEIMAGE which serves as a "file image" for use
		of the other APIs.

    INTERFACE:  UserPreferenceRead( ppFileImage )
		ppFileImage - returns pointer to a file image.

		Return values are:
		NERR_Success
		ERROR_NOT_ENOUGH_MEMORY
		errors in NetWkstaGetInfo[1]
		file read errors

    USES:	Use to obtain a file image for use in the UserPref APIs.

    NOTES:	Currently, the values are stored in LANMAN.INI, and hence
		each value is per machine.

		Use UserPreferenceFree to release the file image when
		it is no longer needed.

    		Some users may choose to ignore ERROR_FILE_NOT_FOUND.
		The file image must be freed regardless of the return
		code.

    HISTORY:
 	jonn	10/11/90	Created
 	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI
	jonn	06/26/91	No longer takes LANROOT parameter

**************************************************************************/

APIERR UserPreferenceRead(
	PPFILEIMAGE ppFileImage
	) ;



/*************************************************************************

    NAME:	UserPreferenceWrite

    SYNOPSIS:	UserPreferenceWrite attempts to write the user's profile
		back to permanent storage.

    INTERFACE:  UserPreferenceWrite( pFileImage )
		pFileImage - a file image originally obtained from
			UserPreferenceRead.

		Return values are:
		NERR_Success
		ERROR_NOT_ENOUGH_MEMORY
		file write errors

    USES:	Use to write out changes to the preferences in a file image.

    HISTORY:
 	jonn	10/11/90	Created
 	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI
	jonn	06/26/91	No longer takes LANROOT parameter

**************************************************************************/

APIERR UserPreferenceWrite(
	PFILEIMAGE pFileImage
	) ;



/*************************************************************************

    NAME:	UserPreferenceFree

    SYNOPSIS:	UserPreferenceFree releases a file image.

    INTERFACE:  UserPreferenceFree( pFileImage )
		pFileImage - a file image originally obtained from
			UserPreferenceRead.

    RETURNS:	NERR_Success

    USES:	Use when a file image is no longer needed.  File images
    		use a considerable amount of memory, so be sure to free
		them.

    NOTES:	It is permitted to free a null file image pointer.

    CAVEATS:	Do not use the file image after it has been freed.

    HISTORY:
 	jonn	10/11/90	Created
 	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPreferenceFree(
	PFILEIMAGE pFileImage
	) ;


/*************************************************************************

    NAME:	UserPrefStringQuery

    SYNOPSIS:	Queries a user preference (i.e. remembered string).

    INTERFACE:  UserPrefStringQuery( pFileImage, usKey, pszBuffer, cbBuffer )
		pFileImage - as obtained from UserPreferenceRead
		usKey 	 - will indicate which value we want, as defined
			   in newprofc.h.
		pszBuffer - pointer to buffer that will receive value
		cbBuffer - size of buffer in bytes

		return values are:
		NERR_Success
		NERR_CfgCompNotFound
		NERR_CfgParamNotFound
		ERROR_INVALID_PARAMETER: bad usKey
		NERR_BufTooSmall
		ERROR_NOT_ENOUGH_MEMORY

    USES:	Use to recall string-valued parameters, normally things
    		like default logon name.  Do not use for boolean-valued
		parameters -- for those, use UserPrefBool instead.

    NOTES:	Currently, the values are stored in LANMAN.INI, and hence
		each value is per machine.

		A buffer of size MAXPATHLEN+1 is guaranteed to be large enough.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefStringQuery( PFILEIMAGE      pFileImage,
			    USHORT     usKey,
		            PSZ        pszBuffer,
			    USHORT     cbBuffer) ;


/*************************************************************************

    NAME:	UserPrefStringSet

    SYNOPSIS:	Sets a user preference (i.e. remembered string).

    INTERFACE:  UserPrefStringSet( pFileImage, usKey, pszValue )
		pFileImage - as obtained from UserPreferenceRead
		usKey 	 - will indicate which value we want, as defined
			   in newprofc.h.
		pszValue - pointer to null-terminated string to be remembered

		return values are:
		NERR_Success
		ERROR_INVALID_PARAMETER: bad usKey
		ERROR_NOT_ENOUGH_MEMORY

    USES:	Use to create or change string-valued parameters,
		normally things like default logon name, etc.  Do not use
		for boolean-valued parameters -- for those, use UserPrefBool
		instead.

    CAVEATS:	Note that this API only modifies the file image; you must
		call UserPreferenceWrite to save the change in permanent
		storage.

    NOTES:	Currently, the values are stored in LANMAN.INI, and hence
		each value is per machine.

		Also used to delete boolean-valued parameters.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefStringSet( PFILEIMAGE pFileImage,
			  USHORT     usKey,
		          CPSZ       cpszValue) ;


/*************************************************************************

    NAME:	UserPrefBoolQuery

    SYNOPSIS:	Queries a boolean user preference

    INTERFACE:  UserPrefBoolQuery( pFileImage, usKey, pfValue )
		pFileImage - as obtained from UserPreferenceRead
		usKey 	 - will indicate which value we want, as defined
			   in newprofc.h.
		pfValue  - pointer to BOOL that will contain value

		return values as UserPrefStringQuery

    USES:	as UserPrefStringQuery for boolean-valued parameters

    CAVEATS:	as UserPrefStringQuery for boolean-valued parameters

    NOTES:	as UserPrefStringQuery for boolean-valued parameters
		We take USERPREF_YES to be true, USERPREF_NO to be false
		(case-insensitive); other values are invalid.

		os2def.h defines PBOOL as BOOL FAR *.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefBoolQuery(	PFILEIMAGE pFileImage,
				USHORT     usKey,
			        PBOOL      pfValue) ;


/*************************************************************************

    NAME:	UserPrefBoolSet

    SYNOPSIS:	Sets a boolean user preference

    INTERFACE:  UserPrefBoolSet( pFileImage, usKey, fValue )
		pFileImage - as obtained from UserPreferenceRead
		usKey 	 - will indicate which value we want, as defined
			   in newprofc.h.
		fValue   - BOOL value, true or false

		return values as UserPrefStringSet

    USES:	as UserPrefStringSet for boolean-valued parameters

    CAVEATS:	as UserPrefStringSet for boolean-valued parameters

    NOTES:	as UserPrefStringSet for boolean-valued parameters
		We write USERPREF_YES for TRUE, USERPREF_NO for FALSE.

		Use UserPrefStringSet to delete boolean-valued parameters.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefBoolSet( PFILEIMAGE pFileImage,
			USHORT     usKey,
		        BOOL       fValue) ;


/*************************************************************************

    NAME:	UserPrefProfileQuery

    SYNOPSIS:	Queries a device-connection user preference

    INTERFACE:  UserPrefProfileQuery( pFileImage, cpszDeviceName,
			pszBuffer, cbBuffer, psAsgType, pusResType )
		pFileImage - as obtained from UserPreferenceRead
		cpszDeviceName - indicates which device we want
		pszBuffer   - buffer into which to store remote name
		cbBuffer - length of buffer in bytes
		psAsgType   - returns asgType of remote device
		pusResType   - returns resType of remote device

		return values as UserPrefStringQuery
		ERROR_INVALID_PARAMETER: bad cpszDeviceName

    USES:	as UserPrefStringQuery for device-connection parameters

		psAsgType returns the device type as in use_info_1 or
		(LM30) use_info_2 fields ui1_asg_type or (LM30) ui2_asg_type.
		pusResType returns the device name type (e.g. UNC, alias, DFS,
		DS) as in the use_info_2 ui1_res_type field.  Either of these
		parameters may be passed as NULL by programs which do not
		care about those return values.

    CAVEATS:	as UserPrefStringQuery for device-connection parameters

		Note that it is the caller's reponsibility to deal with
		the case where the user is not logged on and should therefore
		see no unavailable connections.

    NOTES:	as UserPrefStringQuery for device-connection parameters

    		os2def.h defines PSHORT and PUSHORT as explicitly FAR.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefProfileQuery(
	PFILEIMAGE  pFileImage,
	CPSZ   cpszDeviceName,
	PSZ    pszBuffer,      // returns UNC, alias or domain name
	USHORT cbBuffer,       // length of above buffer in bytes
	PSHORT psAsgType,      // as ui1_asg_type / ui2_asg_type
                               // ignored if NULL
	PUSHORT pusResType     // ignore / as ui2_res_type
                               // ignored if NULL
	) ;



/*************************************************************************

    NAME:	UserPrefProfileEnum

    SYNOPSIS:	Lists all device-connection user preferences

    INTERFACE:  UserPrefProfileEnum( pFileImage, pszBuffer, cbBuffer );
		pFileImage - as obtained from UserPreferenceRead
		pszBuffer   - buffer into which to store list of device names
		cbBuffer - length of buffer in bytes

		return values are:
		ERROR_NOT_ENOUGH_MEMORY
		NERR_BufTooSmall

    USES:	Returns a list of all devices for which the file image
    		lists a connection, separated by nulls, with a null-null at
		the end.  For example, "LPT1:\0D:\0F:\0" (don't forget the
		extra '\0' implicit in "" strings)

    CAVEATS:	Note that it is the caller's reponsibility to deal with
		the case where the user is not logged on and should therefore
		see no unavailable connections.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefProfileEnum(
	PFILEIMAGE  pFileImage,
	PSZ    pszBuffer,       // returns NULL-NULL list of device names
	USHORT cbBuffer         // length of above buffer in bytes
	) ;



/*************************************************************************

    NAME:	UserPrefProfileSet

    SYNOPSIS:	Sets a device-connection user preference

    INTERFACE:  UserPrefProfileSet( pFileImage, cpszDeviceName,
			cpszRemoteName, sAsgType, usResType )
		pFileImage - as obtained from UserPreferenceRead
		cpszDeviceName - Device to associate with remote resource
		cpszRemoteName - name of remote resource (UNCname for LM21)
				 Use NULL to delete entries
		sAsgType - asgType of remote device
		usResType - resType of remote device (ignored for LM21)

		return values as UserPrefStringSet
		ERROR_INVALID_PARAMETER: bad cpszDeviceName

    USES:	as UserPrefStringSet for device-connection parameters

    CAVEATS:	as UserPrefStringSet for device-connection parameters

		The user is expected to ensure that usResType corresponds
		to the type of the remote resource, and that device
		pszDeviceName can be connected to a resource of that type.

		Note that it is the caller's reponsibility to deal with
		the case where the user is not logged on and should therefore
		see no unavailable connections.

    NOTES:	as UserPrefStringSet for device-connection parameters

		LM21 programs should pass 0 for usResType

		Pass cpszRemoteName==NULL to delete device-connection
		parameters.

    HISTORY:
	chuckc	03/07/91	Created
	jonn	05/28/91	Restructured to allow preferences in LMUSER.INI

**************************************************************************/

APIERR UserPrefProfileSet(
	PFILEIMAGE  pFileImage,
	CPSZ   cpszDeviceName,
	CPSZ   cpszRemoteName,
	short  sAsgType,		// as ui1_asg_type / ui2_asg_type
	unsigned short usResType	// as ui2_res_type
	) ;


/*************************************************************************

    NAME:	UserPrefProfileTrim

    SYNOPSIS:	Trims an file image to contain only device-connection
		components.

    INTERFACE:  UserPrefProfileTrim( pFileImage )
		pFileImage - as obtained from UserPreferenceRead

    USES:	This is meant for use where a "cache" of device
    		connection parameters will be held for a long time.

    RETURNS:	NERR_NOT_ENOUGH_MEMORY
		Does not fail if component not found

    CAVEATS:	Do not write a trimmed file image -- this will destroy all
		parameters which are not device connections!

    NOTES:	Free the file image if this API fails.

    HISTORY:
	jonn	06/26/91	Created

**************************************************************************/

APIERR UserPrefProfileTrim(
	PFILEIMAGE  pFileImage
	) ;

#endif // _NEWPROF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\passdlg.h ===
/*****************************************************************/  
/**		     Microsoft Windows NT			**/ 
/**	       Copyright(c) Microsoft Corp., 1991 		**/
/*****************************************************************/ 

/*
 *  passdlg.h
 *  This manifests are used by the RESOURCE_PASSWORD_DIALOG
 *
 *  History:
 *  	Yi-HsinS	8/15/91		Created
 *
 */

#ifndef _PASSDLG_H_
#define _PASSDLG_H_

#include "applibrc.h"

#define IDPW_PASSWORD    	    	200
#define IDPW_RESOURCE               	201 


/* 
 * Help Context
 */

#define HC_RESOURCE_PASSWORD_DIALOG	6000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\newprofc.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990,1991          **/
/********************************************************************/

/*
    newprof.h
    Constants for ini-file-handling module

    These constants are needed by both newprof.h and newprof.hxx clients.

    FILE STATUS:
    06/04/91  jonn	Created
*/

#ifndef _NEWPROFC_H_
#define _NEWPROFC_H_

/****************************************************************************

    MODULE: NewProfC.h

    PURPOSE: Constants and macros for the C and C++ version of the
	user preference module.

    FUNCTIONS:

    COMMENTS:

****************************************************************************/



/* returncodes: */



/* global macros */
#define PROFILE_DEFAULTFILE    "LMUSER.INI" // this is not internationalized.

#define USERPREF_MAX	256		// arbitrary limit to ease mem alloc

#define USERPREF_YES	"yes"		// this is not internationalized.
#define USERPREF_NO	"no"		// ditto

#define USERPREF_NONE			0	// no such value
#define USERPREF_AUTOLOGON		0x1	// auto logon
#define USERPREF_AUTORESTORE		0x2	// auto restore profile
#define USERPREF_SAVECONNECTIONS	0x3	// auto save connections
#define USERPREF_USERNAME		0x4	// user name
#define USERPREF_CONFIRMATION		0x5	// confirm actions?
#define USERPREF_ADMINMENUS		0x6	// Admin menus (PrintMgr)


#endif // _NEWPROFC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\spl_wnt.h ===
/*
 *	Windows/Network Interface
 *	Copyright (C) Microsoft 1989
 *
 *	Print Manager Administration APIs
 *	for later inclusion into WINNET.H once they settle down
 *
 *	JONN 4/19/91	Trimmed out unnecessary stuff
 *	JONN 5/3/91	Added type WNETERR
 */


/*
    Codes for WNetPrintMgrSelNotify's "type" variable, indicating
    what's selected:  a queue, a job, or nothing.
*/

#define WNPMSEL_NOTHING	0
#define WNPMSEL_QUEUE	1
#define WNPMSEL_JOB	2

#define PRIORITY        10		/* menu uses 10, 11, 12, 13 */
#define ABOUT	       24
#define EXIT            25
#define PRINT_LOG       28
#define NETWORK         29
#define HELP_NDEX       30
#define HELP_MOUSE      31
#define HELP_KEYBOARD   32
#define HELP_HELP       33
#define HELP_COMMANDS   34
#define HELP_PROCEDURES 35

#define SHOW_TIME   51
#define SHOW_SIZE   52
#define SHOW_DETAIL 53
#define UPDATE      54
#define SHOW_LOCAL  55
#define SHOW_NET    56
#define SHOW_QUEUE  57
#define SHOW_OTHER  58

#define ALERT_ALWAYS	100
#define ALERT_FLASH	101
#define ALERT_IGNORE	102

#define PM_REFRESH	WM_USER + 100  // BUGBUG: Need to define proper manifest
#define PM_SELQUEUE	WM_USER + 101
#define PM_QUERYSEL	WM_USER + 102

typedef struct _wnpmsel {	/* structure returned by PM_QUERYSEL */
    WORD wJobID;
    char szQueueName [260];
} WNPMSEL, far *LPWNPMSEL;

#define IDM_PROPERTIES		202
#define IDM_CHANGE_MENUS    	212

/*
 *	added JONN 2/26/91
 *	Print Manager Extensions
 */

typedef struct _queuestruct2
{
    WORD pq2Name;		/* offset to queue name */
    WORD pq2Comment;		/* offset to queue comment */
    WORD pq2Driver;		/* offset to driver name */
    WORD pq2Status;		/* status flags */
    WORD pq2Jobcount;		/* number of jobs in this queue */    

} QUEUESTRUCT2, FAR *LPQS2;

#define QNAME(buf,qs)	((LPSTR)(buf) + (qs).pq2Name)
#define QCOMMENT(buf,qs) ((LPSTR)(buf) + (qs).pq2Comment)
#define QDRIVER(buf,qs)	((LPSTR)(buf) + (qs).pq2Driver)

typedef struct _jobstruct2 {
	WORD	pj2Id;		// job ID
	WORD	pj2Username;	// name of owner (offset to string)
//	WORD	pj2Parms;
	WORD	pj2Position;	// 0-based position in queue
	WORD	pj2Status;	// status flags (WNPRJ_XXXXX)
	DWORD	pj2Submitted;
	DWORD	pj2Size;	// size of job in bytes
//	WORD	pj2Copies;
	WORD	pj2Comment;	// comment/app name (offset to string)
	WORD	pj2Document;	// document name (offset to string)
	WORD	pj2StatusText;	// verbose status (offset to string)
	WORD	pj2PrinterName;	// name of port job is printing on (offs to str)
} JOBSTRUCT2;

typedef JOBSTRUCT2 far * LPJOBSTRUCT2;

#define JOBNAME(buf,job)	((LPSTR)(buf) + (job).pj2Username)
#define JOBCOMMENT(buf,job)	((LPSTR)(buf) + (job).pj2Comment)
#define JOBDOCUMENT(buf,job)	((LPSTR)(buf) + (job).pj2Document)
#define JOBSTATUS(buf,job)	((LPSTR)(buf) + (job).pj2StatusText)
#define JOBPRINTER(buf,job)	((LPSTR)(buf) + (job).pj2PrinterName)

/*
 * Type WNETERR distinguishes WN_ error codes from other WORD
 * values.  Added JONN 5/3/91
 */
typedef WORD WNETERR;

// new Print Manager Extensions APIs
extern void far pascal WNetPrintMgrSelNotify (BYTE, LPQS2, LPQS2,
	LPJOBSTRUCT2, LPJOBSTRUCT2, LPWORD, LPSTR, WORD);
extern WNETERR far pascal WNetPrintMgrPrinterEnum (LPSTR lpszQueueName,
	LPSTR lpBuffer, LPWORD pcbBuffer, LPWORD cAvail, WORD usLevel);
extern WNETERR far pascal WNetPrintMgrChangeMenus(HWND, HANDLE FAR *, BOOL FAR *);
extern WNETERR far pascal WNetPrintMgrCommand (HWND, WORD);
extern void far pascal WNetPrintMgrExiting (void);
extern BOOL far pascal WNetPrintMgrExtHelp (DWORD);
extern void far pascal WNetPrintMgrMoveJob (HWND, LPSTR, WORD, int);

// new values for WNetGetCaps()
#define WNNC_PRINTMGREXT		0x000B
// returns extensions version number, re: GetVersion(),
//   or 0 if not supported

// QUEUESTRUCT2.pq2Status and .pq2Jobcount for WNetPrintMgrPrinterEnum[2]
#define WNQ_UNKNOWN -1

#define WNPRS_CANPAUSE	0x0001
#define WNPRS_CANRESUME	0x0002
#define WNPRS_CANDELETE	0x0004
#define WNPRS_CANMOVE	0x0008

// help contexts, were previously in sphelp.h
#define IDH_HELPFIRST		5000
#define IDH_SYSMENU	(IDH_HELPFIRST + 2000)
#define IDH_MBFIRST	(IDH_HELPFIRST + 2001)
#define IDH_MBLAST	(IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST	(IDH_HELPFIRST + 3000)


#define IDH_PRIORITY	(IDH_HELPFIRST + PRIORITY )
#define IDH_PRIORITY1 	(IDH_HELPFIRST + PRIORITY + 1)
#define IDH_PRIORITY2 	(IDH_HELPFIRST + PRIORITY + 2)
#define IDH_ABOUT	(IDH_HELPFIRST + ABOUT	)
#define IDH_EXIT 	(IDH_HELPFIRST + EXIT)
#define IDH_NETWORK 	(IDH_HELPFIRST + NETWORK)
#define IDH_HELP_NDEX 	(IDH_HELPFIRST + HELP_NDEX)
#define IDH_HELP_MOUSE 	(IDH_HELPFIRST + HELP_MOUSE)
#define IDH_HELP_KEYBOARD 	(IDH_HELPFIRST + HELP_KEYBOARD)
#define IDH_HELP_HELP 	(IDH_HELPFIRST + HELP_HELP)
#define IDH_HELP_COMMANDS 	(IDH_HELPFIRST + HELP_COMMANDS)
#define IDH_HELP_PROCEDURES 	(IDH_HELPFIRST + HELP_PROCEDURES)
#define IDH_SHOW_TIME 	(IDH_HELPFIRST + SHOW_TIME)
#define IDH_SHOW_SIZE 	(IDH_HELPFIRST + SHOW_SIZE)
#define IDH_UPDATE 	(IDH_HELPFIRST + UPDATE)
#define IDH_SHOW_QUEUE 	(IDH_HELPFIRST + SHOW_QUEUE)
#define IDH_SHOW_OTHER 	(IDH_HELPFIRST + SHOW_OTHER)
#define IDH_ALERT_ALWAYS 	(IDH_HELPFIRST + ALERT_ALWAYS)
#define IDH_ALERT_FLASH 	(IDH_HELPFIRST + ALERT_FLASH)
#define IDH_ALERT_IGNORE 	(IDH_HELPFIRST + ALERT_IGNORE)


// was in spoolids.h

#define IDS_A_BASE	4096

/* also used as button IDs */
#define ID_ABORT	4
#define ID_PAUSE	2
#define ID_RESUME	3
#define ID_EXPLAIN	5
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\smx.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    smx.h
    This file contains the common messages, manifests, types, and
    structures used by Server Manager Extensions.

    NOTE:  You must include windows.h and lmcons.h *before* this file.


    FILE HISTORY:
        KeithMo     19-Oct-1992     Created, version 1.2+ of SMX spec.
        KeithMo     07-Dec-1992     Conform with version 1.6 of SMX spec.
        JonN        16-May-1996     Added GETSERVERSEL2 and GETCURFOCUS2

*/



#ifndef _SMX_H_
#define _SMX_H_



//
//  This is the maximum length allowed for an extension menu item.
//

#define MENU_TEXT_LEN                   50



//
//  This is the current version number of the extension interface.
//  Version 0 is the original version (NT 3.x).
//  Version 1 supports GETSERVERSEL2 and GETCURFOCUS2 (NT 4.x).
//

#define SME_VERSION                     1



//
//  These are the messages sent from the extension to the
//  Server Manager application.
//
//      SM_GETSELCOUNT
//
//              Purpose - Retrieves the number of selected items in
//                        the specified listbox.
//
//              wParam  - Listbox index.  This 0-based index specifies
//                        the listbox to query.  For the Server Manager,
//                        this must always be zero.
//
//              lParam  - Points to an SMS_GETSELCOUNT structure.
//
//              Returns - TRUE  if successful, FALSE if unsuccessful.
//
//
//      SM_GETSERVERSEL[A][2]
//                        New clients should use version 2 when
//                        SMS_LOADMENU.dwVersion is 1 or greater.
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is useful
//                        for muliple-select listboxes.  Since the Server
//                        manager uses a single-select listbox, this
//                        value must always be zero.
//
//              lParam  - Points to an SMS_GETSERVERSEL[AW] structure.
//
//              Returns - TRUE  if successful, FALSE if unsuccessful.
//
//      SM_GETCURFOCUS[AW][2]
//
//              Purpose - Retrieves the current application focus.
//                        New clients should use version 2 when
//                        SMS_LOADMENU.dwVersion is 1 or greater.
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a SMS_GETCURFOCUS structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      SM_GETOPTIONS
//
//              Purpose - Retrieves the current option settings
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a SMS_GETOPTIONS structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//

#define SM_GETSELCOUNT                  (WM_USER + 1000)
#define SM_GETSERVERSELA                (WM_USER + 1001)
#define SM_GETSERVERSELW                (WM_USER + 1002)
#define SM_GETCURFOCUSA                 (WM_USER + 1003)
#define SM_GETCURFOCUSW                 (WM_USER + 1004)
#define SM_GETOPTIONS                   (WM_USER + 1005)
#define SM_GETSERVERSEL2A               (WM_USER + 1006)
#define SM_GETSERVERSEL2W               (WM_USER + 1007)
#define SM_GETCURFOCUS2A                (WM_USER + 1008)
#define SM_GETCURFOCUS2W                (WM_USER + 1009)

#ifdef UNICODE
#define SM_GETSERVERSEL                 SM_GETSERVERSELW
#define SM_GETCURFOCUS                  SM_GETCURFOCUSW
#define SM_GETSERVERSEL2                SM_GETSERVERSEL2W
#define SM_GETCURFOCUS2                 SM_GETCURFOCUS2W
#else   // !UNICODE
#define SM_GETSERVERSEL                 SM_GETSERVERSELA
#define SM_GETCURFOCUS                  SM_GETCURFOCUSA
#define SM_GETSERVERSEL2                SM_GETSERVERSEL2A
#define SM_GETCURFOCUS2                 SM_GETCURFOCUS2A
#endif  // UNICODE



//
//  These structures are used when the extension is
//  communicating with the application.
//


//
//  The SMS_LOADMENU[AW] structure is passed to the extension's
//  SMELoadMenu[AW] entrypoint when the extension is loaded.
//
//      dwVersion       - On entry to SMELoadMenu[AW], this will
//                        contain the maximum extension version
//                        supported by the Server Manager.  If the
//                        extension supports a lower version, it
//                        should set this field appropriately before
//                        returning.  The Server Manager will use
//                        the returned value to determine the
//                        capabilities of the extension.
//
//                        Version 0 is the original version (NT 3.x).
//                        Version 1 supports GETSERVERSEL2 and GETCURFOCUS2.
//
//      szMenuName      - The name of the menu item that is to appear
//                        in the app's main menu.  This value will also
//                        appear in the "Help On Extensions" submene and
//                        the "View" menu.
//
//      hMenu           - A valid HMENU for the popup-menu to be inserted
//                        into the app's main menu.  Ownership of this
//                        handle transfers to the Server Manager.  The
//                        extension should *not* destroy this handle.
//
//      szHelpFileName  - The name of the help file associated with this
//                        extension.  This file will be used for the
//                        "Help On Extensions" menu.  This will also be
//                        used when the user presses [F1] while the
//                        extension's menu is dropped.
//
//      dwServerType    - A bitmask containing the appropriate server type
//                        bit associated with the extension.  It is
//                        assumed that each extension will be associated
//                        with a unique server type.  For example,
//                        SV_TYPE_WFW represents Windows for Workgroups
//                        servers.
//
//      dwMenuDelta     - The Server Manager will apply this delta
//                        to each menu ID present in hMenu.  This is
//                        to prevent conflicts with other extension's
//                        menu IDs.
//

typedef struct _SMS_LOADMENUA
{
    DWORD       dwVersion;
    CHAR        szMenuName[MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    CHAR        szHelpFileName[MAX_PATH];
    DWORD       dwServerType;
    DWORD       dwMenuDelta;

} SMS_LOADMENUA, * PSMS_LOADMENUA;

typedef struct _SMS_LOADMENUW
{
    DWORD       dwVersion;
    WCHAR       szMenuName[MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    WCHAR       szHelpFileName[MAX_PATH];
    DWORD       dwServerType;
    DWORD       dwMenuDelta;

} SMS_LOADMENUW, * PSMS_LOADMENUW;

#ifdef UNICODE
#define SMS_LOADMENU                    SMS_LOADMENUW
#define PSMS_LOADMENU                   PSMS_LOADMENUW
#else   // !UNICODE
#define SMS_LOADMENU                    SMS_LOADMENUA
#define PSMS_LOADMENU                   PSMS_LOADMENUA
#endif  // UNICODE


//
//  The SMS_GETSERVERSEL[AW][2] structure is filled in by the
//  Server Manager when it handles SM_GETSERVERSEL[AW][2] messages.
//  This is used to return the current selection to the extension.
//
//  SMS_GETSERVERSEL is outdated due to the change in server name length,
//  use SMS_GETSERVERSEL2 when SMS_LOADMENU.dwVersion is 1 or greater.
//
//      szServerName    - Will receive the UNC name of the selected
//                        server.
//
//      dwServerType    - Will receive the server type mask associated
//                        with the server.  This field may be 0 if
//                        the type is unknown.
//

typedef struct _SMS_GETSERVERSELA
{
    CHAR        szServerName[UNCLEN+1];
    DWORD       dwServerType;

} SMS_GETSERVERSELA, * PSMS_GETSERVERSELA;

typedef struct _SMS_GETSERVERSELW
{
    WCHAR       szServerName[UNCLEN+1];
    DWORD       dwServerType;

} SMS_GETSERVERSELW, * PSMS_GETSERVERSELW;

typedef struct _SMS_GETSERVERSEL2A
{
    CHAR        szServerName[MAX_PATH];
    DWORD       dwServerType;

} SMS_GETSERVERSEL2A, * PSMS_GETSERVERSEL2A;

typedef struct _SMS_GETSERVERSEL2W
{
    WCHAR       szServerName[MAX_PATH];
    DWORD       dwServerType;

} SMS_GETSERVERSEL2W, * PSMS_GETSERVERSEL2W;

#ifdef UNICODE
#define SMS_GETSERVERSEL                SMS_GETSERVERSELW
#define PSMS_GETSERVERSEL               PSMS_GETSERVERSELW
#define SMS_GETSERVERSEL2               SMS_GETSERVERSEL2W
#define PSMS_GETSERVERSEL2              PSMS_GETSERVERSEL2W
#else   // !UNICODE
#define SMS_GETSERVERSEL                SMS_GETSERVERSELA
#define PSMS_GETSERVERSEL               PSMS_GETSERVERSELA
#define SMS_GETSERVERSEL2               SMS_GETSERVERSEL2A
#define PSMS_GETSERVERSEL2              PSMS_GETSERVERSEL2A
#endif  // UNICODE


//
//  The SMS_GETSELCOUNT structure is filled in by the Server Manager
//  when it handles the SM_GETSELCOUNT message.  This is used to
//  return the number of selected items to the extension.  In the
//  current implementation, this will be either 0 (empty listbox)
//  or 1 (single selection).
//
//      dwItems         - The number of selected items in the listbox.
//

typedef struct _SMS_GETSELCOUNT
{
    DWORD       dwItems;
} SMS_GETSELCOUNT, * PSMS_GETSELCOUNT;


//
//  The SMS_GETCURFOCUS[AW][2] structure is filled in by the Server Manager
//  when it handles the SM_GETCURFOCUS[2] message.  This is used to
//  return the current focus of the User Manager application.
//
//  SMS_GETCURFOCUS is outdated due to the change in server name length,
//  use SMS_GETCURFOCUS2 when SMS_LOADMENU.dwVersion is 1 or greater.
//
//      szFocus         - The domain name or server name of the current
//                        focus.  Server names can be distinguished
//                        by the leading backslashes, or by dwFocusType.
//
//      dwFocusType     - This is the type of focus, either
//                        SM_FOCUS_TYPE_NT_DOMAIN
//                        SM_FOCUS_TYPE_LM_DOMAIN
//                        SM_FOCUS_TYPE_UNKNOWN_DOMAIN
//                        SM_FOCUS_TYPE_NT_SERVER
//                        SM_FOCUS_TYPE_LM_SERVER
//                        SM_FOCUS_TYPE_WFW_SERVER
//                        SM_FOCUS_TYPE_UNKNOWN_SERVER
//

#define SM_FOCUS_TYPE_NT_DOMAIN         1
#define SM_FOCUS_TYPE_LM_DOMAIN         2
#define SM_FOCUS_TYPE_UNKNOWN_DOMAIN    3
#define SM_FOCUS_TYPE_NT_SERVER         4
#define SM_FOCUS_TYPE_LM_SERVER         5
#define SM_FOCUS_TYPE_WFW_SERVER        6
#define SM_FOCUS_TYPE_UNKNOWN_SERVER    7

typedef struct _SMS_GETCURFOCUSA
{
    CHAR        szFocus[UNCLEN+1];
    DWORD       dwFocusType;

} SMS_GETCURFOCUSA, * PSMS_GETCURFOCUSA;

typedef struct _SMS_GETCURFOCUSW
{
    WCHAR       szFocus[UNCLEN+1];
    DWORD       dwFocusType;

} SMS_GETCURFOCUSW, * PSMS_GETCURFOCUSW;

typedef struct _SMS_GETCURFOCUS2A
{
    CHAR        szFocus[MAX_PATH];
    DWORD       dwFocusType;

} SMS_GETCURFOCUS2A, * PSMS_GETCURFOCUS2A;

typedef struct _SMS_GETCURFOCUS2W
{
    WCHAR       szFocus[MAX_PATH];
    DWORD       dwFocusType;

} SMS_GETCURFOCUS2W, * PSMS_GETCURFOCUS2W;

#ifdef UNICODE
#define SMS_GETCURFOCUS             SMS_GETCURFOCUSW
#define PSMS_GETCURFOCUS            PSMS_GETCURFOCUSW
#define SMS_GETCURFOCUS2            SMS_GETCURFOCUS2W
#define PSMS_GETCURFOCUS2           PSMS_GETCURFOCUS2W
#else   // UNICODE
#define SMS_GETCURFOCUS             SMS_GETCURFOCUSA
#define PSMS_GETCURFOCUS            PSMS_GETCURFOCUSA
#define SMS_GETCURFOCUS2            SMS_GETCURFOCUS2A
#define PSMS_GETCURFOCUS2           PSMS_GETCURFOCUS2A
#endif  // UNICODE


//
//  The SMS_GETOPTIONS structure is filled in by the Server Manager
//  when it handles the SM_GETOPTIONS message.  This is used to
//  return the current option settings of the Server Manager
//  application.
//
//      fSaveSettingsOnExit     - Should Server Manager settings be saved
//                                on exit?
//
//      fConfirmation           - Should permanent and/or dangerous
//                                actions be confirmed?  In the current
//                                Server Manager implementation, this
//                                will always be TRUE.
//

typedef struct _SMS_GETOPTIONS
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;

} SMS_GETOPTIONS, * PSMS_GETOPTIONS;


//
//  The SMS_VALIDATE[AW] structure is passed between the Server Manager
//  application and the extension to validate a particular "alien"
//  (non-LANMan) server.
//
//      pszServer       - The (UNC) name of the server to validate.  This
//                        is filled in by the Server Manager.
//
//      pszType         - The type string to display in the Server Manager's
//                        main window.  This is filled in by the extension.
//
//      pszComment      - The comment to display in the Server Manager's
//                        main window.  This is filled in by the extension.
//

typedef struct _SMS_VALIDATEA
{
    const CHAR * pszServer;
    CHAR       * pszType;
    CHAR       * pszComment;

} SMS_VALIDATEA, * PSMS_VALIDATEA;

typedef struct _SMS_VALIDATEW
{
    const WCHAR * pszServer;
    WCHAR       * pszType;
    WCHAR       * pszComment;

} SMS_VALIDATEW, * PSMS_VALIDATEW;

#ifdef UNICODE
#define SMS_VALIDATE                SMS_VALIDATEW
#define PSMS_VALIDATE               PSMS_VALIDATEW
#else   // UNICODE
#define SMS_VALIDATE                SMS_VALIDATEA
#define PSMS_VALIDATE               PSMS_VALIDATEA
#endif  // UNICODE



//
//  These are the names of the extension entrypoints.
//

#define SZ_SME_UNLOADMENU               "SMEUnloadMenu"
#define SZ_SME_INITIALIZEMENU           "SMEInitializeMenu"
#define SZ_SME_REFRESH                  "SMERefresh"
#define SZ_SME_MENUACTION               "SMEMenuAction"

#define SZ_SME_LOADMENUW                "SMELoadMenuW"
#define SZ_SME_GETEXTENDEDERRORSTRINGW  "SMEGetExtendedErrorStringW"
#define SZ_SME_VALIDATEW                "SMEValidateW"

#define SZ_SME_LOADMENUA                "SMELoadMenuA"
#define SZ_SME_GETEXTENDEDERRORSTRINGA  "SMEGetExtendedErrorStringA"
#define SZ_SME_VALIDATEA                "SMEValidateA"

#ifdef UNICODE
#define SZ_SME_LOADMENU                 SZ_SME_LOADMENUW
#define SZ_SME_GETEXTENDEDERRORSTRING   SZ_SME_GETEXTENDEDERRORSTRINGW
#define SZ_SME_VALIDATE                 SZ_SME_VALIDATEW
#else   // !UNICODE
#define SZ_SME_LOADMENU                 SZ_SME_LOADMENUA
#define SZ_SME_GETEXTENDEDERRORSTRING   SZ_SME_GETEXTENDEDERRORSTRINGA
#define SZ_SME_VALIDATE                 SZ_SME_VALIDATEA
#endif  // UNICODE



//
//  Typedefs for the extension entrypoints.
//

typedef DWORD (PASCAL * PSMX_LOADMENU)( HWND          hWnd,
                                        PSMS_LOADMENU psmsload );

typedef LPTSTR (PASCAL * PSMX_GETEXTENDEDERRORSTRING)( VOID );

typedef VOID (PASCAL * PSMX_UNLOADMENU)( VOID );

typedef VOID (PASCAL * PSMX_INITIALIZEMENU)( VOID );

typedef VOID (PASCAL * PSMX_REFRESH)( HWND hwndParent );

typedef VOID (PASCAL * PSMX_MENUACTION)( HWND hwndParent, DWORD dwEventId );

typedef BOOL (PASCAL * PSMX_VALIDATE)( PSMS_VALIDATE psmsvalidate );



//
//  Prototypes for the extension entrypoints.
//

DWORD PASCAL SMELoadMenuA( HWND           hWnd,
                           PSMS_LOADMENUA psmsload );

DWORD PASCAL SMELoadMenuW( HWND           hWnd,
                           PSMS_LOADMENUW psmsload );

LPSTR  PASCAL SMEGetExtendedErrorStringA( VOID );

LPWSTR PASCAL SMEGetExtendedErrorStringW( VOID );

VOID PASCAL SMEUnloadMenu( VOID );

VOID PASCAL SMEInitializeMenu( VOID );

VOID PASCAL SMERefresh( HWND hwndParent );

VOID PASCAL SMEMenuAction( HWND hwndParent, DWORD dwEventId );

BOOL PASCAL SMEValidateA( PSMS_VALIDATEA psmsValidate );

BOOL PASCAL SMEValidateW( PSMS_VALIDATEW psmsValidate );



#endif  // _SMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\uierr.h ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    uierr.h
    Replacement bseerr.h

    This file redirects bseerr.h to winerror.h.  BSEERR.H is an OS/2
    include file for which WINERROR.H is the nearest equivalent.  The
    directory containing this file should only be on the include path for NT.


    FILE HISTORY:
        jonn        12-Sep-1991     Added to $(UI)\common\h\nt
        KeithMo     12-Dec-1992     Moved to common\h, renamed to uierr.h.

*/

#include <winerror.h>

// BUGBUG BUGBUG We shouldn't be using this error code, but
// collect\maskmap.cxx uses it

#define ERROR_NO_ITEMS                  93 /* no items to operate upon        */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\uigenhlp.h ===
/********************************************************/
/*               Microsoft Windows NT                   */
/*       Copyright(c) Microsoft Corp., 1990, 1991       */
/********************************************************/

/*
    uigenhlp.h

    This file contains the ranges for help contexts that live
    in the general range. they will live in network.hlp

    FILE HISTORY:
        ChuckC       04-01-93    created

*/


#ifndef _UIGENHLP_H_
#define _UIGENHLP_H_

#include <uihelp.h>

#define HC_GENHELP_BROWSE              (HC_UI_GENHELP_BASE+0)
#define HC_GENHELP_BROWSESERVERS       (HC_UI_GENHELP_BASE+1)

#endif  // _UIGENHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\uidomain.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uidomain.h
    Header file for PROMPT_FOR_ANY_DC dialog ID values.

    FILE HISTORY:
        KeithMo 31-Aug-1992 Created.
*/

#ifndef _UIDOMAIN_H_
#define _UIDOMAIN_H_

#include "applibrc.h"

#define IDPDC_MESSAGE           200
#define IDPDC_SERVER_LABEL      201
#define IDPDC_SERVER            202

#endif  // _UIDOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\uilmini.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    uilmini.h

Abstract:

    This file maps the LM 2.x include file name to the appropriate NT include
    file name, and does any other mapping required by this include file.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

    Jon Newman (jonn) 19-Oct-1991:  added LMI_COMP_FILESRV, LMI_PARM_F_REMARK

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/
#define LMI_PARM_S_FILESRV              "server"
#define LMI_COMP_SERVICE        "services"
#define LMI_COMP_VERSION                "version"
#define LMI_PARM_V_LAN_MANAGER          "lan_manager"


#define LMI_COMP_FILESRV        "server"
#define LMI_PARM_F_REMARK               "srvcomment"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\uihelp.h ===
/********************************************************/
/*               Microsoft Windows NT                   */
/*       Copyright(c) Microsoft Corp., 1990, 1991       */
/********************************************************/

/*
    uihelp.h
    This file contains the ranges for ALL UI help contexts.

    FILE HISTORY:
        KeithMo     04-Aug-1992     Created.

*/


#ifndef _UIHELP_H_
#define _UIHELP_H_


//
//  The mother of all help contexts.
//

#define  HC_UI_BASE     7000


//
//  The following help context ranges are defined
//  for the various NETUI modules (LMUICMN0, LMUICMN1,
//  NTLANMAN, MPRUI, etc).
//
//  All help contexts < 7000 are reserved for APIERR mapping.
//
//  Note that ACLEDIT does not need a range;  it receives
//  a set of help contexts from the invoker.
//

#define HC_UI_LMUICMN0_BASE     (HC_UI_BASE+0)
#define HC_UI_LMUICMN0_LAST     (HC_UI_BASE+1999)

#define HC_UI_LMUICMN1_BASE     (HC_UI_BASE+2000)
#define HC_UI_LMUICMN1_LAST     (HC_UI_BASE+3999)

#define HC_UI_MPR_BASE          (HC_UI_BASE+4000)
#define HC_UI_MPR_LAST          (HC_UI_BASE+5999)

#define HC_UI_SETUP_BASE        (HC_UI_BASE+8000)
#define HC_UI_SETUP_LAST        (HC_UI_BASE+9999)

#define HC_UI_SHELL_BASE        (HC_UI_BASE+10000)
#define HC_UI_SHELL_LAST        (HC_UI_BASE+11999)

#define HC_UI_USRMGR_BASE       (HC_UI_BASE+14000)
#define HC_UI_USRMGR_LAST       (HC_UI_BASE+15999)

#define HC_UI_EVTVWR_BASE       (HC_UI_BASE+16000)
#define HC_UI_EVTVWR_LAST       (HC_UI_BASE+17999)

#define HC_UI_RASMAC_BASE       (HC_UI_BASE+18000)
#define HC_UI_RASMAC_LAST       (HC_UI_BASE+19999)

#define HC_UI_GENHELP_BASE      (HC_UI_BASE+20000)
#define HC_UI_GENHELP_LAST      (HC_UI_BASE+20999)

#define HC_UI_RPLMGR_BASE       (HC_UI_BASE+21000)
#define HC_UI_RPLMGR_LAST       (HC_UI_BASE+21999)



//
//  Help contexts for all NetUI Control Panel Applets
//  must be >= 40000.  Keeping the contexts >= 40000
//  will prevent context collisions with the other
//  Control Panel Applets.
//
//  As stated in SHELL\CONTROL\MAIN\CPHELP.H, NetUI has
//  reserved the help context range from 40000 - 59999.
//  This should give us plenty of breathing room for
//  any future applets we may create.
//

#define HC_UI_NCPA_BASE         (HC_UI_BASE+34000)
#define HC_UI_NCPA_LAST         (HC_UI_BASE+35999)

#define HC_UI_SRVMGR_BASE       (HC_UI_BASE+36000)
#define HC_UI_SRVMGR_LAST       (HC_UI_BASE+37999)

#define HC_UI_UPS_BASE          (HC_UI_BASE+38000)
#define HC_UI_UPS_LAST          (HC_UI_BASE+39999)

#define HC_UI_FTPMGR_BASE       (HC_UI_BASE+40000)
#define HC_UI_FTPMGR_LAST       (HC_UI_BASE+41999)

#define HC_UI_IPX_BASE       (HC_UI_BASE+42000)
#define HC_UI_IPX_LAST       (HC_UI_BASE+42999)

#define HC_UI_TCP_BASE       (HC_UI_BASE+43000)
#define HC_UI_TCP_LAST       (HC_UI_BASE+43999)

#define HC_UI_RESERVED1_BASE       (HC_UI_BASE+44000)
#define HC_UI_RESERVED1_LAST       (HC_UI_BASE+44999)

#define HC_UI_RESERVED2_BASE       (HC_UI_BASE+45000)
#define HC_UI_RESERVED2_LAST       (HC_UI_BASE+45999)

#define HC_UI_RESERVED3_BASE       (HC_UI_BASE+46000)
#define HC_UI_RESERVED3_LAST       (HC_UI_BASE+46999)

#endif  // _UIHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\uimsg.h ===
/********************************************************/
/*               Microsoft Windows NT                   */
/*       Copyright(c) Microsoft Corp., 1990, 1991       */
/********************************************************/

/*
 * uimsg.h
 * Defines the ranges for ALL UI messages
 *
 * It also contains messages that are common across apps
 * but not in the NERR or BASE error ranges.
 *
 * FILE HISTORY:
 *      beng        05-Aug-1992 Dllization
 */

#ifndef _UIMSG_H_
#define _UIMSG_H_

/*
 * NOTE below is based on MAX_NERR currently being 3000.
 * we dont include NETERR.H and define in terms of MAX_NERR because
 * this file goes thru RC. 7000 is chosen since its past all
 * the NERR and APPERR and a couple of thousand beyond for safety.
 */
#define IDS_UI_BASE       7000


// Ranges for partitioning the IDS namespace.
// The ordering of these ranges is significant, since BLT can only
// associate a single range with a hmod on which to locate a string.

// These strings all reside on hmodCommon0

#define IDS_UI_COMMON_BASE      (IDS_UI_BASE+0)
#define IDS_UI_COMMON_LAST      (IDS_UI_BASE+999)

#define IDS_UI_BLT_BASE         (IDS_UI_BASE+1000)
#define IDS_UI_BLT_LAST         (IDS_UI_BASE+1999)

#define IDS_UI_APPLIB_BASE      (IDS_UI_BASE+2000)
#define IDS_UI_APPLIB_LAST      (IDS_UI_BASE+2899)

#define IDS_UI_MISC_BASE        (IDS_UI_BASE+3000)
#define IDS_UI_MISC_LAST        (IDS_UI_BASE+3999)

// These strings each have their own module

#define IDS_UI_ACLEDIT_BASE     (IDS_UI_BASE+4000)
#define IDS_UI_ACLEDIT_LAST     (IDS_UI_BASE+4999)

#define IDS_UI_MPR_BASE         (IDS_UI_BASE+5000)
#define IDS_UI_MPR_LAST         (IDS_UI_BASE+5999)

#define IDS_UI_NCPA_BASE        (IDS_UI_BASE+6000)
#define IDS_UI_NCPA_LAST        (IDS_UI_BASE+6999)

#define IDS_UI_SETUP_BASE       (IDS_UI_BASE+7000)
#define IDS_UI_SETUP_LAST       (IDS_UI_BASE+7999)

#define IDS_UI_SHELL_BASE       (IDS_UI_BASE+8000)
#define IDS_UI_SHELL_LAST       (IDS_UI_BASE+8999)

#define IDS_UI_IPX_BASE         (IDS_UI_BASE+9000)
#define IDS_UI_IPX_LAST         (IDS_UI_BASE+9999)

#define IDS_UI_TCP_BASE         (IDS_UI_BASE+10000)
#define IDS_UI_TCP_LAST         (IDS_UI_BASE+10999)

#define IDS_UI_FTPMGR_BASE      (IDS_UI_BASE+16000)
#define IDS_UI_FTPMGR_LAST      (IDS_UI_BASE+16999)

#define IDS_UI_RESERVED1_BASE      (IDS_UI_BASE+17000)
#define IDS_UI_RESERVED1_LAST      (IDS_UI_BASE+17999)

#define IDS_UI_RESERVED2_BASE      (IDS_UI_BASE+18000)
#define IDS_UI_RESERVED2_LAST      (IDS_UI_BASE+18999)

// These strings all reside on the application hmodule, for now

#define IDS_UI_LMOBJ_BASE       (IDS_UI_BASE+9900)
#define IDS_UI_LMOBJ_LAST       (IDS_UI_BASE+9999)

#define IDS_UI_PROFILE_BASE     (IDS_UI_BASE+10000)
#define IDS_UI_PROFILE_LAST     (IDS_UI_BASE+10999)

#define IDS_UI_ADMIN_BASE       (IDS_UI_BASE+11000)
#define IDS_UI_ADMIN_LAST       (IDS_UI_BASE+11999)

#define IDS_UI_SRVMGR_BASE      (IDS_UI_BASE+12000)
#define IDS_UI_SRVMGR_LAST      (IDS_UI_BASE+12999)

#define IDS_UI_USRMGR_BASE      (IDS_UI_BASE+13000)
#define IDS_UI_USRMGR_LAST      (IDS_UI_BASE+13999)

#define IDS_UI_EVTVWR_BASE      (IDS_UI_BASE+14000)
#define IDS_UI_EVTVWR_LAST      (IDS_UI_BASE+14999)

#define IDS_UI_RASMAC_BASE      (IDS_UI_BASE+15000)
#define IDS_UI_RASMAC_LAST      (IDS_UI_BASE+15999)

// Use these manifests when constructing the application

#define IDS_UI_APP_BASE         (IDS_UI_LMOBJ_BASE)
#define IDS_UI_APP_LAST         (IDS_UI_RASMAC_LAST)

/*------------------------------------------------------------------------*/

/*
 * use this range, which is the top half of COMMON for strings like YES/NO
 */
#define  IDS_UI_YES             (IDS_UI_COMMON_BASE+0)
#define  IDS_UI_NO              (IDS_UI_COMMON_BASE+1)

/*
 * Read/Write/Create/Execute/Delete/Change_attrib/Change_Perm must be
 * contiguous msg ids, and IDS_UI_READ must be have the first msg id and
 * IDS_UI_CHANGE_PERM must have the last msg id.
 */
#define  IDS_UI_READ            (IDS_UI_COMMON_BASE+2)
#define  IDS_UI_WRITE           (IDS_UI_COMMON_BASE+3)
#define  IDS_UI_CREATE          (IDS_UI_COMMON_BASE+4)
#define  IDS_UI_EXECUTE         (IDS_UI_COMMON_BASE+5)
#define  IDS_UI_DELETE          (IDS_UI_COMMON_BASE+6)
#define  IDS_UI_CHANGE_ATTRIB   (IDS_UI_COMMON_BASE+7)
#define  IDS_UI_CHANGE_PERM     (IDS_UI_COMMON_BASE+8)

#define  IDS_UI_NOTAVAIL        (IDS_UI_COMMON_BASE+9)
#define  IDS_UI_UNKNOWN         (IDS_UI_COMMON_BASE+10)

#define  IDS_UI_NONE            (IDS_UI_COMMON_BASE+11)
#define  IDS_UI_ERROR           (IDS_UI_COMMON_BASE+12)
#define  IDS_UI_WARNING         (IDS_UI_COMMON_BASE+13)
#define  IDS_UI_INFORMATION     (IDS_UI_COMMON_BASE+14)
#define  IDS_UI_AUDIT_SUCCESS   (IDS_UI_COMMON_BASE+15)
#define  IDS_UI_AUDIT_FAILURE   (IDS_UI_COMMON_BASE+16)
#define  IDS_UI_DEFAULT_DESC    (IDS_UI_COMMON_BASE+17)

#define  IDS_UI_NA              (IDS_UI_COMMON_BASE+18)
/*
 * use this range, which is the bottom half of COMMON for longer strings
 */
#define  IDS_UI_CLOSE_FILE      (IDS_UI_COMMON_BASE+500)
#define  IDS_UI_CLOSE_ALL       (IDS_UI_COMMON_BASE+501)
#define  IDS_UI_CLOSE_WARN      (IDS_UI_COMMON_BASE+502)
#define  IDS_UI_CLOSE_LOSE_DATA (IDS_UI_COMMON_BASE+503)

#define  IDS_UI_LOG_RECORD_CORRUPT  (IDS_UI_COMMON_BASE+504)

#endif  // _UIMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\uinetlib.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uinetlib.h
    Replacement netlib.h

    This file redirects netlib.h to string.h.  NETLIB.H is a LANMAN
    include file for which STRING.H is the nearest equivalent.  The
    directory containing this file should only be on the include path for NT.

    We place several macros here to allow the "f" variants to be used.

    FILE HISTORY:
        jonn        12-Sep-1991 Added to $(UI)\common\h\nt
        beng        22-Oct-1991 Patch for NT c runtimes
        beng        09-Mar-1992 Add Unicode versions
        beng        28-Mar-1992 More Unicode versions
        beng        07-May-1992 Use correct wcs include and names
        KeithMo     12-Dec-1992 Moved to common\h, renamed to uinetlib.h
                                to avoid conflict with net\inc\netlib.h.
        jonn        25-Mar-1993 ITG special sort
        jonn        02-Feb-1994 Added NETUI_strncmp2 and NETUI_strnicmp2
*/

#ifndef NETUI_UINETLIB
#define NETUI_UINETLIB

#if defined(__cplusplus)
extern "C"
{
#endif

void  InitCompareParam( void );
DWORD QueryStdCompareParam( void );
DWORD QueryNocaseCompareParam( void );
DWORD QueryUserDefaultLCID( void ); // actually an LCID

DLL_BASED
INT NETUI_strcmp( const WCHAR * pchString1, const WCHAR * pchString2 );
DLL_BASED
INT NETUI_stricmp( const WCHAR * pchString1, const WCHAR * pchString2 );
DLL_BASED
INT NETUI_strncmp( const WCHAR * pchString1, const WCHAR * pchString2, INT cch );
DLL_BASED
INT NETUI_strnicmp( const WCHAR * pchString1, const WCHAR * pchString2, INT cch );

/*
    NETUI_strncmp2 and NETUI_strncmp2 allow you to compare two strings
    of fixed but different lengths.  This is important where the strings
    might compare '-', and cutting "X-Y" to "X-" might have undesirable
    effects on sort order without SORT_STRINGSORT (see ::CompareStringW).

    BEWARE of using NETUI_strncmp and NETUI_strnicmp without understanding
    this behavior!  The same applies to strncmp() and strnicmp().
*/

DLL_BASED
INT NETUI_strncmp2( const WCHAR * pchString1, INT cch1,
                    const WCHAR * pchString2, INT cch2 );
DLL_BASED
INT NETUI_strnicmp2( const WCHAR * pchString1, INT cch1,
                     const WCHAR * pchString2, INT cch2 );


#define memcmpf memcmp
#define memcpyf memcpy
#define memmovef memmove
#define memsetf memset

#if defined(UNICODE)
#define strcatf wcscat
#define strchrf wcschr
#define strcmpf(x,y) NETUI_strcmp(x,y)
#define stricmpf(x,y) NETUI_stricmp(x,y)
#define strcpyf wcscpy
#define strcspnf wcscspn
#define strlenf wcslen
#define strlwrf _wcslwr
#define strncatf wcsncat
#define strncmpf(x,y,n) NETUI_strncmp(x,y,n)
#define strnicmpf(x,y,n) NETUI_strnicmp(x,y,n)
#define strncpyf wcsncpy
#define strpbrkf wcspbrk
#define strrchrf wcsrchr
#define strrevf _wcsrev
#define strspnf wcsspn
#define strstrf wcsstr
//#define strtokf strtok - This function is not available under Unicode
#define struprf _wcsupr
#else
#define strcatf strcat
#define strchrf strchr
#define strcmpf strcmp
#define stricmpf _stricmp
#define strcpyf strcpy
#define strcspnf strcspn
#define strlenf strlen
#define strlwrf _strlwr
#define strncatf strncat
#define strncmpf strncmp
#define strnicmpf _strnicmp
#define strncpyf strncpy
#define strpbrkf strpbrk
#define strrchrf strrchr
#define strrevf _strrev
#define strspnf strspn
#define strstrf strstr
#define strtokf strtok
#define struprf _strupr
#endif

#define nprintf printf

#if defined(__cplusplus)
}
#endif

#if defined(UNICODE)
#include <wchar.h>
#else
#include <string.h>
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\uiprof.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  10/11/90  jonn      created
 *  01/10/91  jonn      removed PSHORT, PUSHORT
 *  01/27/91  jonn      changed from CFGFILE, added UserProfileInit/Free
 *  02/02/91  jonn      added UserProfileWrite/Clear, removed Confirm,
 *                      redefined Set.
 *  02/04/91  jonn      added cpszUsername param to Query, Enum, Set
 *  03/08/91  chuckc    added UserPreferenceXXX() calls.
 *  04/16/91  jonn      added USERPREF_CONFIRMATION and USERPREF_ADMINMENUS
 *  05/08/91  jonn      Added canonicalization of netnames, canonicalize
 *                      on read
 *  06-Apr-92 beng      Nuked PSZ and CPSZ types (Unicode pass)
 */

/****************************************************************************

    MODULE: UIProf.h

    PURPOSE: Handles low-level manipulation of user profile files
             Handles user preferences (saved info)

    FUNCTIONS:

        UserProfileInit() - Initializes the user profile module.  The
                            cached profile is initially empty.
        UserProfileFree() - Frees memory used by the user profile module.
        UserProfileRead() - Caches the profile for the specified user from
                            permanent storage into a global data structure,
                            for future UserProfileQuery/Enum calls.
                            Call with NULL to clear the cached profile.
        UserProfileWrite() - Writes the cached profile into permanent storage.
        UserProfileQuery() - Returns one entry from the cached profile.
        UserProfileEnum() - Lists all entries in the cached profile.
        UserProfileSet() - Changes the cached profile.  It is generally
                            advisable to immediately precede this call with
                            UserProfileRead, and immediately follow it with
                            UserProfileWrite.


        UserPreferenceQuery() - queries a single user preference string.
        UserPreferenceSet() - saves a single user preference string.
        UserPreferenceQueryBool() - queries a user preference bool value.
        UserPreferenceSetBool() - saves a user preference bool value.

    COMMENTS:


      UserProfile routines:

        Under LM30, the profile in $(LANROOT) will only be used if the
        profile stored in the DS is unavailable.

        Be sure to cache a user's profile before calling
        UserProfileQuery, UserProfileEnum or UserProfileSet.  These
        routines will fail if no profile is currently cached.

        The cpszUsername argument is handled differently from different
        APIs.  UserProfileRead and UserProfileWrite use it to specify the
        user profile to read or write.  UserProfileRead will also remember
        the last username in a static variable whether the call succeeds
        or not.  Null or empty user names clear the stored profile in
        UserProfileRead, and return NERR_BadUsername in
        UserProfileWrite.
        UserProfileQuery, Enum and Set compare cpszUsername with the
        last username remembered by UserProfileRead.  If UserProfileRead
        has never been called, or if it was last called with a different
        username (NULL and empty string are equivalent), these calls
        fail with ERROR_GEN_FAILURE.  In this way, you can use the
        cpszUsername parameter to check whether the correct profile is
        loaded, or you can use it to check whether your module has just
        started and should perform the initial UserProfileRead.  Note that
        UserProfileRead(NULL) will prevent the ERROR_GEN_FAILURE return
        code when cpszUsername==NULL.

        Remember that a user may be logged on from several different
        machines, and that the cached profile is not automatically
        updated.  When the profile is to be changed in permanent
        storage, it is generally advisable to reread the profile from
        permanent storage with UserProfileRead, make the change in the
        cache with userProfileSet, and immediately rewrite the profile
        with UserProfileWrite; this reduces the chance that another
        user's changes will be lost.

        When successful, the UserProfile APIs return NO_ERROR (0).  The
        following are the error codes returned by the UserProfile APIs:

        NERR_BadUsername: bad username argument
        NERR_InvalidDevice: bad devicename argument
        ERROR_BAD_NETPATH: bad lanroot argument
        ERROR_BAD_NET_NAME: bad remotename argument
        NERR_UseNotFound: the specified device is not listed in the profile
        ERROR_NOT_ENOUGH_MEMORY:  lack of global memory or overfull profile
        ERROR_GET_FAILURE:  username mismatch
        ERROR_FILE_NOT_FOUND: any file read error
        ERROR_WRITE_FAULT: any file write error

        BUGBUG  We must determine correct behavior when no user is logged on.
        BUGBUG  Do we return ERROR_GEN_FAILURE?  NO_ERROR?  what?


      User preferences routines:

        These routines read and write sticky values in some section
        of the local LANMAN.INI.  These sticky values are therefore
        all local to the workstation;  this mechanism is not intended
        for values associated with a user.  Unlike the UserProfile
        routines, these routines do not cache any data.


****************************************************************************/



/* returncodes: */



/* global macros */
#define PROFILE_DEFAULTFILE    "LMUSER.INI"

#define USERPREF_MAX    256             // arbitrary limit to ease mem alloc

#define USERPREF_YES    "yes"           // this is not internationalized.
#define USERPREF_NO     "no"            // ditto

#define USERPREF_NONE                   0       // no such value
#define USERPREF_AUTOLOGON              0x1     // auto logon
#define USERPREF_AUTORESTORE            0x2     // auto restore profile
#define USERPREF_SAVECONNECTIONS        0x3     // auto save connections
#define USERPREF_USERNAME               0x4     // user name
#define USERPREF_CONFIRMATION           0x5     // confirm actions?
#define USERPREF_ADMINMENUS             0x6     // Admin menus (PrintMgr)

#ifdef __cplusplus
extern "C" {
#endif

/* functions: */


/*
 * UserProfileInit prepares the profile library.  This API must be
 * called exactly once, and before any other UserProfile APIs.
 *
 * error returns:
 * ERROR_NOT_ENOUGH_MEMORY
 */
USHORT UserProfileInit( void
        );



/*
 * UserProfileFree releases memory claimed by the profile library.
 * Do not call UserProfileFree unless the profile library is initialized.
 * After UserProfileFree, the only permissible UserProfile call is
 * userProfileInit.
 *
 * error returns:
 * <none>
 */
USHORT UserProfileFree( void
        );



/*
 * UserProfileRead attempt to cache the user's profile as stored in
 * permanent storage (<cpszLanroot>\LMUSER.INI, or the DS for LM30).
 *
 * Call with cpszUsername==NULL or cpszUsername=="" to clear cached profile.
 * In this case, cpszLanroot is ignored.
 *
 * UserProfileRead updates the username associated with the current
 * profile, for use by UserProfileQuery/Enum/Set.
 *
 * error returns:
 * NERR_BadUsername
 * ERROR_BAD_NETPATH
 * ERROR_NOT_ENOUGH_MEMORY: includes "profile full" state
 * ERROR_FILE_NOT_FOUND
 */
USHORT UserProfileRead(
        const TCHAR *  pszUsername,
        const TCHAR *  pszLanroot
        );



/*
 * UserProfileWrite attempts to write the user's profile back to
 * permanent storage (<cpszLanroot>\LMUSER.INI, or the DS for LM30).
 *
 * error returns:
 * NERR_BadUsername
 * ERROR_BAD_NETPATH
 * ERROR_NOT_ENOUGH_MEMORY
 * ERROR_WRITE_FAULT
 */
USHORT UserProfileWrite(
        const TCHAR *  pszUsername,
        const TCHAR *  pszLanroot
        );



/*
 * psAsgType returns the device type as in use_info_1 or (LM30) use_info_2
 *   fields ui1_asg_type or (LM30) ui2_asg_type.  pusResType returns
 *   the device name type (e.g. UNC, alias, DFS, DS) as in the
 *   use_info_2 ui1_res_type field.  Either of these parameters may be
 *   passed as NULL by programs which do not care about the return value.
 *
 * cpszUsername is used to confirm that the cached profile is for the
 * named user.  Pass NULL to accept any cached profile (but still
 * reject if UserProfileRead has not been called).
 *
 * error returns:
 * ERROR_GEN_FAILURE: cached profile is not for the named user
 * NERR_BadUsername
 * NERR_InvalidDevice
 * NERR_UseNotFound
 * ERROR_NOT_ENOUGH_MEMORY
 * ERROR_INSUFFICIENT_BUFFER
 */
USHORT UserProfileQuery(
        const TCHAR *   pszUsername,
        const TCHAR *   pszDeviceName,
        TCHAR *    pszBuffer,      // returns UNC, alias or domain name
        USHORT usBufferSize,   // length of above buffer
        short far * psAsgType,      // as ui1_asg_type / ui2_asg_type
                               // ignored if NULL
        unsigned short far * pusResType     // ignore / as ui2_res_type
                               // ignored if NULL
        );



/*
 * Returns a list of all devices for which the cached profile lists a
 * connection, separated by nulls, with a null-null at the end.
 * For example, "LPT1:\0D:\0F:\0" (don't forget the extra '\0'
 * implicit in "" strings)
 *
 * cpszUsername is used to confirm that the cached profile is for the
 * named user.  Pass NULL to accept any cached profile (but still
 * reject if UserProfileRead has not been called).
 *
 * error returns:
 * NERR_BadUsername
 * ERROR_NOT_ENOUGH_MEMORY
 * ERROR_INSUFFICIENT_BUFFER
 */
USHORT UserProfileEnum(
        const TCHAR *   pszUsername,
        TCHAR *    pszBuffer,       // returns NULL-NULL list of device names
        USHORT usBufferSize     // length of above buffer
        );



/*
 * Changes the cached profile.  Follow this call with a call to
 *   UserProfileWrite to write the profile to permanent storage.
 *
 * The user is expected to ensure that usResType corresponds to
 * the type of the remote resource, and that device pszDeviceName
 * can be connected to a resource of that type.
 *
 * Does not canonicalize cpszCanonRemoteName, caller must do this
 *
 * cpszUsername is used to confirm that the cached profile is for the
 * named user.  Pass NULL to accept any cached profile (but still
 * reject if no user profile is cached).
 *
 * error returns:
 * ERROR_GEN_FAILURE: cached profile is not for the named user
 * NERR_InvalidDevice: bad cpszDeviceName
 * ERROR_BAD_NET_NAME: bad cpszRemoteName
 * ERROR_NOT_ENOUGH_MEMORY: includes "profile full" state
 */
USHORT UserProfileSet(
        const TCHAR *   pszUsername,
        const TCHAR *   pszDeviceName,
        const TCHAR *   pszRemoteName,
        short  sAsgType,     // as ui2_asg_type
        unsigned short usResType     // as ui2_res_type
        );


/*************************************************************************

    NAME:       UserPreferenceQuery

    SYNOPSIS:   Queries a user preference (ie remembered string).

    INTERFACE:  UserPreferenceQuery( usKey, pchValue, cbLen )
                usKey    - will indicate which value we want, as defined
                           in uiprof.h.
                pchValue - pointer to buffer that will receive value
                cbLen    - size of buffer

                return value is NERR_Success, ERROR_INAVALID_PARAMETER,
                or NetConfigGet2 error.

    USES:       Use to recall values saved by UserPrefenceSet(), normally
                things like default logon name, etc.

    CAVEATS:

    NOTES:      Currently, the values are stored in LANMAN.INI, and hence
                each value is per machine.

    HISTORY:
        chuckc   7-Mar-1991     Created

**************************************************************************/

USHORT UserPreferenceQuery( USHORT     usKey,
                            TCHAR FAR * pchValue,
                            USHORT     cbLen);

/*************************************************************************

    NAME:       UserPreferenceSet

    SYNOPSIS:   Sets a user preference (remembers a string).

    INTERFACE:  UserPreferenceSet( usKey, pchValue )
                usKey    - will indicate which value we want, as defined
                           in uiprof.h.
                pchValue - pointer to null terminates string to be remembered

                return value is NERR_Success, ERROR_INAVALID_PARAMETER,
                or NetConfigSet error.

    USES:       Use to save values to be retrieved by UserPrefenceQuery(),
                normally things like default logon name, etc.

    CAVEATS:

    NOTES:      Currently, the values are stored in LANMAN.INI, and hence
                each value is per machine.

    HISTORY:
        chuckc   7-Mar-1991     Created

**************************************************************************/

USHORT UserPreferenceSet( USHORT     usKey,
                          TCHAR FAR * pchValue);

/*************************************************************************

    NAME:       UserPreferenceQueryBool

    SYNOPSIS:   Queries a BOOL a user preference (remembered flag).

    INTERFACE:  UserPreferenceQueryBool( usKey, pfValue )
                usKey    - will indicate which value we want, as defined
                           in uiprof.h.
                pfValue  - pointer to BOOL that will contain value

                return value is NERR_Success, ERROR_INAVALID_PARAMETER,
                or UserPreferenceQuery error.

    USES:       Use to retrieve flags set by by UserPrefenceSetBool(),
                normally things like auto logon, etc.

    CAVEATS:

    NOTES:      Currently, the values are stored in LANMAN.INI, and hence
                each value is per machine. This func calls
                UserPreferenceQuery(), taking "yes" or "YES" to be
                true, "no" or "NO" to be false.

    HISTORY:
        chuckc   7-Mar-1991     Created

**************************************************************************/


USHORT UserPreferenceQueryBool( USHORT     usKey,
                                BOOL FAR * pfValue) ;

/*************************************************************************

    NAME:       UserPreferenceSetBool

    SYNOPSIS:   Sets a user preference flag

    INTERFACE:  UserPreferenceSetBool( usKey, fValue )
                usKey    - will indicate which value we want, as defined
                           in uiprof.h.
                fValue   - BOOL value, true or false

                return value is NERR_Success, ERROR_INAVALID_PARAMETER,
                or UserPreferenceSet error.

    USES:       Use to save values to be retrieved by UserPrefenceQueryBool(),
                normally flags like autologon, etc.

    CAVEATS:

    NOTES:      Currently, the values are stored in LANMAN.INI, and hence
                each value is per machine. This func calls
                UserPreferenceSet(), taking "yes" or "YES" to be
                true, "no" or "NO" to be false.
                We also restrict values to length of < USERPREF_MAX.

    HISTORY:
        chuckc   7-Mar-1991     Created

**************************************************************************/

USHORT UserPreferenceSetBool( USHORT     usKey,
                              BOOL       fValue);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\uirsrc.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uirsrc.h
    Resource header file coordination

    This file defines and coordinates the resource IDs of all resources.

    FILE HISTORY:
        beng        05-Aug-1992 Created
*/

#ifndef _UIRSRC_H_
#define _UIRSRC_H_


#define IDRSRC_APP_BASE     1
#define IDRSRC_APP_LAST     4999

#define IDRSRC_NCPA_BASE    6000
#define IDRSRC_NCPA_LAST    6999

#define IDRSRC_MPRUI_BASE   7000
#define IDRSRC_MPRUI_LAST   7999

#define IDRSRC_SHELL_BASE   8000
#define IDRSRC_SHELL_LAST   8999

#define IDRSRC_RESERVED1_BASE  9000
#define IDRSRC_RESERVED1_LAST  9199

#define IDRSRC_RESERVED2_BASE  9200
#define IDRSRC_RESERVED2_LAST  9399

#define IDRSRC_ACLEDIT_BASE 10000
#define IDRSRC_ACLEDIT_LAST 10999

#define IDRSRC_RASMAC_BASE 11000
#define IDRSRC_RASMAC_LAST 11999

#define IDRSRC_FTPMGR_BASE  12000
#define IDRSRC_FTPMGR_LAST  12999

#define IDRSRC_IPX_BASE  13000
#define IDRSRC_IPX_LAST  13999

#define IDRSRC_TCP_BASE  14000
#define IDRSRC_TCP_LAST  14999

#define IDRSRC_COMMON_BASE  15000


#endif // _UIRSRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\umx.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    umx.h
    This file contains the common messages, manifests, types, and
    structures used by User Manager Extensions.

    NOTE:  You must include windows.h and lmcons.h *before* this file.


    FILE HISTORY:
        JonN        19-Nov-1992     Created, templated from SMX spec
        JonN        16-May-1996     Added GETCURFOCUS2

*/



#ifndef _UMX_H_
#define _UMX_H_



//
//  This is the maximum length allowed for an extension menu item.
//

#define UME_MENU_TEXT_LEN               50



//
//  This is the current version number of the extension interface.
//  Version 0 is the original version (NT 3.x).
//  Version 1 supports GETCURFOCUS2 (NT 4.x).
//

#define UME_VERSION                     1


//
//  These are the two listboxes in the User Manager main window.
//

#define UMS_LISTBOX_USERS               0
#define UMS_LISTBOX_GROUPS              1


//
//  These are the messages sent from the extension to the
//  User Manager application.
//
//      UM_GETSELCOUNT
//
//              Purpose - Retrieves the number of selected items in
//                        the specified listbox.
//
//              wParam  - Listbox index.  This 0-based index specifies
//                        the listbox to query.  For the User Manager,
//                        this may be either UMS_LISTBOX_USERS or
//                        UMS_LISTBOX_GROUPS.
//
//              lParam  - Points to a UMS_GETSELCOUNT structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETUSERSEL[AW]
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is used here
//                        since the Users listbox is multiple-select.
//
//              lParam  - Points to a UMS_GETSEL[AW] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETGROUPSEL[AW]
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is useful
//                        for muliple-select listboxes.  Since the Groups
//                        listbox is single-select, this value must always
//                        be zero.
//
//              lParam  - Points to a UMS_GETSEL[AW] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETCURFOCUS[AW][2]
//
//              Purpose - Retrieves the current application focus.
//                        New clients should use version 2 when
//                        UMS_LOADMENU.dwVersion is 1 or greater.
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a UMS_GETCURFOCUS[2] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETOPTIONS[2]
//
//              Purpose - Retrieves the current option settings
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a UMS_GETOPTIONS[2] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//

#define UM_GETSELCOUNT                  (WM_USER + 1000)
#define UM_GETUSERSELA                  (WM_USER + 1001)
#define UM_GETUSERSELW                  (WM_USER + 1002)
#define UM_GETGROUPSELA                 (WM_USER + 1003)
#define UM_GETGROUPSELW                 (WM_USER + 1004)
#define UM_GETCURFOCUSA                 (WM_USER + 1005)
#define UM_GETCURFOCUSW                 (WM_USER + 1006)
#define UM_GETOPTIONS                   (WM_USER + 1007)
#define UM_GETOPTIONS2                  (WM_USER + 1008)
#define UM_GETCURFOCUS2A                (WM_USER + 1009)
#define UM_GETCURFOCUS2W                (WM_USER + 1010)

#ifdef UNICODE
#define UM_GETUSERSEL                 UM_GETUSERSELW
#define UM_GETGROUPSEL                UM_GETGROUPSELW
#define UM_GETCURFOCUS                UM_GETCURFOCUSW
#define UM_GETCURFOCUS2               UM_GETCURFOCUS2W
#else   // !UNICODE
#define UM_GETUSERSEL                 UM_GETUSERSELA
#define UM_GETGROUPSEL                UM_GETGROUPSELA
#define UM_GETCURFOCUS                UM_GETCURFOCUSA
#define UM_GETCURFOCUS2               UM_GETCURFOCUS2A
#endif  // UNICODE



//
//  These structures are used when the extension is
//  communicating with the application.
//


//
//  The UMS_LOADMENU[AW] structure is passed to the extension's
//  UMELoadMenu[AW] entrypoint when the extension is loaded.
//
//      dwVersion       - On entry to UMELoadMenu[AW], this will
//                        contain the maximum extension version
//                        supported by the User Manager.  If the
//                        extension supports a lower version, it
//                        should set this field appropriately before
//                        returning.  The User Manager will use
//                        the returned value to determine the
//                        capabilities of the extension.
//
//                        Version 0 is the original version (NT 3.x).
//                        Version 1 supports GETCURFOCUS2.
//
//      szMenuName      - The name of the menu item that is to appear
//                        in the app's main menu.  This value will also
//                        appear in the "Help On Extensions" submene and
//                        the "View" menu.
//
//      hMenu           - A valid HMENU for the popup-menu to be inserted
//                        into the app's main menu.  Ownership of this
//                        handle transfers to the User Manager.  The
//                        extension should *not* destroy this handle.
//
//      szHelpFileName  - The name of the help file associated with this
//                        extension.  This file will be used for the
//                        "Help On Extensions" menu.  This will also be
//                        used when the user presses [F1] while the
//                        extension's menu is dropped.
//
//      dwMenuDelta     - The User Manager will apply this delta
//                        to each menu ID present in hMenu.  This is
//                        to prevent conflicts with other extension's
//                        menu IDs.
//

typedef struct _UMS_LOADMENUA
{
    DWORD       dwVersion;
    CHAR        szMenuName[UME_MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    CHAR        szHelpFileName[MAX_PATH];
    DWORD       dwMenuDelta;

} UMS_LOADMENUA, * PUMS_LOADMENUA;

typedef struct _UMS_LOADMENUW
{
    DWORD       dwVersion;
    WCHAR       szMenuName[UME_MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    WCHAR       szHelpFileName[MAX_PATH];
    DWORD       dwMenuDelta;

} UMS_LOADMENUW, * PUMS_LOADMENUW;

#ifdef UNICODE
#define UMS_LOADMENU                    UMS_LOADMENUW
#define PUMS_LOADMENU                   PUMS_LOADMENUW
#else   // !UNICODE
#define UMS_LOADMENU                    UMS_LOADMENUA
#define PUMS_LOADMENU                   PUMS_LOADMENUA
#endif  // UNICODE

#define UM_SELTYPE_USER     0x10
#define UM_SELTYPE_NORMALUSER   0x1 | UM_SELTYPE_USER
#define UM_SELTYPE_REMOTEUSER   0x2 | UM_SELTYPE_USER
#define UM_SELTYPE_GROUP    0x20
#define UM_SELTYPE_LOCALGROUP   0x4 | UM_SELTYPE_GROUP
#define UM_SELTYPE_GLOBALGROUP  0x8 | UM_SELTYPE_GROUP


//
//  The UMS_GETSEL[AW] structure is filled in by the User Manager
//  when it handles UM_GETUSERSEL[AW] or UM_GETGROUPSEL[AW] messages.
//  This is used to return the current selection to the extension.
//  Note that this structure contains pointers.  The extension should not
//  assume that these pointers will be valid forever, instead the
//  extension should promptly copy these strings and use the copies.
//
//      dwRID         - The RID of the item.  Note that the RID is not
//                      valid when the UMS_GETSEL describes a group.
//
//      pchName       - Will receive the name of the selected account.
//
//      dwSelType     - Will receive the account type mask associated
//                      with the account.
//
//      pchName       - Will receive the fullname of the selected account.
//                      Note that groups do not have fullnames.
//
//      pchComment    - Will receive the comment of the selected account.
//

typedef struct _UMS_GETSELA
{
    DWORD       dwRID;
    LPSTR       pchName;
    DWORD       dwSelType;
    LPSTR       pchFullName;
    LPSTR       pchComment;

} UMS_GETSELA, * PUMS_GETSELA;

typedef struct _UMS_GETSELW
{
    DWORD       dwRID;
    LPWSTR      pchName;
    DWORD       dwSelType;
    LPWSTR      pchFullName;
    LPWSTR      pchComment;

} UMS_GETSELW, * PUMS_GETSELW;

#ifdef UNICODE
#define UMS_GETSEL                  UMS_GETSELW
#define PUMS_GETSEL                 PUMS_GETSELW
#else   // !UNICODE
#define UMS_GETSEL                  UMS_GETSELA
#define PUMS_GETSEL                 PUMS_GETSELA
#endif  // UNICODE


//
//  The UMS_GETSELCOUNT structure is filled in by the User Manager
//  when it handles the UM_GETSELCOUNT message.  This is used to
//  return the number of selected items to the extension.  This could
//  be more than 1 for the user listbox.
//
//      dwItems         - The number of selected items in the listbox.
//

typedef struct _UMS_GETSELCOUNT
{
    DWORD       dwItems;
} UMS_GETSELCOUNT, * PUMS_GETSELCOUNT;


//
//  The UMS_GETCURFOCUS structure is filled in by the User Manager
//  when it handles the UM_GETCURFOCUS message.  This is used to
//  return the current focus of the User Manager application.
//
//  UMS_GETCURFOCUS is outdated due to the change in server name length,
//  use UMS_GETCURFOCUS2 when SMS_LOADMENU.dwVersion is 1 or greater.
//
//      szFocus         - The domain name or server name of the current
//                        focus.  Server names can be distinguished
//                        by the leading backslashes, or by dwFocusType.
//
//      dwFocusType     - This is the type of focus, either
//                        UM_FOCUS_TYPE_DOMAIN (and szFocus is a domain name)
//                        UM_FOCUS_TYPE_WINNT  (and szFocus is a server name)
//                        UM_FOCUS_TYPE_LM     (and szFocus is a server name)
//                        UM_FOCUS_TYPE_UNKNOWN
//
//      szFocusPDC      - This is the PDC of the domain of focus, and is valid
//                        only if focus is set to UM_FOCUS_TYPE_DOMAIN.
//
//      psidFocus       - This points to the SID of the domain of focus.  It
//                        may be NULL.  Note that this pointer will not be
//                        valid forever, the extension should copy the SID
//                        immediately if it intends to use it.
//

#define UM_FOCUS_TYPE_DOMAIN    1
#define UM_FOCUS_TYPE_WINNT     2
#define UM_FOCUS_TYPE_LM        3
#define UM_FOCUS_TYPE_UNKNOWN   4

typedef struct _UMS_GETCURFOCUSA
{
    CHAR        szFocus[UNCLEN+1];
    DWORD       dwFocusType;
    CHAR        szFocusPDC[UNCLEN+1];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUSA, * PUMS_GETCURFOCUSA;

typedef struct _UMS_GETCURFOCUSW
{
    WCHAR       szFocus[UNCLEN+1];
    DWORD       dwFocusType;
    WCHAR       szFocusPDC[UNCLEN+1];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUSW, * PUMS_GETCURFOCUSW;

typedef struct _UMS_GETCURFOCUS2A
{
    CHAR        szFocus[MAX_PATH];
    DWORD       dwFocusType;
    CHAR        szFocusPDC[MAX_PATH];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUS2A, * PUMS_GETCURFOCUS2A;

typedef struct _UMS_GETCURFOCUS2W
{
    WCHAR       szFocus[MAX_PATH];
    DWORD       dwFocusType;
    WCHAR       szFocusPDC[MAX_PATH];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUS2W, * PUMS_GETCURFOCUS2W;

#ifdef UNICODE
#define UMS_GETCURFOCUS             UMS_GETCURFOCUSW
#define PUMS_GETCURFOCUS            PUMS_GETCURFOCUSW
#define UMS_GETCURFOCUS2            UMS_GETCURFOCUS2W
#define PUMS_GETCURFOCUS2           PUMS_GETCURFOCUS2W
#else   // UNICODE
#define UMS_GETCURFOCUS             UMS_GETCURFOCUSA
#define PUMS_GETCURFOCUS            PUMS_GETCURFOCUSA
#define UMS_GETCURFOCUS2            UMS_GETCURFOCUS2A
#define PUMS_GETCURFOCUS2           PUMS_GETCURFOCUS2A
#endif  // UNICODE


//
//  The UMS_GETOPTIONS[2] structure is filled in by the User Manager
//  when it handles the UM_GETOPTIONS[2] message.  This is used to
//  return the current option settings of the User Manager application.
//
//      fSaveSettingsOnExit - Should User Manager settings be saved on exit?
//
//      fConfirmation   - Should permanent and/or dangerous actions be
//                        confirmed?
//
//      fSortByFullName - Should the main user listbox be sorted by
//                        fullname rather than by user name?
//
//      fMiniUserManager - (UMS_GETOPTIONS2 only) Is this the User Manager
//                         rather than the User Manager for Domains?
//
//      fLowSpeedConnection - (UMS_GETOPTIONS2 only) Is the User Manager
//                            optimized for use across a slow network link?
//

typedef struct _UMS_GETOPTIONS
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;
    BOOL        fSortByFullName;
} UMS_GETOPTIONS, * PUMS_GETOPTIONS;

typedef struct _UMS_GETOPTIONS2
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;
    BOOL        fSortByFullName;
    BOOL        fMiniUserManager;
    BOOL        fLowSpeedConnection;
} UMS_GETOPTIONS2, * PUMS_GETOPTIONS2;




//
//  These are the names of the extension entrypoints.
//

#define SZ_UME_UNLOADMENU               "UMEUnloadMenu"
#define SZ_UME_INITIALIZEMENU           "UMEInitializeMenu"
#define SZ_UME_REFRESH                  "UMERefresh"
#define SZ_UME_MENUACTION               "UMEMenuAction"

#define SZ_UME_LOADMENUW                "UMELoadMenuW"
#define SZ_UME_GETEXTENDEDERRORSTRINGW  "UMEGetExtendedErrorStringW"
#define SZ_UME_CREATEW                  "UMECreateW"
#define SZ_UME_DELETEW                  "UMEDeleteW"
#define SZ_UME_RENAMEW                  "UMERenameW"

#define SZ_UME_LOADMENUA                "UMELoadMenuA"
#define SZ_UME_GETEXTENDEDERRORSTRINGA  "UMEGetExtendedErrorStringA"
#define SZ_UME_CREATEA                  "UMECreateA"
#define SZ_UME_DELETEA                  "UMEDeleteA"
#define SZ_UME_RENAMEA                  "UMERenameA"

#ifdef UNICODE
#define SZ_UME_LOADMENU                 SZ_UME_LOADMENUW
#define SZ_UME_GETEXTENDEDERRORSTRING   SZ_UME_GETEXTENDEDERRORSTRINGW
#define SZ_UME_CREATE                   SZ_UME_CREATEW
#define SZ_UME_DELETE                   SZ_UME_DELETEW
#define SZ_UME_RENAME                   SZ_UME_RENAMEW
#else   // !UNICODE
#define SZ_UME_LOADMENU                 SZ_UME_LOADMENUA
#define SZ_UME_GETEXTENDEDERRORSTRING   SZ_UME_GETEXTENDEDERRORSTRINGA
#define SZ_UME_CREATE                   SZ_UME_CREATEA
#define SZ_UME_DELETE                   SZ_UME_DELETEA
#define SZ_UME_RENAME                   SZ_UME_RENAMEA
#endif  // UNICODE



//
//  Typedefs for the extension entrypoints.
//

typedef DWORD (PASCAL * PUMX_LOADMENUW)( HWND          hWnd,
                                         PUMS_LOADMENUW pumsload );
typedef DWORD (PASCAL * PUMX_LOADMENUA)( HWND          hWnd,
                                         PUMS_LOADMENUA pumsload );

typedef LPWSTR (PASCAL * PUMX_GETEXTENDEDERRORSTRINGW)( VOID );
typedef LPSTR  (PASCAL * PUMX_GETEXTENDEDERRORSTRINGA)( VOID );

typedef VOID (PASCAL * PUMX_UNLOADMENU)( VOID );

typedef VOID (PASCAL * PUMX_INITIALIZEMENU)( VOID );

typedef VOID (PASCAL * PUMX_REFRESH)( HWND hwndParent );

typedef VOID (PASCAL * PUMX_MENUACTION)( HWND  hwndParent,
                                         DWORD dwEventId );

typedef VOID (PASCAL * PUMX_CREATEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection );
typedef VOID (PASCAL * PUMX_CREATEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection );

typedef VOID (PASCAL * PUMX_DELETEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection );
typedef VOID (PASCAL * PUMX_DELETEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection );

typedef VOID (PASCAL * PUMX_RENAMEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection,
                                      LPWSTR       pchNewName    );
typedef VOID (PASCAL * PUMX_RENAMEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection,
                                      LPSTR        pchNewName    );


#ifdef  UNICODE
#define PUMX_LOADMENU                   PUMX_LOADMENUW
#define PUMX_GETEXTENDEDERRORSTRING     PUMX_GETEXTENDEDERRORSTRINGW
#define PUMX_CREATE                     PUMX_CREATEW
#define PUMX_DELETE                     PUMX_DELETEW
#define PUMX_RENAME                     PUMX_RENAMEW
#else   // !UNICODE
#define PUMX_LOADMENU                   PUMX_LOADMENUA
#define PUMX_GETEXTENDEDERRORSTRING     PUMX_GETEXTENDEDERRORSTRINGA
#define PUMX_CREATE                     PUMX_CREATEA
#define PUMX_DELETE                     PUMX_DELETEA
#define PUMX_RENAME                     PUMX_RENAMEA
#endif  // UNICODE



//
//  Prototypes for the extension entrypoints.
//

DWORD PASCAL UMELoadMenuA( HWND           hwndMessage,
                           PUMS_LOADMENUA pumsload );

DWORD PASCAL UMELoadMenuW( HWND           hwndMessage,
                           PUMS_LOADMENUW pumsload );

LPSTR  PASCAL UMEGetExtendedErrorStringA( VOID );

LPWSTR PASCAL UMEGetExtendedErrorStringW( VOID );

VOID PASCAL UMEUnloadMenu( VOID );

VOID PASCAL UMEInitializeMenu( VOID );

VOID PASCAL UMERefresh( HWND hwndParent );

VOID PASCAL UMEMenuAction( HWND hwndParent,
                           DWORD dwEventId );

VOID PASCAL UMECreateA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection );
VOID PASCAL UMECreateW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection );

VOID PASCAL UMEDeleteA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection );
VOID PASCAL UMEDeleteW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection );

VOID PASCAL UMERenameA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection,
                        LPSTR pchNewName );
VOID PASCAL UMERenameW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection,
                        LPWSTR pchNewName );


#endif  // _UMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\vcpphelp.h ===
//  BUGBUG:  This helper file makes VC++ work with its standard includes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\winnet.h ===
/*
 *	Windows/Network Interface
 *	Copyright (C) Microsoft 1989
 *
 *	Standard WINNET Driver Header File, spec version 3.10
 *						 rev. 3.10.05 ;Internal
 */


typedef WORD far * LPWORD;


/*
 *	SPOOLING - CONTROLLING JOBS
 */

#define WNJ_NULL_JOBID  0


WORD FAR PASCAL WNetOpenJob(LPSTR,LPSTR,WORD,LPINT);
WORD FAR PASCAL WNetCloseJob(WORD,LPINT,LPSTR);
WORD FAR PASCAL WNetWriteJob(HANDLE,LPSTR,LPINT);
WORD FAR PASCAL WNetAbortJob(WORD,LPSTR);
WORD FAR PASCAL WNetHoldJob(LPSTR,WORD);
WORD FAR PASCAL WNetReleaseJob(LPSTR,WORD);
WORD FAR PASCAL WNetCancelJob(LPSTR,WORD);
WORD FAR PASCAL WNetSetJobCopies(LPSTR,WORD,WORD);

/*
 *	SPOOLING - QUEUE AND JOB INFO
 */

typedef struct _queuestruct	{
	WORD	pqName;
	WORD	pqComment;
	WORD	pqStatus;
	WORD	pqJobcount;
	WORD	pqPrinters;
} QUEUESTRUCT;

typedef QUEUESTRUCT far * LPQUEUESTRUCT;

#define WNPRQ_ACTIVE	0x0
#define WNPRQ_PAUSE	0x1
#define WNPRQ_ERROR	0x2
#define WNPRQ_PENDING	0x3
#define WNPRQ_PROBLEM	0x4


typedef struct _jobstruct 	{
	WORD	pjId;
	WORD	pjUsername;
	WORD	pjParms;
	WORD	pjPosition;
	WORD	pjStatus;
	DWORD	pjSubmitted;
	DWORD	pjSize;
	WORD	pjCopies;
	WORD	pjComment;
} JOBSTRUCT;

typedef JOBSTRUCT far * LPJOBSTRUCT;

#define WNPRJ_QSTATUS		0x0007
#define  WNPRJ_QS_QUEUED		0x0000
#define  WNPRJ_QS_PAUSED		0x0001
#define  WNPRJ_QS_SPOOLING		0x0002
#define  WNPRJ_QS_PRINTING		0x0003
#define WNPRJ_DEVSTATUS 	0x0FF8
#define  WNPRJ_DS_COMPLETE		0x0008
#define  WNPRJ_DS_INTERV		0x0010
#define  WNPRJ_DS_ERROR 		0x0020
#define  WNPRJ_DS_DESTOFFLINE		0x0040
#define  WNPRJ_DS_DESTPAUSED		0x0080
#define  WNPRJ_DS_NOTIFY		0x0100
#define  WNPRJ_DS_DESTNOPAPER		0x0200
#define  WNPRJ_DS_DESTFORMCHG		0x0400
#define  WNPRJ_DS_DESTCRTCHG		0x0800
#define  WNPRJ_DS_DESTPENCHG  		0x1000

#define SP_QUEUECHANGED 	0x0500


WORD FAR PASCAL WNetWatchQueue(HWND,LPSTR,LPSTR,WORD);
WORD FAR PASCAL WNetUnwatchQueue(LPSTR);
WORD FAR PASCAL WNetLockQueueData(LPSTR,LPSTR,LPQUEUESTRUCT FAR *);
WORD FAR PASCAL WNetUnlockQueueData(LPSTR);


/*
 *	CONNECTIONS
 */

WORD FAR PASCAL WNetAddConnection(LPSTR,LPSTR,LPSTR);
WORD FAR PASCAL WNetCancelConnection(LPSTR,BOOL);
WORD FAR PASCAL WNetGetConnection(LPSTR,LPSTR,LPWORD);
WORD FAR PASCAL WNetRestoreConnection(HWND,LPSTR);

/*
 *	CAPABILITIES
 */

#define WNNC_SPEC_VERSION		0x0001

#define WNNC_NET_TYPE			0x0002
#define  WNNC_NET_NONE				0x0000
#define  WNNC_NET_MSNet 			0x0100
#define  WNNC_NET_LanMan			0x0200
#define  WNNC_NET_NetWare			0x0300
#define  WNNC_NET_Vines 			0x0400

#define WNNC_DRIVER_VERSION		0x0003

#define WNNC_USER			0x0004
#define  WNNC_USR_GetUser			0x0001

#define WNNC_CONNECTION 		0x0006
#define  WNNC_CON_AddConnection 		0x0001
#define  WNNC_CON_CancelConnection		0x0002
#define  WNNC_CON_GetConnections		0x0004
#define  WNNC_CON_AutoConnect			0x0008
#define  WNNC_CON_BrowseDialog			0x0010
#define  WNNC_CON_RestoreConnection		0x0020

#define WNNC_PRINTING			0x0007
#define  WNNC_PRT_OpenJob			0x0002
#define  WNNC_PRT_CloseJob			0x0004
#define  WNNC_PRT_HoldJob			0x0010
#define  WNNC_PRT_ReleaseJob			0x0020
#define  WNNC_PRT_CancelJob			0x0040
#define  WNNC_PRT_SetJobCopies			0x0080
#define  WNNC_PRT_WatchQueue			0x0100
#define  WNNC_PRT_UnwatchQueue			0x0200
#define  WNNC_PRT_LockQueueData 		0x0400
#define  WNNC_PRT_UnlockQueueData		0x0800
#define  WNNC_PRT_ChangeMsg			0x1000
#define  WNNC_PRT_AbortJob			0x2000
#define  WNNC_PRT_NoArbitraryLock		0x4000
#define  WNNC_PRT_WriteJob			0x8000

#define WNNC_DIALOG			0x0008
#define  WNNC_DLG_DeviceMode			0x0001
#define  WNNC_DLG_BrowseDialog			0x0002
#define  WNNC_DLG_ConnectDialog 		0x0004
#define  WNNC_DLG_DisconnectDialog		0x0008
#define  WNNC_DLG_ViewQueueDialog		0x0010
#define  WNNC_DLG_PropertyDialog		0x0020
#define  WNNC_DLG_ConnectionDialog		0x0040

#define WNNC_ADMIN			0x0009
#define  WNNC_ADM_GetDirectoryType		0x0001
#define  WNNC_ADM_DirectoryNotify		0x0002
#define  WNNC_ADM_LongNames			0x0004

#define WNNC_ERROR			0x000A
#define  WNNC_ERR_GetError			0x0001
#define  WNNC_ERR_GetErrorText			0x0002


WORD FAR PASCAL WNetGetCaps(WORD);

/*
 *	OTHER
 */

WORD FAR PASCAL WNetGetUser(LPSTR,LPINT);

/*
 *	BROWSE DIALOG
 */

#define WNBD_CONN_UNKNOWN	0x0
#define WNBD_CONN_DISKTREE	0x1
#define WNBD_CONN_PRINTQ	0x3
#define WNBD_MAX_LENGTH		0x80	// path length, includes the NULL

#define WNTYPE_DRIVE		1
#define WNTYPE_FILE		2
#define WNTYPE_PRINTER		3
#define WNTYPE_COMM		4

#define WNPS_FILE		0
#define WNPS_DIR		1
#define WNPS_MULT		2

WORD FAR PASCAL WNetDeviceMode(HWND);
WORD FAR PASCAL WNetBrowseDialog(HWND,WORD,LPSTR);
WORD FAR PASCAL WNetConnectDialog(HWND,WORD);
WORD FAR PASCAL WNetDisconnectDialog(HWND,WORD);
WORD FAR PASCAL WNetConnectionDialog(HWND,WORD);
WORD FAR PASCAL WNetViewQueueDialog(HWND,LPSTR);
WORD FAR PASCAL WNetPropertyDialog(HWND hwndParent, WORD iButton, WORD nPropSel, LPSTR lpszName, WORD nType);
WORD FAR PASCAL WNetGetPropertyText(WORD iButton, WORD nPropSel, LPSTR lpszName, LPSTR lpszButtonName, WORD cbButtonName, WORD nType);

/*
 *	ADMIN
 */

#define WNDT_NORMAL   0
#define WNDT_NETWORK  1

#define WNDN_MKDIR  1
#define WNDN_RMDIR  2
#define WNDN_MVDIR  3

WORD FAR PASCAL WNetGetDirectoryType(LPSTR,LPINT);
WORD FAR PASCAL WNetDirectoryNotify(HWND,LPSTR,WORD);

/*
 *	ERRORS
 */

WORD FAR PASCAL WNetGetError(LPINT);
WORD FAR PASCAL WNetGetErrorText(WORD,LPSTR,LPINT);


/*
 *	STATUS CODES
 */

/* General */

#define WN_SUCCESS			0x0000
#define WN_NOT_SUPPORTED		0x0001
#define WN_NET_ERROR			0x0002
#define WN_MORE_DATA			0x0003
#define WN_BAD_POINTER			0x0004
#define WN_BAD_VALUE			0x0005
#define WN_BAD_PASSWORD 		0x0006
#define WN_ACCESS_DENIED		0x0007
#define WN_FUNCTION_BUSY		0x0008
#define WN_WINDOWS_ERROR		0x0009
#define WN_BAD_USER			0x000A
#define WN_OUT_OF_MEMORY		0x000B
#define WN_CANCEL			0x000C
#define WN_CONTINUE			0x000D

/* Connection */

#define WN_NOT_CONNECTED		0x0030
#define WN_OPEN_FILES			0x0031
#define WN_BAD_NETNAME			0x0032
#define WN_BAD_LOCALNAME		0x0033
#define WN_ALREADY_CONNECTED		0x0034
#define WN_DEVICE_ERROR 		0x0035
#define WN_CONNECTION_CLOSED		0x0036

/* Printing */

#define WN_BAD_JOBID			0x0040
#define WN_JOB_NOT_FOUND		0x0041
#define WN_JOB_NOT_HELD 		0x0042
#define WN_BAD_QUEUE			0x0043
#define WN_BAD_FILE_HANDLE		0x0044
#define WN_CANT_SET_COPIES		0x0045
#define WN_ALREADY_LOCKED		0x0046

#define WN_NO_ERROR			0x0050

/* stuff in user, not driver, for shell apps ;Internal */
WORD FAR PASCAL WNetErrorText(WORD,LPSTR,WORD); /* ;Internal */

#ifdef LFN

/* this is the data structure returned from LFNFindFirst and
 * LFNFindNext.  The last field, achName, is variable length.  The size
 * of the name in that field is given by cchName, plus 1 for the zero
 * terminator.
 */
typedef struct _filefindbuf2
  {
    WORD fdateCreation;
    WORD ftimeCreation;
    WORD fdateLastAccess;
    WORD ftimeLastAccess;
    WORD fdateLastWrite;
    WORD ftimeLastWrite;
    DWORD cbFile;
    DWORD cbFileAlloc;
    WORD attr;
    DWORD cbList;
    BYTE cchName;
    BYTE achName[1];
  } FILEFINDBUF2, FAR * PFILEFINDBUF2;

typedef BOOL (FAR PASCAL *PQUERYPROC)( void );

WORD FAR PASCAL LFNFindFirst(LPSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
WORD FAR PASCAL LFNFindNext(HANDLE,LPINT,WORD,PFILEFINDBUF2);
WORD FAR PASCAL LFNFindClose(HANDLE);
WORD FAR PASCAL LFNGetAttribute(LPSTR,LPINT);
WORD FAR PASCAL LFNSetAttribute(LPSTR,WORD);
WORD FAR PASCAL LFNCopy(LPSTR,LPSTR,PQUERYPROC);
WORD FAR PASCAL LFNMove(LPSTR,LPSTR);
WORD FAR PASCAL LFNDelete(LPSTR);
WORD FAR PASCAL LFNMKDir(LPSTR);
WORD FAR PASCAL LFNRMDir(LPSTR);
WORD FAR PASCAL LFNGetVolumeLabel(WORD,LPSTR);
WORD FAR PASCAL LFNSetVolumeLabel(WORD,LPSTR);
WORD FAR PASCAL LFNParse(LPSTR,LPSTR,LPSTR);
WORD FAR PASCAL LFNVolumeType(WORD,LPINT);

/* return values from LFNParse
 */
#define FILE_83_CI		0
#define FILE_83_CS		1
#define FILE_LONG		2

/* volumes types from LFNVolumeType
 */
#define VOLUME_STANDARD 	0
#define VOLUME_LONGNAMES	1

/* error code return values
 */
#define ERROR_SUCCESS		0

// will add others later, == DOS int 21h error codes.

// this error code causes a call to WNetGetError, WNetGetErrorText
// to get the error text.
#define ERROR_NETWORKSPECIFIC	0xFFFF

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\wintimrc.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    wintimrc.h
    IDS constants for the WINTIME.RC date/time resource file

    FILE HISTORY:
        terryk      ??-???-???? Created
        beng        21-Feb-1992 Moved codes out of everybody's way
        beng        05-Aug-1992 Moved codes into correct range
*/

#ifndef _WINTIMRC_H_
#define _WINTIMRC_H_

#define  IDS_WINTIME_BASE       IDS_UI_MISC_BASE+500

#define  WINTIME_DAY_LENGTH         12  /* maximum length of a day name   */
#define  WINTIME_SHORT_DAY_LENGTH   4   /* max length of a short day name */
#define  WINTIME_MONTH_LENGTH       12  /* length of a long month name    */
#define  WINTIME_SHORT_MONTH_LENGTH 4   /* max length of a short month    */

#define  IDS_SUNDAY             (IDS_WINTIME_BASE+24)
#define  IDS_MONDAY             (IDS_WINTIME_BASE+25)
#define  IDS_TUESDAY            (IDS_WINTIME_BASE+26)
#define  IDS_WEDNESDAY          (IDS_WINTIME_BASE+27)
#define  IDS_THURSDAY           (IDS_WINTIME_BASE+28)
#define  IDS_FRIDAY             (IDS_WINTIME_BASE+29)
#define  IDS_SATURDAY           (IDS_WINTIME_BASE+30)
#define  IDS_SUNDAY_SHORT       (IDS_WINTIME_BASE+31)
#define  IDS_MONDAY_SHORT       (IDS_WINTIME_BASE+32)
#define  IDS_TUESDAY_SHORT      (IDS_WINTIME_BASE+33)
#define  IDS_WEDNESDAY_SHORT    (IDS_WINTIME_BASE+34)
#define  IDS_THURSDAY_SHORT     (IDS_WINTIME_BASE+35)
#define  IDS_FRIDAY_SHORT       (IDS_WINTIME_BASE+36)
#define  IDS_SATURDAY_SHORT     (IDS_WINTIME_BASE+37)
#define  IDS_JANUARY            (IDS_WINTIME_BASE+40)
#define  IDS_FEBURARY           (IDS_WINTIME_BASE+41)
#define  IDS_MARCH              (IDS_WINTIME_BASE+42)
#define  IDS_APRIL              (IDS_WINTIME_BASE+43)
#define  IDS_MAY                (IDS_WINTIME_BASE+44)
#define  IDS_JUNE               (IDS_WINTIME_BASE+45)
#define  IDS_JULY               (IDS_WINTIME_BASE+46)
#define  IDS_AUGUST             (IDS_WINTIME_BASE+47)
#define  IDS_SEPTEMBER          (IDS_WINTIME_BASE+48)
#define  IDS_OCTOBER            (IDS_WINTIME_BASE+49)
#define  IDS_NOVEMBER           (IDS_WINTIME_BASE+50)
#define  IDS_DECEMBER           (IDS_WINTIME_BASE+51)
#define  IDS_JANUARY_SHORT      (IDS_WINTIME_BASE+56)
#define  IDS_FEBURARY_SHORT     (IDS_WINTIME_BASE+57)
#define  IDS_MARCH_SHORT        (IDS_WINTIME_BASE+58)
#define  IDS_APRIL_SHORT        (IDS_WINTIME_BASE+59)
#define  IDS_MAY_SHORT          (IDS_WINTIME_BASE+60)
#define  IDS_JUNE_SHORT         (IDS_WINTIME_BASE+61)
#define  IDS_JULY_SHORT         (IDS_WINTIME_BASE+62)
#define  IDS_AUGUST_SHORT       (IDS_WINTIME_BASE+63)
#define  IDS_SEPTEMBER_SHORT    (IDS_WINTIME_BASE+64)
#define  IDS_OCTOBER_SHORT      (IDS_WINTIME_BASE+65)
#define  IDS_NOVEMBER_SHORT     (IDS_WINTIME_BASE+66)
#define  IDS_DECEMBER_SHORT     (IDS_WINTIME_BASE+67)
#define  IDS_SESSION_DURATION   (IDS_WINTIME_BASE+68)

#endif // end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\wnet16.h ===
/********************************************************/
/*               Microsoft Windows NT                   */
/*       Copyright(c) Microsoft Corp., 1990, 1991       */
/********************************************************/

/*
 * uimsg.h
 *
 * Defines the prototypes for misc functions in mprui.dll and
 * ntlanman.dll used to support the thunked 16bit wfwnet.drv.
 *
 * Note that all prototypes here end with A0. The A denotes ANSI,
 * as opposed to Unicode while the 0 means its even before 1 (since
 * this is for WFW support.
 *
 * FILE HISTORY:
 *      ChuckC (Chuck Y Chan)    3/28/93       Created
 */

#ifndef _WNET16_H_
#define _WNET16_H_

#include <mpr.h>

#ifdef __cplusplus
extern "C" {
#endif

DWORD ServerBrowseDialogA0(
    HWND    hwnd,
    CHAR   *pchBuffer,
    DWORD   cchBufSize) ;

DWORD BrowseDialogA0(
    HWND    hwnd,
    DWORD   nType,
    CHAR   *pszName,
    DWORD   cchBufSize) ;

DWORD ShareAsDialogA0(
    HWND    hwnd,
    DWORD   nType,
    CHAR    *pszPath) ;

DWORD StopShareDialogA0(
    HWND    hwnd,
    DWORD   nType,
    CHAR    *pszPath) ;

DWORD RestoreConnectionA0(
    HWND    hwnd,
    CHAR    *pszName) ;

#ifdef __cplusplus
}
#endif

#endif  // _WNET16_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\wnintrn.h ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990		     **/
/**********************************************************************/

#ifndef _WNINTRN_H_
#define _WNINTRN_H_

/*
    wnintrn.h
    LANMAN.DRV APIs for internal use only

    LANMAN.DRV implements a set of APIs defined in winnet.h, and exports
    these for use by the Windows Shell (File Manager, Print Manager
    etc.)  These APIs are standard between all network drivers.  However,
    there is also a range of ordinals reserved for internal use.
    These ordinals provide entry points to LANMAN.DRV which are used
    by other LanMan programs such as the logon application,
    the administrative tools, etc.  This header file provides
    prototypes for these internal APIs.



    I_AutoLogon

    Offers the user an opportunity to log on if not already logged on.
        Does nothing if user is already logged on.

    PARAMETERS:
    HWND hParent -- Parent window handle for the parent to the
	logon dialog.  NULL is acceptable if none is available.
    const char FAR *pszAppName -- Name of the application requesting
	the logon dialog, for use in constructing the dialog caption.
	NULL is acceptable here.
    BOOL fPrompt -- If TRUE and user is not logged on, logon dialog
	is preceded by a popup asking if the user wishes to log on.
	If FALSE and user is not logged on, we proceed straight to
	the logon dialog.
    BOOL FAR *pfLoggedOn -- TRUE is returned here if the user was logged on
	by I_AutoLogon.  This may be different from the return value,
	since *pfLoggedOn is FALSE if the user was already logged on.
	Pass pfLoggedOn==NULL if the caller doesn't care.

    RETURN VALUES:
    TRUE -- user is logged on when call completes, either because
	the user was already logged on, or because the user was
        logged on by this call.
    FALSE -- user is not logged on when call completes.


    I_ChangePassword

    Offers the user an "Change Password" dialog box, with which the user
    can change his/her own password, or someone else's.

    PARAMETERS:
    HWND hParent -- Parent window handle.

    FILE HISTORY:

    jonn	11-Feb-1991	Renamed from autolgon.hxx
				Merged in chpass.h
    jonn	30-Apr-1991	Added pszAppName parameter
    terryk	18-Nov-1991	Added I_SystemFocusDialog
    terryk	26-Nov-1991	Added comment
    JohnL	22-Apr-1992	Moved the system focus dialog out to uiexport.h

*/

#ifdef __cplusplus
extern "C" {
#endif

BOOL FAR PASCAL I_AutoLogon(
	HWND hParent,
	const TCHAR FAR *pszAppName,
	BOOL fPrompt,
	BOOL FAR *pfLoggedOn
	);

APIERR FAR PASCAL I_ChangePassword ( HWND hParent );

#ifdef __cplusplus
}
#endif

/* Include the I_SystemFocusDialog definition
 */

#include <uiexport.h>

#endif	//  _WNINTRN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\h\wnet1632.h ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    WNet1632.h

    This file allows WNet clients to be singled sourced for Win16 and Win32.

    FILE HISTORY:
	Johnl	30-Oct-1991	Created
	terryk	07-Nov-1991	undef WNetGetUser
	terryk	18-Nov-1991	add npwnet.h 
	terryk	03-Jan-1992	MPR conversion
	terryk	06-Jan-1992	add mprwnet.h mprerr.h

*/

#ifndef _WNET1632_H_
#define _WNET1632_H_

#ifndef WIN32
/* The following make the Winnet32.h NT-ese friendly to our 16 bit friends.
 */
    #define IN
    #define OUT
    #define LPTSTR   LPSTR

    /* Include the 16 bit winnet driver, note that we have hacked out all of
     * the functionality between this file and Winnet32.h.
     */
    #include <winnet16.h>

    // not in winnet32.h
    /*  This manifest existed in winnet.h but not in winnet32.h and 
	npapi.h.
    */

#endif

// This will cover up the WNetCloseEnum in winnet32.h and use the 
// one in npapi.h
#define	WNetCloseEnum		DWORDWNetCloseEnum
#define	WNetConnectionDialog	DWORDWNetConnectionDialog
#include <winnetwk.h>
#undef WNetCloseEnum
#undef WNetConnectionDialog

// include the npapi.h
#define	LPDWORD	PUINT
#define	DWORD	UINT
#ifdef WIN32
    #define LPUINT	PUINT
    #include <npwnet.h>
    #include <npapi.h>
#else
    #undef 	WNetAddConnection
    #undef 	WNetAddConnection2
    #undef 	WNetCancelConnection
    #undef 	WNetGetConnection
    #undef 	WNetOpenEnum
    #undef 	WNetEnumResource
    #undef 	WNetGetUser
    #undef 	WNetGetLastError

    #include	<mprerr.h>
    #include	<mprwnet.h>

    // 16 bits version
    #define     NPGetConnection         WNetGetConnection        
    #define     NPGetCaps               WNetGetCaps              
    #define     NPDeviceMode            WNetDeviceMode           
    //#define     NPGetUser               WNetGetUser              
    //#define     NPAddConnection         WNetAddConnection        
    #define     NPCancelConnection      WNetCancelConnection     
    #define     NPPropertyDialog	WNetPropertyDialog	     
    #define     NPGetDirectoryType      WNetGetDirectoryType     
    #define     NPDirectoryNotify       WNetDirectoryNotify      
    #define     NPGetPropertyText       WNetGetPropertyText      
    #define	NPOpenEnum	      	WNetOpenEnum	     
    #define	NPEnumResource	  	WNetEnumResource	     
    #define     NPCloseEnum	        WNetCloseEnum	     
    #include <npapi.h>

    // Use the old WNetAddConnection conversion
    UINT APIENTRY WNetAddConnection( LPSTR, LPSTR, LPSTR );
    UINT APIENTRY WNetRestoreConnection( HWND, LPSTR );
    // Skip the DWORD WNetConnectionDialog in winnet32.h
    UINT APIENTRY WNetConnectionDialog( HWND, UINT );
#endif
#undef	DWORD
#undef	LPDWORD

#ifndef WIN32
    #undef WNetGetUser
    /* There are error codes the Win32 network driver supports that the
     * Win16 driver doesn't
     */
    #undef  WN_NO_NETWORK
    #undef  WN_NO_NET_OR_BAD_PATH

    /* The following are defined in both
     */
    //#undef  WN_BAD_HANDLE
    //#undef  WN_NO_MORE_ENTRIES
#endif

#endif // _WNET1632_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\hack\npwnet.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    npwnet.h
	define the mapping between WNetXXX and NPXXX

    FILE HISTORY:
	terryk	11-Nov-91	Created
	terryk	10-Dec-91	Added WNetAddConnection2
	terryk	03-Jan-92	Remove GetError and GetErrorText

*/

#undef     WNetOpenJob
#undef     WNetCloseJob
#undef     WNetAbortJob
#undef     WNetHoldJob
#undef     WNetReleaseJob
#undef     WNetCancelJob
#undef     WNetSetjobCopies
#undef     WNetWatchQueue
#undef     WNetUnwatchQueue
#undef     WNetLockQueueData
#undef     WNetUnlockQueueData
#undef     WNetGetConnection
#undef     WNetGetCaps
#undef     WNetDeviceMode
#undef     WNetBrowseDialog
#undef     WNetGetUser
#undef     WNetAddConnection2
#undef     WNetAddConnection
#undef     WNetCancelConnection
#undef     WNetRestoreConnection
#undef     WNetConnectDialog
#undef     WNetDisconnectDialog
#undef     WNetConnectionDialog
#undef     WNetPropertyDialog
#undef     WNetGetDirectoryType
#undef     WNetDirectoryNotify
#undef     WNetGetPropertyText
#undef	    WNetOpenEnum
#undef	    WNetEnumResource
#undef     WNetCloseEnum
#undef     WNetGetHackText

#define     WNetOpenJob               NPOpenJob              
#define     WNetCloseJob              NPCloseJob             
#define     WNetAbortJob              NPAbortJob             
#define     WNetHoldJob               NPHoldJob              
#define     WNetReleaseJob            NPReleaseJob           
#define     WNetCancelJob             NPCancelJob            
#define     WNetSetjobCopies          NPSetjobCopies         
#define     WNetWatchQueue            NPWatchQueue           
#define     WNetUnwatchQueue          NPUnwatchQueue         
#define     WNetLockQueueData         NPLockQueueData        
#define     WNetUnlockQueueData       NPUnlockQueueData      
#define     WNetGetConnection         NPGetConnection        
#define     WNetGetCaps               NPGetCaps              
#define     WNetDeviceMode            NPDeviceMode           
#define     WNetBrowseDialog          NPBrowseDialog         
#define     WNetGetUser               NPGetUser              
#define     WNetAddConnection2        NPAddConnection2        
#define     WNetAddConnection         NPAddConnection        
#define     WNetCancelConnection      NPCancelConnection     
#define     WNetRestoreConnection     NPRestoreConnection    
#define     WNetConnectDialog	      NPConnectDialog	     
#define     WNetDisconnectDialog      NPDisconnectDialog     
#define     WNetConnectionDialog      NPConnectionDialog     
#define     WNetPropertyDialog	      NPPropertyDialog	     
#define     WNetGetDirectoryType      NPGetDirectoryType     
#define     WNetDirectoryNotify       NPDirectoryNotify      
#define     WNetGetPropertyText       NPGetPropertyText      
#define	    WNetOpenEnum	      NPOpenEnum	     
#define	    WNetEnumResource	      NPEnumResource	     
#define     WNetCloseEnum	      NPCloseEnum	     
#define	    WNetGetHackText	      NPGetHackText


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\bmpblock.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    BmpBlock.cxx

    Block containing bitmaps for subject listboxes


    FILE HISTORY:
        JonN        04-Oct-1993 Created

*/

#include "pchapplb.hxx"   // Precompiled header

#include <bmpblock.hxx>


/*************************************************************************

    NAME:       SUBJECT_BITMAP_BLOCK

    SYNOPSIS:   This listbox lists users, groups, aliases and well known SIDs.

    INTERFACE:

    PARENT:     BLT_LISTBOX_HAW

    USES:       DISPLAY_MAP

    CAVEATS:

    NOTES:

    HISTORY:
        JonN        04-Oct-1993 Created

**************************************************************************/

SUBJECT_BITMAP_BLOCK::SUBJECT_BITMAP_BLOCK()
    : BASE              ( ),
      _dmiddteAlias          ( DMID_ALIAS ),
      _dmiddteGroup          ( DMID_GROUP ),
      _dmiddteUser           ( DMID_USER ),
      _dmiddteUnknown        ( DMID_UNKNOWN ),
      _dmiddteRemote         ( DMID_REMOTE ),
      _dmiddteWorld          ( DMID_WORLD ),
      _dmiddteCreatorOwner   ( DMID_CREATOR_OWNER ),
      _dmiddteSystem         ( DMID_SYSTEM ),
      _dmiddteNetwork        ( DMID_NETWORK ),
      _dmiddteInteractive    ( DMID_INTERACTIVE ),
      _dmiddteRestricted     ( DMID_RESTRICTED ),
      _dmiddteDeletedAccount ( DMID_DELETEDACCOUNT )
{
    APIERR err = NERR_Success ;

    if ( (err = _dmiddteAlias.QueryError())    ||
         (err = _dmiddteGroup.QueryError())    ||
         (err = _dmiddteUser.QueryError())     ||
         (err = _dmiddteUnknown.QueryError())  ||
         (err = _dmiddteRemote.QueryError())   ||
         (err = _dmiddteWorld.QueryError())    ||
         (err = _dmiddteCreatorOwner.QueryError()) ||
         (err = _dmiddteSystem.QueryError()) ||
         (err = _dmiddteNetwork.QueryError()) ||
         (err = _dmiddteInteractive.QueryError()) ||
         (err = _dmiddteRestricted.QueryError()) ||
         (err = _dmiddteDeletedAccount.QueryError())
       )
    {
        DBGEOL( "SUBJECT_BITMAP_BLOCK::ctor error " << err );
        ReportError( err ) ;
        return ;
    }
}

SUBJECT_BITMAP_BLOCK::~SUBJECT_BITMAP_BLOCK()
{
    // nothing to do here
}

/*******************************************************************

    NAME:       SUBJECT_BITMAP_BLOCK::QueryDisplayMap

    SYNOPSIS:   Retrieves the correct display map

    INTERFACE:  sidtype: pass a SID_NAME_USE here
                uisid:   pass an enum UI_SystemSid here, only
                         relevant for sidtype==SidTypeWellKnownGroup
                fRemoteUser: only relevant for sidtype==SidTypeUser

    RETURNS:    Pointer to the appropriate display map

    NOTES:

    HISTORY:
        JonN        04-Oct-1993 Created

********************************************************************/

DMID_DTE * SUBJECT_BITMAP_BLOCK::QueryDmDte( INT sidtype,
                                             INT uisid,
                                             BOOL fRemoteUser )
{
    DMID_DTE * pdmap = NULL ;

    switch ( (SID_NAME_USE)sidtype )
    {
    case SidTypeUser:
        if ( fRemoteUser )
        {
            pdmap = &_dmiddteRemote ;
        }
        else
        {
            pdmap = &_dmiddteUser ;
        }
        break ;

    case SidTypeWellKnownGroup:
        {
            switch ( (enum UI_SystemSid)uisid )
            {
            case UI_SID_World:
                pdmap = &_dmiddteWorld ;
                break ;

            case UI_SID_CreatorOwner:
                pdmap = &_dmiddteCreatorOwner ;
                break ;

            case UI_SID_System:
                pdmap = &_dmiddteSystem ;
                break ;

            case UI_SID_Network:
                pdmap = &_dmiddteNetwork ;
                break ;

            case UI_SID_Interactive:
                pdmap = &_dmiddteInteractive ;
                break ;

            case UI_SID_Restricted:
                pdmap = &_dmiddteRestricted ;
                break ;

            case UI_SID_Invalid:
            default:
                DBGEOL(   "SUBJECT_BITMAP_BLOCK::QueryDisplayMap: unknown UISysSid "
                       << uisid );
                pdmap = &_dmiddteGroup ;
                break ;
            }
            break ;
        }

    case SidTypeGroup:
        pdmap = &_dmiddteGroup ;
        break ;

    case SidTypeAlias:
        pdmap = &_dmiddteAlias ;
        break ;

    case SidTypeDeletedAccount:
        pdmap = &_dmiddteDeletedAccount ;
        break ;

    case SidTypeUnknown:
    case SidTypeInvalid:
        pdmap = &_dmiddteUnknown ;
        break ;

    case SidTypeDomain:
    default:
        /* We shouldn't ever get here
         */
        DBGEOL(   "SUBJECT_BITMAP_BLOCK::QueryDisplayMap: unknown sidtype "
               << sidtype );
        ASSERT( FALSE ) ;
        pdmap = &_dmiddteUnknown ;
        break ;
    }

    ASSERT( pdmap != NULL );

    return pdmap ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\browmemb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    BrowMemb.cxx

    This file contains the implementation for the Group Membership
    subdialogs of the User Browser dialog.

    FILE HISTORY:
        JonN        20-Oct-1992 Created

    CODEWORK Single selection is not yet implemented (filed as Pr4 bug)
*/

#include "pchapplb.hxx"   // Precompiled header

#include "browmemb.hxx"


DECLARE_SLIST_OF(OS_SID) ;
DEFINE_SLIST_OF(OS_SID) ;

/*******************************************************************

    NAME:       NT_GROUP_BROWSER_DIALOG::NT_GROUP_BROWSER_DIALOG

    SYNOPSIS:   Constructor for the base group browser dialog

    ENTRY:      pszDlgName           - Resource name of the dialog
                                        (supplied for possible derivation).
                hwndOwner            - Owner hwnd
                pdlgUserBrowser      - Pointer to the User Browser dialog at
                                        the heart of this.  This is usually
                                        hwndOwner, but isn't if the user
                                        presses "&Members" in a Local Group
                                        Browser dialog.
                pszDomainDisplayName - used to build the group name in the SLT.
                pszGroupName         - used to build the group name in the SLT.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

NT_GROUP_BROWSER_DIALOG::NT_GROUP_BROWSER_DIALOG(
                        const TCHAR *            pszDlgName,
                        HWND                     hwndOwner,
                        NT_USER_BROWSER_DIALOG * pdlgUserBrowser,
                        const TCHAR *            pszDomainDisplayName,
                        const TCHAR *            pszGroupName )
    : DIALOG_WINDOW             ( pszDlgName, hwndOwner ),
      _buttonOK                 ( this, IDOK ),
      _sltGroupText             ( this, SLT_SHOW_BROWSEGROUP ),
      _pdlgUserBrowser          ( pdlgUserBrowser ),
      _pdlgSourceDialog         ( this ),
      _lbAccounts               ( this, LB_ACCOUNTS )
{
    ASSERT( pdlgUserBrowser != NULL && pszGroupName != NULL );

    if ( QueryError() )
        return ;

    NLS_STR nlsGroupText;
    NLS_STR nlsQualifiedGroupName;
    ALIAS_STR nlsDomainDisplayName( pszDomainDisplayName );
    ALIAS_STR nlsGroupName( pszGroupName );

    APIERR err;
    if (   (err = nlsGroupText.QueryError()) != NERR_Success
        || (err = nlsQualifiedGroupName.QueryError()) != NERR_Success
        || (err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                        &nlsQualifiedGroupName,
                        nlsGroupName,
                        nlsDomainDisplayName )) != NERR_Success // always qualify
        || (err = _sltGroupText.QueryText( &nlsGroupText )) != NERR_Success
        || (err = nlsGroupText.InsertParams( nlsQualifiedGroupName )) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    _sltGroupText.SetText( nlsGroupText );

}

NT_GROUP_BROWSER_DIALOG::~NT_GROUP_BROWSER_DIALOG()
{
    if ( this != _pdlgSourceDialog )
        delete _pdlgSourceDialog;
    _pdlgSourceDialog = NULL ;
}


/*******************************************************************

    NAME:       NT_GROUP_BROWSER_DIALOG::QueryHelpFile

    SYNOPSIS:   Returns the help file name to use for this instance of
                dialog

    NOTES:

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

const TCHAR * NT_GROUP_BROWSER_DIALOG::QueryHelpFile( ULONG ulHelpContext )
{
    return _pdlgUserBrowser->QueryHelpFile( ulHelpContext );
}


/*******************************************************************

    NAME:       NT_GROUP_BROWSER_DIALOG::OnCommand

    SYNOPSIS:   Typical OnCommand for this dialog, we catch pressing
                the Members button and changing the selection in the
                listbox

    EXIT:

    RETURNS:

    NOTES:	The Members button is enabled any time a single group
                is selected in the listbox.

    HISTORY:
        JonN    04-Nov-1992     Created
********************************************************************/

BOOL NT_GROUP_BROWSER_DIALOG::OnCommand( const CONTROL_EVENT & event )
{
    APIERR err = NERR_Success ;

    switch ( event.QueryCid() )
    {
    case LB_ACCOUNTS:
	switch ( event.QueryCode() )
	{

	// case LBN_SELCHANGE:
        // default:
	//     break ;

	case LBN_DBLCLK:
            return OnOK() ; // no need to redefine this virtual here
	}
        UpdateButtonState() ;
	break ;

    default:
        return DIALOG_WINDOW::OnCommand( event ) ;
    }

    return TRUE ;
}


/*******************************************************************

    NAME:       NT_GROUP_BROWSER_DIALOG::UpdateButtonState

    SYNOPSIS:   Changes the state of the Add button

    EXIT:

    RETURNS:

    NOTES:	The Members button is enabled any time a single group
                is selected in the listbox.

    HISTORY:
        JonN    04-Nov-1992     Created
********************************************************************/
void NT_GROUP_BROWSER_DIALOG::UpdateButtonState( void )
{
    BOOL fSelection = ( _lbAccounts.QuerySelCount() != 0 );
    if (fSelection)
	_buttonOK.MakeDefault() ;
    else
    {
        // sets default to nothing, method as recommended by Ian James
        WPARAM styleNew = _buttonOK.QueryStyle();
        styleNew = (styleNew & ~BS_DEFPUSHBUTTON) | BS_PUSHBUTTON;
        (void) _buttonOK.Command( BM_SETSTYLE,
                                  styleNew,
                                  TRUE ); // TRUE -> redraw button
    }
}


/*******************************************************************

    NAME:       NT_LOCALGROUP_BROWSER_DIALOG::NT_LOCALGROUP_BROWSER_DIALOG

    SYNOPSIS:   Constructor for the Local Group browser dialog

                hwndOwner            - Owner hwnd
                pdlgUserBrowser      - User Browser dialog which started this
                pszDomainDisplayName - name of display containing localgroup
                pszGroupName         - qualified groupname
                possidGroup          - SID of localgroup
                psamdomGroup         - SAM_DOMAIN containing localgroup
                psamdomTarget        - Accounts SAM_DOMAIN where the resource lives.
                plsapolTarget        - LSA handle where the resource lives.
                pszServerTarget      - Name of server (in "\\server" form)
                                        the resource lives on.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

NT_LOCALGROUP_BROWSER_DIALOG::NT_LOCALGROUP_BROWSER_DIALOG(
                        HWND                     hwndOwner,
                        NT_USER_BROWSER_DIALOG * pdlgUserBrowser,
                        const TCHAR *            pszDomainDisplayName,
                        const TCHAR *            pszGroupName,
                        const OS_SID *           possidGroup,
                        const SAM_DOMAIN *       psamdomGroup,
                        const SAM_DOMAIN *       psamdomTarget,
                              LSA_POLICY *       plsapolTarget,
                        const TCHAR *            pszServerTarget )
    : NT_GROUP_BROWSER_DIALOG   ( (pdlgUserBrowser->IsSingleSelection())
                                    ? MAKEINTRESOURCE(IDD_LGRPBROWS_1SEL_DLG)
                                    : MAKEINTRESOURCE(IDD_LGRPBROWS_DLG),
                                  hwndOwner,
                                  pdlgUserBrowser,
                                  pszDomainDisplayName,
                                  pszGroupName ),
      _buttonMembers   ( this, USR_BUTTON_MEMBERS ),
      _psamdomTarget   ( psamdomTarget ),
      _plsapolTarget   ( plsapolTarget ),
      _pszServerTarget ( pszServerTarget )
{
    if ( QueryError() )
        return ;

    AUTO_CURSOR cursHourGlass;

    APIERR err = _lbAccounts.FillLocalGroupMembers( possidGroup,
                                                    psamdomGroup,
                                                    psamdomTarget,
                                                    plsapolTarget,
                                                    pszServerTarget );
    if (err != NERR_Success)
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not fill listbox: " << err );
        ReportError( err );
        return;
    }

    _lbAccounts.Invalidate( TRUE ) ;
    UpdateButtonState() ;
}

NT_LOCALGROUP_BROWSER_DIALOG::~NT_LOCALGROUP_BROWSER_DIALOG()
{
}


/*******************************************************************

    NAME:       NT_LOCALGROUP_BROWSER_DIALOG::QueryHelpContext

    SYNOPSIS:   Typical help context query for this dialog

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

ULONG NT_LOCALGROUP_BROWSER_DIALOG::QueryHelpContext( void )
{
    ULONG ulHelpContextLocalMembership =
         QueryUserBrowserDialog()->QueryHelpContextLocalMembership();

    if ( ulHelpContextLocalMembership == 0 )
    {
        ulHelpContextLocalMembership =
            QueryUserBrowserDialog()->QueryHelpContext()
            + USRBROWS_HELP_OFFSET_LOCALGROUP;
    }

    return ulHelpContextLocalMembership;
}


/*******************************************************************

    NAME:       NT_LOCALGROUP_BROWSER_DIALOG::OnCommand

    SYNOPSIS:   Typical OnCommand for this dialog, we catch pressing
                the Members button.

    EXIT:

    RETURNS:

    NOTES:	The Members button is enabled any time a single group
                is selected in the listbox.

    HISTORY:
        JonN    04-Nov-1992     Created
********************************************************************/

BOOL NT_LOCALGROUP_BROWSER_DIALOG::OnCommand( const CONTROL_EVENT & event )
{
    switch ( event.QueryCid() )
    {
    case USR_BUTTON_MEMBERS:
        {
	    APIERR err = OnMembers() ;
            if (err != NERR_Success)
                MsgPopup( this, err );

	     UpdateButtonState() ;
        }
	break ;

    default:
        return NT_GROUP_BROWSER_DIALOG::OnCommand( event ) ;
    }

    return TRUE ;
}


/*******************************************************************

    NAME:       NT_LOCALGROUP_BROWSER_DIALOG::OnMembers

    SYNOPSIS:   Handles the "Members" button

    NOTES:

    HISTORY:
        JonN        26-Oct-1992 Created

********************************************************************/

APIERR NT_LOCALGROUP_BROWSER_DIALOG::OnMembers( void )
{
    APIERR err = NERR_Success;

    if (_lbAccounts.QuerySelCount() != 1)
    {
        UIASSERT( FALSE );
        return ERROR_GEN_FAILURE;
    }
    USER_BROWSER_LBI * pgblbi = (USER_BROWSER_LBI*) _lbAccounts.QueryItem() ;
    if (pgblbi == NULL)
    {
        UIASSERT( FALSE );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ASSERT ( pgblbi->QueryType() == SidTypeGroup ) ;

    NT_GLOBALGROUP_BROWSER_DIALOG * pntggbdlg = new NT_GLOBALGROUP_BROWSER_DIALOG(
                        this->QueryHwnd(),
                        QueryUserBrowserDialog(),
                        pgblbi->QueryDomainName(),
                        pgblbi->QueryAccountName(),
                        pgblbi->QueryOSSID(),
                        _psamdomTarget,
                        _plsapolTarget,
                        _pszServerTarget );
    BOOL fShouldAdd;
    err = ERROR_NOT_ENOUGH_MEMORY;
    if (   (pntggbdlg == NULL)
        || (err = pntggbdlg->QueryError()) != NERR_Success
        || (err = pntggbdlg->Process( &fShouldAdd )) != NERR_Success
       )
    {
        return err;
    }

    if (fShouldAdd)
    {
        //
        // If the user clicked "Add" but didn't select any users, we want
        // to add the global group.  If we set the source dialog to pntggbdlg
        // but none of its listbox items are selected, the caller will add
        // the local group instead.  Therefore, we only set the source dialog
        // if at least one item is selected.  Otherwise, "this" remains
        // the source dialog and the global group will be added.
        //
        if (pntggbdlg->QuerySourceListbox()->QuerySelCount() > 0)
        {
            SetSourceDialog( pntggbdlg );
        }
        Dismiss( TRUE );
    }
    else
    {
        delete pntggbdlg;
        pntggbdlg = NULL;
    }

    return NERR_Success;
}



/*******************************************************************

    NAME:       NT_LOCALGROUP_BROWSER_DIALOG::UpdateButtonState

    SYNOPSIS:   Changes the state of the Members button

    EXIT:

    RETURNS:

    NOTES:	The Members button is enabled any time a single group
                is selected in the listbox.

    HISTORY:
        JonN    04-Nov-1992     Created
********************************************************************/
void NT_LOCALGROUP_BROWSER_DIALOG::UpdateButtonState( void )
{
    _buttonMembers.Enable( _lbAccounts.IsSelectionExpandableGroup() );

    NT_GROUP_BROWSER_DIALOG::UpdateButtonState();
}


/*******************************************************************

    NAME:       NT_GLOBALGROUP_BROWSER_DIALOG::NT_GLOBALGROUP_BROWSER_DIALOG

    SYNOPSIS:   Constructor for the Global Group browser dialog

    ENTRY:
                hwndOwner            - Owner hwnd
                pdlgUserBrowser      - User Browser dialog which started this
                pszDomainDisplayName - name of display containing globalgroup
                pszGroupName         - qualified groupname
                possidGroup          - SID of globalgroup
                psamdomGroup         - SAM_DOMAIN containing globalgroup
                psamdomTarget        - Accounts SAM_DOMAIN where the resource lives.
                plsapolTarget        - LSA handle where the resource lives.
                pszServerTarget      - Name of server (in "\\server" form)
                                        the resource lives on.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        JonN        29-Oct-1992 Created

********************************************************************/

NT_GLOBALGROUP_BROWSER_DIALOG::NT_GLOBALGROUP_BROWSER_DIALOG(
                        HWND            hwndOwner,
                        NT_USER_BROWSER_DIALOG * pdlgUserBrowser,
                        const TCHAR * pszDomainDisplayName,
                        const TCHAR * pszGroupName,
                        const OS_SID * possidGroup,
                        const SAM_DOMAIN * psamdomTarget,
                              LSA_POLICY * plsapolTarget,
                        const TCHAR * pszServerTarget )
    : NT_GROUP_BROWSER_DIALOG   ( (pdlgUserBrowser->IsSingleSelection())
                                    ? MAKEINTRESOURCE(IDD_GGRPBROWS_1SEL_DLG)
                                    : MAKEINTRESOURCE(IDD_GGRPBROWS_DLG),
                                  hwndOwner,
                                  pdlgUserBrowser,
                                  pszDomainDisplayName,
                                  pszGroupName )
{
    if ( QueryError() )
        return ;

    AUTO_CURSOR cursHourGlass;

    BROWSER_DOMAIN * pbrowdom = NULL;
    APIERR err = NERR_Success;

    {
        OS_SID ossidGroupDomain( possidGroup->QueryPSID(), (BOOL)TRUE );
        ULONG ulLastSubAuthority;
        if (   (err = ossidGroupDomain.QueryError()) != NERR_Success
            || (err = ossidGroupDomain.TrimLastSubAuthority( &ulLastSubAuthority )) != NERR_Success
            || (err = ((ulLastSubAuthority == DOMAIN_GROUP_RID_USERS)
                                ? IDS_USRBROWS_CANT_SHOW_DOMAIN_USERS
                                : NERR_Success )) != NERR_Success
           )
        {
            ReportError( err );
            return;
        }

        // groups are never in builtin domain
        pbrowdom = pdlgUserBrowser->FindDomain( &ossidGroupDomain );
    }

    if ( pbrowdom == NULL )
    {
        // bad domain
        ReportError( IDS_CANT_BROWSE_GLOBAL_GROUP );
        return;
    }

    if ( !pbrowdom->IsInitialized() )
    {
	err = pbrowdom->GetDomainInfo( pdlgUserBrowser );
        if (err != NERR_Success)
        {
            TRACEEOL( "User Browser: error " << err << " in GetDomainInfo()" );
            ReportError( err );
            return;
        }
    }

    err = pbrowdom->WaitForAdminAuthority();
    if (err != NERR_Success)
    {
        TRACEEOL( "User Browser: error " << err << " in WaitForAdminAuthority()" );
        ReportError( err );
        return;
    }

    if(   pbrowdom->QueryAdminAuthority() == NULL
       || pbrowdom->QueryAccountDomain() == NULL
       || pbrowdom->QueryAccountDomain()->QueryError() != NERR_Success )
    {
        err = pbrowdom->QueryErrorLoadingAuthority();
        ASSERT( err != NERR_Success );
        TRACEEOL( "User Browser: error " << err << ", no ADMIN_AUTHORITY " );
        ReportError( err );
        return;
    }

    ASSERT(   pbrowdom->QueryAccountDomain() != NULL
           && pbrowdom->QueryAccountDomain()->QueryError() == NERR_Success );

    err = _lbAccounts.FillGlobalGroupMembers( possidGroup,
                                              pbrowdom->QueryAccountDomain(),
                                              psamdomTarget,
                                              plsapolTarget,
                                              pszServerTarget );
    if (err != NERR_Success)
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not fill listbox: " << err );
        ReportError( err );
        return;
    }

    _lbAccounts.Invalidate( TRUE ) ;
    UpdateButtonState() ;

}

NT_GLOBALGROUP_BROWSER_DIALOG::~NT_GLOBALGROUP_BROWSER_DIALOG()
{
}


/*******************************************************************

    NAME:       NT_GLOBALGROUP_BROWSER_DIALOG::QueryHelpContext

    SYNOPSIS:   Typical help context query for this dialog

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

ULONG NT_GLOBALGROUP_BROWSER_DIALOG::QueryHelpContext( void )
{
    ULONG ulHelpContextGlobalMembership =
          QueryUserBrowserDialog()->QueryHelpContextGlobalMembership();

    if ( ulHelpContextGlobalMembership == 0 )
    {
        ulHelpContextGlobalMembership =
            QueryUserBrowserDialog()->QueryHelpContext()
            + USRBROWS_HELP_OFFSET_GLOBALGROUP;
    }

    return ulHelpContextGlobalMembership;
}


/*************************************************************************

    NAME:	NT_GROUP_BROWSER_LB

    SYNOPSIS:   This listbox lists the contents of a local or global group

    INTERFACE:

    PARENT:     USER_BROWSER_LB

    CAVEATS:

    NOTES:

    HISTORY:
	JonN 	20-Oct-1992	Created

**************************************************************************/

NT_GROUP_BROWSER_LB::NT_GROUP_BROWSER_LB( OWNER_WINDOW * powin,
                                          CID cid )
    : USER_BROWSER_LB ( powin, cid ),
      _lbicache()
{
    if ( QueryError() )
	return ;

    APIERR err ;
    if ( (err = _lbicache.QueryError()) )
    {
	ReportError( err ) ;
	return ;
    }

    //
    //	This is where the LBIs will be stored
    //
    SetCurrentCache( &_lbicache ) ;
}

NT_GROUP_BROWSER_LB::~NT_GROUP_BROWSER_LB()
{
    /* Nothing to do */
}



/*******************************************************************

    NAME:       NT_GROUP_BROWSER_LB::FillLocalGroupMembers

    SYNOPSIS:   Adds LBIs corresponding to members of a local group

    NOTES:      psamdomGroup is the domain the group is in
                psamdomTarget is the domain of focus (may be NULL)

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

APIERR NT_GROUP_BROWSER_LB::FillLocalGroupMembers(
                        const OS_SID *     possidGroup,
                        const SAM_DOMAIN * psamdomGroup,
                        const SAM_DOMAIN * psamdomTarget,
                              LSA_POLICY * plsapolTarget,
                        const TCHAR *      pszServerTarget )
{
    UIASSERT( possidGroup  != NULL  && possidGroup->QueryError()   == NERR_Success );
    UIASSERT( psamdomGroup  != NULL && psamdomGroup->QueryError()  == NERR_Success );
    UNREFERENCED( psamdomTarget );
    UIASSERT( plsapolTarget != NULL && plsapolTarget->QueryError() == NERR_Success );

    APIERR err = NERR_Success;
    PULONG pulRID;

    // Determine localgroup RID

    // CODEWORK We need an OS_SID::QueryRID method
    if (   (err = possidGroup->QueryLastSubAuthority( &pulRID )) != NERR_Success
       )
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not determine localgroup RID: " << err );
        return err;
    }

    // Determine localgroup membership

    SAM_ALIAS samalias( *psamdomGroup, *pulRID, ALIAS_LIST_MEMBERS );
    SAM_SID_MEM samsm;

    if (   (err = samalias.QueryError()) != NERR_Success
        || (err = samsm.QueryError()) != NERR_Success
        || (err = samalias.GetMembers( &samsm )) != NERR_Success
       )
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not determine localgroup membership: " << err );
        return err;
    }

    if (samsm.QueryCount() == 0)
        return NERR_Success;

    return Fill( samsm.QueryPtr(),
                 samsm.QueryCount(),
                 NULL,
                 plsapolTarget,
                 pszServerTarget );
}


/*******************************************************************

    NAME:       NT_GROUP_BROWSER_LB::FillGlobalGroupMembers

    SYNOPSIS:   Adds LBIs corresponding to members of a global group

    NOTES:      psamdomGroup is the domain the group is in
                psamdomTarget is the domain of focus

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

APIERR NT_GROUP_BROWSER_LB::FillGlobalGroupMembers(
                        const OS_SID *     possidGroup,
                        const SAM_DOMAIN * psamdomGroup,
                        const SAM_DOMAIN * psamdomTarget,
                              LSA_POLICY * plsapolTarget,
                        const TCHAR *      pszServerTarget )
{
    UIASSERT( possidGroup   != NULL && possidGroup->QueryError()   == NERR_Success );
    UIASSERT( psamdomGroup  != NULL && psamdomGroup->QueryError()  == NERR_Success );
    UIASSERT( psamdomTarget != NULL && psamdomTarget->QueryError() == NERR_Success );
    UIASSERT( plsapolTarget != NULL && plsapolTarget->QueryError() == NERR_Success );

    APIERR err = NERR_Success;
    PULONG pulRID;

    // Determine globalgroup RID

    if (   (err = possidGroup->QueryLastSubAuthority( &pulRID )) != NERR_Success
       )
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not determine globalgroup RID: " << err );
        return err;
    }

    // Determine globalgroup membership

    SAM_GROUP samgroup( *psamdomGroup, *pulRID, GROUP_LIST_MEMBERS );
    SAM_RID_MEM samrm;

    if (   (err = samgroup.QueryError()) != NERR_Success
        || (err = samrm.QueryError()) != NERR_Success
        || (err = samgroup.GetMembers( &samrm )) != NERR_Success
       )
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not determine globalgroup membership: " << err );
        return err;
    }

    if (samrm.QueryCount() == 0)
        return NERR_Success;

    // Build list of SIDS for members of globalgroup.  Each SID is a copy
    // of the globalgroup SID with a changed RID.

    ULONG cMembers = samrm.QueryCount();
    BUFFER bufPOSSID( (UINT) (sizeof(PVOID) * cMembers) );
    BUFFER bufPSID  ( (UINT) (sizeof(PVOID) * cMembers) );

    OS_SID ossidTemp( possidGroup->QueryPSID(), (BOOL)TRUE );
    PULONG pulRIDTemp;

    if (   (err = bufPOSSID.QueryError()) != NERR_Success
        || (err = bufPSID.QueryError()) != NERR_Success
        || (err = ossidTemp.QueryError()) != NERR_Success
        || (err = ossidTemp.QueryLastSubAuthority( &pulRIDTemp )) != NERR_Success
       )
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not allocate memory: " << err );
        return err;
    }

    OS_SID ** ppossid = (OS_SID **) bufPOSSID.QueryPtr();
    PSID * ppsid = (PSID *) bufPSID.QueryPtr();

    for (ULONG i = 0; i < cMembers; i++)
    {
        ppossid[i] = NULL;
        ppsid[i] = NULL;
    }

    for (i = 0; (err == NERR_Success) && (i < cMembers); i++)
    {
        // Change the RID in ossidTemp
        *pulRIDTemp = samrm.QueryRID(i);

        // Make a copy of ossidTemp and store it in the array
        ppossid[i] = new OS_SID( ossidTemp.QueryPSID(), (BOOL)TRUE );

        if ( ppossid[i] == NULL )
            err = ERROR_NOT_ENOUGH_MEMORY;
        else if ( (err = ppossid[i]->QueryError()) == NERR_Success )
            ppsid[i] = ppossid[i]->QueryPSID();
    }

    // now don't return until the OS_SIDs are freed

    if (err == NERR_Success)
    {
        err = Fill( ppsid,
                    cMembers,
                    psamdomTarget,
                    plsapolTarget,
                    pszServerTarget );
    }
    else
    {
        TRACEEOL( "USRBROWS: BROWMEMB: Could not allocate SIDs: " << err );
    }

    for (i = 0; i < cMembers; i++)
    {
        delete ppossid[i];
        ppossid[i] = NULL;
    }

    return err;
}


/*******************************************************************

    NAME:       NT_GROUP_BROWSER_LB::Fill

    SYNOPSIS:   Adds LBIs corresponding to listed SIDs

    NOTES:      If psamdomTarget is NULL then all names are qualified

    HISTORY:
        JonN        20-Oct-1992 Created

********************************************************************/

APIERR NT_GROUP_BROWSER_LB::Fill( const PSID *	     apsidMembers,
                                  ULONG              cMembers,
                                  const SAM_DOMAIN * psamdomTarget,
                                        LSA_POLICY * plsapolTarget,
                                  const TCHAR *      pszServerTarget )
{
    APIERR err = ::CreateLBIsFromSids(
				 apsidMembers,
				 cMembers,
                                 ( (psamdomTarget == NULL)
                                        ? NULL
				        : psamdomTarget->QueryPSID() ),
				 plsapolTarget,
				 pszServerTarget,
				 this,
				 NULL ) ;

    SetCount( QueryCurrentCache()->QueryCount() ) ;
    return err ;
}

/*******************************************************************

    NAME:	::CreateLBIsFromSids

    SYNOPSIS:	Helper routine that converts an array of sids to LBIs.	Will
		add to either the passed listbox pointer or the array of
		paplbi

    NOTES:	If publb is not NULL, the LBIs are added to publb.  If paplbi
		if not NULL, the LBIs are added to paplbi.

    HISTORY:
	Johnl	12-Dec-1992	Broke off from NT_GROUP_BROWSER_LB::Fill

********************************************************************/

APIERR CreateLBIsFromSids( const PSID *       apsidMembers,
			   ULONG	      cMembers,
			   const PSID	      psidSamDomainTarget,
				 LSA_POLICY * plsapolTarget,
			   const TCHAR *      pszServerTarget,
			   USER_BROWSER_LB *  publb,
			   SLIST_OF(USER_BROWSER_LBI) * psllbi )
{
    UIASSERT( plsapolTarget != NULL && plsapolTarget->QueryError() == NERR_Success );

    if (cMembers == 0)
        return NERR_Success;

    BUFFER bufUserFlags( (UINT) (sizeof(ULONG)        * cMembers) );
    BUFFER bufSidUse   ( (UINT) (sizeof(SID_NAME_USE) * cMembers) );
    STRLIST strlistQualifiedNames;
    STRLIST strlistAccountNames;
    STRLIST strlistFullNames;
    STRLIST strlistComments;
    STRLIST strlistDomainNames;

    APIERR err = NERR_Success;
    if (   (err = bufUserFlags.QueryError()) != NERR_Success
        || (err = bufSidUse.QueryError()) != NERR_Success
        || (err = NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                        *plsapolTarget,
			psidSamDomainTarget,
                        apsidMembers,
                        cMembers,
                        TRUE,                       // fFullNames
                        &strlistQualifiedNames,
                        (ULONG *) bufUserFlags.QueryPtr(),
                        (SID_NAME_USE *) bufSidUse.QueryPtr(),
                        NULL,                       // perrNonFatal
                        pszServerTarget, // used for:  NetUserGetInfo[2]
                                         //            qualifying name
                        &strlistAccountNames,
                        &strlistFullNames,
                        &strlistComments,
                        &strlistDomainNames )) != NERR_Success
       )
    {
	TRACEEOL( "USRBROWS: CreateLBIsFromSids: Could not get account information: " << err );
        return err;
    }

    ITER_STRLIST iterQualifiedNames( strlistQualifiedNames );
    ITER_STRLIST iterAccountNames  ( strlistAccountNames   );
    ITER_STRLIST iterFullNames     ( strlistFullNames      );
    ITER_STRLIST iterComments      ( strlistComments       );
    ITER_STRLIST iterDomainNames   ( strlistDomainNames    );
    NLS_STR *    pnlsQualifiedName;
    NLS_STR *    pnlsAccountName;
    NLS_STR *    pnlsFullName;
    NLS_STR *    pnlsComment;
    NLS_STR *    pnlsDomainName;

    for ( ULONG i = 0; i < cMembers; i++ )
    {
        // We must have at least as many strings as SIDs
        REQUIRE( (pnlsQualifiedName = iterQualifiedNames.Next()) != NULL );
        REQUIRE( (pnlsAccountName   = iterAccountNames.Next())   != NULL );
        REQUIRE( (pnlsFullName      = iterFullNames.Next())      != NULL );
        REQUIRE( (pnlsComment       = iterComments.Next())       != NULL );
        REQUIRE( (pnlsDomainName    = iterDomainNames.Next())    != NULL );

        USER_BROWSER_LBI * pntublbi = new USER_BROWSER_LBI(
                pnlsAccountName   ? pnlsAccountName->QueryPch()   : NULL,
                pnlsFullName      ? pnlsFullName->QueryPch()      : NULL,
                pnlsQualifiedName ? pnlsQualifiedName->QueryPch() : NULL,
                pnlsComment       ? pnlsComment->QueryPch()       : NULL,
                pnlsDomainName    ? pnlsDomainName->QueryPch()    : NULL,
                apsidMembers[i],
                UI_SID_Invalid,
                ((SID_NAME_USE *)(bufSidUse.QueryPtr()))[i],
                ((ULONG *)(bufUserFlags.QueryPtr()))[i] );

        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   pntublbi == NULL
            || (err = pntublbi->QueryError()) != NERR_Success
           )
        {
            delete pntublbi;
            TRACEEOL( "USRBROWS: BROWMEMB: Could not create LBI: " << err );
            return err;
        }

	//
	//  Add to the listbox or the cache
	//
	if ( publb != NULL )
	{
	    if ( publb->AddItem( pntublbi ) < 0 )
	    {
		// Will be deleted by AddItem in case of error
		TRACEEOL( "USRBROWS: BROWMEMB: Could not add LBI" );
		return ERROR_NOT_ENOUGH_MEMORY;
	    }
	}
	else if ( psllbi != NULL )
	{
	    if ( err = psllbi->Append( pntublbi ))
	    {
		delete pntublbi ;
		return err ;
	    }
	}
	else
	{
	    UIASSERT(FALSE) ;
	}
    }

    // We should not have more strings than SIDs
    ASSERT( (pnlsQualifiedName = iterQualifiedNames.Next()) == NULL );
    ASSERT( (pnlsAccountName   = iterAccountNames.Next())   == NULL );
    ASSERT( (pnlsFullName      = iterFullNames.Next())      == NULL );
    ASSERT( (pnlsComment       = iterComments.Next())       == NULL );
    ASSERT( (pnlsDomainName    = iterDomainNames.Next())    == NULL );

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\makefile.inc ===
# @@ COPY_RIGHT_HERE
# @@ ROADMAP :: The Rules.mk for the product-wide header files

#
# Pls record ALL changes here with reason!
#
# jonn, 10/22/91.  Created from BenG's template.
#
# jonn, 10/23/91.  Minor update.
#
#       This makefile-inclusion handles combining multiple libraries
#       into one target directory.  It uses the following macros:
#       $(NTTARGETFILES): define in SOURCES, should include comblib
#       $(COMBINE_SOURCELIBS): define in MAKEFILE.INC
#       $(COMBINE_TARGETLIB): define in MAKEFILE.INC
#       A sample SOURCES and MAKEFILE.INC might look like this:
#
#       sources:
#       TARGETPATH=obj
#       TARGETNAME=intermed3
#       TARGETTYPE=LIBRARY
#       ...
#       NTTARGETFILES=comblib
#
#       makefile.inc:
#       COMBINE_SOURCELIBS=..\foo\$(O)\intermed1.lib \
#                          ..\bar\$(O)\intermed2.lib \
#                          $(O)\intermed3.lib
#       COMBINE_TARGETLIB=..\..\..\lib\*\finallib.lib
#       !include <comblib.mk>
#


!IF $(386) && ("$(COMBINE_TARGETLIB)" != "")
COMBINE_386_DSTLIB=$(COMBINE_TARGETLIB:*=i386)
$(COMBINE_386_DSTLIB): $(COMBINE_SOURCELIBS:*=i386)
    @echo Combining libraries...
    lib -out:$@ $(**)
!ENDIF

!IF $(AMD64) && ("$(COMBINE_TARGETLIB)" != "")
COMBINE_AMD64_DSTLIB=$(COMBINE_TARGETLIB:*=amd64)
$(COMBINE_AMD64_DSTLIB): $(COMBINE_SOURCELIBS:*=amd64)
    @echo Combining libraries...
    lib -out:$@ $(**)
!ENDIF

!IF $(IA64) && ("$(COMBINE_TARGETLIB)" != "")
COMBINE_IA64_DSTLIB=$(COMBINE_TARGETLIB:*=ia64)
$(COMBINE_IA64_DSTLIB): $(COMBINE_SOURCELIBS:*=ia64)
    @echo Combining libraries...
    lib -out:$@ $(**)
!ENDIF

comblib: $(COMBINE_386_DSTLIB)   \
	 $(COMBINE_AMD64_DSTLIB) \
	 $(COMBINE_IA64_DSTLIB)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\auditchk.cxx ===
/**********************************************************************/
/**	      Microsoft Windows NT				     **/
/**	   Copyright(c) Microsoft Corp., 1991			     **/
/**********************************************************************/

/*
    auditchk.cxx

    This file contains the implementation for the audit checkboxes.

    FILE HISTORY:
	Johnl	06-Sep-1991 Created

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:	AUDIT_CHECKBOXES::AUDIT_CHECKBOXES

    SYNOPSIS:	Constructor for the AUDIT_CHECKBOXES class

    ENTRY:  cidSLTAuditName - CID of SLT that represents the name of this
		    audit set
	    cidCheckSuccess - CID of Success checkbox
	    cidCheckFailed  - CID of Failed checkbox
	    nlsAuditName    - Name of this audit set (SLT set to this)
	    bitMask	- Bitflags that represent this audit set

    NOTES:  We enable and show the checkboxes (doesn't matter if already
	    enabled or displayed).  This allows for variable numbers of
	    checkboxes and having the unused checkboxes default to hidden.

    HISTORY:
	Johnl	9-Sep-1991  Created

********************************************************************/

AUDIT_CHECKBOXES::AUDIT_CHECKBOXES( OWNER_WINDOW * powin,
		   CID	 cidSLTAuditName,
		   CID	 cidCheckSuccess,
		   CID	 cidCheckFailed,
		   const NLS_STR  & nlsAuditName,
		   const BITFIELD & bitMask )
    : _sltAuditName( powin, cidSLTAuditName ),
      _fcheckSuccess( powin, cidCheckSuccess ),
      _fcheckFailed ( powin, cidCheckFailed ),
      _bitMask( bitMask )
{
    APIERR err ;
    if ( (err = _sltAuditName.QueryError())  ||
	 (err = _fcheckSuccess.QueryError()) ||
	 (err = _fcheckFailed.QueryError() ) ||
	 (err = _bitMask.QueryError() )  )
    {
	ReportError( err ) ;
	return ;
    }

    _fcheckSuccess.Enable( TRUE ) ;
    _fcheckFailed.Enable( TRUE ) ;
    _fcheckSuccess.Show( TRUE ) ;
    _fcheckFailed.Show( TRUE ) ;

    _sltAuditName.SetText( nlsAuditName ) ;
}

AUDIT_CHECKBOXES::~AUDIT_CHECKBOXES()
{
	/* Nothing to do... */
}

/*******************************************************************

    NAME:	AUDIT_CHECKBOXES::Enable

    SYNOPSIS:	Enables or disables the checkboxes in this audit checkbox
		pair.  The checks are also removed.

    ENTRY:	fEnable - TRUE if enabling, FALSE if disabling

    NOTES:	When disabled, the checks will be removed, when renabled,
		they checks will *not* be restored.

    HISTORY:
	Johnl	22-Nov-1991	Created

********************************************************************/

void AUDIT_CHECKBOXES::Enable( BOOL fEnable, BOOL fClear )
{
    if ( fClear )
    {
	_fcheckSuccess.SetCheck( FALSE ) ;
	_fcheckFailed.SetCheck( FALSE ) ;
    }

    _fcheckSuccess.Enable( fEnable ) ;
    _fcheckFailed.Enable( fEnable ) ;
    _sltAuditName.Enable( fEnable ) ;
}


/*******************************************************************

    NAME:	SET_OF_AUDIT_CATEGORIES::SET_OF_AUDIT_CATEGORIES

    SYNOPSIS:	Constructor for SET_OF_AUDIT_CATEGORIES class

    ENTRY:
		pbitsSuccess, pbitsFailed - Default values to initialize
		    the checkboxes to.	If NULL, then all of the
		    checkboxes default to being in the unchecked state.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	30-Sep-1991	Created

********************************************************************/

SET_OF_AUDIT_CATEGORIES::SET_OF_AUDIT_CATEGORIES( OWNER_WINDOW * powin,
			 CID	    cidSLTBase,
			 CID	    cidCheckSuccessBase,
			 CID	    cidCheckFailedBase,
			 MASK_MAP * pmaskmapAuditInfo,
			 BITFIELD * pbitsSuccess,
			 BITFIELD * pbitsFailed,
                         INT        nID    )
    : _pAuditCheckboxes( NULL ),
      _cUsedAuditCheckboxes( 0 ),
      _pOwnerWindow( powin ),
      _cidSLTBase( cidSLTBase ),
      _cidSuccessCheckboxBase( cidCheckSuccessBase ),
      _cidFailedCheckboxBase( cidCheckFailedBase ),
      _nID( nID )
{
    if ( QueryError() )
	return ;

    if ( pmaskmapAuditInfo == NULL ||
	 (pmaskmapAuditInfo->QueryCount() < 1) )
    {
	UIASSERT(!SZ("Can't be NULL and must be more then one item in mask map") ) ;
	ReportError( ERROR_INVALID_PARAMETER ) ;
	return ;
    }

    _pAuditCheckboxes = (AUDIT_CHECKBOXES *) new BYTE[sizeof( AUDIT_CHECKBOXES )*pmaskmapAuditInfo->QueryCount()] ;
    if ( _pAuditCheckboxes == NULL )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
	return ;
    }

    APIERR err = SetCheckBoxNames( pmaskmapAuditInfo ) ;
    if ( err != NERR_Success )
    {
	ReportError( err ) ;
	return ;
    }

    if ( pbitsSuccess != NULL && pbitsFailed != NULL )
    {
	err = ApplyPermissionsToCheckBoxes( pbitsSuccess, pbitsFailed ) ;
	if ( err != NERR_Success )
	{
	    ReportError( err ) ;
	    return ;
	}
    }
}

SET_OF_AUDIT_CATEGORIES::~SET_OF_AUDIT_CATEGORIES()
{
    //
    //  UPDATED for C++ 2.0: this code used to read:
    //     delete [_cUsedAuditCheckboxes] _pAuditCheckboxes ;
    //  which is INVALID for a user-constructed vector.
    //

    for ( INT i = 0 ; i < _cUsedAuditCheckboxes ; i++ )
    {
        _pAuditCheckboxes[i].AUDIT_CHECKBOXES::~AUDIT_CHECKBOXES() ;
    }
    delete (void *) _pAuditCheckboxes ;

    _pAuditCheckboxes = NULL ;
    _cUsedAuditCheckboxes = 0 ;
}

/*******************************************************************

	NAME:	    SET_OF_AUDIT_CATEGRORIES::SetCheckBoxNames

	SYNOPSIS:   Constructs each audit checkbox set and sets the permissions
		    accordingly

	ENTRY:	    pAccessMap - Pointer to the MASK_MAP the ACCESS_PERMISSION
			is using

	EXIT:	    Each used dialog will have its name set and be enabled
		    and visible.  The _cUsedAuditCheckboxes will be set to the
		    number of checkboxes that were successfully constructed.

	RETURNS:    An APIERR if an error occurred

	NOTES:	    This is a *construction* method (i.e., meant to be called
		    from the constructor).

	HISTORY:
	    Johnl   30-Sep-1991 Created

********************************************************************/

APIERR SET_OF_AUDIT_CATEGORIES::SetCheckBoxNames( MASK_MAP * pAccessMaskMap )
{
    BOOL fMoreData ;
    BOOL fFromBeginning = TRUE ;
    NLS_STR nlsSpecialPermName( 40 ) ;
    BITFIELD bitMask( (ULONG) 0 ) ;
    APIERR err ;
    AUDIT_CHECKBOXES * pcheckTemp = _pAuditCheckboxes ;

    /* Loop through all of the special permission names and construct
     * each checkbox with the permission name and assocated bitmap.
     */
    while ( ( err = pAccessMaskMap->EnumStrings( &nlsSpecialPermName,
				                 &fMoreData,
			                         &fFromBeginning,
				                 _nID ) ) == NERR_Success
	    && fMoreData
          )
    {
	err = pAccessMaskMap->StringToBits( nlsSpecialPermName,
					    &bitMask,
					    _nID ) ;
	if ( err != NERR_Success )
		return err ;

	new (pcheckTemp)
                         AUDIT_CHECKBOXES( QueryOwnerWindow(),
					   QuerySLTBaseCID() + _cUsedAuditCheckboxes,
					   QuerySuccessBaseCID() + _cUsedAuditCheckboxes,
					   QueryFailedBaseCID() + _cUsedAuditCheckboxes,
					   nlsSpecialPermName,
					   bitMask ) ;

	if ( pcheckTemp->QueryError() != NERR_Success )
		return pcheckTemp->QueryError() ;

	_cUsedAuditCheckboxes++ ;
	pcheckTemp++ ;
    }

    if ( err != NERR_Success )
    {
      return err ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SET_OF_AUDIT_CATEGORIES::ApplyPermissionsToCheckBoxes

    SYNOPSIS:	This method checks all of the checkboxes that have the
		same bits set as the passed bitfields.

    ENTRY:	pbitsSuccess, pbitsFailed - Pointer to bitfields which contains
		    the checkmark criteria.

    EXIT:	All appropriate checkboxes will be selected or deselected
		as appropriate.

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

APIERR SET_OF_AUDIT_CATEGORIES::ApplyPermissionsToCheckBoxes( BITFIELD * pbitsSuccess,
							      BITFIELD * pbitsFailed  )
{
    APIERR err = NERR_Success ;

    for ( int i = 0 ; i < QueryCount() ; i++ )
    {
	BITFIELD bitSTemp( *pbitsSuccess ) ;
	BITFIELD bitFTemp( *pbitsFailed ) ;

	if ( (err = bitSTemp.QueryError()) ||
	     (err = bitFTemp.QueryError())  )
	{
	    return err ;
	}

	/* Mask out all of the bits except for the ones we care about then
	 * check the box if the masks are equal.
	 */
	bitSTemp &= *QueryAuditCheckBox(i)->QueryMask() ;
	QueryAuditCheckBox(i)->CheckSuccess( *QueryAuditCheckBox(i)->QueryMask() == bitSTemp ) ;

	bitFTemp &= *QueryAuditCheckBox(i)->QueryMask() ;
	QueryAuditCheckBox(i)->CheckFailed( *QueryAuditCheckBox(i)->QueryMask() == bitFTemp ) ;
    }

    return NERR_Success ;
}


/*******************************************************************

    NAME:	SET_OF_AUDIT_CATEGORIES::QueryUserSelectedBits

    SYNOPSIS:	Builds a bitfield by examining all of the selected
		checkboxes and the associated bitfields.

    ENTRY:	pbitsSuccess, pbitsFailed - Pointer to bitfield that will
		receive the built bitfield.

    NOTES:	We resize the bits so they match the size of the audit bitmaps

    HISTORY:
	Johnl	30-Sep-1991 Created

********************************************************************/

APIERR SET_OF_AUDIT_CATEGORIES::QueryUserSelectedBits( BITFIELD * pbitsSuccess, BITFIELD * pbitsFailed )
{
    UIASSERT( pbitsSuccess != NULL ) ;
    UIASSERT( pbitsFailed != NULL ) ;
    APIERR err ;
    if ( (err = pbitsSuccess->Resize( QueryAuditCheckBox(0)->QueryMask()->QueryCount())) ||
	 (err = pbitsFailed->Resize( QueryAuditCheckBox(0)->QueryMask()->QueryCount()))   )
    {
	return err ;
    }

    pbitsSuccess->SetAllBits( OFF ) ;
    pbitsFailed->SetAllBits( OFF ) ;

    for ( INT i = 0 ; i < QueryCount() ; i++ )
    {
	if ( QueryAuditCheckBox(i)->IsSuccessChecked() )
	    *pbitsSuccess |= *QueryAuditCheckBox(i)->QueryMask() ;

	if ( QueryAuditCheckBox(i)->IsFailedChecked() )
	    *pbitsFailed |= *QueryAuditCheckBox(i)->QueryMask() ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SET_OF_AUDIT_CATEGORIES::Enable

    SYNOPSIS:	Enables or disables all of the audit checkboxes in this
		set of audit categories

    ENTRY:	fEnable - TRUE if the checkboxes should be enabled, FALSE
		    otherwise
		fClear - TRUE if the checkbox should be cleared prior to
		    enable/disable

    NOTES:

    HISTORY:
	Johnl	22-Nov-1991	Created

********************************************************************/

void SET_OF_AUDIT_CATEGORIES::Enable( BOOL fEnable, BOOL fClear )
{
    for ( INT i = 0 ; i < QueryCount() ; i++ )
	QueryAuditCheckBox(i)->Enable( fEnable, fClear ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\cncltask.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
 *  openfile.cxx
 *	This module contains the code for the Task cancel dialog
 *
 *
 *  FILE HISTORY:
 *	Johnl	21-Oct-1992	Created
 *
 */

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:	CANCEL_TASK_DIALOG::CANCEL_TASK_DIALOG

    SYNOPSIS:	Constructor for cancel task dialog

    ENTRY:	hwndParent - Parent window handle
		idDialog   - Dialog resource to use
		pszDlgTitle - Title of this dialog
		ulContext   - User supplied context that will be passed
			      to DoOneItem callout
		msgidErrorMsg - Error message (w/ insert strings) to display
				when DoOneItem returns an error.

    NOTES:	If we fail to construct because we couldn't get a timer,
		then we will call DoOneItem repeatedly until we are told
		to quit (i.e., no time slicing).

    HISTORY:
	Johnl	21-Oct-1992	Created

********************************************************************/

CANCEL_TASK_DIALOG::CANCEL_TASK_DIALOG( UINT  idDialog,
					HWND  hwndParent,
					const TCHAR * pszDlgTitle,
					ULONG_PTR ulContext,
                    MSGID msgidErrorMsg,
                    ELLIPSIS_STYLE style )
    : DIALOG_WINDOW( idDialog,
		     hwndParent ),
      _ulContext( ulContext ),
      _msgidErrorMsg( msgidErrorMsg ),
      _sltStatusText( this, SLT_STATUS_TEXT, style ),
      _idTimer	    ( 0 ),
      _fInTimer     ( FALSE ),
      _fDone	    ( FALSE )
{
    if ( QueryError() )
	return ;

    if ( pszDlgTitle != NULL )
    {
	SetText( pszDlgTitle ) ;
    }

    //
    //	If we can't get a timer then the MayRun method will loop through
    //	each time slice.
    //
    _idTimer = ::SetTimer( QueryHwnd(),
	                   CANCEL_TASK_TIMER_ID,
	                   CANCEL_TASK_TIMER_INTERVAL,
	                   NULL ) ;
}


CANCEL_TASK_DIALOG::~CANCEL_TASK_DIALOG()
{
    if ( _idTimer != 0 )
	::KillTimer( QueryHwnd(), _idTimer ) ;

    _idTimer = 0 ;
}


/*******************************************************************

    NAME:	CANCEL_TASK_DIALOG::DoOneItem

    SYNOPSIS:	Default virtual, does nothing

    NOTES:

    HISTORY:
	Johnl	21-Oct-1992	Created

********************************************************************/

APIERR CANCEL_TASK_DIALOG::DoOneItem( ULONG_PTR   ulContext,
				      BOOL  * pfContinue,
                                      BOOL  * pfDisplayError,
                                      MSGID * pmsgidAlternateError )
{
    UNREFERENCED( ulContext ) ;
    UIASSERT( FALSE ) ;
    *pfContinue = FALSE ;
    *pfDisplayError = TRUE ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:	CANCEL_TASK_DIALOG::OnTimer

    SYNOPSIS:	Calls each task slice

    NOTES:	This method maybe called without being in response to a
		timer message.

		Note that the timer will keep pinging away at us even if
		there is an error message up.  Thus the IsInTimer method
		acts as a semaphore to keep us from being re-entrant.

		We use QueryRobustHwnd for message popups because we may
		be called w/o ever appearing

    HISTORY:
	Johnl	21-Oct-1992	Created

********************************************************************/

BOOL CANCEL_TASK_DIALOG::OnTimer( const TIMER_EVENT & )
{
    if ( IsInTimer() || IsFinished() )
	return TRUE ;
    SetInTimer( TRUE ) ;

    APIERR err ;
    APIERR errOnDoOneItem ;
    MSGID  msgidError = 0 ;
    BOOL fContinue = FALSE ;
    BOOL fDisplayError = TRUE ;

    if ( (errOnDoOneItem = DoOneItem( _ulContext,
                                      &fContinue,
                                      &fDisplayError,
                                      &msgidError )) &&
	 fDisplayError )
    {
	RESOURCE_STR nlsError( errOnDoOneItem ) ;
	NLS_STR      nlsObjectName ;
	APIERR	     errTmp ;

	if ( (errTmp = nlsError.Load( errOnDoOneItem )))
	{
	    DEC_STR decStr( (ULONG) errOnDoOneItem ) ;
	    if ( (errTmp = decStr.QueryError()) ||
		 (errTmp = nlsError.CopyFrom( decStr )) )
	    {
		::MsgPopup( this->QueryRobustHwnd(), (MSGID) errTmp ) ;
		SetInTimer( FALSE ) ;
		return TRUE ;
	    }
	}

	if ( (err = nlsObjectName.QueryError())        ||
	     (err = nlsError.QueryError())	       ||
	     (err = QueryObjectName( &nlsObjectName ))	 )
	{
	    ::MsgPopup( this->QueryRobustHwnd(), (MSGID) err ) ;
	    SetInTimer( FALSE ) ;
	    return TRUE ;
	}

	switch ( ::MsgPopup( this->QueryRobustHwnd(),
                             msgidError ? msgidError : _msgidErrorMsg,
			     MPSEV_WARNING,
			     MP_YESNO,
			     nlsError,
			     nlsObjectName ))
	{
	case IDYES:
	    break ;

	case IDNO:
	default:
	    Dismiss( FALSE ) ;
	    _fDone = TRUE ;
	    break ;
	}
    }

    if ( !fContinue )
    {
	Dismiss( TRUE ) ;
	_fDone = TRUE ;
    }

    SetInTimer( FALSE ) ;
    return TRUE ;
}


/*******************************************************************

    NAME:	CANCEL_TASK_DIALOG::QueryObjectName

    SYNOPSIS:	Gets the object name to use for messages

    ENTRY:	pnlsObjName - NLS_STR to receive the object name

    RETURNS:	NERR_Success if succesful, error code otherwise

    NOTES:	This method defaults to getting what's in the status SLT

    HISTORY:
	Johnl	21-Oct-1992	Created

********************************************************************/

APIERR CANCEL_TASK_DIALOG::QueryObjectName( NLS_STR *pnlsObjName )
{
    return  _sltStatusText.QueryText( pnlsObjName ) ;
}

/*******************************************************************

    NAME:	CANCEL_TASK_DIALOG::MayRun

    SYNOPSIS:	If we failed to get the timer, then loop here and
		forget about time slicing.  The dialog won't come up.

    RETURNS:	FALSE indicating the dialog shouldn't come up

    NOTES:

    HISTORY:
	Johnl	22-Oct-1992	Created

********************************************************************/

BOOL CANCEL_TASK_DIALOG::MayRun( void )
{
    if ( _idTimer == 0 )
    {
	AUTO_CURSOR niftycursor ;
	TIMER_EVENT teDummy( 0, 0, 0 ) ;
	while ( !IsFinished() )
	{
	    OnTimer( teDummy ) ;
	}
	return FALSE ;
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\devcb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    devcb.cxx
    BLT device combo and domain combo definitions

    FILE HISTORY:
        rustanl     28-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        rustanl     20-Mar-1991 Added cbMaxLen parameter to DOMAIN_COMBO ct
        rustanl     21-Mar-1991 Folded in code review changes from
                                CR on 20-Mar-1991 attended by
                                JimH, GregJ, Hui-LiCh, RustanL.
        beng        14-May-1991 Exploded blt.hxx into components
        beng        22-Sep-1991 Relocated from BLT into Applib
        terryk      07-Oct-1991 type changes for NT

*/

#include "pchapplb.hxx"   // Precompiled header


/***********************************************************************

    NAME:       DEVICE_COMBO::DEVICE_COMBO

    SYNOPSIS:   Fills a combo box with devices (spec'd by parms).
                Selects first item in combo.

    ENTRY:
       powin             Pointer to owner window
       cid               ID of control
       lmodevType        Indicates which type of device (e.g., disk, printer)
       devusage  Indicates which particular devices go into the
                       combo box (e.g., devices currently available for
                       new connections)
    EXIT:

    NOTES:
       The DEVICE_COMBO control should not use the CBS_SORT style.  Instead,
       the control will insert the devices in the correct order.

    HISTORY:
        rustanl     28-Nov-1990 Created
        beng        31-Jul-1991 Error reporting changed
        beng        05-Oct-1991 Win32 conversion

***********************************************************************/

DEVICE_COMBO::DEVICE_COMBO( OWNER_WINDOW * powin,
                            CID cid,
                            LMO_DEVICE lmodevType,
                            LMO_DEV_USAGE devusage )
    : COMBOBOX( powin, cid ),
      _lmodevType( lmodevType ),
      _devusage( devusage ),
      _fDefSelLast( devusage == LMO_DEV_ALLDEVICES_DEFZ )
{
    if (QueryError())
        return;

    if ( _devusage == LMO_DEV_ALLDEVICES_DEFZ )
    {
        _devusage = LMO_DEV_ALLDEVICES;
    }

    //  Fill devices
    APIERR err = FillDevices();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/**********************************************************************

    NAME:       DEVICE_COMBO::FillDevices

    SYNOPSIS:   Appends the names of the devices to the combo.

    ENTRY:      NONE

    RETURN:     Error value, which is NERR_Success on success.

    NOTES:
        Private member.

    HISTORY:
        rustanl     28-Nov-1990 Created
        beng        05-Oct-1991 Win32 conversion

**********************************************************************/

APIERR DEVICE_COMBO::FillDevices()
{
    ITER_DEVICE idev( _lmodevType, _devusage );

    INT cDevsAdded = 0;
    const TCHAR * pszDev;
    while ( ( pszDev = idev()) != NULL )
    {
        if ( AddItem( pszDev ) < 0 )
            return ERROR_NOT_ENOUGH_MEMORY;

        cDevsAdded++;
    }

    //  Finally, select the first item, unless no items were inserted
    if ( cDevsAdded > 0 )
    {
        SelectItem( _fDefSelLast ? cDevsAdded - 1 : 0 );
    }

    return NERR_Success;
}


/**********************************************************************

    NAME:       DEVICE_COMBO::Refresh

    SYNOPSIS:   This method refreshes the contents of the combo box.
                Then, it selects first item in the list, if any, or
		the last device depending on _fDefSelLast.

    RETURN:     An error value, which is NERR_Success on success.

    HISTORY:
        rustanl     28-Nov-1990 Created
        rustanl     26-Mar-1991 Changed how new selection is made
        beng        05-Oct-1991 Win32 conversion

**********************************************************************/

APIERR DEVICE_COMBO::Refresh()
{
    SetRedraw( FALSE );

    DeleteAllItems();

    //  Add the devices.  Keep the error for below.  Note, that the
    //  code in between is always executed regardless of the success
    //  of FillDevices.
    APIERR err = FillDevices();

    //  Set new selection
    if ( QueryCount() > 0 )
        SelectItem( _fDefSelLast ? QueryCount() - 1 : 0 );

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;
}


/**********************************************************************

    NAME:       DEVICE_COMBO::QueryDevice

    SYNOPSIS:   Returns the currently selected device name.

    ENTRY:
       pnlsDevice        Pointer to NLS_STR object.  To be safe, an owner
                       alloc'd NLS_STR should be able to accomodate of string
                       of length DEVLEN.

    RETURN:     An error value, which is NERR_Success on success.

    NOTES:
       QueryTextItem( NLS_STR ) could be used to retrieve the device
       name, but since the length of the device is know, QueryItemText(
       TCHAR, USHORT ) is used instead for efficiency.

    HISTORY:
        rustanl     28-Nov-1990 Created
        beng        05-Oct-1991 Win32 conversion

**********************************************************************/

APIERR DEVICE_COMBO::QueryDevice( NLS_STR * pnlsDevice ) const
{
    UIASSERT( pnlsDevice != NULL );

    INT i = QueryCurrentItem();
    if ( i < 0 )
    {
        //  No item is selected.  The combo had better be empty.
        UIASSERT( QueryCount() == 0 );
        *pnlsDevice = SZ("");
        return NERR_Success;
    }

    TCHAR szDevice[ DEVLEN + 1 ];

    REQUIRE( QueryItemText( szDevice, sizeof(szDevice), i ) == NERR_Success );

    *pnlsDevice = szDevice;

    return pnlsDevice->QueryError();
}


/**********************************************************************

    NAME:       DEVICE_COMBO::DeleteCurrentDeviceName

    SYNOPSIS:   Removes the currently selected device from the combo box.
                It then selects the first item in the list, if any.

    ENTRY:      NONE

    RETURN:     NONE

    NOTES:

    HISTORY:
        rustanl     28-Nov-1990     Created

***********************************************************************/

VOID DEVICE_COMBO::DeleteCurrentDeviceName()
{
    INT i = QueryCurrentItem();
    if ( i < 0 )
    {
        //  There is no selection.  The combo box had better be empty.
        UIASSERT( QueryCount() == 0 );
        return;
    }

    RemoveSelection();
    if ( DeleteItem( i ) > 0)
    {
        //  There are items left in the combo; thus, select the first item
        SelectItem( 0 );
    }
}


/**********************************************************************

    NAME:       DOMAIN_COMBO::DOMAIN_COMBO

    SYNOPSIS:   Differs from parent only in contents of combo.

    ENTRY:
       powin             Pointer to owner window
       cid               ID of control
       fsDomains Specifies which domains are to be inserted into
                       the list.  This value is a bit array and may contain
                       any of the following values OR'd together:
                                  DOMCB_PRIM_DOMAIN
                                  DOMCB_LOGON_DOMAIN
                                  DOMCB_OTHER_DOMAINS
                                  DOMCB_DS_DOMAINS
       cbMaxLen  Text size limit.  Should be 0 for dropdown lists,
                       and is normally DNLEN for dropdown combos.

    EXIT:

    NOTES:
       The DOMAIN_COMBO should use the CBS_SORT style to sort the domains.

    HISTORY:
        rustanl     28-Nov-1990 Created
        beng        31-Jul-1991 Error reporting changed
        beng        05-Oct-1991 Partial Win32 conversion
        beng        29-Mar-1992 Remove odious PCH type

**********************************************************************/

DOMAIN_COMBO::DOMAIN_COMBO( OWNER_WINDOW * powin,
                            CID cid,
                            UINT fsDomains,
                            UINT cbMaxLen )
    : COMBOBOX( powin, cid, cbMaxLen )
{
    UIASSERT( ! ( fsDomains & ~( DOMCB_PRIM_DOMAIN | DOMCB_LOGON_DOMAIN |
                                 DOMCB_OTHER_DOMAINS | DOMCB_DS_DOMAINS )));

    if (QueryError())
        return;

    WKSTA_10 wksta10;
    APIERR usErr = wksta10.GetInfo();
    if ( usErr != NERR_Success )
    {
        ReportError( usErr );
        return;
    }

    //  Add wksta domain if requested
    if ( fsDomains & DOMCB_PRIM_DOMAIN )
    {
        const TCHAR * psz = wksta10.QueryWkstaDomain();

        //  Note.  Wksta must be started since GetInfo worked; thus, there
        //  must be a wksta domain
        UIASSERT( psz != NULL && ::strlenf( psz ) > 0 );

        if ( AddItemIdemp( psz ) < 0 )
        {
            ReportError( ERROR_NOT_ENOUGH_MEMORY );
            return;
        }
    }

    //  Add logon domain if requested and the user is logged
    if ( fsDomains & DOMCB_LOGON_DOMAIN )
    {
        const TCHAR * psz = wksta10.QueryLogonDomain();
        if ( psz != NULL && ::strlenf( psz ) > 0 &&
             AddItemIdemp( psz ) < 0 )
        {
            ReportError( ERROR_NOT_ENOUGH_MEMORY );
            return;
        }
    }

    //  Add other domains, if requested
    if ( fsDomains & DOMCB_OTHER_DOMAINS )
    {
        //  QueryOtherDomains returns pointer to STRLIST
        STRLIST * pslOtherDomains = wksta10.QueryOtherDomains();

        //  declare iterator for STRLIST
        ITER_STRLIST islOtherDomains( *pslOtherDomains );

        NLS_STR * pnls;
        while ( ( pnls = islOtherDomains()) != NULL )
        {
            if ( AddItemIdemp( pnls->QueryPch()) < 0 )
            {
                ReportError( ERROR_NOT_ENOUGH_MEMORY );
                return;
            }
        }
    }

    if ( fsDomains & DOMCB_DS_DOMAINS )
    {
        //  Add the domains listed in the DS.
        //  CODEWORK.  Not yet implemented (Thor time frame).
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\domthred.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
    This file contains the domain fill thread code


    FILE HISTORY:
	Johnl	07-Dec-1992	Created

*/

#include "pchapplb.hxx"   // Precompiled header

#include "browmemb.hxx"

/*******************************************************************

    NAME:	DOMAIN_FILL_THREAD::DOMAIN_FILL_THREAD

    SYNOPSIS:	Constructor for the domain fill thread

    ENTRY:	pdlg - Pointer to user browser dialog (generally treated
		    as a read only resource)
		pbrowdomain - Pointer to browser domain that this thread
		    will get the information for

    NOTES:	This thread is created in the suspended state.	The caller
		must call resume to actually get the thread moving.

    HISTORY:
	Johnl	07-Dec-1992	Created

********************************************************************/

DOMAIN_FILL_THREAD::DOMAIN_FILL_THREAD( NT_USER_BROWSER_DIALOG * pdlg,
					BROWSER_DOMAIN	       * pbrowdomain,
					const ADMIN_AUTHORITY * pAdminAuthority )
    : WIN32_THREAD	     ( TRUE, 1024, SZ("NETUI2.DLL") ),
      _pAdminAuthority       ( (ADMIN_AUTHORITY *)pAdminAuthority ),
      _eventExitThread	     ( NULL, FALSE ),
      _eventRequestForData   ( NULL, FALSE ),
      _eventLoadedAuthority  ( NULL, TRUE, FALSE ),
      _fRequestDataPending   ( FALSE ),
      _fThreadIsTerminating  ( FALSE ),
      _errLoadingAuthority   ( NERR_Success ),
      _plbicache	     ( NULL ),
      _hwndDlg               ( pdlg->QueryHwnd() ),
      _ulDlgFlags            ( pdlg->QueryFlags() ),
      _nlsDCofPrimaryDomain  ( pdlg->QueryDCofPrimaryDomain() ),
      _nlsDomainName         ( pbrowdomain->QueryDomainName() ),
      _nlsLsaDomainName      ( pbrowdomain->QueryLsaLookupName() ),
      _fIsWinNT              ( pbrowdomain->IsWinNTMachine() ),
      _fIsTargetDomain       ( pbrowdomain->IsTargetDomain() ),
      _fDeleteAdminAuthority ( pAdminAuthority == NULL )
{
    if ( QueryError() )
	return ;

    //
    //	The thread is started after we check for successful construction
    //	of our members
    //
    APIERR err ;
    if ( (err = _eventExitThread.QueryError()) ||
	 (err = _eventRequestForData.QueryError()) ||
	 (err = _eventLoadedAuthority.QueryError()) )
    {
	ReportError( err ) ;
	return ;
    }
}

DOMAIN_FILL_THREAD::~DOMAIN_FILL_THREAD()
{
    delete _plbicache ;
    _plbicache = NULL ;
    if ( _fDeleteAdminAuthority )
    {
        delete _pAdminAuthority ;
        _pAdminAuthority = NULL ;
    }
}

APIERR DOMAIN_FILL_THREAD::PostMain( VOID )
{
    TRACEEOL("DOMAIN_FILL_THREAD::PostMain - Deleting \"this\" for thread "
             << HEX_STR( (ULONG) QueryHandle() )) ;

    DeleteAndExit( NERR_Success ) ; // This method should never return

    UIASSERT( FALSE );

    return NERR_Success;
}

/*******************************************************************

    NAME:	DOMAIN_FILL_THREAD::Main

    SYNOPSIS:	Threads main worker method

    NOTES:

    HISTORY:
	Johnl	07-Dec-1992	Created

********************************************************************/

APIERR DOMAIN_FILL_THREAD::Main( VOID )
{
    TRACEEOL("DOMAIN_FILL_THREAD::Main Entered") ;

    APIERR err = NERR_Success ;
    const TCHAR * pszServer ;
    BOOL fIsServer = TRUE ;

    //
    //	If the name begins with a "\\" or is NULL, then the domain is
    //	really a server which we can use directly (i.e., its either the
    //	focused machine or the PDC of a domain).
    //
    const TCHAR *pszDomainName = _nlsDomainName.QueryPch();
    if ( ( pszDomainName[ 0 ] != TCH('\0') &&
	   pszDomainName[ 0 ] == TCH('\\') &&
	   pszDomainName[ 1 ] == TCH('\\')))
    {
	pszServer = pszDomainName;
    }
    else if ( *pszDomainName == TCH('\0') )
    {
        pszServer = NULL ;
    }
    else
    {
        fIsServer = FALSE ;
    }

    //
    //	The domain name length will be zero if this is the local machine
    //
    //  SPECIAL CAUTION: see the SPECIAL CAUTION in lmodom.hxx for a warning about
    //  this call.  This is believed to be the only call in NETUI which passes a
    //  target server to DOMAIN[_WITH_DC_CACHE], this parameter is no longer active.
    //  JonN 5/18/98
    //
    DOMAIN_WITH_DC_CACHE BrowserDomain( _nlsDCofPrimaryDomain,
                                        _nlsDomainName,
                                        TRUE ) ;
    BOOL fGotDC        = FALSE ;
    BOOL fGotValidData = FALSE ;    // Successfully enumerated all data

    //
    //  This is the thread's main loop.  In response to each request, we
    //	try and get the necessary data items.  If we can't, then will try
    //	again on the next request.  Once we have successfully gotten all of
    //	the data, we just keep it in a sorted array waiting for somebody
    //	to ask for it.
    //

    while ( TRUE )
    {
	err = NERR_Success ;

	if ( _fThreadIsTerminating )
	    break ;

	//
	//  First try and get the DC
	//

	if ( !fIsServer &&
	     !fGotDC	&&
             (_pAdminAuthority == NULL) &&
	     (err = BrowserDomain.GetInfo()) )
	{
	    DBGEOL( "DOMAIN_FILL_THREAD::Main - Error " << (ULONG) err <<
		    " occurred constructing the DOMAIN class" ) ;
            //
            //  Give a more specific error message.  The workstation or
            //  browser not started should be the only reason why we get
            //  this error.
            //
            if ( err == NERR_ServiceNotInstalled )
                err = IDS_WKSTA_OR_BROWSER_NOT_STARTED;
        }
	else
	{
	    fGotDC = TRUE ;
	}

	if ( _fThreadIsTerminating )
	    break ;

	//
	//  Now try and get the admin authority
	//

	if ( !err && _pAdminAuthority == NULL )
	{
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    _pAdminAuthority = new ADMIN_AUTHORITY(fIsServer ? pszServer :
						     BrowserDomain.QueryAnyDC(),
						   DEF_SAM_DOMAIN_ACCESS,
						   DEF_SAM_DOMAIN_ACCESS,
						   DEF_LSA_POLICY_ACCESS,
						   DEF_SAM_SERVER_ACCESS,
						   TRUE
						  ) ;
            err = ERROR_NOT_ENOUGH_MEMORY;
	    if ( _pAdminAuthority == NULL ||
		 (err = _pAdminAuthority->QueryError()) )
	    {
		DBGEOL( "DOMAIN_FILL_THREAD::Main -  - Error " << (ULONG) err <<
			" occurred creating the ADMIN_AUTHORITY" ) ;
                if ( _fDeleteAdminAuthority )
                {
		    delete _pAdminAuthority;
		    _pAdminAuthority = NULL;
                }
	    }
	}

        //
        // We remember the reason why (if) we failed to load the authority.
        //
        ASSERT(   (    _pAdminAuthority != NULL
                    && _pAdminAuthority->QueryError() == NERR_Success )
               || (err != NERR_Success) );
        _errLoadingAuthority = err;

        //
        // Whether or not we successfully allocated the ADMIN_AUTHORITY,
        // we set the LoadedAuthority event here.
        //
        {
            TRACEEOL( "DOMAIN_FILL_THREAD: setting AdminAuthority event (1)" );

            APIERR errEvent = _eventLoadedAuthority.Set() ;
            if (errEvent != NERR_Success)
            {
		DBGEOL("DOMAIN_FILL_THREAD::Main - Error " << errEvent <<
		       "setting LoadedAuthority event" ) ;
                if (err == NERR_Success)
                    err = errEvent;
            }
        }

	if ( _fThreadIsTerminating )
	    break ;

	//
	//  Now try and fill the array
	//

	if (!err &&
	    _plbicache == NULL )
	{
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    _plbicache = new USER_BROWSER_LBI_CACHE() ;
	    if ( _plbicache == NULL ||
                 (err = _plbicache->Fill(
                                   _pAdminAuthority,
                                   _nlsLsaDomainName.QueryPch()[0] == TCH('\\') ?
                                       _nlsLsaDomainName.QueryPch()+2 :
                                       _nlsLsaDomainName.QueryPch(),
                                   _ulDlgFlags,
                                   _fIsWinNT,
                                   _fIsTargetDomain,
                                   &_fThreadIsTerminating )) )
	    {
		DBGEOL("DOMAIN_FILL_THREAD::Main - Error " << err <<
		       "retrieving account data" ) ;
		delete _plbicache ;
		_plbicache = NULL ;
	    }
	}

	if ( _fThreadIsTerminating )
	    break ;

	//
	//  If we failed on any of the previous items, then put up an error
	//  and wait to see if we are selected again.
	//
	//  Else send the data to the dialog if they still want it.
	//

	if ( err )
	{
	    fGotValidData = FALSE ;
	    if ( _fRequestDataPending && !_fThreadIsTerminating )
	    {
		::SendMessage( _hwndDlg, WM_LB_FILLED,
                               (WPARAM) FALSE, (LPARAM) err ) ;
	    }
	}
	else
	{
	    fGotValidData = TRUE ;

	    //
	    //	The data request may have been cancelled or this may be
	    //	the second time through this loop because we got an error
	    //	the first time.  Satisfy the request then clear the event.
	    //
	    if ( _fRequestDataPending )
            {
                //
                //  Only include users in the initial data request if the users
                //  are expanded or that is all that is shown.
                //
                _plbicache->SetIncludeUsers(
                   _ulDlgFlags & USRBROWS_EXPAND_USERS ||
                   (( _ulDlgFlags & USRBROWS_SHOW_ALL) == USRBROWS_SHOW_USERS));

		if ( _fRequestDataPending && !_fThreadIsTerminating )
                {
                    ::PostMessage( _hwndDlg,
                                   WM_LB_FILLED,
                                   (WPARAM) TRUE,
                                   (LPARAM) _plbicache ) ;
		}

		//
		// Reset any subsequent requests we may have received for this
		// domain's thread
		//
		_eventRequestForData.Reset() ;
		_fRequestDataPending = FALSE ;
	    }
	}

	//
	//  Wait on events
	//

	HANDLE ahEvents[2] ;
	ahEvents[0] = _eventExitThread.QueryHandle() ;
	ahEvents[1] = _eventRequestForData.QueryHandle() ;

	switch ( ::WaitForMultipleObjects( 2, ahEvents, FALSE, INFINITE ))
	{
	case STATUS_WAIT_0: // Get out of Dodge...

	    _fThreadIsTerminating = TRUE ;
	    break ;

	case STATUS_WAIT_1: // Dialog wants our data
	    //
	    //	Make sure we have data to give.  If we don't, then we loop
	    //	through and try again.
	    //
	    _fRequestDataPending = TRUE ;

	    break ;

	default:
	    err = ::GetLastError() ;
	    DBGEOL("DOMAIN_FILL_THREAD::Main - Error " << err << " waiting on events")
	}

	if ( _fThreadIsTerminating )
	    break ;
    }


    TRACEEOL("DOMAIN_FILL_THREAD::terminating") ;
    return err ;
}

APIERR DOMAIN_FILL_THREAD::WaitForAdminAuthority( DWORD msTimeout,
                                                  BOOL * pfTimedOut ) const
{
    TRACEEOL( "DOMAIN_FILL_THREAD: waiting for AdminAuthority at time " << ::GetTickCount() );

    APIERR err = NERR_Success;

    if (pfTimedOut != NULL)
        *pfTimedOut = FALSE;

    HANDLE hEvent = _eventLoadedAuthority.QueryHandle();

    switch ( ::WaitForSingleObject( _eventLoadedAuthority.QueryHandle(), msTimeout ))
    {
    case WAIT_OBJECT_0: // event was set
        TRACEEOL("DOMAIN_FILL_THREAD::WaitForAdminAuthority - WAIT_OBJECT_0");
        break ;

    case WAIT_ABANDONED:
        TRACEEOL("DOMAIN_FILL_THREAD::WaitForAdminAuthority - WAIT_ABANDONED");
        break;

    case WAIT_TIMEOUT:
        TRACEEOL("DOMAIN_FILL_THREAD::WaitForAdminAuthority - WAIT_TIMEOUT after " << msTimeout << " ms" );
        if (pfTimedOut != NULL)
            *pfTimedOut = TRUE;
        break;

    default:
        err = ::GetLastError() ;
        DBGEOL("DOMAIN_FILL_THREAD::WaitForAdminAuthority - Error " << err << " waiting on events")
        break;
    }

    TRACEEOL( "DOMAIN_FILL_THREAD: returning " << err << " at time " << ::GetTickCount() );

    return err;
}


//
//  Gets around circular reference problems
//
APIERR DOMAIN_FILL_THREAD::RequestAndWaitForUsers( void )
{
    const TCHAR *pszDomainName = _nlsLsaDomainName.QueryPch();
    if ( ( pszDomainName[ 0 ] != TCH('\0') &&
	   pszDomainName[ 0 ] == TCH('\\') &&
	   pszDomainName[ 1 ] == TCH('\\')))
    {
        //
        //  Domain name is a server name so strip the '\\'
        //
        pszDomainName += 2 ;
    }
    return _plbicache->AddUsers( _pAdminAuthority,
                                 pszDomainName,
				 _fIsTargetDomain,
                                 &_fThreadIsTerminating ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\ellipsis.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ellipsis.cxx

    This file contains all the ellipsis related classes.
    There are: BASE_ELLIPSIS
               CONSOLE_ELLIPSIS
               WIN_ELLIPSIS
               SLT_ELLIPSIS
               STR_DTE_ELLIPSIS

    Ellipsis text:    // put dot dot in the left, center or right
                       // handside of the string if the string is too
                       // long
        ELLIPSIS_NONE
        ELLIPSIS_LEFT
        ELLIPSIS_CENTER
        ELLIPSIS_RIGHT
        ELLIPSIS_PATH

    FILE HISTORY:
        terryk      21-Mar-1991 creation
        terryk      28-Mar-1991 change it to SLTP
        terryk       2-Apr-1991 add double ampersands
        terryk       3-Apr-1991 add the SLTP_DOT_PATH
        terryk       4-Apr-1991 code review changed
        terryk       5-Apr-1991 SLTP_DOUBLE_AMPERSANDS deleted
        terryk      16-Apr-1991 second code review changed
                                attend: johnl jonn gregj rustanl
        beng        14-May-1991 Exploded blt.hxx into components
        terryk      12-Jun-1991 Add column header type.
        terryk      18-Jul-1991 fix the cchGuess out of range bug
        terryk      01-Aug-1991 Change GetClientRect.
        beng        18-Sep-1991 Cleaned up error reporting
        beng        17-Oct-1991 Moved into APPLIB
        beng        25-Oct-1991 Remove static global ctors
        congpay     05-Apr-1993 Changed from SLTPLUS class to ellipsis classes.
*/

#include "pchapplb.hxx"   // Precompiled header

DEFINE_MI2_NEWBASE (SLT_ELLIPSIS, SLT, WIN_ELLIPSIS);

// Set up the global Ellipsis Text string

static NLS_STR * pnlsEllipsisText = NULL;
static INT       nCount = 0;

/**********************************************************************

    NAME:       BASE_ELLIPSIS::Init

    SYNOPSIS:   Initialize the ellipsis text string by loading it from
                the resource file.

    RETURNS:    Error code, 0 if successful

    NOTES:      set the ellipsistext member within the class

    HISTORY:
        terryk      26-Apr-1991 creation
        beng        18-Sep-1991 Renamed; returns error code
        beng        25-Oct-1991 Remove global static ctor

**********************************************************************/

APIERR BASE_ELLIPSIS::Init()
{
    nCount++;

    // Load the standard Ellipsis Text String from the resource file
    if (::pnlsEllipsisText == NULL)
    {
        ::pnlsEllipsisText = new RESOURCE_STR( IDS_BLT_ELLIPSIS_TEXT );
    }

    if (::pnlsEllipsisText == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    return ::pnlsEllipsisText->QueryError();
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::Term

    SYNOPSIS:   Release the internal string

    NOTES:      Call global object destrcutor to delete the internal string

    HISTORY:
        terryk      29-Apr-1991 creation
        beng        18-Sep-1991 Renamed
        beng        25-Oct-1991 Remove global static dtor

**********************************************************************/

VOID BASE_ELLIPSIS::Term()
{
    if( nCount > 0 )
    {
        if( --nCount == 0 )
        {
            delete ::pnlsEllipsisText;
            ::pnlsEllipsisText = NULL;
        }
    }
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::BASE_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:      INT - nStyle
                   can be either one of the 5 styles:
                      ELLIPSIS_NONE
                      ELLIPSIS_LEFT
                      ELLIPSIS_CENTER
                      ELLIPSIS_RIGHT
                      ELLIPSIS_PATH

    NOTES:      The default setting is
                      ELLIPSIS_NONE.

    HISTORY:
        terryk      24-Mar-91   Creation
        terryk      16-Apr-91   Code Review changed
        beng        17-May-1991 Added app-window constructor
        beng        18-Sep-1991 Refined error reporting
        beng        30-Apr-1992 Bug in WINDOW::QueryText usage
        congpay     05-Apr-1993 Changed from SLTPLUS class to BASE_ELLIPSIS class.

**********************************************************************/

BASE_ELLIPSIS::BASE_ELLIPSIS( ELLIPSIS_STYLE nStyle )
    :_nStyle( nStyle ),
     _nlsOriginalStr()
{
    APIERR err = _nlsOriginalStr.QueryError();

    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::IsValidStyle

    SYNOPSIS:   check the incoming Style flag is correct or not

    ENTRY:      ELLIPSIS_STYLE - style to be checked

    RETURN:     BOOL to indicate whether the style is valid or not

    NOTES:      Currently, the style must be one of the ELLIPSIS type.

    HISTORY:
        terryk      3-Apr-1991  creation
        terryk      16-Apr-1991 change it to case statement

**********************************************************************/

BOOL BASE_ELLIPSIS::IsValidStyle ( const ELLIPSIS_STYLE nStyle ) const
{
   // we have 5 ellipsis text styles, check whether he ask for something else
    switch ( nStyle )
    {
    case ELLIPSIS_NONE:
    case ELLIPSIS_LEFT:
    case ELLIPSIS_CENTER:
    case ELLIPSIS_RIGHT:
    case ELLIPSIS_PATH:
        return TRUE;
    default:
        return FALSE;
    }
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetEllipsis

    SYNOPSIS:   It will put an ellipsis text within the string
                if the string is too long.

    ENTRY:

    RETURN:  error code from the converting routine.

    NOTES:

    HISTORY:
        terryk      27-Mar-1991 Created
        beng        18-Sep-1991 Refined error reporting
        beng        04-Oct-1991 Win32 conversion
        beng        30-Apr-1992 Use NLS_STR::CopyFrom

**********************************************************************/

APIERR BASE_ELLIPSIS::SetEllipsis(NLS_STR * pnlsStr )
{
    if (!*pnlsStr)
        return pnlsStr->QueryError();

    _nlsOriginalStr.CopyFrom(*pnlsStr);

    if ( !_nlsOriginalStr )
        return _nlsOriginalStr.QueryError();

    if (QueryStrLen (*pnlsStr) > QueryLimit())
    {
        switch ( _nStyle )
        {
        case ELLIPSIS_LEFT:
            return SetEllipsisLeft(pnlsStr);

        case ELLIPSIS_CENTER:
            return SetEllipsisCenter(pnlsStr);

        case ELLIPSIS_RIGHT:
            return SetEllipsisRight(pnlsStr);

        case ELLIPSIS_PATH:
            return SetEllipsisPath(pnlsStr);

        case ELLIPSIS_NONE:
        default:
            break;
        }
    }

    return NERR_Success;
}

APIERR BASE_ELLIPSIS::SetEllipsis (TCHAR * lpStr)
{
    ASSERT (lpStr);

    NLS_STR nlsTemp(lpStr);

    if ( !nlsTemp )
        return nlsTemp.QueryError();

    APIERR err = SetEllipsis (&nlsTemp);

    if (err == NERR_Success)
    {
        ::strcpyf (lpStr, nlsTemp.QueryPch());
    }

    return err;
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::QueryText

    SYNOPSIS:   Returns the original non-ellipsis text of the control.

    ENTRY:
       pszBuffer    A pointer to a buffer, where the text
                    will be copied.

       cbBufSize    The size of this buffer.  The window text
                    copied to the buffer will be truncated if
                    the buffer is not big enough (including the
                    trailing NUL), in which case the function will
                    return ERROR_MORE_DATA.
         or

       pnls         A pointer to a NLS_STR to hold the results

    EXIT:       If psz+cb, psz buffer now contains the text.
                If pnls, the string has endured assignment.

    RETURNS:    0 if successful,
                ERROR_MORE_DATA if had to truncate string to fit in
                    user-supplied buffer.
                Otherwise, some error code.

    HISTORY:
        terryk      27-Mar-1991     Created
        beng        23-May-1991     Changed return type
        beng        30-Apr-1992     Unicode fixes

**********************************************************************/

APIERR BASE_ELLIPSIS::QueryText( TCHAR * pszBuffer, UINT cbBufSize ) const
{
    ASSERT (pszBuffer);

    if ( !_nlsOriginalStr )
        return _nlsOriginalStr.QueryError();

    // I would use CopyTo, but want to preserve the truncating
    // behavior of WINDOW::QueryText.

    UINT cch = (cbBufSize/sizeof(TCHAR)) - 1;

    ::strncpyf( pszBuffer, _nlsOriginalStr.QueryPch() , cch );
    pszBuffer[cch] = TCH('\0');

    if (_nlsOriginalStr.strlen() > (cbBufSize - 1)) // truncated? check bytes
        return ERROR_MORE_DATA;
    else
        return NERR_Success;
}

APIERR BASE_ELLIPSIS::QueryText( NLS_STR * pnls ) const
{
    if (pnls == NULL)
        return ERROR_INVALID_PARAMETER;

    if ( !_nlsOriginalStr )
        return _nlsOriginalStr.QueryError();

    return pnls->CopyFrom( _nlsOriginalStr );
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::QueryTextLength

    SYNOPSIS:   Returns the length of the text in the control.

    RETURNS:    The length, in actual characters (as opposed to the
                byte-characters of strlen), of the window text.

    NOTE:       The length returned is that of the *original text*,
                not the mangled version displayed.

    HISTORY:
        terryk      27-Mar-1991     Created
        beng        12-Jun-1991     Changed return type
        beng        30-Apr-1992     Fix Unicode bug

**********************************************************************/

INT BASE_ELLIPSIS::QueryTextLength() const
{
    if ( !_nlsOriginalStr )
        return 0;

    return _nlsOriginalStr.QueryTextLength();
}

/*******************************************************************

    NAME:       BASE_ELLIPSIS::QueryTextSize

    SYNOPSIS:   Returns the byte count of the text,
                including the terminating character

    RETURNS:    Count of bytes

    NOTES:      The count returned is that sufficient to duplicate
                the original text.

    HISTORY:
        beng        12-Jun-1991     Created
        beng        30-Apr-1992     Fix Unicode bug

********************************************************************/

INT BASE_ELLIPSIS::QueryTextSize() const
{
    if ( !_nlsOriginalStr )
        return 0;

    return _nlsOriginalStr.QueryTextSize();
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetStyle

    SYNOPSIS:   set the display style

    ENTRY:      ELLIPSIS_STYLE flStyle - the display style.
                It will be any one of the following 5 styles:
                   ELLIPSIS_NONE
                   ELLIPSIS_LEFT
                   ELLIPSIS_CENTER
                   ELLIPSIS_RIGHT
                   ELLIPSIS_PATH

    EXIT:       set the internal style

    NOTES:

    HISTORY:
        terryk      27-Mar-1991 creation

**********************************************************************/

VOID BASE_ELLIPSIS::SetStyle( const ELLIPSIS_STYLE nStyle )
{
    UIASSERT( IsValidStyle( nStyle ));

    _nStyle = nStyle;
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::QueryOriginalStr()

    SYNOPSIS:   return the original string.

    RETURN:

    HISTORY:
        congpay      05-Apr-1993 creation

**********************************************************************/

NLS_STR BASE_ELLIPSIS::QueryOriginalStr() const
{
    return _nlsOriginalStr;
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetOriginalStr()

    SYNOPSIS:

    RETURN:

    HISTORY:
        congpay      05-Apr-1993 creation

**********************************************************************/

APIERR BASE_ELLIPSIS::SetOriginalStr(const TCHAR * psz)
{
    return (_nlsOriginalStr.CopyFrom(psz));
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::QueryStyle

    SYNOPSIS:   return the current style for display method

    RETURN:     the style of display method

    HISTORY:
        terryk      27-Mar-1991 creation

**********************************************************************/

ELLIPSIS_STYLE  BASE_ELLIPSIS::QueryStyle() const
{
    return _nStyle;
}

/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetEllipsisRight

    SYNOPSIS:   Add the ellipsis text string in the right hand side
                of the given string and delete a character one by one
                until the string can fit into the given window rectangle.

    ENTRY:

    EXIT:       Fix the pnls, so it fits into the rectangle box.

    HISTORY:
        terryk      8-Apr-1991  creation
        terryk      16-Apr-1991 add the Ellipsis text first before
                                delete any character
        beng        18-Sep-1991 Changed return type; refined error handling
        beng        30-Apr-1992 Fixed some signed vs. unsigned

**********************************************************************/

APIERR BASE_ELLIPSIS::SetEllipsisRight( NLS_STR * pnls )
{
    if (!*pnls)
        return pnls->QueryError();

    pnls->strcat( *::pnlsEllipsisText );
    if (!*pnls)
        return pnls->QueryError();

    // Guess the minimal number of characters to be deleted
    INT dxStringSize = QueryStrLen ( *pnls ) ;
    INT dxRectSize = QueryLimit () ;

    UINT cchNumChar = pnls->QueryNumChar();
    UINT cchGuess = (dxRectSize >= dxStringSize)
                   ? 0
                   : (dxStringSize - dxRectSize) / QueryMaxCharWidth();
    if (cchGuess > cchNumChar)
        cchGuess = cchNumChar;

    UINT cchEllipsisText = ::pnlsEllipsisText->QueryNumChar();

    // set the deleted substring start and end position
    ISTR istrSubStrStart( *pnls );
    ISTR istrSubStrEnd( *pnls );

    istrSubStrStart += cchNumChar - cchEllipsisText - cchGuess;
    istrSubStrEnd += cchNumChar - cchEllipsisText;

    pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
    if (!*pnls)
        return pnls->QueryError();

    cchNumChar = pnls->QueryNumChar();

    // decrease a character from the end of the string
    // until the string fit into the rectangle

    while (( QueryStrLen( *pnls )) > dxRectSize )
    {
        // Check window size for proper ellipsis
        ASSERT((cchNumChar - cchEllipsisText - 1) > 0);

        if ( ( cchNumChar - cchEllipsisText - 1 ) <= 0 )
            break;

        istrSubStrStart.Reset();
        istrSubStrStart += cchNumChar - cchEllipsisText - 1;

        istrSubStrEnd.Reset();
        istrSubStrEnd += cchNumChar - cchEllipsisText ;

        pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
        if (!*pnls)
            return pnls->QueryError();

        cchNumChar--;

        ASSERT( cchNumChar > 0 );
    }

    return pnls->QueryError();
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetEllipsisLeft

    SYNOPSIS:   Add the ellipsis text string in the left hand side
                of the given string and delete a character one by one
                until the string can fit into the given window rectangle.

    ENTRY:      pnls       - the original string

    EXIT:       Fix the string, so it fix into the rectangle

    HISTORY:
        terryk      8-Apr-1991  creation
        beng        18-Sep-1991 Changed return type; refined error handling
        beng        30-Apr-1992 Fixed some signed vs. unsigned

**********************************************************************/

APIERR BASE_ELLIPSIS::SetEllipsisLeft (NLS_STR * pnls)
{
    if (!*pnls)
        return pnls->QueryError();

    ISTR istrSubStrStart( *pnls );

    // Insert the Ellipsis Text String
    pnls->InsertStr( *::pnlsEllipsisText, istrSubStrStart );
    if (!*pnls)
        return pnls->QueryError();

    // Guess the minimal number of characters to be deleted
    INT dxStringSize = QueryStrLen( *pnls );
    INT dxRectSize = QueryLimit();

    UINT cchNumChar = pnls->QueryNumChar();
    UINT cchGuess = (dxRectSize >= dxStringSize)
                   ? 0
                   : (dxStringSize - dxRectSize) / QueryMaxCharWidth();
    if (cchGuess > cchNumChar)
        cchGuess = cchNumChar;

    UINT cchEllipsisText = ::pnlsEllipsisText->QueryNumChar();

    istrSubStrStart.Reset();
    istrSubStrStart += cchEllipsisText ;

    ISTR istrSubStrEnd ( *pnls );

    istrSubStrEnd += cchEllipsisText + cchGuess ;

    // delete the minimal number of character within the string in order
    // to fit the reset of the string in the window
    pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
    if (!*pnls)
        return pnls->QueryError();

    // keep delete the first character of the string until the string
    // fits into the rectangle

    while ( QueryStrLen( *pnls ) > dxRectSize )
    {
        // Check window size for proper ellipsis
        ASSERT( pnls->QueryNumChar() > 0 );

        if ( pnls->QueryNumChar() == 0 )
            break;

        istrSubStrStart.Reset();
        istrSubStrStart += cchEllipsisText;

        istrSubStrEnd.Reset();
        istrSubStrEnd += cchEllipsisText + 1;

        pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
        if (!*pnls)
            return pnls->QueryError();
    }

    return pnls->QueryError();
}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetEllipsisPath

    SYNOPSIS:   Add the ellipsis text string in the left hand side
                of the given string and delete a character one by one
                until the string can fit into the given window rectangle.
                We will treate the string as a Path and try to keep some
                important imformation within the string, i.e. the header
                of the string, "c:", "\\", "c:\"...

    ENTRY:      pnls       - the original string

    EXIT:       Modified the string, so it fits into the rectangle

    HISTORY:
        terryk      8-Apr-1991  creation
        beng        18-Sep-1991 Changed return type; refined error handling
        beng        30-Apr-1992 Fixed some signed vs. unsigned

**********************************************************************/

APIERR BASE_ELLIPSIS::SetEllipsisPath ( NLS_STR * pnls )
{
    if (!*pnls)
        return pnls->QueryError();

    ULONG ulPathType;

    APIERR err = ::I_MNetPathType( NULL, pnls->QueryPch(), &ulPathType, 0 ) ;


    if ( err != NERR_Success )
    {
        // if it is not a valid path, leave it alone and don't modify it.
        return err;
    }

    UINT cchHeaderSize = 0;

    // find the header part of the string and advance the substring's
    // starting position

    switch( ulPathType )
    {
    case ITYPE_UNC:
    case ITYPE_UNC_WC:
    case ITYPE_UNC_SYS_SEM:
    case ITYPE_UNC_SYS_SHMEM:
    case ITYPE_UNC_SYS_MSLOT:
    case ITYPE_UNC_SYS_PIPE:
    case ITYPE_UNC_COMPNAME:        // \\computername\....
    case ITYPE_PATH_RELD:           // c:foo\bar
    case ITYPE_PATH_RELD_WC:        // c:foo\bar\*.h
        // keep the first 2 characters
        cchHeaderSize += 2;
        break;

    case ITYPE_PATH_ABSND:          // \foo\bar
    case ITYPE_PATH_ABSND_WC:       // \foo\bar\*.c
    case ITYPE_PATH_SYS_MSLOT:      // \mailslot\foo
    case ITYPE_PATH_SYS_SEM:        // \sem\bar
    case ITYPE_PATH_SYS_PIPE:       // \pipe\smokers
    case ITYPE_PATH_SYS_SHMEM:      // \sharemem\mine
    case ITYPE_PATH_SYS_COMM:       // \comm\unist\plot
    case ITYPE_PATH_SYS_PRINT:      // \print\it\all\now
        // keep the first character
        cchHeaderSize ++;
        break;

    case ITYPE_PATH_ABSD:               // c:\foo\bar
    case ITYPE_PATH_ABSD_WC:        // c:\foo\george.*
        // keep the first 3 characters
        cchHeaderSize += 3;
        break;

    case ITYPE_PATH_RELND:          // foo\bar
    case ITYPE_PATH_RELND_WC:       // foo\?.?
    case ITYPE_DEVICE_DISK:         // d:
    case ITYPE_DEVICE_LPT:          // lpt1:
    case ITYPE_DEVICE_COM:          // com9
    default:
        // don't keep any header character
        break;
    }

    // guess the minimal number of characters to be deleted
    INT dxStringSize = QueryStrLen( *pnls );
    INT dxRectSize = QueryLimit();
    UINT cchNumChar = pnls->QueryNumChar();
    INT dxBloat = dxStringSize + QueryStrLen( *::pnlsEllipsisText );
    UINT cchGuess = (dxRectSize >= dxBloat)
                    ? 0
                    : (dxBloat - dxRectSize) / QueryMaxCharWidth();
    if (cchGuess > cchNumChar)
        cchGuess = cchNumChar;

    UINT cchEllipsisText = ::pnlsEllipsisText->QueryNumChar();

    ISTR istrSubStrStart( *pnls );
    ISTR istrSubStrEnd( *pnls );

    istrSubStrStart += cchHeaderSize ;
    istrSubStrEnd += cchHeaderSize + cchGuess ;

    // keep track of the last deleted character
    ISTR istrLastDelChar( *pnls );
    istrLastDelChar += cchHeaderSize + cchGuess - 1;

    WCHAR chLastDelChar = pnls->QueryChar( istrLastDelChar );

    // replace the minimal number of characters to be deleted with the
    // Ellipsis Text

    pnls->ReplSubStr( *::pnlsEllipsisText, istrSubStrStart, istrSubStrEnd );
    if (!*pnls)
        return pnls->QueryError();

    // Delete a character one at a time and stop when we can fit the string
    // within the window or we cannot del anymore character

    while( QueryStrLen( *pnls ) > dxRectSize )
    {
        // Check window size for proper ellipsis
        ASSERT( pnls->QueryNumChar() > ( cchEllipsisText + cchHeaderSize ) );

        if ( pnls->QueryNumChar() <= ( cchEllipsisText + cchHeaderSize ))
            break;

        istrSubStrStart.Reset();
        istrSubStrStart += cchEllipsisText + cchHeaderSize ;

        istrSubStrEnd = istrSubStrStart;
        ++istrSubStrEnd;

        // keep track of the last deleted character
        chLastDelChar = pnls->QueryChar( istrSubStrStart );

        pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
        if (!*pnls)
            return pnls->QueryError();
    }

    // move back one position and check whether the current position
    // is the beginning of a directory name or a '\'

    istrSubStrStart.Reset();
    istrSubStrStart += cchHeaderSize + cchEllipsisText ;

    if ( chLastDelChar != TCH('\\') )
    {
        // if we cut somewhere within a directory name, delete everything
        // until we see the next '\'
        // for example c:\....\abcdef\xyz
        // if we are on '\' or 'a' position, we have no problem
        // if we hit either 'b' 'c' 'd' 'e' 'f', we need to delete all the
        // characters up to but not include the next '\'
        // the result string will be c:\...\xyz

        istrSubStrEnd.Reset();

        if ( pnls->strchr( &istrSubStrEnd, TCH('\\'), istrSubStrStart ))
            pnls->DelSubStr( istrSubStrStart, istrSubStrEnd );
    }

    return pnls->QueryError();

}


/**********************************************************************

    NAME:       BASE_ELLIPSIS::SetEllipsisCenter

    SYNOPSIS:   Add the ellipsis text string in the center
                of the given string and delete a character one by one
                until the string can fit into the given window rectangle.

    ENTRY:      pnls       - the original string

    EXIT:       fix the string so it fit into the rectangle

    HISTORY:
        terryk      08-Apr-1991 creation
        terryk      18-Jul-1991 fix the cchGuess out of range bug.
        beng        18-Sep-1991 Changed return type; refined error handling
        beng        30-Apr-1992 Fixed some signed vs. unsigned

**********************************************************************/

APIERR BASE_ELLIPSIS::SetEllipsisCenter( NLS_STR * pnls )
{
    if (!*pnls)
        return pnls->QueryError();

    // divide the given string into 2 parts
    UINT cchNumLogicalChar = pnls->QueryNumChar();
    UINT ichCenter = cchNumLogicalChar / 2;

    // get the minimal number of character to be deleted
    INT dxStringSize = QueryStrLen( *pnls );
    INT dxRectSize = QueryLimit();
    INT dxBloat = dxStringSize + QueryStrLen( *::pnlsEllipsisText );
    UINT cchGuess = (dxRectSize >= dxBloat)
                    ? 0
                    : (dxBloat - dxRectSize) / QueryMaxCharWidth();
    if (cchGuess > cchNumLogicalChar)
        cchGuess = cchNumLogicalChar;

    UINT cchEllipsisText = ::pnlsEllipsisText->QueryNumChar();

    // divide the guess number into 2 and reduce the size of the 2 part
    // given string.

    UINT cchFirstPart = ( cchNumLogicalChar - cchGuess ) / 2;
    UINT cchSecPart = cchNumLogicalChar - cchFirstPart;

    ISTR istrSubStrStart( *pnls );
    ISTR istrSubStrEnd( *pnls );

    istrSubStrStart += cchFirstPart;
    istrSubStrEnd += cchNumLogicalChar - cchSecPart;

    // replace the minimal number of characters with the EllipsisText

    pnls->ReplSubStr( *::pnlsEllipsisText, istrSubStrStart, istrSubStrEnd );
    if (!*pnls)
        return pnls->QueryError();

    cchNumLogicalChar = pnls->QueryNumChar();

    ISTR istrStrStart( *pnls );
    ISTR istrStrEnd( *pnls );
    ISTR istrTempPos ( *pnls );

    INT dxFirstPart;
    INT dxSecPart;

    while ( QueryStrLen( *pnls ) > dxRectSize )
    {
        ASSERT(cchNumLogicalChar > 0);

        if ( cchNumLogicalChar == 0 )
            break;

        // divide the string into 2 part, keep delete a character from the
        // end of the first string, or the beginning of the second string
        // until the modified string can fit into the rectangle

        // reset all the string iterators

        istrStrStart.Reset();

        istrStrEnd.Reset();
        istrStrEnd += cchNumLogicalChar;

        istrSubStrStart.Reset();
        istrSubStrStart += cchFirstPart;

        istrSubStrEnd.Reset();
        istrSubStrEnd += cchNumLogicalChar - cchSecPart - 1;


        // determine which part of the string should we deleted

        dxFirstPart = QueryStrLen( pnls->QueryPch(),
                                         istrSubStrStart - istrStrStart );
        dxSecPart = QueryStrLen( pnls->QueryPch(istrSubStrEnd),
                                       istrStrEnd - istrSubStrEnd );

        if ( dxFirstPart > dxSecPart )
        {
            cchFirstPart--;
            ASSERT( cchFirstPart > 0 );

            istrSubStrStart.Reset();
            istrSubStrStart += cchFirstPart;
            istrTempPos = istrSubStrStart;
            ++istrTempPos;

            pnls->DelSubStr( istrSubStrStart, istrTempPos );
        }
        else
        {
            cchSecPart--;
            ASSERT( cchSecPart > 0 );

            istrTempPos.Reset();
            istrTempPos += cchNumLogicalChar - cchSecPart - 1;
            istrSubStrEnd = istrTempPos;
            ++istrSubStrEnd;

            pnls->DelSubStr( istrTempPos, istrSubStrEnd );
        }
        if (!*pnls)
            return pnls->QueryError();

        cchNumLogicalChar = pnls->QueryNumChar();
    }

    return pnls->QueryError();
}

/**********************************************************************

    NAME:       CONSOLE_ELLIPSIS::CONSOLE_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

CONSOLE_ELLIPSIS::CONSOLE_ELLIPSIS( ELLIPSIS_STYLE nStyle,
                                    INT            nLimit)
    :BASE_ELLIPSIS ( nStyle ),
     _nLimit(nLimit)
{
}

/**********************************************************************

    NAME:       CONSOLE_ELLIPSIS::QueryStrLen

    SYNOPSIS:

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

INT CONSOLE_ELLIPSIS::QueryStrLen( NLS_STR nlsStr)
{
    return (nlsStr.strlen());
}

INT CONSOLE_ELLIPSIS::QueryStrLen( const TCHAR * lpStr, INT nIstr)
{
    UNREFERENCED (lpStr);
    return (nIstr);
}
/**********************************************************************

    NAME:       CONSOLE_ELLIPSIS::QueryLimit

    SYNOPSIS:

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

CONSOLE_ELLIPSIS::QueryLimit()
{
    return (_nLimit);
}

/**********************************************************************

    NAME:       CONSOLE_ELLIPSIS::QueryMaxCharWidth()

    SYNOPSIS:

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

INT CONSOLE_ELLIPSIS::QueryMaxCharWidth( )
{
    return(1);
}

/**********************************************************************

    NAME:       CONSOLE_ELLIPSIS::SetSize

    SYNOPSIS:

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

void CONSOLE_ELLIPSIS::SetSize( INT nLimit)
{
    _nLimit = nLimit;
}

/**********************************************************************

    NAME:       WIN_ELLIPSIS::WIN_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:

    NOTES:

    HISTORY:
        congpay     06-Apr-1993 created.

**********************************************************************/

WIN_ELLIPSIS::WIN_ELLIPSIS( WINDOW * pwin, ELLIPSIS_STYLE nStyle)
    :BASE_ELLIPSIS (nStyle),
    _dc(pwin)
{
    if (QueryError())
        return;

    pwin->QueryClientRect(&_rect);
}

WIN_ELLIPSIS::WIN_ELLIPSIS (WINDOW * pwin, HDC hdc, const RECT * prect, ELLIPSIS_STYLE nStyle)
    :BASE_ELLIPSIS (nStyle),
     _dc (pwin, hdc)
{
    if (QueryError())
        return;

    _rect.right = prect->right;
    _rect.left = prect->left;
    _rect.bottom = prect->bottom;
    _rect.top = prect->top;
}


/**********************************************************************

    NAME:       WIN_ELLIPSIS::QueryLimit

    SYNOPSIS:

    ENTRY:

    NOTES:

    HISTORY:
        congpay      07-Apr-1993 created

**********************************************************************/

INT WIN_ELLIPSIS::QueryLimit()
{
    return ( _rect.right - _rect.left );
}

/**********************************************************************

    NAME:       WIN_ELLIPSIS::QueryMaxCharWidth

    ENTRY:

    EXIT:

    HISTORY:
        congpay     07-Apr-1993  creation

**********************************************************************/

INT WIN_ELLIPSIS::QueryMaxCharWidth( )
{
    TEXTMETRIC textmetric;

    _dc.QueryTextMetrics( & textmetric );
    ASSERT(textmetric.tmMaxCharWidth  != 0 );

    return (textmetric.tmMaxCharWidth);
}

/**********************************************************************

    NAME:       WIN_ELLIPSIS::QueryStrLen

    ENTRY:

    EXIT:

    HISTORY:
        congpay     07-Apr-1993  creation

**********************************************************************/

INT WIN_ELLIPSIS::QueryStrLen( NLS_STR nlsStr )
{
    return (_dc.QueryTextWidth( nlsStr ));
}

INT WIN_ELLIPSIS::QueryStrLen (const TCHAR * lpStr, INT nIstr)
{
    return(_dc.QueryTextWidth (lpStr, nIstr));
}

/*******************************************************************

    NAME:      WIN_ELLIPSIS::SetSize

    SYNOPSIS:  Sets the width and height of a window

    ENTRY:     dxWidth, dyHeight - width and height to set window to

    NOTES:

    HISTORY:
        congpay   10-Apr-1993       Created

********************************************************************/

VOID WIN_ELLIPSIS::SetSize( INT dxWidth, INT dyHeight )
{
    _rect.right = _rect.left + dxWidth;
    _rect.bottom = _rect.top + dyHeight;
}


/**********************************************************************

    NAME:       SLT_ELLIPSIS::SLT_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:

    NOTES:

    HISTORY:
        congpay     08-Apr-1993 created.

**********************************************************************/

SLT_ELLIPSIS::SLT_ELLIPSIS( OWNER_WINDOW * powin, CID cid, ELLIPSIS_STYLE nStyle)
    :SLT (powin, cid),
     WIN_ELLIPSIS (this, nStyle)
{
}

SLT_ELLIPSIS::SLT_ELLIPSIS( OWNER_WINDOW * powin, CID cid,
                            XYPOINT xy, XYDIMENSION  dxy,
                            ULONG flStyle, const TCHAR * pszClassName,
                            ELLIPSIS_STYLE nStyle)
    :SLT (powin, cid, xy, dxy, flStyle, pszClassName),
     WIN_ELLIPSIS (this, nStyle)
{
}

/**********************************************************************

    NAME:       SLT_ELLIPSIS::QueryText

    SYNOPSIS:   Returns the original non-ellipsis text of the control.

    ENTRY:
       pszBuffer    A pointer to a buffer, where the text
                    will be copied.

       cbBufSize    The size of this buffer.  The window text
                    copied to the buffer will be truncated if
                    the buffer is not big enough (including the
                    trailing NUL), in which case the function will
                    return ERROR_MORE_DATA.
         or

       pnls         A pointer to a NLS_STR to hold the results

    EXIT:       If psz+cb, psz buffer now contains the text.
                If pnls, the string has endured assignment.

    RETURNS:    0 if successful,
                ERROR_MORE_DATA if had to truncate string to fit in
                    user-supplied buffer.
                Otherwise, some error code.

    HISTORY:
        congpay      13-Apr-1993     Created

**********************************************************************/

APIERR SLT_ELLIPSIS::QueryText( TCHAR * pszBuffer, UINT cbBufSize ) const
{
    return WIN_ELLIPSIS::QueryText (pszBuffer, cbBufSize);
}

APIERR SLT_ELLIPSIS::QueryText( NLS_STR * pnls ) const
{
    return WIN_ELLIPSIS::QueryText(pnls);
}

/**********************************************************************

    NAME:       SLT_ELLIPSIS::SetText

    SYNOPSIS:   Sets the text contents of a control.
                It will also put an ellipsis text within the string
                if the string is too long.

    ENTRY:
         psz             A pointer to the text
        or
         nls             NLS text string

    RETURN:  error code from the converting routine.

    NOTES:
        NLS text string can be a NULL string

    HISTORY:
        terryk      27-Mar-1991 Created
        beng        18-Sep-1991 Refined error reporting
        beng        04-Oct-1991 Win32 conversion
        beng        30-Apr-1992 Use NLS_STR::CopyFrom

**********************************************************************/

APIERR SLT_ELLIPSIS::SetText( const TCHAR * psz )
{
    APIERR err = SetOriginalStr (psz);
    if (err != NERR_Success)
        return err;

    return ConvertAndSetStr();
}

APIERR SLT_ELLIPSIS::SetText (const NLS_STR & nls)
{
    if (!nls)
        return nls.QueryError();

    return SetText(nls.QueryPch());
}

/**********************************************************************

    NAME:       SLT_ELLIPSIS::ClearText

    SYNOPSIS:   Clears the window text of the window.

    NOTE:       This redefinition is necessary because this class
                also redefines SetText, *which is not virtual*.

    HISTORY:
        terryk      27-Mar-1991     Created

**********************************************************************/

VOID SLT_ELLIPSIS::ClearText()
{
    SetText( NULL );
}

/**********************************************************************

    NAME:       SLT_ELLIPSIS::ConvertAndSetStr

    SYNOPSIS:   set the ellipsis text and set the window text

    NOTES:      set the window text at the end of the procedure.

    HISTORY:
        terryk      2-Apr-1991  creation
        beng        18-Sep-1991 Changed return type

**********************************************************************/

APIERR SLT_ELLIPSIS::ConvertAndSetStr()
{
    NLS_STR nlsTempStr = QueryOriginalStr();

    APIERR err = nlsTempStr.QueryError();

    if ( err == NERR_Success )
    {
        if ( BASE_ELLIPSIS::QueryStyle() != ELLIPSIS_NONE )
            err = SetEllipsis( &nlsTempStr );

        if (err == NERR_Success )
        {
            // set the temporary string as a window text

            SLT::SetText( nlsTempStr );
        }
    }

    return err;
}

/*******************************************************************

    NAME:      SLT_ELLIPSIS::SetSize

    SYNOPSIS:  Sets the width and height of a window

    ENTRY:     dxWidth, dyHeight - width and height to set window to

    NOTES:     resize the window and reset the display string

    HISTORY:
        terryk      27-Mar-91       Created

********************************************************************/

VOID SLT_ELLIPSIS::SetSize( INT dxWidth, INT dyHeight, BOOL fRepaint )
{
    // Always set repaint to FALSE, because ConvertAndSetStr will
    // change the string anyway

    UNREFERENCED(fRepaint);

    WIN_ELLIPSIS::SetSize( dxWidth, dyHeight );

    SLT::SetSize (dxWidth, dyHeight, FALSE);

    ConvertAndSetStr();
}

/**********************************************************************

    NAME:       SLT_ELLIPSIS::ResetStyle

    SYNOPSIS:   reset the display style

    ENTRY:      ELLIPSIS_STYLE flStyle - the display style.
                It will be any one of the following 5 styles:
                   SLTP_ELLIPSIS_NONE
                   SLTP_ELLIPSIS_LEFT
                   SLTP_ELLIPSIS_CENTER
                   SLTP_ELLIPSIS_RIGHT
                   SLTP_ELLIPSIS_PATH

    EXIT:       reset the internal style.

    NOTES:      It will also update the window text

    HISTORY:
        terryk      27-Mar-1991 creation

**********************************************************************/

VOID SLT_ELLIPSIS::ResetStyle( const ELLIPSIS_STYLE nStyle )
{
    UIASSERT( IsValidStyle( nStyle ));

    if ( BASE_ELLIPSIS::QueryStyle() != nStyle )
    {
        BASE_ELLIPSIS::SetStyle(nStyle);
        ConvertAndSetStr();
    }
}

/**********************************************************************

    NAME:       STR_DTE_ELLIPSIS::STR_DTE_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:

    NOTES:

    HISTORY:
        congpay     08-Apr-1993 created.

**********************************************************************/

STR_DTE_ELLIPSIS::STR_DTE_ELLIPSIS(const TCHAR * pch, LISTBOX * plb, ELLIPSIS_STYLE nStyle)
    :STR_DTE(pch),
    _plb(plb),
    _nStyle(nStyle)
{
}

/**********************************************************************

    NAME:       STR_DTE_ELLIPSIS::STR_DTE_ELLIPSIS

    SYNOPSIS:   constructor

    ENTRY:

    NOTES:

    HISTORY:
        congpay     08-Apr-1993 created.

**********************************************************************/

VOID STR_DTE_ELLIPSIS::Paint (HDC hdc, const RECT * prect) const
{
    if (QueryPch() == NULL)
        return;

    WIN_ELLIPSIS winellipsis ((WINDOW *) _plb, hdc, prect, _nStyle);

    if (winellipsis.QueryError() != NERR_Success)
        return;

    NLS_STR nlsTemp(QueryPch());

    ASSERT (nlsTemp.QueryError() == NERR_Success);

    winellipsis.SetEllipsis (&nlsTemp);

    DEVICE_CONTEXT dc(hdc);

    UINT cyHeight = prect->bottom - prect->top + 1;

    INT dyCentering = ((INT) cyHeight - dc.QueryFontHeight()) / 2;

    BOOL fSuccess = dc.TextOut (nlsTemp.QueryPch(),
                                ::strlenf(nlsTemp.QueryPch()),
                                prect->left,
                                prect->top + dyCentering,
                                prect);

#if defined(DEBUG)
    if (!fSuccess)
    {
        APIERR err = BLT::MapLastError (ERROR_GEN_FAILURE);
        DBGOUT ("BLT: TexeOut in LB failed, err = " << err);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\focuschk.cxx ===
/**********************************************************************/
/**           Microsoft Windows NT                                   **/
/**        Copyright(c) Microsoft Corp., 1991                        **/
/**********************************************************************/

/*
    focuschk.cxx

    This file contains the implementation for the focus checkboxes.

    FILE HISTORY:
        Johnl   06-Sep-1991 Created

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       FOCUS_CHECKBOX::FOCUS_CHECKBOX

    SYNOPSIS:   Constructor for FOCUS_CHECKBOX control

    ENTRY:      Same as CHECKBOX

    NOTES:      The focus box is placed one unit outside the checkbox

    HISTORY:
        Johnl   12-Sep-1991 Created

********************************************************************/

FOCUS_CHECKBOX::FOCUS_CHECKBOX( OWNER_WINDOW * powin, CID cidCheckBox )
        : CHECKBOX( powin, cidCheckBox ),
          CUSTOM_CONTROL( this ),
          _fHasFocus( FALSE )
{
    if ( QueryError() != NERR_Success )
        return ;

    /* We have to convert the rectangle's position since we are drawing in
     * the owner window's cooridinates.
     */
    QueryWindowRect( &_rectFocusBox ) ;
    ::ScreenToClient( QueryOwnerHwnd(), &( ((LPPOINT)&_rectFocusBox)[0] )) ;
    ::ScreenToClient( QueryOwnerHwnd(), &( ((LPPOINT)&_rectFocusBox)[1] )) ;

    /* Expand the rectangle by just a little
     */
    _rectFocusBox.top-- ;
    _rectFocusBox.left-- ;
    #if (defined(_MIPS_)) || (defined(_PPC_))
        _rectFocusBox.right++ ;
    #else
        _rectFocusBox.right += 4;
    #endif
    _rectFocusBox.bottom++ ;
}


/*******************************************************************

    NAME:       FOCUS_CHECKBOX::OnFocus

    SYNOPSIS:   Draws the focus rect and saves our state

    NOTES:      Note we are drawing on the owner window and not in
                the checkbox

    HISTORY:
        Johnl   12-Aug-1991 Created

********************************************************************/


BOOL FOCUS_CHECKBOX::OnFocus( const FOCUS_EVENT & focusevent )
{
    DISPLAY_CONTEXT dc( QueryOwnerHwnd() ) ;
    DrawFocusRect( &dc, &_rectFocusBox ) ;

    _fHasFocus = TRUE ;
    return DISPATCHER::OnFocus( focusevent ) ;
}

/*******************************************************************

    NAME:       FOCUS_CHECKBOX::OnDefocus

    SYNOPSIS:   Clears the focus box

    NOTES:

    HISTORY:
        Johnl   12-Aug-1991 Created

********************************************************************/

BOOL FOCUS_CHECKBOX::OnDefocus( const FOCUS_EVENT & focusevent )
{
    DISPLAY_CONTEXT dc( QueryOwnerHwnd() ) ;
    EraseFocusRect( &dc, &_rectFocusBox ) ;

    _fHasFocus = FALSE ;
    return DISPATCHER::OnDefocus( focusevent ) ;
}

/*******************************************************************

    NAME:       FOCUS_CHECKBOX::OnPaintReq

    SYNOPSIS:   If we have the focus, then draw the focus rectangle

    NOTES:

    HISTORY:
        Johnl   12-Aug-1991 Created

********************************************************************/

BOOL FOCUS_CHECKBOX::OnPaintReq( void )
{
    if ( _fHasFocus )
    {
        /* Note: This is not a PAINT_DISPLAY_CONTEXT because we need to let the
         * code that draws the checkbox validate the window (if we validate it,
         * then no one else can draw to it using the BeginPaint/EndPaint sequence).
         */
        DISPLAY_CONTEXT dc( QueryOwnerHwnd() ) ;

        DrawFocusRect( &dc, &_rectFocusBox ) ;
    }

    return DISPATCHER::OnPaintReq() ;
}

/*******************************************************************

    NAME:       FOCUS_CHECKBOX::DrawFocusRect

    SYNOPSIS:   Draws/erases the rectangle that indicates this checkbox
                has the focus.

    ENTRY:      pdc - Pointer to the device context to draw/clear the focus box
                lpRect - Cooridinates the focus box resides
                fErase - FALSE for drawing the focus box, TRUE for erasing
                         the focus box.

    NOTES:      We erase the focus box with COLOR_WINDOW color

    HISTORY:
        Johnl   12-Sep-1991 Created

********************************************************************/

void FOCUS_CHECKBOX::DrawFocusRect( DEVICE_CONTEXT * pdc, LPRECT lpRect, BOOL fErase )
{
    /* We always erase the focus box before redrawing it since we never know
     * if only half of the focus box is there (which is a problem since it
     * is an XOR operation).
     *
     * JonN 9/29/95 In WINVER40 we use COLOR_3DFACE not COLOR_WINDOW.
     */
    DWORD rgbFocusBoxColor = ::GetSysColor( COLOR_3DFACE ) ;

    HBRUSH hbrushFocusBoxColor = ::CreateSolidBrush( rgbFocusBoxColor ) ;
    HBRUSH hbrushOld = pdc->SelectBrush( hbrushFocusBoxColor ) ;

    if ( hbrushOld != NULL )
    {
        pdc->FrameRect( lpRect, hbrushFocusBoxColor ) ;

        pdc->SelectBrush( hbrushOld ) ;
        REQUIRE( ::DeleteObject( (HGDIOBJ)hbrushFocusBoxColor) ) ;
    }

    if ( !fErase )
    {
        pdc->DrawFocusRect( lpRect ) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\findacct.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    FindUser.cxx

    This file contains the implementation for the Find Account
    subdialog of the User Browser dialog.

    FILE HISTORY:
        JonN        01-Dec-1992 Created

    CODEWORK Single selection is not yet implemented (filed as Pr4 bug)
*/

#include "pchapplb.hxx"   // Precompiled header

#include "findacct.hxx"


DECLARE_SLIST_OF(OS_SID) ;

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI_PB::BROWSER_DOMAIN_LBI_PB

    HISTORY:
        JonN    01-Dec-1992     Created

********************************************************************/

BROWSER_DOMAIN_LBI_PB::BROWSER_DOMAIN_LBI_PB( BROWSER_DOMAIN_LBI * pbdlbi )
    : LBI(),
      _pbdlbi( pbdlbi )
{
    ASSERT( pbdlbi != NULL && pbdlbi->QueryError() == NERR_Success );
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI_PB::~BROWSER_DOMAIN_LBI_PB

    SYNOPSIS:	Does not delete _pbdlbi member

    HISTORY:
        JonN    01-Dec-1992     Created

********************************************************************/

BROWSER_DOMAIN_LBI_PB::~BROWSER_DOMAIN_LBI_PB()
{
    // nothing
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI_PB::Paint

    SYNOPSIS:   Typical LBI Paint method

    NOTES:

    HISTORY:
        JonN    01-Dec-1992     Created

********************************************************************/

VOID BROWSER_DOMAIN_LBI_PB::Paint(
                    LISTBOX * plb,
                    HDC hdc,
                    const RECT * prect,
                    GUILTT_INFO * pGUILTT ) const
{
    _pbdlbi->W_Paint( ((BROWSER_DOMAIN_LB *)plb)->_pbdcb, plb, hdc, prect, pGUILTT );
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI_PB::Compare

    SYNOPSIS:   Typical LBI compare for user browser listbox

    NOTES:      This method will sort all user sid types to the end of
                the list

    HISTORY:
        JonN    01-Dec-1992     Created

********************************************************************/

INT BROWSER_DOMAIN_LBI_PB::Compare( const LBI * plbi ) const
{
    return _pbdlbi->Compare( ((BROWSER_DOMAIN_LBI_PB *)plbi)->_pbdlbi );
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI_PB::QueryLeadingChar

    SYNOPSIS:   Typical QueryLeadingChar method

    HISTORY:
        JonN    01-Dec-1992     Created

********************************************************************/

WCHAR BROWSER_DOMAIN_LBI_PB::QueryLeadingChar( void ) const
{
    return _pbdlbi->QueryLeadingChar();
}


/*************************************************************************

    NAME:	BROWSER_DOMAIN_LB::BROWSER_DOMAIN_LB

    SYNOPSIS:   This listbox piggybacks off a BROWSER_DOMAIN_CB

    INTERFACE:

    PARENT:	BLT_LISTBOX

    CAVEATS:

    NOTES:

    HISTORY:
        JonN    01-Dec-1992     Created

**************************************************************************/

BROWSER_DOMAIN_LB::BROWSER_DOMAIN_LB( OWNER_WINDOW * powin,
				      CID cid,
                                      BROWSER_DOMAIN_CB * pbdcb )
    : BLT_LISTBOX	( powin, cid ),
      _pbdcb( pbdcb )
{
    ASSERT( pbdcb != NULL && pbdcb->QueryError() == NERR_Success );

    if ( QueryError() )
        return ;

    APIERR err = NERR_Success ;

    INT cItems = pbdcb->QueryCount();

    for ( INT i = 0; i < cItems; i++ )
    {
        BROWSER_DOMAIN_LBI_PB * pbdlbipb = new BROWSER_DOMAIN_LBI_PB(
                           (BROWSER_DOMAIN_LBI *)(pbdcb->QueryItem(i)) );

        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   (pbdlbipb == NULL)
            || (err = pbdlbipb->QueryError() != NERR_Success)
           )
        {
            delete pbdlbipb;
            ReportError( err );
            return;
        }

        if ( AddItem( pbdlbipb ) < 0 )
        {
            ReportError( ERROR_NOT_ENOUGH_MEMORY );
            return;
        }
    }

}

BROWSER_DOMAIN_LB::~BROWSER_DOMAIN_LB()
{
    /* Nothing to do */
}



/*************************************************************************

    NAME:	NT_FIND_ACCOUNT_DIALOG::NT_FIND_ACCOUNT_DIALOG

    SYNOPSIS:   This dialog searches for users with some username

    PARENT:	DIALOG_WINDOW

    CAVEATS:

    NOTES:      Use the Flags parameter to pass USRBROWS_SHOW_ALIASES,
                USRBROWS_SHOW_GROUPS and/or USRBROWS_SHOW_USERS.

    HISTORY:
        JonN    03-Dec-1992     Created

**************************************************************************/

NT_FIND_ACCOUNT_DIALOG::NT_FIND_ACCOUNT_DIALOG(
                            HWND                     hwndOwner,
                            NT_USER_BROWSER_DIALOG * pdlgUserBrowser,
                            BROWSER_DOMAIN_CB *      pcbDomains,
                            const TCHAR *            pchTarget,
                            ULONG                    ulFlags )
    : DIALOG_WINDOW     ( (pdlgUserBrowser->IsSingleSelection())
                             ? MAKEINTRESOURCE(IDD_BROWS_FIND_ACCOUNT_1SEL)
                             : MAKEINTRESOURCE(IDD_BROWS_FIND_ACCOUNT),
                          hwndOwner ),
      _pdlgUserBrowser  ( pdlgUserBrowser ),
      _pchTarget        ( pchTarget ),
      _padminauthTarget ( NULL ),
      _ulFlags          ( ulFlags ),
      _buttonOK         ( this, IDOK ),
      _buttonSearch     ( this, USR_PB_SEARCH ),
      _sleAccountName   ( this, USR_SLE_ACCTNAME, GNLEN ),
                                        // maximum user or groupname length
                                        // max( LM20_UNLEN, LM20_GNLEN, GNLEN );
      _lbDomains        ( this, USR_LB_SEARCH, pcbDomains ),
      _lbAccounts       ( this, LB_ACCOUNTS ),
      _pmgrpSearchWhere ( NULL )
{

    if ( QueryError() != NERR_Success )
    {
        return;
    }

    ASSERT(   _pdlgUserBrowser != NULL
           && _pdlgUserBrowser->QueryError() == NERR_Success
          );

    _pmgrpSearchWhere = new MAGIC_GROUP( this, USR_RB_SEARCHALL, 2 );
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   _pmgrpSearchWhere == NULL
        || (err = _pmgrpSearchWhere->QueryError()) != NERR_Success
        || (_pmgrpSearchWhere->SetSelection( USR_RB_SEARCHALL ), FALSE)
        || (err = _pmgrpSearchWhere->AddAssociation(
                        USR_RB_SEARCHONLY, &_lbDomains)) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    UpdateButtonState();

}

NT_FIND_ACCOUNT_DIALOG::~NT_FIND_ACCOUNT_DIALOG()
{
    delete _pmgrpSearchWhere;
    delete _padminauthTarget;
}


/*******************************************************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::OnCommand

    SYNOPSIS:   Typical OnCommand for this dialog, we catch pressing
                the Search button and changing the selection in the
                listbox

    EXIT:

    RETURNS:

    NOTES:	The Members button is enabled any time the text in the
                SLE is non-empty.

    HISTORY:
        JonN    03-Dec-1992     Created
        JonN    17-Mar-1993     Fix focus handling
********************************************************************/

BOOL NT_FIND_ACCOUNT_DIALOG::OnCommand( const CONTROL_EVENT & event )
{
    APIERR err = NERR_Success ;

    switch ( event.QueryCid() )
    {
    case USR_PB_SEARCH:
        // We select the account name and return focus to that field
        // in anticipation of a possible error.  DoSearch() will move
        // focus elsewhere if necessary.
        _sleAccountName.SelectString();
        _sleAccountName.ClaimFocus();
        err = DoSearch();
        UpdateButtonState() ; // notification of select/deselect
        break;

    case USR_SLE_ACCTNAME:
        if ( event.QueryCode() == EN_CHANGE )
            UpdateButtonState() ;

        break;

    case LB_ACCOUNTS:
	switch ( event.QueryCode() )
	{
	case LBN_DBLCLK:
            return OnOK() ; // no need to redefine this virtual here
	}
        UpdateButtonState() ; // notification of select/deselect
        break;

    case USR_LB_SEARCH: // selection change, notified via LBS_NOTIFY
    case USR_RB_SEARCHALL:
    case USR_RB_SEARCHONLY:

        UpdateButtonState() ;
	break ;

    default:
        return DIALOG_WINDOW::OnCommand( event ) ;
    }

    if (err != NERR_Success)
        ::MsgPopup( this, err );

    return TRUE ;
}


/*******************************************************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::OnOK

    SYNOPSIS:   When the user presses OK, we make sure that no invalid
                listbox items were selected.

    EXIT:

    RETURNS:

    HISTORY:
        JonN    16-May-1994     Created
********************************************************************/

BOOL NT_FIND_ACCOUNT_DIALOG::OnOK()
{
    APIERR err = NERR_Success ;
    INT cSel = _lbAccounts.QuerySelCount();
    BUFFER buffSelection( cSel * sizeof(INT) );
    INT * pSel = NULL;
    INT i = 0;
    USER_BROWSER_LBI * plbi = NULL;

    if ( (err = buffSelection.QueryError()) != NERR_Success )
        goto cleanup;
    pSel = (INT *) buffSelection.QueryPtr();
    if ( (err = _lbAccounts.QuerySelItems( pSel, cSel )) != NERR_Success )
        goto cleanup;
    for ( i = cSel - 1; i >= 0; i-- )
    {
        plbi = _lbAccounts.QueryItem( pSel[i] );
        ASSERT( plbi != NULL );
        if ( (err = ACCOUNT_NAMES_MLE::CheckNameType(
                        plbi->QueryType(), _ulFlags )) != NERR_Success )
        {
            // don't bother changing selection
            break;
        }
    }

cleanup:

    if (err != NERR_Success)
        ::MsgPopup( this,
                    err,
                    MPSEV_ERROR,
                    MP_OK,
                    (plbi != NULL) ? plbi->QueryDisplayName() : NULL );
    else
        Dismiss( TRUE );



    return TRUE ;
}


/*******************************************************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::UpdateButtonState

    SYNOPSIS:   Changes the state of the Search button

    EXIT:

    RETURNS:

    NOTES:	The Search button is enabled any time a username is entered
                and either the "Search All" radio button is selected, or
                the "Search Only In" rdio button is selected and at least
                one domain is selected in the domains listbox.

    HISTORY:
        JonN    04-Nov-1992     Created
********************************************************************/
void NT_FIND_ACCOUNT_DIALOG::UpdateButtonState( void )
{
    BOOL fEnableSearch = (   (_sleAccountName.QueryTextLength() > 0)
                          && (   (_pmgrpSearchWhere->QuerySelection() == USR_RB_SEARCHALL)
                              || (_lbDomains.QuerySelCount() > 0)
                             )
                         );
    BOOL fEnableOK = (_lbAccounts.QuerySelCount() > 0);
    BOOL fDefaultOK = fEnableOK && _lbAccounts.HasFocus();

    _buttonSearch.Enable( fEnableSearch );
    _buttonOK.Enable( fEnableOK );

    if ( !fDefaultOK )
        _buttonSearch.MakeDefault();
    else
        _buttonOK.MakeDefault();
        // Note that this button can be both default and disabled
}


/*******************************************************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::DoSearch

    SYNOPSIS:   Handles "Search" button keypress

    RETURNS:    As OnCommand()

    NOTES:      DoSearch() assumes that, on entry, the account name
                is selected and its field has focus.  It will move
                selection and/or focus as necessary.

    HISTORY:
        JonN    03-Dec-1992     Created
        JonN    17-Mar-1993     Fix focus handling
********************************************************************/
APIERR NT_FIND_ACCOUNT_DIALOG::DoSearch( void )
{
    APIERR err = NERR_Success;

    //
    // determine name to search for
    //

    NLS_STR nlsAccountName;
    if (   (err = nlsAccountName.QueryError()) != NERR_Success
        || (err = _sleAccountName.QueryText( &nlsAccountName )) != NERR_Success
       )
    {
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " loading account name" );
        return err;
    }

    //
    // It is possible that the Search button is both diabled and default.
    // If so, then the user might have pressed ENTER while the edit field
    // was empty.  In this case we just pretend the DoSearch() never happened.
    //

    if ( nlsAccountName.strlen() == 0 )
        return NERR_Success;


    AUTO_CURSOR autocur;


    BOOL fSearchAll = ( _pmgrpSearchWhere->QuerySelection() == USR_RB_SEARCHALL );


    //
    // get ADMIN_AUTHORITY if we don't already have one
    //

    if (_padminauthTarget == NULL)
    {
        _padminauthTarget = new ADMIN_AUTHORITY( _pchTarget ); // default auth
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _padminauthTarget == NULL
            || _padminauthTarget->QueryError() != NERR_Success
           )
        {
            DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " loading ADMIN_AUTHORITY" );
            delete _padminauthTarget;
            _padminauthTarget = NULL;
            return err;
        }
    }


    //
    // Determine selection in domains listbox
    //

    INT cDomainCount = _lbDomains.QueryCount();
    INT cDomainSelCount = _lbDomains.QuerySelCount();
    INT cActiveDomains = (fSearchAll) ? cDomainCount : cDomainSelCount;

    BUFFER bufDomainSelItems( cDomainSelCount * sizeof(INT) );

    // We leave one extra space in the bufSearchnames array for WinNt
    // machines.  If we search on one of these, we will need two names,
    // "<machine>\<name>" and "BUILTIN\<name>".
    BUFFER bufSearchNames( (cActiveDomains+1) * sizeof(TCHAR *));

    INT * aiDomainSelItems = NULL;

    if (   (err = bufDomainSelItems.QueryError()) != NERR_Success
        || (err = bufSearchNames.QueryError()) != NERR_Success
        || (aiDomainSelItems = (INT *)bufDomainSelItems.QueryPtr(), FALSE)
                                // comma notation means this is always FALSE
        || (err = _lbDomains.QuerySelItems( aiDomainSelItems,
                                            cDomainSelCount )) != NERR_Success
       )
    {
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " loading selection" );
        return err;
    }

    const TCHAR * * apchSearchNames = (const TCHAR * *) bufSearchNames.QueryPtr();

    //
    // build array and STRLIST of qualified names
    //

    STRLIST strlstSearchNames;


    INT iNumNewNames = 0;
    for ( INT cSearchDom = 0; cSearchDom < cActiveDomains; cSearchDom++ )
    {
        INT iDomain = (fSearchAll) ? cSearchDom : aiDomainSelItems[cSearchDom];
        ASSERT( iDomain >= 0 && iDomain < cDomainCount );

        BROWSER_DOMAIN_LBI_PB * pbdlbipb = (BROWSER_DOMAIN_LBI_PB *)
                                                _lbDomains.QueryItem(iDomain);
        ASSERT( pbdlbipb != NULL && pbdlbipb->QueryError() == NERR_Success );

        NLS_STR * pnlsNewName = new NLS_STR();
        NLS_STR nlsQualifiedDomainName;
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   pnlsNewName == NULL
            || (err = pnlsNewName->QueryError()) != NERR_Success
            || (err = nlsQualifiedDomainName.QueryError()) != NERR_Success
            || (err = pbdlbipb->GetQualifiedDomainName(
                                   &nlsQualifiedDomainName )) != NERR_Success
            || (err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                pnlsNewName,
                                nlsAccountName,
                                nlsQualifiedDomainName )) != NERR_Success
            || (err = strlstSearchNames.Append( pnlsNewName )) != NERR_Success
           )
        {
            DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " building search names" );
            delete pnlsNewName;
            return err;
        }
        ASSERT( iNumNewNames < cActiveDomains+1 ); // only one target domain
        apchSearchNames[iNumNewNames++] = pnlsNewName->QueryPch();
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: searching for " << *pnlsNewName );

        // add BUILTIN domain if target domain selected
        //
        if ( pbdlbipb->IsTargetDomain() )
        {
            OS_SID ossidBuiltIn;
            PSID psidBuiltIn;
            LSA_TRANSLATED_NAME_MEM lsatnm;
            LSA_REF_DOMAIN_MEM lsardm;
            LONG iDomainIndex;
            pnlsNewName = new NLS_STR();
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   pnlsNewName == NULL
                || (err = pnlsNewName->QueryError()) != NERR_Success
                || (err = nlsQualifiedDomainName.QueryError()) != NERR_Success
                || (err = ossidBuiltIn.QueryError()) != NERR_Success
                || (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                UI_SID_BuiltIn,
                                &ossidBuiltIn )) != NERR_Success
                || (psidBuiltIn = ossidBuiltIn.QueryPSID(), FALSE)
                || (err = _padminauthTarget->QueryLSAPolicy()->TranslateSidsToNames(
                                                &psidBuiltIn,
                                                1,
                                                &lsatnm,
                                                &lsardm )) != NERR_Success
                // CODEWORK what error code?
                || (err = (((iDomainIndex = lsatnm.QueryDomainIndex(0)) >= 0)
                        ? NERR_Success : NERR_InternalError )) != NERR_Success
                || (err = lsardm.QueryName( iDomainIndex, &nlsQualifiedDomainName))
                                != NERR_Success
                || (err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                    pnlsNewName,
                                    nlsAccountName,
                                    nlsQualifiedDomainName )) != NERR_Success
                || (err = strlstSearchNames.Append( pnlsNewName )) != NERR_Success
               )
            {
                DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " building BUILTIN search name" );
                delete pnlsNewName;
                return err;
            }
            ASSERT( iNumNewNames < cActiveDomains+1 ); // only one WinNt machine
            apchSearchNames[iNumNewNames++] = pnlsNewName->QueryPch();
            DBGEOL( "NT_FIND_ACCOUNT_DIALOG: searching for " << *pnlsNewName );
        }
    }

    //
    // Lookup the search names
    //

    LSA_TRANSLATED_SID_MEM lsatsm;
    LSA_REF_DOMAIN_MEM lsardm;
    LSA_POLICY * plsapolTarget = _padminauthTarget->QueryLSAPolicy();
    SAM_DOMAIN * psamdomTarget = _padminauthTarget->QueryAccountDomain();

    if (   (err = lsatsm.QueryError()) != NERR_Success
        || (err = lsardm.QueryError()) != NERR_Success
        || (err = _padminauthTarget->QueryLSAPolicy()->TranslateNamesToSids(
                        apchSearchNames,
                        iNumNewNames,
                        &lsatsm,
                        &lsardm )) != NERR_Success
       )
    {
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " looking up names" );
        switch (err)
        {
        case STATUS_NONE_MAPPED:
        case NERR_GroupNotFound:
        case NERR_UserNotFound:

            // Display our own special error
            autocur.TurnOff();
            ::MsgPopup( QueryHwnd(),
                        IDS_APPLIB_NO_MATCHES,
                        MPSEV_WARNING,
                        1,
                        nlsAccountName.QueryPch() );

            // we have already displayed the error
            return NERR_Success;

        default:
            break;
        }

        return err;
    }


    //
    // Get list of SIDs for all found items
    //

    // reuse existing buffer of search names
    // we will not necessarily fill this buffer
    SLIST_OF( OS_SID ) slistOSSID;
    PSID * apsidLocate = (PSID *)bufSearchNames.QueryPtr();
    INT cFound = 0;
    BOOL fSomeSidIsCopy = FALSE;

    for ( INT cFoundSubject = 0; err == NERR_Success && cFoundSubject < (INT)lsatsm.QueryCount(); cFoundSubject++ )
    {
        switch ( lsatsm.QueryUse( cFoundSubject ) )
        {
        case SidTypeUser:
        case SidTypeGroup:
        case SidTypeAlias:
        case SidTypeWellKnownGroup: // CODEWORK allow this?
            {
                ULONG ulRID = lsatsm.QueryRID( cFoundSubject );
                ASSERT( ulRID != 0L );

                LONG iDomainIndex = lsatsm.QueryDomainIndex( cFoundSubject );
                ASSERT( iDomainIndex >= 0 && (ULONG)iDomainIndex < lsardm.QueryCount() );

                PSID psidDomain = lsardm.QueryPSID( iDomainIndex );
                ASSERT( psidDomain != NULL );

                OS_SID * possidFound = new OS_SID( psidDomain, ulRID );
                err = ERROR_NOT_ENOUGH_MEMORY;
                if (   possidFound == NULL
                    || (err = possidFound->QueryError()) != NERR_Success
                   )
                {
                    delete possidFound;
                    break;
                }

                // If this is already in the list, don't add a duplicate
                INT cublbi = _lbAccounts.QueryCount();
                BOOL fThisSidIsCopy = FALSE;
                for ( INT ilbi = 0; ilbi < cublbi; ilbi++ )
                {
                    USER_BROWSER_LBI * publbi = _lbAccounts.QueryItem( ilbi );
                    ASSERT( publbi != NULL );
                    if ( (*possidFound) == (*(publbi->QueryOSSID())) )
                    {
                        fThisSidIsCopy = TRUE;
                        break;
                    }
                }
                if ( fThisSidIsCopy )
                {
                    delete possidFound;
                    fSomeSidIsCopy = TRUE;
                    break;
                }

                if ( (err = slistOSSID.Add( possidFound )) != NERR_Success )
                    break;

                apsidLocate[ cFound++ ] = possidFound->QueryPSID();
            }
            break;

        case SidTypeDomain:
        case SidTypeDeletedAccount:
        case SidTypeInvalid:
        case SidTypeUnknown:
        default:
            // item not found, or invalid type
            break;
        }
    }

    if ( err != NERR_Success )
    {
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " building SIDs" );
        return err;
    }

    if ( cFound == 0 )
    {
        if ( fSomeSidIsCopy )
        {
             DBGEOL( "NT_FIND_ACCOUNT_DIALOG: all matches already listed" );
        }
        else
        {
             DBGEOL( "NT_FIND_ACCOUNT_DIALOG: no valid matches found" );

             // Display our own special error
             autocur.TurnOff();
             ::MsgPopup( QueryHwnd(),
                         IDS_APPLIB_NO_MATCHES,
                         MPSEV_WARNING,
                         1,
                         nlsAccountName.QueryPch() );
        }

        // we have already displayed the error
        return NERR_Success;
    }


    //
    // Add found items to the search listbox
    //
    // pass psamdomTarget==NULL so that all names are qualified
    //

    err = _lbAccounts.Fill( apsidLocate,
                            cFound,
                            NULL,
                            plsapolTarget,
                            _pchTarget );
    if ( err != NERR_Success )
    {
        DBGEOL( "NT_FIND_ACCOUNT_DIALOG: error " << err << " filling listbox with SIDs" );
        return err;
    }

    if (_lbAccounts.QuerySelCount() == 0)
    {
        ASSERT( _lbAccounts.QueryCount() > 0 );
        if (_lbAccounts.QueryCount() > 0)
            _lbAccounts.SelectItem( 0 );
    }
    _lbAccounts.ClaimFocus();

    return err;

}


/***************************************