exist
                    // so if this setting is found in domain table, it must come from domain
                    //
                    bSettingExist = TRUE;
                }

                // if the setting doesn't come from domain, no need to query undo value
                if ( !bSettingExist ) continue;

                //
                // now we need to query the tattoo value for this privilege
                //
                RtlInitUnicodeString( &UserRight, (PCWSTR)(SCE_Privileges[i].Name));

                //
                // now enumerate all accounts for this user right.
                //

                NtStatus = LsaEnumerateAccountsWithUserRight(
                                    PolicyHandle,
                                    &UserRight,
                                    (PVOID *)&EnumBuffer,   // account SIDs
                                    &CountReturned
                                    );

                if ( NtStatus == STATUS_NO_MORE_ENTRIES ||
                     NtStatus == STATUS_NO_SUCH_PRIVILEGE ||
                     NtStatus == STATUS_NOT_FOUND ||
                     NT_SUCCESS(NtStatus) ) {

                    rc = ERROR_SUCCESS;

                } else {

                    rc = RtlNtStatusToDosError(NtStatus);
                }

                pNameList = NULL;

                //
                // if fail to get the account list
                // save NULL as the tattoo value
                //
                if ( NT_SUCCESS(NtStatus) && CountReturned > 0 ) {

                    //
                    // add the SIDs
                    //

                    for ( j=0; j<CountReturned; j++ ) {
                        //
                        // build each account into the name list
                        // Convert using the Rtl functions
                        //
                        rc2 = ScepAddSidStringToNameList(&pNameList, EnumBuffer[j].Sid);

                        if ( NO_ERROR != rc2 ) {
                            rc = rc2;
                        }
                    }
                }

                LsaFreeMemory( EnumBuffer );
                EnumBuffer = NULL;

                //
                // log an error
                //
                if ( ERROR_SUCCESS != rc ) {

                    saveRc = ScepDosErrorToSceStatus(rc);
                    ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_QUERY, rc, SCE_Privileges[i].Name);

                } else {
                    //
                    // now save the name list to the tattoo table
                    //

                    rc = ScepWriteNameListValue(
                            PolicyHandle,
                            hSectionTattoo,
                            SCE_Privileges[i].Name,
                            pNameList,
                            SCE_WRITE_EMPTY_LIST,
                            4
                            );
                    if ( rc != SCESTATUS_SUCCESS ) {
                        saveRc = rc;
                        ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_SETTING, ScepSceStatusToDosError(rc), SCE_Privileges[i].Name);
                    } else {
                        ScepLogOutput3(3, 0, SCESRV_POLICY_TATTOO_CHECK, SCE_Privileges[i].Name);
                    }
                }

                if ( pNameList != NULL ) {
                    ScepFreeNameList( pNameList );
                    pNameList = NULL;
                }

            }
        }
    }

    if ( hSectionDomain ) SceJetCloseSection(&hSectionDomain, TRUE);
    if ( hSectionTattoo ) SceJetCloseSection(&hSectionTattoo, TRUE);

    return(saveRc);
}

BOOL
ScepAccountHandledByNetJoin(
    IN PSID AliasSid,
    IN PSID MemberSid,
    OUT BOOL *pfAliasHandled)
/* ++
Routine Description:

    Checks if the current member for the specified alias is handled by net join. Net
    join currently handles the following groups:

    - in Administrators: Domain Admins
    - in Users: Domain Users

Arguments:

    AliasSid    - group's SID

    MemberSid   - group's member SID

    fAliasHandled - optimization variable, the function is called in a loop, we can
                    avoid calling it again if alias is not handled by net join

Return value:

    TRUE    - if account is modified by net join
    FALSE   - if account not modified or error occured
-- */
{
    NTSTATUS NtStatus;
    BOOL fRet = FALSE;
    PSID pSidAdmins = NULL;
    PSID pSidUsers = NULL;
    PSID pSidDomAdmins = NULL;
    PSID pSidDomUsers = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo=NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO  PrimaryDomainInfo=NULL;

    *pfAliasHandled = FALSE;

    if (ERROR_SUCCESS == ScepGetBuiltinSid(DOMAIN_ALIAS_RID_ADMINS, &pSidAdmins) &&
        ERROR_SUCCESS == ScepGetBuiltinSid(DOMAIN_ALIAS_RID_USERS, &pSidUsers))
    {
        //
        // check if group SID is one of the accounts net join changes, otherwise 
        // there's no need to further process it
        //
        if (EqualSid(AliasSid, pSidAdmins) ||
            EqualSid(AliasSid, pSidUsers))
        {
            *pfAliasHandled = TRUE;

            NtStatus = ScepGetLsaDomainInfo(
                        &AccountDomainInfo,
                        &PrimaryDomainInfo
                        );

            if(NT_SUCCESS(NtStatus) &&
               NT_SUCCESS(ScepDomainIdToSid(PrimaryDomainInfo->Sid, DOMAIN_GROUP_RID_ADMINS, &pSidDomAdmins)) &&
               NT_SUCCESS(ScepDomainIdToSid(PrimaryDomainInfo->Sid, DOMAIN_GROUP_RID_USERS, &pSidDomUsers)))
            {
                //
                // check if the member group is changed by net join
                //
                if(EqualSid(AliasSid, pSidAdmins) && EqualSid(MemberSid,pSidDomAdmins) ||
                   EqualSid(AliasSid, pSidUsers)  && EqualSid(MemberSid,pSidDomUsers))
                {
                    fRet = TRUE;
                }
            }
        }
    }

    if(pSidAdmins) {
        ScepFree(pSidAdmins);
    }
    if(pSidUsers) {
        ScepFree(pSidUsers);
    }
    if(pSidDomAdmins) {
        ScepFree(pSidDomAdmins);
    }
    if(pSidDomUsers) {
        ScepFree(pSidDomUsers);
    }
    if(AccountDomainInfo != NULL) {
        LsaFreeMemory(AccountDomainInfo);
    }
    if(PrimaryDomainInfo != NULL) {
        LsaFreeMemory(PrimaryDomainInfo);
    }

    return fRet;
}

DWORD
ScepTattooCurrentGroupMembers(
    IN PSID             ThisDomainSid,
    IN PSID             GrpSid OPTIONAL,
    IN SID_NAME_USE     GrpUse,
    IN PULONG           MemberRids OPTIONAL,
    IN PSID             *MemberAliasSids OPTIONAL,
    IN DWORD            MemberCount,
    OUT PSCE_NAME_LIST  *ppNameList
    )
/* ++
Routine Description:

    This routine builds the current group membership into a name list (in SID string
    format).

Arguments:

    ThisDomainSid - The domain SID

    GrpUse   - The "type" of the group

    MemberRids - the member RIDs (for SidTypeGroup)

    MemberAliasSids - the member SIDs (for SidTypeAlias)

    MemberCount - number of members

    ppNameList - the output name list

Return value:

    WIN32 errors
-- */
{
    NTSTATUS                NtStatus=ERROR_SUCCESS;
    DWORD                   j;
    DWORD                   saveRc=ERROR_SUCCESS;
    DWORD                   rc;

    if ( ppNameList == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *ppNameList = NULL;

    switch ( GrpUse ) {
    case SidTypeGroup:
        //
        // member IDs are passed in as Rids
        // DomainHandle must point to a account domain because builtin domain
        // won't have SidTypeGroup account
        //
        if ( ThisDomainSid == NULL )
            saveRc = ERROR_INVALID_PARAMETER;

        else if ( MemberRids ) {

            PSID AccountSid=NULL;

            for (j=0; j<MemberCount; j++) {

                NtStatus = ScepDomainIdToSid(
                                ThisDomainSid,
                                MemberRids[j],
                                &AccountSid
                                );

                rc = RtlNtStatusToDosError(NtStatus);
                if ( NT_SUCCESS(NtStatus) ) {

                    rc = ScepAddSidStringToNameList(ppNameList, AccountSid);

                    ScepFree(AccountSid);
                    AccountSid = NULL;
                }

                if ( ERROR_SUCCESS != rc ) saveRc = rc;
            }
        }
        break;

    case SidTypeAlias:
        //
        // members are passed in as SIDs
        // add them to the output list directly
        //
        if ( MemberAliasSids ) {

            BOOL fAliasHandled = TRUE;  // optimization variable, set to FALSE by ScepAccountHandledByNetJoin
                                        // if group is not handled by net join so we avoid calling
                                        // ScepAccountHandledByNetJoin unnecessarily

            for ( j=0; j<MemberCount; j++ ) {
                if ( MemberAliasSids[j] != NULL ) {
                    //
                    // add member to the list
                    //

                    // 
                    // Some builtin groups are modified by net join. To avoid undoing net join's changes,
                    // we'll save those domain specific accounts handled by net join only as relative SIDs.
                    // Upon restore from tattoo table, we'll rebuild the full SID based on the current 
                    // domain (e.g. so we don't restore old domain Domain Admin, but current one)
                    //

                    if (fAliasHandled && 
                        ScepAccountHandledByNetJoin(
                            GrpSid, 
                            MemberAliasSids[j],
                            &fAliasHandled)) {
                        rc = ScepAddRelativeSidToNameList(ppNameList, MemberAliasSids[j]);
                    } else {
                        rc = ScepAddSidStringToNameList(ppNameList, MemberAliasSids[j]);
                    }

                    if ( ERROR_SUCCESS != rc ) saveRc = rc;
                }
            }
        }

        break;

    default:
        saveRc = ERROR_INVALID_PARAMETER;
        break;
    }


    return(saveRc);
}

SCESTATUS
ScepCheckNetworkLogonRights(
    IN LSA_HANDLE PolicyHandle,
    IN OUT DWORD *pLowMask,
    IN OUT DWORD *pHighMask,
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppPrivilegeAssigned
    )
/*
Description:

    This function is to make sure that Authenticated Users already have
    "Network Logon Right" and Authenticated Users & Everyone must not
    have "Deny network logon right".

    If the network logon right or deny network logon right are not defined
    in the privilege mask, no change is made since the user rights are not
    defined in the configuration.

    If Authenticated Users or Everyone is not defined in the privilege list,
    this function will add them in (hard coded). The output of this function
    ppPrivilegeAssigned may contain new added nodes for the hard coded accounts.

*/
{
    INT i;
    INT idxAllow = -1;
    INT idxDeny = -1;
    INT idxLocal = -1;
    INT idxDenyLocal = -1;

    DWORD PrivHighMask = *pHighMask;
    DWORD PrivLowMask = *pLowMask;

    //
    // check first if Network logon right is defined
    //
    i = ScepLookupPrivByName(SE_NETWORK_LOGON_NAME);
    if ( i != -1 ) {
        if ( SCEP_CHECK_PRIV_BIT(i,PrivLowMask,PrivHighMask) ) {
            //
            // network logon right is defined
            //
            idxAllow = i;
        }
    }

    //
    // check if Deny Network logon right is defined
    //

    i = ScepLookupPrivByName(SE_DENY_NETWORK_LOGON_NAME);
    if ( i != -1 ) {

        if ( SCEP_CHECK_PRIV_BIT(i,PrivLowMask,PrivHighMask) ) {
            //
            // deny network logon right is defined
            //
            idxDeny = i;

        }
    }

    //
    // check if logon locally right is defined
    //

    i = ScepLookupPrivByName(SE_INTERACTIVE_LOGON_NAME);
    if ( i != -1 ) {

        if ( SCEP_CHECK_PRIV_BIT(i,PrivLowMask,PrivHighMask) ) {
            //
            // logon locally right is defined
            //
            idxLocal = i;
        }
    }

    //
    // check if deny logon locally right is defined
    //

    i = ScepLookupPrivByName(SE_DENY_INTERACTIVE_LOGON_NAME);
    if ( i != -1 ) {

        if ( SCEP_CHECK_PRIV_BIT(i,PrivLowMask,PrivHighMask) ) {
            //
            // deny logon locally right is defined
            //
            idxDenyLocal = i;
        }
    }

    if ( idxAllow == -1 && idxDeny == -1 && idxLocal == -1 && idxDenyLocal == -1 ) {

        //
        // none of them is defined so do not enforce anything
        //

        return(SCESTATUS_SUCCESS);
    }

    //
    // build well known SIDs for the enforcement
    //

    SID EveryoneSid;
    SID AuthSid;
    SID ControllerSid;
    PSID AdminUserSid=NULL;

    SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;


    //
    // initialize Administrators group sid
    //

    if ( ! NT_SUCCESS ( RtlAllocateAndInitializeSid( &NtAuth,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0,0,0,0,0,0,
                                                     &AdminsSid
                                                   ) ) ) {
        ScepLogOutput3(0,ERROR_NOT_ENOUGH_MEMORY,
                       SCEDLL_ADMINISTRATORS_SID);

        //
        // failure to initialize this one SID will still continue to other SIDs
        //
    }

    //
    // initialize administrator SID
    //

    if ( idxDenyLocal != -1 ) {

        NTSTATUS Status;

        //
        // Query the account domain SID
        // failure to initialize this one SID will still continue to
        // enforce other SIDs
        //

        PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo=NULL;

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyAccountDomainInformation,
                                            (PVOID *)&PolicyAccountDomainInfo );


        if ( NT_SUCCESS(Status) && PolicyAccountDomainInfo &&
             PolicyAccountDomainInfo->DomainSid ) {

            Status = ScepDomainIdToSid(
                            PolicyAccountDomainInfo->DomainSid,
                            DOMAIN_USER_RID_ADMIN,
                            &AdminUserSid
                            );

        }

        if ( PolicyAccountDomainInfo ) {
            LsaFreeMemory( PolicyAccountDomainInfo );
        }

        if ( AdminUserSid == NULL ) {

            ScepLogOutput3(0, RtlNtStatusToDosError(Status),
                           SCEDLL_ADMINISTRATORS_SID);
        }
    }

    //
    // initialize well known SIDs
    //

    RtlInitializeSid ( &EveryoneSid, &WorldAuth, 1);
    *RtlSubAuthoritySid ( &EveryoneSid, 0 ) = SECURITY_WORLD_RID;

    RtlInitializeSid ( &AuthSid, &NtAuth, 1);
    *RtlSubAuthoritySid ( &AuthSid, 0 ) = SECURITY_AUTHENTICATED_USER_RID;

    RtlInitializeSid ( &ControllerSid, &NtAuth, 1);
    *RtlSubAuthoritySid ( &ControllerSid, 0 ) = SECURITY_ENTERPRISE_CONTROLLERS_RID;


    PSCE_PRIVILEGE_VALUE_LIST pTemp=*ppPrivilegeAssigned;
    PSCE_PRIVILEGE_VALUE_LIST pParent=NULL;

    BOOL bFindEveryone=FALSE;
    BOOL bFindAuthUsers=FALSE;
    BOOL bFindLocal=FALSE;
    BOOL bFindController=FALSE;
    BOOL bFindAdminUser=FALSE;

    //
    // loop through each one defined in the list to match the above SIDs
    //

    for ( ; pTemp != NULL; pParent=pTemp, pTemp=pTemp->Next) {

        if ( pTemp->Name == NULL ) continue;

        if ( (idxLocal != -1 || idxDenyLocal != -1) && !bFindLocal && AdminsSid &&
             ( bFindLocal = RtlEqualSid( (PSID)(pTemp->Name), AdminsSid) ) ) {

            //
            // make sure Administrators always have the interactive logon right
            //
            if ( idxLocal != -1 ) {

                if ( !SCEP_CHECK_PRIV_BIT(idxLocal,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_LOCAL_RIGHT, SE_INTERACTIVE_LOGON_NAME);
                    SCEP_ADD_PRIV_BIT(idxLocal, pTemp->PrivLowPart, pTemp->PrivHighPart)
                }
            }

            //
            // make sure administrators don't have deny interactive logon right
            //
            if ( idxDenyLocal != -1 ) {

                if ( SCEP_CHECK_PRIV_BIT(idxDenyLocal,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_DENY_LOCAL_RIGHT, SE_DENY_INTERACTIVE_LOGON_NAME);
                    SCEP_REMOVE_PRIV_BIT(idxDenyLocal, &(pTemp->PrivLowPart), &(pTemp->PrivHighPart))
                }
            }
        }

        if ( (idxDeny != -1 || idxDenyLocal != -1) &&
             ( !bFindAuthUsers && ( bFindAuthUsers = RtlEqualSid( (PSID)(pTemp->Name), &AuthSid )) ) ||
             ( !bFindEveryone && ( bFindEveryone = RtlEqualSid( (PSID)(pTemp->Name), &EveryoneSid )) ) )  {

            //
            // find Authenticated Users or Everyone
            // make sure they do not have the deny rights
            //

            if ( idxDenyLocal != -1 ) {

                //
                // remove the deny logon locally bit
                //

                if ( SCEP_CHECK_PRIV_BIT(idxDenyLocal,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_DENY_LOCAL_RIGHT, SE_DENY_INTERACTIVE_LOGON_NAME);
                    SCEP_REMOVE_PRIV_BIT(idxDenyLocal, &(pTemp->PrivLowPart), &(pTemp->PrivHighPart))
                }
            }

            if ( (idxDeny != -1) && (ProductType == NtProductLanManNt) ) {

                //
                // remove the deny network logon bit on domain controllers
                //

                if ( SCEP_CHECK_PRIV_BIT(idxDeny,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_DENY_NETWORK_RIGHT, SE_DENY_NETWORK_LOGON_NAME);
                    SCEP_REMOVE_PRIV_BIT(idxDeny, &(pTemp->PrivLowPart), &(pTemp->PrivHighPart))
                }
            }

        } else if ( !bFindController && (ProductType == NtProductLanManNt) &&
                    ( bFindController = RtlEqualSid( (PSID)(pTemp->Name), &ControllerSid )) )  {

            //
            // find domain controller SID
            // make sure it have network logon right and must not have deny network logon right
            //

            if ( idxDeny != -1 ) {

                //
                // remove the deny network logon bit
                //
                if ( SCEP_CHECK_PRIV_BIT(idxDeny,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_DENY_NETWORK_RIGHT, SE_DENY_NETWORK_LOGON_NAME);
                    SCEP_REMOVE_PRIV_BIT(idxDeny, &(pTemp->PrivLowPart), &(pTemp->PrivHighPart))
                }
            }

            if ( idxAllow != -1 ) {

                //
                // add the network logon bit
                //
                if ( !SCEP_CHECK_PRIV_BIT(idxAllow,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_NETWORK_RIGHT, SE_NETWORK_LOGON_NAME);
                    SCEP_ADD_PRIV_BIT(idxAllow, pTemp->PrivLowPart, pTemp->PrivHighPart)
                }
            }

        } else if ( idxDenyLocal != -1 && !bFindAdminUser && AdminUserSid &&
                    ( bFindAdminUser = RtlEqualSid( (PSID)(pTemp->Name), AdminUserSid) ) ) {

            //
            // make sure administrator account don't have the deny right
            //

            if ( SCEP_CHECK_PRIV_BIT(idxDenyLocal,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                ScepLogOutput3(0,0, SCESRV_ENFORCE_DENY_LOCAL_RIGHT, SE_DENY_INTERACTIVE_LOGON_NAME);
                SCEP_REMOVE_PRIV_BIT(idxDenyLocal, &(pTemp->PrivLowPart), &(pTemp->PrivHighPart))
            }

        }

        //
        // all enforcement is done, break the loop now
        //

        if ( (idxLocal == -1 || bFindLocal) &&
             ( (idxDeny == -1 && idxDenyLocal == -1) || (bFindAuthUsers && bFindEveryone) ) &&
             ( bFindController || (ProductType != NtProductLanManNt) ) &&
             (idxDenyLocal == -1 || bFindAdminUser) ) {
            break;
        }
    }


    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( idxLocal != -1 && !bFindLocal && AdminsSid ) {

        //
        // make sure administrators have "logon locally right"
        // add a new node the the end of the list
        //

        rc = ScepAddAccountRightToList(
                             ppPrivilegeAssigned,
                             &pParent,
                             idxLocal,
                             AdminsSid
                             );

        if ( rc == SCESTATUS_SUCCESS ) {
            ScepLogOutput3(0,0, SCESRV_ENFORCE_LOCAL_RIGHT, SE_INTERACTIVE_LOGON_NAME);
        } else {
            ScepLogOutput3(0,ERROR_NOT_ENOUGH_MEMORY, SCESRV_ERROR_ENFORCE_LOCAL_RIGHT, SE_INTERACTIVE_LOGON_NAME);
        }
    }

    //
    // if enterprise controllers is not found in the list
    // and it's on a DC, should add it
    //

    rc=SCESTATUS_SUCCESS;

    if ( idxAllow != -1 && !bFindController &&
         ( ProductType == NtProductLanManNt ) ) {

        //
        // make sure enterprise controllers have "network logon right"
        //

        rc = ScepAddAccountRightToList(
                             ppPrivilegeAssigned,
                             &pParent,
                             idxAllow,
                             &ControllerSid
                             );

        if ( rc == SCESTATUS_SUCCESS ) {
            ScepLogOutput3(0,0, SCESRV_ENFORCE_NETWORK_RIGHT, SE_NETWORK_LOGON_NAME);
        } else {
            ScepLogOutput3(0,ERROR_NOT_ENOUGH_MEMORY, SCESRV_ERROR_ENFORCE_NETWORK_RIGHT, SE_NETWORK_LOGON_NAME);
        }
    }

    //
    // free memory
    //

    if ( AdminsSid ) {
        RtlFreeSid( AdminsSid );
        AdminsSid = NULL;
    }

    if ( AdminUserSid ) {
        RtlFreeSid( AdminUserSid );
    }

    return(rc);

}

SCESTATUS
ScepAddAccountRightToList(
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppPrivilegeAssigned,
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppParent,
    IN INT idxRight,
    IN PSID AccountSid
    )
/*
Description:

    Create a new node linked to the end of the link list

    The new node contains the AccountSid for the specified user right "idxRight"

*/
{
    SCESTATUS rc=SCESTATUS_SUCCESS;

    PSCE_PRIVILEGE_VALUE_LIST pPriv = (PSCE_PRIVILEGE_VALUE_LIST)ScepAlloc( LMEM_ZEROINIT,
                                            sizeof(SCE_PRIVILEGE_VALUE_LIST));
    if ( pPriv != NULL ) {

        DWORD Length = RtlLengthSid ( AccountSid );

        //
        // allocate the sid buffer, note it's stored in the name field
        //

        pPriv->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, Length);

        if ( pPriv->Name != NULL ) {

            //
            // copy the SID in
            //

            RtlCopySid( Length, (PSID)(pPriv->Name), AccountSid );

            //
            // add the interactive logon right bit
            //

            SCEP_ADD_PRIV_BIT(idxRight, pPriv->PrivLowPart, pPriv->PrivHighPart)

            //
            // link to the list
            //

            if ( *ppParent != NULL )
                (*ppParent)->Next = pPriv;
            else
                *ppPrivilegeAssigned = pPriv;

            *ppParent = pPriv;

        } else {

            ScepFree(pPriv);
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }

    } else {

        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    return rc;
}


DWORD
ScepAddAceToSecurityDescriptor(
    IN  DWORD    AceType,
    IN  ACCESS_MASK AccessMask,
    IN  PSID  pSid,
    IN OUT  PSECURITY_DESCRIPTOR    pSDAbsolute,
    IN  PSECURITY_DESCRIPTOR    pSDSelfRelative,
    OUT PACL    *ppNewAcl
    )
/*
Routine Description:

    This routine adds an ACE to a Security Descriptor (at the head only).

    Two optimizations are attempted in adding the ACE.

Arguments:

    AceType         -   type of ACE to add

    AccessMask      -   access mask of ACE to set

    pSid            -   sid for ACE to add

    pSDAbsolute     -   absolute SD ptr to build. pSDAbsolute must be empty.
                        It's vacuous in the caller's stack hence no SD member
                        should be freed outside this routine.

    pSDSelfRelative -   self relative SD to get DACL information from

    ppNewAcl        -   ptr to the new DACL which needs to be freed outside

Return Value:

    Win32 error code
*/
{

    DWORD   rc = ERROR_SUCCESS;
    BOOL    bOrMaskInOldDacl = FALSE;

    if (ppNewAcl == NULL ||
        pSDAbsolute == NULL ||
        pSDSelfRelative == NULL ||
        (AceType != ACCESS_ALLOWED_ACE_TYPE && AceType != ACCESS_DENIED_ACE_TYPE )
        ) {

        return ERROR_INVALID_PARAMETER;
    }

    PACL        pNewAcl = *ppNewAcl = NULL;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     bAclPresent = FALSE;
    PACL        pOldAcl = NULL;
    BOOLEAN     bDaclDefaulted = FALSE;
    DWORD       dwNewAclSize = 0;
    DWORD       dwAceSize = 0;
    ACE_HEADER  *pFirstAce = NULL;
    DWORD       dwFirstAceSize = 0;

    NtStatus = RtlGetDaclSecurityDescriptor(
                                           pSDSelfRelative,
                                           &bAclPresent,
                                           &pOldAcl,
                                           &bDaclDefaulted);

    rc = RtlNtStatusToDosError( NtStatus );

    if ( rc != ERROR_SUCCESS )
        goto Cleanup;

    //
    // null DACL should never happen - CliffV
    // we shouldn't set the DACL with the one
    // anonymous ACE only since it will deny
    // all other SID's any access
    //

    if ( !bAclPresent ||
         pOldAcl == NULL ||
         pOldAcl->AceCount == 0 ) {

        rc = ERROR_INVALID_ACL;
        goto Cleanup;

    }

    NtStatus = RtlGetAce( pOldAcl,
                          0,
                          (PVOID *) &pFirstAce);

    rc = RtlNtStatusToDosError( NtStatus );

    if ( rc != ERROR_SUCCESS )
        goto Cleanup;

    //
    // if the first ACE is for the SID passed in attempt two optimizations
    //

    if ( RtlValidSid((PSID)&((PKNOWN_ACE)pFirstAce)->SidStart) &&
         RtlEqualSid((PSID)&((PKNOWN_ACE)pFirstAce)->SidStart, pSid)) {

        if (pFirstAce->AceType == AceType) {

            //
            // Optimization 1:
            // simply OR in the mask
            //

            ((PKNOWN_ACE)pFirstAce)->Mask |= AccessMask;

            bOrMaskInOldDacl = TRUE;

            goto SetDacl;
        }

        else if (((PKNOWN_ACE)pFirstAce)->Mask == AccessMask ) {

            //
            // Optimization 2:
            // if only AccessMask is turned on, later on
            // (a) prepare a new ACE
            // (b) copy the old ACL except the first ACE
            //

            //
            // remember the size of the first ACE since we need to skip it
            //

            dwFirstAceSize = (DWORD)(((PKNOWN_ACE)pFirstAce)->Header.AceSize);
        }
    }


    switch (AceType) {
    case ACCESS_ALLOWED_ACE_TYPE:
        dwAceSize = sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(pSid) - sizeof(ULONG);
        break;
    case ACCESS_DENIED_ACE_TYPE:
        dwAceSize = sizeof(ACCESS_DENIED_ACE) + RtlLengthSid(pSid) - sizeof(ULONG);
        break;
    default:
        break;
    }

    dwNewAclSize = dwAceSize + pOldAcl->AclSize - dwFirstAceSize;

    *ppNewAcl = pNewAcl = (PACL) LocalAlloc(LMEM_ZEROINIT, dwNewAclSize);

    if ( pNewAcl == NULL ) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // initialize the ACL
    //

    pNewAcl->AclSize = (USHORT) dwNewAclSize;
    pNewAcl->AclRevision = ACL_REVISION;
    pNewAcl->AceCount = 0;

    //
    // add allow/deny ACE to the head of the ACL
    //

    switch (AceType) {
    case ACCESS_ALLOWED_ACE_TYPE:

        if (  ! AddAccessAllowedAce(
                                   pNewAcl,
                                   ACL_REVISION,
                                   AccessMask,
                                   pSid
                                   ) ) {
            rc = GetLastError();

        }

        break;

    case ACCESS_DENIED_ACE_TYPE:

        if (  ! AddAccessDeniedAce(
                                   pNewAcl,
                                   ACL_REVISION,
                                   AccessMask,
                                   pSid
                                   ) ) {
            rc = GetLastError();

        }

        break;

    default:
        break;
    }

    if ( rc != ERROR_SUCCESS)
        goto Cleanup;

    //
    // copy all the ACEs in the old ACL after the newly added ACE
    // (potentially skipping the first ACE in the old ACL)
    //

    memcpy((PUCHAR)pNewAcl +  sizeof(ACL) + dwAceSize,
           (PUCHAR)pOldAcl + sizeof(ACL) + dwFirstAceSize,
           pOldAcl->AclSize - (sizeof(ACL) + dwFirstAceSize) );

    pNewAcl->AceCount += pOldAcl->AceCount;

    if ( dwFirstAceSize != 0 )
        --pNewAcl->AceCount;

SetDacl:

    //
    // either set the adjusted-ACE ACL, or the added-ACE ACL in the SD
    //

    if ( rc == ERROR_SUCCESS ) {

        NtStatus = RtlSetDaclSecurityDescriptor (
                                                pSDAbsolute,
                                                TRUE,
                                                ( bOrMaskInOldDacl ? pOldAcl : pNewAcl),
                                                FALSE
                                                );

        rc = RtlNtStatusToDosError(NtStatus);

    }

    if ( rc == ERROR_SUCCESS ) {

        if ( !IsValidSecurityDescriptor(pSDAbsolute) )

            rc = ERROR_INVALID_SECURITY_DESCR;

    }


Cleanup:

    if (rc != ERROR_SUCCESS) {
        if (pNewAcl)
            LocalFree(pNewAcl);
        *ppNewAcl = NULL;

    }

    return rc;
}

DWORD
ScepConfigureLSAPolicyObject(
    IN  DWORD   dwLSAAnonymousNameLookup,
    IN  DWORD   ConfigOptions,
    IN PSCE_ERROR_LOG_INFO *pErrLog OPTIONAL,
    OUT BOOL    *pbOldLSAPolicyDifferent
    )
/*
Routine Description:

    This routine *actually* configures the LSA policy security descriptor ONLY if required.

Arguments:

    dwLSAAnonymousNameLookup    -   the value of the desired setting

    ConfigOptions               -   configuration options

    pErrLog                     -   ptr to error log list

    pbOldLSAPolicyDifferent     -   ptr to boolean that says whether or not the
                                    existing setting is different from the desired setting
                                    this information is required for tattooing

Return Value:

    Win32 error code
*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DWORD       rc = ERROR_SUCCESS;
    PACL        pNewAcl = NULL;
    DWORD       dwAceType;
    BOOL        bAddAce = FALSE;
    PSECURITY_DESCRIPTOR    pSDCurrentLsaPolicyObject = NULL;
    SECURITY_DESCRIPTOR SDAbsoluteToBuildAndSet;

    if (pbOldLSAPolicyDifferent == NULL ||
        (dwLSAAnonymousNameLookup != 0 && dwLSAAnonymousNameLookup != 1))
        {

        return ERROR_INVALID_PARAMETER;

    }

    LSA_HANDLE  LsaHandle = NULL;

    if ( LsaPrivatePolicy == NULL ) {

        NtStatus = ScepOpenLsaPolicy(
                                    MAXIMUM_ALLOWED,
                                    &LsaHandle,
                                    TRUE
                                    );

        rc = RtlNtStatusToDosError( NtStatus );

    }

    else {

        LsaHandle = LsaPrivatePolicy;

    }

    if ( !NT_SUCCESS( NtStatus ) ) {

        if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

            ScepBuildErrorLogInfo(
                        rc,
                        pErrLog,
                        SCEDLL_LSA_POLICY
                        );
        } else {
            ScepLogOutput3(1, rc, SCEDLL_LSA_POLICY);
        }
    }

    if ( rc == ERROR_SUCCESS ) {

        NtStatus = LsaQuerySecurityObject(
                                         LsaHandle,
                                         OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                         &pSDCurrentLsaPolicyObject
                                         );

        rc = RtlNtStatusToDosError( NtStatus );

        if ( !NT_SUCCESS( NtStatus ) ) {

            if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                ScepBuildErrorLogInfo(
                            rc,
                            pErrLog,
                            SCEDLL_SCP_ERROR_LSAPOLICY_QUERY
                            );
            } else {
                ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_QUERY);
            }
        }

        if ( rc == ERROR_SUCCESS ) {

            LPTSTR pwszSDlsaPolicyObject = NULL;

            //
            // log the SDDL SD for diagnostics
            //

            if ( ConvertSecurityDescriptorToStringSecurityDescriptor(
                                                               pSDCurrentLsaPolicyObject,
                                                               SDDL_REVISION_1,
                                                               DACL_SECURITY_INFORMATION,
                                                               &pwszSDlsaPolicyObject,
                                                               NULL
                                                               ) ){

                ScepLogOutput3(1,0,SCEDLL_SCP_INFO_LSAPOLICY_EXISTING_SDDL, pwszSDlsaPolicyObject);

                LocalFree(pwszSDlsaPolicyObject);

            }

            //
            // use AUTHZ to check if desired access is existing access
            //

            if ( ghAuthzResourceManager ) {

                SID AnonymousSid;
                SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
                AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext = NULL;
                LUID    Identifier = {0};

                RtlInitializeSid ( &AnonymousSid, &NtAuth, 1);
                *RtlSubAuthoritySid ( &AnonymousSid, 0 ) = SECURITY_ANONYMOUS_LOGON_RID;

                if ( AuthzInitializeContextFromSid(0,
                                                  &AnonymousSid,
                                                  ghAuthzResourceManager,
                                                  0,
                                                  Identifier,
                                                  NULL,
                                                  &hAuthzClientContext) ) {

                    AUTHZ_ACCESS_REPLY AuthzReply;
                    AUTHZ_ACCESS_REQUEST AuthzRequest;
                    ACCESS_MASK GrantedAccessMask;
                    DWORD   AuthzError;

                    AuthzReply.ResultListLength = 1;
                    AuthzReply.GrantedAccessMask = &GrantedAccessMask;
                    AuthzReply.Error = &AuthzError;
                    AuthzReply.SaclEvaluationResults = NULL;

                    memset(&AuthzRequest, 0, sizeof(AuthzRequest));
                    AuthzRequest.DesiredAccess = POLICY_LOOKUP_NAMES;

                    DWORD   AceType = 0;

                    if ( AuthzAccessCheck(0,
                                         hAuthzClientContext,
                                         &AuthzRequest,
                                         NULL,
                                         pSDCurrentLsaPolicyObject,
                                         NULL,
                                         NULL,
                                         &AuthzReply,
                                         NULL) ) {

                        //
                        // check if existing access is different from desired access
                        // if so, add the appropriate ACE or manipulate existing ACEs
                        // to get the desired permissions
                        //

                        if ( GrantedAccessMask & POLICY_LOOKUP_NAMES ) {
                            //ASSERT(AuthzError == ERROR_SUCCESS);
                            if ( !dwLSAAnonymousNameLookup ) {

                                bAddAce = TRUE;
                                AceType = ACCESS_DENIED_ACE_TYPE;

                            }


                        } else {
                            //ASSERT(AuthzError == ERROR_ACCESS_DENIED || AuthzError == ERROR_PRIVILEGE_NOT_HELD);
                            if ( dwLSAAnonymousNameLookup ) {

                                bAddAce = TRUE;
                                AceType = ACCESS_ALLOWED_ACE_TYPE;

                            }
                        }

                        if ( bAddAce ) {

                            *pbOldLSAPolicyDifferent = TRUE;

                            if ( InitializeSecurityDescriptor( &SDAbsoluteToBuildAndSet, SECURITY_DESCRIPTOR_REVISION) ) {

                                rc = ScepAddAceToSecurityDescriptor(
                                                                   AceType,
                                                                   POLICY_LOOKUP_NAMES,
                                                                   &AnonymousSid,
                                                                   &SDAbsoluteToBuildAndSet,
                                                                   pSDCurrentLsaPolicyObject,
                                                                   &pNewAcl
                                                                   );

                                if ( rc == ERROR_SUCCESS) {

                                    //
                                    // log the SDDL SD for diagnostics
                                    //
                                    pwszSDlsaPolicyObject = NULL;

                                    if ( ConvertSecurityDescriptorToStringSecurityDescriptor(
                                                                                       &SDAbsoluteToBuildAndSet,
                                                                                       SDDL_REVISION_1,
                                                                                       DACL_SECURITY_INFORMATION,
                                                                                       &pwszSDlsaPolicyObject,
                                                                                       NULL
                                                                                       ) ){

                                        ScepLogOutput3(1,0,SCEDLL_SCP_INFO_LSAPOLICY_COMPUTED_SDDL, pwszSDlsaPolicyObject);

                                        LocalFree(pwszSDlsaPolicyObject);

                                    }

                                    NtStatus = LsaSetSecurityObject(
                                                                   LsaHandle,
                                                                   DACL_SECURITY_INFORMATION,
                                                                   &SDAbsoluteToBuildAndSet
                                                                   );

                                    LocalFree(pNewAcl);

                                    rc = RtlNtStatusToDosError( NtStatus );

                                    if ( !NT_SUCCESS( NtStatus ) ) {

                                        if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                                            ScepBuildErrorLogInfo(
                                                        rc,
                                                        pErrLog,
                                                        SCEDLL_SCP_ERROR_LSAPOLICY_SET
                                                        );
                                        } else {
                                            ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_SET);
                                        }
                                    }

                                }

                                else {

                                    if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                                        ScepBuildErrorLogInfo(
                                                    rc,
                                                    pErrLog,
                                                    SCEDLL_SCP_ERROR_LSAPOLICY_BUILDDACL
                                                    );
                                    } else {
                                        ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_BUILDDACL);
                                    }

                                }

                            }

                            else {

                                rc = GetLastError();

                                if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                                    ScepBuildErrorLogInfo(
                                                rc,
                                                pErrLog,
                                                SCEDLL_SCP_ERROR_LSAPOLICY_SD_INIT
                                                );
                                } else {
                                    ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_SD_INIT);
                                }


                            }

                        }

                    }

                    else {

                        rc = GetLastError();

                        if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                            ScepBuildErrorLogInfo(
                                        rc,
                                        pErrLog,
                                        SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ
                                        );
                        } else {
                            ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ);
                        }

                    }

                    AuthzFreeContext( hAuthzClientContext );

                } else {

                    rc = GetLastError();

                    if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                        ScepBuildErrorLogInfo(
                                    rc,
                                    pErrLog,
                                    SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ
                                    );
                    } else {
                        ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ);
                    }

                }

            }

            else {

                rc = ERROR_RESOURCE_NOT_PRESENT;

                if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                    ScepBuildErrorLogInfo(
                                rc,
                                pErrLog,
                                SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ
                                );
                } else {
                    ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ);
                }

            }

            LsaFreeMemory(pSDCurrentLsaPolicyObject);

        }

        if ( LsaPrivatePolicy == NULL ) {

            LsaClose(LsaHandle);

        }

    }

    return rc;
}

SCESTATUS
ScepConfigureLSAAnonymousLookup(
    IN PSCE_PROFILE_INFO pScpInfo,
    IN DWORD ConfigOptions,
    IN PSCE_ERROR_LOG_INFO *pErrLog)

/* ++

Routine Description:

   This routine configures LSA anonymous lookup policy

Arguments:

   pScpInfo - The buffer which contains SCP info loaded from the profile

   ConfigOptions - options in configuration

   pErrLog - the output log for potential errors

-- */
{
    DWORD       rc=ERROR_SUCCESS;
    PSCESECTION hSectionDomain=NULL;
    PSCESECTION hSectionTattoo=NULL;

    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         ScepIsSystemShutDown() ) 
    {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    if ( pScpInfo->LSAAnonymousNameLookup != SCE_NO_VALUE ) 
    {
        BOOL    bImpliedOldLSAPolicyDifferent = FALSE;
        DWORD   dwImpliedOldLSAAnonymousNameLookup = 
            pScpInfo->LSAAnonymousNameLookup;

        rc = ScepConfigureLSAPolicyObject(
                pScpInfo->LSAAnonymousNameLookup,
                ConfigOptions,
                pErrLog,
                &bImpliedOldLSAPolicyDifferent
                );

        if (bImpliedOldLSAPolicyDifferent) 
        {
            dwImpliedOldLSAAnonymousNameLookup = 
                (pScpInfo->LSAAnonymousNameLookup ? 0 : 1);
        }

        //
        // if this is policy propagation, we need to open the sections for
        // updating undo settings if this is not domain controller
        // *** on DCs, domain account policy can't be reset'ed to tattoo
        // on each individual DC. So there is no point to query/save tattoo values
        //
        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             (ProductType != NtProductLanManNt))
        {
            ScepTattooOpenPolicySections(
                hProfile,
                szSystemAccess,
                &hSectionDomain,
                &hSectionTattoo
                );

            ScepTattooManageOneIntValue(
                hSectionDomain,
                hSectionTattoo,
                (PWSTR)L"LSAAnonymousNameLookup",
                0,
                dwImpliedOldLSAAnonymousNameLookup, 
                rc);
        }

        if ((ConfigOptions & SCE_SYSTEM_SETTINGS) && 
            pErrLog ) 
        {
            ScepBuildErrorLogInfo(
                rc,
                pErrLog,
                SCEDLL_SCP_LSAPOLICY
                );
        }
        else 
        {
            ScepLogOutput3(1, rc, SCEDLL_SCP_LSAPOLICY);
        }

        if (ConfigOptions & SCE_RSOP_CALLBACK) 
        {
            ScepRsopLog(SCE_RSOP_LSA_POLICY_INFO, rc, NULL, 0, 0);
        }
    }

    if ( hSectionDomain ) 
    {
        SceJetCloseSection( &hSectionDomain, TRUE );
    }
    if ( hSectionTattoo ) 
    {
        SceJetCloseSection( &hSectionTattoo, TRUE );
    }

    return(ScepDosErrorToSceStatus(rc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\dumpnt.c ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    dumpnt.c

Abstract:

      Dump routines for various native defined types.

      The original/maintained version of this code lives @
      \\brillig\ntct!slm\src\security\util\dumpnt.c

Author:

    TimF 12-Jun-92 created

Revision History:

    JinHuang 13-Feb-98 modified
*/

#include	<stdio.h>

#include	<nt.h>
#include	<ntrtl.h>
#include	<nturtl.h>
#include	<windows.h>
#include	<ntlsa.h>
#include	<ntsam.h>

#include	"dumpnt.h"


/*
 * Generic header:
 *
 * Dump<TYPE_FOO>
 *
 * Takes a pointer to an object of TYPE_FOO, and dumps the contents of that
 * structure to wherever output is being sent these days (as best it can).
 *
 * Pointers and regions pointed are expected to be valid, and accessible.
 *
 * No return value is defined.
 */

VOID
DumpGUID(
	IN	GUID			*g
)
{
	if (!g) {
		printf("<NULL>\n");
	} else {
		try {
			printf("0x%08lx-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",
				g -> Data1,
				g -> Data2,
				g -> Data3,
				g -> Data4[0],
				g -> Data4[1],
				g -> Data4[2],
				g -> Data4[3],
				g -> Data4[4],
				g -> Data4[5],
				g -> Data4[6],
				g -> Data4[7]);
		} except (EXCEPTION_EXECUTE_HANDLER) {
			printf("DumpGUID:  invalid pointer (0x%p)\n",
				g);
		}
	}
}


VOID
DumpSID(
	IN	PSID			s
)
{
	static	char	b[128];

	SID_IDENTIFIER_AUTHORITY	*a;
	ULONG			id = 0, i;

	try {
		b[0] = '\0';

		a = RtlIdentifierAuthoritySid(s);

		sprintf(b, "s-0x1-%02x%02x%02x%02x%02x%02x", a -> Value[0],
			a -> Value[1], a -> Value[2], a -> Value[3], a ->
			Value[4], a -> Value[5]);

		for (i = 0; i < *RtlSubAuthorityCountSid(s); i++) {
			sprintf(b, "%s-%lx", b, *RtlSubAuthoritySid(s, i));
		}

		printf("%s", b);
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("%s<invalid pointer:  0x%p>\t", b, s);
	}
}


/*
 * DumpSIDNAME() attempts to unravel the Sid into a Display Name
 */

VOID
DumpSIDNAME(
	IN	PSID			s
)
{
	NTSTATUS		Status;
	LSA_HANDLE		Policy;
	OBJECT_ATTRIBUTES	ObjAttr;
	SECURITY_QUALITY_OF_SERVICE SQoS;
	PLSA_REFERENCED_DOMAIN_LIST RefDomains = NULL;
	PLSA_TRANSLATED_NAME	XNames = NULL;

	try {
		/*
		 * Open the policy with POLICY_LOOKUP_NAMES and lookup this
		 * Sid.
		 */

		InitializeObjectAttributes(&ObjAttr,
			NULL,
			0L,
			NULL,
			NULL);

		/*
		 * init the sqos struct
		 */

		SQoS.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
		SQoS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
		SQoS.ImpersonationLevel = SecurityIdentification;
		SQoS.EffectiveOnly = TRUE;

		ObjAttr.SecurityQualityOfService = &SQoS;

		/*
		 * make the actual call
		 */

		Status = LsaOpenPolicy(NULL,
			&ObjAttr,
			POLICY_LOOKUP_NAMES,
			&Policy);

		if (!NT_SUCCESS(Status)) {
			printf("DumpSIDNAMES: can't open Lsa, (0x%lx)\n",
				Status);

			return;
		}

		Status = LsaLookupSids(Policy,
			1L,
			&s,
			&RefDomains,
			&XNames);

		if (Status == STATUS_NONE_MAPPED) {
			printf("Unknown\n");
		} else if (!NT_SUCCESS(Status)) {
			printf("DumpSIDNAMES: can't Lookup Sids, (0x%lx)\n",
				Status);
		} else {
			printf("'%wZ' (%s)\n",
				&(XNames->Name),
				(XNames->Use == SidTypeUser ? "User" :
				 XNames->Use == SidTypeGroup ? "Group" :
				 XNames->Use == SidTypeDomain ? "Domain" :
				 XNames->Use == SidTypeAlias ? "Alias" :
				 XNames->Use == SidTypeWellKnownGroup ? "WellKnownGroup" :
				 XNames->Use == SidTypeDeletedAccount ? "Deleted" :
				 XNames->Use == SidTypeInvalid ? "Invalid" :
				 XNames->Use == SidTypeUnknown ?  "Unknown" :
				"ERROR!"));
		}
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpSIDNAME:  invalid pointer (0x%p)\n", s);
	}

	if (RefDomains) {
		LsaFreeMemory(RefDomains);
	}

	if (XNames) {
		LsaFreeMemory(XNames);
	}

	LsaClose(Policy);
}


VOID
DumpACL(
	IN	ACL			*a
)
{
	ACE_HEADER		*Ace;
	USHORT			i;

	try {
		printf("Acl -> AclRevision = 0x%x\n", a -> AclRevision);
		printf("Acl -> Sbz1 = 0x%x\n", a -> Sbz1);
		printf("Acl -> AclSize = 0x%x\n", a -> AclSize);
		printf("Acl -> AceCount = 0x%x\n", a -> AceCount);
		printf("Acl -> Sbz2 = 0x%x\n\n", a -> Sbz2);

		for (i = 0; i < a -> AceCount; i++) {
			if (NT_SUCCESS(RtlGetAce(a, i, (PVOID *)&Ace))) {
				DumpACE(Ace);
			} else {
				printf("(Can't RtlGetAce[%d])\n", i);
			}

			printf("\n");
		}
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpACL:  invalid pointer (0x%p)\n", a);
	}
}


VOID
DumpACE(
	IN	ACE_HEADER		*a
)
{
	ACCESS_ALLOWED_ACE	*Ace = (ACCESS_ALLOWED_ACE *)a;

	try {
		printf("Ace -> AceType = ");
		Dump_ACE_TYPE(a -> AceType);

		printf("Ace -> AceSize = 0x%x\n", a -> AceSize);

		printf("Ace -> AceFlags = ");
		Dump_ACE_FLAGS(a -> AceFlags);

		switch (a -> AceType) {
			case ACCESS_ALLOWED_ACE_TYPE:
			case ACCESS_DENIED_ACE_TYPE:
			case SYSTEM_AUDIT_ACE_TYPE:
			case SYSTEM_ALARM_ACE_TYPE:
				printf("Ace -> Mask = 0x%lx\n",
					Ace -> Mask);

				printf("Ace -> Sid = ");
				DumpSID(&(Ace -> SidStart));
				printf("\t");
				DumpSIDNAME(&(Ace -> SidStart));

				break;

			case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
			case ACCESS_DENIED_OBJECT_ACE_TYPE:
			case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
			case SYSTEM_ALARM_OBJECT_ACE_TYPE: {

				ACCESS_ALLOWED_OBJECT_ACE *ObjAce;
				ULONG_PTR Offset;

				ObjAce = (ACCESS_ALLOWED_OBJECT_ACE *)a;

				printf("Ace -> Mask = 0x%lx\n",
					Ace -> Mask);

				if (!ObjAce -> Flags) {
					printf("Ace -> Flags = 0\n");
				} else {
					printf("Ace -> Flags = ");

					if (ObjAce -> Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
						printf("ACE_INHERITED_OBJECT_TYPE_PRESENT ");
					}

					if (ObjAce -> Flags & ACE_OBJECT_TYPE_PRESENT) {
						printf("ACE_OBJECT_TYPE_PRESENT");
					}

					printf("\n");
				}

				Offset = (ULONG_PTR)&(ObjAce -> ObjectType);

				if (ObjAce -> Flags & ACE_OBJECT_TYPE_PRESENT) {
					printf("Ace -> ObjectType = ");
					DumpGUID((GUID *)Offset);

					Offset += sizeof (GUID);
				}
				
				if (ObjAce -> Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
					printf("Ace -> InheritedObjectType = ");
					DumpGUID((GUID *)Offset);

					Offset += sizeof (GUID);
				}

				printf("Ace -> Sid = ");
				DumpSID((SID *)Offset);
				printf("\t");
				DumpSIDNAME((SID *)Offset);

				break;
			}

			default:
				printf("(Unknown ACE type)\n");

				break;
		}
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpACE:  invalid pointer (0x%p)\n",
			a);
	}
}


VOID
DumpSECURITY_DESCRIPTOR_CONTROL(
	SECURITY_DESCRIPTOR_CONTROL Control
)
{
	printf("SecurityDescriptor -> Control = ");

	if (!Control) {
		printf("<no flags set>");
	}

	if (Control & SE_OWNER_DEFAULTED) {
		printf("SE_OWNER_DEFAULTED ");
	}
	
	if (Control & SE_GROUP_DEFAULTED) {
		printf("SE_GROUP_DEFAULTED ");
	}
	
	if (Control & SE_DACL_PRESENT) {
		printf("SE_DACL_PRESENT ");
	}
	
	if (Control & SE_DACL_DEFAULTED) {
		printf("SE_DACL_DEFAULTED ");
	}
	
	if (Control & SE_SACL_PRESENT) {
		printf("SE_SACL_PRESENT ");
	}
	
	if (Control & SE_SACL_DEFAULTED) {
		printf("SE_SACL_DEFAULTED ");
	}
	
	if (Control & SE_DACL_UNTRUSTED) {
		printf("SE_DACL_UNTRUSTED ");
	}
	
	if (Control & SE_SERVER_SECURITY) {
		printf("SE_SERVER_SECURITY ");
	}
	
	if (Control & SE_DACL_AUTO_INHERIT_REQ) {
		printf("SE_DACL_AUTO_INHERIT_REQ ");
	}
	
	if (Control & SE_SACL_AUTO_INHERIT_REQ) {
		printf("SE_SACL_AUTO_INHERIT_REQ ");
	}
	
	if (Control & SE_DACL_AUTO_INHERITED) {
		printf("SE_DACL_AUTO_INHERITED ");
	}
	
	if (Control & SE_SACL_AUTO_INHERITED) {
		printf("SE_SACL_AUTO_INHERITED ");
	}
	
	if (Control & SE_DACL_PROTECTED) {
		printf("SE_DACL_PROTECTED ");
	}
	
	if (Control & SE_SACL_PROTECTED) {
		printf("SE_SACL_PROTECTED ");
	}
	
	if (Control & SE_SELF_RELATIVE) {
		printf("SE_SELF_RELATIVE");
	}

	printf("\n");
}


VOID
DumpSECURITY_DESCRIPTOR(
	IN	PSECURITY_DESCRIPTOR	s
)
{
	BOOLEAN			Defaulted, Present;
	PACL			Acl;
	PSID			Sid;
	SECURITY_DESCRIPTOR_CONTROL Control;
	ULONG			Rev;

	try {
		printf("\nSecurityDescriptor -> Length = 0x%lx\n",
			RtlLengthSecurityDescriptor(s));

		RtlGetControlSecurityDescriptor(s,
			&Control,
			&Rev);

		DumpSECURITY_DESCRIPTOR_CONTROL(Control);

		printf("SecurityDescriptor -> Revision = 0x%lx\n",
			Rev);

		RtlGetOwnerSecurityDescriptor(s,
			&Sid,
			&Defaulted);

		printf("SecurityDescriptor -> Owner = ");
		if (Sid) {
			DumpSID(Sid);
			printf("\t");
			DumpSIDNAME(Sid);

		} else {
			printf("<NULL>\n");
		}

		RtlGetGroupSecurityDescriptor(s,
			&Sid,
			&Defaulted);

		printf("SecurityDescriptor -> Group = ");
		if (Sid) {
			DumpSID(Sid);
			printf("\t");
			DumpSIDNAME(Sid);
		} else {
			printf("<NULL>\n");
		}

		RtlGetDaclSecurityDescriptor(s,
			&Present,
			&Acl,
			&Defaulted);
			
		if (Present && Acl) {
			printf("SecurityDescriptor -> Dacl = \n");
			DumpACL(Acl);
		} else {
			printf("SecurityDescriptor -> Dacl = <not present>\n");
		}

		RtlGetSaclSecurityDescriptor(s,
			&Present,
			&Acl,
			&Defaulted);
			
		if (Present && Acl) {
			printf("SecurityDescriptor -> Sacl = \n");
			DumpACL(Acl);
		} else {
			printf("SecurityDescriptor -> Sacl = <not present>\n");
		}
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpSECURITY_DESCRIPTOR:  invalid pointer (0x%p)\n",
			s);
	}
}




VOID
DumpUNICODE_STRING(
	IN	UNICODE_STRING		*s
)
{
	ANSI_STRING		a;

	try {
		printf("UnicodeString -> Length = 0x%x\n", s -> Length);
		printf("UnicodeString -> MaximumLength = 0x%x\n",
			s -> MaximumLength);

		RtlUnicodeStringToAnsiString(&a,
			s,
			TRUE);

		printf("UnicodeString -> Buffer (a la ansi) = \"%s\"\n",
			a.Buffer);

		RtlFreeAnsiString(&a);
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpUNICODE_STRING:  invalid pointer (0x%p)\n", s);
	}
}


VOID
Dump_ACE_TYPE(
	IN	UCHAR			t
)
{
	switch (t) {
		case ACCESS_ALLOWED_ACE_TYPE:

			printf("ACCESS_ALLOWED_ACE_TYPE\n");

			break;

		case ACCESS_DENIED_ACE_TYPE:

			printf("ACCESS_DENIED_ACE_TYPE\n");

			break;

		case SYSTEM_AUDIT_ACE_TYPE:

			printf("SYSTEM_AUDIT_ACE_TYPE\n");

			break;

		case SYSTEM_ALARM_ACE_TYPE:

			printf("SYSTEM_ALARM_ACE_TYPE\n");

			break;

		case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

			printf("ACCESS_ALLOWED_COMPOUND_ACE_TYPE\n");

			break;

		case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

			printf("ACCESS_ALLOWED_OBJECT_ACE_TYPE\n");

			break;

		case ACCESS_DENIED_OBJECT_ACE_TYPE:

			printf("ACCESS_DENIED_OBJECT_ACE_TYPE\n");

			break;
		
		case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

			printf("SYSTEM_AUDIT_OBJECT_ACE_TYPE\n");

			break;

		case SYSTEM_ALARM_OBJECT_ACE_TYPE:

			printf("SYSTEM_ALARM_OBJECT_ACE_TYPE\n");

			break;

		default:

			printf("(unknown ace type)\n");

			break;
	}
}


VOID	
Dump_ACE_FLAGS(
	IN	UCHAR			f
)
{
	if (f & INHERIT_ONLY_ACE) {
		printf("INHERIT_ONLY_ACE ");
	}

	if (f & NO_PROPAGATE_INHERIT_ACE) {
		printf("NO_PROPAGATE_INHERIT_ACE ");
	}

	if (f & CONTAINER_INHERIT_ACE) {
		printf("CONTAINER_INHERIT_ACE ");
	}

	if (f & OBJECT_INHERIT_ACE) {
		printf("OBJECT_INHERIT_ACE ");
	}

	if (f & INHERITED_ACE) {
		printf("INHERITED_ACE ");
	}

	if (f & SUCCESSFUL_ACCESS_ACE_FLAG) {
		printf("SUCCESSFUL_ACCESS_ACE_FLAG ");
	}

	if (f & FAILED_ACCESS_ACE_FLAG) {
		printf("FAILED_ACCESS_ACE_FLAG");
	}

	printf("\n");
}


VOID
DumpSTRING(
	IN	STRING			*s
)
{
	try {
		printf("String -> Length = 0x%x\n", s -> Length);
		printf("String -> MaximumLength = 0x%x\n", s ->
			MaximumLength);
		printf("String -> Buffer = \"%s\"\n", s -> Buffer);
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpUNICODE_STRING:  invalid pointer (0x%p)\n", s);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\editsave.cpp ===
//depot/private/vishnup_branch/DS/security/services/scerpc/server/editsave.cpp#3 - edit change 1167 (text)
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    editsave.c

Abstract:

    APIs for UI to handle SMP (configuration) editing.

Author:

    Jin Huang (jinhuang) 17-Jun-1996

Revision History:

    jinhuang 28-Jan-1998  splitted to client-server

--*/

#include "serverp.h"
#include <io.h>
#include "pfp.h"
#pragma hdrstop

//
// for whole buffer areas
//

SCESTATUS
ScepUpdateSystemAccess(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateSystemAuditing(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateLogs(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateKerberos(
    IN PSCECONTEXT hProfile,
    IN PSCE_KERBEROS_TICKET_INFO pInfo,
    IN PSCE_KERBEROS_TICKET_INFO pBufScep OPTIONAL,
    IN PSCE_KERBEROS_TICKET_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateRegistryValues(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep,
    IN PSCE_PROFILE_INFO pBufSap
    );

SCESTATUS
ScepSaveRegValueEntry(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PWSTR CurrentValue,
    IN DWORD dType,
    IN DWORD Status
    );

SCESTATUS
ScepUpdateFixValueSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep,
    IN PSCE_PROFILE_INFO pBufSap,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName,
    OUT PSCESECTION *hSecScep OPTIONAL,
    OUT PSCESECTION *hSecSap OPTIONAL
    );

SCESTATUS
ScepUpdateAccountName(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PCWSTR KeyName,
    IN PWSTR NewName OPTIONAL,
    IN PWSTR SmpName OPTIONAL,
    IN PWSTR SapName OPTIONAL
    );

SCESTATUS
ScepUpdatePrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pNewPriv,
    IN PSCE_PRIVILEGE_ASSIGNMENT *pScepPriv
    );

SCESTATUS
ScepUpdateGroupMembership(
    IN PSCECONTEXT hProfile,
    IN PSCE_GROUP_MEMBERSHIP pNewGroup,
    IN PSCE_GROUP_MEMBERSHIP *pScepGroup
    );

SCESTATUS
ScepGetKeyNameList(
   IN LSA_HANDLE LsaPolicy,
   IN PSCESECTION hSection,
   IN PWSTR Key,
   IN DWORD KeyLen,
   IN DWORD dwAccountFormat,
   OUT PSCE_NAME_LIST *pNameList
   );

#define SCE_FLAG_UPDATE_PRIV        0
#define SCE_FLAG_UPDATE_MEMBERS     1
#define SCE_FLAG_UPDATE_MEMBEROF    2

SCESTATUS
ScepUpdateKeyNameList(
    IN LSA_HANDLE LsaPolicy,
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR GroupName OPTIONAL,
    IN BOOL bScepExist,
    IN PWSTR KeyName,
    IN DWORD NameLen,
    IN PSCE_NAME_LIST pNewList,
    IN PSCE_NAME_LIST pScepList,
    IN DWORD flag
    );

SCESTATUS
ScepUpdateGeneralServices(
    IN PSCECONTEXT hProfile,
    IN PSCE_SERVICES pNewServices,
    IN PSCE_SERVICES *pScepServices
    );

//
// for object updates
//

SCESTATUS
ScepObjectUpdateExistingNode(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN SE_OBJECT_TYPE ObjectType,
    IN BYTE ConfigStatus,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    );

SCESTATUS
ScepObjectGetKeySetting(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    OUT PBYTE Status,
    OUT PBOOL IsContainer OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor OPTIONAL,
    OUT PSECURITY_INFORMATION SeInfo OPTIONAL
    );

SCESTATUS
ScepObjectSetKeySetting(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    IN BYTE Status,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN BOOL bOverwrite
    );


SCESTATUS
ScepObjectCompareKeySetting(
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pScepSD,
    OUT PBYTE pAnalysisStatus
    );

SCESTATUS
ScepObjectDeleteScepAndAllChildren(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN BOOL IsContainer,
    IN BYTE StatusToRaise
    );

SCESTATUS
ScepObjectAdjustNode(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN SE_OBJECT_TYPE ObjectType,
    IN BYTE ConfigStatus,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN BOOL bAdd,
    OUT PBYTE pAnalysisStatus
    );

#define SCE_OBJECT_TURNOFF_IGNORE   0x1L
#define SCE_OBJECT_SEARCH_JUNCTION  0x2L

SCESTATUS
ScepObjectAdjustParentStatus(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN WCHAR Delim,
    IN INT Level,
    IN BYTE Flag,
    OUT PINT ParentLevel,
    OUT PBYTE ParentStatus OPTIONAL,
    OUT PWSTR ParentName OPTIONAL
    );

SCESTATUS
ScepObjectHasAnyChild(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN WCHAR Delim,
    OUT PBOOL bpHasChild
    );

SCESTATUS
ScepObjectRaiseChildrenInBetween(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN BOOL IsContainer,
    IN BYTE Status,
    IN BOOL bChangeStatusOnly
    );

SCESTATUS
ScepObjectRaiseNodesInPath(
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN INT StartLevel,
    IN INT EndLevel,
    IN WCHAR Delim,
    IN BYTE Status
    );

SCESTATUS
ScepGetFullNameInLevel(
    IN PCWSTR ObjectFullName,
    IN DWORD  Level,
    IN WCHAR  Delim,
    IN BOOL bWithLastDelim,
    OUT PWSTR Buffer,
    OUT PBOOL LastOne
    );

SCESTATUS
ScepObjectTotalLevel(
    IN PWSTR ObjectName,
    IN WCHAR Delim,
    OUT PINT pLevel
    );

SCESTATUS
ScepUpdateLocalSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateLocalAccountName(
    IN PSCECONTEXT hProfile,
    IN PCWSTR KeyName,
    IN PWSTR NewName OPTIONAL
    );

SCESTATUS
ScepUpdateLocalRegValues(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateLocalPrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pNewPriv,
    IN DWORD dwMode
    );

DWORD
ScepQueryAnalysisStatus(
    IN PSCESECTION hSection,
    IN PWSTR KeyName,
    IN DWORD NameLen
    );

DWORD
ScepConvertNameListFormat(
    IN LSA_HANDLE LsaHandle,
    IN PSCE_NAME_LIST pInList,
    IN DWORD FromFormat,
    IN DWORD ToFormat,
    OUT PSCE_NAME_LIST *ppOutList
    );

DWORD
ScepConvertPrivilegeList(
    IN LSA_HANDLE LsaHandle,
    IN PSCE_PRIVILEGE_ASSIGNMENT pFromList,
    IN DWORD FromFormat,
    IN DWORD ToFormat,
    OUT PSCE_PRIVILEGE_ASSIGNMENT *ppToList
    );
//
// implementations
//


SCESTATUS
ScepUpdateDatabaseInfo(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PSCE_PROFILE_INFO pInfo
    )
/*
Routine Description:

    Update SMP section and "compute" analysis status to determine related
    changes for SAP section. For rules on computing, refer to spec objedit.doc

    This routine should work for areas security policy, privileges, and
    group membership

Arguements:

    hProfile - the jet database handle

    Area - The areas to update

    pInfo - the buffer containing modified SMP information

Return Value:

    SCESTATUS
*/
{
    SCESTATUS    rc;
    PSCE_PROFILE_INFO pBufScep=NULL;
    PSCE_ERROR_LOG_INFO Errlog=NULL;
    PSCE_PROFILE_INFO pBufSap=NULL;


    if ( hProfile == NULL || pInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( Area & ~( AREA_SECURITY_POLICY | AREA_PRIVILEGES |
                   AREA_GROUP_MEMBERSHIP | AREA_SYSTEM_SERVICE ) ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // get original SMP information
    //
    rc = ScepGetDatabaseInfo(
            hProfile,
            SCE_ENGINE_SMP,
            Area,
            SCE_ACCOUNT_SID_STRING,
            &pBufScep,
            &Errlog
            );

    ScepLogWriteError(Errlog, 1);
    ScepFreeErrorLog(Errlog );
    Errlog = NULL;

    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }

    rc = SceJetStartTransaction( hProfile );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( Area & AREA_SECURITY_POLICY ) {
            //
            // security policy area, get SAP information
            //

            rc = ScepGetDatabaseInfo(
                    hProfile,
                    SCE_ENGINE_SAP,
                    AREA_SECURITY_POLICY,
                    0,
                    &pBufSap,
                    &Errlog
                    );
            ScepLogWriteError(Errlog, 1);
            ScepFreeErrorLog(Errlog );
            Errlog = NULL;

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // Update system access section
                //
                rc = ScepUpdateSystemAccess(hProfile,
                                            pInfo,
                                            pBufScep,
                                            pBufSap,
                                            0);

                if ( rc == SCESTATUS_SUCCESS) {
                    //
                    // Update system auditing section
                    //
                    rc = ScepUpdateSystemAuditing(hProfile,
                                                  pInfo,
                                                  pBufScep,
                                                  pBufSap,
                                                  0);

                    if ( rc == SCESTATUS_SUCCESS) {
                        //
                        // Update log sections
                        //
                        rc = ScepUpdateLogs(hProfile,
                                            pInfo,
                                            pBufScep,
                                            pBufSap,
                                            0);

                        if ( rc == SCESTATUS_SUCCESS && pInfo->pKerberosInfo ) {
                            //
                            // Update kerberos policy
                            //
                            rc = ScepUpdateKerberos(hProfile,
                                                    pInfo->pKerberosInfo,
                                                    pBufScep->pKerberosInfo,
                                                    pBufSap->pKerberosInfo,
                                                    0);
                        }
                        if ( rc == SCESTATUS_SUCCESS ) {
                            //
                            // update registry values
                            //
                            rc = ScepUpdateRegistryValues(hProfile,
                                                          pInfo,
                                                          pBufScep,
                                                          pBufSap
                                                          );

                        }
                        //
                        // Note: policy attachment is not updated through this API
                        //
                    }
                }

                SceFreeProfileMemory(pBufSap);
            }

            if ( rc != SCESTATUS_SUCCESS ) {
                goto Cleanup;
            }
        }

        if ( Area & AREA_PRIVILEGES ) {
            //
            // privileges area
            //
            rc = ScepUpdatePrivileges(hProfile,
                                     pInfo->OtherInfo.smp.pPrivilegeAssignedTo,
                                     &(pBufScep->OtherInfo.smp.pPrivilegeAssignedTo)
                                     );

            if ( rc != SCESTATUS_SUCCESS ) {
                goto Cleanup;
            }
        }

        if ( Area & AREA_GROUP_MEMBERSHIP ) {
            //
            // group membership area
            //
            rc = ScepUpdateGroupMembership(hProfile,
                                          pInfo->pGroupMembership,
                                          &(pBufScep->pGroupMembership)
                                          );

        }

        if ( Area & AREA_SYSTEM_SERVICE ) {
            //
            // system service general setting area
            //
            rc = ScepUpdateGeneralServices(hProfile,
                                          pInfo->pServices,
                                          &(pBufScep->pServices)
                                          );

        }

        if ( rc == SCESTATUS_SUCCESS ) {
           //
           // needs return code for commiting the transaction
           //
           rc = SceJetCommitTransaction(hProfile, 0);

        }
        if ( rc != SCESTATUS_SUCCESS ) {

            SceJetRollback(hProfile, 0);
        }
    }

Cleanup:

    SceFreeProfileMemory(pBufScep);

    return(rc);

}


SCESTATUS
ScepUpdateSystemAccess(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update system access section

Arguements:

    hProfile - the jet database handle

    pInfo    - the changed info buffer

    pBufScep - the original SMP buffer

    pBufSap  - the SAP buffer

Return Value:

    SCESTATUS
*/
{
    SCE_KEY_LOOKUP AccessLookup[] = {
        {(PWSTR)TEXT("MinimumPasswordAge"),           offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordAge),        'D'},
        {(PWSTR)TEXT("MaximumPasswordAge"),           offsetof(struct _SCE_PROFILE_INFO, MaximumPasswordAge),        'D'},
        {(PWSTR)TEXT("MinimumPasswordLength"),        offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordLength),     'D'},
        {(PWSTR)TEXT("PasswordComplexity"),           offsetof(struct _SCE_PROFILE_INFO, PasswordComplexity),        'D'},
        {(PWSTR)TEXT("PasswordHistorySize"),          offsetof(struct _SCE_PROFILE_INFO, PasswordHistorySize),       'D'},
        {(PWSTR)TEXT("LockoutBadCount"),              offsetof(struct _SCE_PROFILE_INFO, LockoutBadCount),           'D'},
        {(PWSTR)TEXT("ResetLockoutCount"),            offsetof(struct _SCE_PROFILE_INFO, ResetLockoutCount),         'D'},
        {(PWSTR)TEXT("LockoutDuration"),              offsetof(struct _SCE_PROFILE_INFO, LockoutDuration),           'D'},
        {(PWSTR)TEXT("RequireLogonToChangePassword"), offsetof(struct _SCE_PROFILE_INFO, RequireLogonToChangePassword), 'D'},
        {(PWSTR)TEXT("ForceLogoffWhenHourExpire"),    offsetof(struct _SCE_PROFILE_INFO, ForceLogoffWhenHourExpire), 'D'},
        {(PWSTR)TEXT("ClearTextPassword"),            offsetof(struct _SCE_PROFILE_INFO, ClearTextPassword),         'D'},
        {(PWSTR)TEXT("LSAAnonymousNameLookup"),       offsetof(struct _SCE_PROFILE_INFO, LSAAnonymousNameLookup),         'D'},
        {(PWSTR)TEXT("EnableAdminAccount"),          offsetof(struct _SCE_PROFILE_INFO, EnableAdminAccount),         'D'},
        {(PWSTR)TEXT("EnableGuestAccount"),          offsetof(struct _SCE_PROFILE_INFO, EnableGuestAccount),         'D'}
        };

    DWORD       cAccess = sizeof(AccessLookup) / sizeof(SCE_KEY_LOOKUP);

    SCESTATUS    rc;
    PSCESECTION  hSectionSmp=NULL,
                hSectionSap=NULL;


    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }


    if ( dwMode & SCE_UPDATE_LOCAL_POLICY ) {
        //
        // update local policy table only
        //

        rc = ScepUpdateLocalSection(
                    hProfile,
                    pInfo,
                    AccessLookup,
                    cAccess,
                    szSystemAccess,
                    dwMode
                    );

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // new admin name
            //
            rc = ScepUpdateLocalAccountName(
                        hProfile,
                        L"newadministratorname",
                        pInfo->NewAdministratorName
                        );

            if ( SCESTATUS_SUCCESS == rc ) {

                //
                // new guest name
                //
                rc = ScepUpdateLocalAccountName(
                            hProfile,
                            L"newguestname",
                            pInfo->NewGuestName
                            );
            }

        }

    } else {

        if ( pBufScep == NULL || pBufSap == NULL ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }

        rc = ScepUpdateFixValueSection(
                    hProfile,
                    pInfo,
                    pBufScep,
                    pBufSap,
                    AccessLookup,
                    cAccess,
                    szSystemAccess,
                    &hSectionSmp,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // new admin name
            //
            rc = ScepUpdateAccountName(
                        hSectionSmp,
                        hSectionSap,
                        L"newadministratorname",
                        pInfo->NewAdministratorName,
                        pBufScep->NewAdministratorName,
                        pBufSap->NewAdministratorName
                        );

            if ( SCESTATUS_SUCCESS == rc ) {

                //
                // new guest name
                //
                rc = ScepUpdateAccountName(
                            hSectionSmp,
                            hSectionSap,
                            L"newguestname",
                            pInfo->NewGuestName,
                            pBufScep->NewGuestName,
                            pBufSap->NewGuestName
                            );
            }

            SceJetCloseSection(&hSectionSap, TRUE);
            SceJetCloseSection(&hSectionSmp, TRUE);
        }
    }

    return(rc);

}


SCESTATUS
ScepUpdateAccountName(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PCWSTR KeyName,
    IN PWSTR NewName OPTIONAL,
    IN PWSTR SmpName OPTIONAL,
    IN PWSTR SapName OPTIONAL
    )
/*
Routine Description:

    Update or delete Administrator and/or guest name

Arguements:

    hSectionSmp - the SMP section context

    hSectionSap - the SAP section context

    KeyName    - the key name where this account name is stored

    NewName - new name to change to, if NULL, the key is deleted

    SmpName - the old name in SMP buffer

    SapName - the analyzed name in SAP buffer

Return Value:

    SCESTATUS
*/
{
    DWORD LenNew=0, LenSmp=0, LenSap=0;
    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( !hSectionSmp || !hSectionSap || !KeyName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( NewName )
        LenNew = wcslen(NewName);

    if ( SmpName )
        LenSmp = wcslen(SmpName);

    if ( SapName )
        LenSap = wcslen(SapName);


    if ( LenSap > 0 ) {
        //
        // old status is mismatch for this item
        //
        if ( LenNew > 0 && _wcsicmp(NewName, SapName) == 0 ) {
            //
            // now it is matched, delete the SAP entry
            //
            rc = SceJetDelete(
                    hSectionSap,
                    (PWSTR)KeyName,
                    FALSE,
                    SCEJET_DELETE_LINE
                    );
        }
        //
        // update SMP entry
        //
        if ( !LenNew ) {
            //
            // delete the SMP entry
            //
            rc = SceJetDelete(
                    hSectionSmp,
                    (PWSTR)KeyName,
                    FALSE,
                    SCEJET_DELETE_LINE
                    );
        } else {
            //
            // update it
            //
            rc = SceJetSetLine(
                hSectionSmp,
                (PWSTR)KeyName,
                TRUE,
                NewName,
                LenNew*sizeof(WCHAR),
                0
                );
        }

    } else {
        //
        // old status is match
        //
        if ( LenNew != LenSmp ||
             ( LenNew > 0 && _wcsicmp(NewName, SmpName) != 0 ) ) {
            //
            // mismatch should be raised with pBufScep
            //
            rc = SceJetSetLine(
                    hSectionSap,
                    (PWSTR)KeyName,
                    TRUE,
                    SmpName,
                    LenSmp*sizeof(WCHAR),
                    0
                    );

            if ( !LenNew ) {
                //
                // delete SMP
                //
                rc = SceJetDelete(
                            hSectionSmp,
                            (PWSTR)KeyName,
                            FALSE,
                            SCEJET_DELETE_LINE
                            );
            } else {
                //
                // update SMP
                //
                rc = SceJetSetLine(
                    hSectionSmp,
                    (PWSTR)KeyName,
                    TRUE,
                    NewName,
                    LenNew*sizeof(WCHAR),
                    0
                    );
            }
        }
    }

    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);
}


SCESTATUS
ScepUpdateLocalAccountName(
    IN PSCECONTEXT hProfile,
    IN PCWSTR KeyName,
    IN PWSTR NewName OPTIONAL
    )
/*
Routine Description:

    Update or delete Administrator and/or guest name

Arguements:

    KeyName    - the key name where this account name is stored

    NewName - new name to change to, if NULL, the key is deleted

Return Value:

    SCESTATUS
*/
{
    DWORD LenNew=0;
    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( !KeyName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( NewName )
        LenNew = wcslen(NewName);

    //
    // open local policy section
    //
    PSCESECTION hSectionSmp=NULL;

    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szSystemAccess,
                &hSectionSmp
                );

    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }

    if ( LenNew > 0 ) {
        //
        // there is a new name to set
        //
        rc = SceJetSetLine(
                hSectionSmp,
                (PWSTR)KeyName,
                TRUE,
                NewName,
                LenNew*sizeof(WCHAR),
                0
                );
    } else {
        //
        // no name to set, delete it
        //
        rc = SceJetDelete(
                hSectionSmp,
                (PWSTR)KeyName,
                FALSE,
                SCEJET_DELETE_LINE
                );
    }

    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    SceJetCloseSection(&hSectionSmp, TRUE);

    return(rc);
}


SCESTATUS
ScepUpdateSystemAuditing(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update system auditing section

Arguements:

    hProfile - the jet database handle

    pInfo    - the changed info buffer

    pBufScep - the original SMP buffer

    pBufSap  - the SAP buffer

Return Value:

    SCESTATUS
*/
{
    SCE_KEY_LOOKUP       EventKeys[]={
        {(PWSTR)TEXT("AuditSystemEvents"),  offsetof(struct _SCE_PROFILE_INFO, AuditSystemEvents),   'D'},
        {(PWSTR)TEXT("AuditLogonEvents"),   offsetof(struct _SCE_PROFILE_INFO, AuditLogonEvents),    'D'},
        {(PWSTR)TEXT("AuditObjectAccess"),  offsetof(struct _SCE_PROFILE_INFO, AuditObjectAccess),   'D'},
        {(PWSTR)TEXT("AuditPrivilegeUse"),  offsetof(struct _SCE_PROFILE_INFO, AuditPrivilegeUse),   'D'},
        {(PWSTR)TEXT("AuditPolicyChange"),  offsetof(struct _SCE_PROFILE_INFO, AuditPolicyChange),   'D'},
        {(PWSTR)TEXT("AuditAccountManage"), offsetof(struct _SCE_PROFILE_INFO, AuditAccountManage),  'D'},
        {(PWSTR)TEXT("AuditProcessTracking"),offsetof(struct _SCE_PROFILE_INFO, AuditProcessTracking),'D'},
        {(PWSTR)TEXT("AuditDSAccess"),      offsetof(struct _SCE_PROFILE_INFO, AuditDSAccess),       'D'},
        {(PWSTR)TEXT("AuditAccountLogon"),  offsetof(struct _SCE_PROFILE_INFO, AuditAccountLogon),   'D'}};

    DWORD cKeys = sizeof(EventKeys) / sizeof(SCE_KEY_LOOKUP);


    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    if ( dwMode & SCE_UPDATE_LOCAL_POLICY ) {
        //
        // update local policy table only
        //

        rc = ScepUpdateLocalSection(
                    hProfile,
                    pInfo,
                    EventKeys,
                    cKeys,
                    szAuditEvent,
                    dwMode
                    );

    } else {

        if ( pBufScep == NULL || pBufSap == NULL ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }

        rc = ScepUpdateFixValueSection(
                    hProfile,
                    pInfo,
                    pBufScep,
                    pBufSap,
                    EventKeys,
                    cKeys,
                    szAuditEvent,
                    NULL,
                    NULL
                    );
    }

    return rc;
}


SCESTATUS
ScepUpdateLogs(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update event log sections

Arguements:

    hProfile - the jet database handle

    pInfo    - the changed info buffer

    pBufScep - the original SMP buffer

    pBufSap  - the SAP buffer

Return Value:

    SCESTATUS
*/
{
    SCE_KEY_LOOKUP       LogKeys[]={
        {(PWSTR)TEXT("MaximumLogSize"),         offsetof(struct _SCE_PROFILE_INFO, MaximumLogSize),          'D'},
        {(PWSTR)TEXT("AuditLogRetentionPeriod"),offsetof(struct _SCE_PROFILE_INFO, AuditLogRetentionPeriod), 'D'},
        {(PWSTR)TEXT("RetentionDays"),          offsetof(struct _SCE_PROFILE_INFO, RetentionDays),           'D'},
        {(PWSTR)TEXT("RestrictGuestAccess"),    offsetof(struct _SCE_PROFILE_INFO, RestrictGuestAccess),     'D'}
        };

    DWORD cKeys = sizeof(LogKeys) / sizeof(SCE_KEY_LOOKUP);

    SCESTATUS rc;
    DWORD i, j;
    PCWSTR szAuditLog=NULL;

    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !(dwMode & SCE_UPDATE_LOCAL_POLICY) ) {
        if ( pBufScep == NULL || pBufSap == NULL ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }
    }

    for ( i=0; i<3; i++) {

        //
        // Get Event Log setting for system log, security log and application log
        //

        switch (i) {
        case 0:
            szAuditLog = szAuditSystemLog;
            break;
        case 1:
            szAuditLog = szAuditSecurityLog;
            break;
        default:
            szAuditLog = szAuditApplicationLog;
            break;
        }

        if ( dwMode & SCE_UPDATE_LOCAL_POLICY ) {

            //
            // update local policy table only
            //

            rc = ScepUpdateLocalSection(
                        hProfile,
                        pInfo,
                        LogKeys,
                        4,
                        szAuditLog,
                        dwMode
                        );

        } else {

            //
            // get DWORD values for the section
            //
            rc = ScepUpdateFixValueSection(
                       hProfile,
                       pInfo,
                       pBufScep,
                       pBufSap,
                       LogKeys,
                       4,
                       szAuditLog,
                       NULL,
                       NULL
                       );
        }

        if ( rc != SCESTATUS_SUCCESS )
            break;

        //
        // update the Offset for next section
        //
        for ( j=0; j<4; j++ )
            LogKeys[j].Offset += sizeof(DWORD);
    }

    return(rc);
}

SCESTATUS
ScepUpdateKerberos(
    IN PSCECONTEXT hProfile,
    IN PSCE_KERBEROS_TICKET_INFO pInfo,
    IN PSCE_KERBEROS_TICKET_INFO pBufScep OPTIONAL,
    IN PSCE_KERBEROS_TICKET_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    )
{
    SCESTATUS rc;
    SCE_KEY_LOOKUP       KerberosKeys[]={
        {(PWSTR)TEXT("MaxTicketAge"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxTicketAge),  'D'},
        {(PWSTR)TEXT("MaxRenewAge"),      offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxRenewAge),   'D'},
        {(PWSTR)TEXT("MaxServiceAge"), offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxServiceAge),   'D'},
        {(PWSTR)TEXT("MaxClockSkew"),  offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxClockSkew), 'D'},
        {(PWSTR)TEXT("TicketValidateClient"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, TicketValidateClient),  'D'}
        };

    DWORD cKeys = sizeof(KerberosKeys) / sizeof(SCE_KEY_LOOKUP);
    SCE_KERBEROS_TICKET_INFO tmpBuf;

    if ( !pInfo ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( dwMode & SCE_UPDATE_LOCAL_POLICY ) {

        rc = ScepUpdateLocalSection(
            hProfile,
            (PSCE_PROFILE_INFO)pInfo,
            KerberosKeys,
            cKeys,
            szKerberosPolicy,
            dwMode
            );

    } else {

        if ( !pBufScep || !pBufSap ) {
            //
            // if SMP or SAP buffer is NULL
            //
            tmpBuf.MaxTicketAge = SCE_NO_VALUE;
            tmpBuf.MaxRenewAge = SCE_NO_VALUE;
            tmpBuf.MaxServiceAge = SCE_NO_VALUE;
            tmpBuf.MaxClockSkew = SCE_NO_VALUE;
            tmpBuf.TicketValidateClient = SCE_NO_VALUE;
        }

        //
        // get DWORD values for the section
        //
        rc = ScepUpdateFixValueSection(
                   hProfile,
                   (PSCE_PROFILE_INFO)pInfo,
                   pBufScep ? (PSCE_PROFILE_INFO)pBufScep : (PSCE_PROFILE_INFO)&tmpBuf,
                   pBufSap ? (PSCE_PROFILE_INFO)pBufSap : (PSCE_PROFILE_INFO)&tmpBuf,
                   KerberosKeys,
                   cKeys,
                   szKerberosPolicy,
                   NULL,
                   NULL
                   );
    }

    return(rc);
}


SCESTATUS
ScepUpdateFixValueSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep,
    IN PSCE_PROFILE_INFO pBufSap,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName,
    OUT PSCESECTION *hSecScep OPTIONAL,
    OUT PSCESECTION *hSecSap OPTIONAL
    )
/*
Routine Description:

    Update each key in the Keys array based on the editing rule. SMP entry is
    updated with the new value. SAP entry is either deleted, or created, depending
    on the new computed analysis status.

Arguements:

    hProfile - the jet database handle

    pInfo    - the changed info buffer

    pBufScep - the original SMP buffer

    pBufSap  - the SAP buffer

    Keys     - the lookup keys array

    cKeys    - the number of keys in the array

    SecitonName - the section name to work on

    hSecScep - the section context handle in SMP to output

    hSecSap  - the section context handle in SAP to output

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;

    DWORD       i;
    UINT        Offset;
    DWORD       valScep, valSap, valNewScep;



    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                SectionName,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    SectionName,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS) {

            for ( i=0; i<cKeys; i++) {

                //
                // get settings in AccessLookup table
                //

                Offset = Keys[i].Offset;

                switch ( Keys[i].BufferType ) {
                case 'B':
                    break;

                case 'D': {

                    valScep = *((DWORD *)((CHAR *)pBufScep+Offset));
                    valSap = *((DWORD *)((CHAR *)pBufSap+Offset));
                    valNewScep = *((DWORD *)((CHAR *)pInfo+Offset));

                    switch ( valSap ) {
                    case SCE_NO_VALUE:

                        //
                        // old status is match
                        //
                        if ( valNewScep != valScep ) {
                            //
                            // mismatch should be raised with valScep
                            //
                            rc = ScepCompareAndSaveIntValue(
                                    hSectionSap,
                                    Keys[i].KeyString,
                                    FALSE,
                                    SCE_NO_VALUE,
                                    (valScep != SCE_NO_VALUE ) ? valScep : SCE_NOT_ANALYZED_VALUE
                                    );

                        }

                        break;

                    case SCE_ERROR_VALUE:
                    case SCE_NOT_ANALYZED_VALUE:
                        //
                        // old status is error when analyzing so we don't know the
                        // status of this one (yet), or
                        // this is an item that was added after analyzing
                        //
                        // do not change SAP table
                        //
                        break;

                    default:
                        //
                        // old status is mismatch for this item
                        //
                        if ( valNewScep == valSap ) {
                            //
                            // now it is matched, delete the SAP entry
                            //
                            rc = SceJetDelete(
                                    hSectionSap,
                                    Keys[i].KeyString,
                                    FALSE,
                                    SCEJET_DELETE_LINE_NO_CASE
                                    );
                        }

                        break;
                    }

                    //
                    // update SMP entry
                    //
                    if ( valNewScep != valScep ) {

                        if ( valNewScep == SCE_NO_VALUE ) {
                            //
                            // delete Scep
                            //
                            rc = SceJetDelete(
                                        hSectionSmp,
                                        Keys[i].KeyString,
                                        FALSE,
                                        SCEJET_DELETE_LINE_NO_CASE
                                        );
                        } else {
                            //
                            // update SMP
                            //
                            rc = ScepCompareAndSaveIntValue(
                                        hSectionSmp,
                                        Keys[i].KeyString,
                                        FALSE,
                                        SCE_NO_VALUE,
                                        valNewScep
                                        );
                        }
                    }

                    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                        //
                        // if not find for delete, ignore the error
                        //
                        rc = SCESTATUS_SUCCESS;
                    }
                    break;
                }

                default:
                    break;
                }

                if ( rc != SCESTATUS_SUCCESS ) {
                    break;
                }
            }

            //
            // return the section handle if asked, else free it
            //
            if ( hSecSap != NULL )
                *hSecSap = hSectionSap;
            else
                SceJetCloseSection(&hSectionSap, TRUE);
        }

        //
        // return the section handle if asked, else free it
        //
        if ( hSecScep != NULL )
            *hSecScep = hSectionSmp;
        else
            SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);

}

SCESTATUS
ScepUpdateRegistryValues(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep,
    IN PSCE_PROFILE_INFO pBufSap
    )
{
    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;
    PWSTR valScep, valSap, valNewScep;
    DWORD i,j,k,status;

    if ( pInfo->RegValueCount == 0 ||
         pInfo->aRegValues == NULL ) {
        //
        // impossible to have a empty buffer to update
        // this buffer should contain all available registry values to configure/analyze
        //
        return(SCESTATUS_SUCCESS);
    }

    if ( (pBufScep->RegValueCount != 0 && pBufScep->aRegValues == NULL) ||
         (pBufSap->RegValueCount != 0 && pBufSap->aRegValues == NULL) ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szRegistryValues,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    szRegistryValues,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS) {

            for (i=0; i<pInfo->RegValueCount; i++ ) {

                if ( !(pInfo->aRegValues[i].FullValueName) ) {
                    continue;
                }
                //
                // find SMP match
                //
                for ( j=0; j<pBufScep->RegValueCount; j++ ) {
                    if ( pBufScep->aRegValues[j].FullValueName &&
                         _wcsicmp(pInfo->aRegValues[i].FullValueName,
                                  pBufScep->aRegValues[j].FullValueName) == 0 ) {
                        break;
                    }
                }

                //
                // find SAP match
                //
                for ( k=0; k<pBufSap->RegValueCount; k++ ) {
                    if ( pBufSap->aRegValues[k].FullValueName &&
                         _wcsicmp(pInfo->aRegValues[i].FullValueName,
                                  pBufSap->aRegValues[k].FullValueName) == 0 ) {
                        break;
                    }
                }
                //
                // find old configuration
                //
                if ( j < pBufScep->RegValueCount ) {
                    valScep = pBufScep->aRegValues[j].Value;
                } else {
                    valScep = NULL;
                }

                //
                // find analysis value and status
                //
                if ( k < pBufSap->RegValueCount ) {
                    valSap = pBufSap->aRegValues[k].Value;
                    status = pBufSap->aRegValues[k].Status;
                } else {
                    valSap = NULL;
                    if ( valScep ) {
                        status = SCE_STATUS_GOOD;
                    } else {
                        status = SCE_STATUS_NOT_CONFIGURED;
                    }
                }

                valNewScep = pInfo->aRegValues[i].Value;

                if ( status == SCE_STATUS_NOT_ANALYZED ||
                     status == SCE_STATUS_ERROR_NOT_AVAILABLE ) {
                    //
                    // do not change SAP
                    //
                } else {

                    if ( valSap ) {
                        //
                        // mismatched
                        //
                        if ( valNewScep && _wcsicmp(valNewScep, valSap) == 0 ) {
                            //
                            // now it is matched, delete the SAP entry
                            //
                            rc = SceJetDelete(
                                    hSectionSap,
                                    pInfo->aRegValues[i].FullValueName,
                                    FALSE,
                                    SCEJET_DELETE_LINE_NO_CASE
                                    );
                        }
                    } else {
                        if ( valScep ) {
                            //
                            // was a matched item
                            //
                            if (valNewScep && _wcsicmp(valNewScep, valScep) != 0 ) {
                                //
                                // mismatched
                                //
                                rc = ScepSaveRegValueEntry(
                                           hSectionSap,
                                           pInfo->aRegValues[i].FullValueName,
                                           valScep,
                                           pInfo->aRegValues[i].ValueType,
                                           SCE_STATUS_MISMATCH
                                           );
                            }
                        } else {
                            //
                            // was a not configure/not analyze item
                            //
                            rc = ScepSaveRegValueEntry(
                                       hSectionSap,
                                       pInfo->aRegValues[i].FullValueName,
                                       NULL,
                                       pInfo->aRegValues[i].ValueType,
                                       SCE_STATUS_NOT_ANALYZED
                                       );
                        }
                    }
                }

                if ( !valNewScep ) {
                    //
                    // delete Scep
                    //
                    rc = SceJetDelete(
                                hSectionSmp,
                                pInfo->aRegValues[i].FullValueName,
                                FALSE,
                                SCEJET_DELETE_LINE_NO_CASE
                                );
                } else {
                    //
                    // update SMP
                    //
                    rc = ScepSaveRegValueEntry(
                                hSectionSmp,
                                pInfo->aRegValues[i].FullValueName,
                                valNewScep,
                                pInfo->aRegValues[i].ValueType,
                                0
                                );
                }

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    //
                    // if not find for delete, ignore the error
                    //
                    rc = SCESTATUS_SUCCESS;
                }

                if ( SCESTATUS_SUCCESS != rc ) {
                    break;
                }

            }

            SceJetCloseSection(&hSectionSap, TRUE);
        }
        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);
}


SCESTATUS
ScepSaveRegValueEntry(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PWSTR CurrentValue,
    IN DWORD dType,
    IN DWORD Status
    )
/* ++
Routine Description:


Arguments:

    hSection - The JET section context

    Name    - The entry name

    CurrentValue - The current system setting (DWORD value)

    dType   - the registry value type

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS  rc;
    PWSTR     StrValue;
    DWORD     Len=0;

    if ( Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);


    if ( CurrentValue == NULL && Status == 0 ) {
        //
        // delete this entry
        //
        rc = SceJetDelete( hSection,
                           Name,
                           FALSE,
                           SCEJET_DELETE_LINE_NO_CASE);
        return (rc);
    }

    //
    // update this entry
    //

    if ( CurrentValue ) {
        Len = wcslen(CurrentValue);
    }

    StrValue = (PWSTR)ScepAlloc(0, (Len+4)*sizeof(WCHAR));

    if ( StrValue ) {

        *((CHAR *)StrValue) = (BYTE)(dType % 10) + '0';
        *((CHAR *)StrValue+1) = (BYTE)Status + '0';

//      swprintf(StrValue, L"%1d", dType);
        StrValue[1] = L'\0';

        if ( CurrentValue ) {

            // there are binary data here
            memcpy(StrValue+2, CurrentValue, Len*2);
        }
        StrValue[Len+2] = L'\0';
        StrValue[Len+3] = L'\0';

        if ( REG_MULTI_SZ == dType ) {
            //
            // convert the , to null
            //
            ScepConvertMultiSzToDelim(StrValue+2, Len+1, L',', L'\0');

        }
        rc = SceJetSetLine( hSection, Name, FALSE, StrValue, (Len+3)*2, 0);

        ScepFree(StrValue);

    } else {
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    return(rc);

}


SCESTATUS
ScepUpdatePrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pNewPriv,
    IN PSCE_PRIVILEGE_ASSIGNMENT *pScepPriv
    )
/*
Routine Description:

    Update privileges

Arguements:

    hProfile - the jet database handle

    pNewPriv    - the changed info buffer

    pBufScep - the original SMP priv buffer

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;
    PSCE_PRIVILEGE_ASSIGNMENT pPriv, pNode, pParent;
    DWORD NameLen;


    if ( pScepPriv == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pNewPriv == NULL && *pScepPriv == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    LSA_HANDLE LsaHandle=NULL;

    rc = RtlNtStatusToDosError(
              ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &LsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {
        return(ScepDosErrorToSceStatus(rc));
    }

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szPrivilegeRights,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    szPrivilegeRights,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            //
            // convert pNewPriv to Name/*SID format (from all name format)
            //
            PSCE_PRIVILEGE_ASSIGNMENT pConvertedPriv=NULL;

            rc = ScepConvertPrivilegeList(LsaHandle,
                                         pNewPriv,
                                         0,
                                         SCE_ACCOUNT_SID_STRING,
                                         &pConvertedPriv);

            if ( ERROR_SUCCESS != rc ) {
                //
                // use the original list
                //
                pPriv = pNewPriv;
            } else {
                pPriv = pConvertedPriv;
            }

            for ( ; pPriv != NULL; pPriv = pPriv->Next ) {
                //
                // Process each privilege in the new list
                //
                if ( pPriv->Name == NULL ) {
                    continue;
                }
                NameLen = wcslen(pPriv->Name);

                //
                // look for the matched SMP
                //
                for ( pNode=*pScepPriv, pParent=NULL; pNode != NULL;
                      pParent = pNode, pNode = pNode->Next ) {

                    if ( pNode->Name == NULL ) {
                        continue;
                    }
                    if ( _wcsicmp(pPriv->Name, pNode->Name) == 0 ) {
                        break;
                    }
                }


                rc = ScepUpdateKeyNameList(
                        LsaHandle,
                        hSectionSmp,
                        hSectionSap,
                        NULL, // not a group
                        ( pNode == NULL ) ? FALSE : TRUE,
                        pPriv->Name,
                        NameLen,
                        pPriv->AssignedTo,
                        ( pNode == NULL ) ? NULL : pNode->AssignedTo,
                        SCE_FLAG_UPDATE_PRIV
                        );

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    rc = SCESTATUS_SUCCESS;

                } else if ( rc != SCESTATUS_SUCCESS) {
                    break;
                }

                //
                // remove the SMP node from pScepPriv
                //
                if ( pNode != NULL ) {

                    //
                    // link to the next
                    //
                    if ( pParent != NULL ) {
                        pParent->Next = pNode->Next;

                    } else {
                        *pScepPriv = pNode->Next;
                    }
                    //
                    // delete this node
                    //
                    ScepFreeNameList(pNode->AssignedTo);
                    ScepFree(pNode->Name);
                    ScepFree(pNode);
                    pNode = NULL;
                }
            }

            if ( pConvertedPriv ) {
                //
                // free the new list
                //
                ScepFreePrivilege( pConvertedPriv );
                pConvertedPriv = NULL;
            }

            //
            // delete remaining SMP entries, do not care error code
            //
            if ( rc == SCESTATUS_SUCCESS ) {

                for (pNode=*pScepPriv; pNode != NULL; pNode = pNode->Next ) {
                    //
                    // raise SAP entries first
                    //
                    if ( pNode->Name == NULL ) {
                        continue;
                    }
                    NameLen = wcslen(pNode->Name);

                    rc = SceJetSeek(
                            hSectionSap,
                            pNode->Name,
                            NameLen*sizeof(WCHAR),
                            SCEJET_SEEK_EQ_NO_CASE
                            );

                    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                        //
                        // pNode->AssignedTo is already in name, *SID format
                        // no need to convert
                        //
                        rc = ScepWriteNameListValue(
                                LsaHandle,
                                hSectionSap,
                                pNode->Name,
                                pNode->AssignedTo,
                                SCE_WRITE_EMPTY_LIST,
                                0
                                );
                    }

                    if ( rc == SCESTATUS_SUCCESS ) {
                        rc = SceJetDelete(
                                    hSectionSmp,
                                    pNode->Name,
                                    FALSE,
                                    SCEJET_DELETE_LINE_NO_CASE
                                    );
                        if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
                            rc = SCESTATUS_SUCCESS;
                        }
                    }
                    if ( rc != SCESTATUS_SUCCESS ) {
                        break;
                    }
                }
            }

            SceJetCloseSection(&hSectionSap, TRUE);
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);
}



SCESTATUS
ScepGetKeyNameList(
   IN LSA_HANDLE LsaPolicy,
   IN PSCESECTION hSection,
   IN PWSTR Key,
   IN DWORD KeyLen,
   IN DWORD dwAccountFormat,
   OUT PSCE_NAME_LIST *pNameList
   )
/* ++
Routine Description:

   Read multi-sz format value for the key from the section into a name list
   structure

Arguments:

   hSection - the section handle

   Key - the key name

   KeyLen - the key length

   pNameList - the name list of multi-sz value

Return Value:

   SCE status

-- */
{
    SCESTATUS      rc;
    PWSTR         Value=NULL;

    PSCE_NAME_STATUS_LIST       pPrivilegeList=NULL;

    DWORD         ValueLen;
    DWORD         Len;
    PWSTR         pTemp;


    if ( hSection == NULL || pNameList == NULL || Key == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }
    //
    // goto the key
    //
    rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                Key,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueLen
                );

    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }

    //
    // allocate memory for the group name and value string
    //
    Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

    if ( Value == NULL )
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    //
    // Get the group and its value
    //
    rc = SceJetGetValue(
                hSection,
                SCEJET_CURRENT,
                NULL,
                NULL,
                0,
                NULL,
                Value,
                ValueLen,
                &ValueLen
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // add the multi-sz value string to the node, depending on the value type
        //
        pTemp = Value;
        while ( rc == SCESTATUS_SUCCESS && pTemp != NULL && pTemp[0]) {

            Len = wcslen(pTemp);

            if ( dwAccountFormat == 0 && pTemp[0] == L'*' ) {
                //
                // convert *SID to name
                //
                rc = ScepLookupSidStringAndAddToNameList(
                                LsaPolicy,
                                pNameList,
                                pTemp, // +1,
                                Len    // -1
                                );

            } else {
                rc = ScepAddToNameList(pNameList, pTemp, Len );

            }

            pTemp += Len +1;

        }

        //
        // Free the list if error
        //
        if ( rc != SCESTATUS_SUCCESS && *pNameList != NULL ) {

            ScepFreeNameList(*pNameList);
            *pNameList = NULL;

        }
    }

    ScepFree(Value);

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    return(rc);

}


BYTE
ScepGetObjectAnalysisStatus(
    IN PSCESECTION hSection,
    IN PWSTR KeyName,
    IN BOOL bLookForParent
    )
/*

Routine Description:

    Get analysis status for the KeyName specified. If bLookForParent is TRUE,
    check for the closest parent status instead of this KeyName.

*/
{

    WCHAR StatusFlag=L'\0';
    BYTE Status=(BYTE)-1;

    DWORD Len;
    SCESTATUS rc=SCESTATUS_SUCCESS;
    PWSTR Buffer=NULL, pTemp;

    pTemp = KeyName;

    while ( TRUE ) {

        if ( bLookForParent ) {

            pTemp = wcschr(pTemp, L'\\');
            if ( pTemp ) {
                Len = (DWORD)(pTemp-KeyName);

                Buffer = (PWSTR)ScepAlloc(0, (Len+1)*sizeof(WCHAR));
                if ( Buffer ) {
                    memcpy(Buffer, KeyName, Len*sizeof(WCHAR));
                    Buffer[Len] = L'\0';
                } else {
                    // no memory
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }
            } else {
                Buffer = KeyName;
            }
        } else {
            Buffer = KeyName;
        }

        rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                Buffer,
                NULL,
                0,
                NULL,
                (PWSTR)&StatusFlag,
                2,
                &Len
                );
        if ( Buffer != KeyName ) {
            ScepFree(Buffer);
            Buffer = NULL;
        }

        if ( SCESTATUS_SUCCESS == rc ||
             SCESTATUS_BUFFER_TOO_SMALL == rc ) {
            //
            // find the record
            //
            Status = *((BYTE *)&StatusFlag);
        } else if ( rc != SCESTATUS_RECORD_NOT_FOUND ) {
            break;
        }
        rc = SCESTATUS_SUCCESS;

        if ( bLookForParent && pTemp ) {
            pTemp++;
        } else {
            // the end
            break;
        }
    }

    if ( SCESTATUS_SUCCESS == rc ) {
        return Status;
    }

    return (BYTE)-1;

}

DWORD
ScepQueryAnalysisStatus(
    IN PSCESECTION hSection,
    IN PWSTR KeyName,
    IN DWORD NameLen
    )
{

    DWORD dwSapStatus = SCE_STATUS_GOOD;

    SCESTATUS rc = SceJetSeek(
                        hSection,
                        KeyName,
                        NameLen*sizeof(WCHAR),
                        SCEJET_SEEK_EQ_NO_CASE
                        );

    if ( rc == SCESTATUS_SUCCESS ) {

        dwSapStatus = SCE_STATUS_MISMATCH;

        //
        // check if this is errored item, or not analyzed item
        //
        TCHAR szErrorValue[20];
        DWORD ValueLen;

        szErrorValue[0] = L'\0';

        rc = SceJetGetValue(
                    hSection,
                    SCEJET_CURRENT,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    szErrorValue,
                    20*sizeof(TCHAR),
                    &ValueLen
                    );
        if ( SCESTATUS_SUCCESS == rc ||
             SCESTATUS_BUFFER_TOO_SMALL == rc ) {

            if ( szErrorValue[0] == L' ' ) {
                dwSapStatus = SCE_STATUS_NOT_ANALYZED;

            } else if ( _wcsicmp( SCE_ERROR_STRING, szErrorValue ) == 0 ) {
                //
                // this group is errored or not analyzed
                //
                dwSapStatus = SCE_STATUS_ERROR_NOT_AVAILABLE;
            }
        }
    }

    return dwSapStatus;
}


SCESTATUS
ScepUpdateKeyNameList(
    IN LSA_HANDLE LsaPolicy,
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR GroupName OPTIONAL,
    IN BOOL bScepExist,
    IN PWSTR KeyName,
    IN DWORD NameLen,
    IN PSCE_NAME_LIST pNewList,
    IN PSCE_NAME_LIST pScepList,
    IN DWORD flag
    )
/*
Routine Description:

    Update multi-sz format value for a Key

Arguements:

    hSectionSmp - the SMP section handle

    hSectionSap - the SAP section handle

    bScepExist  - if th ekey exist in SMP

    KeyName - the key name

    NameLen  - the name length

    pNewList - the new value to update to

    pScepList - the original value to update

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc=SCESTATUS_SUCCESS;
    PSCE_NAME_LIST pSapList=NULL;

    if ( hSectionSmp == NULL || hSectionSap == NULL || KeyName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD dwSapExist=ScepQueryAnalysisStatus(hSectionSap,
                                             KeyName,
                                             NameLen
                                            );

    if ( GroupName && (flag == SCE_FLAG_UPDATE_MEMBEROF) ) {
        //
        // this is for group membership (memberof) update
        //
        DWORD TmpLen = wcslen(GroupName)+wcslen(szMembers);
        PWSTR TmpStr = (PWSTR)ScepAlloc(LPTR, (TmpLen+1)*sizeof(WCHAR));

        if ( TmpStr ) {

            swprintf(TmpStr, L"%s%s\0", GroupName, szMembers);

            DWORD dwTmp = ScepQueryAnalysisStatus(hSectionSap,
                                                     TmpStr,
                                                     TmpLen
                                                    );

            if ( dwTmp == SCE_STATUS_NOT_ANALYZED ||
                 dwTmp == SCE_STATUS_ERROR_NOT_AVAILABLE ) {
                dwSapExist = dwTmp;
            }

            ScepFree(TmpStr);

        } else {
            // ignore this error
        }

    }

    switch ( dwSapExist ) {
    case SCE_STATUS_GOOD:

        //
        // SAP entry does not exist -- matched
        //
        if ( bScepExist ) {
            //
            // SMP entry exist
            //
            if ( !SceCompareNameList(pNewList, pScepList) ) {
                //
                // new SMP does not match SAP. SAP entry should be created with SMP
                // for privileges, it's already in SID/name format, no need to convert
                //
                rc = ScepWriteNameListValue(
                        LsaPolicy,
                        hSectionSap,
                        KeyName,
                        pScepList,
                        GroupName ? (SCE_WRITE_EMPTY_LIST | SCE_WRITE_CONVERT) :
                         SCE_WRITE_EMPTY_LIST,
                        0
                        );
            }

        } else {
            //
            // SMP entry does not exist. should not occur for privileges but
            // it is possible for group membership (new added group)
            // But if it occurs, create SAP entry with NULL
            //
            rc = SceJetSetLine(
                    hSectionSap,
                    KeyName,
                    FALSE,
                    L" ",
                    2,
                    0);
        }

        break;

    case SCE_STATUS_ERROR_NOT_AVAILABLE:
    case SCE_STATUS_NOT_ANALYZED:
        //
        // SAP entry errored or not analyzed
        // do not change SAP entry
        //
        break;

    default:

        //
        // SAP entry exists. -- mismatched or not configured
        //
        rc = ScepGetKeyNameList(
                LsaPolicy,
                hSectionSap,
                KeyName,
                NameLen,
                GroupName ? 0 : SCE_ACCOUNT_SID_STRING,
                &pSapList
                );
        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // Get the SAP assigned to list and compare
            //
            if ( SceCompareNameList(pNewList, pSapList) ) {
                //
                // new SMP is the same as SAP, delete SAP entry
                //
                rc = SceJetDelete(
                        hSectionSap,
                        KeyName,
                        FALSE,
                        SCEJET_DELETE_LINE_NO_CASE
                        );
            }
            //
            // free the Sap list
            //
            ScepFreeNameList(pSapList);
            pSapList = NULL;
        }

        break;
    }

    if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        //
        // Update SMP with new value
        //
        rc = ScepWriteNameListValue(
                LsaPolicy,
                hSectionSmp,
                KeyName,
                pNewList,
                GroupName ? (SCE_WRITE_EMPTY_LIST | SCE_WRITE_CONVERT) :
                    SCE_WRITE_EMPTY_LIST,
                0
                );
    }

    return(rc);
}


SCESTATUS
ScepUpdateGroupMembership(
    IN PSCECONTEXT hProfile,
    IN PSCE_GROUP_MEMBERSHIP pNewGroup,
    IN PSCE_GROUP_MEMBERSHIP *pScepGroup
    )
/*
Routine Description:

    Update group membership section

Arguements:

    hProfile - the jet database handle

    pNewGroup    - the changed info buffer

    pScepGroup - the original SMP buffer

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;
    PSCE_GROUP_MEMBERSHIP pGroup, pNode, pParent;
    DWORD NameLen, MembersLen, MemberofLen;
    PWSTR KeyName=NULL;
    PWSTR SidString=NULL;


    if ( pScepGroup == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pNewGroup == NULL && *pScepGroup == NULL ) {
        return(SCESTATUS_SUCCESS);
    }


    LSA_HANDLE LsaHandle=NULL;

    rc = RtlNtStatusToDosError(
              ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &LsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {
        return(ScepDosErrorToSceStatus(rc));
    }

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szGroupMembership,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    szGroupMembership,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            MemberofLen = wcslen(szMemberof);
            MembersLen = wcslen(szMembers);


            for ( pGroup=pNewGroup; pGroup != NULL; pGroup = pGroup->Next ) {
                //
                // Process each group members and memberof in the new list
                //
                if ( !(pGroup->GroupName) ) {
                    continue;
                }

                if ( (pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) &&
                     (pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF ) ) {
                    continue;
                }

                if ( wcschr(pGroup->GroupName, L'\\') ) {
                    //
                    // this is in account domain format, convert it to sid string
                    //
                    NameLen = 0;

                    ScepConvertNameToSidString(
                                LsaHandle,
                                pGroup->GroupName,
                                FALSE,
                                &SidString,
                                &NameLen
                                );
                } else {

                    if ( ScepLookupWellKnownName( 
                            pGroup->GroupName, 
                            LsaHandle,
                            &SidString ) ) {
                        NameLen = wcslen(SidString);
                    } else {
                        SidString = NULL;
                    }
                }

                if ( SidString == NULL ) {
                    NameLen = wcslen(pGroup->GroupName);
                }

                KeyName = (PWSTR)ScepAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                          (NameLen+MemberofLen+1)*sizeof(WCHAR));

                if ( KeyName == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                } else {
                    //
                    // look for the matched SMP
                    //
                    for ( pNode=*pScepGroup, pParent=NULL; pNode != NULL;
                          pParent = pNode, pNode = pNode->Next ) {

                        if ( _wcsicmp(pGroup->GroupName, pNode->GroupName) == 0 ) {
                            break;
                        }
                    }

                    if ( !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

                        //
                        // work for members first
                        //
                        if ( SidString ) {
                            swprintf(KeyName, L"%s%s\0", SidString, szMembers);
                        } else {
                            swprintf(KeyName, L"%s%s\0", pGroup->GroupName, szMembers);
                        }
                        KeyName = _wcslwr(KeyName);

                        rc = ScepUpdateKeyNameList(
                                LsaHandle,
                                hSectionSmp,
                                hSectionSap,
                                SidString ? SidString : pGroup->GroupName,  // group name
                                ( pNode == NULL || (pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS)) ? FALSE : TRUE,
                                KeyName,
                                NameLen+MembersLen,
                                pGroup->pMembers,
                                ( pNode == NULL ) ? NULL : pNode->pMembers,
                                SCE_FLAG_UPDATE_MEMBERS
                                );
                    }

                    if ( ( rc == SCESTATUS_SUCCESS ) &&
                         !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

                        //
                        // work for memberof second
                        //
                        if ( SidString ) {
                            swprintf(KeyName, L"%s%s\0", SidString, szMemberof);
                        } else {
                            swprintf(KeyName, L"%s%s\0", pGroup->GroupName, szMemberof);
                        }
                        KeyName = _wcslwr(KeyName);

                        rc = ScepUpdateKeyNameList(
                                LsaHandle,
                                hSectionSmp,
                                hSectionSap,
                                SidString ? SidString : pGroup->GroupName,
                                ( pNode == NULL || (pNode->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) ? FALSE : TRUE,
                                KeyName,
                                NameLen+MemberofLen,
                                pGroup->pMemberOf,
                                ( pNode == NULL ) ? NULL : pNode->pMemberOf,
                                SCE_FLAG_UPDATE_MEMBEROF
                                );
                    }

                    ScepFree(KeyName);
                    KeyName = NULL;

                }

                if ( SidString ) {
                    LocalFree(SidString);
                    SidString = NULL;
                }

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    rc = SCESTATUS_SUCCESS;

                } else if ( rc != SCESTATUS_SUCCESS) {
                    break;
                }

                //
                // remove the SMP node/or portion from pScepPriv
                //
                if ( pNode != NULL ) {

                    if ( !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) &&
                         !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {

                        //
                        // both of members and memberof are processed
                        // link to the next
                        //
                        if ( pParent != NULL ) {
                            pParent->Next = pNode->Next;

                        } else {
                            *pScepGroup = pNode->Next;
                        }
                        //
                        // delete this node
                        //
                        ScepFreeNameList(pNode->pMembers);
                        ScepFreeNameList(pNode->pMemberOf);
                        ScepFreeNameStatusList(pNode->pPrivilegesHeld);

                        ScepFree(pNode->GroupName);
                        ScepFree(pNode);
                        pNode = NULL;

                    } else {

                        if (!(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

                            pNode->Status |= SCE_GROUP_STATUS_NC_MEMBERS;
                            ScepFreeNameList(pNode->pMembers);
                            pNode->pMembers = NULL;
                        }

                        if ( !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {

                            pNode->Status |= SCE_GROUP_STATUS_NC_MEMBEROF;
                            ScepFreeNameList(pNode->pMemberOf);
                            pNode->pMemberOf = NULL;
                        }
                    }
                }
            }

            //
            // delete remaining SMP entries, do not care error code
            //
            if ( rc == SCESTATUS_SUCCESS ) {
                for (pNode=*pScepGroup; pNode != NULL; pNode = pNode->Next ) {
                    //
                    // raise SAP if it's not there
                    //
                    if ( pNode->GroupName == NULL ) {
                        continue;
                    }

                    if ( (pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS) &&
                         (pNode->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {
                        continue;
                    }

                    if ( wcschr(pNode->GroupName, L'\\') ) {
                        //
                        // this is in account domain format, convert it to sid string
                        //
                        NameLen = 0;

                        ScepConvertNameToSidString(
                                    LsaHandle,
                                    pNode->GroupName,
                                    FALSE,
                                    &SidString,
                                    &NameLen
                                    );
                    } else {
                        if ( ScepLookupWellKnownName( 
                                pNode->GroupName, 
                                LsaHandle,
                                &SidString ) ) {
                            NameLen = wcslen(SidString);
                        } else {
                            SidString = NULL;
                        }
                    }

                    if ( SidString == NULL ) {
                        NameLen = wcslen(pNode->GroupName);
                    }

                    KeyName = (PWSTR)ScepAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                              (NameLen+MemberofLen+1)*sizeof(WCHAR));

                    if ( KeyName == NULL ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                    } else {

                        BOOL bSapError=FALSE;

                        if ( SidString ) {
                            swprintf(KeyName, L"%s%s\0", SidString, szMembers);
                        } else {
                            swprintf(KeyName, L"%s%s\0", pNode->GroupName, szMembers);
                        }

                        if ( !(pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

                            //
                            // members configuration has to be deleted.
                            //
                            rc = SceJetDelete(
                                    hSectionSmp,
                                    KeyName,
                                    FALSE,
                                    SCEJET_DELETE_LINE_NO_CASE
                                    );
                        }

                        if ( SCESTATUS_SUCCESS == rc ) {

                            rc = ScepQueryAnalysisStatus(hSectionSap,
                                                         KeyName,
                                                         NameLen+MembersLen
                                                        );

                            if ( rc == SCE_STATUS_NOT_ANALYZED ||
                                 rc == SCE_STATUS_ERROR_NOT_AVAILABLE ) {
                                //
                                // the entire group is analyzed with error
                                // or the group is new added
                                //
                                if ( !(pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS) &&
                                     !(pNode->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {
                                    //
                                    // the SAP should be removed because both members and
                                    // memberof are deleted
                                    //
                                    rc = SceJetDelete(
                                            hSectionSap,
                                            SidString ? SidString : pNode->GroupName,
                                            FALSE,
                                            SCEJET_DELETE_PARTIAL_NO_CASE
                                            );
                                } else {
                                    // else leave the SAP stuff there.
                                    rc = SCESTATUS_SUCCESS;
                                }
                                bSapError = TRUE;

                            } else {

                                if ( !(pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

                                    if ( rc == SCE_STATUS_GOOD ) {

                                        //
                                        // SAP doesn't exist, this is a match group members
                                        // remove SMP means this group becomes not configured
                                        //

                                        rc = ScepWriteNameListValue(
                                                LsaHandle,
                                                hSectionSap,
                                                KeyName,
                                                pNode->pMembers,
                                                SCE_WRITE_EMPTY_LIST | SCE_WRITE_CONVERT,
                                                0
                                                );
                                    } else {
                                        //
                                        // it's already mismatched. do nothing to SAP table
                                        //
                                        rc = SCESTATUS_SUCCESS;

                                    }
                                } else {
                                    rc = SCESTATUS_SUCCESS;
                                }
                            }
                        }

                        if ( SCESTATUS_SUCCESS == rc ) {

                            //
                            // continue to process memberof
                            //
                            if ( !(pNode->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {

                                if ( SidString ) {
                                    swprintf(KeyName, L"%s%s\0", SidString, szMemberof);
                                } else {
                                    swprintf(KeyName, L"%s%s\0", pNode->GroupName, szMemberof);
                                }

                                //
                                // delete configuration
                                //
                                rc = SceJetDelete(
                                        hSectionSmp,
                                        KeyName,
                                        FALSE,
                                        SCEJET_DELETE_LINE_NO_CASE
                                        );

                                if ( (SCESTATUS_SUCCESS == rc) && !bSapError ) {

                                    rc = SceJetSeek(
                                        hSectionSap,
                                        KeyName,
                                        (NameLen+MemberofLen)*sizeof(WCHAR),
                                        SCEJET_SEEK_EQ_NO_CASE
                                        );

                                    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

                                        //
                                        // SAP doesn't exist, this is a match group membership
                                        // remove SMP means membership becomes "not configured"
                                        //

                                        rc = ScepWriteNameListValue(
                                                LsaHandle,
                                                hSectionSap,
                                                KeyName,
                                                pNode->pMemberOf,
                                                SCE_WRITE_EMPTY_LIST | SCE_WRITE_CONVERT,
                                                0
                                                );
                                    } else {
                                        //
                                        // a mismatch item already
                                        //
                                    }
                                }
                            }
                        }

                        ScepFree(KeyName);
                        KeyName = NULL;
                    }

                    if ( SidString ) {
                        LocalFree(SidString);
                        SidString = NULL;
                    }

                    if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
                        rc = SCESTATUS_SUCCESS;
                    }

                    if ( rc != SCESTATUS_SUCCESS ) {
                        break;
                    }
                }
            }

            SceJetCloseSection(&hSectionSap, TRUE);
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);

}


SCESTATUS
ScepUpdateGeneralServices(
    IN PSCECONTEXT hProfile,
    IN PSCE_SERVICES pNewServices,
    IN PSCE_SERVICES *pScepServices
    )
/*
Routine Description:

    Update general services section

Arguements:

    hProfile - the jet database handle

    pNewServices - the new server list

    pScepServices - the original SMP service list

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;
    PSCE_SERVICES pService, pNode, pParent;
    PSCE_SERVICES pSapService=NULL;
    BOOL IsDifferent;

    if ( pScepServices == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pNewServices == NULL && *pScepServices == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szServiceGeneral,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    szServiceGeneral,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            for ( pService=pNewServices; pService != NULL; pService = pService->Next ) {
                //
                // look for the matched SMP
                //
                for ( pNode=*pScepServices, pParent=NULL; pNode != NULL;
                      pParent = pNode, pNode = pNode->Next ) {

                    if ( _wcsicmp(pService->ServiceName, pNode->ServiceName) == 0 ) {
                        break;
                    }
                }

                //
                // get Sap
                //
                rc = ScepGetSingleServiceSetting(
                        hSectionSap,
                        pService->ServiceName,
                        &pSapService
                        );

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // old status is mismatch, error, no not analyzed for this item
                    //
                    if ( pSapService &&
                         ( pSapService->Status == SCE_STATUS_NOT_ANALYZED ||
                           pSapService->Status == SCE_STATUS_ERROR_NOT_AVAILABLE ) ) {
                        // do not change SAP
                    } else {

                        rc = ScepCompareSingleServiceSetting(
                                        pService,
                                        pSapService,
                                        &IsDifferent
                                        );
                        if ( rc == SCESTATUS_SUCCESS ) {

                            if ( !IsDifferent ) {
                                //
                                // now it is matched, delete the SAP entry
                                //
                                SceJetDelete(
                                    hSectionSap,
                                    pService->ServiceName,
                                    FALSE,
                                    SCEJET_DELETE_LINE_NO_CASE
                                    );
                            }
                        }
                    }
                    if ( SCESTATUS_SUCCESS == rc ) {

                        //
                        // update the SMP entry
                        //
                        rc = ScepSetSingleServiceSetting(
                                    hSectionSmp,
                                    pService
                                    );
                    }

                    SceFreePSCE_SERVICES(pSapService);
                    pSapService = NULL;

                } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    //
                    // old status is matched or new added
                    //
                    if ( pNode == NULL ) {
                        //
                        // new added, add SMP first
                        //
                        rc = ScepSetSingleServiceSetting(
                                    hSectionSmp,
                                    pService
                                    );
                        if ( rc == SCESTATUS_SUCCESS) {
                            pService->Status = SCE_STATUS_NOT_ANALYZED;
                            //
                            // raise SAP
                            //
                            rc = ScepSetSingleServiceSetting(
                                        hSectionSap,
                                        pService
                                        );
                        }
                    } else {
                        rc = ScepCompareSingleServiceSetting(
                                        pService,
                                        pNode,
                                        &IsDifferent
                                        );
                        if ( rc == SCESTATUS_SUCCESS ) {

                            if ( IsDifferent ) {
                                //
                                // mismatch should be raised with valScep
                                //
                                pNode->Status = SCE_STATUS_MISMATCH;
                                rc = ScepSetSingleServiceSetting(
                                            hSectionSap,
                                            pNode
                                            );
                                if ( rc == SCESTATUS_SUCCESS) {
                                    //
                                    // update SMP
                                    //
                                    rc = ScepSetSingleServiceSetting(
                                                hSectionSmp,
                                                pService
                                                );
                                }
                            }
                        }
                    }
                }

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    rc = SCESTATUS_SUCCESS;

                } else if ( rc != SCESTATUS_SUCCESS) {
                    break;
                }

                //
                // remove the SMP node from old configuration
                //
                if ( pNode != NULL ) {

                    //
                    // link to the next
                    //
                    if ( pParent != NULL ) {
                        pParent->Next = pNode->Next;

                    } else {
                        *pScepServices = pNode->Next;
                    }
                    //
                    // delete this node
                    //
                    ScepFree(pNode->ServiceName);
                    if (pNode->General.pSecurityDescriptor)
                        ScepFree(pNode->General.pSecurityDescriptor);

                    ScepFree(pNode);
                    pNode = NULL;
                }
            }

            //
            // delete remaining SMP entries, do not care error code
            //
            if ( rc == SCESTATUS_SUCCESS ) {
                for (pNode=*pScepServices; pNode != NULL; pNode = pNode->Next ) {

                    //
                    // first change SAP entry
                    //
                    rc = SceJetSeek(
                            hSectionSap,
                            pNode->ServiceName,
                            wcslen(pNode->ServiceName)*sizeof(WCHAR),
                            SCEJET_SEEK_EQ_NO_CASE
                            );

                    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
                        //
                        // was a match item
                        //
                        pNode->Status = SCE_STATUS_NOT_CONFIGURED;
                        rc = ScepSetSingleServiceSetting(
                                    hSectionSap,
                                    pNode
                                    );
                    }

                    if ( rc == SCESTATUS_SUCCESS ||
                         rc == SCESTATUS_RECORD_NOT_FOUND ) {

                        //
                        // delete SMP - it's taken out of the service list
                        //
                        rc = SceJetDelete(
                                hSectionSmp,
                                pNode->ServiceName,
                                FALSE,
                                SCEJET_DELETE_LINE_NO_CASE
                                );
                    }

                    if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
                        rc = SCESTATUS_SUCCESS;
                    }

                    if ( rc != SCESTATUS_SUCCESS ) {
                        break;
                    }
                }
            }

            SceJetCloseSection(&hSectionSap, TRUE);
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);
}


SCESTATUS
ScepUpdateObjectInfo(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    IN DWORD NameLen, // number of characters
    IN BYTE ConfigStatus,
    IN BOOL  IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    )
/*
Routine Description:

    Determine related changes to the object's parent(s), child(ren) in SMP and SAP
    database then update the SMP entry for the object. Refer to objedit.doc for
    the rule to update database.

Arguments:

    hProfile - the database handle

    Area - security area to update (file, registry, ds)

    ObjectName - object name in full name

    NameLen - the length of the object name

    ConfigStatus - the flag changed to

    IsContainer - if the object is a container type

    pSD - the security descriptor for the object

    SeInfo - the security information for the object

    pAnalysisStatus - output status of analysis for the object

Return Value:

    SCE status
*/
{
    SCESTATUS rc;
    PCWSTR SectionName;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;
    SE_OBJECT_TYPE ObjectType;

    HKEY            hKey;

    PWSTR JetName;
    DWORD NewNameLen;

    if ( hProfile == NULL || ObjectName == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( (ConfigStatus > SCE_STATUS_NO_AUTO_INHERIT ||
          ConfigStatus < SCE_STATUS_CHECK) &&
          (BYTE)SCE_NO_VALUE != ConfigStatus &&
          (DWORD)SCE_NO_VALUE != (DWORD)ConfigStatus ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    switch(Area) {
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        ObjectType = SE_REGISTRY_KEY;

        rc = ScepOpenRegistryObject(
                    ObjectType,
                    ObjectName,
                    KEY_READ,
                    &hKey
                    );

        if ( rc == ERROR_SUCCESS ) {
            RegCloseKey(hKey);

        } else {
            //
            // not find the key
            //
            return(SCESTATUS_INVALID_DATA);
        }

        JetName = ObjectName;
        NewNameLen = NameLen;

        break;

    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        ObjectType = SE_FILE_OBJECT;

        if ( ObjectName[0] == L'\\' ) {  // UNC name format
            return(SCESTATUS_INVALID_PARAMETER);
        }

        if ( 0xFFFFFFFF == GetFileAttributes(ObjectName) ) {
            return(SCESTATUS_INVALID_DATA);
        }

        JetName = ObjectName;
        NewNameLen = NameLen;
        break;
#if 0
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        ObjectType = SE_DS_OBJECT;

        rc = ScepLdapOpen(NULL);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // detect if the Ds object exist
            //
            rc = ScepDsObjectExist(ObjectName);

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // convert LDAP name to Jet index name
                //
                rc = ScepConvertLdapToJetIndexName(
                            ObjectName,
                            &JetName
                            );
            }
        }
        if ( rc != SCESTATUS_SUCCESS ) {

            ScepLdapClose(NULL);
            return(rc);
        }

        NewNameLen = wcslen(JetName);

        break;
#endif

    default:

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pAnalysisStatus ) {
        *pAnalysisStatus = (BYTE)SCE_NO_VALUE;
    }
    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                SectionName,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    SectionName,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS) {

            //
            // Start a transaction so all updates related to this object is atomic
            //
            rc = SceJetStartTransaction( hProfile );

            if ( rc == SCESTATUS_SUCCESS ) {

                rc = SceJetSeek(
                        hSectionSmp,
                        JetName,
                        NewNameLen*sizeof(WCHAR),
                        SCEJET_SEEK_EQ_NO_CASE
                        );

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // existing SMP object
                    //
                    if ( (BYTE)SCE_NO_VALUE == ConfigStatus ||
                         (DWORD)SCE_NO_VALUE == (DWORD)ConfigStatus ) {
                        //
                        // get the old configure flag
                        //
                        WCHAR StatusFlag;
                        BYTE ScepStatus=0;
                        DWORD Len;

                        rc = SceJetGetValue(
                                hSectionSmp,
                                SCEJET_CURRENT,
                                NULL,
                                NULL,
                                0,
                                NULL,
                                (PWSTR)&StatusFlag,
                                2,
                                &Len
                                );

                        if ( SCESTATUS_SUCCESS == rc ||
                             SCESTATUS_BUFFER_TOO_SMALL == rc ) {
                            //
                            // find the record
                            //
                            ScepStatus = *((BYTE *)&StatusFlag);

                            //
                            // update SAP entries.
                            //
                            rc = ScepObjectAdjustNode(
                                      hSectionSmp,
                                      hSectionSap,
                                      JetName,
                                      NewNameLen,
                                      ObjectType,
                                      ScepStatus,
                                      IsContainer,
                                      NULL,
                                      0,
                                      FALSE, // remove the node
                                      pAnalysisStatus
                                      );

                            if ( SCESTATUS_SUCCESS == rc ) {
                                //
                                // delete the SMP entry
                                //
                                rc = SceJetDelete(
                                        hSectionSmp,
                                        JetName,
                                        FALSE,
                                        SCEJET_DELETE_LINE_NO_CASE
                                        );
                            }

                        }

                    } else {

                        rc = ScepObjectUpdateExistingNode(
                                    hSectionSmp,
                                    hSectionSap,
                                    JetName,
                                    NewNameLen,
                                    ObjectType,
                                    ConfigStatus,
                                    IsContainer,
                                    pSD,
                                    SeInfo,
                                    pAnalysisStatus
                                    );

                        if ( rc == SCESTATUS_SUCCESS ) {
                            //
                            // Update the SMP record
                            //
                            rc = ScepObjectSetKeySetting(
                                hSectionSmp,
                                JetName,
                                ConfigStatus,
                                IsContainer,
                                pSD,
                                SeInfo,
                                TRUE
                                );
                        }
                    }

                } else if ( rc == SCESTATUS_RECORD_NOT_FOUND &&
                           (BYTE)SCE_NO_VALUE != ConfigStatus &&
                           (DWORD)SCE_NO_VALUE != (DWORD)ConfigStatus ) {
                    //
                    // new added object
                    //
                    rc = ScepObjectAdjustNode(
                            hSectionSmp,
                            hSectionSap,
                            JetName,
                            NewNameLen,
                            ObjectType,
                            ConfigStatus,
                            IsContainer,
                            pSD,
                            SeInfo,
                            TRUE,  // add the node
                            pAnalysisStatus
                            );

                }

                if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
                    rc = SCESTATUS_SUCCESS;
                }
                //
                // Commit or Rollback the changes
                //
                if ( rc == SCESTATUS_SUCCESS ) {
                   //
                   // needs return code for commiting the transaction
                   //
                   rc = SceJetCommitTransaction(hProfile, 0);

                }
                if ( rc != SCESTATUS_SUCCESS ) {

                    SceJetRollback(hProfile, 0);
                }
            }

            SceJetCloseSection(&hSectionSap, TRUE);

        } else if ( rc == SCESTATUS_BAD_FORMAT ) {
            //
            // SMP exist, but SAP does not exist
            //
        }

        SceJetCloseSection(&hSectionSmp, TRUE);

    } else if ( rc == SCESTATUS_BAD_FORMAT ) {
        //
        // SMP section does not exist
        //
    }

    //
    // free stuff used for DS
    //
    if ( Area == AREA_DS_OBJECTS ) {

        ScepFree(JetName);

        ScepLdapClose(NULL);
    }

    return(rc);
}



SCESTATUS
ScepObjectUpdateExistingNode(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN SE_OBJECT_TYPE ObjectType,
    IN BYTE ConfigStatus,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    )
/*
Routine Description:

    Update an existing object

Arguements:

    see ScepUpdateObjectInfo

Return Value:

    SCESTATUS
*/
{
    SCESTATUS  rc;
    BYTE ScepStatus, SapStatus;
    PSECURITY_DESCRIPTOR pScepSD=NULL;
    SECURITY_INFORMATION ScepSeInfo;

    BYTE retStat = SCE_STATUS_NOT_ANALYZED;

    rc = ScepObjectGetKeySetting(
            hSectionSmp,
            ObjectName,
            &ScepStatus,
            NULL,
            &pScepSD,
            &ScepSeInfo
            );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // check for analysis status
        //
        SapStatus = ScepGetObjectAnalysisStatus(
                        hSectionSap,
                        ObjectName,
                        FALSE
                        );

        if ( ScepStatus == SCE_STATUS_IGNORE ) {
            //
            // no change is needed if update from IGNORE to IGNORE
            //
            if ( ConfigStatus != SCE_STATUS_IGNORE ) {

                //
                // N.A. the object (changed from N.C)
                //
                rc = ScepObjectSetKeySetting(
                        hSectionSap,
                        ObjectName,
                        SCE_STATUS_NOT_ANALYZED,
                        TRUE,
                        NULL,
                        0,
                        TRUE
                        );
            } else {

                if ( SapStatus == SCE_STATUS_NOT_CONFIGURED ) {
                    retStat = SapStatus;
                }
            }

        } else if ( ConfigStatus == SCE_STATUS_IGNORE ) {
            //
            // changed to ignore. delete all children from SMP & SAP
            //
            rc = ScepObjectDeleteScepAndAllChildren(
                    hSectionSmp,
                    hSectionSap,
                    ObjectName,
                    IsContainer,
                    SCE_STATUS_NOT_CONFIGURED
                    );

            retStat = SCE_STATUS_NOT_CONFIGURED;

        } else if ( SapStatus == SCE_STATUS_NOT_ANALYZED ) {
            //
            // was already added/modified, no need to update SAP
            // although children status may be mixed with C.C. or N.A.
            //
            if ( ConfigStatus == SCE_STATUS_OVERWRITE &&
                 ScepStatus != SCE_STATUS_OVERWRITE ) {

                //
                // change C.C children to N.A. children
                //

                rc = ScepObjectRaiseChildrenInBetween(
                             hSectionSmp,
                             hSectionSap,
                             ObjectName,
                             NameLen,
                             IsContainer,
                             SCE_STATUS_NOT_ANALYZED,
                             TRUE  // change status only
                             );

            } else if ( ConfigStatus != SCE_STATUS_OVERWRITE &&
                        ScepStatus == SCE_STATUS_OVERWRITE ) {

                //
                // change N.A. children to C.C. children
                //
                rc = ScepObjectRaiseChildrenInBetween(
                             hSectionSmp,
                             hSectionSap,
                             ObjectName,
                             NameLen,
                             IsContainer,
                             SCE_STATUS_CHILDREN_CONFIGURED,
                             TRUE  // change status only
                             );
            }

        } else {

            if ( ScepStatus == SCE_STATUS_OVERWRITE &&
                 ( ConfigStatus == SCE_STATUS_CHECK ||
                   ConfigStatus == SCE_STATUS_NO_AUTO_INHERIT ) ) {
                //
                // delete all mismatched status between this node
                // and its children; N.A. all nodes in between
                //
                rc = ScepObjectRaiseChildrenInBetween(
                             hSectionSmp,
                             hSectionSap,
                             ObjectName,
                             NameLen,
                             IsContainer,
                             SCE_STATUS_NOT_ANALYZED,
                             FALSE
                             );

            } else if ( ConfigStatus == SCE_STATUS_OVERWRITE &&
                        (ScepStatus == SCE_STATUS_CHECK ||
                         ScepStatus == SCE_STATUS_NO_AUTO_INHERIT) ) {
                //
                // change C.C children to N.A. children
                //
                rc = ScepObjectRaiseChildrenInBetween(
                             hSectionSmp,
                             hSectionSap,
                             ObjectName,
                             NameLen,
                             IsContainer,
                             SCE_STATUS_NOT_ANALYZED,
                             TRUE  // change status only
                             );
            }

            //
            // compare the current node status
            //
            if ( rc == SCESTATUS_SUCCESS ||
                 rc == SCESTATUS_RECORD_NOT_FOUND ) {

                if ( SapStatus == SCE_STATUS_ERROR_NOT_AVAILABLE ) {
                    // if errored, don't touch it.
                    retStat = SapStatus;
                    rc = SCESTATUS_SUCCESS;

                } else {
                    rc = ScepObjectCompareKeySetting(
                                hSectionSap,
                                ObjectName,
                                ObjectType,
                                TRUE,
                                pSD,
                                SeInfo,
                                pScepSD,
                                &retStat
                                );
                }
            }
        }

        if ( pScepSD ) {
            ScepFree(pScepSD);
        }
    }

    if ( pAnalysisStatus ) {
        *pAnalysisStatus = retStat;
    }

    return(rc);
}


SCESTATUS
ScepObjectGetKeySetting(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    OUT PBYTE Status,
    OUT PBOOL IsContainer OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor OPTIONAL,
    OUT PSECURITY_INFORMATION SeInfo OPTIONAL
    )
/*
Routine Description:

    Read settings for the object in the section

Arguements:

    hSection - the section handle

    others see ScepUpdateObjectInfo

Return Value:

    SCESTATUS
*/
{

    SCESTATUS        rc;
    PWSTR           Value=NULL;
    DWORD           ValueLen;

    PSECURITY_DESCRIPTOR pTempSD=NULL;
    SECURITY_INFORMATION tmpSeInfo;
    DWORD           SDsize, Win32Rc;

    if ( hSection == NULL || ObjectName == NULL || Status == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                ObjectName,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueLen
                );

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // allocate memory for value string
        //
        Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

        if ( Value == NULL )
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        //
        // Get the value
        //
        rc = SceJetGetValue(
                    hSection,
                    SCEJET_CURRENT,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    Value,
                    ValueLen,
                    &ValueLen
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            if (pSecurityDescriptor != NULL ) {
                //
                // convert security descriptor
                //
                Win32Rc = ConvertTextSecurityDescriptor(
                               Value+1,
                               &pTempSD,
                               &SDsize,
                               &tmpSeInfo
                               );
                if ( Win32Rc == NO_ERROR ) {

                    *pSecurityDescriptor = pTempSD;

                    if (tmpSeInfo )
                        *SeInfo = tmpSeInfo;

                } else
                    rc = ScepDosErrorToSceStatus(Win32Rc);
            }

            if ( rc == SCESTATUS_SUCCESS ) {

                *Status = *((BYTE *)Value);

                if ( IsContainer != NULL )
                    *IsContainer = *((CHAR *)Value+1) != '0' ? TRUE : FALSE;
            }
        }

        ScepFree(Value);

    }

    return(rc);
}


SCESTATUS
ScepObjectSetKeySetting(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    IN BYTE Status,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN BOOL bOverwrite
    )
/*
Routine Description:

    Set settings for the object in the section

Arguements:

    See ScepObjectGetKeySetting

    bOverwrite - if the new setting should overwrite existing settings

Return Value:

    SCESTATUS
*/
{
    SCESTATUS        rc;
    DWORD           SDsize=0, Win32Rc=NO_ERROR;
    PWSTR           SDspec=NULL;


    if ( hSection == NULL ||
         ObjectName == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !bOverwrite ) {
        rc = SceJetSeek(
               hSection,
               ObjectName,
               wcslen(ObjectName)*sizeof(WCHAR),
               SCEJET_SEEK_EQ_NO_CASE
               );

        if ( rc != SCESTATUS_RECORD_NOT_FOUND ) {
            //
            // if found it, do not overwrite, so just return
            // if errored, also return
            //
            return(rc);
        }
    }
    //
    // convert security descriptor
    //
    if ( pSD ) {

        Win32Rc = ConvertSecurityDescriptorToText (
                        pSD,
                        SeInfo,
                        &SDspec,
                        &SDsize
                        );
    }

    if ( Win32Rc == NO_ERROR ) {

        rc = ScepSaveObjectString(
                    hSection,
                    ObjectName,
                    IsContainer,
                    Status,
                    SDspec,
                    SDsize
                    );
    } else
        rc = ScepDosErrorToSceStatus(Win32Rc);

    if ( SDspec != NULL ) {
        ScepFree(SDspec);
    }

    return(rc);

}


SCESTATUS
ScepObjectDeleteScepAndAllChildren(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN BOOL IsContainer,
    IN BYTE StatusToRaise
    )
/*
Routine Description:

    Delete a object and all child objects from SMP and SAP

Arguements:

    hSectionSmp - SMP section handle

    hSectionSap - SAP section handle

    ObjectName  - the object's name

    IsContainer - if the object is a container

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;

    rc = SceJetDelete(
            hSectionSmp,
            ObjectName,
            TRUE,
            SCEJET_DELETE_PARTIAL_NO_CASE
            );

    if ( rc == SCESTATUS_SUCCESS ||
         rc == SCESTATUS_RECORD_NOT_FOUND ) {

        rc = SceJetDelete(
            hSectionSap,
            ObjectName,
            TRUE,
            SCEJET_DELETE_PARTIAL_NO_CASE
            );

        if ( rc == SCESTATUS_SUCCESS ||
             rc == SCESTATUS_RECORD_NOT_FOUND ) {
            //
            // Raise a N.C. status for the object
            //
            rc = ScepObjectSetKeySetting(
                    hSectionSap,
                    ObjectName,
                    StatusToRaise,  //SCE_STATUS_NOT_CONFIGURED,
                    IsContainer,
                    NULL,
                    0,
                    TRUE
                    );
        }

    }

    if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);
}


SCESTATUS
ScepObjectAdjustNode(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN SE_OBJECT_TYPE ObjectType,
    IN BYTE ConfigStatus,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN BOOL bAdd,
    OUT PBYTE pAnalysisStatus
    )
/*
Routine Description:

    Add a new object to SMP and SAP sections

Arguements:

    hSectionSmp - the SMP section handle

    hSectionSap - the SAP section handle

    others see ScepUpdateObjectInfo

Return Value:

    SCESTATUS
*/
{

    if ( hSectionSmp == NULL || hSectionSap == NULL ||
         ObjectName == NULL || NameLen == 0 ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS    rc=SCESTATUS_SUCCESS;
    WCHAR       Delim;

    switch ( ObjectType) {
    case SE_REGISTRY_KEY:
    case SE_FILE_OBJECT:
        Delim = L'\\';
        break;
/*
    case SE_DS_OBJECT:
        Delim = L',';
        break;
*/
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    INT         i, Level=0, ParentLevel=0;
    BYTE        ParentStatus;

    //
    // get total number levels of the objectname
    //
    ScepObjectTotalLevel(ObjectName, Delim, &Level);

    //
    // allocate temp buffer
    //
    PWSTR ParentName = (PWSTR)ScepAlloc(0, (NameLen+4)*sizeof(WCHAR));

    if ( ParentName == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    //
    // loop through each parent of the object to turn of IGNORE status
    //
    ParentName[0] = L'\0';

    rc = ScepObjectAdjustParentStatus(
                hSectionSmp,
                hSectionSap,
                ObjectName,
                NameLen,
                Delim,
                Level,
                bAdd ? (BYTE)SCE_OBJECT_TURNOFF_IGNORE : 0, // if TRUE, turn off parent ignore status, otherwise, just get the parent
                &ParentLevel,
                &ParentStatus,
                ParentName   // ParentName
                );


    if ( rc != SCESTATUS_SUCCESS ) {
         //
         // error occurs when turning off IGNORE
         //
         ScepFree(ParentName);
         return(rc);
    }

    BYTE retStat = SCE_STATUS_NOT_ANALYZED;

    BOOL        HasChild;

    rc = ScepObjectHasAnyChild(
               hSectionSmp,
               ObjectName,
               NameLen,
               Delim,
               &HasChild
               );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( bAdd ) {

            //
            // ****when bAdd = TRUE, add the node.
            // there are the following cases to consider regarding the SAP entries:
            //
            //  1. tree path is empty to the root (the first object added in this path)
            //        C.C. all parent nodes if they don't exist
            //        N.A. the object
            //        return status N.A.
            //  2. have parent node but no child node (the new node is a leaf node)
            //        if the closest parent is in OVERWRITE status
            //            if the closet parent is new added (N.A. status)
            //               add the node, N.A. the object
            //               return status N.A.
            //            else
            //               if new node status is CHECK
            //                  delete all SAP mismatches for children under the new node,
            //                  determine MATCH/MISMATCH of the new node
            //               if new node status is OVERWRITE
            //                  determine MATCH/MISMATCH of the new node, everthing else stays unchanged
            //               return status GOOD or MISMATCH
            //        if the closest parent is CHECK
            //            C.C. all nodes in the path to the parent,
            //            add the node, N.A. the object
            //            return status N.A.
            //  3. have child node but no parent node
            //         new node's status (CHECK or OVERWRITE ) does not make difference
            //         if new status is IGNORE,
            //            delete all children in SMP and SAP,
            //            add the node and N.C. the object
            //            return status N.C.
            //         else
            //            delete all children in SAP,
            //            add the node,
            //            raise all SMP node and children as N.A.
            //            return status N.A
            //
            //  4. have both parent and child
            //         combine rules for 2 and 3 except:
            //              if parent's status is OVERWRITE and new node status is CHECK
            //                  ONLY delete SAP mismatches for children between the new node and the child node
            //

            //
            // decide child objects
            //
            if ( ConfigStatus == SCE_STATUS_IGNORE ) {
                //
                // delete all children objects from template and analysis database
                //
                rc = ScepObjectDeleteScepAndAllChildren(
                            hSectionSmp,
                            hSectionSap,
                            ObjectName,
                            IsContainer,
                            SCE_STATUS_NOT_ANALYZED
                            );

            } else {

                if ( ParentLevel > 0 && ParentStatus == SCE_STATUS_OVERWRITE ) {

                    //
                    // check if this parent was added (N.A. status)
                    //
                    BYTE oldStatus = ScepGetObjectAnalysisStatus(hSectionSap,
                                                                ParentName,
                                                                FALSE
                                                               );

                    if ( oldStatus == SCE_STATUS_NOT_ANALYZED ) {
                        //
                        // parent was also new added
                        // add the node, N.A. the object
                        //
                        rc = ScepObjectSetKeySetting(
                                hSectionSap,
                                ObjectName,
                                SCE_STATUS_NOT_ANALYZED,
                                TRUE,
                                NULL,
                                0,
                                TRUE
                                );
                    } else {

                        //
                        // closest parent has OVERWRITE status
                        //

                        if ( ConfigStatus == SCE_STATUS_CHECK ||
                             ConfigStatus == SCE_STATUS_NO_AUTO_INHERIT ) {

                            //
                            // delete all SAP children except explicitly specified
                            //
                            if ( !HasChild ) {
                                //
                                // no child - delete everything under the SAP
                                //
                                rc = SceJetDelete(
                                        hSectionSap,
                                        ObjectName,
                                        TRUE,
                                        SCEJET_DELETE_PARTIAL_NO_CASE
                                        );
                            } else {

                                //
                                // here is the problem: should only delete SAP entry between
                                // the new node and its child(ren)
                                // and raise C.C. for nodes in between
                                //
                                //         p
                                //        /
                                //       .
                                //      N
                                //     / |
                                //     . C
                                //    / \
                                //    .  C
                                //    /|
                                //   C C
                                //
                                //

                                rc = ScepObjectRaiseChildrenInBetween(
                                             hSectionSmp,
                                             hSectionSap,
                                             ObjectName,
                                             NameLen,
                                             IsContainer,
                                             SCE_STATUS_CHILDREN_CONFIGURED,
                                             FALSE
                                             );
                            }
                        }

                        //
                        // determine the current node's status, MATCH or MISMATCH
                        //

                        if ( rc == SCESTATUS_SUCCESS ||
                             rc == SCESTATUS_RECORD_NOT_FOUND ) {

                            if ( oldStatus == SCE_STATUS_ERROR_NOT_AVAILABLE  ) {

                                //
                                // Leave Error status alone
                                //
                                rc = ScepObjectSetKeySetting(
                                        hSectionSap,
                                        ObjectName,
                                        oldStatus,
                                        TRUE,
                                        NULL,
                                        0,
                                        TRUE
                                        );
                            } else {

                                //
                                // should compare with SAP to decide mismatch status
                                //
                                rc = ScepObjectCompareKeySetting(
                                        hSectionSap,
                                        ObjectName,
                                        ObjectType,
                                        TRUE,
                                        pSD,
                                        SeInfo,
                                        NULL,
                                        &retStat
                                        );
                            }
                        }
                    }

                } else if ( !HasChild ) {
                    //
                    // there is no child but there may be a parent
                    // if there is a parent, parent's stauts is check
                    //
                    if ( ParentLevel > 0 ) {
                        // C.C. all nodes in the path to the parent,
                        // (if there is child, it's already CCed)
                        // add the node, N.A. the object
                        i = ParentLevel+1;

                    } else {
                        //
                        // no parent was found, no child - the first node
                        //
                        if ( ObjectType == SE_DS_OBJECT ) {
                            //
                            // Ds objects should start with the level for the local domain
                            //
                            PSCE_OBJECT_LIST pDsRoot=NULL;
                            rc = ScepEnumerateDsObjectRoots(NULL, &pDsRoot);

                            if ( rc == SCESTATUS_SUCCESS && pDsRoot != NULL ) {
                                ScepObjectTotalLevel(pDsRoot->Name, Delim, &ParentLevel);

                                ScepFreeObjectList(pDsRoot);
                                pDsRoot = NULL;

                                i = ParentLevel+1;

                            }

                        } else {
                            //
                            // other type starting with level 1
                            //
                            i = 1;
                        }
                    }

                    //
                    // process each node in between the new node and its closest parent
                    //
                    if ( rc == SCESTATUS_SUCCESS ) {
                        rc = ScepObjectRaiseNodesInPath(
                                    hSectionSap,
                                    ObjectName,
                                    NameLen,
                                    i,
                                    Level,
                                    Delim,
                                    SCE_STATUS_CHILDREN_CONFIGURED
                                    );
                    }

                    //
                    // N.A. the object
                    //
                    if ( rc == SCESTATUS_SUCCESS ) {
                        rc = ScepObjectSetKeySetting(
                                hSectionSap,
                                ObjectName,
                                SCE_STATUS_NOT_ANALYZED,
                                IsContainer,
                                NULL,
                                0,
                                TRUE
                                );
                    }

                } else {
                    //
                    // there is child
                    //
                    if ( ConfigStatus == SCE_STATUS_OVERWRITE ) {
                        //
                        // if there is a parent, it must be in CHECK status
                        // nodes between this node and its children
                        // should all be N.A.
                        //
                        rc = ScepObjectRaiseChildrenInBetween(
                                     hSectionSmp,
                                     hSectionSap,
                                     ObjectName,
                                     NameLen,
                                     IsContainer,
                                     SCE_STATUS_NOT_ANALYZED,
                                     FALSE
                                     );
                    }

                    //
                    // N.A. the object
                    //
                    if ( rc == SCESTATUS_SUCCESS ) {
                        rc = ScepObjectSetKeySetting(
                                hSectionSap,
                                ObjectName,
                                SCE_STATUS_NOT_ANALYZED,
                                IsContainer,
                                NULL,
                                0,
                                TRUE
                                );
                    }
                }
            }

            //
            // add the SMP entry
            //
            if ( rc == SCESTATUS_SUCCESS ) {
                rc = ScepObjectSetKeySetting(
                        hSectionSmp,
                        ObjectName,
                        ConfigStatus,
                        IsContainer,
                        pSD,
                        SeInfo,
                        TRUE
                        );
            }

        } else {

            //
            // when bAdd = FALSE, remove the node
            // there are the following cases to consider regarding the SAP entries:
            //
            //  1. if there is no existing child under this node
            //        if no parent, or parent N.A., or parent not OVERWRITE
            //           find junction point with other siblings
            //           remove all SAP below junction point (if not exist, use root/parent)
            //           if no juction point and no parent
            //              N.C. the root
            //           return status N.C.
            //        else { parent in overwrite } if ( TNA/TI/TC) }
            //           delete all SAP below this object
            //           N.A. the object
            //           return status N.A.
            //        else ( parent in overwrite and TO )
            //           N.A. the object
            //           return status N.A.
            //  2. have existing child(ren) - note multiple branches
            //        if no parent
            //            if object status was OVERWRITE
            //               delete SAP entries between this node and all children
            //               C.C. all branch nodes in between
            //            C.C. this object
            //            return status C.C.
            //        else { there is a parent }
            //            if (parent OVERWRITE, object N.A. OVERWRITE) or
            //               (parent not N.A., parent OVERWRITE, object not N.A., object OVERWRITE)
            //               N.A. object
            //               return N.A.
            //            else if parent CHECK, object OVERWRITE
            //               delete SAP entries between this node and all children
            //               C.C. all branch nodes in between
            //               C.C. object
            //               return C.C.
            //            else if (parent OVERWRITE, object CHECK) or
            //                    (parent N.A., parent OVERWRITE, object not N.A., object OVERWRITE)
            //               delete SAP entries between this node and all children
            //               N.A. all branch nodes in between
            //               N.A. object
            //               return N.A.
            //            else { must be parent CHECK, object CHECK }
            //               C.C. object
            //               return C.C
            //

            //
            // check if this parent was added (N.A. status)
            //
            BYTE oldParentFlag = ScepGetObjectAnalysisStatus(hSectionSap,
                                                            ParentName,
                                                            FALSE
                                                           );
            BYTE oldObjectFlag = ScepGetObjectAnalysisStatus(hSectionSap,
                                                             ObjectName,
                                                             FALSE
                                                            );
            if ( !HasChild ) {

                if ( ParentLevel <= 0 ||
                     oldParentFlag == SCE_STATUS_NOT_ANALYZED ||
                     ParentStatus != SCE_STATUS_OVERWRITE ) {

                    //
                    // find junction point with other siblings
                    //
                    INT JuncLevel=0;

                    rc = ScepObjectAdjustParentStatus(
                                hSectionSmp,
                                hSectionSap,
                                ObjectName,
                                NameLen,
                                Delim,
                                Level,
                                SCE_OBJECT_SEARCH_JUNCTION,
                                &JuncLevel,
                                NULL,
                                NULL
                                );

                    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
                        rc = SCESTATUS_SUCCESS;
                    }

                    if ( JuncLevel == 0 ) {
                        JuncLevel = ParentLevel;
                    }

                    if ( SCESTATUS_SUCCESS == rc ) {
                        //
                        // remove all SAP below junction point
                        // (if not exist, use root/parent)
                        //
                        rc = ScepObjectRaiseNodesInPath(
                                    hSectionSap,
                                    ObjectName,
                                    NameLen,
                                    (JuncLevel > 0) ? JuncLevel+1 : 1,
                                    Level,
                                    Delim,
                                    (BYTE)SCE_NO_VALUE
                                    );

                        if ( SCESTATUS_SUCCESS == rc ) {
                            //
                            // delete everything under this deleted node
                            //
                            rc = SceJetDelete(
                                      hSectionSap,
                                      ObjectName,
                                      TRUE,
                                      SCEJET_DELETE_PARTIAL_NO_CASE
                                      );
                        }
                    }

                    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
                        rc = SCESTATUS_SUCCESS;
                    }

                    if ( SCESTATUS_SUCCESS == rc ) {

                        if ( JuncLevel <= 0 ) {
                            //
                            // if no juction point and no parent, N.C. the root
                            // use the ParentName buffer
                            //
                            if ( ObjectType == SE_FILE_OBJECT ) {
                                if ( ParentName[0] == L'\0' ) {
                                    //
                                    // there is no parent
                                    //
                                    ParentName[0] = ObjectName[0];
                                    ParentName[1] = ObjectName[1];
                                }
                                ParentName[2] = L'\\';
                                ParentName[3] = L'\0';
                            } else {
                                // reg keys
                                PWSTR pTemp = wcschr(ParentName, L'\\');
                                if ( pTemp ) {
                                    ParentName[pTemp-ParentName] = L'\0';

                                } else if ( ParentName[0] == L'\0' ) {

                                    pTemp = wcschr(ObjectName, L'\\');
                                    if ( pTemp ) {

                                        wcsncpy(ParentName, ObjectName, pTemp-ObjectName);
                                        ParentName[pTemp-ObjectName] = L'\0';

                                    } else {
                                        wcscpy(ParentName, ObjectName);
                                    }
                                }
                            }

                            rc = ScepObjectSetKeySetting(
                                    hSectionSap,
                                    ParentName,
                                    SCE_STATUS_NOT_CONFIGURED,
                                    TRUE,
                                    NULL,
                                    0,
                                    TRUE
                                    );
                        }
                    }

                    retStat = SCE_STATUS_NOT_CONFIGURED;

                } else {

                    if ( ConfigStatus != SCE_STATUS_OVERWRITE ) {
                        //
                        // delete all SAP below this object
                        //
                        rc = SceJetDelete(
                                hSectionSap,
                                ObjectName,
                                TRUE,
                                SCEJET_DELETE_PARTIAL_NO_CASE
                                );
                    }

                    if ( SCESTATUS_SUCCESS == rc ) {

                        //
                        // N.A. the object
                        //
                        rc = ScepObjectSetKeySetting(
                                hSectionSap,
                                ObjectName,
                                SCE_STATUS_NOT_ANALYZED,
                                IsContainer,
                                NULL,
                                0,
                                TRUE
                                );
                    }

                    retStat = SCE_STATUS_NOT_ANALYZED;
                }

            } else if ( ParentLevel <= 0 ||
                        ( ParentStatus != SCE_STATUS_OVERWRITE &&
                          ConfigStatus == SCE_STATUS_OVERWRITE) ) {

                // no parent, or parent check, object overwrite

                if ( ConfigStatus == SCE_STATUS_OVERWRITE ) {
                    //
                    // delete SAP entries between this node and all children
                    // C.C. all branch nodes in between
                    //
                    rc = ScepObjectRaiseChildrenInBetween(
                                hSectionSmp,
                                hSectionSap,
                                ObjectName,
                                NameLen,
                                IsContainer,
                                SCE_STATUS_CHILDREN_CONFIGURED,
                                FALSE
                                );
                }

                if ( SCESTATUS_SUCCESS == rc ) {

                    // C.C. this object
                    rc = ScepObjectSetKeySetting(
                            hSectionSap,
                            ObjectName,
                            SCE_STATUS_CHILDREN_CONFIGURED,
                            IsContainer,
                            NULL,
                            0,
                            TRUE
                            );
                }

                retStat = SCE_STATUS_CHILDREN_CONFIGURED;

            } else {
                //
                // have both parent and children
                //

                if ( ParentStatus == SCE_STATUS_OVERWRITE &&
                     ConfigStatus == SCE_STATUS_OVERWRITE &&
                     ( oldObjectFlag == SCE_STATUS_NOT_ANALYZED ||
                       (oldParentFlag != SCE_STATUS_NOT_ANALYZED &&
                        oldObjectFlag != SCE_STATUS_NOT_ANALYZED )
                     ) ) {
                    //
                    // (parent OVERWRITE, object N.A. OVERWRITE) or
                    // (parent not N.A., parent OVERWRITE, object not N.A., object OVERWRITE)
                    // N.A. the object
                    //
                    retStat = SCE_STATUS_NOT_ANALYZED;

                } else if ( ParentStatus == SCE_STATUS_OVERWRITE &&
                            ( ConfigStatus != SCE_STATUS_OVERWRITE ||
                              ( oldParentFlag == SCE_STATUS_NOT_ANALYZED &&
                                oldObjectFlag != SCE_STATUS_NOT_ANALYZED &&
                                ConfigStatus == SCE_STATUS_OVERWRITE ))
                          ) {
                    //
                    // (parent OVERWRITE, object CHECK) or
                    // (parent N.A., parent OVERWRITE, object not N.A., object OVERWRITE)
                    //
                    // delete SAP entries between this node and all children
                    // N.A. all branch nodes in between
                    //

                    rc = ScepObjectRaiseChildrenInBetween(
                                hSectionSmp,
                                hSectionSap,
                                ObjectName,
                                NameLen,
                                IsContainer,
                                SCE_STATUS_NOT_ANALYZED,
                                FALSE
                                );

                    // N.A. object
                    retStat = SCE_STATUS_NOT_ANALYZED;

                } else {
                    //
                    // must be parent CHECK, object CHECK }
                    // C.C. object
                    //

                    retStat = SCE_STATUS_NOT_ANALYZED;
                }

                if ( SCESTATUS_SUCCESS == rc ) {
                    rc = ScepObjectSetKeySetting(
                            hSectionSap,
                            ObjectName,
                            retStat,
                            IsContainer,
                            NULL,
                            0,
                            TRUE
                            );
                }
            }
            //
            // remove the SMP entry
            //
            if ( rc == SCESTATUS_SUCCESS ) {

                rc = SceJetDelete(
                        hSectionSmp,
                        ObjectName,
                        FALSE,
                        SCEJET_DELETE_LINE_NO_CASE
                        );
            }
        }
    }

    ScepFree(ParentName);

    if ( pAnalysisStatus ) {
        *pAnalysisStatus = retStat;
    }

    return(rc);
}


SCESTATUS
ScepObjectRaiseNodesInPath(
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN INT StartLevel,
    IN INT EndLevel,
    IN WCHAR Delim,
    IN BYTE Status
    )
{
    BOOL        LastOne=FALSE;
    SCESTATUS   rc = SCESTATUS_SUCCESS;
    PWSTR NodeName=NULL;

    //
    // process each node in between the start level and end level
    //
    for ( INT i=StartLevel; rc==SCESTATUS_SUCCESS && i < EndLevel; i++ ) {

        if ( NodeName == NULL ) {

            NodeName = (PWSTR)ScepAlloc(0, (NameLen+1)*sizeof(WCHAR));
            if ( NodeName == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                break;
            }
        }

        //
        // get level i full name
        //
        memset(NodeName, '\0', (NameLen+1)*sizeof(WCHAR));

        rc = ScepGetFullNameInLevel(
                    ObjectName,
                    i,
                    Delim,
                    FALSE,
                    NodeName,
                    &LastOne
                    );

        if ( rc == SCESTATUS_SUCCESS) {

            if (  Status != (BYTE)SCE_NO_VALUE ) {
                //
                // raise the status
                //

                rc = ScepObjectSetKeySetting(
                        hSectionSap,
                        NodeName,
                        Status,
                        TRUE,
                        NULL,
                        0,
                        TRUE
                        );
            } else {

                //
                // remove the raise
                //
                rc = SceJetDelete(
                        hSectionSap,
                        NodeName,
                        FALSE,
                        SCEJET_DELETE_LINE_NO_CASE
                        );
            }

        }

        if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
            rc = SCESTATUS_SUCCESS;
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            break;
        }

    }

    if ( NodeName ) {
        ScepFree(NodeName);
    }

    return rc;
}


SCESTATUS
ScepObjectTotalLevel(
    IN PWSTR ObjectName,
    IN WCHAR Delim,
    OUT PINT pLevel
    )
/*
Routine Description:

    Count total levels of the object name, for example, c:\winnt\system32
    will return level of 3

Arguements:

    ObjectName - the object's name in full path

    Delim       - the delimiter to look for

    pLevel      - the output level

Return Value:

    SCESTATUS
*/
{
    PWSTR pStart;

    if ( ObjectName == NULL || pLevel == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    pStart = ObjectName;
    *pLevel = 0;

    while (pStart) {

        (*pLevel)++;
        pStart = wcschr(pStart, Delim);

        if ( pStart != NULL && *(pStart+1) != L'\0' )
            pStart++;
        else
            break;
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepObjectCompareKeySetting(
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pScepSD,
    OUT PBYTE pAnalysisStatus
    )
/*
Routine Description:

    Compare an object's setting with info in the section.

Arguements:

    hSectionSap - the SAP section handle

    others see ScepUpdateObjectInfo

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;
    BYTE SapStatus;
    PSECURITY_DESCRIPTOR pSapSD = NULL;
    SECURITY_INFORMATION SapSeInfo;
    DWORD Win32rc;
    BYTE CompareStatus=0;


    rc = ScepObjectGetKeySetting(
            hSectionSap,
            ObjectName,
            &SapStatus,
            NULL,
            &pSapSD,
            &SapSeInfo
            );

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // SAP record exists. was mismatched
        //
        Win32rc = ScepCompareObjectSecurity(
                        ObjectType,
                        IsContainer,
                        pSD,
                        pSapSD,
                        SeInfo,
                        &CompareStatus
                        );

        if ( Win32rc != NO_ERROR ) {
            rc = ScepDosErrorToSceStatus(Win32rc);

        } else if ( !CompareStatus ) {
            //
            // new setting is same as the SAP setting - matched
            // delete the SAP entry
            //
            rc = SceJetDelete(
                 hSectionSap,
                 ObjectName,
                 FALSE,
                 SCEJET_DELETE_LINE_NO_CASE
                 );

            if ( pAnalysisStatus ) {
                *pAnalysisStatus = SCE_STATUS_GOOD;
            }

        } else {
            //
            // still mismatched, just update the SMP entry (outside)
            //
            rc = ScepObjectSetKeySetting(
                    hSectionSap,
                    ObjectName,
                    CompareStatus, // SCE_STATUS_MISMATCH,
                    IsContainer,
                    pSapSD,
                    SapSeInfo,
                    TRUE
                    );
            if ( pAnalysisStatus ) {
                *pAnalysisStatus = CompareStatus;  // SapStatus;
            }

        }

        if ( pSapSD ) {
            ScepFree(pSapSD);
        }

    } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

        rc = SCESTATUS_SUCCESS;
        //
        // no SAP record exist. was matched
        //
        Win32rc = ScepCompareObjectSecurity(
                        ObjectType,
                        IsContainer,
                        pSD,
                        pScepSD,
                        SeInfo,
                        &CompareStatus
                        );

        if ( Win32rc != NO_ERROR ) {
            rc = ScepDosErrorToSceStatus(Win32rc);

        } else if ( CompareStatus ) {
            //
            // new setting is different from the SMP setting
            // create SAP entry using the SMP setting
            //
            rc = ScepObjectSetKeySetting(
                    hSectionSap,
                    ObjectName,
                    CompareStatus, // SCE_STATUS_MISMATCH,
                    IsContainer,
                    pScepSD,
                    SeInfo,
                    TRUE
                    );
            if ( pAnalysisStatus ) {
                *pAnalysisStatus = CompareStatus;  // SCE_STATUS_MISMATCH;
            }

        } else {

            if ( pAnalysisStatus ) {
                *pAnalysisStatus = SCE_STATUS_GOOD;
            }
        }

    }

    if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
        rc = SCESTATUS_SUCCESS;
    }
    return(rc);
}


SCESTATUS
ScepObjectAdjustParentStatus(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN WCHAR Delim,
    IN INT Level,
    IN BYTE Flag,
    OUT PINT ParentLevel,
    OUT PBYTE ParentStatus OPTIONAL,
    OUT PWSTR ParentName OPTIONAL
    )
/*
Routine Description:

    delete the ignored parent in the object's path (should only have one)
    The following actions are taken when a IGNORE node is found:
       (it should have N.C.ed in SAP but no children has N.C record)
       delete all children in SMP and SAP
          (force to have only no or one IGNORE in the path)
       delete the SMP entry ( turn the IGNORE status to CHECK ?)
       There should be no other nodes under a IGNORE node. But if there are,
          delete them.
       raise SAP status as "Not analyzed"

Arguments:

    hSectionSmp - the SMP section handle

    hSectionSap - the SAP section handle

    ObjectName - the object's full name

    NameLen  - the length of the name

    Delim - the delimiter to look for

    Level - the total level of the object name

    ParentLevel - output of its closest parent level

    ParentStatus - output of its closest parent status

Return Value:

    SCE status
*/
{
    SCESTATUS rc=SCESTATUS_SUCCESS;
    INT i;
    PWSTR Name=NULL;
    BOOL LastOne;
    DWORD ParentLen;
    BYTE Status;
    PSECURITY_DESCRIPTOR pScepSD=NULL;
    SECURITY_INFORMATION SeInfo;

    Name = (PWSTR)ScepAlloc(0, (NameLen+2)*sizeof(WCHAR));

    if ( Name == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    *ParentLevel = 0;

    for ( i=Level-1; i>=1; i-- ) {
        //
        // get level i full name
        //
        memset(Name, '\0', (NameLen+2)*sizeof(WCHAR));

        rc = ScepGetFullNameInLevel(
                    ObjectName,
                    i,
                    Delim,
                    (Flag & SCE_OBJECT_SEARCH_JUNCTION) ? TRUE : FALSE,
                    Name,
                    &LastOne
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            //
            // search and get information of this path
            //
            if ( Flag & SCE_OBJECT_SEARCH_JUNCTION ) {

                DWORD Count=0;

                rc = SceJetGetLineCount(
                            hSectionSmp,
                            Name,
                            FALSE,
                            &Count
                            );

                if ( rc == SCESTATUS_SUCCESS &&
                     Count > 1 ) {
                    //
                    // there are other children under this node
                    // this is the junction point
                    //
                    *ParentLevel = i;
                    break;
                }
                //
                // dont' care error
                //
                rc = SCESTATUS_SUCCESS;

            } else {

                ParentLen = wcslen(Name);
                Status = (BYTE)-1;

                rc = ScepObjectGetKeySetting(
                        hSectionSmp,
                        Name,
                        &Status,
                        NULL,
                        &pScepSD,
                        &SeInfo
                        );

                if ( rc == SCESTATUS_SUCCESS ) {

                    //
                    // find a parent.
                    //
                    *ParentLevel = i;
                    if ( ParentStatus ) {
                        *ParentStatus = Status;
                    }
                    if ( ParentName ) {
                        wcscpy(ParentName, Name);
                    }

                    if ( (Flag & SCE_OBJECT_TURNOFF_IGNORE) &&
                         Status == SCE_STATUS_IGNORE ) {
                        //
                        // delete all SMP and SAP under this node
                        //
                        rc = ScepObjectDeleteScepAndAllChildren(
                                    hSectionSmp,
                                    hSectionSap,
                                    Name,
                                    TRUE,
                                    SCE_STATUS_NOT_ANALYZED
                                    );
    /*
                        if ( rc == SCESTATUS_SUCCESS ) {
                            //
                            // change its status to CHECK,
                            //
                            rc = ScepObjectSetKeySetting(
                                    hSectionSmp,
                                    Name,
                                    SCE_STATUS_CHECK,
                                    TRUE,
                                    pScepSD,
                                    SeInfo,
                                    TRUE
                                    );
                        }
    */
                        //
                        // all other nodes are deleted. should break out of the loop
                        //
                    }

                    if ( pScepSD ) {
                        ScepFree(pScepSD);
                        pScepSD = NULL;
                    }

                    if ( !(Flag & SCE_OBJECT_TURNOFF_IGNORE) ||
                         Status == SCE_STATUS_IGNORE ) {

                        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
                            rc = SCESTATUS_SUCCESS;

                        break;
                    }
                }
            }
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
            rc = SCESTATUS_SUCCESS;
        }

        //
        // process next parent
        //

        if ( rc != SCESTATUS_SUCCESS  )
            break;
    }

    ScepFree(Name);

    return(rc);
}

SCESTATUS
ScepObjectHasAnyChild(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN WCHAR Delim,
    OUT PBOOL bpHasChild
    )
/*
Routine Description:

    Detect if the object has child objects in the section

Arguements:

    hSection - the section handle

    ObjectName - the object name

    NameLen - the name length

    Delim - the delimeter to look for

    bpHasChild - output TRUE if the object has a child in the section

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;
    PWSTR pTemp=NULL;

    if ( hSection == NULL || ObjectName == NULL ||
         NameLen == 0 || Delim == L'\0' || bpHasChild == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    pTemp = (PWSTR)ScepAlloc(0, (NameLen+2)*sizeof(WCHAR));
    if ( pTemp != NULL ) {

        wcscpy(pTemp, ObjectName);
        pTemp[NameLen] = Delim;
        pTemp[NameLen+1] = L'\0';

        rc = SceJetSeek(
               hSection,
               pTemp,
               (NameLen+1)*sizeof(WCHAR),
               SCEJET_SEEK_GE_NO_CASE
               );

        if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
            *bpHasChild = FALSE;
            rc = SCESTATUS_SUCCESS;

        } else if ( rc == SCESTATUS_SUCCESS ) {
            *bpHasChild = TRUE;
        }

        ScepFree(pTemp);

    } else
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

    return(rc);
}


SCESTATUS
ScepObjectRaiseChildrenInBetween(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN BOOL IsContainer,
    IN BYTE Status,
    IN BOOL bChangeStatusOnly
    )
/*
Routine Description:

    Delete any SAP entries for objects between Name and its children in SMP table
    and raise SAP entries for bridge nodes to the Status specified.

    For example, in the picture below, every SAP entry in the 1. level and 2. level
    , except the C nodes, should be deleted from SAP. Then 1. and 2. nodes are
    raised as Status.

         p
        /
       .
      N     <----
     / |
    1. C
    / \
   2.  C
    /|
   C C

Arguments:

    hSectionSmp - the SMP section handle

    hSection - the SAP section handle

    Name - the object name

    NameLen - the length of the name

    Status - the object's status to raise


Return Value:

    SCE status
*/
{
    SCESTATUS rc;

    PWSTR *pSmpNames=NULL;
    DWORD *pSmpNameLen=NULL;
    DWORD cntNames=0;
    BOOL bFirst=TRUE;
    WCHAR Delim=L'\\';

    DWORD DirLen = wcslen(ObjectName);

    if ( ObjectName[DirLen-1] != Delim ) {
        DirLen++;
    }

    PWSTR DirName = (PWSTR)ScepAlloc(0, (DirLen+1)*sizeof(WCHAR));

    if ( DirName == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    }

    wcscpy(DirName, ObjectName);

    if ( DirName[DirLen-1] != Delim ) {
        DirName[DirLen-1] = Delim;
    }

    //
    // get all children of DirName in SMP
    //
    rc = SceJetGetLineCount(
                    hSectionSmp,
                    DirName,
                    FALSE,
                    &cntNames);

    DWORD index=0;

    if ( rc == SCESTATUS_SUCCESS ) {

        pSmpNames = (PWSTR *)ScepAlloc(LPTR, cntNames*sizeof(PWSTR));
        pSmpNameLen = (DWORD *)ScepAlloc(LPTR, cntNames*sizeof(DWORD));

        if ( pSmpNames != NULL && pSmpNameLen != NULL ) {

            //
            // get each name loaded into this array
            //
            PWSTR Buffer=NULL;
            DWORD KeyLen;

            rc = SceJetGetValue(
                        hSectionSmp,
                        SCEJET_PREFIX_MATCH_NO_CASE,
                        DirName,
                        NULL,
                        0,
                        &KeyLen,
                        NULL,
                        0,
                        NULL
                        );

            bFirst = TRUE;

            while ( rc == SCESTATUS_SUCCESS ) {

                Buffer = (PWSTR)ScepAlloc(LPTR, (KeyLen+1)*sizeof(WCHAR));

                if ( Buffer == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }

                rc = SceJetGetValue(
                            hSectionSmp,
                            SCEJET_CURRENT,
                            NULL,
                            Buffer,
                            KeyLen*sizeof(WCHAR),
                            NULL,
                            NULL,
                            0,
                            NULL
                            );

                if ( rc == SCESTATUS_SUCCESS ) {

                    if ( !bFirst ||
                         _wcsicmp(DirName, Buffer) != 0 ) {
                        //
                        // ignore the object itself
                        //
                        pSmpNames[index] = Buffer;
                        pSmpNameLen[index] = wcslen(Buffer);

                        Buffer = NULL;
                        index++;
                    }

                    bFirst = FALSE;

                } else {

                    ScepFree(Buffer);
                    Buffer = NULL;
                    break;

                }

                //
                // read next line
                //
                rc = SceJetGetValue(
                            hSectionSmp,
                            SCEJET_NEXT_LINE,
                            NULL,
                            NULL,
                            0,
                            &KeyLen,
                            NULL,
                            0,
                            NULL
                            );
            }

        } else {

            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        //
        // should have one or more children but if it's 0
        // delete everything in SAP
        //
        if ( cntNames == 0 || pSmpNames == NULL ||
             pSmpNameLen == NULL ||
             pSmpNameLen[0] == 0 || pSmpNames[0] == NULL ) {

            rc = SceJetDelete(
                    hSectionSap,
                    DirName,
                    TRUE,
                    SCEJET_DELETE_PARTIAL_NO_CASE
                    );

        } else if ( !bChangeStatusOnly ) {

            //
            // get each name loaded into this array
            //
            PWSTR Buffer=NULL;
            DWORD KeyLen;

            rc = SceJetGetValue(
                        hSectionSap,
                        SCEJET_PREFIX_MATCH_NO_CASE,
                        DirName,
                        NULL,
                        0,
                        &KeyLen,
                        NULL,
                        0,
                        NULL
                        );

            bFirst = TRUE;
            index = 0;

            while ( rc == SCESTATUS_SUCCESS ) {

                Buffer = (PWSTR)ScepAlloc(LPTR, (KeyLen+1)*sizeof(WCHAR));

                if ( Buffer == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }

                rc = SceJetGetValue(
                            hSectionSap,
                            SCEJET_CURRENT,
                            NULL,
                            Buffer,
                            KeyLen*sizeof(WCHAR),
                            NULL,
                            NULL,
                            0,
                            NULL
                            );

                if ( rc == SCESTATUS_SUCCESS &&
                     (!bFirst ||
                      _wcsicmp(DirName, Buffer) != 0) ) {
                    //
                    // ignore the object itself
                    // compare with the next child in SMP
                    // if it's before the next child, should delete it
                    //
                    int ci = _wcsnicmp(Buffer, pSmpNames[index], pSmpNameLen[index]);

                    while ( rc == SCESTATUS_SUCCESS &&
                            ci > 0 ) {
                        //
                        // this is the component or next one, move on to next one
                        //
                        index++;

                        if ( index >= cntNames || pSmpNames[index] == NULL ||
                             pSmpNameLen[index] == 0 ) {
                            //
                            // no more SMP child. We are done.
                            //
                            rc = SCESTATUS_RECORD_NOT_FOUND;

                        } else {

                            //
                            // already bigger than this child
                            //

                            ci = _wcsnicmp(Buffer, pSmpNames[index], pSmpNameLen[index]);
                        }
                    }

                    if ( ci < 0 ) {

                        SceJetDelete(
                            hSectionSap,
                            NULL, // delete the current line
                            FALSE,
                            SCEJET_DELETE_LINE
                            );

                    }
                }

                bFirst = FALSE;

                ScepFree(Buffer);
                Buffer = NULL;

                if ( rc == SCESTATUS_SUCCESS ) {

                    //
                    // read next line
                    //
                    rc = SceJetGetValue(
                                hSectionSap,
                                SCEJET_NEXT_LINE,
                                NULL,
                                NULL,
                                0,
                                &KeyLen,
                                NULL,
                                0,
                                NULL
                                );
                }
            }

        }
    }

    //
    // raise SAP entries for branch nodes between ObjectName and
    // SMP names as Status, then free smp names array
    //
    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    SCESTATUS rc2 = rc;
    INT StartLevel=0, EndLevel=0;

    if ( pSmpNames ) {

        ScepObjectTotalLevel(ObjectName, Delim, &StartLevel);
        StartLevel++;

        for ( index=0; index<cntNames; index++) {
            if ( pSmpNames[index] ) {

                if ( SCESTATUS_SUCCESS == rc2 ) {
                    //
                    // get this object level
                    //
                    ScepObjectTotalLevel(pSmpNames[index], Delim, &EndLevel);

                    rc2 = ScepObjectRaiseNodesInPath(
                                hSectionSap,
                                pSmpNames[index],
                                pSmpNameLen[index],
                                StartLevel,
                                EndLevel,
                                Delim,
                                Status
                                );

                    if ( rc2 == SCESTATUS_RECORD_NOT_FOUND ) {
                        rc2 = SCESTATUS_SUCCESS;
                    }
                    if ( rc2 != SCESTATUS_SUCCESS ) {
                        rc = rc2;
                    }
                }

                ScepFree(pSmpNames[index]);
            }
        }

        ScepFree(pSmpNames);
    }

    if ( pSmpNameLen ) {
        ScepFree(pSmpNameLen);
    }

    ScepFree(DirName);

    return rc;
}


SCESTATUS
ScepGetFullNameInLevel(
    IN PCWSTR ObjectFullName,
    IN DWORD  Level,
    IN WCHAR  Delim,
    IN BOOL bWithLastDelim,
    OUT PWSTR Buffer,
    OUT PBOOL LastOne
    )
/* ++
Routine Description:

    This routine parses a full path name and returns the component for the
    level. For example, a object name "c:\winnt\system32" will return c: for
    level 1, winnt for level 2, and system32 for level 3. This routine is
    used when add a object to the security tree.

Arguments:

    ObjectFullName - The full path name of the object

    Level - the level of component to return

    Delim - the deliminator to look for

    Buffer - The address of buffer for the full path name to the level

    LastOne - Flag to indicate if the component is the last one

Return value:

    SCESTATUS

-- */
{
    PWSTR  pTemp, pStart;
    DWORD i;
    ULONG Len = 0;

    if ( ObjectFullName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // loop through the object name to find the level
    // if there is no such level, return INVALID_PARAMETER
    //
    pStart = (PWSTR)ObjectFullName;

    for ( i=0; i<Level; i++) {

        pTemp = wcschr(pStart, Delim);

        if ( i == Level-1 ) {
            //
            // find the right level
            //
            if ( pTemp == NULL ) {
                wcscpy(Buffer, ObjectFullName);
                if ( bWithLastDelim ) {
                    Len = wcslen(ObjectFullName);
                if (Buffer[Len - 1] != Delim)
                    Buffer[Len] = Delim;
                }
                *LastOne = TRUE;
            } else {
                Len = (DWORD)(pTemp - ObjectFullName);

                if ( bWithLastDelim ) {
                    Len++;
                }
                wcsncpy(Buffer, ObjectFullName, Len);

                if ( *(pTemp+1) == L'\0' )
                    *LastOne = TRUE;
                else
                    *LastOne = FALSE;
            }
        } else {
            if ( pTemp == NULL )
                return(SCESTATUS_INVALID_PARAMETER);
            else
                pStart = pTemp + 1;
        }
    }

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepUpdateLocalTable(
    IN PSCECONTEXT       hProfile,
    IN AREA_INFORMATION  Area,
    IN PSCE_PROFILE_INFO pInfo,
    IN DWORD             dwMode
    )
{

    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( Area & AREA_SECURITY_POLICY ) {

        rc = ScepUpdateSystemAccess(hProfile,
                                    pInfo,
                                    NULL,
                                    NULL,
                                    dwMode
                                    );

        if ( rc == SCESTATUS_SUCCESS) {
            //
            // Update system auditing section
            //
            rc = ScepUpdateSystemAuditing(hProfile,
                                          pInfo,
                                          NULL,
                                          NULL,
                                          dwMode);

            if ( rc == SCESTATUS_SUCCESS) {
                //
                // Update log sections
                //
                rc = ScepUpdateLogs(hProfile,
                                    pInfo,
                                    NULL,
                                    NULL,
                                    dwMode
                                    );

                if ( rc == SCESTATUS_SUCCESS && pInfo->pKerberosInfo ) {
                    //
                    // Update kerberos policy
                    //
                    rc = ScepUpdateKerberos(hProfile,
                                            pInfo->pKerberosInfo,
                                            NULL,
                                            NULL,
                                            dwMode
                                            );
                }
                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // update registry values
                    //
                    rc = ScepUpdateLocalRegValues(hProfile,
                                                  pInfo,
                                                  dwMode
                                                  );

                }
                //
                // Note: policy attachment is not updated through this API
                //
            }
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            return(rc);
        }
    }

    if ( Area & AREA_PRIVILEGES ) {
        //
        // update user rights
        //
        rc = ScepUpdateLocalPrivileges(
                    hProfile,
                    pInfo->OtherInfo.smp.pPrivilegeAssignedTo,
                    dwMode
                    );

    }

    return rc;
}


SCESTATUS
ScepUpdateLocalSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update each key in the Keys array based on the editing rule. SMP entry is
    updated with the new value. SAP entry is either deleted, or created, depending
    on the new computed analysis status.

Arguements:

    hProfile - the jet database handle

    pInfo    - the changed info buffer

    Keys     - the lookup keys array

    cKeys    - the number of keys in the array

    SecitonName - the section name to work on

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;

    DWORD       i;
    UINT        Offset;
    DWORD       val;


    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                SectionName,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( !( dwMode & SCE_UPDATE_DIRTY_ONLY) ) {

            SceJetDelete(hSectionSmp, NULL, FALSE, SCEJET_DELETE_SECTION);
        }

        for ( i=0; i<cKeys; i++) {

            //
            // get settings in AccessLookup table
            //

            Offset = Keys[i].Offset;

            switch ( Keys[i].BufferType ) {
            case 'B':
                break;

            case 'D':

                val = *((DWORD *)((CHAR *)pInfo+Offset));

                if ( val != SCE_NO_VALUE ) {
                    //
                    // something changed for this one
                    //
                    if ( ( dwMode & SCE_UPDATE_DIRTY_ONLY ) &&
                         ( val == SCE_DELETE_VALUE ) ) {

                        rc = SceJetDelete(
                                hSectionSmp,
                                Keys[i].KeyString,
                                FALSE,
                                SCEJET_DELETE_LINE_NO_CASE
                                );
                    } else {

                        //
                        // update the SMP entry
                        //
                        rc = ScepCompareAndSaveIntValue(
                                    hSectionSmp,
                                    Keys[i].KeyString,
                                    FALSE,
                                    SCE_NO_VALUE,
                                    val
                                    );
                    }

                    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                        //
                        // if not find for delete, ignore the error
                        //
                        rc = SCESTATUS_SUCCESS;
                    }
                }
                break;

            default:
                break;
            }

            if ( rc != SCESTATUS_SUCCESS ) {
                break;
            }
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);

}


SCESTATUS
ScepUpdateLocalRegValues(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN DWORD dwMode
    )
{
    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pInfo->RegValueCount == 0 ||
         pInfo->aRegValues == NULL ) {
        //
        // impossible to have a empty buffer to update
        // this buffer should contain all available registry values to configure/analyze
        //
        return(SCESTATUS_SUCCESS);
    }

    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    DWORD i;

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szRegistryValues,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( !(dwMode & SCE_UPDATE_DIRTY_ONLY) ) {

            SceJetDelete(hSectionSmp, NULL, FALSE, SCEJET_DELETE_SECTION);
        }

        for (i=0; i<pInfo->RegValueCount; i++ ) {

            if ( !(pInfo->aRegValues[i].FullValueName) ) {
                continue;
            }

            if ( ( dwMode & SCE_UPDATE_DIRTY_ONLY) &&
                 (pInfo->aRegValues[i].ValueType == SCE_DELETE_VALUE) ) {

                rc = SceJetDelete(
                        hSectionSmp,
                        pInfo->aRegValues[i].FullValueName,
                        FALSE,
                        SCEJET_DELETE_LINE_NO_CASE
                        );
            } else {

                //
                // update the SMP entry
                //
                rc = ScepSaveRegValueEntry(
                            hSectionSmp,
                            pInfo->aRegValues[i].FullValueName,
                            pInfo->aRegValues[i].Value,
                            pInfo->aRegValues[i].ValueType,
                            0
                            );
            }

            if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                //
                // if not find for delete, ignore the error
                //
                rc = SCESTATUS_SUCCESS;
            }

            if ( SCESTATUS_SUCCESS != rc ) {
                break;
            }

        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);
}


SCESTATUS
ScepUpdateLocalPrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pNewPriv,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update privileges

Arguements:

    hProfile - the jet database handle

    pNewPriv    - the changed info buffer

    pBufScep - the original SMP priv buffer

Return Value:

    SCESTATUS
*/
{
    if ( hProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    LSA_HANDLE LsaHandle=NULL;
    SCESTATUS rc;

    rc = RtlNtStatusToDosError(
              ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &LsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {
        return(ScepDosErrorToSceStatus(rc));
    }

    PSCESECTION hSectionSmp=NULL;

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szPrivilegeRights,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( !(dwMode & SCE_UPDATE_DIRTY_ONLY) ) {

            SceJetDelete(hSectionSmp, NULL, FALSE, SCEJET_DELETE_SECTION);
        }

        PSCE_PRIVILEGE_ASSIGNMENT pPriv;

        for ( pPriv=pNewPriv; pPriv != NULL; pPriv = pPriv->Next ) {

            //
            // Process each privilege in the new list
            //
            if ( pPriv->Name == NULL ) {
                continue;
            }

            if ( ( dwMode & SCE_UPDATE_DIRTY_ONLY) &&
                 ( pPriv->Status == SCE_DELETE_VALUE) ) {

                rc = SceJetDelete(
                            hSectionSmp,
                            pPriv->Name,
                            FALSE,
                            SCEJET_DELETE_LINE_NO_CASE
                            );
            } else {

                rc = ScepWriteNameListValue(
                        LsaHandle,
                        hSectionSmp,
                        pPriv->Name,
                        pPriv->AssignedTo,
                        SCE_WRITE_EMPTY_LIST | SCE_WRITE_CONVERT | SCE_WRITE_LOCAL_TABLE,
                        0
                        );

            }

            if ( rc == SCESTATUS_RECORD_NOT_FOUND )
                rc = SCESTATUS_SUCCESS;

            if ( rc != SCESTATUS_SUCCESS) {
                break;
            }

        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);
}


DWORD
ScepConvertNameListFormat(
    IN LSA_HANDLE LsaHandle,
    IN PSCE_NAME_LIST pInList,
    IN DWORD FromFormat,
    IN DWORD ToFormat,
    OUT PSCE_NAME_LIST *ppOutList
    )
{
    if (LsaHandle == NULL || ppOutList == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *ppOutList = NULL;

    PSCE_NAME_LIST pList;
    DWORD rc = ERROR_SUCCESS;
    PWSTR   SidString=NULL;

    for ( pList=pInList; pList != NULL; pList=pList->Next ) {

        if ( pList->Name == NULL ) {
            continue;
        }

        if ( wcschr(pList->Name, L'\\') ) {

            rc = ScepLookupNameAndAddToSidStringList(
                                                    LsaHandle,
                                                    ppOutList,
                                                    pList->Name,
                                                    wcslen(pList->Name)
                                                    );
        } else if ( ScepLookupWellKnownName( 
                        pList->Name, 
                        LsaHandle,
                        &SidString ) ) {

            rc = ScepAddTwoNamesToNameList(
                                          ppOutList,
                                          FALSE,
                                          NULL,
                                          0,
                                          SidString,
                                          wcslen(SidString)
                                          );
        } else {

            rc = ScepAddToNameList(ppOutList, pList->Name, 0);

        }




        if ( rc != ERROR_SUCCESS ) {
            break;
        }
    }

    if ( rc != ERROR_SUCCESS &&
         (*ppOutList ) ) {
        ScepFreeNameList(*ppOutList);
        *ppOutList = NULL;
    }

    return(rc);
}

DWORD
ScepConvertPrivilegeList(
    IN LSA_HANDLE LsaHandle,
    IN PSCE_PRIVILEGE_ASSIGNMENT pFromList,
    IN DWORD FromFormat,
    IN DWORD ToFormat,
    OUT PSCE_PRIVILEGE_ASSIGNMENT *ppToList
    )
{

    if ( LsaHandle == NULL || pFromList == NULL || ppToList == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( FromFormat != 0 ||
         ToFormat != SCE_ACCOUNT_SID_STRING ) {
        return(ERROR_NOT_SUPPORTED);
    }

    //
    // only support name->sid string convert, for now.
    //
    DWORD rc = ERROR_SUCCESS;
    PSCE_PRIVILEGE_ASSIGNMENT pPriv, pPriv2;
    PSCE_NAME_LIST pTempList=NULL;

    for ( pPriv=pFromList; pPriv != NULL; pPriv=pPriv->Next ) {

        if ( pPriv->Name == NULL ) {
            continue;
        }

        rc = ScepConvertNameListFormat(LsaHandle,
                                         pPriv->AssignedTo,
                                         FromFormat,
                                         ToFormat,
                                         &pTempList
                                        );

        if ( rc != ERROR_SUCCESS ) {
            break;
        }

        //
        // a sce_privilege_assignment structure. allocate buffer
        //
        pPriv2 = (PSCE_PRIVILEGE_ASSIGNMENT)ScepAlloc( LMEM_ZEROINIT,
                                                       sizeof(SCE_PRIVILEGE_ASSIGNMENT) );
        if ( pPriv2 == NULL ) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pPriv2->Name = (PWSTR)ScepAlloc( (UINT)0, (wcslen(pPriv->Name)+1)*sizeof(WCHAR));
        if ( pPriv2->Name == NULL ) {
            ScepFree(pPriv2);
            rc = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        wcscpy(pPriv2->Name, pPriv->Name);
        pPriv2->Value = pPriv->Value;
        pPriv2->Status = pPriv->Status;

        pPriv2->AssignedTo = pTempList;
        pTempList = NULL;

        pPriv2->Next = *ppToList;
        *ppToList = pPriv2;

    }

    if ( pTempList ) {
        ScepFreeNameList(pTempList);
    }

    if ( rc != ERROR_SUCCESS &&
         (*ppToList) ) {
        //
        // free the output list
        //
        ScepFreePrivilege(*ppToList);
        *ppToList = NULL;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\convert.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    convert.cpp

Abstract:

    SCE APIs to set security on converted drives
    The main routine is
        exposed via RPC to SCE client (for immediate conversion)
        executed as an asynchronous thread spawned by the server during reboot (for scheduled conversion)

Author:

    Vishnu Patankar (vishnup) 07-Aug-2000 created

Revision History:

--*/

#include "headers.h"
#include "serverp.h"
#include "winsvcp.h"
#include "userenvp.h"

extern HINSTANCE MyModuleHandle;

//
// IIS function prototype. This function reapplies the acls
// to the IIS folders and files.
//
typedef BOOL (__stdcall *pApplyIISAcl) (WCHAR, BOOL);

#define SCE_IIS_DLL         L"\\System32\\Setup\\iis.dll"
#define SCE_IIS_FUNCTIONA   "ApplyIISAcl"
#define SCE_IIS_FUNCTION    TEXT(SCE_IIS_FUNCTIONA)

DWORD
ScepExamineDriveInformation(
    IN  PWSTR   pszRootDrive,
    IN  PWSTR   LogFileName,
    OUT BOOL    *pbSetSecurity
    );

DWORD
ScepSetDefaultSecurityDocsAndSettings(
    );

DWORD
ScepExtractRootDacl(
    OUT PSECURITY_DESCRIPTOR    *ppSDSet,
    OUT PACL    *ppDacl,
    OUT SECURITY_INFORMATION *pSeInfo
    );

VOID
ScepSecureUserProfiles(
    IN PWSTR pCurrDrive
    );

BOOL
ScepSecureIISFolders(
    IN PWSTR pszWindir,
    IN PWSTR pszCurrDrive
    );

DWORD
ScepConfigureConvertedFileSecurityImmediate(
                                           IN PWSTR    pszDriveName
                                           );

VOID
ScepConfigureConvertedFileSecurityReboot(
    IN PVOID pV
    )
/*++

Routine Description:

    The actual routine to configure setup style security for drives converted from FAT to NTFS.

    The following applies foreach volume that is NTFS - otherwise we log an error and continue with
    other drives (if any)

    First we need to set security on the \Docs&Settings folder if it sits below the drive
    under consideration. Upgrade style security configuration for this folder is done by the userenv API
    DetermineProfilesLocation(). Also need to read SD - add protected bit to SD - set SD back to \Docs&Settings
    such that configuring root with MARTA later will not whack this security. This step is not required if
    security set by userenv is diffetent from default FAT security on the root drive (since marta will not
    detect inheritance and hence will not whack security on \Docs&Settings). The latter is the more likely
    case.

    (a) If we are dealing with the system drive

    Then we just use the security template
    %windir%\security\templates\setup security.inf to configure setup style security (make an RPC
    call into scesrv).

    (b) If we are dealing with a non system drive (whatever the OS maybe), we just use MARTA APIs to set
    security on the root drive (from scecli itself). Currently, this is the design since there is no
    reliable way of parsing the boot files (boot.ini/boot.nvr).

    Then continue with the next drive as in the reg value.

    Since we are doing all this at reboot (scheduled), delete the reg value after we're done.

    Note on error reporting:
        All errors are logged to the logfile %windir%\security\logs\convert.log. but if it is not possible
        to log an error to the logfile, we log it to the event log with source "SceSrv". Also, higher level
        errors/successes are logged to both the logfile and the eventlog.

Arguments:

    pV              -  MULTI_SZ drive name(s) argument

Return:

    none
--*/
{
    //
    // arguments for the thread in which this routine executes
    //

    PWSTR   pmszDriveNames = (PWSTR)pV;

    //
    // Error codes
    //

    DWORD rc = ERROR_SUCCESS;
    DWORD rcSave = ERROR_SUCCESS;

    //
    // folders to use for logging etc.
    //

    WCHAR   szWinDir[MAX_PATH + 1];
    PWSTR   LogFileName = NULL;
    PWSTR   InfFileName = NULL;
    PWSTR   DatabaseName = NULL;
    PWSTR   pszSystemDrive = NULL;

    SafeAllocaAllocate( LogFileName, (MAX_PATH + 1 + 20) * sizeof(WCHAR) );
    SafeAllocaAllocate( InfFileName, (MAX_PATH + 1 + 40) * sizeof(WCHAR) );
    SafeAllocaAllocate( DatabaseName, (MAX_PATH + 1 + 20) * sizeof(WCHAR) );
    SafeAllocaAllocate( pszSystemDrive, (MAX_PATH + 1 + 20) * sizeof(WCHAR) );
    
    if ( LogFileName    == NULL ||
         InfFileName    == NULL || 
         pszSystemDrive == NULL || 
         DatabaseName   == NULL ) {

        goto ExitHandler;
    }


    //
    // other variables
    //

    BOOL    bSetSecurity = TRUE;
    PSECURITY_DESCRIPTOR    pSDSet=NULL;
    PACL    pDacl=NULL;
    BOOLEAN bRootDaclExtracted = FALSE;

    //
    // before attempting to do any useful work, validate arguments for this thread etc.
    // todo - should we handle exceptions ?
    //
    (void) InitializeEvents(L"SceSrv");

    if ( pmszDriveNames == NULL) {

        //
        // should not happen - parameters have been checked by all callers
        //

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_PARAMETER,
                 IDS_ERROR_CONVERT_PARAMETER
                );

        goto ExitHandler;
    }

    pszSystemDrive[0] = L'\0';

    //
    // ready the log file, logging level etc.
    //

    //
    // logging, database creation (if required) etc. is done in %windir%\security\*
    //

    szWinDir[0] = L'\0';

    if ( GetSystemWindowsDirectory( szWinDir, MAX_PATH+1 ) == 0 ) {

        //
        // too bad if this happens
        //

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_BAD_ENV_VAR,
                 IDS_ERROR_CONVERT_BAD_ENV_VAR,
                 L"%windir%"
                );

        goto ExitHandler;

    }

    LogFileName[0] = L'\0';
    wcscpy(LogFileName, szWinDir);
    wcscat(LogFileName, L"\\security\\logs\\convert.log");

    ScepEnableDisableLog(TRUE);

    ScepSetVerboseLog(3);

    if ( ScepLogInitialize( LogFileName ) == ERROR_INVALID_NAME ) {

        ScepLogOutput3(1,0, SCEDLL_LOGFILE_INVALID, LogFileName );

    }

    //
    // continue even if we cannot initialize log file but we absolutely
    // need the following environment var, so if we can't get it, quit
    //

    if ( GetEnvironmentVariable( L"SYSTEMDRIVE", pszSystemDrive, MAX_PATH) == 0 ) {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_BAD_ENV_VAR, L"%SYSTEMDRIVE%");

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_BAD_ENV_VAR,
                 IDS_ERROR_CONVERT_BAD_ENV_VAR,
                 L"%systemdrive%"
                );

        ScepLogClose();

        goto ExitHandler;
    }

    //
    // following two will be used only if system drive
    //

    OSVERSIONINFOEX   osVersionInfo;
    BYTE    Product_Type = VER_NT_WORKSTATION;

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if ( GetVersionEx((LPOSVERSIONINFO) &osVersionInfo) ){

        Product_Type = osVersionInfo.wProductType;
        // use osVersionInfo.wSuiteMask when Personal Template Bug is fixed
    }

    else {

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEDLL_CONVERT_PROD_TYPE,
                 IDS_ERROR_CONVERT_PROD_TYPE,
                 GetLastError()
                );

        ScepLogClose();

        goto ExitHandler;

    }

    //
    // use the right template
    //

    InfFileName[0] = L'\0';
    wcscpy(InfFileName, szWinDir);

    switch(Product_Type){

    case VER_NT_WORKSTATION:
    case VER_NT_SERVER:
        wcscat(InfFileName, L"\\security\\templates\\setup security.inf");
        break;

    case VER_NT_DOMAIN_CONTROLLER:
        wcscat(InfFileName, L"\\security\\templates\\DC security.inf");
        break;


    default:
        //
        // won't happen unless API is bad - default to wks
        //
        ASSERT(FALSE);

        wcscat(InfFileName, L"\\security\\templates\\setup security.inf");

        break;
    }


    DatabaseName[0] = L'\0';
    wcscpy(DatabaseName, szWinDir);
    wcscat(DatabaseName, L"\\security\\database\\convert.sdb");

    //
    // condition in the loop will end when it sees the last two \0 s in a
    // MULTI_SZ string such as C:\0E:\0\0
    //

    for (PWSTR  pCurrDrive = pmszDriveNames; pCurrDrive[0] != L'\0' ; pCurrDrive += wcslen(pCurrDrive) + 1) {

        //
        // try next drive if this drive is not securable or if error in querying drive information
        //

        if (ERROR_SUCCESS != (rc = ScepExamineDriveInformation(pCurrDrive, LogFileName, &bSetSecurity))) {
            rcSave = rc;
            continue;
        }

        if (!bSetSecurity) {

            //
            // reset for next iteration
            //

            bSetSecurity = TRUE;
            continue;
        }

        ScepLogOutput3(0,0, SCEDLL_CONVERT_ROOT_NTFS_VOLUME, pCurrDrive);

        //
        // set security on userprofiles directory if root of profile dir == current drive
        // ignore if error - template will have ignore entry for Docs&settings
        //

        ScepSecureUserProfiles(pCurrDrive);

        if ( _wcsicmp(pszSystemDrive, pCurrDrive) == 0 ) {

                //
                // always use the same databases and log files for convert
                //

                //
                // check config options
                //

                rc = ScepServerConfigureSystem(
                                              InfFileName,
                                              DatabaseName,
                                              LogFileName,
                                              0,
                                              AREA_FILE_SECURITY
                                              );

                if (rc != ERROR_SUCCESS) {
                    ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_TEMPLATE_APPLY, rc, pCurrDrive);
                } else {
                    ScepLogOutput3(0,0, SCEDLL_CONVERT_SUCCESS_TEMPLATE_APPLY, pCurrDrive);
                }


        }

        //
        // Secure the IIS Folders/Files
        //
        ScepSecureIISFolders(szWinDir, pCurrDrive);

        //
        // for now use MARTA to set root DACL (another possibility is to use root.inf when checked in)
        //

        //
        // set root DACL - use MARTA to set security
        //

        if ( rc == ERROR_SUCCESS ) {
            //
            // extract DACL once only
            //

            SECURITY_INFORMATION SeInfo = 0;

            if (!bRootDaclExtracted) {

                rc = ScepExtractRootDacl(&pSDSet, &pDacl, &SeInfo);

                ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_DACL, rc, SDDLRoot);

            }

            if (rc == ERROR_SUCCESS) {

                //
                // reuse szWinDir
                //

                PWSTR   szCurrDriveSlashed = szWinDir;

                memset(szCurrDriveSlashed, '\0', (MAX_PATH + 1) * sizeof(WCHAR));
                wcsncpy(szCurrDriveSlashed, pCurrDrive, 5);
                wcscat(szCurrDriveSlashed, L"\\");

                bRootDaclExtracted = TRUE;

                rc = SetNamedSecurityInfo(szCurrDriveSlashed,
                                          SE_FILE_OBJECT,
                                          SeInfo,
                                          NULL,
                                          NULL,
                                          pDacl,
                                          NULL
                                         );

                if (rc != ERROR_SUCCESS) {
                    ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_MARTA, rc, szCurrDriveSlashed);
                } else {
                    ScepLogOutput3(0,0, SCEDLL_CONVERT_SUCCESS_MARTA, szCurrDriveSlashed);
                }

            }
        }

        if (rc != ERROR_SUCCESS) {
            LogEvent(MyModuleHandle,
                     STATUS_SEVERITY_INFORMATIONAL,
                     SCEEVENT_INFO_ERROR_CONVERT_DRIVE,
                     0,
                     pCurrDrive
                    );
        } else {
            LogEvent(MyModuleHandle,
                     STATUS_SEVERITY_INFORMATIONAL,
                     SCEEVENT_INFO_SUCCESS_CONVERT_DRIVE,
                     0,
                     pCurrDrive
                    );
        }

        if (rc != ERROR_SUCCESS) {
            rcSave = rc;
            rc = ERROR_SUCCESS;
        }

    }

    //
    // delete the value (done using this value)
    //

    ScepRegDeleteValue(
                      HKEY_LOCAL_MACHINE,
                      SCE_ROOT_PATH,
                      L"FatNtfsConvertedDrives"
                      );

    if (pSDSet) {
        LocalFree(pSDSet);
    }

    //
    // if scheduled, then services.exe allocated space - so free it
    //

    LocalFree(pmszDriveNames);

    ScepLogClose();

ExitHandler:

    if ( LogFileName )
        SafeAllocaFree( LogFileName );
    if ( InfFileName )
        SafeAllocaFree( InfFileName );
    if ( DatabaseName )        
        SafeAllocaFree( DatabaseName );
    if ( pszSystemDrive )        
        SafeAllocaFree( pszSystemDrive );

    return;
}


DWORD
ScepExamineDriveInformation(
    IN  PWSTR   pszRootDrive,
    IN  PWSTR   LogFileName,
    OUT BOOL    *pbSetSecurity
    )
/*++

Routine Description:

    If drive type is remote or FAT, do not set security.

Arguments:

    pszRootDrive    - Name of drive (Null terminated)

    pbSetSecurity   - whether we should attempt to set security on this drive


Return:

    win32 error code
--*/
{

    UINT    DriveType;
    DWORD   FileSystemFlags;
    DWORD   rc = ERROR_SUCCESS;
    WCHAR   pszDriveNameWithSlash[MAX_PATH];

    if (pszRootDrive == NULL || pbSetSecurity == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    pszDriveNameWithSlash[0] = L'\0';

    //
    // drives are of type c:\ only (cannot have drives of type cd:\)
    //

    memset(pszDriveNameWithSlash, '\0', MAX_PATH * sizeof(WCHAR));
    wcsncpy(pszDriveNameWithSlash, pszRootDrive, 5);
    wcscat(pszDriveNameWithSlash, L"\\");

    //
    // detect if the partition is FAT
    //
    DriveType = GetDriveType(pszDriveNameWithSlash);

    if ( DriveType == DRIVE_FIXED ||
         DriveType == DRIVE_RAMDISK ) {

        if ( GetVolumeInformation(pszDriveNameWithSlash,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL,
                                  &FileSystemFlags,
                                  NULL,
                                  0
                                 ) ) {

            if ( !(FileSystemFlags & FS_PERSISTENT_ACLS)  ) {
                //
                // only set security on NTFS partition
                //
                ScepLogOutput3(0,0, SCEDLL_CONVERT_ROOT_NON_NTFS, pszRootDrive);

                *pbSetSecurity = FALSE;

            }

        } else {
            //
            // something is wrong
            //
            rc = GetLastError();

            ScepLogOutput3(0,0, SCEDLL_CONVERT_ROOT_ERROR_QUERY_VOLUME, rc, pszRootDrive);

            *pbSetSecurity = FALSE;

        }
    }
    else {
        //
        // do not set security on remote drives
        //
        ScepLogOutput3(0,0, SCEDLL_CONVERT_ROOT_NOT_FIXED_VOLUME, pszRootDrive);

        *pbSetSecurity = FALSE;

    }

    return(rc);
}



DWORD
ScepExtractRootDacl(
    OUT PSECURITY_DESCRIPTOR    *ppSDSet,
    OUT PACL    *ppDacl,
    OUT SECURITY_INFORMATION *pSeInfo
    )
/*++

Routine Description:

    Extract root dacl (binary) from golden SD in (in text)

Arguments:

    ppDacl    - pointer to pointer to converted binary dacl


Return:

    win32 error code (DWORD)
--*/
{

    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwSize=0;
    BOOLEAN tFlag;
    BOOLEAN aclPresent = FALSE;
    SECURITY_DESCRIPTOR_CONTROL Control=0;
    ULONG Revision;


    if ( ppSDSet == NULL || ppDacl == NULL || pSeInfo == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    rc = ConvertTextSecurityDescriptor (SDDLRoot,
                                        ppSDSet,
                                        &dwSize,
                                        pSeInfo
                                       );

    if (rc == ERROR_SUCCESS) {



        RtlGetControlSecurityDescriptor (
                *ppSDSet,
                &Control,
                &Revision
                );

        //
        // Get DACL address
        //

        *ppDacl = NULL;
        rc = RtlNtStatusToDosError(
                  RtlGetDaclSecurityDescriptor(
                                *ppSDSet,
                                &aclPresent,
                                ppDacl,
                                &tFlag));

        if (rc == NO_ERROR && !aclPresent )
            *ppDacl = NULL;

        //
        // if error occurs for this one, do not set. return
        //

        if ( Control & SE_DACL_PROTECTED ) {
            *pSeInfo |= PROTECTED_DACL_SECURITY_INFORMATION;
        }



    }

    return rc;

}


VOID
ScepWaitForServicesEventAndConvertSecurityThreadFunc(
    IN PVOID pV
    )
/*++

Routine Description:

    The main purpose of this thread is to wait for the autostart services event and thereafter call
    ScepConfigureConvertedFileSecurityThreadFunc to do the real configuration work

Arguments:

    pV              -  thread argument simply passed on to ScepConfigureConvertedFileSecurityThreadFunc

Return:

    none
--*/
{

    HANDLE  hConvertCanStartEvent = NULL;
    DWORD   Status;
    WCHAR   LogFileName[MAX_PATH + sizeof(L"\\security\\logs\\convert.log") + 1];

    LogFileName[0] = L'\0';

    if ( GetSystemWindowsDirectory( LogFileName, MAX_PATH ) == 0 ) {

        //
        // too bad if this happens - can't log anwhere
        //

        return;
    }

    //
    // same log file is used by this thread as well as the actual configuration
    // routine ScepConfigureConvertedFileSecurityThreadFunc (without passing handles)
    //

    wcscat(LogFileName, L"\\security\\logs\\convert.log");

    ScepEnableDisableLog(TRUE);

    ScepSetVerboseLog(3);

    if ( ScepLogInitialize( LogFileName ) == ERROR_INVALID_NAME ) {

        ScepLogOutput3(1,0, SCEDLL_LOGFILE_INVALID, LogFileName );

    }

    hConvertCanStartEvent =  OpenEvent(
                                SYNCHRONIZE,
                                FALSE,
                                SC_AUTOSTART_EVENT_NAME
                                );

    if (hConvertCanStartEvent == NULL) {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_EVENT_HANDLE, GetLastError(), SC_AUTOSTART_EVENT_NAME);

        if (pV) {
            LocalFree(pV);
        }

        ScepLogClose();

        return;
    }

    //
    // timeout after 10 mins
    //

    Status = WaitForSingleObjectEx(
                                   hConvertCanStartEvent,
                                   10*60*1000,
                                   FALSE
                                   );
    //
    // done using the handle
    //

    CloseHandle(hConvertCanStartEvent);

    if (Status == WAIT_OBJECT_0) {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_SUCCESS_EVENT_WAIT, SC_AUTOSTART_EVENT_NAME);

        //
        // close the log file - since ScepConfigureConvertedFileSecurityThreadFunc will
        // need to open a handle to the same log file
        //

        ScepLogClose();

        ScepConfigureConvertedFileSecurityReboot(pV);

    } else {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_EVENT_WAIT, RtlNtStatusToDosError(Status), SC_AUTOSTART_EVENT_NAME);

        ScepLogClose();
    }

    ExitThread(RtlNtStatusToDosError(Status));

    return;

}

VOID
ScepSecureUserProfiles(
    PWSTR   pCurrDrive
    )
/*++

Routine Description:

    Configure Docs&Settings and folders under it

Arguments:

    None

Return:

    win32Error code
--*/
{
    DWORD   rc = ERROR_SUCCESS;
    WCHAR   szProfilesDir[MAX_PATH + 1];

    szProfilesDir[0] = L'\0';

    BOOL  bSecureUserProfiles = TRUE;

    if (pCurrDrive == NULL) {
        return;
    }

    DWORD   dwLen = MAX_PATH;
    //
    // don't care for error translating this environment variable -
    // just log and continue
    //

    if ( GetProfilesDirectory(szProfilesDir, &dwLen ) ){

        //
        // both strings are NULL terminated
        //

        ULONG uPosition;

        for ( uPosition = 0;
             szProfilesDir[uPosition] != L'\0' &&
             pCurrDrive[uPosition] != L'\0' &&
             szProfilesDir[uPosition] != L':' &&
             pCurrDrive[uPosition] != L':' &&
             towlower(szProfilesDir[uPosition]) ==  towlower(pCurrDrive[uPosition]);
             uPosition++ );

        if (!(uPosition > 0 &&
            szProfilesDir[uPosition] == L':' &&
            pCurrDrive[uPosition] == L':')) {

            //
            // only if mismatch happened, do not set user profiles
            //

            bSecureUserProfiles = FALSE;

        }

    }

    else {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_BAD_ENV_VAR, L"%USERPROFILE%");

    }

    if ( bSecureUserProfiles ) {

        //
        // DetermineProfilesLocation secures Docs&Settings
        // SecureUserProfiles() secures folders under Docs&Settings
        //

        if ( DetermineProfilesLocation(FALSE) ){

            SecureUserProfiles();

        }

        else {

            rc = GetLastError();

        }

    }

    if ( bSecureUserProfiles ) {

        if ( rc == ERROR_SUCCESS ) {

            ScepLogOutput3(0,0, SCEDLL_CONVERT_SUCCESS_PROFILES_DIR, pCurrDrive);

        } else {

            ScepLogOutput3(0,rc, SCEDLL_CONVERT_ERROR_PROFILES_DIR, pCurrDrive);

        }
    }

    return;
}


BOOL
ScepSecureIISFolders(
    IN PWSTR pszWindir,
    IN PWSTR pszCurrDrive
    )
/*++

Routine Description:

    Secures the IIS folders that exists in the drive
    being converted.

Arguments:

    pszWinDir       - The Windows directory path.

    pszCurrDrive    - The drive being converted.


Return:

    TRUE on success and FALSE on failuer
    
--*/
{

    PWSTR           pszIISDllFullPath = NULL;
    DWORD           dwSize = 0;
    HMODULE         hIISDll = NULL;
    BOOL            rc = TRUE;
    pApplyIISAcl    pAclIIS = NULL;
    DWORD           WinErr = ERROR_SUCCESS;

    //
    // parameter validation
    //
    if(!pszWindir ||
       !pszCurrDrive ||
       L'\0' == pszCurrDrive[0]){

        return FALSE;

    }

    //
    // build the full path expanded path to iis.dll
    // %windir%\system32\setup\iis.dll
    //
    dwSize = (wcslen(pszWindir) + wcslen(SCE_IIS_DLL) + 1)*sizeof(WCHAR);

    pszIISDllFullPath = (PWSTR) ScepAlloc(LMEM_ZEROINIT, dwSize);

    if(!pszIISDllFullPath){

        return FALSE;

    }

    wcscpy(pszIISDllFullPath, pszWindir);
    wcscat(pszIISDllFullPath, SCE_IIS_DLL);

    //
    // load iis.dll
    //
    hIISDll = LoadLibraryEx(pszIISDllFullPath,
                            NULL,
                            LOAD_WITH_ALTERED_SEARCH_PATH
                            );

    if(NULL == hIISDll){

        rc = FALSE;
        WinErr = GetLastError();
        ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_DLL_LOAD , WinErr, pszIISDllFullPath, pszCurrDrive);
        goto ExitHandler;

    }

    //
    // Get the address of the function 
    // BOOL ApplyIISAcl( WCHAR cDriveLetter, BOOL bAdd );
    // from iis.dll
    //
    pAclIIS = (pApplyIISAcl) GetProcAddress(hIISDll,
                                            SCE_IIS_FUNCTIONA
                                            );

    if(NULL == pAclIIS){

        rc = FALSE;
        WinErr = GetLastError();
        ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_DLL_FUNCTION  , WinErr, SCE_IIS_FUNCTION, pszIISDllFullPath, pszCurrDrive);
        goto ExitHandler;

    }

    //
    // call the function
    // this function will secure all IIS folders for the given
    // drive letter.
    //
    __try{

        rc = (*pAclIIS)(pszCurrDrive[0], TRUE);

    }
    __except(EXCEPTION_EXECUTE_HANDLER){

        rc = FALSE;

    }

ExitHandler:

    //
    // clean up.
    //
    if ( rc ) {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_SUCCESS_IIS_DIR, pszCurrDrive);

    } else {

        ScepLogOutput3(0,rc, SCEDLL_CONVERT_ERROR_IIS_DIR, pszCurrDrive);

    }

    if(pszIISDllFullPath){

        ScepFree(pszIISDllFullPath);

    }

    if(hIISDll){

        FreeLibrary(hIISDll);

    }

    return rc;

}

DWORD
ScepConfigureConvertedFileSecurityImmediate(
                                           IN PWSTR    pszDriveName
                                           )
/*++

Routine Description:

    The actual routine to configure setup style security for drives converted from FAT to NTFS.

    We are dealing only with a non system drive (whatever the OS maybe), we just use MARTA APIs to set
    security on the root drive (from scecli itself). Currently, this is the design since there is no
    reliable way of parsing the boot files (boot.ini/boot.nvr) and take care of dual boot scenarios.

    Note on error reporting:
        All errors are logged to the logfile %windir%\security\logs\convert.log. but if it is not possible
        to log an error to the logfile, we log it to the event log with source "SceSrv". Also, higher level
        errors/successes are logged to both the logfile and the eventlog.

    Note that this routine could be done in the client but due to commonality of the error logging,
    functionality etc, an RPC call is made to the server

Arguments:

    pszDriveName   -   Name of the volume to be converted
                        (not freed by services.exe - freed by convert.exe)


Return:

    win32 error code
--*/
{

    DWORD rc = ERROR_SUCCESS;
    DWORD rcSave = ERROR_SUCCESS;

    //
    // folders to use for logging etc.
    //

    WCHAR   LogFileName[MAX_PATH + sizeof(L"\\security\\logs\\convert.log")+1];
    PWSTR   pszSystemDrive = NULL;
    PWSTR   pszWinDir = NULL;

    SafeAllocaAllocate( pszSystemDrive, (MAX_PATH + 1) * sizeof(WCHAR) );
    SafeAllocaAllocate( pszWinDir, (MAX_PATH + 1) *sizeof(WCHAR) );

    if (pszSystemDrive == NULL ||
        pszWinDir == NULL) {
        
        rc = ERROR_NOT_ENOUGH_MEMORY;
        
        goto ExitHandler;
    }


    //
    // other variables
    //

    BOOL    bImmediate;
    BOOL    bSetSecurity = TRUE;
    PSECURITY_DESCRIPTOR    pSDSet=NULL;
    PACL    pDacl=NULL;
    BOOLEAN bRootDaclExtracted = FALSE;

    //
    // before attempting to do any useful work, validate arguments for this thread etc.
    // todo - should we handle exceptions ?
    //
    (void) InitializeEvents(L"SceSrv");

    if (pszDriveName == NULL) {

        //
        // should not happen - parameters have been checked by all callers
        //

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_PARAMETER,
                 IDS_ERROR_CONVERT_PARAMETER
                );

        rc = ERROR_INVALID_PARAMETER;

        goto ExitHandler;
    }

    pszSystemDrive[0] = L'\0';

    //
    // ready the log file, logging level etc.
    //

    pszWinDir[0] = L'\0';
    LogFileName[0] = L'\0';

    if ( GetSystemWindowsDirectory( pszWinDir, MAX_PATH ) == 0 ) {

        //
        // too bad if this happens
        //

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_BAD_ENV_VAR,
                 IDS_ERROR_CONVERT_BAD_ENV_VAR,
                 L"%windir%"
                );

        rc = ERROR_ENVVAR_NOT_FOUND;

        goto ExitHandler;
    }

    wcscpy(LogFileName, pszWinDir);
    wcscat(LogFileName, L"\\security\\logs\\convert.log");

    ScepEnableDisableLog(TRUE);

    ScepSetVerboseLog(3);

    if ( ScepLogInitialize( LogFileName ) == ERROR_INVALID_NAME ) {

        ScepLogOutput3(1,0, SCEDLL_LOGFILE_INVALID, LogFileName );

    }

    //
    // continue even if we cannot initialize log file but we absolutely
    // need the following environment var, so if we can't get it, quit
    //

    if ( GetEnvironmentVariable( L"SYSTEMDRIVE", pszSystemDrive, MAX_PATH) == 0 ) {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_BAD_ENV_VAR, L"%SYSTEMDRIVE%");

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_BAD_ENV_VAR,
                 IDS_ERROR_CONVERT_BAD_ENV_VAR,
                 L"%systemdrive%"
                );

        ScepLogClose();
        
        rc = ERROR_ENVVAR_NOT_FOUND;

        goto ExitHandler;
    }

    //
    // called immediately (not reboot/scheduled conversion)
    // template never used here - only marta
    //

    PWSTR  pCurrDrive = pszDriveName;

    rc = ScepExamineDriveInformation(pCurrDrive, LogFileName, &bSetSecurity);

    if (rc == ERROR_SUCCESS && bSetSecurity) {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_ROOT_NTFS_VOLUME, pCurrDrive);

        //
        // set security on userprofiles directory if root of profile dir == current drive
        //

        ScepSecureUserProfiles(pCurrDrive);

        //
        // Secure the IIS Folders/Files
        //
        ScepSecureIISFolders(pszWinDir, pCurrDrive);

        //
        // non system drive - use MARTA to set security
        //

        //
        // extract DACL once only, potentially for multiple "other-OS" drives
        //

        SECURITY_INFORMATION SeInfo = 0;

        if (!bRootDaclExtracted) {

            rc = ScepExtractRootDacl(&pSDSet, &pDacl, &SeInfo);

            ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_DACL, rc, SDDLRoot);

        }

        if (rc == ERROR_SUCCESS) {

            WCHAR   szCurrDriveSlashed[MAX_PATH];

            memset(szCurrDriveSlashed, '\0', (MAX_PATH) * sizeof(WCHAR));
            wcsncpy(szCurrDriveSlashed, pCurrDrive, 5);
            wcscat(szCurrDriveSlashed, L"\\");

            bRootDaclExtracted = TRUE;

            rc = SetNamedSecurityInfo(szCurrDriveSlashed,
                                      SE_FILE_OBJECT,
                                      SeInfo,
                                      NULL,
                                      NULL,
                                      pDacl,
                                      NULL
                                     );

            if (rc != ERROR_SUCCESS) {
                ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_MARTA, rc, szCurrDriveSlashed);
            } else {
                ScepLogOutput3(0,0, SCEDLL_CONVERT_SUCCESS_MARTA, szCurrDriveSlashed);
            }


        }

    }

    if (rc != ERROR_SUCCESS) {
        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_INFORMATIONAL,
                 SCEEVENT_INFO_ERROR_CONVERT_DRIVE,
                 0,
                 pCurrDrive
                );
    } else {
        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_INFORMATIONAL,
                 SCEEVENT_INFO_SUCCESS_CONVERT_DRIVE,
                 0,
                 pCurrDrive
                );
    }

    if (rc != ERROR_SUCCESS) {
        rcSave = rc;
    }


    if (pSDSet) {
        LocalFree(pSDSet);
    }

    ScepLogClose();


ExitHandler:    
    if ( pszSystemDrive )        
        SafeAllocaFree( pszSystemDrive );

    if ( pszWinDir )        
        SafeAllocaFree( pszWinDir );

    return rc ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\dsobject.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsobject.cpp

Abstract:

    Routines to configure/analyze security of DS objects

Author:

    Jin Huang (jinhuang) 7-Nov-1996

--*/
#include "headers.h"
#include "serverp.h"
#include <io.h>
#include <lm.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <ntldap.h>
#pragma hdrstop

//#define SCEDS_DBG 1

//
// NT-Security-Descriptor attribute's LDAP name.
//
#define ACTRL_SD_PROP_NAME  L"nTSecurityDescriptor"

//
// LDAP handle
//
PLDAP Thread  pLDAP = NULL;
BOOL  Thread  StartDsCheck=FALSE;

DWORD
ScepConvertObjectTreeToLdap(
    IN PSCE_OBJECT_TREE pObject
    );

SCESTATUS
ScepConfigureDsObjectTree(
    IN PSCE_OBJECT_TREE  ThisNode
    );

DWORD
ScepSetDsSecurityOverwrite(
    PWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor OPTIONAL,
    SECURITY_INFORMATION SeInfo,
    PSCE_OBJECT_CHILD_LIST pNextLevel OPTIONAL
    );

BOOL
ScepIsMatchingSchemaObject(
    PWSTR  Class,
    PWSTR  ClassDn
    );

DWORD
ScepAnalyzeDsObjectTree(
    IN PSCE_OBJECT_TREE ThisNode
    );

DWORD
ScepAnalyzeDsObject(
    IN PWSTR ObjectFullName,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo
    );

DWORD
ScepAnalyzeDsObjectAndChildren(
    IN PWSTR ObjectName,
    IN BYTE Status,
    IN SECURITY_INFORMATION SeInfo,
    IN PSCE_OBJECT_CHILD_LIST pNextLevel
    );

PSECURITY_DESCRIPTOR
ScepMakeNullSD();

DWORD
ScepChangeSecurityOnObject(
    PWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    SECURITY_INFORMATION SeInfo
    );

DWORD
ScepReadDsObjSecurity(
    IN  PWSTR                  pwszObject,
    IN  SECURITY_INFORMATION   SeInfo,
    OUT PSECURITY_DESCRIPTOR  *ppSD
    );

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// Functions to configure DS object security
//
//
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SCESTATUS
ScepConfigureDsSecurity(
    IN PSCE_OBJECT_TREE   pObject
    )
/* ++

Routine Description:

   Configure the ds object security as specified in pObject tree.
   This routine should only be executed on a domain controller.

Arguments:

    pObject - The ds object tree. The objects in the tree are in
    the format of Jet index (o=,dc=,...cn=), need to convert before
    calls to ldap

Return value:

   SCESTATUS error codes

++ */
{

    SCESTATUS            rc;
    DWORD               Win32rc;

    //
    // open the Ldap server
    //
    rc = ScepLdapOpen(NULL);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // process the tree node format to ldap format
        //
        Win32rc = ScepConvertObjectTreeToLdap(pObject);

        if ( Win32rc == ERROR_SUCCESS ) {
            //
            // do not need bind because ConvertObjectTreeToLadp already does that
            //
            //
            // configure the object tree
            //
            rc = ScepConfigureDsObjectTree(pObject);

        } else {
            ScepLogOutput3(1, Win32rc,
                         SCEDLL_ERROR_CONVERT_LDAP,
                         pObject->ObjectFullName);
            rc = ScepDosErrorToSceStatus(Win32rc);
        }

        ScepLdapClose(NULL);

    }

    return(rc);
}


SCESTATUS
ScepConfigureDsObjectTree(
    IN PSCE_OBJECT_TREE  ThisNode
    )
/* ++
Routine Description:

    This routine set security information to each DS object in the tree. DS
    objects are configured separately from file/registry objects because the
    logic behind ds objects is different.


Arguments:

    ThisNode - one node in the tree

Return value:

    SCESTATUS

-- */
{
    if ( ThisNode == NULL )
        return(SCESTATUS_SUCCESS);

    SCESTATUS        rc=SCESTATUS_SUCCESS;
    //
    // if IGNORE is set, skip this node
    //
    if ( ThisNode->Status != SCE_STATUS_CHECK &&
         ThisNode->Status != SCE_STATUS_OVERWRITE &&
         ThisNode->Status != SCE_STATUS_NO_AUTO_INHERIT )
        goto SkipNode;

    if ( ThisNode->pSecurityDescriptor != NULL ) {

        ScepLogOutput3(2, 0, SCEDLL_SCP_CONFIGURE, ThisNode->ObjectFullName);
        //
        // notify the progress bar if there is any
        //
        ScepPostProgress(1, AREA_DS_OBJECTS, ThisNode->ObjectFullName);
    }
    //
    // Process this node first
    //
    if ( ThisNode->pSecurityDescriptor != NULL ||
         ThisNode->Status == SCE_STATUS_OVERWRITE ) {

        ScepLogOutput3(1, 0, SCEDLL_SCP_CONFIGURE, ThisNode->ObjectFullName);

        DWORD Win32Rc;
        //
        // set security to the ds object and all children
        // because the OVERWRITE flag.
        //
        if ( ThisNode->Status == SCE_STATUS_OVERWRITE ) {
            //
            // prepare for next level nodes
            //
            for ( PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
                  pTemp != NULL;
                  pTemp = pTemp->Next ) {

                if ( pTemp->Node->pSecurityDescriptor == NULL &&
                     pTemp->Node->Status != SCE_STATUS_IGNORE )

                    pTemp->Node->Status = SCE_STATUS_OVERWRITE;
            }

            //
            // recursive set objects under the node, exclude nodes in the tree
            //
            Win32Rc = ScepSetDsSecurityOverwrite(
                            ThisNode->ObjectFullName,
                            ThisNode->pSecurityDescriptor,
                            ThisNode->SeInfo,
                            ThisNode->ChildList
                            );

        } else {

            Win32Rc = ScepChangeSecurityOnObject(
                        ThisNode->ObjectFullName,
                        ThisNode->pSecurityDescriptor,
                        ThisNode->SeInfo
                        );
        }
        //
        // ignore the following error codes
        //
        if ( Win32Rc == ERROR_FILE_NOT_FOUND ||
             Win32Rc == ERROR_PATH_NOT_FOUND ||
             Win32Rc == ERROR_ACCESS_DENIED ||
             Win32Rc == ERROR_SHARING_VIOLATION ||
             Win32Rc == ERROR_INVALID_OWNER ||
             Win32Rc == ERROR_INVALID_PRIMARY_GROUP) {

            gWarningCode = Win32Rc;
            rc = SCESTATUS_SUCCESS;
            goto SkipNode;
        }

        if ( Win32Rc != ERROR_SUCCESS )
            return(ScepDosErrorToSceStatus(Win32Rc));
    }

    //
    // then process children
    //
    for ( PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
          pTemp != NULL;
          pTemp = pTemp->Next ) {

        if ( pTemp->Node == NULL ) continue;

        rc = ScepConfigureDsObjectTree(
                    pTemp->Node
                    );
    }

SkipNode:

    return(rc);

}


DWORD
ScepSetDsSecurityOverwrite(
    PWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor OPTIONAL,
    SECURITY_INFORMATION SeInfo,
    PSCE_OBJECT_CHILD_LIST pNextLevel OPTIONAL
    )
{
    DWORD retErr=ERROR_SUCCESS;

    //
    // set security on the object first
    //
/*
    retErr = ScepSetSecurityWin32(
                ObjectName,
                SeInfo,
                pSecurityDescriptor,
                SE_DS_OBJECT
                );
*/
    retErr = ScepChangeSecurityOnObject(
                ObjectName,
                pSecurityDescriptor,
                SeInfo
                );
    if ( retErr == ERROR_SUCCESS ) {
        //
        // enumerate one level nodes under the current object
        //
        LDAPMessage *Message = NULL;
        PWSTR    Attribs[2];
        WCHAR    dn[] = L"distinguishedName";

        Attribs[0] = dn;
        Attribs[1] = NULL;

        retErr = ldap_search_s( pLDAP,
                  ObjectName,
                  LDAP_SCOPE_ONELEVEL,
                  L"(objectClass=*)",
                  Attribs,
                  0,
                  &Message);

        if( Message ) {
            retErr = ERROR_SUCCESS;

            LDAPMessage *Entry = NULL;
            //
            // How many entries ?
            //
            ULONG nChildren = ldap_count_entries(pLDAP, Message);
            //
            // get the first one.
            //
            Entry = ldap_first_entry(pLDAP, Message);
            //
            // now loop through the entries and recursively fix the
            // security on the subtree.
            //
            PWSTR  *Values;
            PWSTR SubObjectName;
            INT   cmpFlag;
            PSCE_OBJECT_CHILD_LIST pTemp;

            PSECURITY_DESCRIPTOR pNullSD = ScepMakeNullSD();

            for(ULONG i = 0; i<nChildren; i++) {

                if(Entry != NULL) {

                    Values = ldap_get_values(pLDAP, Entry, Attribs[0]);

                    if(Values != NULL) {
                        //
                        // Save the sub object DN for recursion.
                        //
                        SubObjectName = (PWSTR)LocalAlloc(0,(wcslen(Values[0]) + 1)*sizeof(WCHAR));
                        if ( SubObjectName != NULL ) {

                            wcscpy(SubObjectName, Values[0]);
#ifdef SCEDS_DBG
    printf("%ws\n", SubObjectName);
#endif
                            ldap_value_free(Values);
                            //
                            // check if the SubObjectName is in the object tree already
                            // SubObjectName should not contain extra spaces and comma is used as the delimiter
                            // if not, need a convert routine to handle it.
                            //
                            for ( pTemp = pNextLevel; pTemp != NULL; pTemp=pTemp->Next ) {
                                cmpFlag = _wcsicmp(pTemp->Node->ObjectFullName, SubObjectName);
                                if ( cmpFlag >= 0 )
                                    break;
                            }
                            if ( pTemp == NULL || cmpFlag > 0 ) {
                                //
                                // did not find in the object tree, so resurse it
                                //

                                retErr = ScepSetDsSecurityOverwrite(
                                                SubObjectName,
                                                pNullSD,
                                                (SeInfo & ( DACL_SECURITY_INFORMATION |
                                                            SACL_SECURITY_INFORMATION)),
                                                NULL
                                                );
                            }  // else find it, skip the subnode

                            LocalFree(SubObjectName);

                        } else {
                            ldap_value_free(Values);
                            retErr = ERROR_NOT_ENOUGH_MEMORY;
                        }

                    } else {
                        retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
                    }

                } else {
                    retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
                }

                if ( retErr != ERROR_SUCCESS ) {
                    break;
                }
                if ( i < nChildren-1 ) {
                    Entry = ldap_next_entry(pLDAP, Entry);
                }
            }  // end for loop

            //
            // free the NULL security descriptor
            //
            if ( pNullSD ) {
                ScepFree(pNullSD);
            }

            ldap_msgfree(Message);
        }
    }

    return(retErr);
}


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// Functions to analyze DS object security
//
//
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

BOOL
ScepIsMatchingSchemaObject(
    PWSTR  Class,
    PWSTR  ClassDn
    )
{
    //
    // Note: Class and ClassDn can't be NULL
    //
    ULONG   len = lstrlen(Class);
    ULONG   i;

    //
    // if the first component is not CN=, then no point continuing
    //
    if(*ClassDn != L'C') return FALSE;

    //
    // we need to match the name exactly.
    //
    for(i=0;i<len;i++)
    {
        if(ClassDn[i+3] != Class[i]) return FALSE;
    }

    //
    // things are good, but ensure that this is not just a prefix match!
    //
    if(ClassDn[i+3] == L',' || ClassDn[i+3] == L';')
        return TRUE;
    else
        return FALSE;
}


DWORD
ScepAnalyzeDsSecurity(
    IN PSCE_OBJECT_TREE pObject
    )
/* ++

Routine Description:

   Analyze the ds object security as specified in pObject tree.
   This routine should only be executed on a domain controller.

Arguments:

    pObject - The ds object tree

Return value:

   SCESTATUS error codes

++ */
{
    DWORD               Win32rc;

    //
    // open the Ldap server
    //
    Win32rc = ScepSceStatusToDosError( ScepLdapOpen(NULL) );

    if( Win32rc == ERROR_SUCCESS ) {
        //
        // process the tree node format to ldap format
        //
        Win32rc = ScepConvertObjectTreeToLdap(pObject);

        if ( Win32rc == ERROR_SUCCESS ) {
            //
            // analyze all ds objects to the level that NOT_CONFIGURED
            // status is raised for the node
            // no matter if the node is specified in the tree
            //
            StartDsCheck=FALSE;
            Win32rc = ScepAnalyzeDsObjectTree(pObject);

        } else {
            ScepLogOutput3(1, Win32rc,
                          SCEDLL_ERROR_CONVERT_LDAP, pObject->ObjectFullName);
        }

        ScepLdapClose(NULL);

    }

    return(Win32rc);
}


DWORD
ScepAnalyzeDsObjectTree(
    IN PSCE_OBJECT_TREE ThisNode
    )
/* ++
Routine Description:

    This routine analyze security information of each DS object in the tree. DS
    objects are analyzed separately from file/registry objects because the
    logic behind ds objects is different.


Arguments:

    ThisNode - one node in the tree

Return value:

    Win32 error codes

-- */
{

    if ( ThisNode == NULL )
        return(ERROR_SUCCESS);

    DWORD           Win32Rc=ERROR_SUCCESS;
    //
    // if IGNORE is set, log a SAP and skip this node
    //
    if ( ThisNode->Status != SCE_STATUS_CHECK &&
         ThisNode->Status != SCE_STATUS_OVERWRITE &&
         ThisNode->Status != SCE_STATUS_NO_AUTO_INHERIT ) {
        //
        // Log a point in SAP
        //
        Win32Rc = ScepSaveDsStatusToSection(
                    ThisNode->ObjectFullName,
                    ThisNode->IsContainer,
                    SCE_STATUS_NOT_CONFIGURED,
                    NULL,
                    0
                    );

        goto SkipNode;
    }

    if ( NULL != ThisNode->pSecurityDescriptor ) {
        //
        // notify the progress bar if there is any
        //
        ScepPostProgress(1, AREA_DS_OBJECTS, ThisNode->ObjectFullName);

        StartDsCheck = TRUE;

        ScepLogOutput3(1, 0, SCEDLL_SAP_ANALYZE, ThisNode->ObjectFullName);
        //
        // only analyze objects with explicit aces specified
        //
        Win32Rc = ScepAnalyzeDsObject(
                    ThisNode->ObjectFullName,
                    ThisNode->pSecurityDescriptor,
                    ThisNode->SeInfo
                    );
        //
        // if the object denies access, skip it.
        //
        if ( Win32Rc == ERROR_ACCESS_DENIED ||
             Win32Rc == ERROR_SHARING_VIOLATION) {
            //
            // log a point in SAP for skipping
            //
            Win32Rc = ScepSaveDsStatusToSection(
                        ThisNode->ObjectFullName,
                        ThisNode->IsContainer,
                        SCE_STATUS_ERROR_NOT_AVAILABLE,
                        NULL,
                        0
                        );
            if ( Win32Rc == ERROR_SUCCESS)
                goto ProcChild;
        }
        //
        // if the object specified in the profile does not exist, skip it and children
        //
        if ( Win32Rc == ERROR_FILE_NOT_FOUND ||
             Win32Rc == ERROR_PATH_NOT_FOUND ) {

            gWarningCode = Win32Rc;
            Win32Rc = ERROR_SUCCESS;
            goto SkipNode;
        }

    } else {
        //
        // log a point in SAP for not analyzing
        //
        Win32Rc = ScepSaveDsStatusToSection(
                    ThisNode->ObjectFullName,
                    ThisNode->IsContainer,
                    SCE_STATUS_CHILDREN_CONFIGURED,
                    NULL,
                    0
                    );

    }

    if ( Win32Rc != ERROR_SUCCESS )
        return(Win32Rc);

    //
    // if the status is NO_AUTO_INHERIT then all children except specified are N.C.ed
    // if status is overwrite, analyze everyone under
    // if status is check (auto inherit), everyone except specified should be "good" so don't go down
    //
    if ( (StartDsCheck && ThisNode->Status != SCE_STATUS_CHECK) ||
         (!StartDsCheck && NULL != ThisNode->ChildList ) ) {

        if ( ThisNode->Status == SCE_STATUS_OVERWRITE ) {
            //
            // prepare for next level nodes
            //
            for ( PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
                  pTemp != NULL;
                  pTemp = pTemp->Next ) {

                if ( pTemp->Node->pSecurityDescriptor == NULL &&
                     pTemp->Node->Status != SCE_STATUS_IGNORE )

                    pTemp->Node->Status = SCE_STATUS_OVERWRITE;
            }
        }
        //
        // make a SD which represents a NULL DACL and SACL
        //

        Win32Rc = ScepAnalyzeDsObjectAndChildren(
                        ThisNode->ObjectFullName,
                        ThisNode->Status,
                        (ThisNode->SeInfo &
                          (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)),
                        ThisNode->ChildList
                        );
        //
        // ignore the following errors
        //
        if ( Win32Rc == ERROR_FILE_NOT_FOUND ||
             Win32Rc == ERROR_PATH_NOT_FOUND ||
             Win32Rc == ERROR_ACCESS_DENIED ||
             Win32Rc == ERROR_SHARING_VIOLATION ||
             Win32Rc == ERROR_INVALID_OWNER ||
             Win32Rc == ERROR_INVALID_PRIMARY_GROUP) {

            gWarningCode = Win32Rc;
            Win32Rc = ERROR_SUCCESS;
        }
        if ( Win32Rc != ERROR_SUCCESS )
            return(Win32Rc);
    }

ProcChild:

    //
    // then process children
    //
    for (PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
        pTemp != NULL; pTemp = pTemp->Next ) {

        Win32Rc = ScepAnalyzeDsObjectTree(
                    pTemp->Node
                    );

        if ( Win32Rc != ERROR_SUCCESS ) {
            break;
        }
    }

SkipNode:

    return(Win32Rc);

}


DWORD
ScepAnalyzeDsObject(
    IN PWSTR ObjectFullName,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo
    )
/* ++

Routine Description:

   Get security setting for the current object and compare it with the profile
   setting. This routine analyzes the current object only. If there is
   difference in the security setting, the object will be added to the
   analysis database

Arguments:

   ObjectFullName     - The object's full path name

   ProfileSD          - security descriptor specified in the INF profile

   ProfileSeInfo      - security information specified in the INF profile

Return value:

   SCESTATUS error codes

++ */
{
    DWORD                   Win32rc=NO_ERROR;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor=NULL;

    //
    // get security information for this object
    //
/*
    Win32rc = GetNamedSecurityInfo(
                        ObjectFullName,
                        SE_DS_OBJECT,
                        ProfileSeInfo,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &pSecurityDescriptor
                        );
*/

    Win32rc = ScepReadDsObjSecurity(
                        ObjectFullName,
                        ProfileSeInfo,
                        &pSecurityDescriptor
                        );

    if ( Win32rc != ERROR_SUCCESS ) {
        ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_QUERY_SECURITY, ObjectFullName );
        return(Win32rc);
    }

//    printf("\n\n\nDs Obj Sec. for %ws\n", ObjectFullName);
//    ScepPrintSecurityDescriptor(pSecurityDescriptor, TRUE);


    //
    // Compare the analysis security descriptor with the profile
    //

    Win32rc = ScepCompareAndAddObject(
                        ObjectFullName,
                        SE_DS_OBJECT,
                        TRUE,
                        pSecurityDescriptor,
                        ProfileSD,
                        ProfileSeInfo,
                        TRUE,
                        NULL
                        );
    if ( Win32rc != ERROR_SUCCESS ) {
        ScepLogOutput3(1, Win32rc, SCEDLL_SAP_ERROR_ANALYZE, ObjectFullName);
    }

    ScepFree(pSecurityDescriptor);


    return(Win32rc);

}


DWORD
ScepAnalyzeDsObjectAndChildren(
    IN PWSTR ObjectName,
    IN BYTE Status,
    IN SECURITY_INFORMATION SeInfo,
    IN PSCE_OBJECT_CHILD_LIST pNextLevel
    )
/* ++

Routine Description:

   Analyze current object and all subkeys/files/directories under the object.
   If there is difference in security setting for any object, the object will
   be added to the analysis database.

Arguments:

   ObjectFullName     - The object's full path name

   ProfileSD          - security descriptor specified in the INF profile

   ProfileSeInfo      - security information specified in the INF profile

Return value:

   SCESTATUS error codes

++ */
{
    DWORD retErr=ERROR_SUCCESS;

    //
    // enumerate one level nodes under the current object
    //
    LDAPMessage *Message = NULL;
    PWSTR    Attribs[2];
    WCHAR    dn[] = L"distinguishedName";

    Attribs[0] = dn;
    Attribs[1] = NULL;

    retErr = ldap_search_s( pLDAP,
              ObjectName,
              LDAP_SCOPE_ONELEVEL,
              L"(objectClass=*)",
              Attribs,
              0,
              &Message);

    if( Message ) {
        retErr = ERROR_SUCCESS;

        LDAPMessage *Entry = NULL;
        //
        // How many entries ?
        //
        ULONG nChildren = ldap_count_entries(pLDAP, Message);
        //
        // get the first one.
        //
        Entry = ldap_first_entry(pLDAP, Message);
        //
        // now loop through the entries and recursively fix the
        // security on the subtree.
        //
        PWSTR  *Values;
        PWSTR SubObjectName;
        INT   cmpFlag;
        PSCE_OBJECT_CHILD_LIST pTemp;

        for(ULONG i = 0; i<nChildren; i++) {

            if(Entry != NULL) {

                Values = ldap_get_values(pLDAP, Entry, Attribs[0]);

                if(Values != NULL) {
                    //
                    // Save the sub object DN for recursion.
                    //
                    SubObjectName = (PWSTR)LocalAlloc(0,(wcslen(Values[0]) + 1)*sizeof(WCHAR));
                    if ( SubObjectName != NULL ) {

                        wcscpy(SubObjectName, Values[0]);
                        ldap_value_free(Values);
#ifdef SCEDS_DBG
    printf("%ws\n", SubObjectName);
#endif
                        //
                        // check if the SubObjectName is in the object tree already
                        //
                        for ( pTemp = pNextLevel; pTemp != NULL; pTemp=pTemp->Next ) {
                            cmpFlag = _wcsicmp(pTemp->Node->ObjectFullName, SubObjectName);
                            if ( cmpFlag >= 0 )
                                break;
                        }
                        if ( pTemp == NULL || cmpFlag > 0 ) {
                            //
                            // did not find in the object tree, so anayze it or recursive it
                            //
                            if ( Status == SCE_STATUS_OVERWRITE ) {
                                //
                                // analyze this file/key first
                                //
                                retErr = ScepAnalyzeDsObject(
                                                SubObjectName,
                                                NULL,
                                                SeInfo
                                                );
                                //
                                // if the object does not exist (impossible), skip all children
                                //
                                if ( retErr == ERROR_ACCESS_DENIED ||
                                     retErr == ERROR_SHARING_VIOLATION ) {

                                    gWarningCode = retErr;

                                    retErr = ScepSaveDsStatusToSection(
                                                    SubObjectName,
                                                    TRUE,
                                                    SCE_STATUS_ERROR_NOT_AVAILABLE,
                                                    NULL,
                                                    0
                                                    );
                                    retErr = ERROR_SUCCESS;

                                }
                                if ( retErr == ERROR_FILE_NOT_FOUND ||
                                     retErr == ERROR_PATH_NOT_FOUND ) {

                                    gWarningCode = retErr;
                                    retErr = ERROR_SUCCESS;

                                } else if ( retErr == SCESTATUS_SUCCESS ) {
                                    //
                                    // recursive to next level
                                    //
                                    retErr = ScepAnalyzeDsObjectAndChildren(
                                                    SubObjectName,
                                                    Status,
                                                    SeInfo,
                                                    NULL
                                                    );
                                }

                            } else {
                                //
                                // status is check, just raise a NOT_CONFIGURED status
                                //
                                retErr = ScepSaveDsStatusToSection(
                                                SubObjectName,
                                                TRUE,
                                                SCE_STATUS_NOT_CONFIGURED,
                                                NULL,
                                                0
                                                );
                            }

                        }  // else find it, skip the subnode

                        LocalFree(SubObjectName);

                    } else {
                        ldap_value_free(Values);
                        retErr = ERROR_NOT_ENOUGH_MEMORY;
                    }

                } else {
                    retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
                }

            } else {
                retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
            }

            if ( retErr != ERROR_SUCCESS ) {
                break;
            }
            if ( i < nChildren-1 ) {
                Entry = ldap_next_entry(pLDAP, Entry);
            }
        }  // end for loop

        ldap_msgfree(Message);
    }

    return(retErr);
}


DWORD
ScepConvertObjectTreeToLdap(
    IN PSCE_OBJECT_TREE pObject
    )
{
    DWORD Win32rc;
    PWSTR NewName=NULL;

    if ( pObject == NULL ) {
        return(ERROR_SUCCESS);
    }

    //
    // this node
    //
    Win32rc = ScepConvertJetNameToLdapCase(
                    pObject->ObjectFullName,
                    FALSE,
                    SCE_CASE_DONT_CARE,
                    &NewName
                    );

    if ( Win32rc == ERROR_SUCCESS && NewName != NULL ) {

        ScepFree(pObject->ObjectFullName);
        pObject->ObjectFullName = NewName;

        //
        // child
        //
        for ( PSCE_OBJECT_CHILD_LIST pTemp = pObject->ChildList;
              pTemp != NULL; pTemp = pTemp->Next ) {

            Win32rc = ScepConvertObjectTreeToLdap(
                            pTemp->Node
                            );
            if ( Win32rc != ERROR_SUCCESS ) {
                break;
            }
        }

    }

    return(Win32rc);
}


DWORD
ScepConvertJetNameToLdapCase(
    IN PWSTR JetName,
    IN BOOL bLastComponent,
    IN BYTE bCase,
    OUT PWSTR *LdapName
    )
{
    if ( JetName == NULL || LdapName == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD retErr;
    PWSTR pTempName=NULL;

    //
    // reserve the components
    //
    retErr = ScepSceStatusToDosError(
                ScepConvertLdapToJetIndexName(
                     JetName,
                     &pTempName
                     ) );

    if ( retErr == ERROR_SUCCESS && pTempName == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( retErr == ERROR_SUCCESS ) {

        if ( bCase == SCE_CASE_REQUIRED ||
             bCase == SCE_CASE_PREFERED ) {

            if ( pLDAP == NULL ) {
                //
                // ldap is not available
                //
                retErr = ERROR_NOT_SUPPORTED;

            } else {

                //
                // go search in the DS tree
                //
                LDAPMessage *Message = NULL;          // for LDAP calls.
                PWSTR    Attribs[2];                  // for LDAP calls.

                Attribs[0] = L"distinguishedName";
                Attribs[1] = NULL;

                retErr = ldap_search_s( pLDAP,
                                        pTempName,
                                        LDAP_SCOPE_BASE,
                                        L"(objectClass=*)",
                                        Attribs,
                                        0,
                                        &Message);

                if( Message ) {

                    retErr = ERROR_SUCCESS;
                    LDAPMessage *Entry = NULL;

                    Entry = ldap_first_entry(pLDAP, Message);

                    if(Entry != NULL) {
                        //
                        // Values here is a new scope pointer
                        //
                        PWSTR *Values = ldap_get_values(pLDAP, Entry, Attribs[0]);

                        if(Values != NULL) {
                            //
                            // Values[0] is the DN.
                            // save it in pTempName
                            //
                            PWSTR pTemp2 = (PWSTR)ScepAlloc(0, (wcslen(Values[0])+1)*sizeof(WCHAR));

                            if ( pTemp2 != NULL ) {

                                wcscpy(pTemp2, Values[0]);

                                ScepFree(pTempName);
                                pTempName = pTemp2;

                            } else
                                retErr = ERROR_NOT_ENOUGH_MEMORY;

                            ldap_value_free(Values);

                        } else
                            retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
                    } else
                        retErr = LdapMapErrorToWin32(pLDAP->ld_errno);

                    ldap_msgfree(Message);
                }
            }

            if ( (retErr != ERROR_SUCCESS && bCase == SCE_CASE_REQUIRED) ||
                 retErr == ERROR_NOT_ENOUGH_MEMORY ) {

                ScepFree(pTempName);
                return(retErr);
            }
        }
        if ( pTempName == NULL ) {
            // ???
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        //
        // ignore other errors for CASE_PREFERED
        //
        retErr = ERROR_SUCCESS;

        if ( bLastComponent ) {
            //
            // only return the first component
            // pTempName must not be NULL. it shouldn't be NULL
            //
            PWSTR pStart = wcschr(pTempName, L',');

            if ( pStart == NULL ) {
                *LdapName = pTempName;

            } else {
                *LdapName = (PWSTR)ScepAlloc(0, ((UINT)(pStart-pTempName+1))*sizeof(WCHAR));

                if ( *LdapName == NULL ) {
                    retErr = ERROR_NOT_ENOUGH_MEMORY;

                } else {
                    wcsncpy(*LdapName, pTempName, (size_t)(pStart-pTempName));
                    *(*LdapName+(pStart-pTempName)) = L'\0';
                }
                ScepFree(pTempName);
            }

        } else {
            //
            // return the whole name
            //
            *LdapName = pTempName;
        }

    }

    return(retErr);
}


SCESTATUS
ScepDsObjectExist(
    IN PWSTR ObjectName
    )
// ObjectName must be in Ldap format
{
    DWORD retErr;
    LDAPMessage *Message = NULL;          // for LDAP calls.
    PWSTR    Attribs[2];                  // for LDAP calls.

    Attribs[0] = L"distinguishedName";
    Attribs[1] = NULL;

    retErr = ldap_search_s( pLDAP,
                            ObjectName,
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)",
                            Attribs,
                            0,
                            &Message);

    if( Message ) {
        retErr = ERROR_SUCCESS;

        LDAPMessage *Entry = NULL;

        Entry = ldap_first_entry(pLDAP, Message);

        if(Entry != NULL) {
            //
            // Values here is a new scope pointer
            //
            PWSTR *Values = ldap_get_values(pLDAP, Entry, Attribs[0]);

            if(Values != NULL) {

                ldap_value_free(Values);

            } else
                retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
        } else
            retErr = LdapMapErrorToWin32(pLDAP->ld_errno);

        ldap_msgfree(Message);
    }

    return(ScepDosErrorToSceStatus(retErr));

}


SCESTATUS
ScepEnumerateDsOneLevel(
    IN PWSTR ObjectName,
    OUT PSCE_NAME_LIST *pNameList
    )
{
    if ( ObjectName == NULL || pNameList == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD retErr=ERROR_SUCCESS;
    //
    // enumerate one level nodes under the current object
    //
    LDAPMessage *Message = NULL;
    PWSTR    Attribs[2];
    WCHAR    dn[] = L"distinguishedName";

    Attribs[0] = dn;
    Attribs[1] = NULL;

    retErr = ldap_search_s( pLDAP,
              ObjectName,
              LDAP_SCOPE_ONELEVEL,
              L"(objectClass=*)",
              Attribs,
              0,
              &Message);

    if( Message ) {
        retErr = ERROR_SUCCESS;

        LDAPMessage *Entry = NULL;
        //
        // How many entries ?
        //
        ULONG nChildren = ldap_count_entries(pLDAP, Message);
        //
        // get the first one.
        //
        Entry = ldap_first_entry(pLDAP, Message);
        //
        // now loop through the entries and recursively fix the
        // security on the subtree.
        //
        PWSTR  *Values;

        for(ULONG i = 0; i<nChildren; i++) {

            if(Entry != NULL) {

                Values = ldap_get_values(pLDAP, Entry, Attribs[0]);

                if(Values != NULL) {
                    //
                    // Save the sub object DN for recursion.
                    //
                    retErr = ScepAddToNameList(
                                    pNameList,
                                    Values[0],
                                    wcslen(Values[0])
                                    );

                    ldap_value_free(Values);

                } else {
                    retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
                }

            } else {
                retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
            }

            if ( retErr != ERROR_SUCCESS ) {
                break;
            }
            if ( i < nChildren-1 ) {
                Entry = ldap_next_entry(pLDAP, Entry);
            }
        }  // end for loop

        ldap_msgfree(Message);
    }

    if ( retErr != ERROR_SUCCESS ) {
        //
        // free the object list
        //
        ScepFreeNameList(*pNameList);
        *pNameList = NULL;
    }

    return(ScepDosErrorToSceStatus(retErr));
}


DWORD
ScepChangeSecurityOnObject(
    PWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    SECURITY_INFORMATION SeInfo
    )
{
    PLDAPMod        rgMods[2];
    PLDAP_BERVAL    pBVals[2];
    LDAPMod         Mod;
    LDAP_BERVAL     BVal;
    DWORD     retErr;
    BYTE            berValue[8];

    //
    // JohnsonA The BER encoding is current hardcoded.  Change this to use
    // AndyHe's BER_printf package once it's done.
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    rgMods[0] = &Mod;
    rgMods[1] = NULL;

    pBVals[0] = &BVal;
    pBVals[1] = NULL;

    //
    // lets set object security (whack NT-Security-Descriptor)
    //
    Mod.mod_op      = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    Mod.mod_type    = ACTRL_SD_PROP_NAME;
    Mod.mod_values  = (PWSTR *)pBVals;

    //
    // calculate the length of the security descriptor
    //
    if ( pSecurityDescriptor == NULL )
        BVal.bv_len = 0;
    else {
        BVal.bv_len = RtlLengthSecurityDescriptor(pSecurityDescriptor);
    }
    BVal.bv_val = (PCHAR)(pSecurityDescriptor);

    //
    // Now, we'll do the write...
    //
    retErr = ldap_modify_ext_s(pLDAP,
                           ObjectName,
                           rgMods,
                           ServerControls,
                           NULL);

    return(retErr);
}


DWORD
ScepReadDsObjSecurity(
    IN  PWSTR                  pwszObject,
    IN  SECURITY_INFORMATION   SeInfo,
    OUT PSECURITY_DESCRIPTOR  *ppSD
    )
{
    DWORD   dwErr;

    PLDAPMessage    pMessage = NULL;
    PWSTR           rgAttribs[2];
    BYTE            berValue[8];

    //
    //  JohnsonA The BER encoding is current hardcoded.  Change this to use
    // AndyHe's BER_printf package once it's done.
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    rgAttribs[0] = ACTRL_SD_PROP_NAME;
    rgAttribs[1] = NULL;

    dwErr = ldap_search_ext_s(pLDAP,
                              pwszObject,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgAttribs,
                              0,
                              ServerControls,
                              NULL,
                              NULL,
                              10000,
                              &pMessage);

    if( pMessage ) {
        dwErr = ERROR_SUCCESS;

        LDAPMessage *pEntry = NULL;

        pEntry = ldap_first_entry(pLDAP,
                                  pMessage);

        if(pEntry == NULL) {

            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );

        } else {
            //
            // Now, we'll have to get the values
            //
            PWSTR *ppwszValues = ldap_get_values(pLDAP,
                                                 pEntry,
                                                 rgAttribs[0]);
            if(ppwszValues == NULL) {
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );

            } else {
                PLDAP_BERVAL *pSize = ldap_get_values_len(pLDAP,
                                                          pMessage,
                                                          rgAttribs[0]);
                if(pSize == NULL) {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );

                } else {
                    //
                    // Allocate the security descriptor to return
                    //
                    *ppSD = (PSECURITY_DESCRIPTOR)ScepAlloc(0, (*pSize)->bv_len);
                    if(*ppSD == NULL) {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;

                    } else {
                        memcpy(*ppSD,
                               (PBYTE)(*pSize)->bv_val,
                               (*pSize)->bv_len);
                    }
                    ldap_value_free_len(pSize);
                }
                ldap_value_free(ppwszValues);
            }
        }

        ldap_msgfree(pMessage);
    }

    return(dwErr);
}


PSECURITY_DESCRIPTOR
ScepMakeNullSD()
{
    PSECURITY_DESCRIPTOR pNullSD = NULL;
    DWORD dwErr=ERROR_SUCCESS;


#if 0

    pNullSD = (PSECURITY_DESCRIPTOR)ScepAlloc(0, sizeof(SECURITY_DESCRIPTOR));

    if(pNullSD == NULL) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        SetLastError(dwErr);

    } else {
        //
        // build the SD
        //
        if(InitializeSecurityDescriptor(pNullSD,
                                        SECURITY_DESCRIPTOR_REVISION
                                       ) == FALSE ) {
            dwErr = GetLastError();

        } else {
            if(SetSecurityDescriptorDacl(pNullSD,
                                         TRUE,
                                         NULL,
                                         FALSE) == FALSE) {
                dwErr = GetLastError();
            } else {

                if(SetSecurityDescriptorSacl(pNullSD,
                                             TRUE,
                                             NULL,
                                             FALSE) == FALSE) {
                    dwErr = GetLastError();
                }

            }

        }

        if ( dwErr != ERROR_SUCCESS ) {

            ScepFree(pNullSD);
            pNullSD = NULL;

            SetLastError(dwErr);
        }
    }
#endif

    return(pNullSD);

}

SCESTATUS
ScepEnumerateDsObjectRoots(
    IN PLDAP pLdap OPTIONAL,
    OUT PSCE_OBJECT_LIST *pRoots
    )
{
    DWORD retErr;
    SCESTATUS rc=SCESTATUS_SUCCESS;
    LDAPMessage *Message = NULL;          // for LDAP calls.
    PWSTR    Attribs[2];                  // for LDAP calls.

    Attribs[0] = LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W;   // ntldap.h
    Attribs[1] = NULL;

    PLDAP pTempLdap;

    if ( pLdap == NULL )
        pTempLdap = pLDAP;
    else
        pTempLdap = pLdap;

    retErr = ldap_search_s(pTempLdap,
                          L"",
                          LDAP_SCOPE_BASE,
                          L"(objectClass=*)",
                          Attribs,
                          0,
                          &Message);

    if( Message ) { // should not check for error code

        retErr = ERROR_SUCCESS;

        LDAPMessage *Entry = NULL;
        //
        // read the first entry.
        // we did base level search, we have only one entry.
        // Entry does not need to be freed (it is freed with the message)
        //
        Entry = ldap_first_entry(pTempLdap, Message);
        if(Entry != NULL) {

            PWSTR *Values = ldap_get_values(pTempLdap, Entry, Attribs[0]);

            if(Values != NULL) {
                //
                // should only get one value for the default naming context
                // Values[0] here is the DN.
                //
                if ( Values[0] == NULL ) {
                    //
                    // unknown error.
                    //
                    rc = SCESTATUS_OTHER_ERROR;
                } else {
                    //
                    // add the full name to the object list
                    // search for base, only one value should be returned
                    //
                    rc = ScepAddToObjectList(
                            pRoots,
                            Values[0],
                            wcslen(Values[0]),
                            TRUE,
                            SCE_STATUS_IGNORE,
                            0,
                            SCE_CHECK_DUP  //TRUE // check for duplicate
                            );
                }

                ldap_value_free(Values);

            } else
                retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);

        } else
            retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);

        ldap_msgfree(Message);
        Message = NULL;
    }

    if ( retErr != ERROR_SUCCESS ) {
        rc = ScepDosErrorToSceStatus(retErr);
    }

    return(rc);

}
/*

SCESTATUS
ScepEnumerateDsObjectRoots(
    IN PLDAP pLdap OPTIONAL,
    OUT PSCE_OBJECT_LIST *pRoots
    )
{
    DWORD retErr;
    SCESTATUS rc;
    LDAPMessage *Message = NULL;          // for LDAP calls.
    PWSTR    Attribs[2];                  // for LDAP calls.

    Attribs[0] = LDAP_OPATT_NAMING_CONTEXTS_W;
    Attribs[1] = NULL;

    PLDAP pTempLdap;

    if ( pLdap == NULL )
        pTempLdap = pLDAP;
    else
        pTempLdap = pLdap;

    retErr = ldap_search_s(pTempLdap,
                          L"",
                          LDAP_SCOPE_BASE,
                          L"(objectClass=*)",
                          Attribs,
                          0,
                          &Message);

    if(retErr == ERROR_SUCCESS) {

        LDAPMessage *Entry = NULL;
        //
        // read the first entry.
        // we did base level search, we have only one entry.
        // Entry does not need to be freed (it is freed with the message)
        //
        Entry = ldap_first_entry(pTempLdap, Message);
        if(Entry != NULL) {

            PWSTR *Values = ldap_get_values(pTempLdap, Entry, Attribs[0]);

            if(Values != NULL) {

                ULONG   ValCount = ldap_count_values(Values);
                ULONG   index;
                PWSTR   ObjectName;

                Attribs[0] = L"distinguishedName";
                Attribs[1] = NULL;
                //
                // process each NC
                //
                for(index = 0; index < ValCount; index++) {

                    if ( Values[index] == NULL ) {
                        continue;
                    }

                    if( ScepIsMatchingSchemaObject(L"Configuration", Values[index]) ||
                        ScepIsMatchingSchemaObject(L"Schema", Values[index]) ) {
                        //
                        // If it is the Configuration or Schema, skip it
                        // because it is under the domain node
                        // only the domain node is returned
                        //
                        continue;
                    }
                    //
                    // free the message so it can be reused
                    //
                    ldap_msgfree(Message);
                    Message = NULL;
                    //
                    // The root object of the NC
                    //
                    retErr = ldap_search_s( pTempLdap,
                                            Values[index],
                                            LDAP_SCOPE_BASE,
                                            L"(objectClass=*)",
                                            Attribs,
                                            0,
                                            &Message);

                    if(retErr == ERROR_SUCCESS) {

                        Entry = ldap_first_entry(pTempLdap, Message);

                        if(Entry != NULL) {
                            //
                            // Values here is a new scope pointer
                            //
                            PWSTR *Values = ldap_get_values(pTempLdap, Entry, Attribs[0]);

                            if(Values != NULL) {
                                //
                                // Values[0] is the DN.
                                //
                                if ( Values[0] == NULL ) {
                                    //
                                    // unknown error.
                                    //
                                    rc = SCESTATUS_OTHER_ERROR;
                                } else {
                                    //
                                    // add the full name to the object list
                                    // search for base, only one value should be returned
                                    //
                                    rc = ScepAddToObjectList(
                                            pRoots,
                                            Values[0],
                                            wcslen(Values[0]),
                                            TRUE,
                                            SCE_STATUS_IGNORE,
                                            0,
                                            SCE_CHECK_DUP //TRUE // check for duplicate
                                            );
                                }

                                ldap_value_free(Values);

                            } else
                                retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);
                        } else
                            retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);

                        if ( retErr != ERROR_SUCCESS ) {
                            break;
                        }
                    }
                }  // end for loop
                //
                // outer scope Values
                //
                ldap_value_free(Values);

            } else
                retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);
        } else
            retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);

        ldap_msgfree(Message);
        Message = NULL;
    }

    if ( retErr != ERROR_SUCCESS ) {
        rc = ScepDosErrorToSceStatus(retErr);
    }

    return(rc);

}
*/


SCESTATUS
ScepLdapOpen(
    OUT PLDAP *pLdap OPTIONAL
    )
{

#if _WIN32_WINNT<0x0500
    return SCESTATUS_SERVICE_NOT_SUPPORT;
#else

    DWORD               Win32rc;

    //
    // bind to ldap
    //
    PLDAP pTempLdap;
    pTempLdap = ldap_open(NULL, LDAP_PORT);

    if ( pTempLdap == NULL ) {

        Win32rc = ERROR_FILE_NOT_FOUND;

    } else {
        Win32rc = ldap_bind_s(pTempLdap,
                            NULL,
                            NULL,
                            LDAP_AUTH_SSPI);

    }
    if ( pLdap == NULL ) {
        pLDAP = pTempLdap;
    } else {
        *pLdap = pTempLdap;
    }
    pTempLdap = NULL;


    if ( Win32rc != ERROR_SUCCESS ) {
        ScepLogOutput3(0, Win32rc, SCEDLL_ERROR_OPEN, L"Ldap server.");
    }

    return(ScepDosErrorToSceStatus(Win32rc));

#endif

}

SCESTATUS
ScepLdapClose(
    IN PLDAP *pLdap OPTIONAL
    )
{
    if ( pLdap == NULL ) {

        if ( pLDAP != NULL )
            ldap_unbind(pLDAP);
        pLDAP = NULL;

        return(SCESTATUS_SUCCESS );
    }
    //
    // unbind pLDAP
    //
    if ( *pLdap != NULL )
        ldap_unbind(*pLdap);

    *pLdap = NULL;

    return(SCESTATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\errlog.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    errlog.c

Abstract:

    Routines to handle error log information

Author:

    Jin Huang (jinhuang) 9-Nov-1996

Revision History:

--*/

#include "headers.h"
#include "serverp.h"
#include <winnls.h>
#include <alloca.h>

#pragma hdrstop
#define SCESRV_LOG_PATH  L"\\security\\logs\\scesrv.log"

extern HINSTANCE MyModuleHandle;
HANDLE  Thread hMyLogFile=INVALID_HANDLE_VALUE;

BOOL
ScepCheckLogging(
    IN INT ErrLevel,
    IN DWORD rc
    );

SCESTATUS
ScepSetVerboseLog(
    IN INT dbgLevel
    )
{
    DWORD dValue;

    if ( dbgLevel > 0 ) {
        gDebugLevel = dbgLevel;

    } else {

        //
        // load value from registry
        //
        if ( ScepRegQueryIntValue(
                HKEY_LOCAL_MACHINE,
                SCE_ROOT_PATH,
                L"DebugLevel",
                &dValue
                ) == SCESTATUS_SUCCESS )
            gDebugLevel = (INT)dValue;
        else
            gDebugLevel = 1;
    }

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepEnableDisableLog(
   IN BOOL bOnOff
   )
{
   bLogOn = bOnOff;

   if ( INVALID_HANDLE_VALUE != hMyLogFile ) {
       CloseHandle( hMyLogFile );
   }

   //
   // Reset the LogFileName buffer and return
   //

   hMyLogFile = INVALID_HANDLE_VALUE;

   return(SCESTATUS_SUCCESS);
}



SCESTATUS
ScepLogInitialize(
   IN PCWSTR logname
   )
/* ++
Routine Description:

   Open the log file specified and save the name and its handle in global
   variables.

Arguments:

   logname - log file name

Return value:

   SCESTATUS error code

-- */
{
    DWORD  rc=NO_ERROR;

    if ( !bLogOn ) {
        return(rc);
    }

    if ( logname && 
         wcslen(logname) > 3 && 
         TRUE == ScepIsValidFileOrDir((PWSTR)logname)) {

        hMyLogFile = CreateFile(logname,
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if ( INVALID_HANDLE_VALUE != hMyLogFile ) {

            DWORD dwBytesWritten;

            SetFilePointer (hMyLogFile, 0, NULL, FILE_BEGIN);

            CHAR TmpBuf[3];
            TmpBuf[0] = (CHAR)0xFF;
            TmpBuf[1] = (CHAR)0xFE;
            TmpBuf[2] = '\0';

            WriteFile (hMyLogFile, (LPCVOID)TmpBuf, 2,
                       &dwBytesWritten,
                       NULL);

            SetFilePointer (hMyLogFile, 0, NULL, FILE_END);

        }

    } else {
        hMyLogFile = INVALID_HANDLE_VALUE;
    }

    BOOL bOpenGeneral = FALSE;

    if ( INVALID_HANDLE_VALUE == hMyLogFile ) {

        //
        // use the general server log
        //
        LPTSTR dName=NULL;
        DWORD dirSize=0;

        DWORD rc2 = ScepGetNTDirectory(
                            &dName,
                            &dirSize,
                            SCE_FLAG_WINDOWS_DIR
                            );

        if ( ERROR_SUCCESS == rc2 && dName ) {

            LPTSTR windirName = (LPTSTR)ScepAlloc(0, (dirSize+wcslen(SCESRV_LOG_PATH)+1)*sizeof(TCHAR));

            if ( windirName ) {

                wcscpy(windirName, dName);
                wcscat(windirName, SCESRV_LOG_PATH);

                //
                // only keep current log transaction. if other threads are holding
                // on this log, it won't be deleted. It's ok (will be deleted later).
                //
                DeleteFile(windirName);

                hMyLogFile = CreateFile(windirName,
                                       GENERIC_WRITE,
                                       FILE_SHARE_READ,
                                       NULL,
                                       OPEN_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL);

                if ( hMyLogFile != INVALID_HANDLE_VALUE ) {

                    DWORD dwBytesWritten;

                    SetFilePointer (hMyLogFile, 0, NULL, FILE_BEGIN);

                    CHAR TmpBuf[3];
                    TmpBuf[0] = (CHAR)0xFF;
                    TmpBuf[1] = (CHAR)0xFE;
                    TmpBuf[2] = '\0';

                    WriteFile (hMyLogFile, (LPCVOID)TmpBuf, 2,
                               &dwBytesWritten,
                               NULL);

                    SetFilePointer (hMyLogFile, 0, NULL, FILE_END);
                }

                ScepFree(windirName);

                bOpenGeneral = TRUE;

            }
        }

        if ( dName ) {
            ScepFree(dName);
        }

    }

    if ( hMyLogFile == INVALID_HANDLE_VALUE ) {

        //
        // Open file fails. return error
        //

        if (logname != NULL)
            rc = ERROR_INVALID_NAME;
    }

    //
    // log a separator to the file
    //
    ScepLogOutput3(0, 0, SCEDLL_SEPARATOR);

    if ( bOpenGeneral && logname ) {
        //
        // the log file provided is not valid, log it
        //
        ScepLogOutput3(0, 0, IDS_ERROR_OPEN_LOG, logname);
    }

    //
    // Write date/time information to the begining of the log file or to screen
    //
    TCHAR pvBuffer[100];

    pvBuffer[0] = L'\0';
    rc = ScepGetTimeStampString(pvBuffer);

    if ( pvBuffer[0] != L'\0' )
        ScepLogOutput(0, pvBuffer);

    return(rc);
}


SCESTATUS
ScepLogOutput2(
   IN INT     ErrLevel,
   IN DWORD   rc,
   IN PWSTR   fmt,
   ...
  )
/* ++

Routine Description:

   This routine adds the information (variable arguments) to the end of the log file or
   prints to screen

Arguments:

   ErrLevel - the error level of this error (to determine if the error needs to be outputted)

   rc    - Win32 error code

   fmt   - the format of the error information

   ...  - variable argument list

Return value:

   SCESTATUS error code

-- */
{
    PWSTR              buf=NULL;
    va_list            args;

    if ( !ScepCheckLogging(ErrLevel, rc) ) {
        //
        // no log
        //
        return(SCESTATUS_SUCCESS);
    }
    //
    // check arguments
    //
    if ( !fmt )
        return(SCESTATUS_SUCCESS);

    //
    // safely allocate the buffer on stack (or heap)
    //
    SafeAllocaAllocate( buf, SCE_BUF_LEN*sizeof(WCHAR) );
    if ( buf == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    va_start( args, fmt );
    _vsnwprintf( buf, SCE_BUF_LEN - 1, fmt, args );
    va_end( args );

    buf[SCE_BUF_LEN-1] = L'\0';

    SCESTATUS rCode = ScepLogOutput(rc, buf);

    SafeAllocaFree( buf );

    return rCode;
}


SCESTATUS
ScepLogOutput(
    IN DWORD rc,
    IN LPTSTR buf
    )
{
    if ( !buf ) {
        return(SCESTATUS_SUCCESS);
    }

    LPVOID     lpMsgBuf=NULL;
    TCHAR      strLevel[32];
    INT        idLevel=0;

    if ( rc != NO_ERROR ) {

        //
        // determine if this is warning, or error
        //
        if ( rc == ERROR_FILE_NOT_FOUND ||
             rc == ERROR_PATH_NOT_FOUND ||
             rc == ERROR_ACCESS_DENIED ||
             rc == ERROR_CANT_ACCESS_FILE ||
             rc == ERROR_SHARING_VIOLATION ||
             rc == ERROR_INVALID_OWNER ||
             rc == ERROR_INVALID_PRIMARY_GROUP ||
             rc == ERROR_INVALID_HANDLE ||
             rc == ERROR_INVALID_SECURITY_DESCR ||
             rc == ERROR_INVALID_ACL ||
             rc == ERROR_SOME_NOT_MAPPED ) {
            //
            // this is warning
            //
            idLevel = IDS_WARNING;
        } else {
            //
            // this is error
            //
            idLevel = IDS_ERROR;
        }

        strLevel[0] = L'\0';

        if ( idLevel > 0 ) {

            LoadString( MyModuleHandle,
                        idLevel,
                        strLevel,
                        31
                        );
        }

        //
        // get error description of rc
        //

        FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                       NULL,
                       rc,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                       (LPTSTR)&lpMsgBuf,
                       0,
                       NULL
                    );
    }

    if ( hMyLogFile != INVALID_HANDLE_VALUE ) {

        //
        // The log file is initialized
        //
        if ( rc != NO_ERROR ) {
            if ( lpMsgBuf != NULL )
                ScepWriteVariableUnicodeLog( hMyLogFile, TRUE, L"%s %d: %s %s",
                                             strLevel, rc, (PWSTR)lpMsgBuf, buf );
            else
                ScepWriteVariableUnicodeLog( hMyLogFile, TRUE, L"%s %d: %s",
                                             strLevel, rc, buf );
        } else {
            if ( lpMsgBuf != NULL )
                ScepWriteVariableUnicodeLog( hMyLogFile, TRUE, L"%s %s",
                                             (PWSTR)lpMsgBuf, buf );
            else
                ScepWriteSingleUnicodeLog( hMyLogFile, TRUE, buf );
        }

    }

    if ( lpMsgBuf != NULL )
        LocalFree(lpMsgBuf);

    return(SCESTATUS_SUCCESS);
}


BOOL
ScepCheckLogging(
    IN INT ErrLevel,
    IN DWORD rc
    )
{

    DWORD      dValue;

    if ( rc )
        gWarningCode = rc;

    if ( !bLogOn ) {
        return(FALSE);
    }

    if ( gDebugLevel < 0 ) {
        //
        // load value from registry
        //
        if ( ScepRegQueryIntValue(
                HKEY_LOCAL_MACHINE,
                SCE_ROOT_PATH,
                L"DebugLevel",
                &dValue
                ) == SCESTATUS_SUCCESS )
            gDebugLevel = (INT)dValue;
        else
            gDebugLevel = 1;
    }
    //
    // return if the error level is higher than required
    //
    if ( ErrLevel > gDebugLevel ) {
        return(FALSE);
    } else {
        return(TRUE);
    }
}


SCESTATUS
ScepLogOutput3(
   IN INT     ErrLevel,
   IN DWORD   rc,
   IN UINT nId,
   ...
  )
/* ++

Routine Description:

   This routine load resource and adds error info (variable arguments)
   to the end of the log file or prints to screen

Arguments:

   ErrLevel - the error level of this error (to determine if the error needs to be outputted)

   rc    - Win32 error code

   nId   - the resource string ID

   ...  - variable argument list

Return value:

   SCESTATUS error code

-- */
{
    WCHAR              szTempString[256];
    PWSTR              buf=NULL;
    va_list            args;

    if ( !ScepCheckLogging(ErrLevel, rc) ) {
        //
        // no log
        //
        return(SCESTATUS_SUCCESS);
    }

    if ( nId > 0 ) {

        szTempString[0] = L'\0';

        LoadString( MyModuleHandle,
                    nId,
                    szTempString,
                    256
                    );

        //
        // safely allocate the buffer on stack (or heap)
        //
        SafeAllocaAllocate( buf, SCE_BUF_LEN*sizeof(WCHAR) );
        if ( buf == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }

        //
        // get the arguments
        //
        va_start( args, nId );
        _vsnwprintf( buf, SCE_BUF_LEN - 1, szTempString, args );
        va_end( args );

        buf[SCE_BUF_LEN-1] = L'\0';

        //
        // log it and free
        //
        SCESTATUS rCode = ScepLogOutput(rc, buf);

        SafeAllocaFree( buf );

        return rCode;
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepLogWriteError(
    IN PSCE_ERROR_LOG_INFO  pErrlog,
    IN INT ErrLevel
    )
/* ++
Routine Description:

   This routine outputs the error message in each node of the SCE_ERROR_LOG_INFO
   list to the log file

Arguments:

    pErrlog - the error list

Return value:

   None

-- */
{
    PSCE_ERROR_LOG_INFO  pErr;

    if ( !bLogOn ) {
        return(SCESTATUS_SUCCESS);
    }

    for ( pErr=pErrlog; pErr != NULL; pErr = pErr->next )
        if ( pErr->buffer != NULL )
            ScepLogOutput2( ErrLevel, pErr->rc, pErr->buffer );

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepLogClose()
/* ++
Routine Description:

   Close the log file if there is one opened. Clear the log varialbes

Arguments:

   None

Return value:

   None

--*/
{

    if ( !bLogOn ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( hMyLogFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( hMyLogFile );
    }

    //
    // Reset the log handle
    //

    hMyLogFile = INVALID_HANDLE_VALUE;

    return(SCESTATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\kerberos.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    kerberos.h

Abstract:

    Headers of apis for kerberos policy

Author:

    Jin Huang (jinhuang) 17-Dec-1997 created

Revision History:

    jinhuang 28-Jan-1998 splitted to client-server

--*/

#ifndef _sce_kerberos_
#define _sce_kerberos_

#ifdef __cplusplus
extern "C" {
#endif

SCESTATUS
ScepGetKerberosPolicy(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_KERBEROS_TICKET_INFO * ppKerberosInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepConfigureKerberosPolicy(
    IN PSCECONTEXT hProfile,
    IN PSCE_KERBEROS_TICKET_INFO pKerberosInfo,
    IN DWORD ConfigOptions
    );

SCESTATUS
ScepAnalyzeKerberosPolicy(
    IN PSCECONTEXT hProfile OPTIONAL,
    IN PSCE_KERBEROS_TICKET_INFO pKerInfo,
    IN DWORD Options
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\kerberos.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    kerberos.cpp

Abstract:

    Routines to read/write/configure kerberos policy settings

    The following modules have links to kerberos policy
        scejet.c    <SceJetAddSection>
        inftojet.c  <SceConvertpInfKeyValue>
        pfget.c     <ScepGetKerberosPolicy>
        config.c    <ScepConfigureKerberosPolicy>
        analyze.c   <ScepAnalyzeKerberosPolicy>

Author:

    Jin Huang (jinhuang) 17-Dec-1997

Revision History:

    jinhuang 28-Jan-1998 splitted to client-server

--*/

#include "headers.h"
#include "serverp.h"
#include "kerberos.h"
#include "kerbcon.h"
#include "pfp.h"

#define MAXDWORD    0xffffffff

static  PWSTR KerbItems[] = {
        {(PWSTR)TEXT("MaxTicketAge")},
        {(PWSTR)TEXT("MaxRenewAge")},
        {(PWSTR)TEXT("MaxServiceAge")},
        {(PWSTR)TEXT("MaxClockSkew")},
        {(PWSTR)TEXT("TicketValidateClient")}
        };

#define MAX_KERB_ITEMS      5

#define IDX_KERB_MAX        0
#define IDX_KERB_RENEW      1
#define IDX_KERB_SERVICE    2
#define IDX_KERB_CLOCK      3
#define IDX_KERB_VALIDATE   4


SCESTATUS
ScepGetKerberosPolicy(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_KERBEROS_TICKET_INFO * ppKerberosInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine retrieves kerberos policy information from the Jet database
   and stores in the output buffer ppKerberosInfo.

Arguments:

   hProfile     -  The profile handle context

   ppKerberosInfo -  the output buffer to hold kerberos settings.

   Errlog       -  A buffer to hold all error codes/text encountered when
                   parsing the INF file. If Errlog is NULL, no further error
                   information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_BAD_FORMAT
               SCESTATUS_INVALID_DATA

--*/

{
    SCESTATUS                rc;
    PSCESECTION              hSection=NULL;

    SCE_KEY_LOOKUP AccessKeys[] = {
        {(PWSTR)TEXT("MaxTicketAge"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxTicketAge),  'D'},
        {(PWSTR)TEXT("MaxRenewAge"),      offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxRenewAge),   'D'},
        {(PWSTR)TEXT("MaxServiceAge"),    offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxServiceAge),   'D'},
        {(PWSTR)TEXT("MaxClockSkew"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxClockSkew), 'D'},
        {(PWSTR)TEXT("TicketValidateClient"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, TicketValidateClient),  'D'}
    };

    DWORD cKeys = sizeof(AccessKeys) / sizeof(SCE_KEY_LOOKUP);
    SCE_KERBEROS_TICKET_INFO TicketInfo;

    if ( ppKerberosInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = ScepGetFixValueSection(
               hProfile,
               szKerberosPolicy,
               AccessKeys,
               cKeys,
               ProfileType,
               (PVOID)&TicketInfo,
               &hSection,
               Errlog
               );
    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }
    //
    // copy the value in TicketInfo to ppKerberosInfo
    //
    if ( NULL == *ppKerberosInfo ) {
        *ppKerberosInfo = (PSCE_KERBEROS_TICKET_INFO)ScepAlloc(0, sizeof(SCE_KERBEROS_TICKET_INFO));
    }

    if ( *ppKerberosInfo ) {

       memcpy(*ppKerberosInfo, &TicketInfo, sizeof(SCE_KERBEROS_TICKET_INFO));

    } else {

       rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    SceJetCloseSection(&hSection, TRUE);

    return(rc);
}

#if _WIN32_WINNT>=0x0500

SCESTATUS
ScepConfigureKerberosPolicy(
    IN PSCECONTEXT hProfile,
    IN PSCE_KERBEROS_TICKET_INFO pKerberosInfo,
    IN DWORD ConfigOptions
    )
/* ++

Routine Description:

   This routine configure the kerberos policy settings in the area of security
   policy.

Arguments:

   pKerberosInfo - The buffer which contains kerberos policy settings

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_OTHER_ERROR

-- */
{
   if ( !pKerberosInfo ) {
      //
      // if no info to configure
      //
      return SCESTATUS_SUCCESS;
   }

   NTSTATUS                      NtStatus;
   LSA_HANDLE                    lsaHandle=NULL;
   DWORD                         rc = NO_ERROR;
   BOOL                          bDefaultUsed=FALSE;
   BOOL                          bDefined=FALSE;

   //
   // open LSA policy to configure kerberos policy
   //
   NtStatus = ScepOpenLsaPolicy(
               MAXIMUM_ALLOWED,
               &lsaHandle,
               TRUE
               );

   if (!NT_SUCCESS(NtStatus)) {

       lsaHandle = NULL;
       rc = RtlNtStatusToDosError( NtStatus );
       ScepLogOutput3( 1, rc, SCEDLL_LSA_POLICY);

       if ( ConfigOptions & SCE_RSOP_CALLBACK )

           ScepRsopLog(SCE_RSOP_KERBEROS_INFO, rc, NULL, 0, 0);

       return(ScepDosErrorToSceStatus(rc));
   }
   //
   // query current kerberos policy settings into pBuffer
   //
   PPOLICY_DOMAIN_KERBEROS_TICKET_INFO pBuffer=NULL;
   POLICY_DOMAIN_KERBEROS_TICKET_INFO TicketInfo;

   NtStatus = LsaQueryDomainInformationPolicy(
                  lsaHandle,
                  PolicyDomainKerberosTicketInformation,
                  (PVOID *)&pBuffer
                  );

   if ( NT_SUCCESS(NtStatus) && pBuffer ) {
       //
       // transfer ticket info to TicketInfo buffer
       //
       TicketInfo.AuthenticationOptions = pBuffer->AuthenticationOptions;
       TicketInfo.MaxTicketAge = pBuffer->MaxTicketAge;
       TicketInfo.MaxRenewAge = pBuffer->MaxRenewAge;
       TicketInfo.MaxServiceTicketAge = pBuffer->MaxServiceTicketAge;
       TicketInfo.MaxClockSkew = pBuffer->MaxClockSkew;

       //
       // free the buffer
       //
       LsaFreeMemory((PVOID)pBuffer);

   } else {
       //
       // no kerberos policy is configured yet because by default it's not created.
       // let's create it now. set a default ticket info
       //
       TicketInfo.AuthenticationOptions = POLICY_KERBEROS_VALIDATE_CLIENT;

       TicketInfo.MaxTicketAge.QuadPart = (LONGLONG) KERBDEF_MAX_TICKET*60*60 * 10000000L;
       TicketInfo.MaxRenewAge.QuadPart = (LONGLONG) KERBDEF_MAX_RENEW*24*60*60 * 10000000L;
       TicketInfo.MaxServiceTicketAge.QuadPart = (LONGLONG) KERBDEF_MAX_SERVICE*60 * 10000000L;
       TicketInfo.MaxClockSkew.QuadPart = (LONGLONG) KERBDEF_MAX_CLOCK*60 * 10000000L;

       bDefaultUsed = TRUE;
   }
   pBuffer = &TicketInfo;

  //
  // process each field in pKerberosInfo
  //
  BOOL bFlagSet=FALSE;
  ULONG lOptions=0;
  ULONG lValue=0;

  SCE_TATTOO_KEYS *pTattooKeys=NULL;
  DWORD           cTattooKeys=0;

  PSCESECTION hSectionDomain=NULL;
  PSCESECTION hSectionTattoo=NULL;

#define MAX_KERB_KEYS           5


  //
  // if in policy propagation, open the policy sections
  // since kerberos policy is only available on DCs and kerberos policy (account policy)
  // can't be reset to local settings on each DC, there is no point to query/save
  // the tattoo values
  //
/* do not take tattoo value for kerberos
  if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
       hProfile ) {

      pTattooKeys = (SCE_TATTOO_KEYS *)ScepAlloc(LPTR,MAX_KERB_KEYS*sizeof(SCE_TATTOO_KEYS));

      if ( !pTattooKeys ) {
          ScepLogOutput3(1, ERROR_NOT_ENOUGH_MEMORY, SCESRV_POLICY_TATTOO_ERROR_CREATE);
      }
  }
*/
  if ( pKerberosInfo->MaxRenewAge != SCE_NO_VALUE ) {
      ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                               (PWSTR)L"MaxRenewAge", ConfigOptions,
                               KERBDEF_MAX_RENEW);
  }

  if ( pKerberosInfo->MaxRenewAge == SCE_FOREVER_VALUE ) {

      if ( pBuffer->MaxRenewAge.HighPart != MINLONG ||
           pBuffer->MaxRenewAge.LowPart != 0  ) {
          //
          // Maximum LARGE_INTEGER .ie. never
          //

          pBuffer->MaxRenewAge.HighPart = MINLONG;
          pBuffer->MaxRenewAge.LowPart = 0;
          bFlagSet = TRUE;

      }
      bDefined = TRUE;

  } else if ( SCE_NO_VALUE != pKerberosInfo->MaxRenewAge ) {

     //
     // ticket is renewable, the max age is stored in MaxRenewAge
     // using days
     //

      lValue = (DWORD) (pBuffer->MaxRenewAge.QuadPart /
                                     (LONGLONG)(10000000L) );
      lValue /= 3600;
      lValue /= 24;

      if ( lValue != pKerberosInfo->MaxRenewAge ) {

          pBuffer->MaxRenewAge.QuadPart = (LONGLONG)pKerberosInfo->MaxRenewAge*24*3600 * 10000000L;
          bFlagSet = TRUE;

      }

      bDefined = TRUE;
  }

  //
  // validate client ?
  //

  if ( pKerberosInfo->TicketValidateClient != SCE_NO_VALUE ) {

     if ( pKerberosInfo->TicketValidateClient ) {
        lOptions |= POLICY_KERBEROS_VALIDATE_CLIENT;
     }

     ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                              (PWSTR)L"TicketValidateClient", ConfigOptions,
                              KERBDEF_VALIDATE);

     if ( ( pBuffer->AuthenticationOptions & POLICY_KERBEROS_VALIDATE_CLIENT ) !=
          ( lOptions & POLICY_KERBEROS_VALIDATE_CLIENT ) ) {


         pBuffer->AuthenticationOptions = lOptions;
         bFlagSet = TRUE;
     }
     bDefined = TRUE;
  }

  //
  // max ticket age
  //
  if ( pKerberosInfo->MaxTicketAge != SCE_NO_VALUE ) {
      ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                               (PWSTR)L"MaxTicketAge", ConfigOptions,
                               KERBDEF_MAX_TICKET);
      bDefined = TRUE;
  }

  if ( pKerberosInfo->MaxTicketAge == SCE_FOREVER_VALUE ) {

      if ( pBuffer->MaxTicketAge.HighPart != MINLONG ||
           pBuffer->MaxTicketAge.LowPart != 0  ) {
          //
          // Maximum LARGE_INTEGER .ie. never
          //

          pBuffer->MaxTicketAge.HighPart = MINLONG;
          pBuffer->MaxTicketAge.LowPart = 0;
          bFlagSet = TRUE;
      }

      bDefined = TRUE;

  }  else if ( pKerberosInfo->MaxTicketAge != SCE_NO_VALUE ) {
      // in hours


      lValue = (DWORD) (pBuffer->MaxTicketAge.QuadPart /
                                     (LONGLONG)(10000000L) );
      lValue /= 3600;

      if ( lValue != pKerberosInfo->MaxTicketAge ) {

          pBuffer->MaxTicketAge.QuadPart = (LONGLONG)pKerberosInfo->MaxTicketAge*60*60 * 10000000L;
          bFlagSet = TRUE;
      }

      bDefined = TRUE;
  }

  //
  // max service ticket age
  //
  if ( pKerberosInfo->MaxServiceAge != SCE_NO_VALUE ) {
      ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                               (PWSTR)L"MaxServiceAge", ConfigOptions,
                               KERBDEF_MAX_SERVICE);
      bDefined = TRUE;
  }

  if ( pKerberosInfo->MaxServiceAge == SCE_FOREVER_VALUE ) {

      if ( pBuffer->MaxServiceTicketAge.HighPart != MINLONG ||
           pBuffer->MaxServiceTicketAge.LowPart != 0  ) {
          //
          // Maximum LARGE_INTEGER .ie. never
          //

          pBuffer->MaxServiceTicketAge.HighPart = MINLONG;
          pBuffer->MaxServiceTicketAge.LowPart = 0;
          bFlagSet = TRUE;
      }

      bDefined = TRUE;

  }  else if ( pKerberosInfo->MaxServiceAge != SCE_NO_VALUE ) {
      // in minutes


      lValue = (DWORD) (pBuffer->MaxServiceTicketAge.QuadPart /
                                     (LONGLONG)(10000000L) );
      lValue /= 60;

      if ( lValue != pKerberosInfo->MaxServiceAge ) {

          pBuffer->MaxServiceTicketAge.QuadPart = (LONGLONG)pKerberosInfo->MaxServiceAge*60 * 10000000L;
          bFlagSet = TRUE;
      }

      bDefined = TRUE;
  }

  //
  // max clock
  //
  if ( pKerberosInfo->MaxClockSkew != SCE_NO_VALUE ) {
      ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                               (PWSTR)L"MaxClockSkew", ConfigOptions,
                               KERBDEF_MAX_CLOCK);
      bDefined = TRUE;
  }

  if ( pKerberosInfo->MaxClockSkew == SCE_FOREVER_VALUE ) {

      if ( pBuffer->MaxClockSkew.HighPart != MINLONG ||
           pBuffer->MaxClockSkew.LowPart != 0  ) {

          //
          // Maximum LARGE_INTEGER .ie. never
          //

          pBuffer->MaxClockSkew.HighPart = MINLONG;
          pBuffer->MaxClockSkew.LowPart = 0;
          bFlagSet = TRUE;
      }
      bDefined = TRUE;

  }  else if ( pKerberosInfo->MaxClockSkew != SCE_NO_VALUE ) {
      // in minutes

      lValue = (DWORD) (pBuffer->MaxClockSkew.QuadPart /
                                     (LONGLONG)(10000000L) );
      lValue /= 60;

      if ( lValue != pKerberosInfo->MaxClockSkew ) {

          pBuffer->MaxClockSkew.QuadPart = (LONGLONG)pKerberosInfo->MaxClockSkew*60 * 10000000L;
          bFlagSet = TRUE;
      }
      bDefined = TRUE;
  }

  if ( bFlagSet || (bDefaultUsed && bDefined) ) {
     //
     // if anything for kerberos to configure
     //
      NtStatus = LsaSetDomainInformationPolicy(
               lsaHandle,
               PolicyDomainKerberosTicketInformation,
               (PVOID)pBuffer
               );
      rc = RtlNtStatusToDosError( NtStatus );

      if ( rc != NO_ERROR ) {
           ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_KERBEROS);
      } else {
           ScepLogOutput3(1, 0, SCEDLL_SCP_KERBEROS);
      }
  }

  if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
       hProfile && pTattooKeys && cTattooKeys ) {

      ScepTattooOpenPolicySections(
                    hProfile,
                    szKerberosPolicy,
                    &hSectionDomain,
                    &hSectionTattoo
                    );
      ScepLogOutput3(3,0,SCESRV_POLICY_TATTOO_ARRAY,cTattooKeys);
      //
      // some policy is different than the system setting
      // check if we should save the existing setting as the tattoo value
      // also remove reset'ed tattoo policy
      //
      ScepTattooManageValues(hSectionDomain, hSectionTattoo, pTattooKeys, cTattooKeys, rc);

      if ( hSectionDomain ) SceJetCloseSection(&hSectionDomain,TRUE);
      if ( hSectionTattoo ) SceJetCloseSection(&hSectionTattoo,TRUE);
  }

  if ( pTattooKeys ) ScepFree(pTattooKeys);

  if ( ConfigOptions & SCE_RSOP_CALLBACK )

      ScepRsopLog(SCE_RSOP_KERBEROS_INFO, rc, NULL, 0, 0);

   //
   // close LSA policy
   //
   LsaClose( lsaHandle );

   return(ScepDosErrorToSceStatus(rc));
}


SCESTATUS
ScepAnalyzeKerberosPolicy(
    IN PSCECONTEXT hProfile OPTIONAL,
    IN PSCE_KERBEROS_TICKET_INFO pKerInfo,
    IN DWORD Options
    )
/* ++

Routine Description:

   This routine queries the system kerberos policy settings and compare them
   with the template settings.

Arguments:

   hProfile - the profile context

   pKerInfo - The buffer which contains kerberos settings to compare with or
                the buffer to query system settings into

   Options  - the option(s) for the analysis, e.g., SCE_SYSTEM_SETTINGS

Return value:


-- */
{
    NTSTATUS                      NtStatus;
    LSA_HANDLE                    lsaHandle=NULL;
    DWORD                         rc32 = NO_ERROR;
    SCESTATUS                     rc=SCESTATUS_SUCCESS;
    PPOLICY_DOMAIN_KERBEROS_TICKET_INFO pBuffer=NULL;
    DWORD dValue;
    PSCESECTION hSection=NULL;
    POLICY_DOMAIN_KERBEROS_TICKET_INFO KerbTicketInfo;

    if ( !pKerInfo ) {
        //
        // if no template info, do not analyze
        //
        if ( Options & SCE_SYSTEM_SETTINGS ) {
            return SCESTATUS_INVALID_PARAMETER;
        } else {
            return SCESTATUS_SUCCESS;
        }
    }


    //
    // open LSA policy to configure kerberos policy
    //
    NtStatus = ScepOpenLsaPolicy(
               MAXIMUM_ALLOWED,
               &lsaHandle,
               TRUE
               );

    if (!NT_SUCCESS(NtStatus)) {

        lsaHandle = NULL;
        rc32 = RtlNtStatusToDosError( NtStatus );
        ScepLogOutput3( 1, rc32, SCEDLL_LSA_POLICY);

        return(ScepDosErrorToSceStatus(rc32));
    }

    if ( !(Options & SCE_SYSTEM_SETTINGS) ) {

        //
        // Prepare kerberos section
        //
        rc = ScepStartANewSection(
                 hProfile,
                 &hSection,
                 (Options & SCE_GENERATE_ROLLBACK) ? SCEJET_TABLE_SMP : SCEJET_TABLE_SAP,
                 szKerberosPolicy
                 );
    }

    if ( rc != SCESTATUS_SUCCESS ) {
      ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                    SCEDLL_SAP_START_SECTION, (PWSTR)szKerberosPolicy);

    } else {

        DWORD KerbValues[MAX_KERB_ITEMS];

        for ( dValue=0; dValue<MAX_KERB_ITEMS; dValue++ ) {
            KerbValues[dValue] = SCE_ERROR_VALUE;
        }

        //
        // query current kerberos policy settings into pBuffer
        //
        NtStatus = LsaQueryDomainInformationPolicy(
                      lsaHandle,
                      PolicyDomainKerberosTicketInformation,
                      (PVOID *)&pBuffer
                      );

        if ( STATUS_NOT_FOUND == NtStatus ) {

            //
            // there is no Kerberos policy
            //
            KerbTicketInfo.AuthenticationOptions = POLICY_KERBEROS_VALIDATE_CLIENT;

            KerbTicketInfo.MaxTicketAge.QuadPart = (LONGLONG) KERBDEF_MAX_TICKET*60*60 * 10000000L;
            KerbTicketInfo.MaxRenewAge.QuadPart = (LONGLONG) KERBDEF_MAX_RENEW*24*60*60 * 10000000L;
            KerbTicketInfo.MaxServiceTicketAge.QuadPart = (LONGLONG) KERBDEF_MAX_SERVICE*60 * 10000000L;
            KerbTicketInfo.MaxClockSkew.QuadPart = (LONGLONG) KERBDEF_MAX_CLOCK*60 * 10000000L;

            pBuffer = &KerbTicketInfo;
            NtStatus = STATUS_SUCCESS;
        }

        rc = ScepDosErrorToSceStatus(
                      RtlNtStatusToDosError( NtStatus ));

        if ( NT_SUCCESS(NtStatus) && pBuffer ) {

            //
            // analyze kerberos values
            // max ticket age
            //
            if ( pBuffer->MaxTicketAge.HighPart == MINLONG &&
                 pBuffer->MaxTicketAge.LowPart == 0 ) {
                //
                // Maximum password age value is MINLONG,0
                //
                dValue = SCE_FOREVER_VALUE;

            }  else {

                dValue = (DWORD) ( pBuffer->MaxTicketAge.QuadPart /
                                    (LONGLONG)(10000000L) );
                //
                // using hours
                //
                //           dValue /= 24;

                dValue /= 3600;

            }

            rc = SCESTATUS_SUCCESS;

            if ( Options & SCE_SYSTEM_SETTINGS ) {

                pKerInfo->MaxTicketAge = dValue;

            } else {

                rc = ScepCompareAndSaveIntValue(
                        hSection,
                        L"MaxTicketAge",
                        (Options & SCE_GENERATE_ROLLBACK),
                        pKerInfo->MaxTicketAge,
                        dValue);
            }

            if ( SCESTATUS_SUCCESS == rc ) {

                KerbValues[IDX_KERB_MAX] = 1;


                if ( pBuffer->MaxRenewAge.HighPart == MINLONG &&
                     pBuffer->MaxRenewAge.LowPart == 0 ) {
                    //
                    // Maximum age value is MINLONG,0
                    //
                    dValue = SCE_FOREVER_VALUE;

                }  else {

                    dValue = (DWORD) ( pBuffer->MaxRenewAge.QuadPart /
                                                   (LONGLONG)(10000000L) );
                    //
                    // using days
                    //
                    dValue /= 3600;
                    dValue /= 24;

                }

                if ( Options & SCE_SYSTEM_SETTINGS ) {

                    pKerInfo->MaxRenewAge = dValue;

                } else {

                    rc = ScepCompareAndSaveIntValue(
                            hSection,
                            L"MaxRenewAge",
                            (Options & SCE_GENERATE_ROLLBACK),
                            pKerInfo->MaxRenewAge,
                            dValue);
                }

                if ( SCESTATUS_SUCCESS == rc ) {

                    KerbValues[IDX_KERB_RENEW] = 1;

                    if ( pBuffer->MaxServiceTicketAge.HighPart == MINLONG &&
                         pBuffer->MaxServiceTicketAge.LowPart == 0 ) {
                        //
                        // Maximum age value is MINLONG,0
                        //
                        dValue = SCE_FOREVER_VALUE;

                    }  else {

                        dValue = (DWORD) ( pBuffer->MaxServiceTicketAge.QuadPart /
                                                       (LONGLONG)(10000000L) );
                        //
                        // using minutes
                        //
                        dValue /= 60;

                    }

                    if ( Options & SCE_SYSTEM_SETTINGS ) {

                        pKerInfo->MaxServiceAge = dValue;

                    } else {

                        rc = ScepCompareAndSaveIntValue(
                                hSection,
                                L"MaxServiceAge",
                                (Options & SCE_GENERATE_ROLLBACK),
                                pKerInfo->MaxServiceAge,
                                dValue);
                    }

                    if ( SCESTATUS_SUCCESS == rc ) {

                        KerbValues[IDX_KERB_SERVICE] = 1;

                        if ( pBuffer->MaxClockSkew.HighPart == MINLONG &&
                             pBuffer->MaxClockSkew.LowPart == 0 ) {
                            //
                            // Maximum age value is MINLONG,0
                            //
                            dValue = SCE_FOREVER_VALUE;

                        }  else {

                            dValue = (DWORD) ( pBuffer->MaxClockSkew.QuadPart /
                                                           (LONGLONG)(10000000L) );
                            //
                            // using minutes
                            //
                            dValue /= 60;

                        }

                        if ( Options & SCE_SYSTEM_SETTINGS ) {

                            pKerInfo->MaxClockSkew = dValue;

                        } else {

                            rc = ScepCompareAndSaveIntValue(
                                    hSection,
                                    L"MaxClockSkew",
                                    (Options & SCE_GENERATE_ROLLBACK),
                                    pKerInfo->MaxClockSkew,
                                    dValue);
                        }

                        if ( SCESTATUS_SUCCESS == rc ) {

                            KerbValues[IDX_KERB_CLOCK] = 1;

                            //
                            // validate client
                            //
                            dValue = ( pBuffer->AuthenticationOptions & POLICY_KERBEROS_VALIDATE_CLIENT ) ? 1 : 0;

                            if ( Options & SCE_SYSTEM_SETTINGS ) {

                                pKerInfo->TicketValidateClient = dValue;

                            } else {

                                rc = ScepCompareAndSaveIntValue(
                                          hSection,
                                          L"TicketValidateClient",
                                          (Options & SCE_GENERATE_ROLLBACK),
                                          pKerInfo->TicketValidateClient,
                                          dValue);
                            }

                            if ( SCESTATUS_SUCCESS == rc ) {

                                KerbValues[IDX_KERB_VALIDATE] = 1;
                            }
                        }
                    }
                }
            }

            if ( !(Options & SCE_SYSTEM_SETTINGS) ) {

                if ( rc == SCESTATUS_SUCCESS ) {

                    ScepLogOutput3( 1, 0, SCEDLL_SAP_KERBEROS);
                } else {
                    ScepLogOutput3( 1, ScepSceStatusToDosError(rc),
                         SCEDLL_SAP_ERROR_KERBEROS);
                }
            }

            if ( pBuffer != &KerbTicketInfo ) {

                //
                // free the buffer
                //
                LsaFreeMemory((PVOID)pBuffer);
            }
        }

        if ( !(Options & SCE_SYSTEM_SETTINGS) ) {

            if ( SCESTATUS_SUCCESS != rc &&
                 !(Options & SCE_GENERATE_ROLLBACK) ) {

                for ( dValue=0; dValue<MAX_KERB_ITEMS; dValue++ ) {
                    if ( KerbValues[dValue] == SCE_ERROR_VALUE ) {

                        ScepCompareAndSaveIntValue(
                                  hSection,
                                  KerbItems[dValue],
                                  FALSE,
                                  SCE_NO_VALUE,
                                  SCE_ERROR_VALUE
                                  );
                    }
                }
            }

            //
            // close the section
            //

            SceJetCloseSection(&hSection, TRUE);

        }
    }

    LsaClose( lsaHandle );

    if ( ( rc == SCESTATUS_PROFILE_NOT_FOUND) ||
        ( rc == SCESTATUS_RECORD_NOT_FOUND) ) {
       rc = SCESTATUS_SUCCESS;
    }

    return(rc);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\inftojet.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    inftojet.c

Abstract:

    Routines to convert security profiles in INF format to JET format.

Author:

    Jin Huang (jinhuang) 23-Jan-1997

Revision History:

--*/

#include "serverp.h"
#include "infp.h"
#include "pfp.h"
#include "regvalue.h"
#pragma hdrstop

//#define SCE_DBG 1
#define SCE_PRIV_ADD                TEXT("Add:")
#define SCE_PRIV_REMOVE             TEXT("Remove:")
#define SCE_REG_ADD                 SCE_PRIV_ADD
#define SCE_REG_REMOVE              SCE_PRIV_REMOVE

#define SCE_REG_ADD_REMOVE_VALUE    8

#define SCE_OBJECT_FLAG_OBJECTS              1
#define SCE_OBJECT_FLAG_OLDSDDL              2
#define SCE_OBJECT_FLAG_UNKNOWN_VERSION      4

//
// Forward references
//
SCEINF_STATUS
SceInfpGetOneObject(
    IN PINFCONTEXT pInfLine,
    IN DWORD ObjectFlag,
    OUT PWSTR *Name,
    OUT PWSTR *Value,
    OUT PDWORD ValueLen
    );

#define SCE_CONVERT_INF_MULTISZ         0x01
#define SCE_CONVERT_INF_PRIV            0x02
#define SCE_CONVERT_INF_GROUP           0x04
#define SCE_CONVERT_INF_NEWVERSION      0x08
#define SCE_CONVERT_INF_REGVALUE        0x10

SCESTATUS
SceConvertpInfKeyValue(
    IN PCWSTR InfSectionName,
    IN HINF   hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN DWORD dwConvertOption,
    IN LONG GpoID,
    IN OPTIONAL PCWSTR pcwszKey,
    OUT PSCE_NAME_LIST *pKeyList
    );

SCESTATUS
SceConvertpInfObject(
    IN PCWSTR InfSectionName,
    IN UINT ObjectType,
    IN DWORD ObjectFlag,
    IN HINF   hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID
    );

SCESTATUS
SceConvertpInfDescription(
    IN HINF hInf,
    IN PSCECONTEXT hProfile
    );

SCESTATUS
SceConvertpAttachmentSections(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID,
    IN SCE_ATTACHMENT_TYPE aType
    );

SCESTATUS
SceConvertpWMIAttachmentSections(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID
    );

SCESTATUS
SceConvertpOneAttachmentSection(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN PWSTR SectionName,
    IN DWORD dwTableOption,
    IN LONG GpoID
    );

SCESTATUS
ScepBuildNewPrivilegeList(
    IN LSA_HANDLE *pPolicyHandle,
    IN PWSTR PrivName,
    IN PWSTR mszUsers,
    IN ULONG dwBuildOption,
    OUT PWSTR *pmszNewUsers,
    OUT DWORD *pNewLen
    );

SCESTATUS
ScepAddToPrivilegeList(
    OUT PSCE_PRIVILEGE_VALUE_LIST  *pPrivilegeList,
    IN PWSTR Name,
    IN DWORD Len,
    IN DWORD PrivValue
    );

SCESTATUS
ScepBuildNewMultiSzRegValue(
    IN PWSTR    pszKeyName,
    IN PWSTR    pszStrValue,
    IN DWORD    dwValueLen,
    OUT PWSTR*  ppszNewValue,
    OUT PDWORD  pdwNewLen
    );

SCESTATUS
ScepBuildRegMultiSzValue(
    IN PWSTR    pszKeyName,
    IN PWSTR    pszAddList OPTIONAL,
    IN DWORD    dwAddLen,
    IN PWSTR    pszRemoveList OPTIONAL,
    IN DWORD    dwRemoveLen,
    IN PWSTR    pszPrefix,
    OUT PWSTR*  ppszNewValue,
    OUT PDWORD  pdwNewValueLen
    );



//
// Function definitions
//
SCESTATUS
SceJetConvertInfToJet(
    IN PCWSTR InfFile,
    IN LPSTR JetDbName,
    IN SCEJET_CREATE_TYPE Flags,
    IN DWORD Options,
    IN AREA_INFORMATION Area
    )
/**++

Function Description:

   This function converts a SCP profile in INF format to a Jet database format
   for the area provided. The SCP profile information is converted into the
   local policy table (SMP) in the Jet database.

   If the Jet database already exists, Flags is used to decide either overwrite,
   reuse, or just error out. All possible errors occur inside the routine are
   saved in the optional Errlog if Errlog is not NULL


Arguments:

   InfFile        - The Inf file name to convert from

   JetDbName      - the SCP profile in Jet format to convert into

   Flags          - Used when there is a duplicated Jet database
                        SCEJET_OVERWRITE
                        SCEJET_OPEN
                        0
   Options        - the conversion options

   Area           - the area to convert

Return Value:


-- **/
{
    PSCECONTEXT     hProfile=NULL;
    SCESTATUS       rc;
    PSCE_NAME_LIST  pProfileList=NULL,
                    pProfile=NULL;
    DWORD           Count;
    PSECURITY_DESCRIPTOR pSD=NULL;
    SECURITY_INFORMATION SeInfo;
    HINF            hInf=NULL;
    RPC_STATUS      RpcStatus=RPC_S_OK;

    INT Revision = 0;
    DWORD ObjectFlag=0;
    INFCONTEXT  InfLine;
    DWORD dwConvertOption=0;

    if ( InfFile == NULL ||
         JetDbName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // open the inf profile
    //
    rc = SceInfpOpenProfile(
                InfFile,
                &hInf
                );
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                     SCEDLL_ERROR_OPEN,
                     (PWSTR)InfFile);
        return(rc);

    }

    LONG   GpoID=0;

    //
    // create/open the Jet database
    //
    DWORD dwNewOption = 0;

    // MREGE_POLICY option allows opening the temp merge policy table to build new policy
    // TATTOO option allows creating/opening the tattoo table into SAP context
    if ( Options & SCE_POLICY_TEMPLATE )
        dwNewOption |= SCE_TABLE_OPTION_MERGE_POLICY | SCE_TABLE_OPTION_TATTOO;
    // this check handles setup case (to create/open tattoo table)
    else {
        if ( (Options & SCE_SYSTEM_DB) )
            dwNewOption |= SCE_TABLE_OPTION_TATTOO;
        // dc demote should reset account policy and user rights at reboot (from tattoo table)
        if ( Options & SCE_DC_DEMOTE )
            dwNewOption |= SCE_TABLE_OPTION_DEMOTE_TATTOO;
    }

    rc = SceJetCreateFile(JetDbName,
                             Flags,
                             dwNewOption,
                             &hProfile);

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                       SCEDLL_ERROR_CREATE, L"database");

        goto CleanUp;

    }

    if ( Options & SCE_SYSTEM_DB ) {

        //
        // set Admin F, CO F to the database (protected)
        //
        rc = ConvertTextSecurityDescriptor (
                        L"D:P(A;;GA;;;CO)(A;;GA;;;BA)(A;;GA;;;SY)",
                        &pSD,
                        &Count,   // temp var for SDsize
                        &SeInfo
                        );
        if ( rc == NO_ERROR ) {

            ScepChangeAclRevision(pSD, ACL_REVISION);

            //
            // use current token as the owner (because this database is
            // to be created
            //

            HANDLE      Token=NULL;

            if (!OpenThreadToken( GetCurrentThread(),
                                   TOKEN_QUERY,
                                   TRUE,
                                   &Token)) {

                if(ERROR_NO_TOKEN == GetLastError()){

                    if(!OpenProcessToken( GetCurrentProcess(),
                                          TOKEN_QUERY,
                                          &Token)) {

                        ScepLogOutput3(1, GetLastError(), SCEDLL_ERROR_QUERY_INFO, L"TOKEN");

                    }

                } else {

                    ScepLogOutput3(1, GetLastError(), SCEDLL_ERROR_QUERY_INFO, L"TOKEN");

                }
            }

            if ( Token ) {

                PSECURITY_DESCRIPTOR pNewSD=NULL;

                //
                // RtlNewSecurityObjectEx must be called on the process context (system)
                // because it will try to get process information inside the api.
                //
                RpcRevertToSelf();

                rc = RtlNtStatusToDosError(
                        RtlNewSecurityObjectEx(
                                NULL,
                                pSD,
                                &pNewSD,
                                NULL, // GUID
                                FALSE,
                                SEF_DACL_AUTO_INHERIT |
                                SEF_AVOID_OWNER_CHECK |
                                SEF_AVOID_PRIVILEGE_CHECK,
                                Token,
                                &FileGenericMapping
                                ));

                RpcStatus = RpcImpersonateClient( NULL );

                if ( RpcStatus == RPC_S_OK ) {

                    if ( rc == NO_ERROR ) {

                        if ( !SetFileSecurityA (
                                    JetDbName,
                                    SeInfo,
                                    pNewSD
                                    ) ) {
                            rc = GetLastError();
                            ScepLogOutput3(1, rc,
                                          SCEDLL_ERROR_SET_SECURITY, L"database");
                        }
                        ScepFree(pNewSD);

                    } else {

                        ScepLogOutput3(1, rc,
                                      SCEDLL_ERROR_BUILD_SD, L"database");
                    }

                } else {
                    if ( rc == NO_ERROR ) {

                        ScepFree(pNewSD);
                    }

                    ScepLogOutput3(1, I_RpcMapWin32Status(RpcStatus),
                                  SCEDLL_ERROR_BUILD_SD, L"database");
                }

                CloseHandle(Token);
            }

            ScepFree(pSD);

        } else
            ScepLogOutput3(1, rc, SCEDLL_ERROR_BUILD_SD, L"database");
    }

    if ( RpcStatus != RPC_S_OK ) {
        goto CleanUp;
    }

    if ( !(Options & SCE_POLICY_TEMPLATE) ) {
        //
        // if not in the middle of policy propagation, use Jet transaction
        // otherwise, use the temp table concept.
        //
        SceJetStartTransaction( hProfile );

        //
        //If it is in demote or snapshot mode delete local policy.
        //
        if ( (Options & SCE_DC_DEMOTE) &&
             (Options & SCE_SYSTEM_DB) ) {

            ScepDeleteInfoForAreas(
                      hProfile,
                      SCE_ENGINE_SMP,
                      AREA_ALL
                      );

            ScepDeleteInfoForAreas(
                  hProfile,
                  SCE_ENGINE_SAP, // tattoo
                  AREA_ALL
                  );

        } else if ( Options & SCE_GENERATE_ROLLBACK ) {
            ScepDeleteInfoForAreas(
                      hProfile,
                      SCE_ENGINE_SMP,
                      AREA_ALL
                      );
        }

    } else if ( Options & SCE_POLICY_FIRST ) {

        //
        // The ENGINE_SCP table points to the new merge table
        // instead of the existing one.
        //
        // delete everything in SCP then
        // copy Tattoo to SCP
        //

        rc = ScepDeleteInfoForAreas(
                  hProfile,
                  SCE_ENGINE_SCP,
                  AREA_ALL
                  );

        if ( rc != SCESTATUS_SUCCESS && rc != SCESTATUS_RECORD_NOT_FOUND ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                         SCEDLL_ERROR_DELETE, L"SCP");

            goto CleanUp;
        }

        //
        // delete GPO table to start over
        //

        SceJetDeleteAll( hProfile,
                         "SmTblGpo",
                         SCEJET_TABLE_GPO
                       );

        PSCE_ERROR_LOG_INFO  Errlog=NULL;

        ScepLogOutput3(2, rc, SCEDLL_COPY_LOCAL);

        // copy from tattoo table to effective policy table
        rc = ScepCopyLocalToMergeTable( hProfile,
                                          Options,
                                          (ProductType == NtProductLanManNt) ? SCE_LOCAL_POLICY_DC : 0,
                                          &Errlog );

        ScepLogWriteError( Errlog,1 );
        ScepFreeErrorLog( Errlog );
        Errlog = NULL;

        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                         SCEDLL_ERROR_COPY);

            goto CleanUp;
        }

        //
        // now, migrate database if tattoo table doesn't exist (in existing database)
        // this could happen if someone manually copied a database to the system
        // database location, or if the database failed to be migrated in setup
        //

        if ( hProfile->JetSapID == JET_tableidNil ) {
            SceJetCreateTable(
                    hProfile,
                    "SmTblTattoo",
                    SCEJET_TABLE_TATTOO,
                    SCEJET_CREATE_IN_BUFFER,
                    NULL,
                    NULL
                    );
        }
    }

    TCHAR  szGpoName[MAX_PATH];

    szGpoName[0] = L'\0';
    szGpoName[1] = L'\0';
    szGpoName[2] = L'\0';

    if ( Options & SCE_POLICY_TEMPLATE ) {
        //
        // get the GPO path and GPOID
        //
        GetPrivateProfileString(TEXT("Version"),
                                TEXT("GPOPath"),
                                TEXT(""),
                                szGpoName,
                                MAX_PATH,
                                InfFile
                               );

        if ( szGpoName[0] != L'\0' ) {

            PWSTR pTemp = wcschr(szGpoName, L'\\');

            if ( pTemp ) {
                *pTemp = L'\0';
            }

            GpoID = SceJetGetGpoIDByName(hProfile,
                                      szGpoName,
                                      TRUE   // add if it's not there
                                      );
            //
            // if GpoID is -1, an error occurred
            //
            if ( GpoID < 0 ) {

                rc = GetLastError();

                if ( rc != SCESTATUS_SUCCESS ) {
                    ScepLogOutput3( 1, ScepDosErrorToSceStatus(rc),
                                   SCEDLL_ERROR_CONVERT, (PWSTR)szGpoName);
                    goto CleanUp;
                }
            }
        }
    }

    //
    // query the version # to determine if the SDDL string should be migrated
    //

    if ( SetupFindFirstLine(hInf,L"Version",L"Revision",&InfLine) ) {
        if ( !SetupGetIntField(&InfLine, 1, (INT *)&Revision) ) {
            Revision = 0;
        }
    }

    if ( Revision == 0 ) ObjectFlag = SCE_OBJECT_FLAG_OLDSDDL;

    if ( Revision > SCE_TEMPLATE_MAX_SUPPORTED_VERSION ) {

        dwConvertOption = SCE_CONVERT_INF_NEWVERSION;
        ObjectFlag |= SCE_OBJECT_FLAG_UNKNOWN_VERSION;

    }

    //
    // process each area
    //
    if ( Area & AREA_SECURITY_POLICY ) {

        if ( !( Options & SCE_NO_DOMAIN_POLICY) ) {

            // System Access section
            rc = SceConvertpInfKeyValue(
                        szSystemAccess,
                        hInf,
                        hProfile,
                        dwNewOption,
                        dwConvertOption,
                        GpoID,
                        NULL,
                        NULL
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepLogOutput3( 1, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szSystemAccess);
                goto CleanUp;
            }
        }

        rc = SceConvertpInfKeyValue(
                    szSystemAccess,
                    hInf,
                    hProfile,
                    dwNewOption,
                    dwConvertOption,
                    GpoID,
                    L"LSAAnonymousNameLookup",
                    NULL
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3( 1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_CONVERT_SECTION, L"LSAAnonymousNameLookup");
            goto CleanUp;
        }

//
//      configure event log settings in setup too
//      since local policy table is not used in policy prop anymore
//
//        if ( !(Options & SCE_SYSTEM_DB) ||
//             (Options & SCE_POLICY_TEMPLATE) ) {

            // System Log section
            rc = SceConvertpInfKeyValue(
                        szAuditSystemLog,
                        hInf,
                        hProfile,
                        dwNewOption,
                        dwConvertOption,
                        GpoID,
                        NULL,
                        NULL
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepLogOutput3( 1, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szAuditSystemLog);
                goto CleanUp;
            }

            // Security Log section
            rc = SceConvertpInfKeyValue(
                        szAuditSecurityLog,
                        hInf,
                        hProfile,
                        dwNewOption,
                        dwConvertOption,
                        GpoID,
                        NULL,
                        NULL
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szAuditSecurityLog);
                goto CleanUp;
            }

            // Application Log section
            rc = SceConvertpInfKeyValue(
                        szAuditApplicationLog,
                        hInf,
                        hProfile,
                        dwNewOption,
                        dwConvertOption,
                        GpoID,
                        NULL,
                        NULL
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szAuditApplicationLog);
                goto CleanUp;
            }
//        }

        // Audit Event section
        rc = SceConvertpInfKeyValue(
                    szAuditEvent,
                    hInf,
                    hProfile,
                    dwNewOption,
                    dwConvertOption,
                    GpoID,
                    NULL,
                    NULL
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szAuditEvent);
            goto CleanUp;
        }

        if ( !( Options & SCE_NO_DOMAIN_POLICY) &&
             (ProductType == NtProductLanManNt) &&
             !( Options & SCE_DC_DEMOTE) ) {

            // Kerberos section
            rc = SceConvertpInfKeyValue(
                        szKerberosPolicy,
                        hInf,
                        hProfile,
                        dwNewOption,
                        dwConvertOption,
                        GpoID,
                        NULL,
                        NULL
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szKerberosPolicy);
                goto CleanUp;
            }
        }

        // registry values
        rc = SceConvertpInfKeyValue(
                    szRegistryValues,
                    hInf,
                    hProfile,
                    dwNewOption,
                    dwConvertOption | SCE_CONVERT_INF_MULTISZ | SCE_CONVERT_INF_REGVALUE,
                    GpoID,
                    NULL,
                    NULL
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szRegistryValues);
            goto CleanUp;
        }

        rc = SceConvertpAttachmentSections(hInf,
                                           hProfile,
                                           (Options & SCE_POLICY_TEMPLATE) ? TRUE : FALSE,
                                           GpoID,
                                           SCE_ATTACHMENT_POLICY);

        if ( rc != SCESTATUS_SUCCESS ) {

            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_SAP_ERROR_ENUMERATE, L"policy attachments.");

            goto CleanUp;
        }
    }

    if ( Area & AREA_REGISTRY_SECURITY ) {
        //
        // Object type - Registry
        //
        rc = SceConvertpInfObject(
                    szRegistryKeys,
                    1,
                    ObjectFlag | SCE_OBJECT_FLAG_OBJECTS,
                    hInf,
                    hProfile,
                    dwNewOption,
                    GpoID
                    );
        if ( rc != SCESTATUS_SUCCESS ) {

            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szRegistryKeys);
            goto CleanUp;
        }
    }

    if ( Area & AREA_FILE_SECURITY ) {

        // File security
        rc = SceConvertpInfObject(
                    szFileSecurity,
                    2,
                    ObjectFlag | SCE_OBJECT_FLAG_OBJECTS,
                    hInf,
                    hProfile,
                    dwNewOption,
                    GpoID
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szFileSecurity);
            goto CleanUp;
        }
    }

#if 0
    //
    // DS object security
    //
    rc = SceConvertpInfObject(
                szDSSecurity,
                3,
                ObjectFlag | SCE_OBJECT_FLAG_OBJECTS,
                hInf,
                hProfile,
                dwNewOption,
                GpoID
                );
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                       SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szDSSecurity);
        goto CleanUp;
    }
#endif

    if ( Area & AREA_SYSTEM_SERVICE ) {

        //
        // Service General Settings
        //
        rc = SceConvertpInfObject(
                    szServiceGeneral,
                    0,
                    ObjectFlag,
                    hInf,
                    hProfile,
                    dwNewOption,
                    GpoID
                    );

        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szServiceGeneral);
            goto CleanUp;
        }

        //
        // each service's specific settings
        //
        rc = SceConvertpAttachmentSections(hInf,
                                           hProfile,
                                           dwNewOption,
                                           GpoID,
                                           SCE_ATTACHMENT_SERVICE);
        if ( rc != SCESTATUS_SUCCESS ) {

            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_SAP_ERROR_ENUMERATE, L"service attachments.");

            goto CleanUp;
        }
    }

    if ( (Area & AREA_ATTACHMENTS) ) {

        //
        // each service's specific settings
        //
        rc = SceConvertpWMIAttachmentSections(hInf,
                                           hProfile,
                                           dwNewOption,
                                           GpoID
                                           );
        if ( rc != SCESTATUS_SUCCESS ) {

            goto CleanUp;
        }
    }

    if ( Area & AREA_PRIVILEGES ) {
        //
        // Multi-Sz type - privilege/rights
        //
        rc = SceConvertpInfKeyValue(
                    szPrivilegeRights,
                    hInf,
                    hProfile,
                    dwNewOption,
                    dwConvertOption | SCE_CONVERT_INF_MULTISZ | SCE_CONVERT_INF_PRIV,
                    GpoID,
                    NULL,
                    NULL
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szPrivilegeRights);
            goto CleanUp;
        }
    }

    if ( Area & AREA_GROUP_MEMBERSHIP ) {
        // group membership
        rc = SceConvertpInfKeyValue(
                    szGroupMembership,
                    hInf,
                    hProfile,
                    dwNewOption,
                    dwConvertOption | SCE_CONVERT_INF_MULTISZ | SCE_CONVERT_INF_GROUP,
                    GpoID,
                    NULL,
                    NULL
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szGroupMembership);
            goto CleanUp;
        }
    }

    //
    // if there is a description, convert it.
    //
    SceConvertpInfDescription(
                hInf,
                hProfile);

    if ( !(Options & SCE_POLICY_TEMPLATE) ) {
        //
        // Commit changes
        //
        SceJetCommitTransaction( hProfile, 0 );

    } else if ( Options & SCE_POLICY_LAST ) {
        //
        // update the LastUsedMergeTable field
        //

        DWORD dwThisTable = hProfile->Type & 0xF0L;

        if ( SCEJET_MERGE_TABLE_1 == dwThisTable ||
             SCEJET_MERGE_TABLE_2 == dwThisTable ) {

            rc = SceJetSetValueInVersion(
                        hProfile,
                        "SmTblVersion",
                        "LastUsedMergeTable",
                        (PWSTR)&dwThisTable,
                        4,
                        JET_prepReplace
                        );
        }

    }

CleanUp:

    //
    // close the inf profile
    //
    SceInfpCloseProfile(hInf);

    if ( pProfileList != NULL ) {
        ScepFreeNameList(pProfileList);
    }

    //
    // Rollback
    //
    if ( !(Options & SCE_POLICY_TEMPLATE) &&
         (RpcStatus == RPC_S_OK) &&
         (rc != SCESTATUS_SUCCESS) ) {

        SceJetRollback( hProfile, 0 );
    }

    //
    // Close the JET database
    //

    SceJetCloseFile( hProfile, TRUE, FALSE );

    if ( RpcStatus != RPC_S_OK ) {
        rc = I_RpcMapWin32Status(RpcStatus);
    }

    return(rc);

}


SCESTATUS
SceConvertpAttachmentSections(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID,
    IN SCE_ATTACHMENT_TYPE aType
    )
{
    SCESTATUS rc;
    PSCE_SERVICES    pServiceList=NULL, pNode;

    rc = ScepEnumServiceEngines( &pServiceList, aType );

    if ( rc == SCESTATUS_SUCCESS ) {

       for ( pNode=pServiceList; pNode != NULL; pNode=pNode->Next) {

           rc = SceConvertpOneAttachmentSection(hInf,
                                                hProfile,
                                                pNode->ServiceName,
                                                dwTableOption,
                                                GpoID
                                               );
           if ( rc != SCESTATUS_SUCCESS ) {
               ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                             SCEDLL_ERROR_CONVERT_SECTION, pNode->ServiceName );
               break;
           }
       }

       SceFreePSCE_SERVICES(pServiceList);

    } else if ( rc == SCESTATUS_PROFILE_NOT_FOUND ||
                rc == SCESTATUS_RECORD_NOT_FOUND ) {
        // if no service exist, just ignore
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);
}


SCESTATUS
SceConvertpWMIAttachmentSections(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID
    )
{
    SCESTATUS rc=SCESTATUS_SUCCESS;
    INFCONTEXT  InfLine;
    WCHAR SectionName[513];
    DWORD DataSize=0;

    if ( SetupFindFirstLine(hInf, szAttachments,NULL,&InfLine) ) {

        do {

            memset(SectionName, '\0', 513*sizeof(WCHAR));

            // get each attachment section name
            if(SetupGetStringField(&InfLine, 0, SectionName, 512, &DataSize) ) {

                rc = SceConvertpOneAttachmentSection(hInf,
                                                     hProfile,
                                                     SectionName,
                                                     dwTableOption,
                                                     GpoID
                                                    );

                if ( rc != SCESTATUS_SUCCESS ) {
                   ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                 SCEDLL_ERROR_CONVERT_SECTION, SectionName );
                   break;
                }

            } else {
                rc = ScepDosErrorToSceStatus(GetLastError());
            }

        } while ( rc == SCESTATUS_SUCCESS &&
                  SetupFindNextLine(&InfLine, &InfLine));
    }

    return(rc);

}

SCESTATUS
SceConvertpOneAttachmentSection(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN PWSTR SectionName,
    IN DWORD dwTableOption,
    IN LONG GpoID
    )
{

    SCESTATUS rc;
    PSCESVC_CONFIGURATION_INFO pServiceInfo=NULL;

    //
    // read inf info for the service
    //
    rc = SceSvcpGetInformationTemplate(
            hInf,
            SectionName,
            NULL,  // not a single key
            &pServiceInfo
            );

    if ( rc == SCESTATUS_SUCCESS && pServiceInfo != NULL ) {
       //
       // write the information to SCP or SMP table
       //

       if ( dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY ) {

           rc = SceSvcpSetInfo(
                    hProfile,
                    SceSvcInternalUse,
                    SectionName,
                    NULL,
                    TRUE,    // to support incremental template, DO NOT overwrite the whole section
                    GpoID,
                    pServiceInfo
                    );
       } else {
           rc = SceSvcpSetInfo(
                    hProfile,
                    SceSvcConfigurationInfo,
                    SectionName,
                    NULL,
                    TRUE,    // to support incremental template, DO NOT overwrite the whole section
                    0,
                    pServiceInfo
                    );
       }

       //
       // free buffer
       //
       SceSvcpFreeMemory(pServiceInfo);
       pServiceInfo = NULL;

    } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
       rc = SCESTATUS_SUCCESS;
    }

    return(rc);
}


SCESTATUS
SceConvertpInfKeyValue(
    IN PCWSTR InfSectionName,
    IN HINF   hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN DWORD dwConvertOption,
    IN LONG GpoID,
    IN OPTIONAL PCWSTR pcwszKey,
    OUT PSCE_NAME_LIST *pKeyList OPTIONAL
    )
/* ++
Routine Description:

    This routine converts INF sections which are in a key=value format. Value
    could be in MultiSz format (dwConvertOption & SCE_CONVERT_INF_MULTISZ).
    The optional pKeyList is a list of all keys in the section. This option
    is used when dynamic sections are converted.

Arguments:

    InfSectionName  - the INF section name to convert

    hInf            - the Inf file handle

    hprofile        - the Jet database context

    dwTableOption   - SCE_TABLE_OPTION_MERGE_POLICY = within policy propagation
                      SCE_TABLE_OPTION_TATTOO - system db (in setup)

    dwConvertOption - SCE_CONVERT_INF_MULTISZ - MultiSz type value
                      SCE_CONVERT_INF_PRIV    - user right section
                      SCE_CONVERT_INF_GROUP   - group membership section

    GpoID           - the group policy ID for this item

    pKeyList        - a list of all keys in the section.

Return Value:

-- */
{
    SCESTATUS    rc;
    DOUBLE      SectionID;
    PSCESECTION hSection=NULL;
    PSCESECTION hSectionTattoo=NULL;
    INFCONTEXT  InfLine;
    WCHAR       Keyname[SCE_KEY_MAX_LENGTH];
    PWSTR       pSidStr=NULL;
    PWSTR       pKeyStr=NULL;
    PWSTR       StrValue=NULL;
    DWORD       ValueLen=0;
    LSA_HANDLE  LsaPolicy=NULL;
    DWORD Len=0;


    if ( InfSectionName == NULL ||
         hInf == INVALID_HANDLE_VALUE ||
         hProfile == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // get section's ID. if the section does not exist, add it to the section table
    //
    rc = SceJetGetSectionIDByName(
                hProfile,
                InfSectionName,
                &SectionID
                );
    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

        rc = SceJetAddSection(
                    hProfile,
                    InfSectionName,
                    &SectionID
                    );
    }
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                       SCEDLL_ERROR_QUERY_INFO, (PWSTR)InfSectionName );
        return(rc);
    }

    if ( SetupFindFirstLine(hInf,InfSectionName,pcwszKey,&InfLine) ) {

        if ( dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY ) {

            //
            // open the SCP section
            //
            rc = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        SCEJET_TABLE_SCP,
                        &hSection
                        );
        } else {

            //
            // open SMP table
            //
            rc = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        SCEJET_TABLE_SMP,
                        &hSection
                        );

            //
            // open the tattoo (in order to update tattoo value in setup)
            // do not care error
            //
            if ( dwTableOption & SCE_TABLE_OPTION_TATTOO )
                SceJetOpenSection(hProfile, SectionID,
                                  SCEJET_TABLE_TATTOO,
                                  &hSectionTattoo);

        }

        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_OPEN, (PWSTR)InfSectionName);

            if (hSection != NULL )
                SceJetCloseSection( &hSection, TRUE);
            if (hSectionTattoo != NULL )
                SceJetCloseSection( &hSectionTattoo, TRUE);

            return(rc);
        }

        //
        // Open LSA policy handle for group name lookup, if any
        // if policy handle can't be opened, import name format
        //

        if ( dwConvertOption & SCE_CONVERT_INF_GROUP ) {

            ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &LsaPolicy,
                    TRUE
                    );
        }

        //
        // process each line in the section and save to the scp table.
        // Each INF line has a key and a value.
        //

        do {

            memset(Keyname, '\0', SCE_KEY_MAX_LENGTH*sizeof(TCHAR));
            rc = SCESTATUS_BAD_FORMAT;

            if ( SetupGetStringField(&InfLine, 0, Keyname, SCE_KEY_MAX_LENGTH, NULL) ) {

                //
                // check if newer version (keys) are passed
                //
                if ( (dwConvertOption & SCE_CONVERT_INF_NEWVERSION) ) {

                    if ( dwConvertOption & SCE_CONVERT_INF_PRIV )  {

                        //
                        // user rights from new version
                        // filter out all unknown rights
                        //
                        if ( -1 == ScepLookupPrivByName(Keyname) ) {

                            rc = SCESTATUS_SUCCESS;
                            goto NextLine;
                        }

                    } else if ( dwConvertOption & SCE_CONVERT_INF_REGVALUE ) {
                        //
                        // convert registry values, should check number of fields
                        //
                        if ( SetupGetFieldCount( &InfLine ) < 2 ) {

                            rc = SCESTATUS_SUCCESS;
                            goto NextLine;
                        }
                    }
                }

                if ( (dwConvertOption & SCE_CONVERT_INF_GROUP) &&
                     ( (dwConvertOption & SCE_CONVERT_INF_NEWVERSION) ||
                       (Keyname[0] != L'*') ) ) {
                    //
                    // this is a group in name format
                    //

                    PWSTR pTemp = (PWSTR)Keyname;
                    //
                    // search for the suffix (szMembers or szMemberof or szPrivileges)
                    //
                    while ( pTemp = wcsstr(pTemp, szMembers) ) {
                        if ( *(pTemp+wcslen(szMembers)) != L'\0') {
                            pTemp++;
                            ValueLen = 0;
                        } else {
                            break;
                        }
                    }

                    if ( pTemp == NULL ) {

                        pTemp = (PWSTR)Keyname;

                        while ( pTemp = wcsstr(pTemp, szMemberof) ) {
                            if ( *(pTemp+wcslen(szMemberof)) != L'\0') {
                                pTemp++;
                                ValueLen = 1;
                            } else {
                                break;
                            }
                        }

                        if ( pTemp == NULL ) {

                            pTemp = (PWSTR)Keyname;

                            while ( pTemp = wcsstr(pTemp, szPrivileges) ) {
                                if ( *(pTemp+wcslen(szPrivileges)) != L'\0') {
                                    pTemp++;
                                    ValueLen = 2;
                                } else {
                                    break;
                                }
                            }
                        }
                    }

                    if ( pTemp == NULL ) {
                        //
                        // this is an unknown group format, just import the keyname
                        // for supported version; for new version template, ignore
                        // this line
                        //
                        if ( (dwConvertOption & SCE_CONVERT_INF_NEWVERSION) ) {
                            rc = SCESTATUS_SUCCESS;
                            goto NextLine;
                        }

                    } else if ( Keyname[0] != L'*' ) {

                        *pTemp = L'\0';

                        Len=0;

                        if ( LsaPolicy ) {

                            //
                            // convert group name (domain\account) into *SID format
                            //

                            ScepConvertNameToSidString(
                                        LsaPolicy,
                                        Keyname,
                                        FALSE,
                                        &pSidStr,
                                        &Len
                                        );

                        } else {

                            if ( ScepLookupWellKnownName( 
                                    Keyname, 
                                    NULL,
                                    &pSidStr ) ) {

                                Len = wcslen(pSidStr);
                            }
                        }

                        //
                        // restore the "_"
                        //
                        *pTemp = L'_';

                        if ( pSidStr ) {
                            //
                            // add the suffix
                            //
                            pKeyStr = (PWSTR)ScepAlloc(0, (Len+wcslen(pTemp)+1)*sizeof(WCHAR));

                            if ( pKeyStr ) {

                                wcscpy(pKeyStr, pSidStr);
                                wcscat(pKeyStr, pTemp);

                            } else {
                                //
                                // use the name instead - out of memory will be caught later
                                //
                            }

                            ScepFree(pSidStr);
                            pSidStr = NULL;
                        }
                    }
                }

                if ( ((dwConvertOption & SCE_CONVERT_INF_MULTISZ) &&
                      SetupGetMultiSzField(&InfLine, 1, NULL, 0, &ValueLen)) ||
                     (!(dwConvertOption & SCE_CONVERT_INF_MULTISZ) &&
                      SetupGetStringField(&InfLine, 1, NULL, 0, &ValueLen)) ) {

                    if ( ValueLen > 1 ) {
                        StrValue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                    (ValueLen+1)*sizeof(TCHAR));

                        if( StrValue == NULL ) {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                        } else if( ((dwConvertOption & SCE_CONVERT_INF_MULTISZ) &&
                                    SetupGetMultiSzField(&InfLine, 1, StrValue, ValueLen, NULL)) ||
                                (!(dwConvertOption & SCE_CONVERT_INF_MULTISZ) &&
                                 SetupGetStringField(&InfLine,1,StrValue,ValueLen,NULL)) ) {

                            //
                            // if dealing with registry values only, do the following:
                            // compress regtype into one CHAR instead of many WCHARS
                            // (can canonicalize REG_QWORD value later by arithmetic padding etc.- doesn't
                            // make sense now since registry api's treat REG_QWORD as a string anyway)
                            // Also, resolve the Add/Remove format
                            //

                            rc = SCESTATUS_SUCCESS;

                            if ( dwConvertOption & SCE_CONVERT_INF_REGVALUE ) {

                                DWORD   LenStrValue = wcslen(StrValue);
                                PWSTR   NewRegValue = NULL;
                                DWORD   NewValueLen = 0;

                                if (LenStrValue > 1) {
                                    *((CHAR *)StrValue) = (CHAR) (_wtol(StrValue) + '0');
                                    memmove( StrValue+1,
                                             StrValue + LenStrValue,
                                             sizeof(WCHAR) * (ValueLen - LenStrValue));
                                    ValueLen -= (LenStrValue - 1);
                                }

                                //
                                // if the reg value is of the type add/remove format in the template,
                                // then we need to resolve the add/remove instructions to generate
                                // the exact value to save in the DB
                                //
                                if(SCE_REG_ADD_REMOVE_VALUE == *((CHAR *)StrValue) - '0'){

                                    rc = ScepBuildNewMultiSzRegValue(Keyname,
                                                                     StrValue,
                                                                     ValueLen,
                                                                     &NewRegValue,
                                                                     &NewValueLen
                                                                     );

                                    if(SCESTATUS_SUCCESS == rc){

                                        ScepFree(StrValue);
                                        StrValue = NewRegValue;
                                        ValueLen = NewValueLen;

                                        //
                                        // if we have no buffer to set, then just go
                                        // to the next line
                                        // This happens only if the reg key/value does not
                                        // exist on the system and we don't have an
                                        // "add" instruction in the inf line
                                        //
                                        if(!StrValue || 0 == NewValueLen){

                                            goto NextLine;

                                        }

                                        //
                                        // now change the reg value type to multisz since
                                        // the add/remove is now resolved.
                                        //
                                        *((CHAR *)StrValue) = (CHAR) (REG_MULTI_SZ + '0');


                                    }
                                    else{

                                        ScepFree(StrValue);
                                        StrValue = NULL;
                                        
                                    }

                                }


                            }

                        } else {
                            ScepFree(StrValue);
                            StrValue = NULL;
                        }

                    } else {
                        rc = SCESTATUS_SUCCESS;
                        ValueLen = 0;
                    }

                    PWSTR NewValue=NULL;
                    DWORD NewLen=0;

                    if ( rc == SCESTATUS_SUCCESS ) {

                        if ( (dwConvertOption & SCE_CONVERT_INF_MULTISZ) &&
                             StrValue != NULL &&
                             (dwConvertOption & SCE_CONVERT_INF_PRIV) &&
                             ( _wcsicmp(SCE_PRIV_ADD, StrValue) == 0 ||
                               _wcsicmp(SCE_PRIV_REMOVE, StrValue) == 0) ) {
                            //
                            // another format for user rights (ADD: REMOVE:...)
                            //

                            rc = ScepBuildNewPrivilegeList(&LsaPolicy,
                                                           Keyname,
                                                           StrValue,
                                                           SCE_BUILD_ENUMERATE_PRIV,
                                                           &NewValue,
                                                           &NewLen);
                            if ( rc == SCESTATUS_SUCCESS ) {

                                ScepFree(StrValue);
                                StrValue = NewValue;
                                ValueLen = NewLen;
                            }

                        }
                    }

                    if ( ( rc == SCESTATUS_SUCCESS) &&
                         !(dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY) &&
                         StrValue &&
                         ( (dwConvertOption & SCE_CONVERT_INF_PRIV) ||
                           (dwConvertOption & SCE_CONVERT_INF_GROUP)) ) {
                        //
                        // convert any free text format accounts from account domain
                        // to sid format if it's resolvable.
                        //
                        NewValue = NULL;
                        NewLen = 0;

                        rc = ScepConvertFreeTextAccountToSid(&LsaPolicy,
                                                            StrValue,
                                                            ValueLen,
                                                            &NewValue,
                                                            &NewLen);

                        if ( ( rc == SCESTATUS_SUCCESS) &&
                             NewValue ) {

                            ScepFree(StrValue);
                            StrValue = NewValue;
                            ValueLen = NewLen;
                        }

                    }

                    if ( rc == SCESTATUS_SUCCESS ) {

                        //
                        // write this line to JET database
                        // within policy propagation, write the GPOID too
                        //
                        rc = SceJetSetLine(
                                     hSection,
                                     pKeyStr ? pKeyStr : Keyname,
                                     FALSE,
                                     StrValue,
                                     ValueLen*sizeof(TCHAR),
                                     (dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY) ? GpoID : 0
                                     );

                        if ( rc != SCESTATUS_SUCCESS ) {
                            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                           SCEDLL_ERROR_WRITE_INFO, Keyname);
                        }

                        //
                        // if this is not policy propagation and it's the system db,
                        // check if the tattoo value exists and if so, update it
                        // but if this is in dc demotion, always import them into the
                        // tattoo table so at reboot when policy propagates, it would
                        // reset the system settings to a standalone server
                        //
                        if ( !(dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY) &&
                             (dwTableOption & SCE_TABLE_OPTION_TATTOO) &&
                             hSectionTattoo ) {

                            if ( pKeyStr )
                                Len = wcslen(pKeyStr);
                            else
                                Len = wcslen(Keyname);

                            if ( (dwTableOption & SCE_TABLE_OPTION_DEMOTE_TATTOO) ||
                                 (SCESTATUS_SUCCESS == SceJetSeek(
                                                            hSectionTattoo,
                                                            pKeyStr ? pKeyStr : Keyname,
                                                            Len*sizeof(WCHAR),
                                                            SCEJET_SEEK_EQ_NO_CASE)) ) {

                                SceJetSetLine(
                                     hSectionTattoo,
                                     pKeyStr ? pKeyStr : Keyname,
                                     FALSE,
                                     StrValue,
                                     ValueLen*sizeof(TCHAR),
                                     0
                                     );

                            }

                        }

                        ScepFree(StrValue);
                        StrValue = NULL;

                        if (pKeyList != NULL) {
                            if ( (rc=ScepAddToNameList(pKeyList, Keyname,0)) != NO_ERROR ) {

                                ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_ADD, Keyname);
                                rc = ScepDosErrorToSceStatus(rc);
                                ScepFreeNameList(*pKeyList);
                            }
                        }
                    }
                }

                if ( pKeyStr ) {
                    ScepFree(pKeyStr);
                    pKeyStr = NULL;
                }
NextLine:
                if  (rc != SCESTATUS_SUCCESS)
                    ScepLogOutput3( 1, ScepSceStatusToDosError(rc),
                                   SCEDLL_ERROR_CONVERT, Keyname);
            }

        } while( rc == SCESTATUS_SUCCESS && SetupFindNextLine(&InfLine, &InfLine));


        SceJetCloseSection( &hSection, TRUE);
        if ( hSectionTattoo )
            SceJetCloseSection( &hSectionTattoo, TRUE);

    }

    if ( LsaPolicy ) {
        LsaClose(LsaPolicy);
    }

    return(rc);
}


SCESTATUS
ScepBuildNewPrivilegeList(
    IN OUT LSA_HANDLE *pPolicyHandle,
    IN PWSTR PrivName,
    IN PWSTR mszUsers,
    IN ULONG dwBuildOption,
    OUT PWSTR *pmszNewUsers,
    OUT DWORD *pNewLen
    )
{
    if ( pPolicyHandle == NULL ||
         PrivName == NULL || mszUsers == NULL ||
         pmszNewUsers == NULL || pNewLen == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    *pNewLen = 0;
    *pmszNewUsers = NULL;

    //
    // lookup the priv first
    //

    DWORD PrivValue = ScepLookupPrivByName(PrivName);
    if ( PrivValue == -1 || PrivValue >= 64 ) {
        return(SCESTATUS_INVALID_DATA);
    }

    NTSTATUS NtStatus=STATUS_SUCCESS;

    if ( *pPolicyHandle == NULL ) {

        NtStatus = ScepOpenLsaPolicy(
                        MAXIMUM_ALLOWED, //GENERIC_ALL,
                        pPolicyHandle,
                        TRUE
                        );
        if ( !NT_SUCCESS(NtStatus) ) {
            return(ScepDosErrorToSceStatus(RtlNtStatusToDosError(NtStatus)));
        }
    }

    PSCE_PRIVILEGE_VALUE_LIST pAccountList=NULL;

    if ( dwBuildOption & SCE_BUILD_ENUMERATE_PRIV ) {

        NtStatus = ScepBuildAccountsToRemove(
                        *pPolicyHandle,
                        (PrivValue < 32) ? (1 << PrivValue) : 0,
                        (PrivValue >= 32) ? (1 << (PrivValue-32)) : 0,
                        SCE_BUILD_IGNORE_UNKNOWN | SCE_BUILD_ACCOUNT_SID_STRING,
                        NULL,
                        0,
                        NULL,
                        &pAccountList
                        );
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( NT_SUCCESS(NtStatus) ) {
        //
        // pAccountList can be NULL (no users are assigned of this privilege)
        //
        PWSTR pCurr = mszUsers;
        BOOL bMode = FALSE;  // add
        DWORD Len;
        DWORD SidStrLen;
        PWSTR CurrSidString=NULL;
        PSCE_PRIVILEGE_VALUE_LIST pTemp, pParent;
        BOOL    bFreeCurrSidString = FALSE;

        while ( pCurr && *pCurr != L'\0' ) {

            Len = wcslen(pCurr);

            if ( _wcsicmp(SCE_PRIV_ADD, pCurr) == 0 ) {
                bMode = FALSE; // add
            } else if ( _wcsicmp(SCE_PRIV_REMOVE, pCurr) == 0 ) {
                bMode = TRUE; // remove
            } else {
                //
                // get SID string for the account if it's a name
                //
                if (*pCurr == L'*') {
                    CurrSidString = pCurr;
                    SidStrLen = Len;
                }
                else if (SCESTATUS_SUCCESS == ScepConvertNameToSidString(
                                                                        *pPolicyHandle,
                                                                        pCurr,
                                                                        FALSE,
                                                                        &CurrSidString,
                                                                        &SidStrLen
                                                                        )) {
                    bFreeCurrSidString = TRUE;
                }
                else {
                    CurrSidString = pCurr;
                    SidStrLen = Len;
                }


                for ( pTemp=pAccountList, pParent=NULL; pTemp != NULL;
                      pParent=pTemp, pTemp = pTemp->Next ) {
                    if ( _wcsicmp(pTemp->Name, CurrSidString) == 0 ) {
                        break;
                    }
                }

                if ( bMode == FALSE ) {
                    if ( pTemp == NULL ) {
                        // add this one in
                        rc = ScepAddToPrivilegeList(&pAccountList, CurrSidString, SidStrLen, 0);
                    }
                } else {
                    if ( pTemp ) {
                        // remove this one out
                        if ( pParent ) {
                            pParent->Next = pTemp->Next;
                        } else {
                            pAccountList = pTemp->Next;
                        }
                        // free this one
                        pTemp->Next = NULL;
                        ScepFreePrivilegeValueList(pTemp);
                        pTemp = NULL;
                    }
                }
            }

            //
            // free CurrSidString if it's allocated
            // (BVT: have to be careful here - MULTI_SZ potentially being freed many times)
            //
            if ( bFreeCurrSidString ) {
                LocalFree(CurrSidString);
                CurrSidString = NULL;
                bFreeCurrSidString = FALSE;
            }
            SidStrLen = 0;

            if ( SCESTATUS_SUCCESS != rc ) {
                break;
            }
            // move to next element
            pCurr += Len + 1;
        }

        if ( SCESTATUS_SUCCESS == rc ) {

            DWORD TotalLen = 0;
            for ( pTemp=pAccountList; pTemp != NULL; pTemp = pTemp->Next ) {
                pTemp->PrivLowPart = wcslen(pTemp->Name);
                TotalLen += pTemp->PrivLowPart+1;
            }

            *pmszNewUsers = (PWSTR)ScepAlloc(0, (TotalLen+1)*sizeof(WCHAR));

            if (*pmszNewUsers ) {

                *pNewLen = TotalLen;
                TotalLen = 0;

                for ( pTemp=pAccountList; pTemp != NULL && TotalLen <= *pNewLen;
                      pTemp = pTemp->Next ) {

                    wcscpy(*pmszNewUsers+TotalLen, pTemp->Name);
                    TotalLen += pTemp->PrivLowPart;
                    *(*pmszNewUsers+TotalLen) = L'\0';
                    TotalLen++;
                }
                *(*pmszNewUsers+TotalLen) = L'\0';

            } else {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }
        }

    } else {
        rc = ScepDosErrorToSceStatus(RtlNtStatusToDosError(NtStatus));
    }

    return(rc);

}

SCESTATUS
ScepBuildNewMultiSzRegValue(
    IN PWSTR    pszKeyName,
    IN PWSTR    pszStrValue,
    IN DWORD    dwValueLen,
    OUT PWSTR*  ppszNewValue,
    OUT PDWORD  pdwNewLen
    )
/* ++
Routine Description:

    This routine resolves a multisz reg value in add/remove format to
    the exact multisz value

Arguments:

    pszKeyName              [in]    - Reg key and value path
    pszStrValue             [in]    - the multisz value in add/remove
                                      format including the reg type
    dwValueLen              [in]    - Number of chars of the value
    ppszNewValue            [out]   - the resolved value
    pdwNewLen               [out]   - number of chars for the resolved value                                  
    
Return Value:

    SCESTATUS value

-- */
{

    PWSTR           pszAddList = NULL;
    PWSTR           pszRemoveList = NULL;
    PWSTR           pCur = NULL;
    PWSTR           pAddCur = NULL;
    PWSTR           pRemoveCur = NULL;
    DWORD           dwAddListSize = 0;
    DWORD           dwRemoveListSize = 0;
    BOOL            bRemove = FALSE;
    DWORD           dwLen = 0;
    SCESTATUS       rc = SCESTATUS_SUCCESS;


    //
    // validate parameters
    //
    if(!pszKeyName || !pszStrValue ||
       !ppszNewValue || !pdwNewLen){

        return SCESTATUS_INVALID_PARAMETER;

    } 

    //
    // Clear return buffers
    //
    *ppszNewValue = NULL;
    *pdwNewLen = 0;

    //
    // initialize the cursor to skip the reg type
    // which is the first item in the multisz string
    //
    pCur = pszStrValue + wcslen(pszStrValue) + 1;

    //
    // Build the add/remove value into an "add" buffer and
    // "remove" buffer
    //
    while(  ( (DWORD)(pCur - pszStrValue) < dwValueLen) &&
            (*pCur != L'\0') ){

        dwLen = wcslen(pCur);

        //
        // Set mode that next item is an "add" item
        // or "remove" item
        //
        if(0 == _wcsicmp(SCE_REG_ADD, pCur)){

            bRemove = FALSE;
            pCur += dwLen + 1;
            continue;

        }
        else if(0 == _wcsicmp(SCE_REG_REMOVE, pCur)){

            bRemove = TRUE;
            pCur += dwLen + 1;
            continue;

        }

        //
        // add to "add" buffer if an "add" item
        //
        if(!bRemove){

            //
            // only allocate the "add list" buffer if we hit an add item
            // and only allocate once
            //
            if(!pszAddList){

                pszAddList = (PWSTR) ScepAlloc(LMEM_ZEROINIT, dwValueLen*sizeof(WCHAR));

                if(!pszAddList){

                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    goto ExitHandler;

                }

                pAddCur = pszAddList;

            }

            wcscpy(pAddCur, pCur);

            pAddCur += dwLen + 1;

        }

        //
        // add to "remove" buffer if an "remove" item
        //
        else{

            //
            // only allocate the "remove list" buffer if we hit a remove item
            // and only allocate once
            //
            if(!pszRemoveList){

                pszRemoveList = (PWSTR) ScepAlloc(LMEM_ZEROINIT, dwValueLen*sizeof(WCHAR));

                if(!pszRemoveList){

                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    goto ExitHandler;

                }

                pRemoveCur = pszRemoveList;

            }

            wcscpy(pRemoveCur, pCur);

            pRemoveCur += dwLen + 1;


        }

        pCur += dwLen + 1;

    }
        
    //
    // calculate the buffers sizes
    //
    if(pszAddList){

        dwAddListSize = (pAddCur - pszAddList + 1) * sizeof(WCHAR);

    }

    if(pszRemoveList){

        dwRemoveListSize = (pRemoveCur - pszRemoveList + 1) * sizeof(WCHAR);

    }

    //
    // Create the new resolved buffer
    //
    rc = ScepBuildRegMultiSzValue(pszKeyName,
                                  pszAddList,
                                  dwAddListSize,
                                  pszRemoveList,
                                  dwRemoveListSize,
                                  pszStrValue,
                                  ppszNewValue,
                                  pdwNewLen
                                  );

    if(SCESTATUS_SUCCESS != rc){

        goto ExitHandler;

    }


ExitHandler:

    //
    // clean up.
    //

    if(pszAddList){

        ScepFree(pszAddList);

    }

    if(pszRemoveList){

        ScepFree(pszRemoveList);

    }

    if(SCESTATUS_SUCCESS != rc){

        if(*ppszNewValue){

            ScepFree(*ppszNewValue);
            *ppszNewValue = NULL;

        }

        *pdwNewLen = 0;

    }

    return rc;

}

SCESTATUS
ScepBuildRegMultiSzValue(
    IN PWSTR    pszKeyName,
    IN PWSTR    pszAddList OPTIONAL,
    IN DWORD    dwAddSize,
    IN PWSTR    pszRemoveList OPTIONAL,
    IN DWORD    dwRemoveSize,
    IN PWSTR    pszPrefix,
    OUT PWSTR*  ppszNewValue,
    OUT PDWORD  pdwNewValueLen
    )
/* ++
Routine Description:

    This routine resolves a multisz reg value for a given "add" buffer
    and "remove" buffer
    
Arguments:

    pszKeyName      [in]            - Reg key and value path.
    pszAddList      [in][optional]  - "add" buffer.
    dwAddSize       [in]            - the "add" buffer size in bytes.
    pszRemoveList   [in][optional]  - the "remove" buffer.
    dwRemoveSize    [in]            - the "remove" buffer size in bytes.
    pszPrefix       [in]            - prefix reg value to be prepended to the
                                      returned value.
    ppszNewValue    [out]           - the resolved value.
    pdwNewLen       [out]           - number of chars for the resolved value.
    
Return Value:

    SCESTATUS value

-- */
{

    HKEY        hKeyRoot = NULL;
    PWSTR       pStart = NULL;
    PWSTR       pValue = NULL;
    PWSTR       pTemp = NULL;
    DWORD       rc = ERROR_SUCCESS;
    BOOL        bRestoreValue = FALSE;
    PWSTR       pszData = NULL;
    DWORD       dwDataSize = 0;
    PWSTR       pszNewData = NULL;
    DWORD       dwNewDataSize = 0;
    DWORD       dwRegType = 0;
    DWORD       dwPrefixLen = 0;

    //
    // validate parameters
    //
    if(!pszKeyName || !ppszNewValue ||
       !pdwNewValueLen || !pszPrefix){

        return SCESTATUS_INVALID_PARAMETER;

    }

    //
    // we have to have either an add list or a remove list
    //
    if(!pszAddList && !pszRemoveList){

        return SCESTATUS_INVALID_PARAMETER;

    }

    //
    // Clear the return buffers
    //
    *ppszNewValue = NULL;
    *pdwNewValueLen = 0;

    //
    // find the prefix len
    //
    dwPrefixLen = wcslen(pszPrefix);

    //
    // obtain the registry key name
    //
    pStart = wcschr(pszKeyName, L'\\');

    if ( (7 == pStart-pszKeyName) &&
         (0 == _wcsnicmp(L"MACHINE", pszKeyName, 7)) ) {

        hKeyRoot = HKEY_LOCAL_MACHINE;

    } else if ( (5 == pStart-pszKeyName) &&
                (0 == _wcsnicmp(L"USERS", pszKeyName, 5)) ) {
        hKeyRoot = HKEY_USERS;

    } else if ( (12 == pStart-pszKeyName) &&
                (0 == _wcsnicmp(L"CLASSES_ROOT", pszKeyName, 12)) ) {
        hKeyRoot = HKEY_CLASSES_ROOT;

    } else {

        rc = ERROR_INVALID_DATA;
        goto ExitHandler;

    }

    //
    // find the value name
    //
    pValue = pStart+1;
    
    do {
       pTemp = wcschr(pValue, L'\\');
       if ( pTemp ) {
           pValue = pTemp+1;
       }
    } while ( pTemp );
    
    if ( pValue == pStart+1 ) {

       rc = ERROR_INVALID_DATA;
       goto ExitHandler;
    }
    
    //
    // terminate the subkey for now
    //
    *(pValue-1) = L'\0';
    bRestoreValue = TRUE;

    rc = ScepRegQueryValue(hKeyRoot,
                           pStart+1,
                           pValue,
                           (PVOID*)&pszData,
                           &dwRegType,
                           &dwDataSize
                           );
    //
    // if the key or the value is not found or the value is empty,
    // then the new value is the "add" buffer.
    //
    if((ERROR_FILE_NOT_FOUND == rc) ||
       (sizeof(WCHAR) >= dwDataSize)){

        if(pszAddList){

            *ppszNewValue = (PWSTR)ScepAlloc(LMEM_ZEROINIT, dwAddSize + (dwPrefixLen+1)*sizeof(WCHAR));
    
            if(!*ppszNewValue){
    
                rc = ERROR_NOT_ENOUGH_MEMORY;
                goto ExitHandler;
    
            }

            wcsncpy(*ppszNewValue, pszPrefix, dwPrefixLen);
            CopyMemory(*ppszNewValue + dwPrefixLen + 1, pszAddList, dwAddSize);
    
            *pdwNewValueLen = (dwAddSize / sizeof(WCHAR)) + dwPrefixLen + 1;

        }

        rc = ERROR_SUCCESS;

    }
    else{

        if(ERROR_SUCCESS != rc){
    
            goto ExitHandler;
    
        }
    
        if(REG_MULTI_SZ != dwRegType){
    
            rc = ERROR_INVALID_PARAMETER;
            goto ExitHandler;
    
        }

        //
        // if we have a "remove" buffer, then remove the items from
        // the queried value
        //
        if(pszRemoveList){
    
            rc = ScepRemoveMultiSzItems(pszData,
                                        dwDataSize,
                                        pszRemoveList,
                                        dwRemoveSize,
                                        &pszNewData,
                                        &dwNewDataSize
                                        );
    
            if(ERROR_SUCCESS != rc){
    
                goto ExitHandler;
    
            }
            
        }
    
        //
        // if we have an "add" buffer, then add the items to the 
        // value
        //
        if(pszAddList){

            if(pszData && pszNewData){

                ScepFree(pszData);
                pszData = pszNewData;
                dwDataSize = dwNewDataSize;
                pszNewData = NULL;
                dwNewDataSize = 0;


            }
    
            rc = ScepAddMultiSzItems(pszData,
                                     dwDataSize,
                                     pszAddList,
                                     dwAddSize,
                                     &pszNewData,
                                     &dwNewDataSize
                                     );
    
            if(ERROR_SUCCESS != rc){
    
                goto ExitHandler;
    
            }
    
    
        }
    

        *ppszNewValue = (PWSTR)ScepAlloc(LMEM_ZEROINIT, dwNewDataSize + (dwPrefixLen+1)*sizeof(WCHAR));

        if(!*ppszNewValue){

            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto ExitHandler;

        }

        wcsncpy(*ppszNewValue, pszPrefix, dwPrefixLen);
        CopyMemory(*ppszNewValue + dwPrefixLen + 1, pszNewData, dwNewDataSize);

        *pdwNewValueLen = (dwNewDataSize / sizeof(WCHAR)) + dwPrefixLen + 1;

    }

ExitHandler:

    //
    // clean up.
    //
    if(bRestoreValue){

        *(pValue-1) = L'\\';

    }

    if(pszData){

        ScepFree(pszData);

    }

    if(pszNewData){

        ScepFree(pszNewData);

    }

    if(ERROR_SUCCESS != rc){

        if(*ppszNewValue){

            ScepFree(*ppszNewValue);
            *ppszNewValue = NULL;

        }

        *pdwNewValueLen = 0;

    }

    return ScepDosErrorToSceStatus(rc);

}


SCESTATUS
SceConvertpInfObject(
    IN PCWSTR InfSectionName,
    IN UINT ObjectType,
    IN DWORD ObjectFlag,
    IN HINF   hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID
    )
/* ++
Routine Description:

    This routine converts INF sections which are in object-security format,
    for example, Registry Keys and File Security sections. These sections
    must have 3 fields on each line. The first field is the object's name,
    the second field is a status flag, and the third field is the security
    descriptor text. The infomration saved in the Jet database for each
    object is the object's name as the key, and the text format security
    descriptor plus 1 byte status flag as the value.

Arguments:

    InfSectionName  - the INF section name to convert

    ObjectType      - The object's type
                          1 = Registry
                          2 = File
                          3 = DS object

    hInf            - the Inf file handle

    hprofile        - the Jet database context

Return Value:

-- */
{

    SCESTATUS    rc;
    DOUBLE      SectionID;
    PSCESECTION hSection=NULL;
    PSCESECTION hSectionTattoo=NULL;
    INFCONTEXT  InfLine;
    PWSTR       TempName=NULL;
    PWSTR       Name=NULL;
    PWSTR       Value=NULL;
    DWORD       ValueLen;
    SCEINF_STATUS InfErr;
    TCHAR       ObjName[MAX_PATH];


    if ( InfSectionName == NULL ||
         hInf == INVALID_HANDLE_VALUE ||
         hProfile == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // get section's ID. if the section does not exist, add it to the section table
    //
    rc = SceJetGetSectionIDByName(
                hProfile,
                InfSectionName,
                &SectionID
                );
    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

        rc = SceJetAddSection(
                    hProfile,
                    InfSectionName,
                    &SectionID
                    );
    }
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                       SCEDLL_SCP_ERROR_ADD, (PWSTR)InfSectionName);
        return(rc);
    }

    if ( SetupFindFirstLine(hInf,InfSectionName,NULL,&InfLine) ) {

        //
        // open the section
        //
        if ( dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY ) {

            rc = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        SCEJET_TABLE_SCP,
                        &hSection
                        );
        } else {
            //
            // SMP exists, also open the SMP section
            //
            rc = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        SCEJET_TABLE_SMP,
                        &hSection
                        );

            if ( dwTableOption & SCE_TABLE_OPTION_TATTOO ) {
                //
                // if it's in setup, should check if tattoo table needs to be updated
                // do not care error
                //
                SceJetOpenSection(
                            hProfile,
                            SectionID,
                            SCEJET_TABLE_TATTOO,
                            &hSectionTattoo
                            );
            }
        }
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_OPEN, (PWSTR)InfSectionName);

            if ( hSection )
                SceJetCloseSection( &hSection, TRUE);
            if ( hSectionTattoo )
                SceJetCloseSection( &hSectionTattoo, TRUE);

            return(rc);
        }

        //
        // process each line in the section and save to the scp table.
        //

        BOOL bIgnore;

        do {
            //
            // Get string fields. Don't care the key name or if it exist.
            // Must have at least 3 fields each line.
            //

            bIgnore = FALSE;

            InfErr = SceInfpGetOneObject(&InfLine,
                                    ObjectFlag,
                                    &TempName,
                                    &Value,
                                    &ValueLen
                                  );
            rc = ScepDosErrorToSceStatus(InfErr);

            if ( rc == SCESTATUS_SUCCESS && TempName != NULL ) {

                //
                // check to see if the object name needs translated
                //
                if ( ObjectType == 3 ) {
                    //
                    // DS object
                    //
                    rc = ScepConvertLdapToJetIndexName(TempName, &Name);

                } else if ( ObjectType == 2 && TempName[0] == L'\\' ) {
                    //
                    // do not support UNC name format
                    //
                    rc = SCESTATUS_INVALID_DATA;

                } else if ( ObjectType == 2 && wcschr(TempName, L'%') != NULL ) {

                    //
                    // translate the name
                    //
                    rc = ScepTranslateFileDirName( TempName, &Name);

                    if ( rc == ERROR_PATH_NOT_FOUND ) {
                        if ( ObjectFlag & SCE_OBJECT_FLAG_UNKNOWN_VERSION )
                            bIgnore = TRUE;
                        rc = SCESTATUS_INVALID_DATA;

                    } else if ( rc != NO_ERROR )
                        rc = ScepDosErrorToSceStatus(rc);

                } else {
                    Name = TempName;
                    TempName = NULL;
                }

                //
                // write this line to JET database
                //
                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // convert to lowercase
                    //
                    Name = _wcslwr(Name);

                    //
                    // within policy propagation, write the GPOID too
                    //
                    rc = SceJetSetLine(
                                 hSection,
                                 Name,
                                 TRUE,
                                 Value,
                                 ValueLen*sizeof(TCHAR),
                                 (dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY) ? GpoID : 0
                                 );

                    if ( hSectionTattoo &&
                         !(dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY) &&
                         (dwTableOption & SCE_TABLE_OPTION_TATTOO ) ) {
                        //
                        // if it's in setup (not policy prop) and tattoo table exists
                        // check if tattoo value exists for this one and if so, update it
                        // do not care error
                        //
                        if ( SCESTATUS_SUCCESS == SceJetSeek(
                                                        hSectionTattoo,
                                                        Name,
                                                        wcslen(Name)*sizeof(WCHAR),
                                                        SCEJET_SEEK_EQ_NO_CASE) ) {

                            SceJetSetLine(
                                 hSectionTattoo,
                                 Name,
                                 TRUE,
                                 Value,
                                 ValueLen*sizeof(TCHAR),
                                 0
                                 );

                        }
                    }

                }
                if ( rc != SCESTATUS_SUCCESS) {
                    ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                   SCEDLL_ERROR_CONVERT, TempName );
                }
                ScepFree(Value);
                Value = NULL;

                ScepFree(TempName);
                TempName = NULL;

                ScepFree(Name);
                Name = NULL;

            } else if ( (ObjectFlag & SCE_OBJECT_FLAG_UNKNOWN_VERSION) &&
                        rc == SCESTATUS_SUCCESS && TempName == NULL ) {
                //
                // this one is ignored because it came from a newer version
                // of template.
                //

            } else {

                ObjName[0] = L'\0';
                SetupGetStringField(&InfLine,1,ObjName,MAX_PATH,&ValueLen);

                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                              SCEDLL_ERROR_CONVERT, ObjName );
            }

            //
            // for a newer version template, if a env variable can't be resolved
            // it will be ignored.
            //
            if ( bIgnore ) rc = SCESTATUS_SUCCESS;

            if ( SCESTATUS_INVALID_DATA == rc ) {
                //
                // if a environment variable or other invalid data is found
                // in the template, will continue to process other areas/items
                // but the error will be eventually returned to the caller
                //
                gbInvalidData = TRUE;
                rc = SCESTATUS_SUCCESS;
            }

            if ( rc != SCESTATUS_SUCCESS )
                break; // do..while loop

        } while( SetupFindNextLine(&InfLine,&InfLine) );

        SceJetCloseSection( &hSection, TRUE);
        if ( hSectionTattoo ) SceJetCloseSection( &hSectionTattoo, TRUE);

    }

    return(rc);

}


SCEINF_STATUS
SceInfpGetOneObject(
    IN PINFCONTEXT pInfLine,
    IN DWORD ObjectFlag,
    OUT PWSTR *Name,
    OUT PWSTR *Value,
    OUT PDWORD ValueLen
    )
/* ++
Routine Description:

   This routine retrieves security setting for one object (a registry key,
   or a file) from the INF file (SCP type). Each object in these sections
   is represented by one line. Each object has 3 fields, a name, status flag,
   and a security setting.

Arguments:

   pInfLine  - Current line context from the INF file for one object

    Name      - The object name

    Value     - The status flag ( 1 byte) plus the security descriptor in text

    ValueLen  - the length of the value

Return value:

   SCESTATUS - SCEINF_SUCCESS
              SCEINF_WARNING
              SCEINF_NOT_ENOUGH_MEMORY
              SCEINF_INVALID_PARAMETER
              SCEINF_CORRUPT_PROFILE
              SCEINF_INVALID_DATA
-- */
{
    SCEINF_STATUS  rc=ERROR_BAD_FORMAT;
    DWORD         cFields;
    INT           Keyvalue1=0;
    DWORD         Keyvalue2=0;
    DWORD         DataSize;
    PWSTR         SDspec=NULL;
    DWORD         Len=0;

    //
    // The Registry/File INF layout must have 3 fields for each line.
    // The first field is the key/file name, the 2nd field is the security descriptor index
    // for workstations, and the 3rd field is the security descriptor index for servers
    //

    if ( Name == NULL || Value == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *Name = NULL;
    *Value = NULL;
    *ValueLen = 0;

    cFields = SetupGetFieldCount( pInfLine );

    if ( cFields < 3 ) {
        if ( ObjectFlag & SCE_OBJECT_FLAG_UNKNOWN_VERSION ) {
            return(ERROR_SUCCESS);
        } else {
            return(ERROR_INVALID_DATA);
        }

    } else if(SetupGetStringField(pInfLine,1,NULL,0,&DataSize) && DataSize > 0 ) {

        *Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                     (DataSize+1)*sizeof(TCHAR) );
        if( *Name == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        } else {

            //
            // the first field is the key/file name. the status is ERROR_BAD_FORMAT now
            //

            if(SetupGetStringField(pInfLine,1,*Name,DataSize,NULL)) {
#ifdef SCE_DBG
                ScepLogOutput2(0,0, L"Read %s", *Name );
#endif
                //
                // The 2nd field is the status
                // The 3rd field (and all fields after) is the security descriptor text
                //
                if ( SetupGetIntField(pInfLine, 2, (INT *)&Keyvalue1) &&
//                     SetupGetStringField(pInfLine, 3, NULL, 0, &Keyvalue2) ) {
                     SetupGetMultiSzField(pInfLine, 3, NULL, 0, &Keyvalue2) ) {

                    *Value = (PWSTR)ScepAlloc( 0, (Keyvalue2+2)*sizeof(WCHAR));

                    //
                    // add this object
                    //
                    if ( *Value == NULL ) {

                        rc = ERROR_NOT_ENOUGH_MEMORY;
//                    } else if ( SetupGetStringField(pInfLine, 3, (*Value)+1, Keyvalue2, NULL) ) {
                    } else if ( SetupGetMultiSzField(pInfLine, 3, (*Value)+1, Keyvalue2, NULL) ) {

                        if ( ObjectFlag & SCE_OBJECT_FLAG_OBJECTS ) {

                            if ( Keyvalue1 > SCE_STATUS_NO_AUTO_INHERIT ||
                                 Keyvalue1 < SCE_STATUS_CHECK ) {

                                Keyvalue1 = SCE_STATUS_CHECK;
                            }

                            *((BYTE *)(*Value)) = (BYTE)Keyvalue1;

                            *((CHAR *)(*Value)+1) = '1';   //always treat as container

                        } else {
                            //
                            // services
                            //
                            if ( Keyvalue1 > SCE_STARTUP_DISABLED ||
                                 Keyvalue1 < SCE_STARTUP_BOOT ) {
                                //
                                // default
                                //
                                Keyvalue1 = SCE_STARTUP_MANUAL;
                            }

                            *((BYTE *)(*Value)) = 0;  // always set status to 0

                            *((BYTE *)(*Value)+1) = (BYTE)Keyvalue1;

                        }
                        //
                        // convert the multi-sz delimiter to space, if there is any
                        //
                        if ( cFields > 3 ) {
                            ScepConvertMultiSzToDelim( (*Value+1), Keyvalue2, L'\0', L' ');
                        }

                        if ( ObjectFlag & SCE_OBJECT_FLAG_OLDSDDL ) {
                            //
                            // convert old SDDL string to new one
                            //
                            ScepConvertToSDDLFormat( (*Value+1), Keyvalue2 );
                        }

                        *ValueLen = Keyvalue2+1;
                        rc = ERROR_SUCCESS;

                    } else {
                        ScepFree(*Value);
                        *Value = NULL;
                        rc = ERROR_INVALID_DATA;
                    }
                }
            }

            // if error, free the memory allocated
            if ( rc != ERROR_SUCCESS ) {
                ScepFree(*Name);
                *Name = NULL;
            }
        }

    }
    if ( rc == ERROR_SUCCESS) {
        //
        // conver the object name to upper case
        //
//        _wcsupr(*Name);  should not do this..
    }
    return(rc);

}

SCESTATUS
SceConvertpInfDescription(
    IN HINF hInf,
    IN PSCECONTEXT hProfile
    )
{
    INFCONTEXT InfLine;
    SCESTATUS   rc=SCESTATUS_SUCCESS;
    WCHAR      Description[513];
    DWORD      Len=0;
    DWORD      DataSize=0;
    DWORD      i, cFields;


    if ( hInf == INVALID_HANDLE_VALUE ||
         hProfile == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }


    if ( SetupFindFirstLine(hInf,szDescription,NULL,&InfLine) ) {

        memset(Description, '\0', 513*sizeof(WCHAR));

        // get description from Inf
        do {
            cFields = SetupGetFieldCount( &InfLine );

            for ( i=0; i<cFields && rc==SCESTATUS_SUCCESS; i++) {
                if(SetupGetStringField(&InfLine, i+1, Description+Len, 512-Len, &DataSize) ) {

                    Len += DataSize;
                    if ( Len >= 512 ) {
                        Len = 512;
                        Description[512] = L'\0';
                        break;
                    }
                    if ( i == cFields-1 )
                        Description[Len-1] = L' ';
                    else
                        Description[Len-1] = L',';
                } else
                    rc = SCESTATUS_INVALID_DATA;
            }
            if ( Len >= 512 )
                break;

        } while ( rc == SCESTATUS_SUCCESS &&
                  SetupFindNextLine(&InfLine, &InfLine));

        if ( rc == SCESTATUS_SUCCESS && Description[0] ) {
            //
            // save description to Jet
            // NOTE: Jet requires long value update must be done in a transaction
            //
            rc = SceJetStartTransaction( hProfile );

            if ( SCESTATUS_SUCCESS == rc ) {

                Description[Len] = L'\0';

                rc = SceJetSetValueInVersion(
                        hProfile,
                        "SmTblVersion",
                        "ProfileDescription",
                        (PWSTR)Description,
                        Len*sizeof(WCHAR),
                        JET_prepReplace
                        );
                if ( SCESTATUS_SUCCESS == rc ) {

                    SceJetCommitTransaction( hProfile, 0 );

                } else {

                    SceJetRollback( hProfile, 0 );

                }
            }
        }
    }

    return(rc);

}

SCESTATUS
ScepConvertRelativeSidToSidString(
    IN PWSTR pwszRelSid,
    OUT PWSTR *ppwszSid)
/*
Routine Description:

    Given a relative SID string "#-RSID", convert to full SID "*S-domain SID-RSID" 
    relative to primary domain

Arguments:

    pwszRelSid - relative SID

    ppwszSid   - output SID

Return Value:

    WIN32 error code
*/
{
    NTSTATUS NtStatus;
    DWORD rc = ERROR_SUCCESS;
    PPOLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo=NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO  PrimaryDomainInfo=NULL;
    ULONG ulRid;
    DWORD dwSize;
    PWSTR pwszDomainSid = NULL;

    //
    // get primary domain SID
    //
    NtStatus = ScepGetLsaDomainInfo(
                   &AccountDomainInfo,
                   &PrimaryDomainInfo
                   );
    rc = RtlNtStatusToDosError(NtStatus);

    if ( ERROR_SUCCESS == rc )
    {
        rc = ScepConvertSidToPrefixStringSid(
            PrimaryDomainInfo->Sid,
            &pwszDomainSid);
    }
    
    if ( ERROR_SUCCESS == rc ) {
        *ppwszSid = (LPWSTR) ScepAlloc(LMEM_ZEROINIT, 
            (wcslen(pwszDomainSid) + wcslen(&pwszRelSid[1]) + 1) * sizeof(WCHAR));
        if(!*ppwszSid)
            rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // build full SID from domain SID and #-RSID, skipping the #
    //
    if (  ERROR_SUCCESS == rc ) {
        wcscpy(*ppwszSid, pwszDomainSid);
        wcscat(*ppwszSid, &pwszRelSid[1]);
    }

    if(AccountDomainInfo != NULL) {
        LsaFreeMemory(AccountDomainInfo);
    }
    
    if(PrimaryDomainInfo != NULL) {
        LsaFreeMemory(PrimaryDomainInfo);
    }
    
    return(ScepDosErrorToSceStatus(rc));
}

SCESTATUS
ScepConvertSpecialAccountToSid(
    IN OUT LSA_HANDLE *pPolicyHandle,
    IN PWSTR mszAccounts,
    IN ULONG dwLen,
    bool fFreeTextAccount,
    OUT PWSTR *pmszNewAccounts,
    OUT DWORD *pNewLen
    )
{

    if ( pPolicyHandle == NULL ||
         pmszNewAccounts == NULL || pNewLen == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    *pNewLen = 0;
    *pmszNewAccounts = NULL;

    PWSTR pCurr = mszAccounts;
    DWORD cnt=0;

    //
    // count how many entries in the list
    //
    while ( pCurr && *pCurr != L'\0' ) {
        cnt++;
        pCurr += wcslen(pCurr)+1;
    }

    if ( cnt == 0 ) {
        return(SCESTATUS_SUCCESS);
    }

    NTSTATUS NtStatus=STATUS_SUCCESS;

    if ( *pPolicyHandle == NULL ) {

        NtStatus = ScepOpenLsaPolicy(
                        MAXIMUM_ALLOWED, //GENERIC_ALL,
                        pPolicyHandle,
                        TRUE
                        );
        if ( !NT_SUCCESS(NtStatus) ) {
            return(ScepDosErrorToSceStatus(RtlNtStatusToDosError(NtStatus)));
        }
    }

    //
    // allocate temp buffer for the sid string pointers
    //
    PWSTR *pSidStrs = (PWSTR *)ScepAlloc(LPTR, cnt*sizeof(PWSTR));

    if ( pSidStrs == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    DWORD *pSidLen = (DWORD *)ScepAlloc(LPTR, cnt*sizeof(DWORD));

    if ( pSidLen == NULL ) {
        ScepFree(pSidStrs);
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    BOOL *pSidFree = (BOOL *)ScepAlloc(LPTR, cnt*sizeof(BOOL));

    if ( pSidFree == NULL ) {
        ScepFree(pSidStrs);
        ScepFree(pSidLen);
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    pCurr = mszAccounts;
    DWORD i = 0;
    BOOL bConvert=FALSE;
    PWSTR SidString, pTemp;
    DWORD StrLen;
    SCESTATUS rc;


    while ( pCurr && *pCurr != L'\0' &&
            ( i < cnt ) ) {

        pSidStrs[i] = pCurr;
        pSidFree[i] = FALSE;
        pSidLen[i] = wcslen(pCurr);
        pTemp = pCurr + pSidLen[i] + 1;

        if ( fFreeTextAccount && *pCurr != L'*' && wcschr(pCurr, L'\\') == 0 ) {
            //
            // this is a name format and it's an isolated name
            // let's resolve it to a SID string
            //
            SidString = NULL;
            StrLen = 0;

            rc = ScepConvertNameToSidString( *pPolicyHandle,
                                             pCurr,
                                             FALSE, //TRUE,
                                             &SidString,
                                             &StrLen
                                           );

            if ( rc == SCESTATUS_SUCCESS &&
                 SidString ) {

                //
                // got a sid string
                //
                pSidStrs[i] = SidString;
                pSidLen[i] = StrLen;
                pSidFree[i] = TRUE;

                bConvert = TRUE;
            }
        }
        else if ( !fFreeTextAccount && *pCurr == RELATIVE_SID_PREFIX ) {
            
            // this is a relative SID in format "#-512", convert to "*S-current domain SID-512"
            rc = ScepConvertRelativeSidToSidString(pCurr, &SidString);

            if( SCESTATUS_SUCCESS == rc) {
                pSidStrs[i] = SidString;
                pSidLen[i] = wcslen(SidString);
                pSidFree[i] = TRUE;
                bConvert = TRUE;
            }
        }

        i ++;
        pCurr = pTemp;

    }

    //
    // now we need to build the new string
    //
    rc = SCESTATUS_SUCCESS;

    if ( bConvert ) {

        DWORD dwTotal=0;

        for ( i=0; i<cnt; i++ ) {

            dwTotal += pSidLen[i];
            dwTotal ++;  // for the NULL terminator
        }

        if ( dwTotal ) {
            dwTotal ++;  // for the last NULL terminator

            *pmszNewAccounts = (PWSTR)ScepAlloc(LPTR, dwTotal*sizeof(WCHAR));

            if ( *pmszNewAccounts ) {

                pCurr = *pmszNewAccounts;

                for ( i=0; i<cnt; i++ ) {

                    wcsncpy(pCurr, pSidStrs[i], pSidLen[i]);

                    pCurr += pSidLen[i];
                    *pCurr = L'\0';
                    pCurr++;
                }

                *pNewLen = dwTotal;

            } else {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }
        }
    }

    for ( i=0; i<cnt; i++ ) {

        if ( pSidFree[i] && pSidStrs[i] ) {
            ScepFree(pSidStrs[i]);
        }
    }

    ScepFree(pSidStrs);
    ScepFree(pSidLen);
    ScepFree(pSidFree);

    return(rc);

}

SCESTATUS
ScepConvertFreeTextAccountToSid(
    IN OUT LSA_HANDLE *pPolicyHandle,
    IN PWSTR mszAccounts,
    IN ULONG dwLen,
    OUT PWSTR *pmszNewAccounts,
    OUT DWORD *pNewLen
    )
{
    return ScepConvertSpecialAccountToSid(
        pPolicyHandle,
        mszAccounts,
        dwLen,
        true,
        pmszNewAccounts,
        pNewLen);
}

SCESTATUS
ScepConvertRelativeSidAccountToSid(
    IN OUT LSA_HANDLE *pPolicyHandle,
    IN PWSTR mszAccounts,
    IN ULONG dwLen,
    OUT PWSTR *pmszNewAccounts,
    OUT DWORD *pNewLen
    )
{
    return ScepConvertSpecialAccountToSid(
        pPolicyHandle,
        mszAccounts,
        dwLen,
        false,
        pmszNewAccounts,
        pNewLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\pfget.cpp ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    pfget.cpp

Abstract:

    Routines to get information from jet database (configuration/analysis
    info).

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

    jinhuang 26-Jan-1998 splitted to client-server

--*/

#include "serverp.h"
#include <io.h>
#include "pfp.h"
#include "kerberos.h"
#include "regvalue.h"
#include <sddl.h>
#pragma hdrstop

//#define SCE_DBG 1
#define SCE_INTERNAL_NP         0x80
#define SCE_ALLOC_MAX_NODE      10

typedef struct _SCE_BROWSE_CALLBACK_VALUE {

    DWORD Len;
    UCHAR *Value;

} SCE_BROWSE_CALLBACK_VALUE;


//
// Forward references
//

SCESTATUS
ScepGetSystemAccess(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_PROFILE_INFO   pProfileInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetVariableValue(
    IN PSCESECTION hSection,
    IN SCETYPE ProfileType,
    IN PCWSTR KeyName,
    OUT PWSTR *Value,
    OUT PDWORD ValueLen
    );

SCESTATUS
ScepAddToPrivilegeList(
    OUT PSCE_PRIVILEGE_VALUE_LIST  *pPrivilegeList,
    IN PWSTR Name,
    IN DWORD Len,
    IN DWORD PrivValue
    );

SCESTATUS
ScepGetGroupMembership(
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetGroupMembershipFromOneTable(
    IN LSA_HANDLE  LsaPolicy,
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetObjectList(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );
SCESTATUS
ScepGetDsRoot(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepBuildDsTree(
    OUT PSCE_OBJECT_CHILD_LIST *TreeRoot,
    IN ULONG Level,
    IN WCHAR Delim,
    IN PCWSTR ObjectFullName
    );

SCESTATUS
ScepGetObjectFromOneTable(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetObjectChildrenFromOneTable(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectPrefix,
    IN SCE_SUBOBJECT_TYPE Option,
    OUT PVOID *Buffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

BYTE
ScepGetObjectStatusFlag(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN AREA_INFORMATION Area,
   IN PWSTR ObjectPrefix,
   IN BOOL bLookForParent
   );

SCESTATUS
ScepGetAuditing(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   OUT PSCE_PROFILE_INFO pProfileInfo,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

SCESTATUS
ScepGetPrivilegesFromOneTable(
   IN LSA_HANDLE LsaPolicy,
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN DWORD dwAccountFormat,
   OUT PVOID *pPrivileges,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

SCESTATUS
ScepGetSystemServices(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    OUT PSCE_SERVICES *pServiceList,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

BOOL
ScepSearchItemInChildren(
    IN PWSTR ItemName,
    IN DWORD NameLen,
    IN PSCE_OBJECT_CHILDREN_NODE *pArrObject,
    IN DWORD arrCount,
    OUT LONG *pFindIndex
    );


DWORD
ScepAddItemToChildren(
    IN PSCE_OBJECT_CHILDREN_NODE ThisNode OPTIONAL,
    IN PWSTR ItemName,
    IN DWORD NameLen,
    IN BOOL  IsContainer,
    IN BYTE  Status,
    IN DWORD ChildCount,
    IN OUT PSCE_OBJECT_CHILDREN_NODE **ppArrObject,
    IN OUT DWORD *pArrCount,
    IN OUT DWORD *pMaxCount,
    IN OUT LONG *pFindIndex
    );

PWSTR
ScepSpecialCaseRegkeyCcs(
    IN OUT  PWSTR    ObjectName
    );


//
// function definitions
//

SCESTATUS
ScepGetDatabaseInfo(
    IN  PSCECONTEXT         hProfile,
    IN  SCETYPE             ProfileType,
    IN  AREA_INFORMATION    Area,
    IN  DWORD               dwAccountFormat,
    OUT PSCE_PROFILE_INFO   *ppInfoBuffer,
    IN  OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/**++

Function Description:

   This function reads all or part of information from a SCP/SAP/SMP profile
   depending on the ProfileType, into the InfoBuffer. ProfileType is saved in
   the ppInfoBuffer's Type field.

   A handle to the profile (Jet database) is passed into the routine every
   time this routine is called. Area specifies one or more pre-defined security
   areas to get information. One area's information may be saved in multiple
   sections in the profile.

   The memory related to the area(s) will be reset/freed before loading
   information from the profile. If the return code is SCESTATUS_SUCCESS, then
   the output InfoBuffer contains the requested information. Otherwise,
   InfoBuffer contains nothing for the area(s) specified.

Arguments:

   hProfile    -   The handle to the profile to read from.

   ProfileType -   value to indicate engine type.
                    SCE_ENGINE_SCP
                    SCE_ENGINE_SAP
                    SCE_ENGINE_SMP

   Area -          area(s) for which to get information from
                     AREA_SECURITY_POLICY
                     AREA_PRIVILEGES
                     AREA_GROUP_MEMBERSHIP
                     AREA_REGISTRY_SECURITY
                     AREA_SYSTEM_SERVICE
                     AREA_FILE_SECURITY

   ppInfoBuffer -  The address of SCP/SAP/SMP buffers. If it is NULL, a buffer
                   will be created which must be freed by LocalFree. The
                   output is the information requested if successful, or
                   nothing if fail.

   Errlog     -    A buffer to hold all error codes/text encountered when
                   parsing the INF file. If Errlog is NULL, no further error
                   information is returned except the return DWORD

Return Value:

   SCESTATUS_SUCCESS
   SCESTATUS_PROFILE_NOT_FOUND
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_BAD_FORMAT
   SCESTATUS_INVALID_DATA

-- **/
{

    SCESTATUS     rc=SCESTATUS_SUCCESS;
    DWORD         Len;
    BOOL          bBufAlloc=FALSE;
    NT_PRODUCT_TYPE theType;

    //
    // if the JET database is not opened then return
    //

    if ( hProfile == NULL ) {

        return( SCESTATUS_INVALID_PARAMETER );
    }

    //
    // address for InfoBuffer cannot be NULL
    //
    if ( ppInfoBuffer == NULL ) {
        return( SCESTATUS_INVALID_PARAMETER );
    }

    //
    // check scetype
    //
    if ( ProfileType > SCE_ENGINE_SMP ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // check to see if there is a SMP or SCP table
    //
    if ( hProfile->JetSmpID == JET_tableidNil ||
         hProfile->JetScpID == JET_tableidNil ) {
        return(SCESTATUS_PROFILE_NOT_FOUND);
    }

    if ( ProfileType == SCE_ENGINE_GPO &&
         hProfile->JetScpID == hProfile->JetSmpID ) {
        //
        // there is no domain GPO policy
        //
        return(SCESTATUS_PROFILE_NOT_FOUND);
    }
    //
    // design on this part is changed.
    // if there is no SAP table which means the system has not been
    // analyzed based on the template in SMP, return error and UI
    // will display "no analysis is performed"
    //
    if ( ProfileType == SCE_ENGINE_SAP &&
          hProfile->JetSapID == JET_tableidNil) {

        return(SCESTATUS_PROFILE_NOT_FOUND);
    }

    //
    // create buffer if it is NULL
    //
    if ( *ppInfoBuffer == NULL) {
        //
        // allocate memory
        //
        Len = sizeof(SCE_PROFILE_INFO);
        *ppInfoBuffer = (PSCE_PROFILE_INFO)ScepAlloc( (UINT)0, Len);
        if ( *ppInfoBuffer == NULL ) {

            return( SCESTATUS_NOT_ENOUGH_RESOURCE );
        }
        memset(*ppInfoBuffer, '\0', Len);
        bBufAlloc = TRUE;

        (*ppInfoBuffer)->Type = ( ProfileType==SCE_ENGINE_GPO) ? SCE_ENGINE_SCP : ProfileType;

    }

/*
// Design changed. Checking is moved above creating the buffer.

    if ( ProfileType == SCE_ENGINE_SAP &&
          hProfile->JetSapID == JET_tableidNil) {
        //
        // if no SAP table is there, which means configuration is done
        // but analysis is not done, we treat it as everything is fine
        // reset the buffer to SCE_NO_VALUE
        //
        ScepResetSecurityPolicyArea(*ppInfoBuffer);

//        return(SCESTATUS_PROFILE_NOT_FOUND);
        return(SCESTATUS_SUCCESS);
    }
*/
    //
    // Free related memory and reset the buffer before parsing
    // there is a problem here for now. it clears the handle and
    // filename too. So comment it out.

    SceFreeMemory( (PVOID)(*ppInfoBuffer), (DWORD)Area );

    //
    // system access
    //

    if ( Area & AREA_SECURITY_POLICY ) {

        rc = ScepGetSystemAccess(
                    hProfile,
                    ProfileType,
                    *ppInfoBuffer,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

        //
        // system auditing
        //
        rc = ScepGetAuditing(hProfile,
                             ProfileType,
                            *ppInfoBuffer,
                            Errlog
                          );

        if( rc != SCESTATUS_SUCCESS )
                goto Done;

#if _WIN32_WINNT>=0x0500
        if ( RtlGetNtProductType(&theType) ) {

            if ( theType == NtProductLanManNt ) {

                rc = ScepGetKerberosPolicy(
                                    hProfile,
                                    ProfileType,
                                    &((*ppInfoBuffer)->pKerberosInfo),
                                    Errlog
                                  );

                if ( rc != SCESTATUS_SUCCESS )
                    goto Done;
            }
        }
#endif
        //
        // registry values
        //
        rc = ScepGetRegistryValues(
                            hProfile,
                            ProfileType,
                            &((*ppInfoBuffer)->aRegValues),
                            &((*ppInfoBuffer)->RegValueCount),
                            Errlog
                          );

        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    //
    // privilege/rights
    //

    if ( Area & AREA_PRIVILEGES ) {
        //
        // SCP/SMP/SAP privilegeAssignedTo are all in the same address in the
        // SCE_PROFILE_INFO structure.
        //
        rc = ScepGetPrivileges(
                    hProfile,
                    ProfileType,
                    dwAccountFormat,
                    (PVOID *)&( (*ppInfoBuffer)->OtherInfo.scp.u.pPrivilegeAssignedTo ),
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }


    //
    // group memberships
    //

    if ( (Area & AREA_GROUP_MEMBERSHIP) &&
         (ProfileType != SCE_ENGINE_GPO) ) {

        rc = ScepGetGroupMembership(
                      hProfile,
                      ProfileType,
                      &((*ppInfoBuffer)->pGroupMembership),
                      Errlog
                      );

        if( rc != SCESTATUS_SUCCESS )
                goto Done;
    }

    //
    // registry keys security
    //

    if ( (Area & AREA_REGISTRY_SECURITY) &&
        (ProfileType != SCE_ENGINE_GPO) ) {

        rc = ScepGetObjectList(
                   hProfile,
                   ProfileType,
                   szRegistryKeys,
                   &((*ppInfoBuffer)->pRegistryKeys.pOneLevel),
                   Errlog
                   );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

    }

    //
    // file security
    //

    if ( (Area & AREA_FILE_SECURITY) &&
         (ProfileType != SCE_ENGINE_GPO) ) {

        rc = ScepGetObjectList(
                   hProfile,
                   ProfileType,
                   szFileSecurity,
                   &((*ppInfoBuffer)->pFiles.pOneLevel),
                   Errlog
                   );

        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    //
    // DS object security
    //
#if 0

#if _WIN32_WINNT>=0x0500
    if ( (Area & AREA_DS_OBJECTS) &&
        (ProfileType != SCE_ENGINE_GPO) &&
        RtlGetNtProductType(&theType) ) {

        if ( theType == NtProductLanManNt ) {
            rc = ScepGetDsRoot(
                       hProfile,
                       ProfileType,
                       szDSSecurity,
                       &((*ppInfoBuffer)->pDsObjects.pOneLevel),
                       Errlog
                       );

            if ( rc != SCESTATUS_SUCCESS )
                goto Done;
        }
    }
#endif
#endif

    if ( (Area & AREA_SYSTEM_SERVICE) &&
         (ProfileType != SCE_ENGINE_GPO) ) {

        rc = ScepGetSystemServices(
                   hProfile,
                   ProfileType,
                   &((*ppInfoBuffer)->pServices),
                   Errlog
                   );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

    }

Done:

    if ( rc != SCESTATUS_SUCCESS ) {

        //
        // need free memory because some fatal error happened
        //

        if ( bBufAlloc ) {
            SceFreeProfileMemory(*ppInfoBuffer);
            *ppInfoBuffer = NULL;
        } else
            SceFreeMemory( (PVOID)(*ppInfoBuffer), (DWORD)Area );

    }
    return(rc);
}


SCESTATUS
ScepGetSystemAccess(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_PROFILE_INFO   pProfileInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine retrieves system access area information from the Jet database
   and stores in the output buffer pProfileInfo. System access information
   includes information in [System Access] sections.

Arguments:

   hProfile     -  The profile handle context

   pProfileinfo -  the output buffer to hold profile info (SCP or SAP).

   Errlog       -  A buffer to hold all error codes/text encountered when
                   parsing the INF file. If Errlog is NULL, no further error
                   information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_BAD_FORMAT
               SCESTATUS_INVALID_DATA

--*/

{
    SCESTATUS                rc;
    PSCESECTION              hSection=NULL;

    SCE_KEY_LOOKUP AccessKeys[] = {
        {(PWSTR)TEXT("MinimumPasswordAge"),     offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordAge),    'D'},
        {(PWSTR)TEXT("MaximumPasswordAge"),     offsetof(struct _SCE_PROFILE_INFO, MaximumPasswordAge),    'D'},
        {(PWSTR)TEXT("MinimumPasswordLength"),  offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordLength), 'D'},
        {(PWSTR)TEXT("PasswordComplexity"),     offsetof(struct _SCE_PROFILE_INFO, PasswordComplexity),    'D'},
        {(PWSTR)TEXT("PasswordHistorySize"),    offsetof(struct _SCE_PROFILE_INFO, PasswordHistorySize),   'D'},
        {(PWSTR)TEXT("LockoutBadCount"),        offsetof(struct _SCE_PROFILE_INFO, LockoutBadCount),       'D'},
        {(PWSTR)TEXT("ResetLockoutCount"),      offsetof(struct _SCE_PROFILE_INFO, ResetLockoutCount),     'D'},
        {(PWSTR)TEXT("LockoutDuration"),        offsetof(struct _SCE_PROFILE_INFO, LockoutDuration),       'D'},
        {(PWSTR)TEXT("RequireLogonToChangePassword"),offsetof(struct _SCE_PROFILE_INFO, RequireLogonToChangePassword),'D'},
        {(PWSTR)TEXT("ForceLogoffWhenHourExpire"),offsetof(struct _SCE_PROFILE_INFO, ForceLogoffWhenHourExpire),'D'},
        {(PWSTR)TEXT("ClearTextPassword"),      offsetof(struct _SCE_PROFILE_INFO, ClearTextPassword),     'D'},
        {(PWSTR)TEXT("LSAAnonymousNameLookup"), offsetof(struct _SCE_PROFILE_INFO, LSAAnonymousNameLookup),     'D'},
        {(PWSTR)TEXT("EnableAdminAccount"),    offsetof(struct _SCE_PROFILE_INFO, EnableAdminAccount),     'D'},
        {(PWSTR)TEXT("EnableGuestAccount"),    offsetof(struct _SCE_PROFILE_INFO, EnableGuestAccount),     'D'}
        };

    DWORD cKeys = sizeof(AccessKeys) / sizeof(SCE_KEY_LOOKUP);

    DWORD         DataSize=0;
    PWSTR         Strvalue=NULL;
    DWORD                  SDsize=0;
    PSECURITY_DESCRIPTOR   pTempSD=NULL;


    if ( pProfileInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = ScepGetFixValueSection(
               hProfile,
               szSystemAccess,
               AccessKeys,
               cKeys,
               ProfileType,
               (PVOID)pProfileInfo,
               &hSection,
               Errlog
               );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // get new administrator for SCP and SMP types
    //
    rc = ScepGetVariableValue(
            hSection,
            ProfileType,
            L"NewAdministratorName",
            &Strvalue,
            &DataSize
            );
    if ( rc != SCESTATUS_RECORD_NOT_FOUND &&
         rc != SCESTATUS_SUCCESS ) {

        ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                             Errlog, SCEERR_QUERY_VALUE,
                             L"NewAdministratorName"
                           );
        goto Done;
    }
    rc = SCESTATUS_SUCCESS;

    if ( Strvalue ) {
        if ( Strvalue[0] != L'\0') {
            pProfileInfo->NewAdministratorName = Strvalue;
        } else {
            pProfileInfo->NewAdministratorName = NULL;
            ScepFree(Strvalue);
        }
        Strvalue = NULL;
    }

    //
    // NewGuestName
    //

    rc = ScepGetVariableValue(
            hSection,
            ProfileType,
            L"NewGuestName",
            &Strvalue,
            &DataSize
            );
    if ( rc != SCESTATUS_RECORD_NOT_FOUND &&
         rc != SCESTATUS_SUCCESS ) {

        ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                             Errlog, SCEERR_QUERY_VALUE,
                             L"NewGuestName"
                           );
        goto Done;
    }
    rc = SCESTATUS_SUCCESS;

    if ( Strvalue ) {
        if ( Strvalue[0] != L'\0') {
            pProfileInfo->NewGuestName = Strvalue;
        } else {
            pProfileInfo->NewGuestName = NULL;
            ScepFree(Strvalue);
        }
        Strvalue = NULL;
    }

Done:

    SceJetCloseSection(&hSection, TRUE);

    if ( pTempSD != NULL )
        ScepFree(pTempSD);

    if ( Strvalue != NULL )
        ScepFree( Strvalue );

    return(rc);
}


SCESTATUS
ScepGetFixValueSection(
    IN PSCECONTEXT  hProfile,
    IN PCWSTR      SectionName,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN SCETYPE ProfileType,
    OUT PVOID pInfo,
    OUT PSCESECTION *phSection,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
-- */
{
    SCESTATUS                rc;
    DWORD                   i;
    TCHAR                   Value[25];
    DWORD                   RetValueLen;
    LONG                    Keyvalue;



    rc = ScepOpenSectionForName(
                hProfile,
                (ProfileType==SCE_ENGINE_GPO)? SCE_ENGINE_SCP : ProfileType,
                SectionName,
                phSection
                );
    if ( SCESTATUS_SUCCESS != rc ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog, SCEERR_OPEN,
                             SectionName
                           );
        return(rc);
    }

    JET_COLUMNID  ColGpoID = 0;
    JET_ERR       JetErr;
    LONG          GpoID=0;
    DWORD         Actual;

    if ( ProfileType == SCE_ENGINE_GPO ) {
        JET_COLUMNDEF ColumnGpoIDDef;

        JetErr = JetGetTableColumnInfo(
                        (*phSection)->JetSessionID,
                        (*phSection)->JetTableID,
                        "GpoID",
                        (VOID *)&ColumnGpoIDDef,
                        sizeof(JET_COLUMNDEF),
                        JET_ColInfo
                        );
        if ( JET_errSuccess == JetErr ) {
            ColGpoID = ColumnGpoIDDef.columnid;
        }
    }

    //
    // get each key in the access array
    //
    for ( i=0; i<cKeys; i++ ) {

        memset(Value, '\0', 50);
        RetValueLen = 0;

        rc = SceJetGetValue(
                *phSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                (PWSTR)(Keys[i].KeyString),
                NULL,
                0,
                NULL,
                Value,
                48,
                &RetValueLen
                );

        if ( RetValueLen > 0 )
            Value[RetValueLen/2] = L'\0';

        if ( rc == SCESTATUS_SUCCESS ) {

            GpoID = 1;
            if ( ProfileType == SCE_ENGINE_GPO ) {

                //
                // query if the setting comes from a GPO
                // get GPO ID field from the current line
                //
                GpoID = 0;

                if ( ColGpoID > 0 ) {

                    JetErr = JetRetrieveColumn(
                                    (*phSection)->JetSessionID,
                                    (*phSection)->JetTableID,
                                    ColGpoID,
                                    (void *)&GpoID,
                                    4,
                                    &Actual,
                                    0,
                                    NULL
                                    );
                }
            }

            if ( GpoID > 0 && RetValueLen > 0 && Value[0] != L'\0' )
                Keyvalue = _wtol(Value);
            else
                Keyvalue = SCE_NO_VALUE;

        } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
            rc = SCESTATUS_SUCCESS; // it is OK not find a record
            Keyvalue = SCE_NO_VALUE;
        } else {
            ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                 Errlog,
                                 SCEERR_QUERY_VALUE,
                                 Keys[i].KeyString
                               );
            goto Done;
        }
#ifdef SCE_DBG
        printf("Get info %s (%d) for ", Value, Keyvalue);
        wprintf(L"%s. rc=%d, Return Length=%d\n",
                Keys[i].KeyString, rc, RetValueLen);
#endif

        switch (Keys[i].BufferType ) {
        case 'B':
            *((BOOL *)((CHAR *)pInfo+Keys[i].Offset)) = (Keyvalue == 1) ? TRUE : FALSE;
            break;
        case 'D':
            *((DWORD *)((CHAR *)pInfo+Keys[i].Offset)) = Keyvalue;
            break;
        default:
            rc = SCESTATUS_INVALID_DATA;
            ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                                 Errlog,
                                 SCEERR_CANT_FIND_DATATYPE,
                                 Keys[i].KeyString
                               );
            goto Done;
        }
    }

Done:
    //
    // close the section
    //
    if ( rc != SCESTATUS_SUCCESS ) {

        SceJetCloseSection(phSection, TRUE);
    }

    return(rc);

}


SCESTATUS
ScepGetVariableValue(
    IN PSCESECTION hSection,
    IN SCETYPE ProfileType,
    IN PCWSTR KeyName,
    OUT PWSTR *Value,
    OUT PDWORD ValueLen
    )
/* ++
-- */
{

    SCESTATUS   rc;

    rc = SceJetGetValue(
            hSection,
            SCEJET_EXACT_MATCH_NO_CASE,
            (PWSTR)KeyName,
            NULL,
            0,
            NULL,
            NULL,
            0,
            ValueLen
            );

    if ( rc == SCESTATUS_SUCCESS && *ValueLen > 0 ) {

        LONG          GpoID=1;

        if ( ProfileType == SCE_ENGINE_GPO ) {

            JET_COLUMNDEF ColumnGpoIDDef;
            JET_COLUMNID  ColGpoID = 0;
            JET_ERR       JetErr;
            DWORD         Actual;


            JetErr = JetGetTableColumnInfo(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            "GpoID",
                            (VOID *)&ColumnGpoIDDef,
                            sizeof(JET_COLUMNDEF),
                            JET_ColInfo
                            );

            GpoID = 0;

            if ( JET_errSuccess == JetErr ) {
                ColGpoID = ColumnGpoIDDef.columnid;
                //
                // query if the setting comes from a GPO
                // get GPO ID field from the current line
                //
                JetErr = JetRetrieveColumn(
                                hSection->JetSessionID,
                                hSection->JetTableID,
                                ColGpoID,
                                (void *)&GpoID,
                                4,
                                &Actual,
                                0,
                                NULL
                                );

            }
        }

        if ( GpoID > 0 ) {

            //
            // if DataSize = 0 then the security descriptor is NULL also
            //
            *Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, *ValueLen+2);

            if( *Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

            } else {
                rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        (PWSTR)KeyName,
                        NULL,
                        0,
                        NULL,
                        *Value,
                        *ValueLen,
                        ValueLen
                        );
            }

        } else {

            rc = SCESTATUS_RECORD_NOT_FOUND;
        }

    }

    return(rc);

}


SCESTATUS
ScepGetPrivileges(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN DWORD dwAccountFormat,
   OUT PVOID *pPrivileges,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
{
   SCESTATUS rc;

   LSA_HANDLE LsaHandle=NULL;

   rc = RtlNtStatusToDosError(
             ScepOpenLsaPolicy(
                   MAXIMUM_ALLOWED,
                   &LsaHandle,
                   TRUE
                   ));

   if ( ERROR_SUCCESS != rc ) {
       ScepBuildErrorLogInfo(
                   rc,
                   Errlog,
                   SCEDLL_LSA_POLICY
                   );
       return(ScepDosErrorToSceStatus(rc));
   }

   PSCE_PRIVILEGE_ASSIGNMENT pTempList=NULL, pNode, pPriv, pParent, pTemp;

    rc = ScepGetPrivilegesFromOneTable(
                   LsaHandle,
                   hProfile,
                   ProfileType,
                   dwAccountFormat,
                   pPrivileges,
                   Errlog
                   );

    if ( SCESTATUS_SUCCESS == rc && SCE_ENGINE_SAP == ProfileType ) {
        //
        // get the remaining stuff from SMP
        //
        rc = ScepGetPrivilegesFromOneTable(
                    LsaHandle,
                    hProfile,
                    SCE_ENGINE_SCP, // SCE_ENGINE_SMP,
                    dwAccountFormat,
                    (PVOID *)&pTempList,
                    Errlog
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // add non-exist nodes to pPrivileges
            //
            pNode=pTempList;
            pParent=NULL;

            while ( pNode ) {
                //
                // if this node does not exist in the SAP
                // this node is analyzed with "match" status
                // if it already exists in SAP, it is a "mismatched" item
                // duplication is prevented by the last argument TRUE
                //
                for ( pPriv=(PSCE_PRIVILEGE_ASSIGNMENT)(*pPrivileges);
                      pPriv != NULL; pPriv=pPriv->Next ) {
                    if ( pPriv->Status & SCE_INTERNAL_NP &&
                         _wcsicmp( pPriv->Name, pNode->Name) == 0 )
                        break;
                }
                if ( pPriv ) {
                    //
                    // find the entry in SAP, mismatched item
                    //
                    if ( pPriv->Status & SCE_STATUS_ERROR_NOT_AVAILABLE ) {
                        pPriv->Status = SCE_STATUS_ERROR_NOT_AVAILABLE;
                    } else {
                        pPriv->Status = SCE_STATUS_MISMATCH;
                    }

                    pParent = pNode;
                    pNode = pNode->Next;

                } else {
                    //
                    // does not exist in SAP.
                    // just move this node to SAP, with status SCE_STATUS_GOOD
                    //
                    if ( pParent )
                        pParent->Next = pNode->Next;
                    else
                        pTempList = pNode->Next;

                    pTemp = pNode;
                    pNode=pNode->Next;

                    pTemp->Next = (PSCE_PRIVILEGE_ASSIGNMENT)(*pPrivileges);
                    *((PSCE_PRIVILEGE_ASSIGNMENT *)pPrivileges) = pTemp;
                }
            }
            //
            // priv exist in analysis but not in template
            //
            for ( pPriv=(PSCE_PRIVILEGE_ASSIGNMENT)(*pPrivileges);
                  pPriv != NULL; pPriv=pPriv->Next ) {
                if ( pPriv->Status & SCE_INTERNAL_NP )
                    pPriv->Status = SCE_STATUS_NOT_CONFIGURED;
            }

        } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

            rc = SCESTATUS_SUCCESS;

        } else {
            //
            // pPrivileges will be freed outside
            //
        }

        if ( pTempList )
            ScepFreePrivilege(pTempList);
    }

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);
}


SCESTATUS
ScepGetPrivilegesFromOneTable(
   IN LSA_HANDLE LsaPolicy,
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN DWORD dwAccountFormat,
   OUT PVOID *pPrivileges,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

Arguments:

Return Value:


-- */
{
    SCESTATUS      rc;
    PSCESECTION    hSection=NULL;
    WCHAR         KeyName[36];
    PWSTR         Value=NULL;

    PSCE_PRIVILEGE_ASSIGNMENT   pPrivilegeAssigned=NULL;
    PSCE_PRIVILEGE_VALUE_LIST   pPrivilegeList=NULL;

    DWORD         KeyLen=0;
    DWORD         ValueLen;
    DWORD         Len;
    PWSTR         pTemp;
    DWORD         PrivValue;


    if ( pPrivileges == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    rc = ScepOpenSectionForName(
            hProfile,
            (ProfileType==SCE_ENGINE_GPO)? SCE_ENGINE_SCP : ProfileType,
            szPrivilegeRights,
            &hSection
            );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog, SCEERR_OPEN,
                             szPrivilegeRights
                           );
        return(rc);
    }

    JET_COLUMNID  ColGpoID = 0;
    JET_ERR       JetErr;
    LONG GpoID;


    if ( ProfileType == SCE_ENGINE_GPO ) {

        JET_COLUMNDEF ColumnGpoIDDef;

        JetErr = JetGetTableColumnInfo(
                        hSection->JetSessionID,
                        hSection->JetTableID,
                        "GpoID",
                        (VOID *)&ColumnGpoIDDef,
                        sizeof(JET_COLUMNDEF),
                        JET_ColInfo
                        );
        if ( JET_errSuccess == JetErr ) {
            ColGpoID = ColumnGpoIDDef.columnid;
        }
    }

    //
    // goto the first line of this section
    //
//    memset(KeyName, '\0', 72);   KeyName will be manually terminated later
    rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH,
                NULL,
                KeyName,
                70,
                &KeyLen,
                NULL,
                0,
                &ValueLen
                );
    while ( rc == SCESTATUS_SUCCESS ||
            rc == SCESTATUS_BUFFER_TOO_SMALL ) {

        //
        // terminate the string
        //
        KeyName[KeyLen/2] = L'\0';

        //
        // lookup privilege's value
        // ignore unknown privileges
        //
        if ( ( PrivValue = ScepLookupPrivByName(KeyName) ) == -1 ) {
            ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                                 Errlog,
                                 SCEERR_INVALID_PRIVILEGE,
                                 KeyName
                               );

            rc = SceJetGetValue(
                        hSection,
                        SCEJET_NEXT_LINE,
                        NULL,
                        KeyName,
                        70,
                        &KeyLen,
                        NULL,
                        0,
                        &ValueLen
                        );
            continue;
//            rc = SCESTATUS_INVALID_DATA;
//            goto Done;
        }

        GpoID = 1;

        if ( ProfileType == SCE_ENGINE_GPO ) {

            GpoID = 0;

            if ( ColGpoID > 0 ) {

                DWORD Actual;

                JetErr = JetRetrieveColumn(
                                hSection->JetSessionID,
                                hSection->JetTableID,
                                ColGpoID,
                                (void *)&GpoID,
                                4,
                                &Actual,
                                0,
                                NULL
                                );
            }
        }

        if ( ProfileType == SCE_ENGINE_GPO &&
             GpoID <= 0 ) {
            //
            // not domain GPO settings
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_NEXT_LINE,
                        NULL,
                        KeyName,
                        70,
                        &KeyLen,
                        NULL,
                        0,
                        &ValueLen
                        );
            continue;
        }

        //
        // allocate memory for the group name and value string
        //
        Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

        if ( Value == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;

        }
        //
        // Get the group and its value
        //
        rc = SceJetGetValue(
                    hSection,
                    SCEJET_CURRENT,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    Value,
                    ValueLen,
                    &ValueLen
                    );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

        //
        // create a node for this privilege
        //
        if ( ProfileType == SCE_ENGINE_SAP ||
             ProfileType == SCE_ENGINE_SMP ||
             ProfileType == SCE_ENGINE_GPO ||
             ProfileType == SCE_ENGINE_SCP ) {

            //
            // a sce_privilege_assignment structure. allocate buffer
            //
            pPrivilegeAssigned = (PSCE_PRIVILEGE_ASSIGNMENT)ScepAlloc( LMEM_ZEROINIT,
                                                                     sizeof(SCE_PRIVILEGE_ASSIGNMENT) );
            if ( pPrivilegeAssigned == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }
            pPrivilegeAssigned->Name = (PWSTR)ScepAlloc( (UINT)0, (wcslen(KeyName)+1)*sizeof(WCHAR));
            if ( pPrivilegeAssigned->Name == NULL ) {
                ScepFree(pPrivilegeAssigned);
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }

            wcscpy(pPrivilegeAssigned->Name, KeyName);
            pPrivilegeAssigned->Value = PrivValue;

            if ( SCE_ENGINE_SAP == ProfileType )
                pPrivilegeAssigned->Status = SCE_INTERNAL_NP;
            else
                pPrivilegeAssigned->Status = SCE_STATUS_GOOD;
        }

        //
        // add the multi-sz value string to the node, depending on the value type
        //
        PSID pSid=NULL;
        BOOL bBufferUsed;

        pTemp = Value;
        if (pTemp != NULL && pTemp[0] == L'\0' && ValueLen > 1) {
            pTemp ++;
        }

        while ( rc == SCESTATUS_SUCCESS && pTemp != NULL && pTemp[0]) {
            Len = wcslen(pTemp);

            if ( (ProfileType == SCE_ENGINE_SAP) &&
                 (_wcsicmp( SCE_ERROR_STRING, pTemp) == 0)  ) {
                //
                // this is an errored item
                //
                pPrivilegeAssigned->Status |= SCE_STATUS_ERROR_NOT_AVAILABLE;
                break;
            }

            //
            // convert pTemp (may be a name, or *SID format) to the right
            // format (SID_STRING, Name, or ACCOUNT_SID)
            //
            switch ( dwAccountFormat ) {
            case SCE_ACCOUNT_SID:

                if ( pTemp[0] == L'*' ) {
                    //
                    // this is the *SID format, convert to SID
                    //
                    if ( !ConvertStringSidToSid( pTemp+1, &pSid) ) {
                        //
                        // if failed to convert from sid string to sid,
                        // treat it as any name
                        //
                        rc = GetLastError();
                    }
                } else {
                    //
                    // lookup name for a sid
                    //
                    rc = RtlNtStatusToDosError(
                              ScepConvertNameToSid(
                                   LsaPolicy,
                                   pTemp,
                                   &pSid
                                   ));
                }

                if ( ERROR_SUCCESS == rc && pSid ) {

                    if ( ProfileType == SCE_ENGINE_SAP ||
                         ProfileType == SCE_ENGINE_SMP ||
                         ProfileType == SCE_ENGINE_GPO ||
                         ProfileType == SCE_ENGINE_SCP ) {

                        rc = ScepAddSidToNameList(
                                     &(pPrivilegeAssigned->AssignedTo),
                                     pSid,
                                     TRUE, // reuse the buffer
                                     &bBufferUsed
                                     );

                    } else {
                        //
                        // add to privilege list (as Sid)
                        //
                        rc = ScepAddSidToPrivilegeList(
                                      &pPrivilegeList,
                                      pSid,
                                      TRUE, // reuse the buffer
                                      PrivValue,
                                      &bBufferUsed
                                      );
                    }

                    if ( rc == ERROR_SUCCESS && bBufferUsed ) {
                        pSid = NULL;
                    }

                    rc = ScepDosErrorToSceStatus(rc);

                } else {
                    //
                    // add as name format
                    //
                    if ( ProfileType == SCE_ENGINE_SAP ||
                         ProfileType == SCE_ENGINE_SMP ||
                         ProfileType == SCE_ENGINE_GPO ||
                         ProfileType == SCE_ENGINE_SCP ) {

                        rc = ScepAddToNameList(&(pPrivilegeAssigned->AssignedTo), pTemp, Len );
                        rc = ScepDosErrorToSceStatus(rc);

                    } else {
                        //
                        // pPrivilegeList is a privilege_value list for each user/group.
                        // the LowValue and HighValue fields are combination of all privileges assigned to the user
                        //
                        rc = ScepAddToPrivilegeList(&pPrivilegeList, pTemp, Len, PrivValue);
                    }
                }

                if ( pSid ) {
                    LocalFree(pSid);
                    pSid = NULL;
                }

                break;

            default:

                if ( (dwAccountFormat != SCE_ACCOUNT_SID_STRING) &&
                     (pTemp[0] == L'*') ) {
                    //
                    // this is a *SID format, must be converted into Domain\Account format
                    //
                    if ( ProfileType == SCE_ENGINE_SAP ||
                         ProfileType == SCE_ENGINE_SMP ||
                         ProfileType == SCE_ENGINE_GPO ||
                         ProfileType == SCE_ENGINE_SCP ) {

                        rc = ScepLookupSidStringAndAddToNameList(
                                     LsaPolicy,
                                     &(pPrivilegeAssigned->AssignedTo),
                                     pTemp, // +1,
                                     Len    // -1
                                     );
                    } else {
                        //
                        // add to privilege value list
                        //
                        PWSTR strName=NULL;
                        DWORD strLen=0;

                        if ( ConvertStringSidToSid( pTemp+1, &pSid) ) {

                            rc = RtlNtStatusToDosError(
                                     ScepConvertSidToName(
                                            LsaPolicy,
                                            pSid,
                                            TRUE,       // want domain\account format
                                            &strName,
                                            &strLen
                                            ));
                            LocalFree(pSid);
                            pSid = NULL;

                        } else {
                            rc = GetLastError();
                        }

                        if ( rc == ERROR_SUCCESS ) {
                            //
                            // add the name to the privilege list
                            //
                            rc = ScepAddToPrivilegeList(&pPrivilegeList, strName, strLen, PrivValue);
                        } else {
                            //
                            // if couldn't lookup for the name, add *SID to the list
                            //
                            rc = ScepAddToPrivilegeList(&pPrivilegeList, pTemp, Len, PrivValue);
                        }

                        if ( strName ) {
                            ScepFree(strName);
                            strName = NULL;
                        }
                    }
                } else {

                    if ( ProfileType == SCE_ENGINE_SAP ||
                         ProfileType == SCE_ENGINE_SMP ||
                         ProfileType == SCE_ENGINE_GPO ||
                         ProfileType == SCE_ENGINE_SCP ) {

                        rc = ScepDosErrorToSceStatus(
                                 ScepAddToNameList(&(pPrivilegeAssigned->AssignedTo),
                                                   pTemp,
                                                   Len ));

                    } else {
                        //
                        // pPrivilegeList is a privilege_value list for each user/group.
                        // the LowValue and HighValue fields are combination of all privileges assigned to the user
                        //
                        rc = ScepAddToPrivilegeList(&pPrivilegeList, pTemp, Len, PrivValue);
#ifdef SCE_DBG
                        wprintf(L"\tAdd Priv %d for %s (%d bytes)\n", PrivValue, pTemp, Len);
#endif
                    }
                }
                break;
            }

            pTemp += Len +1;
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo( ERROR_WRITE_FAULT,
                                     Errlog,
                                     SCEERR_ADD,
                                     KeyName
                                   );
            }
        }

        //
        // Free memory
        //
        if ( rc != SCESTATUS_SUCCESS ) {
            if ( pPrivilegeAssigned != NULL )
                ScepFreePrivilege(pPrivilegeAssigned);

            if ( pPrivilegeList != NULL )
                ScepFreePrivilegeValueList(pPrivilegeList);

            goto Done;
        }

        //
        // link this to the PSCE_PRIVILEGE_ASSIGNMENT list in pPrivileges
        //
        if ( ProfileType == SCE_ENGINE_SAP ||
             ProfileType == SCE_ENGINE_SMP ||
             ProfileType == SCE_ENGINE_GPO ||
             ProfileType == SCE_ENGINE_SCP ) {

            pPrivilegeAssigned->Next = *((PSCE_PRIVILEGE_ASSIGNMENT *)pPrivileges);
            *((PSCE_PRIVILEGE_ASSIGNMENT *)pPrivileges) = pPrivilegeAssigned;
            pPrivilegeAssigned = NULL;

        }

        ScepFree(Value);
        Value = NULL;

        //
        // read next line
        //
//        memset(KeyName, '\0', 72);  KeyName will be manually terminated
        rc = SceJetGetValue(
                    hSection,
                    SCEJET_NEXT_LINE,
                    NULL,
                    KeyName,
                    70,
                    &KeyLen,
                    NULL,
                    0,
                    &ValueLen
                    );
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

    if ( rc == SCESTATUS_SUCCESS ) {

       if ( ProfileType == SCE_ENGINE_SCP_INTERNAL ||
            ProfileType == SCE_ENGINE_SMP_INTERNAL )
           *((PSCE_PRIVILEGE_VALUE_LIST *)pPrivileges) = pPrivilegeList;

    }

Done:

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    if ( Value != NULL )
        ScepFree(Value);

    //
    // close the section
    //
    SceJetCloseSection( &hSection, TRUE );

    return(rc);

}


SCESTATUS
ScepAddToPrivilegeList(
    OUT PSCE_PRIVILEGE_VALUE_LIST  *pPrivilegeList,
    IN PWSTR Name,
    IN DWORD Len,
    IN DWORD PrivValue
    )
{
    PSCE_PRIVILEGE_VALUE_LIST  pPriv,
                               LastOne=NULL;


    if ( pPrivilegeList == NULL || Name == NULL || Len == 0 )
        return(SCESTATUS_INVALID_PARAMETER);

    for ( pPriv = *pPrivilegeList;
          pPriv != NULL;
          LastOne=pPriv, pPriv = pPriv->Next ) {

        if ( ( wcslen(pPriv->Name) == Len ) &&
             ( _wcsnicmp( pPriv->Name, Name, Len ) == 0 ) ) {
            if ( PrivValue < 32 ) {

                pPriv->PrivLowPart |= (1 << PrivValue);
            } else {
                pPriv->PrivHighPart |= (1 << (PrivValue-32) );
            }
            break;
        }
    }
    if ( pPriv == NULL ) {
        //
        // Create a new one
        //
        pPriv = (PSCE_PRIVILEGE_VALUE_LIST)ScepAlloc( LMEM_ZEROINIT,
                                                sizeof(SCE_PRIVILEGE_VALUE_LIST));
        if ( pPriv == NULL )
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        pPriv->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Len+1)*sizeof(WCHAR));
        if ( pPriv->Name == NULL ) {
            ScepFree(pPriv);
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
        wcsncpy(pPriv->Name, Name, Len);

        if ( PrivValue < 32 ) {

            pPriv->PrivLowPart |= (1 << PrivValue);
        } else {
            pPriv->PrivHighPart |= (1 << (PrivValue-32) );
        }

        //
        // link to the list
        //
        if ( LastOne != NULL )
            LastOne->Next = pPriv;
        else
            *pPrivilegeList = pPriv;

    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepAddSidToPrivilegeList(
    OUT PSCE_PRIVILEGE_VALUE_LIST  *pPrivilegeList,
    IN PSID pSid,
    IN BOOL bReuseBuffer,
    IN DWORD PrivValue,
    OUT BOOL *pbBufferUsed
    )
{

    if ( pPrivilegeList == NULL || pbBufferUsed == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    *pbBufferUsed = FALSE;

    if ( pSid == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( !ScepValidSid(pSid) ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    PSCE_PRIVILEGE_VALUE_LIST  pPriv,
                               LastOne=NULL;

    //
    // check if the sid is already in the list
    //
    for ( pPriv = *pPrivilegeList;
          pPriv != NULL;
          LastOne=pPriv, pPriv = pPriv->Next ) {

        if ( pPriv->Name == NULL ) {
            continue;
        }

        if ( ScepValidSid( (PSID)(pPriv->Name) ) &&
             RtlEqualSid( (PSID)(pPriv->Name), pSid ) ) {

            if ( PrivValue < 32 ) {

                pPriv->PrivLowPart |= (1 << PrivValue);
            } else {
                pPriv->PrivHighPart |= (1 << (PrivValue-32) );
            }

            break;
        }
    }

    if ( pPriv == NULL ) {
        //
        // Create a new one
        //
        pPriv = (PSCE_PRIVILEGE_VALUE_LIST)ScepAlloc( LMEM_ZEROINIT,
                                                sizeof(SCE_PRIVILEGE_VALUE_LIST));
        if ( pPriv == NULL )
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        if ( bReuseBuffer ) {

            pPriv->Name = (PWSTR)pSid;
            *pbBufferUsed = TRUE;

        } else {

            DWORD Length = RtlLengthSid ( pSid );

            pPriv->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, Length);
            if ( pPriv->Name == NULL ) {
                ScepFree(pPriv);
                return(SCESTATUS_NOT_ENOUGH_RESOURCE);
            }

            RtlCopySid( Length, (PSID)(pPriv->Name), pSid );

        }

        if ( PrivValue < 32 ) {

            pPriv->PrivLowPart |= (1 << PrivValue);
        } else {
            pPriv->PrivHighPart |= (1 << (PrivValue-32) );
        }

        //
        // link to the list
        //
        if ( LastOne != NULL )
            LastOne->Next = pPriv;
        else
            *pPrivilegeList = pPriv;

    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepGetGroupMembership(
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
{
    SCESTATUS rc;
    DWORD OneStatus;

    PSCE_GROUP_MEMBERSHIP pTempList=NULL, pNode, pGroup2,
                            pParent, pTemp;

    LSA_HANDLE LsaHandle=NULL;

    rc = RtlNtStatusToDosError(
              ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &LsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {
        ScepBuildErrorLogInfo(
                    rc,
                    Errlog,
                    SCEDLL_LSA_POLICY
                    );
        return(ScepDosErrorToSceStatus(rc));
    }

    //
    // get groups from the requested table first
    //
    rc = ScepGetGroupMembershipFromOneTable(
                LsaHandle,
                hProfile,
                ProfileType,
                pGroupMembership,
                Errlog
                );
    //
    // return all groups if it is requested for SAP entry
    //
    if ( SCESTATUS_SUCCESS == rc && SCE_ENGINE_SAP == ProfileType ) {
        //
        // get the remaining stuff from SMP
        //
        rc = ScepGetGroupMembershipFromOneTable(
                    LsaHandle,
                    hProfile,
                    SCE_ENGINE_SCP,   //SCE_ENGINE_SMP,
                    &pTempList,
                    Errlog
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // add non-exist nodes to pObjectRoots
            //
            pNode=pTempList;
            pParent=NULL;

            while ( pNode ) {
                //
                // if this node does not exist in the SAP
                // this node is analyzed with "match" status
                // if it already exists in SAP, it is a "mismatched" item
                // duplication is prevented by the last argument TRUE
                //
                for ( pGroup2=*pGroupMembership; pGroup2 != NULL; pGroup2=pGroup2->Next ) {
                    if ( (pGroup2->Status & SCE_INTERNAL_NP) &&
                         _wcsicmp( pGroup2->GroupName, pNode->GroupName) == 0 )
                        break;
                }
                if ( pGroup2 ) {
                    //
                    // find the entry in SAP, mismatched item
                    // maybe pMembers, or pMemberOf
                    // or not analyzed item, or error items
                    //
                    OneStatus = pGroup2->Status;
                    pGroup2->Status = 0;

                    if ( (OneStatus & SCE_GROUP_STATUS_NOT_ANALYZED) ) {
                        // this item is added after last inspection
                        pGroup2->Status = SCE_GROUP_STATUS_NOT_ANALYZED;

                    } else if ( (OneStatus & SCE_GROUP_STATUS_ERROR_ANALYZED) ) {

                        // this item errored when analyzing
                        pGroup2->Status = SCE_GROUP_STATUS_ERROR_ANALYZED;

                    } else {
                        if ( pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS ) {
                            pGroup2->Status |= SCE_GROUP_STATUS_NC_MEMBERS;
                        } else {
                            if ( !(OneStatus & SCE_GROUP_STATUS_NC_MEMBERS) ) {
                                pGroup2->Status |= SCE_GROUP_STATUS_MEMBERS_MISMATCH;
                            } else {
                                // a matched members, pGroup2->pMembers should be NULL;
                                if ( pGroup2->pMembers ) {
                                    ScepFreeNameList(pGroup2->pMembers);
                                }
                                pGroup2->pMembers = pNode->pMembers;
                                pNode->pMembers = NULL;
                            }
                        }

                        if ( pNode->Status & SCE_GROUP_STATUS_NC_MEMBEROF ) {
                            pGroup2->Status |= SCE_GROUP_STATUS_NC_MEMBEROF;
                        } else {
                            if ( !(OneStatus & SCE_GROUP_STATUS_NC_MEMBEROF) ) {
                                pGroup2->Status |= SCE_GROUP_STATUS_MEMBEROF_MISMATCH;
                            } else {
                                // a matched memberof, pGroup2->pMemberOf should be NULL;
                                if ( pGroup2->pMemberOf ) {
                                    ScepFreeNameList(pGroup2->pMemberOf);
                                }
                                pGroup2->pMemberOf = pNode->pMemberOf;
                                pNode->pMemberOf = NULL;
                            }
                        }
                    }
                    pParent = pNode;
                    pNode = pNode->Next;

                } else {
                    //
                    // does not exist in SAP.
                    // this is a matched item on pMembers, and/or pMemberOf
                    // just move this node to SAP, with status NC_MEMBERS, or NC_MEMBEROF, or 0
                    //
                    if ( pParent )
                        pParent->Next = pNode->Next;
                    else
                        pTempList = pNode->Next;

                    pTemp = pNode;
                    pNode=pNode->Next;

                    pTemp->Next = *pGroupMembership;
                    *pGroupMembership = pTemp;
                }
            }
            //
            // group exist in analysis but not in template
            //
            for ( pGroup2=*pGroupMembership; pGroup2 != NULL; pGroup2=pGroup2->Next ) {
                if ( pGroup2->Status & SCE_INTERNAL_NP )
                    pGroup2->Status = SCE_GROUP_STATUS_NC_MEMBERS | SCE_GROUP_STATUS_NC_MEMBEROF;
            }

        } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

            rc = SCESTATUS_SUCCESS;

        } else {
            //
            // pGroupMembership will be freed outside
            //
        }

        if ( pTempList ) {
            ScepFreeGroupMembership(pTempList);
        }
    }

    //
    // now the group name may be in *SID format, conver it now to name
    //
    if ( SCESTATUS_SUCCESS == rc && *pGroupMembership ) {

        for ( pGroup2=*pGroupMembership; pGroup2 != NULL; pGroup2=pGroup2->Next ) {
            if ( pGroup2->GroupName == NULL ) {
                continue;
            }

            if ( pGroup2->GroupName[0] == L'*' ) {
                //
                // *SID format, convert it
                //
                PSID pSid=NULL;

                if ( ConvertStringSidToSid( (pGroup2->GroupName)+1, &pSid) ) {

                    PWSTR strName=NULL;
                    DWORD strLen=0;

                    if (NT_SUCCESS( ScepConvertSidToName(
                                        LsaHandle,
                                        pSid,
                                        TRUE,       // want domain\account format
                                        &strName,
                                        &strLen
                                        )) && strName ) {

                        ScepFree(pGroup2->GroupName);
                        pGroup2->GroupName = strName;
                        strName = NULL;
                    }

                    LocalFree(pSid);
                    pSid = NULL;
                }
            }
        }
    }

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);

}


SCESTATUS
ScepGetGroupMembershipFromOneTable(
    IN LSA_HANDLE  LsaPolicy,
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine retrieves group membership information from the Jet databasae
   and stores in the output buffer pGroupMembership. Group membership information
   is in [Group Membership] section.

Arguments:

   hProfile      - the profile handle context

   ProfileType   - Type of the Profile
                        SCE_ENGINE_SAP
                        SCE_ENGINE_SMP
                        SCE_ENGINE_SCP

   pGroupMembership - the output buffer to hold group membership info.

   Errlog    - the error list for errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA

-- */
{
    SCESTATUS      rc;
    PSCESECTION    hSection=NULL;
    PSCE_GROUP_MEMBERSHIP   pGroup=NULL;
    DWORD         GroupLen, ValueLen;
    PWSTR         GroupName=NULL;
    PWSTR         Value=NULL;
    DWORD         ValueType;
    ULONG         Len;
    PWSTR         pTemp;


    if ( pGroupMembership == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    rc = ScepOpenSectionForName(
            hProfile,
            ProfileType,
            szGroupMembership,
            &hSection
            );
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog,
                             SCEERR_OPEN,
                             szGroupMembership
                           );
        return(rc);
    }

    //
    // goto the first line of this section
    //
    rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH,
                NULL,
                NULL,
                0,
                &GroupLen,
                NULL,
                0,
                &ValueLen
                );
    while ( rc == SCESTATUS_SUCCESS ) {

        //
        // allocate memory for the group name and value string
        //
        GroupName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, GroupLen+2);
        Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

        if ( GroupName == NULL || Value == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;

        }
        //
        // Get the group and its value
        //
        rc = SceJetGetValue(
                    hSection,
                    SCEJET_CURRENT,
                    NULL,
                    GroupName,
                    GroupLen,
                    &GroupLen,
                    Value,
                    ValueLen,
                    &ValueLen
                    );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

        GroupName[GroupLen/2] = L'\0';
        Value[ValueLen/2] = L'\0';

#ifdef SCE_DBG
    wprintf(L"rc=%d, group membership: %s=%s\n", rc, GroupName, Value);
#endif

        if (pTemp = ScepWcstrr(GroupName, szMembers) )
            ValueType = 0;
        else if (pTemp = ScepWcstrr(GroupName, szMemberof) )
            ValueType = 1;
        else if (pTemp = ScepWcstrr(GroupName, szPrivileges) )
            ValueType = 2;

        if ( pTemp == NULL ) {
            ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                                 Errlog,
                                 SCEERR_CANT_FIND_KEYWORD,
                                 GroupName
                               );
            rc = SCESTATUS_INVALID_DATA;
            goto NextLine;  //Done;
        }

        Len = (DWORD)(pTemp - GroupName);

        //
        // if this is the first group, or a different group, create another node
        // Note, the group name may be in SID string format now.
        // Will be converted later (in the calling function) because we don't want
        // to lookup for the same group name several times (each group may have
        // multiple records).
        //
        if ( *pGroupMembership == NULL ||
             _wcsnicmp((*pGroupMembership)->GroupName, GroupName, Len) != 0 ||
             (*pGroupMembership)->GroupName[Len] != L'\0' ) {
            //
            // a new group. allocate buffer
            //
            pGroup = (PSCE_GROUP_MEMBERSHIP)ScepAlloc( LMEM_ZEROINIT, sizeof(SCE_GROUP_MEMBERSHIP) );
            if ( pGroup == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }
            pGroup->GroupName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Len+1)*sizeof(WCHAR));
            if ( pGroup->GroupName == NULL ) {
                ScepFree(pGroup);
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }
            //
            // get right case for group name
            //
            wcsncpy(pGroup->GroupName, GroupName, Len);

            // do not care return codes
            ScepGetGroupCase(pGroup->GroupName, Len);

            pGroup->Next = *pGroupMembership;

//            if ( SCE_ENGINE_SAP == ProfileType )
                pGroup->Status = SCE_GROUP_STATUS_NC_MEMBERS | SCE_GROUP_STATUS_NC_MEMBEROF;
//            else
//                pGroup->Status = 0;
            if ( SCE_ENGINE_SAP == ProfileType )
                pGroup->Status |= SCE_INTERNAL_NP;

        }

        //
        // add the multi-sz value string to the group node, depending on the value type
        //
        pTemp = Value;
        while ( rc == SCESTATUS_SUCCESS && pTemp != NULL && pTemp[0] ) {
            while ( *pTemp && L' ' == *pTemp ) {
                pTemp++;
            }

            if ( SCE_ENGINE_SAP == ProfileType ) {
                if ( !(*pTemp) ) {
                    // this is an not analyzed item
                    pGroup->Status = SCE_GROUP_STATUS_NOT_ANALYZED |
                                     SCE_INTERNAL_NP;

                    break;
                } else if ( _wcsicmp(SCE_ERROR_STRING, pTemp) == 0 ) {
                    // this is error item
                    pGroup->Status = SCE_GROUP_STATUS_ERROR_ANALYZED |
                                     SCE_INTERNAL_NP;

                    break;
                }
            }

            if ( !(*pTemp) ) {
                // empty string is not allowed
                break;
            }

            Len = wcslen(pTemp);

            if ( ValueType != 0 && ValueType != 1 ) {
#if 0
                //
                // privilege with optional via group name
                //
                Status = (*((CHAR *)pTemp)-'0')*10 + ((*((CHAR *)pTemp+1)) - '0');

                PWSTR strName=NULL;
                DWORD strLen=0;

                if ( pTemp[1] == L'*' ) {
                    //
                    // convert the SID string into name format
                    //
                    PSID pSid=NULL;

                    if ( ConvertStringSidToSid( pTemp+2, &pSid) ) {

                        rc = RtlNtStatusToDosError(
                                 ScepConvertSidToName(
                                        LsaPolicy,
                                        pSid,
                                        TRUE,       // want domain\account format
                                        &strName,
                                        &strLen
                                        ));
                        LocalFree(pSid);
                        pSid = NULL;

                    } else {
                        rc = GetLastError();
                    }
                }

                if ( ERROR_SUCCESS == rc  && strName ) {
                    rc = ScepAddToNameStatusList(&(pGroup->pPrivilegesHeld),
                                                 strName,
                                                 strLen,
                                                 Status);
                } else {
                    //
                    // if failed to convert, or it's a name format already
                    // just add it to the list
                    //
                    rc = ScepAddToNameStatusList(&(pGroup->pPrivilegesHeld),
                                                 pTemp+1, Len-1, Status);
                }

                if ( strName ) {
                    ScepFree(strName);
                    strName = NULL;
                }
#endif
            } else {
                //
                // members (0) of memberof (1)
                //
                if ( pTemp[0] == L'*' ) {
                    //
                    // *SID format, convert to name, and add to the list
                    //
                    rc = ScepLookupSidStringAndAddToNameList(LsaPolicy,
                                                             (ValueType == 0) ?
                                                               &(pGroup->pMembers):
                                                               &(pGroup->pMemberOf),
                                                             pTemp, // +1,
                                                             Len    // -1
                                                            );

                } else {

                    rc = ScepAddToNameList((ValueType == 0) ?
                                              &(pGroup->pMembers):
                                              &(pGroup->pMemberOf),
                                            pTemp,
                                            Len );
                }
            }

#ifdef SCE_DBG
            wprintf(L"Add %s to group list\n", pTemp);
#endif
            pTemp += Len +1;
        }

        //
        // Free memory
        //
        if ( rc != SCESTATUS_SUCCESS && pGroup != *pGroupMembership ) {

            pGroup->Next = NULL;
            ScepFreeGroupMembership( pGroup );
            goto Done;
        }

        switch ( ValueType ) {
        case 0: // members
            pGroup->Status &= ~SCE_GROUP_STATUS_NC_MEMBERS;
            break;
        case 1:
            pGroup->Status &= ~SCE_GROUP_STATUS_NC_MEMBEROF;
            break;
        }
        *pGroupMembership = pGroup;

NextLine:

        ScepFree(GroupName);
        GroupName = NULL;

        ScepFree(Value);
        Value = NULL;

        //
        // read next line
        //
        rc = SceJetGetValue(
                    hSection,
                    SCEJET_NEXT_LINE,
                    NULL,
                    NULL,
                    0,
                    &GroupLen,
                    NULL,
                    0,
                    &ValueLen
                    );
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

Done:

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    if ( GroupName != NULL )
        ScepFree(GroupName);

    if ( Value != NULL )
        ScepFree(Value);

    //
    // close the section
    //
    SceJetCloseSection( &hSection, TRUE );

    return(rc);

}


SCESTATUS
ScepOpenSectionForName(
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    IN PCWSTR     SectionName,
    OUT PSCESECTION *phSection
    )
{
    SCESTATUS      rc;
    DOUBLE        SectionID;
    SCEJET_TABLE_TYPE  tblType;

    //
    // table type
    //
    switch ( ProfileType ) {
    case SCE_ENGINE_SCP:
    case SCE_ENGINE_SCP_INTERNAL:
        tblType = SCEJET_TABLE_SCP;
        break;

    case SCE_ENGINE_SMP:
    case SCE_ENGINE_SMP_INTERNAL:
        tblType = SCEJET_TABLE_SMP;
        break;

    case SCE_ENGINE_SAP:
        tblType = SCEJET_TABLE_SAP;
        break;

    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // get section id
    //
    rc = SceJetGetSectionIDByName(
                hProfile,
                SectionName,
                &SectionID
                );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetOpenSection(
                hProfile,
                SectionID,
                tblType,
                phSection
                );
    return(rc);

}


SCESTATUS
ScepGetDsRoot(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*
DS object root has only one entry, which is the DS domain name
So the list contains only one entry.
The format of the DS domain name is dc=<domain>,dc=<domain1>,...o=internet,
which is the DNS name of the DS domain in LDAP format

*/
{
    SCESTATUS rc;
    PSCESECTION hSection=NULL;
    PSCE_OBJECT_LIST pDsRoot=NULL;
    PWSTR JetName=NULL;
    BOOL IsContainer, LastOne;
    DWORD Count, ValueLen;
    BYTE Status;
    WCHAR         StatusFlag=L'\0';


    rc = ScepOpenSectionForName(
            hProfile,
            ProfileType,
            SectionName,
            &hSection
            );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog,
                             SCEERR_OPEN,
                             SectionName
                           );
        return(rc);
    }

    rc = ScepLdapOpen(NULL);

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = ScepEnumerateDsObjectRoots(
                    NULL,
                    &pDsRoot
                    );
        ScepLdapClose(NULL);
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( pDsRoot == NULL ) {
            rc = SCESTATUS_PROFILE_NOT_FOUND;

        } else {
            //
            // Convert domain root
            //
            rc = ScepConvertLdapToJetIndexName(
                    pDsRoot->Name,
                    &JetName
                    );
        }
    }

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // goto the line matching the domain root
        //
        rc = SceJetSeek(
                hSection,
                JetName,
                wcslen(JetName)*sizeof(WCHAR),
                SCEJET_SEEK_GE
                );

        if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

            if ( ProfileType == SCE_ENGINE_SAP ) {
                //
                // the domain is not in the table, try another one
                //
                SceJetCloseSection(&hSection, FALSE);

                rc = ScepOpenSectionForName(
                        hProfile,
                        SCE_ENGINE_SCP,  // SCE_ENGINE_SMP,
                        SectionName,
                        &hSection
                        );
                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // get count under the domain
                    //
                    Count = 0;
                    rc = SceJetGetLineCount(
                                    hSection,
                                    JetName,
                                    FALSE,
                                    &Count);

                    if ( rc == SCESTATUS_SUCCESS  ||
                         rc == SCESTATUS_RECORD_NOT_FOUND ) {

                        if ( rc == SCESTATUS_SUCCESS )
                            pDsRoot->Status = SCE_STATUS_CHECK;
                        else
                            pDsRoot->Status = SCE_STATUS_NOT_CONFIGURED;
                        pDsRoot->IsContainer = TRUE;
                        pDsRoot->Count = Count;

                        *pObjectRoots = pDsRoot;
                        pDsRoot = NULL;

                        rc = SCESTATUS_SUCCESS;
                    }

                }
            }
            rc = SCESTATUS_SUCCESS;

        } else if ( rc == SCESTATUS_SUCCESS ) {
            //
            // something of the domain exist, get value and count of the domain
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_EXACT_MATCH,
                        JetName,
                        NULL,
                        0,
                        NULL,
                        (PWSTR)&StatusFlag,   // two bytes buffer
                        2,
                        &ValueLen
                        );

            if ( rc == SCESTATUS_SUCCESS ||
                 rc == SCESTATUS_BUFFER_TOO_SMALL ||
                 rc == SCESTATUS_RECORD_NOT_FOUND ) {

                if ( rc != SCESTATUS_RECORD_NOT_FOUND ) {
                    LastOne = TRUE;
                    Status = *((BYTE *)&StatusFlag);
                    IsContainer = *((CHAR *)&StatusFlag+1) != '0' ? TRUE : FALSE;

                } else {
                    LastOne = FALSE;
                    IsContainer = TRUE;
                    if ( ProfileType == SCE_ENGINE_SAP )
                        Status = SCE_STATUS_GOOD;
                    else
                        Status = SCE_STATUS_CHECK;
                }
                //
                // get count under the domain
                //
                rc = SceJetGetLineCount(
                                hSection,
                                JetName,
                                FALSE,
                                &Count);

                if ( rc == SCESTATUS_SUCCESS ) {

                    if ( LastOne )
                        Count--;

                    if ( !IsContainer && Count > 0 ) {
                        IsContainer = TRUE;
                    }

                    //
                    // the proper domain name is in pDsRoot
                    //
                    pDsRoot->Status = Status;
                    pDsRoot->IsContainer = IsContainer;
                    pDsRoot->Count = Count;

                    *pObjectRoots = pDsRoot;
                    pDsRoot = NULL;
                }

            }

        }
        if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
            rc = SCESTATUS_SUCCESS;
        }
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc),
                             Errlog, SCEERR_QUERY_INFO,
                             L"SCP/SMP");
        }

        if ( JetName != NULL ) {
            ScepFree(JetName);
        }

    } else {
        ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc),
                             Errlog, SCEERR_QUERY_INFO,
                             SectionName);
    }

    ScepFreeObjectList(pDsRoot);

    SceJetCloseSection(&hSection, TRUE);

    return(rc);
}


SCESTATUS
ScepGetObjectList(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine retrieves registry or files security information from the JET
   database for the root only. To get detail under a root object, call
   ScepGetChildrentObject.

   For Profiletype "SCE_ENGINE_SAP" (analysis info), a combination of SMP and SAP
   are returned for a complete set of "analyzed" objects.

Arguments:

   hProfile     - the profile handle context

   ProfileType  - value to indicate engine type.
                      SCE_ENGINE_SCP
                      SCE_ENGINE_SAP
                      SCE_ENGINE_SMP

   SectionName   - The section name for the objects to retrieve.

   pObjectRoots  - The output list of object roots

   Errlog   - the cummulative error list to hold errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */

{
    SCESTATUS rc;
    PSCE_OBJECT_LIST pTempList=NULL,
                    pNode;

    //
    // get roots from the first table first
    //
    rc = ScepGetObjectFromOneTable(
                hProfile,
                ProfileType,
                SectionName,
                pObjectRoots,
                Errlog
                );
    //
    // Ds objects only return the domain name, no need to search SMP
    //
    if ( rc == SCESTATUS_SUCCESS && ProfileType == SCE_ENGINE_SAP ) {
        //
        // get the stuff from SMP
        //
        rc = ScepGetObjectFromOneTable(
                    hProfile,
                    SCE_ENGINE_SCP,  // SCE_ENGINE_SMP,
                    SectionName,
                    &pTempList,
                    Errlog
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // add non-exist nodes to pObjectRoots
            //
            for ( pNode=pTempList; pNode != NULL; pNode = pNode->Next ) {

                //
                // if this node does not exist in the SAP
                // this node is analyzed with "match" status and
                // no bad children under the node
                // duplication is prevented by the last argument
                //
                rc = ScepAddToObjectList(pObjectRoots, pNode->Name, 0,
                                        pNode->IsContainer, SCE_STATUS_GOOD, 0, SCE_CHECK_DUP);

                if ( rc != ERROR_SUCCESS ) {
                    ScepBuildErrorLogInfo( rc,
                                     Errlog,
                                     SCEERR_ADD,
                                     pNode->Name
                                   );
                    //
                    // only the following two errors could be returned
                    //
                    if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        break;
                    } else
                        rc = SCESTATUS_INVALID_PARAMETER;
                }

            }

        } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

            rc = SCESTATUS_SUCCESS;

        } else {
            //
            // pObjectRoots will be freed outside
            //
        }

        if ( pTempList ) {
            ScepFreeObjectList(pTempList);

        }

    }

    return(rc);
}


SCESTATUS
ScepGetObjectFromOneTable(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine retrieves registry or files security information from the JET
   database for the root only. To get detail under a root object, call
   ScepGetChildrentObject.

Arguments:

   hProfile     - the profile handle context

   ProfileType  - value to indicate engine type.
                      SCE_ENGINE_SCP
                      SCE_ENGINE_SAP
                      SCE_ENGINE_SMP

   SectionName   - The section name for the objects to retrieve.

   pObjectRoots  - The output list of object roots

   Errlog   - the cummulative error list to hold errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{

    SCESTATUS      rc;
    PSCESECTION    hSection=NULL;
    DWORD         ObjectLen=0;
    WCHAR         ObjectName[21];
    WCHAR         StatusFlag=L'\0';
    BYTE          Status=0;
    BOOL          IsContainer=TRUE;
    DWORD         Len, Count;
    WCHAR         Buffer[21];
    BOOL          LastOne;
    DWORD         ValueLen=0;


    rc = ScepOpenSectionForName(
            hProfile,
            ProfileType,
            SectionName,
            &hSection
            );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog,
                             SCEERR_OPEN,
                             SectionName
                           );
        return(rc);
    }

    //
    // goto the first line of this section
    //
    rc = SceJetSeek(
                hSection,
                NULL,
                0,
                SCEJET_SEEK_GE
                );

    while ( rc == SCESTATUS_SUCCESS ||
            rc == SCESTATUS_BUFFER_TOO_SMALL ) {

        memset(ObjectName, '\0', 21*sizeof(WCHAR));
        memset(Buffer, '\0', 21*sizeof(WCHAR));

        rc = SceJetGetValue(
                    hSection,
                    SCEJET_CURRENT,
                    NULL,
                    ObjectName,
                    20*sizeof(WCHAR),
                    &ObjectLen,
                    (PWSTR)&StatusFlag,   // two bytes buffer
                    2,
                    &ValueLen
                    );
#ifdef SCE_DBG
    wprintf(L"ObjectLen=%d, StatusFlag=%x, ValueLen=%d, rc=%d, ObjectName=%s \n",
             ObjectLen, StatusFlag, ValueLen, rc, ObjectName);
#endif
        if ( rc != SCESTATUS_SUCCESS && rc != SCESTATUS_BUFFER_TOO_SMALL ) {
            ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                 Errlog,
                                 SCEERR_QUERY_VALUE,
                                 SectionName
                               );
            break;
        }
        //
        // get first component of the object
        //
        if ( ObjectLen <= 40 )
            ObjectName[ObjectLen/sizeof(WCHAR)] = L'\0';

        rc = ScepGetNameInLevel(
                    ObjectName,
                    1,
                    L'\\',
                    Buffer,
                    &LastOne
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            Len = wcslen(Buffer);

            if ( LastOne ) {

                Status = *((BYTE *)&StatusFlag);
                IsContainer = *((CHAR *)&StatusFlag+1) != '0' ? TRUE : FALSE;

            } else {
                IsContainer = TRUE;
                if ( ProfileType == SCE_ENGINE_SAP )
                    Status = SCE_STATUS_GOOD;
                else
                    Status = SCE_STATUS_CHECK;
            }

#ifdef SCE_DBG
        printf("\nStatus=%d, StatusFlag=%x, Len=%d, Buffer=%ws\n", Status, StatusFlag, Len, Buffer);
#endif
            //
            // get count of this object
            //
            rc = SceJetGetLineCount(
                            hSection,
                            Buffer,
                            FALSE,
                            &Count);

            if ( rc == SCESTATUS_SUCCESS  ||
                 rc == SCESTATUS_RECORD_NOT_FOUND ) {

                if ( LastOne )
                    Count--;

                if ( !IsContainer && Count > 0 ) {
                    IsContainer = TRUE;
                }

                //
                // the root of registry and file are always upper cased
                //
                _wcsupr(Buffer);

                rc = ScepAddToObjectList(pObjectRoots, Buffer, Len,
                                        IsContainer, Status, Count, 0);

                if ( rc != ERROR_SUCCESS ) {
                    ScepBuildErrorLogInfo( rc,
                                     Errlog,
                                     SCEERR_ADD,
                                     Buffer
                                   );
                    // only the following two errors could be returned
                    if ( rc == ERROR_NOT_ENOUGH_MEMORY )
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    else
                        rc = SCESTATUS_INVALID_PARAMETER;
                }
            }

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // seek to the next one
                //
                Buffer[Len-1] = (WCHAR)( Buffer[Len-1] + 1);

                rc = SceJetSeek(
                    hSection,
                    Buffer,
                    Len*sizeof(TCHAR),
                    SCEJET_SEEK_GT_NO_CASE
                    );

                if ( rc != SCESTATUS_SUCCESS && rc != SCESTATUS_RECORD_NOT_FOUND )
                    ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                         Errlog,
                                         SCEERR_QUERY_VALUE,
                                         SectionName
                                       );

            }
        }
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

    //
    // close the section
    //
    SceJetCloseSection( &hSection, TRUE );

    return(rc);

}


SCESTATUS
ScepGetAuditing(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   OUT PSCE_PROFILE_INFO pProfileInfo,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

   This routine retrieves system auditing information from the JET database
   and stores in the output buffer pProfileInfo. The auditing information
   is stored in [System Log], [Security Log], [Application Log], [Audit Event],
   [Audit Registry], and [Audit File] sections.

Arguments:

   hProfile - the profile handle context

   pProfileInfo  - the output buffer to hold profile info.

   Errlog   - The cummulative error list to hold errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{

    SCESTATUS            rc;
    SCE_KEY_LOOKUP       LogKeys[]={
        {(PWSTR)TEXT("MaximumLogSize"),         offsetof(struct _SCE_PROFILE_INFO, MaximumLogSize),          'D'},
        {(PWSTR)TEXT("AuditLogRetentionPeriod"),offsetof(struct _SCE_PROFILE_INFO, AuditLogRetentionPeriod), 'D'},
        {(PWSTR)TEXT("RetentionDays"),          offsetof(struct _SCE_PROFILE_INFO, RetentionDays),           'D'},
        {(PWSTR)TEXT("RestrictGuestAccess"),    offsetof(struct _SCE_PROFILE_INFO, RestrictGuestAccess),     'D'}
        };

    SCE_KEY_LOOKUP       EventKeys[]={
        {(PWSTR)TEXT("AuditSystemEvents"),  offsetof(struct _SCE_PROFILE_INFO, AuditSystemEvents),   'D'},
        {(PWSTR)TEXT("AuditLogonEvents"),   offsetof(struct _SCE_PROFILE_INFO, AuditLogonEvents),    'D'},
        {(PWSTR)TEXT("AuditObjectAccess"),  offsetof(struct _SCE_PROFILE_INFO, AuditObjectAccess),   'D'},
        {(PWSTR)TEXT("AuditPrivilegeUse"),  offsetof(struct _SCE_PROFILE_INFO, AuditPrivilegeUse),   'D'},
        {(PWSTR)TEXT("AuditPolicyChange"),  offsetof(struct _SCE_PROFILE_INFO, AuditPolicyChange),   'D'},
        {(PWSTR)TEXT("AuditAccountManage"), offsetof(struct _SCE_PROFILE_INFO, AuditAccountManage),  'D'},
        {(PWSTR)TEXT("AuditProcessTracking"),offsetof(struct _SCE_PROFILE_INFO, AuditProcessTracking),'D'},
        {(PWSTR)TEXT("AuditDSAccess"),      offsetof(struct _SCE_PROFILE_INFO, AuditDSAccess),       'D'},
        {(PWSTR)TEXT("AuditAccountLogon"),  offsetof(struct _SCE_PROFILE_INFO, AuditAccountLogon),   'D'}};

    DWORD cKeys = sizeof(EventKeys) / sizeof(SCE_KEY_LOOKUP);

    PCWSTR              szAuditLog;
    DWORD               i, j;
    PSCESECTION          hSection=NULL;


    if ( hProfile == NULL ||
         pProfileInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }


    for ( i=0; i<3; i++) {

        //
        // Get Event Log setting for system log, security log and application log
        //

        switch (i) {
        case 0:
            szAuditLog = szAuditSystemLog;
            break;
        case 1:
            szAuditLog = szAuditSecurityLog;
            break;
        default:
            szAuditLog = szAuditApplicationLog;
            break;
        }

        //
        // get DWORD values for the section
        //
        rc = ScepGetFixValueSection(
                   hProfile,
                   szAuditLog,
                   LogKeys,
                   4,
                   ProfileType,
                   (PVOID)pProfileInfo,
                   &hSection,
                   Errlog
                   );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

        // close the section
        SceJetCloseSection( &hSection, FALSE );

        //
        // update the Offset for next section
        //
        for ( j=0; j<4; j++ )
            LogKeys[j].Offset += sizeof(DWORD);
    }

    //
    // Get Audit Event info
    //
    //
    // get DWORD values for the section
    //
    rc = ScepGetFixValueSection(
               hProfile,
               szAuditEvent,
               EventKeys,
               cKeys,
               ProfileType,
               (PVOID)pProfileInfo,
               &hSection,
               Errlog
               );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    // close the section
    SceJetCloseSection( &hSection, TRUE );

Done:

    // close the section
    if ( rc != SCESTATUS_SUCCESS )
        SceJetCloseSection( &hSection, TRUE );

    return(rc);
}

//////////////////////////////
// helper APIs
//////////////////////////////

SCESTATUS
ScepGetUserSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR Name,
    OUT PVOID *ppInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Function Description:

    This routine get a dynamic section's information for a security area.
    Dynamic sections are those created dynamically, based on other sections'
    related information. Dynamic sections in a profile include User Security
    Profiles for SCP and User Settings for SAP/SMP. Name contains the section's
    identifier, either the section's name, or a partial name (e.g., a user
    name) for the section. The output must be casted to different structure,
    depending on the ProfileType and Area.

    The output buffer contains one instance of the requested information,
    e.g., one user security profile or one user's setting. To get all dynamic
    sections, this routine must be called repeatly. The output buffer must
    be freed by LocalFree after its use.

Arguments:

    hProfile    - The handle of the profile

    ProfileType - The type of the profile to read

    Name        - The dynamic section's identifier

    ppInfo      - Output buffer (PSCE_USER_PROFILE or PSCE_USER_SETTING)

    Errlog      - The error log buffer

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_PROFILE_NOT_FOUND
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_BAD_FORMAT
    SCESTATUS_INVALID_DATA

-- */

{
    //
    // not support area
    // if need this area later, refer to usersav directory for archived code
    //
    return(SCESTATUS_SERVICE_NOT_SUPPORT);

}


SCESTATUS
ScepGetObjectChildren(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectPrefix,
    IN SCE_SUBOBJECT_TYPE Option,
    OUT PVOID *Buffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*
Routine Description

    This routine is the same as ScepGetObjectChildrenFromOneTable, except when
    ProfileType is SCE_ENGINE_SAP, in which case, object children in SMP is also
    looked up and returned so the returned list contains the complete set of
    the objects analyzed.

Arguments:

    See ScepGetObjectChildrenFromOneTable

Return Value:

    See ScepGetObjectChildrenFromOneTable
*/
{
    SCESTATUS rc;

    rc = ScepGetObjectChildrenFromOneTable(
                      hProfile,
                      ProfileType,
                      Area,
                      ObjectPrefix,
                      Option,
                      Buffer,
                      Errlog
                      );

    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
        rc = SCESTATUS_SUCCESS;
    }

    if ( rc == SCESTATUS_SERVICE_NOT_SUPPORT &&
         ProfileType == SCE_ENGINE_SAP &&
         Option == SCE_IMMEDIATE_CHILDREN ) {

        return( SCESTATUS_RECORD_NOT_FOUND);  // no acl support, do not allow children
    }

    if ( rc == SCESTATUS_SUCCESS &&
         ProfileType == SCE_ENGINE_SAP &&
         Option == SCE_IMMEDIATE_CHILDREN ) {

        PSCE_OBJECT_CHILDREN pTempList=NULL;
        PSCE_OBJECT_CHILDREN_NODE *pArrObject=NULL;
        DWORD arrCount=0, MaxCount=0;
        LONG FindIndex;

        if ( *Buffer ) {
            arrCount = ((PSCE_OBJECT_CHILDREN)(*Buffer))->nCount;
            MaxCount = ((PSCE_OBJECT_CHILDREN)(*Buffer))->MaxCount;
            pArrObject = &(((PSCE_OBJECT_CHILDREN)(*Buffer))->arrObject);
        }

        //
        // get object children from SMP table too
        //
        rc = ScepGetObjectChildrenFromOneTable(
                          hProfile,
                          SCE_ENGINE_SCP,  //SCE_ENGINE_SMP,
                          Area,
                          ObjectPrefix,
                          Option,
                          (PVOID *)(&pTempList),
                          Errlog
                          );

        if ( rc == SCESTATUS_SUCCESS && pTempList ) {
            //
            // add non-exist nodes to Buffer
            //
            DWORD i;
            PSCE_OBJECT_CHILDREN_NODE *pTmpObject= &(pTempList->arrObject);

            for ( i=0; i<pTempList->nCount; i++ ) {

                //
                // if this node does not exist in the SAP
                // this node is analyzed with "match" status and
                // no bad children under the node
                // duplication is prevented by the last argument
                //
                if ( pTmpObject[i] == NULL ||
                     pTmpObject[i]->Name == NULL ) {
                    continue;
                }

                FindIndex = -1;
                pTmpObject[i]->Status = SCE_STATUS_GOOD;

                rc = ScepAddItemToChildren(
                            pTmpObject[i],
                            pTmpObject[i]->Name,
                            0,
                            pTmpObject[i]->IsContainer,
                            pTmpObject[i]->Status,
                            pTmpObject[i]->Count,
                            &pArrObject,
                            &arrCount,
                            &MaxCount,
                            &FindIndex
                            );

                if ( rc == ERROR_SUCCESS ) {
                    //
                    // successfully added
                    //
                    pTmpObject[i] = NULL;
                } else if ( rc == ERROR_DUP_NAME ) {
                    //
                    // node already exist, ignore the error
                    //
                    rc = ERROR_SUCCESS;

                } else {
                    ScepBuildErrorLogInfo( rc,
                                     Errlog,
                                     SCEERR_ADD,
                                     pTmpObject[i]->Name
                                   );
                    //
                    // only the following two errors could be returned
                    //
                    if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        break;
                    } else
                        rc = SCESTATUS_INVALID_PARAMETER;
                }

            }

        } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

            rc = SCESTATUS_SUCCESS;

        }

        if ( pTempList ) {
            ScepFreeObjectChildren(pTempList);
        }

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // detect if status of this container or any of its "immediate" parent
            // is in "auto-inherit" status. If so, query from the system to
            // get good items.
            //

            BYTE ParentStatus = ScepGetObjectStatusFlag(
                                           hProfile,
                                           SCE_ENGINE_SCP,   //SCE_ENGINE_SMP,
                                           Area,
                                           ObjectPrefix,
                                           TRUE);

            BYTE AnalysisStatus = ScepGetObjectStatusFlag(
                                           hProfile,
                                           SCE_ENGINE_SAP,
                                           Area,
                                           ObjectPrefix,
                                           FALSE);
            //
            // compute the status to be used for all enumerated objects
            //
            BYTE NewStatus;

            if ( AnalysisStatus == SCE_STATUS_ERROR_NOT_AVAILABLE ||
                 AnalysisStatus == SCE_STATUS_NOT_ANALYZED ) {

                NewStatus = SCE_STATUS_NOT_ANALYZED;

            } else if ( ParentStatus == SCE_STATUS_OVERWRITE ) {

                NewStatus = SCE_STATUS_GOOD;
            } else {
                NewStatus = SCE_STATUS_NOT_CONFIGURED;
            }

            //
            // even though there is no parent in SMP, still return all objects
            //
//            if ( (BYTE)-1 != ParentStatus ) {

                // if any child is found for this level
                // get the remaining "good" status nodes from system
                //

                PWSTR           WildCard=NULL;
                DWORD           BufSize;

                switch ( Area ) {
                case AREA_FILE_SECURITY:

                    struct _wfinddata_t FileInfo;
                    intptr_t            hFile;
                    BOOL            BackSlashExist;

                    BufSize = wcslen(ObjectPrefix)+4;
                    WildCard = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                    if ( !WildCard ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        break;
                    }
                    BackSlashExist = ScepLastBackSlash(ObjectPrefix);
                    if ( BackSlashExist )
                        swprintf(WildCard, L"%s*.*", ObjectPrefix);
                    else
                        swprintf(WildCard, L"%s\\*.*", ObjectPrefix);

                    hFile = _wfindfirst(WildCard, &FileInfo);

                    ScepFree(WildCard);
                    WildCard = NULL;

                    if ( hFile != -1 &&
                         ( 0 == ( GetFileAttributes(ObjectPrefix) &   // bug 635098: don't propagate permissions
                                  FILE_ATTRIBUTE_REPARSE_POINT )))    // across junction points 
                    {
                        do {
                            if ( wcscmp(L"..", FileInfo.name) == 0 ||
                                 wcscmp(L".", FileInfo.name) == 0 )
                                continue;

                            FindIndex = -1;

                            rc = ScepAddItemToChildren(
                                        NULL,
                                        FileInfo.name,
                                        0,
                                        (FileInfo.attrib & _A_SUBDIR) ? TRUE : FALSE,
                                        NewStatus,
                                        0,
                                        &pArrObject,
                                        &arrCount,
                                        &MaxCount,
                                        &FindIndex
                                        );

                            if ( rc == ERROR_DUP_NAME ) {
                                rc = ERROR_SUCCESS;
                            } else if ( rc != ERROR_SUCCESS ) {
                                ScepBuildErrorLogInfo( rc,
                                                 Errlog,
                                                 SCEERR_ADD,
                                                 FileInfo.name
                                               );
                                //
                                // only the following two errors could be returned
                                //
                                if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
                                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                    break;
                                } else
                                    rc = SCESTATUS_INVALID_PARAMETER;
                            }

                        } while ( _wfindnext(hFile, &FileInfo) == 0 );

                        _findclose(hFile);
                    }

                    break;
                case AREA_REGISTRY_SECURITY:

                    HKEY            hKey;
                    DWORD           index;
                    DWORD           EnumRc;
                    //
                    // open the key (on a 64-bit platform, 64-bit
                    // registry only will be done if SCE_ENGINE_SAP)
                    //
                    rc = ScepOpenRegistryObject(
                                SE_REGISTRY_KEY,
                                ObjectPrefix,
                                KEY_READ,
                                &hKey
                                );

                    if ( rc == ERROR_SUCCESS ) {
                        index = 0;
                        //
                        // enumerate all subkeys of the key
                        //
                        do {
                            WildCard = (PWSTR)ScepAlloc(LMEM_ZEROINIT, MAX_PATH*sizeof(WCHAR));
                            if ( WildCard == NULL ) {
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                break;
                            }
                            BufSize = MAX_PATH;

                            EnumRc = RegEnumKeyEx(hKey,
                                            index,
                                            WildCard,
                                            &BufSize,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);

                            if ( EnumRc == ERROR_SUCCESS ) {
                                index++;
                                //
                                // add the name to the object list
                                //
                                FindIndex = -1;
                                rc = ScepAddItemToChildren(
                                            NULL,
                                            WildCard,
                                            BufSize,
                                            TRUE,
                                            NewStatus,
                                            0,
                                            &pArrObject,
                                            &arrCount,
                                            &MaxCount,
                                            &FindIndex
                                            );

                                if ( rc == ERROR_DUP_NAME ) {
                                    rc = ERROR_SUCCESS;
                                } else if ( rc != ERROR_SUCCESS ) {
                                    ScepBuildErrorLogInfo( rc,
                                                     Errlog,
                                                     SCEERR_ADD,
                                                     WildCard
                                                   );
                                    //
                                    // only the following two errors could be returned
                                    //
                                    if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
                                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                        break;
                                    } else
                                        rc = SCESTATUS_INVALID_PARAMETER;
                                }
                            }

                            ScepFree(WildCard);
                            WildCard = NULL;

                        } while ( EnumRc != ERROR_NO_MORE_ITEMS );

                        RegCloseKey(hKey);

                    } else {
                        rc = ScepDosErrorToSceStatus(rc);
                    }

                    break;
#if 0
                case AREA_DS_OBJECTS:

                    PSCE_NAME_LIST  pTemp, pList=NULL;

                    rc = ScepLdapOpen(NULL);

                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // detect if the Ds object exist
                        //
                        rc = ScepDsObjectExist(ObjectPrefix);

                        if ( rc == SCESTATUS_SUCCESS ) {

                            rc = ScepEnumerateDsOneLevel(ObjectPrefix, &pList);
                            //
                            // add each one to the object list
                            //
                            for (pTemp=pList; pTemp != NULL; pTemp = pTemp->Next ) {
                                //
                                // look for the first ldap component
                                //
                                WildCard = wcschr(pTemp->Name, L',');
                                if ( WildCard ) {
                                    BufSize = (DWORD)(WildCard - pTemp->Name);
                                } else {
                                    BufSize = 0;
                                }

                                rc = ScepAddItemToChildren(
                                            NULL,
                                            pTemp->Name,
                                            BufSize,
                                            TRUE,
                                            NewStatus,
                                            0,
                                            &pArrObject,
                                            &arrCount,
                                            &MaxCount,
                                            &FindIndex
                                            );

                                if ( rc != ERROR_SUCCESS ) {
                                    ScepBuildErrorLogInfo( rc,
                                                     Errlog,
                                                     SCEERR_ADD,
                                                     pTemp->Name
                                                   );
                                    //
                                    // only the following two errors could be returned
                                    //
                                    if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
                                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                        break;
                                    } else
                                        rc = SCESTATUS_INVALID_PARAMETER;
                                }
                            }
                            if ( pList ) {
                                //
                                // free the list
                                //
                                ScepFreeNameList(pList);
                            }
                        }
                        ScepLdapClose(NULL);
                    }
                    break;
#endif

                }
                //
                // ignore other errors except out of memory
                //
                if ( rc != SCESTATUS_NOT_ENOUGH_RESOURCE ) {
                    rc = SCESTATUS_SUCCESS;
                }
//            }

        }
/*
        if ( *Buffer ) {
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->nCount = arrCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->MaxCount = MaxCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->arrObject = pArrObject;
        }
*/
        if ( pArrObject ) {
            *Buffer = (PVOID)((PBYTE)pArrObject - 2*sizeof(DWORD));
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->nCount = arrCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->MaxCount = MaxCount;
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            //
            // free Buffer
            //
            ScepFreeObjectChildren((PSCE_OBJECT_CHILDREN)(*Buffer));
            *Buffer = NULL;
        }
    }

    if ( (SCESTATUS_SUCCESS == rc) &&
         (*Buffer == NULL) ) {
        //
        // get nothing
        //
        rc = SCESTATUS_RECORD_NOT_FOUND;
    }

    return(rc);
}


BYTE
ScepGetObjectStatusFlag(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN AREA_INFORMATION Area,
   IN PWSTR ObjectPrefix,
   IN BOOL bLookForParent
   )
/*
Routine Description:

    To find the status for the closest parent  node (immediate/non immediate)
    for the Object in the table.

Arguments:

    hProfile - the databaes handle

    ProfileType - the table type

    Area - the area information

    ObjectPrefix - the object's full name

Return Value:

    Byte - the status flag for the nearest parent if one is found

*/
{
    LPCTSTR SectionName;
    PSCESECTION hSection=NULL;
    WCHAR Delim;
    BYTE Status=(BYTE)-1;

    SCESTATUS rc;
    PWSTR JetName=NULL;


    switch ( Area) {
    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        JetName = ObjectPrefix;
        Delim = L'\\';
        break;
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        JetName = ObjectPrefix;
        Delim = L'\\';
        break;
#if 0
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        Delim = L',';
        rc = ScepConvertLdapToJetIndexName(
                ObjectPrefix,
                &JetName
                );
        if ( rc != SCESTATUS_SUCCESS ) {
            return (BYTE)-1;
        }
        break;
#endif
    default:
        return (BYTE)-1;
    }

    rc = ScepOpenSectionForName(
            hProfile,
            ProfileType,
            SectionName,
            &hSection
            );
    if ( SCESTATUS_SUCCESS == rc ) {

        Status = ScepGetObjectAnalysisStatus(hSection,
                                             JetName,
                                             bLookForParent
                                            );
    }

    SceJetCloseSection(&hSection, TRUE);

    if ( JetName != ObjectPrefix ) {
        ScepFree(JetName);
    }

    if ( SCESTATUS_SUCCESS == rc ) {
        return Status;
    }

    return (BYTE)-1;
}

SCESTATUS
ScepGetObjectChildrenFromOneTable(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectPrefix,
    IN SCE_SUBOBJECT_TYPE Option,
    OUT PVOID *Buffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

    This routine is used for Registry and File Security ONLY.

    This routine takes a object prefix ( e.g., a parent nodes full path name)
    and outputs all files and sub directories under the object, or the immediate
    children under the object, based on Option. When all files and sub
    directories are outputted, the output information is in a n-tree structure
    (SCE_OBJECT_TREE). If only the immediate children are outputted, the
    output information is in a list structure (SCE_OBJECT_CHILDREN). The output buffer
    must be freed by LocalFree after its use.

Arguments:

    hProfile    - The handle to the profile

    ProifleType - The type of the profile to read

    Area        - The security area to read info
                    AREA_REGISTRY_SECURITY
                    AREA_FILE_SECURITY

    ObjectPrefix- The parent nodes full path name (e.g., c:\winnt)

    Option      - The option for output information. Valid values are
                    SCE_ALL_CHILDREN
                    SCE_IMMEDIATE_CHILDREN

    Buffer      - The output buffer.

    Errlog      - The error log buffer.

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_PROFILE_NOT_FOUND
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_BAD_FORMAT
    SCESTATUS_INVALID_DATA
-- */
{
    SCESTATUS       rc = SCESTATUS_SUCCESS;
    PCWSTR          SectionName=NULL;
    PWSTR           JetName;
    WCHAR           Delim=L'\\';


    if ( ObjectPrefix == NULL || ObjectPrefix[0] == L'\0' )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( Option == SCE_ALL_CHILDREN &&
         ProfileType == SCE_ENGINE_SAP )
        return(SCESTATUS_INVALID_PARAMETER);


    switch (Area) {
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        JetName = ObjectPrefix;
        break;

    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        JetName = ObjectPrefix;

        break;
#if 0
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        Delim = L',';

        rc = ScepConvertLdapToJetIndexName(
                ObjectPrefix,
                &JetName
                );
        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
        *Buffer = NULL;
        break;
#endif

    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD           PrefixLen;
    PWSTR           NewPrefix;
    PWSTR           ObjectName=NULL;
    PWSTR           Value=NULL;
    DWORD           ObjectLen, ValueLen;
    PWSTR           Buffer1=NULL;

    //
    // make a new prefix to force a Delim at the end
    //
    PrefixLen = wcslen(JetName);

    if ( Option != SCE_ALL_CHILDREN ) {

        if ( JetName[PrefixLen-1] != Delim )
            PrefixLen++;

        NewPrefix = (PWSTR)ScepAlloc(0, (PrefixLen+1)*sizeof(WCHAR));

        if ( NewPrefix == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

        } else {
            wcscpy(NewPrefix, JetName);
            NewPrefix[PrefixLen-1] = Delim;
            NewPrefix[PrefixLen] = L'\0';
        }
    } else
        NewPrefix = JetName;

    if ( rc != SCESTATUS_SUCCESS ) {
        if ( Area == AREA_DS_OBJECTS )
            ScepFree(JetName);

        return(rc);
    }

    PSCESECTION      hSection=NULL;
    DWORD            i;
    PSCE_OBJECT_CHILDREN_NODE *pArrObject=NULL;
    DWORD            arrCount=0;
    DWORD            MaxCount=0;
    LONG             LastIndex=-1;
    LONG             FindIndex=-1;

    //
    // open the section
    //
    rc = ScepOpenSectionForName(
                hProfile,
                ProfileType,
                SectionName,
                &hSection
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( ProfileType == SCE_ENGINE_SAP &&
             Option != SCE_ALL_CHILDREN &&
             PrefixLen > 2 ) {

            //
            // find if this drive support ACL
            //
            WCHAR StatusFlag=L'\0';
            WCHAR SaveChr = NewPrefix[3];

            NewPrefix[3] = L'\0';

            rc = SceJetGetValue(
                        hSection,
                        SCEJET_EXACT_MATCH_NO_CASE,
                        NewPrefix,
                        NULL,
                        0,
                        NULL,
                        (PWSTR)&StatusFlag,   // two bytes buffer
                        2,
                        &i
                        );

            NewPrefix[3] = SaveChr;

            if ( SCESTATUS_SUCCESS == rc ||
                 SCESTATUS_BUFFER_TOO_SMALL == rc ) {

                i = *((BYTE *)&StatusFlag);

                if ( i == (BYTE)SCE_STATUS_NO_ACL_SUPPORT ||
                     i == (DWORD)SCE_STATUS_NO_ACL_SUPPORT ) {

                    rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                } else {

                    rc = SCESTATUS_SUCCESS;
                }
            } else {
                rc = SCESTATUS_SUCCESS;
            }
        }
    } else {

        ScepBuildErrorLogInfo( ERROR_INVALID_HANDLE,
                            Errlog,
                            SCEERR_OPEN,
                            SectionName
                          );
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        DWORD           Level;
        PWSTR           pTemp;
        DWORD           SDsize=0;

        pTemp = wcschr(JetName, Delim);
        Level=1;
        while ( pTemp ) {
            pTemp++;
            if ( pTemp[0] != 0 )
                Level++;
            pTemp = wcschr(pTemp, Delim);
        }
        Level++;


        if ( Option == SCE_ALL_CHILDREN ) {
            //
            // find the first record in the section
            //
            rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH_NO_CASE,
                JetName,
                NULL,
                0,
                &SDsize,  // temp use for ObjectLen,
                NULL,
                0,
                &i       // temp use for ValueLen
                );
        } else {
            //
            // find the first record matching prefix in the section
            //
            rc = SceJetSeek(
                    hSection,
                    NewPrefix,
                    PrefixLen*sizeof(TCHAR),
                    SCEJET_SEEK_GE_NO_CASE
                    );

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // start the Ldap server
                //
                if ( Area == AREA_DS_OBJECTS) {

                    rc = ScepLdapOpen(NULL);

                    if ( rc != SCESTATUS_SUCCESS ) {
                        ScepBuildErrorLogInfo( 0,
                                Errlog,
                                SCEERR_CONVERT_LDAP,
                                L""
                                );
                    }
                }

                if ( rc == SCESTATUS_SUCCESS ) {
                    rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        &SDsize,  // temp use for ObjectLen,
                        NULL,
                        0,
                        &i        // temp use for ValueLen
                        );
                }
            }

        }

        DWORD Count=0;
        BYTE            Status;
        BOOL            IsContainer;
        SCEJET_FIND_TYPE FindFlag;

        while ( rc == SCESTATUS_SUCCESS ) {

            //
            // allocate memory for the group name and value string
            //
            ObjectName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, SDsize+2);  // ObjectLen
            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, i+2);  //ValueLen

            if ( ObjectName == NULL || Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;

            }
            //
            // Get the group and its value
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        ObjectName,
                        SDsize,
                        &ObjectLen,
                        Value,
                        i,
                        &ValueLen
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                     Errlog,
                                     SCEERR_QUERY_VALUE,
                                     SectionName
                                   );
                goto Done;
            }

            //
            // teminate the string
            //
            if ( ObjectLen > SDsize )
                ObjectLen = SDsize;
            if ( ValueLen > i )
                ValueLen = i;

            ObjectName[ObjectLen/2] = L'\0';
            Value[ValueLen/2] = L'\0';

            if ( Option == SCE_ALL_CHILDREN ) {
                //
                // add this object to the object tree
                //

                PSECURITY_DESCRIPTOR pTempSD=NULL;
                SECURITY_INFORMATION SeInfo;

                //
                // use i temperatorily
                //
                i = ConvertTextSecurityDescriptor(
                                   Value+1,
                                   &pTempSD,
                                   &SDsize,
                                   &SeInfo
                                   );

                if ( i == NO_ERROR ) {

                    if ( Area != AREA_DS_OBJECTS ) {
                        ScepChangeAclRevision(pTempSD, ACL_REVISION);
                    }

                    Status = *((BYTE *)Value);
                    IsContainer = *((CHAR *)Value+1) != '0' ? TRUE : FALSE;

                    if ( Area == AREA_DS_OBJECTS && *Buffer == NULL ) {
                        //
                        // build the first node separately because the first node
                        // is always the domain name with its DNS name as full name
                        //
                        rc = ScepBuildDsTree(
                                (PSCE_OBJECT_CHILD_LIST *)Buffer,
                                Level-1,
                                Delim,
                                JetName
                                );
                        if ( rc == SCESTATUS_SUCCESS ) {

                            if ( _wcsicmp(ObjectName, JetName) == 0 ) {
                                //
                                // exact match
                                //
                                (*((PSCE_OBJECT_TREE *)Buffer))->IsContainer = IsContainer;
                                (*((PSCE_OBJECT_TREE *)Buffer))->Status = Status;
                                (*((PSCE_OBJECT_TREE *)Buffer))->pSecurityDescriptor = pTempSD;
                                (*((PSCE_OBJECT_TREE *)Buffer))->SeInfo = SeInfo;

                            } else {

                                rc = ScepBuildObjectTree(
                                        NULL,
                                        (PSCE_OBJECT_CHILD_LIST *)Buffer,
                                        Level-1,
                                        Delim,
                                        ObjectName,
                                        IsContainer,
                                        Status,
                                        pTempSD,
                                        SeInfo
                                        );
                            }
                        }

                    } else {

                        rc = ScepBuildObjectTree(
                                NULL,
                                (PSCE_OBJECT_CHILD_LIST *)Buffer,
                                (Area == AREA_DS_OBJECTS) ? Level : 1,
                                Delim,
                                ObjectName,
                                IsContainer,
                                Status,
                                pTempSD,
                                SeInfo
                                );
                    }
                    if ( rc != SCESTATUS_SUCCESS ) {
                        ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc),
                                             Errlog,
                                             SCEERR_BUILD_OBJECT
                                           );
                        ScepFree(pTempSD);
                    }

                } else {
                    ScepBuildErrorLogInfo( i,
                                         Errlog,
                                         SCEERR_BUILD_SD,
                                         ObjectName  // Value+1
                                       );
                    rc = ScepDosErrorToSceStatus(i);
                }
                FindFlag = SCEJET_NEXT_LINE;

            } else {

                INT             CompFlag;
                DWORD           ListHeadLen;

                // verify it is within the right range
                CompFlag = _wcsnicmp(ObjectName, NewPrefix, PrefixLen);

                if ( pArrObject != NULL && LastIndex >= 0 && LastIndex < (LONG)arrCount ) {
                    ListHeadLen = wcslen(pArrObject[LastIndex]->Name);

                } else
                    ListHeadLen = 0;

                if ( (CompFlag == 0 && PrefixLen == ObjectLen/2) ||
                     CompFlag < 0 ) {
                    // CompFlag < 0 should be impossible!!!
                    // if it is the exact match with ObjectPrefix, ignore
                    //
                    // Every next level node is returned in the ObjectList
                    // with either
                    //    Count=0 ( no sub children ), or
                    //    Count > 0 && Status=SCE_STATUS_GOOD (this one is good)
                    //                 Status=mismatch/unknown/ignore/check
                    // should not count the object itself
                    //
                    rc = SceJetMoveNext(hSection);

                } else if (CompFlag > 0 ) {

                    rc = SCESTATUS_RECORD_NOT_FOUND;

                } else if (pArrObject != NULL && LastIndex >= 0 && LastIndex < (LONG)arrCount &&
                         PrefixLen+ListHeadLen < ObjectLen/2 &&
                         ObjectName[PrefixLen+ListHeadLen] == Delim &&
                         _wcsnicmp( pArrObject[LastIndex]->Name, ObjectName+PrefixLen,
                                    ListHeadLen ) == 0 ) {
                    //
                    // if the list is not NULL, check the list head (new added item)
                    // to see if the ObjectName is already in. If yes, skip
                    //
                    Buffer1 = (PWSTR)ScepAlloc(0, (ListHeadLen+PrefixLen+2)*sizeof(WCHAR));

                    if ( Buffer1 == NULL ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                    } else {

                        swprintf(Buffer1, L"%s%s", NewPrefix, pArrObject[LastIndex]->Name);
                        Buffer1[PrefixLen+ListHeadLen] = (WCHAR) (Delim + 1);
                        Buffer1[PrefixLen+ListHeadLen+1] = L'\0';
                        //
                        // skip the block
                        //
                        rc = SceJetSeek(
                                hSection,
                                Buffer1,
                                (PrefixLen+ListHeadLen+1)*sizeof(TCHAR),
                                SCEJET_SEEK_GE_DONT_CARE  //SCEJET_SEEK_GE_NO_CASE
                                );

                        ScepFree(Buffer1);
                        Buffer1 = NULL;

                    }

                } else {

                    DWORD           Len;
                    BOOL            LastOne;

                    //
                    // searching for the right level component
                    //
                    PWSTR pStart = ObjectName;

                    for ( i=0; i<Level; i++) {

                        pTemp = wcschr(pStart, Delim);

                        if ( i == Level-1 ) {
                            //
                            // find the right level
                            //
                            if ( pTemp == NULL ) {
                                LastOne = TRUE;
                                Len = ObjectLen/2; // wcslen(pStart); from begining
                            } else {
                                Len = (DWORD)(pTemp - ObjectName);  // pStart; from begining
                                if ( *(pTemp+1) == L'\0' )
                                    LastOne = TRUE;
                                else
                                    LastOne = FALSE;
                            }
                            SDsize = (DWORD)(pStart - ObjectName);
                        } else {
                            if ( pTemp == NULL ) {
                                rc = SCESTATUS_INVALID_PARAMETER;
                                break;
                            } else
                                pStart = pTemp + 1;
                        }
                    }

                    if ( rc == SCESTATUS_SUCCESS && Len > SDsize ) {

                        Buffer1 = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Len+1)*sizeof(WCHAR));

                        if ( Buffer1 == NULL )
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        else {
                            // wcsncpy(Buffer1, pStart, Len );
                            wcsncpy(Buffer1, ObjectName, Len);

                            Count = 1;

                            if ( LastOne ) {

                                Count = 0;

                                Status = *((BYTE *)Value);
                                IsContainer = *((CHAR *)Value+1) != '0' ? TRUE : FALSE;

                            } else {
                                IsContainer = TRUE;

                                if ( ProfileType == SCE_ENGINE_SAP )
                                    Status = SCE_STATUS_GOOD;
                                else
                                    Status = SCE_STATUS_CHECK;
                            }

                        }
                    }

                    if ( rc != SCESTATUS_SUCCESS ) {
                        ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                             Errlog,
                                             SCEERR_PROCESS_OBJECT,
                                             ObjectName
                                           );
                    } else if ( Buffer1 != NULL) {
                        //
                        // check to see if Buffer1 is already in the list
                        //

                        i=0;  // temp. use of i for skip flag
                        if ( pArrObject && LastIndex >= 0 && LastIndex < (LONG)arrCount ) {

                            if ( ScepSearchItemInChildren(Buffer1+SDsize,
                                                          Len-SDsize,
                                                          pArrObject,
                                                          arrCount,
                                                          &FindIndex
                                                          )
                                                       ) {

                                //
                                // Buffer1 is already in the list, skip the block
                                // use pStart temporarily
                                //

                                pStart = (PWSTR)ScepAlloc(0, (Len+2)*sizeof(WCHAR));
                                if ( pStart == NULL ) {
                                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                                } else {
                                    //
                                    // skip the block
                                    //

                                    wcscpy(pStart, Buffer1);
                                    pStart[Len] = (WCHAR) ( Delim+1);
                                    pStart[Len+1] = L'\0';

                                    rc = SceJetSeek(
                                            hSection,
                                            pStart,
                                            (Len+1)*sizeof(TCHAR),
                                            SCEJET_SEEK_GE_DONT_CARE  //cannot use GT cause it will skip the section
                                            );

                                    ScepFree(pStart);
                                    pStart = NULL;

                                    i=1;
                                    LastIndex = FindIndex;
                                }
                            }
                        }

                        if ( 0 == i && SCESTATUS_SUCCESS == rc ) {

                            //
                            // get count
                            //
                            pStart = (PWSTR)ScepAlloc(0, (Len+2)*sizeof(WCHAR));
                            if ( pStart == NULL ) {
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                            } else {

                                wcscpy(pStart, Buffer1);
                                pStart[Len] = Delim;
                                pStart[Len+1] = L'\0';

                                rc = SceJetGetLineCount(
                                                hSection,
                                                pStart,
                                                FALSE,
                                                &Count);

                                if ( rc == SCESTATUS_SUCCESS  ||
                                     rc == SCESTATUS_RECORD_NOT_FOUND ) {

                                    if ( !IsContainer && Count > 0 ) {
                                        IsContainer = TRUE;
                                    }

                                    //
                                    // make buffer1 approprate case
                                    //
                                    switch (Area) {
                                    case AREA_REGISTRY_SECURITY:
                                        rc = ScepGetRegKeyCase(Buffer1, SDsize, Len-SDsize);
                                        break;
                                    case AREA_FILE_SECURITY:
                                        rc = ScepGetFileCase(Buffer1, SDsize, Len-SDsize);
                                        break;
                                    case AREA_DS_OBJECTS:
                                        //
                                        // need convert name first from o=,dc=,cn= to cn=,dc=,o=
                                        //
                                        pTemp=NULL;
                                        rc = ScepConvertJetNameToLdapCase(
                                                         Buffer1,
                                                         TRUE,  // Last component only
                                                         SCE_CASE_PREFERED, // right case
                                                         &pTemp
                                                         );

                                        if ( rc != ERROR_FILE_NOT_FOUND && pTemp != NULL ) {

                                            rc = ScepAddItemToChildren(NULL,
                                                                       pTemp,
                                                                      wcslen(pTemp),
                                                                      IsContainer,
                                                                      Status,
                                                                      Count,
                                                                      &pArrObject,
                                                                      &arrCount,
                                                                      &MaxCount,
                                                                      &FindIndex
                                                                      );

                                            if ( rc != ERROR_SUCCESS ) {
                                                ScepBuildErrorLogInfo( rc,
                                                                 Errlog,
                                                                 SCEERR_ADD,
                                                                 pTemp
                                                               );
                                            } else {
                                                LastIndex = FindIndex;
                                            }

                                            ScepFree(pTemp);
                                            pTemp = NULL;
                                        }
                                        rc = ScepDosErrorToSceStatus(rc);

                                        break;
                                    }
/*
                                    if ( rc == SCESTATUS_PROFILE_NOT_FOUND ) {
                                        //
                                        // if the object does not exist, do not add
                                        //
                                        rc = SCESTATUS_SUCCESS;

                                    } else if ( Area != AREA_DS_OBJECTS ) {
*/
                                    if ( rc != SCESTATUS_PROFILE_NOT_FOUND &&
                                         Area != AREA_DS_OBJECTS ) {

                                        rc = ScepAddItemToChildren(NULL,
                                                                   Buffer1+SDsize,
                                                                  Len-SDsize,
                                                                  IsContainer,
                                                                  Status,
                                                                  Count,
                                                                  &pArrObject,
                                                                  &arrCount,
                                                                  &MaxCount,
                                                                  &FindIndex
                                                                  );

                                        if ( rc != ERROR_SUCCESS ) {
                                            ScepBuildErrorLogInfo( rc,
                                                             Errlog,
                                                             SCEERR_ADD,
                                                             Buffer1
                                                           );
                                            rc = ScepDosErrorToSceStatus(rc);
                                        } else {
                                            LastIndex = FindIndex;
                                        }
                                    }
                                }

                                if ( rc == SCESTATUS_SUCCESS ) {
                                    //
                                    // seek to the original one
                                    //
        //                            Buffer1[Len-1] = (WCHAR) (Buffer1[Len-1] + 1);
                                    rc = SceJetSeek(
                                            hSection,
                                            Buffer1,
                                            Len*sizeof(TCHAR),
                                            SCEJET_SEEK_GE_NO_CASE
                                            );
                                    //
                                    // should be success, move to next line
                                    //
                                    rc = SceJetMoveNext(hSection);

                                } else if ( rc == SCESTATUS_PROFILE_NOT_FOUND ) {

                                    pStart[Len] = (WCHAR) ( Delim+1);
                                    pStart[Len+1] = L'\0';

                                    rc = SceJetSeek(
                                            hSection,
                                            pStart,
                                            (Len+1)*sizeof(TCHAR),
                                            SCEJET_SEEK_GE_DONT_CARE  //cannot use GT cause it will skip the section
                                            );

                                }

                                ScepFree(pStart);
                                pStart = NULL;

                            }
                        }

                        ScepFree(Buffer1);
                        Buffer1 = NULL;

                    } else
                        rc = SceJetMoveNext(hSection);
                }
                FindFlag = SCEJET_CURRENT;
            }

            ScepFree(ObjectName);
            ObjectName = NULL;

            ScepFree(Value);
            Value = NULL;

            if ( rc != SCESTATUS_SUCCESS )
                break;

            //
            // read next line
            //
            rc = SceJetGetValue(
                        hSection,
                        FindFlag,
                        NULL,
                        NULL,
                        0,
                        &SDsize,  // temp use for ObjectLen
                        NULL,
                        0,
                        &i        // temp use for ValueLen
                        );
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
            rc = SCESTATUS_SUCCESS;

    }

Done:

    if ( Area == AREA_DS_OBJECTS ) {

        if ( Area == AREA_DS_OBJECTS ) {
            if ( JetName != NULL )
                ScepFree(JetName);
        }

        ScepLdapClose(NULL);
    }

    if ( Option != SCE_ALL_CHILDREN ) {
        ScepFree(NewPrefix);
    }

    if ( Buffer1 != NULL )
        ScepFree(Buffer1);

    if ( ObjectName != NULL )
        ScepFree(ObjectName);

    if ( Value != NULL )
        ScepFree(Value);

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    SceJetCloseSection( &hSection, TRUE);

    if ( ( rc == SCESTATUS_SUCCESS ) &&
         ( Option != SCE_ALL_CHILDREN ) ) {

        if ( pArrObject ) {
            *Buffer = (PVOID)((PBYTE)pArrObject-sizeof(DWORD)*2);

            ((PSCE_OBJECT_CHILDREN)(*Buffer))->nCount = arrCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->MaxCount = MaxCount;
        } else {
            *Buffer = NULL;
        }
/*
        *Buffer = ScepAlloc(0, sizeof(SCE_OBJECT_CHILDREN));

        if ( *Buffer ) {

            ((PSCE_OBJECT_CHILDREN)(*Buffer))->nCount = arrCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->MaxCount = MaxCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->arrObject = pArrObject;

        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
*/
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // free (PVOID *)Buffer
        //
        if ( Option == SCE_ALL_CHILDREN ) {
            // OBJECT_CHILD_LIST structure
            ScepFreeObject2Security((PSCE_OBJECT_CHILD_LIST)(*Buffer), FALSE);
        } else if ( pArrObject ) {
            // OBJECT_CHILDREN structure
            ScepFreeObjectChildren((PSCE_OBJECT_CHILDREN)((PBYTE)pArrObject-sizeof(DWORD)*2));
        }
        *Buffer = NULL;

    }

    return(rc);
}


SCESTATUS
ScepBuildDsTree(
    OUT PSCE_OBJECT_CHILD_LIST *TreeRoot,
    IN ULONG Level,
    IN WCHAR Delim,
    IN PCWSTR ObjectFullName
    )
{
    TCHAR                   Buffer[MAX_PATH];
    BOOL                    LastOne=FALSE;
    SCESTATUS                rc;

    if ( TreeRoot == NULL || ObjectFullName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    memset(Buffer, '\0', MAX_PATH*sizeof(TCHAR));

    rc = ScepGetNameInLevel(ObjectFullName,
                           Level,
                           Delim,
                           Buffer,
                           &LastOne);

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    *TreeRoot = (PSCE_OBJECT_CHILD_LIST)ScepAlloc(LPTR, sizeof(SCE_OBJECT_CHILD_LIST));
    if ( *TreeRoot == NULL )
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    PSCE_OBJECT_TREE Node;

    //
    // allocate buffer for the node
    //
    Node = (PSCE_OBJECT_TREE)ScepAlloc((UINT)0, sizeof(SCE_OBJECT_TREE));
    if ( Node == NULL ) {
        ScepFree(*TreeRoot);
        *TreeRoot = NULL;
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    //
    // allocate buffer for the object name
    //
    Node->Name = (PWSTR)ScepAlloc((UINT)0,
                                       (wcslen(Buffer)+1) * sizeof(TCHAR));
    if ( Node->Name != NULL ) {

        Node->ObjectFullName = (PWSTR)ScepAlloc( 0, (wcslen(ObjectFullName)+1)*sizeof(TCHAR));

        if ( Node->ObjectFullName != NULL ) {
            //
            // initialize
            //
            wcscpy(Node->Name, Buffer);
            wcscpy(Node->ObjectFullName, ObjectFullName);

            Node->ChildList = NULL;
            Node->Parent = NULL;
            Node->pApplySecurityDescriptor = NULL;

            Node->pSecurityDescriptor = NULL;
            Node->SeInfo = 0;
            Node->IsContainer = TRUE;
            Node->Status = SCE_STATUS_CHECK;

            (*TreeRoot)->Node = Node;

        } else {

            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            ScepFree( Node->Name );
            ScepFree( Node );
            ScepFree( *TreeRoot );
            *TreeRoot = NULL;
        }
    } else {
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        ScepFree( Node );
        ScepFree( *TreeRoot );
        *TreeRoot = NULL;
    }

    return(rc);

}


SCESTATUS
ScepGetObjectSecurity(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    OUT PSCE_OBJECT_SECURITY *ObjSecurity
    )
/*
    Get security for a single object
*/
{
    SCESTATUS        rc;
    PCWSTR          SectionName=NULL;
    PSCESECTION      hSection=NULL;
    PWSTR           Value=NULL;
    DWORD           ValueLen;
    PSECURITY_DESCRIPTOR pTempSD=NULL;
    SECURITY_INFORMATION SeInfo;
    DWORD           SDsize, Win32Rc;


    if ( hProfile == NULL || ObjectName == NULL ||
         ObjSecurity == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    switch (Area) {
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        break;
    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        break;
#if 0
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        break;
#endif
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = ScepOpenSectionForName(
                hProfile,
                ProfileType,
                SectionName,
                &hSection
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = SceJetGetValue(
            hSection,
            SCEJET_EXACT_MATCH_NO_CASE,
            ObjectName,
            NULL,
            0,
            NULL,
            NULL,
            0,
            &ValueLen
            );

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // allocate memory for value string
            //
            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

            if ( Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;

            }
            //
            // Get the value
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        Value,
                        ValueLen,
                        &ValueLen
                        );

            if ( rc == SCESTATUS_SUCCESS ) {

                //
                // convert security descriptor
                //

                Win32Rc = ConvertTextSecurityDescriptor(
                                   Value+1,
                                   &pTempSD,
                                   &SDsize,
                                   &SeInfo
                                   );
                if ( Win32Rc == NO_ERROR ) {

                    if ( Area != AREA_DS_OBJECTS ) {
                        ScepChangeAclRevision(pTempSD, ACL_REVISION);
                    }
                    //
                    // allocate output buffer (SCE_OBJECT_SECURITY)
                    //
                    *ObjSecurity = (PSCE_OBJECT_SECURITY)ScepAlloc(0, sizeof(SCE_OBJECT_SECURITY));
                    if ( *ObjSecurity == NULL ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        goto Done;
                    }
                    (*ObjSecurity)->Name = (PWSTR)ScepAlloc(0, (wcslen(ObjectName)+1)*sizeof(TCHAR));
                    if ( (*ObjSecurity)->Name == NULL ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        ScepFree(*ObjSecurity);
                        *ObjSecurity = NULL;
                        goto Done;
                    }
/*
                    (*ObjSecurity)->SDspec = (PWSTR)ScepAlloc(0, ValueLen);
                    if ( (*ObjSecurity)->SDspec == NULL ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        ScepFree((*ObjSecurity)->Name);
                        ScepFree(*ObjSecurity);
                        *ObjSecurity = NULL;
                        goto Done;
                    }
*/
                    //
                    // build the structure
                    //
                    (*ObjSecurity)->Status = *((BYTE *)Value);
                    (*ObjSecurity)->IsContainer = *((CHAR *)Value+1) != '0' ? TRUE : FALSE;

                    wcscpy( (*ObjSecurity)->Name, ObjectName);
                    (*ObjSecurity)->pSecurityDescriptor = pTempSD;
                    pTempSD = NULL;
                    (*ObjSecurity)->SeInfo = SeInfo;
//                    wcscpy( (*ObjSecurity)->SDspec, Value+1);
//                    (*ObjSecurity)->SDsize = ValueLen/2-1;

                } else
                    rc = ScepDosErrorToSceStatus(Win32Rc);
            }

        }
    }

Done:

    SceJetCloseSection( &hSection, TRUE);

    if ( pTempSD )
        ScepFree(pTempSD);
    if ( Value )
        ScepFree(Value);

    return(rc);
}


SCESTATUS
ScepGetSystemServices(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    OUT PSCE_SERVICES *pServiceList,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*
Routine Description:

    Read all services defined in the Jet table into the service list

Arguments:

    hProfile - the jet profile handle

    ProfileType - The table to read from
                      SCE_ENGINE_SCP
                      SCE_ENGINE_SAP
                      SCE_ENGINE_SMP

    pServiceList - The service list to output

    Errlog - the error messages to output

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS error codes

*/
{
    SCESTATUS rc;
    DWORD   Win32Rc;
    PSCESECTION hSection=NULL;
    DWORD   ServiceLen=0, ValueLen=0;
    PWSTR   ServiceName=NULL,
            Value=NULL;
    PSECURITY_DESCRIPTOR pTempSD=NULL;
    SECURITY_INFORMATION SeInfo;
    DWORD   SDsize;
    PSCE_SERVICES  ServiceNode;
    PSCE_SERVICES  pServices=NULL, pNode, pParent;


    if ( hProfile == NULL ||
         pServiceList == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }
    //
    // open the section
    //
    rc = ScepOpenSectionForName(
                hProfile,
                ProfileType,
                szServiceGeneral,
                &hSection
                );

    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog,
                             SCEERR_OPEN,
                             szServiceGeneral
                           );
        return(rc);
    }

    //
    // enumerate all service names from the system.
    // do not care the error code
    //
    SceEnumerateServices(&pServices, TRUE);

    //
    // goto the first line of this section
    //
    rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH,
                NULL,
                NULL,
                0,
                &ServiceLen,
                NULL,
                0,
                &ValueLen
                );
    while ( rc == SCESTATUS_SUCCESS ) {

        //
        // allocate memory for the service name and value string
        //
        ServiceName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ServiceLen+2);
        if ( ServiceName != NULL ) {

            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);
            if ( Value != NULL ) {
                //
                // Get the service and its value
                //
                rc = SceJetGetValue(
                            hSection,
                            SCEJET_CURRENT,
                            NULL,
                            ServiceName,
                            ServiceLen,
                            &ServiceLen,
                            Value,
                            ValueLen,
                            &ValueLen
                            );
                if ( rc == SCESTATUS_SUCCESS ) {

                    ServiceName[ServiceLen/2] = L'\0';
                    Value[ValueLen/2] = L'\0';

#ifdef SCE_DBG
    wprintf(L"rc=%d, service: %s=%s\n", rc, ServiceName, Value);
#endif
                    //
                    // convert to security descriptor
                    //
                    Win32Rc = ConvertTextSecurityDescriptor(
                                       Value+1,
                                       &pTempSD,
                                       &SDsize,
                                       &SeInfo
                                       );
                    if ( Win32Rc == NO_ERROR ) {

                        ScepChangeAclRevision(pTempSD, ACL_REVISION);
                        //
                        // create this service node
                        //
                        ServiceNode = (PSCE_SERVICES)ScepAlloc( LMEM_FIXED, sizeof(SCE_SERVICES) );

                        if ( ServiceNode != NULL ) {
                            //
                            // find the right name for the service
                            //
                            for ( pNode=pServices, pParent=NULL; pNode != NULL;
                                  pParent=pNode, pNode=pNode->Next ) {

                                if ( _wcsicmp(pNode->ServiceName, ServiceName) == 0 ) {
                                    break;
                                }
                            }
                            if ( pNode != NULL ) {
                                //
                                // got it
                                //
                                ServiceNode->ServiceName = pNode->ServiceName;
                                ServiceNode->DisplayName = pNode->DisplayName;
                                //
                                // free the node
                                //
                                if ( pParent != NULL ) {
                                    pParent->Next = pNode->Next;
                                } else {
                                    pServices = pNode->Next;
                                }
                                // General is NULL becuase the enumerate call asks only for names
                                ScepFree(pNode);
                                pNode = NULL;

                            } else {
                                //
                                // did not find it
                                //
                                ServiceNode->ServiceName = ServiceName;
                                ServiceNode->DisplayName = NULL;

                                ServiceName = NULL;
                            }

                            ServiceNode->Status = *((BYTE *)Value);
                            ServiceNode->Startup = *((BYTE *)Value+1);
                            ServiceNode->General.pSecurityDescriptor = pTempSD;
                            ServiceNode->SeInfo = SeInfo;
                            ServiceNode->Next = *pServiceList;

                            *pServiceList = ServiceNode;

                            //
                            // DO NOT free the following buffers
                            //
                            pTempSD = NULL;

                        } else {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            ScepFree(pTempSD);
                        }

                    } else {
                        ScepBuildErrorLogInfo( Win32Rc,
                                             Errlog,
                                             SCEERR_BUILD_SD,
                                             ServiceName
                                           );
                        rc = ScepDosErrorToSceStatus(Win32Rc);
                    }
                }
                ScepFree(Value);

            } else
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

            //
            // ServiceName could be used in the service node
            //
            if ( ServiceName )
                ScepFree(ServiceName);

        } else
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // read next line
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_NEXT_LINE,
                        NULL,
                        NULL,
                        0,
                        &ServiceLen,
                        NULL,
                        0,
                        &ValueLen
                        );
        }
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    //
    // close the section
    //
    SceJetCloseSection( &hSection, TRUE );

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // free the service list
        //
        SceFreePSCE_SERVICES(*pServiceList);
        *pServiceList = NULL;
    }

    SceFreePSCE_SERVICES(pServices);

    return(rc);
}



SCESTATUS
ScepCopyObjects(
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    IN PWSTR InfFile,
    IN PCWSTR SectionName,
    IN AREA_INFORMATION Area,
    IN OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

    This routine copies registry/file/ds/service object in SMP table to the specified
    inf template.

Arguments:

    hProfile    - The handle to the profile

    InfFile     - The INF template name

    SectionName - the section name where data is stored

    Area        - The security area to read info
                    AREA_REGISTRY_SECURITY
                    AREA_FILE_SECURITY
                    AREA_DS_OBJECTS

    Errlog      - The error log buffer.

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_PROFILE_NOT_FOUND
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_BAD_FORMAT
    SCESTATUS_INVALID_DATA
-- */
{
    SCESTATUS       rc = SCESTATUS_SUCCESS;
    PSCESECTION      hSection=NULL;

    PWSTR           ObjectName=NULL;
    PWSTR           Value=NULL;
    DWORD           ObjectLen, ValueLen;

    BYTE            Status;
    PWSTR           NewValue=NULL;

    DWORD           Count=0;
    WCHAR           KeyName[10];


    if ( InfFile == NULL || hProfile == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // open the section
    //
    rc = ScepOpenSectionForName(
                hProfile,
                ProfileType,
                SectionName,
                &hSection
                );

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // empty the section first.
        //
        WritePrivateProfileSection(
                            SectionName,
                            NULL,
                            (LPCTSTR)InfFile);
        //
        // find the first record in the section
        //
        rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH,
                NULL,
                NULL,
                0,
                &ObjectLen,
                NULL,
                0,
                &ValueLen
                );

        while ( rc == SCESTATUS_SUCCESS ) {

            Count++;
            //
            // allocate memory for the group name and value string
            //


            ObjectName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ObjectLen+2);
            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

            if ( ObjectName == NULL || Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;

            }
            //
            // Get the group and its value
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        ObjectName,
                        ObjectLen,
                        &ObjectLen,
                        Value,
                        ValueLen,
                        &ValueLen
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                     Errlog,
                                     SCEERR_QUERY_VALUE,
                                     SectionName
                                   );
                goto Done;
            }


#ifdef SCE_DBG
            wprintf(L"Addr: %x %x, %s=%s\n", ObjectName, Value, ObjectName, Value+1);
#endif

            if ( Area == AREA_SYSTEM_SERVICE )
                Status = *((BYTE *)Value+1);
            else
                Status = *((BYTE *)Value);
        
            if (0 == _wcsicmp(SectionName, szRegistryKeys) &&
                Status != 1 &&
                0 == _wcsnicmp(L"machine\\system\\controlset",
                       ObjectName,
                       wcslen(L"machine\\system\\controlset"))) {
                
                ObjectName = ScepSpecialCaseRegkeyCcs( ObjectName );

                if ( ObjectName == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    goto Done;
                }
            }

            NewValue = (PWSTR)ScepAlloc(0, ObjectLen+ValueLen+40);

            if ( NewValue == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }

            //
            // to represent "not configured"
            //      0 is used in the database 
            //      "" is used in the inf template 
            // so just generate "" instead of "0"
            //

            if ( Area == AREA_SYSTEM_SERVICE && Status == 0 ){
                swprintf(NewValue, L"\"%s\",, \"%s\"\0", ObjectName, Value+1);
            }
            else {
                swprintf(NewValue, L"\"%s\", %d, \"%s\"\0", ObjectName, Status, Value+1);
            }
            swprintf(KeyName, L"%x\0", Count);

            //
            // write this line to the inf file
            //
            if ( !WritePrivateProfileString(
                            SectionName,
                            KeyName,
                            NewValue,
                            InfFile
                            ) ) {
                ScepBuildErrorLogInfo( GetLastError(),
                                     Errlog,
                                     SCEERR_WRITE_INFO,
                                     ObjectName
                                   );
                rc = ScepDosErrorToSceStatus(GetLastError());
            }

            ScepFree(ObjectName);
            ObjectName = NULL;

            ScepFree(Value);
            Value = NULL;

            ScepFree(NewValue);
            NewValue = NULL;

            if ( rc != SCESTATUS_SUCCESS )
                break;

            //
            // read next line
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_NEXT_LINE,
                        NULL,
                        NULL,
                        0,
                        &ObjectLen,
                        NULL,
                        0,
                        &ValueLen
                        );
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
            rc = SCESTATUS_SUCCESS;

    } else
        ScepBuildErrorLogInfo( ERROR_INVALID_HANDLE,
                             Errlog,
                             SCEERR_OPEN,
                             SectionName
                           );

Done:

    if ( ObjectName != NULL )
        ScepFree(ObjectName);

    if ( Value != NULL )
        ScepFree(Value);

    if ( NewValue != NULL )
        ScepFree(NewValue);
    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    SceJetCloseSection( &hSection, TRUE);

    return(rc);
}

PWSTR
ScepSpecialCaseRegkeyCcs(
    IN OUT  PWSTR    ObjectName
    )
/* ++
Routine Description:
            
    When Status != 1 convert all currentcontrolsetxxx's to currentcontrolset

Arguments:

    ObjectName  -   name of registry key to modify

Return Value:

    none

-- */
{
    PWSTR   pszNewObjectName = NULL;
    DWORD dwCcsLen = wcslen(L"machine\\system\\controlset");

    if (0 == _wcsnicmp(L"machine\\system\\controlset",
                       ObjectName,
                       dwCcsLen)) {

        pszNewObjectName = (PWSTR)ScepAlloc(0, 
                                            (wcslen(ObjectName) + wcslen(L"current") + 3) * sizeof(WCHAR));

        if (NULL == pszNewObjectName) {
            goto Done;
        }

        pszNewObjectName[0] = L'\0';

        wcscat(pszNewObjectName, L"machine\\system\\currentcontrolset");

        wchar_t *pSlash = NULL; 

        pSlash = wcsstr(ObjectName + dwCcsLen, L"\\");
        
        if (pSlash != NULL) {
            wcscat(pszNewObjectName, pSlash);
        }

    }

Done:

    ScepFree(ObjectName);
  
    return pszNewObjectName;

}



SCESTATUS
ScepGetAnalysisSummary(
    IN PSCECONTEXT Context,
    IN AREA_INFORMATION Area,
    OUT PDWORD pCount
    )
{
    SCESTATUS        rc=SCESTATUS_INVALID_PARAMETER;
    DWORD           count;
    DWORD           total=0;
    PSCESECTION      hSection=NULL;

    if ( Context == NULL || pCount == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    *pCount = 0;

    if ( Area & AREA_SECURITY_POLICY ) {
        //
        // system access
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szSystemAccess,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;

        //
        // System Log
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szAuditSystemLog,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
        //
        // Security Log
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szAuditSecurityLog,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
        //
        // Application Log
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szAuditApplicationLog,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
        //
        // Event Audit
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szAuditEvent,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }

    if ( Area & AREA_PRIVILEGES ) {
        //
        // Privileges
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szPrivilegeRights,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }

    if ( Area & AREA_GROUP_MEMBERSHIP) {
        //
        // Group Membership
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szGroupMembership,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }

    if ( Area & AREA_SYSTEM_SERVICE ) {
        //
        // system service
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szServiceGeneral,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }

    if ( Area & AREA_REGISTRY_SECURITY ) {
        //
        // Registry security
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szRegistryKeys,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }
    if ( Area & AREA_FILE_SECURITY ) {
        //
        // File Security
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szFileSecurity,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }

#if 0
#if _WIN32_WINNT>=0x0500
    if ( Area & AREA_DS_OBJECTS &&
         RtlGetNtProductType(&theType) ) {

        if ( theType == NtProductLanManNt ) {
            //
            // DS object security
            //
            rc = ScepOpenSectionForName(
                        Context,
                        SCE_ENGINE_SAP,
                        szDSSecurity,
                        &hSection
                        );
            if ( rc == SCESTATUS_SUCCESS ) {
                rc = SceJetGetLineCount(
                            hSection,
                            NULL,
                            FALSE,
                            &count
                            );
            }
            SceJetCloseSection( &hSection, TRUE);

            if ( rc != SCESTATUS_SUCCESS )
                return(rc);

            total += count;
        }
    }
#endif
#endif

    *pCount = total;

    return(rc);
}


SCESTATUS
ScepBrowseTableSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN PCWSTR SectionName,
    IN DWORD Options
    )
{
    SCESTATUS rc;
    PSCESECTION hSection=NULL;

    SceClientBrowseCallback(
            0,
            (PWSTR)SectionName,
            NULL,
            NULL
            );

    rc = ScepOpenSectionForName(
            hProfile,
            ProfileType,
            SectionName,
            &hSection
            );

    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }

    JET_ERR       JetErr;

    //
    // goto the first line of this section
    //
    DWORD KeyLen, ValueLen, Actual;
    LONG GpoID=0;
    PWSTR KeyName=NULL;
    PWSTR Value=NULL;
    TCHAR GpoName[MAX_PATH];

    SCE_BROWSE_CALLBACK_VALUE  ValBuf;
    ValBuf.Len = 0;
    ValBuf.Value = NULL;

    rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH,
                NULL,
                NULL,
                0,
                &KeyLen,
                NULL,
                0,
                &ValueLen
                );

    while ( rc == SCESTATUS_SUCCESS ) {

        //
        // get GPO ID field from the current line
        //
        GpoID = 0;

        if ( hSection->JetColumnGpoID > 0 ) {

            JetErr = JetRetrieveColumn(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            hSection->JetColumnGpoID,
                            (void *)&GpoID,
                            4,
                            &Actual,
                            0,
                            NULL
                            );
        }


        if ( (Options & SCEBROWSE_DOMAIN_POLICY) &&
             (GpoID <= 0) ) {
            //
            // do not need this line, continue to next line
            //
        } else {

            KeyName = (PWSTR)ScepAlloc(LMEM_ZEROINIT, KeyLen+2);

            //
            // allocate memory for the group name and value string
            //
            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

            if ( KeyName == NULL || Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;

            }

            //
            // Get the key and value
            //
            DWORD NewKeyLen, NewValueLen;

            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        KeyName,
                        KeyLen,
                        &NewKeyLen,
                        Value,
                        ValueLen,
                        &NewValueLen
                        );

            if ( rc != SCESTATUS_SUCCESS )
                goto Done;

            //
            // terminate the string
            //
            KeyName[KeyLen/2] = L'\0';

            Value[ValueLen/2] = L'\0';

            GpoName[0] = L'\0';

            if ( hSection->JetColumnGpoID > 0 && GpoID > 0 ) {

                Actual = MAX_PATH;
                SceJetGetGpoNameByID(
                            hProfile,
                            GpoID,
                            GpoName,
                            &Actual,
                            NULL,
                            NULL
                            );
            }

            if ( Value && Value[0] != L'\0' &&
                 ( Options & SCEBROWSE_MULTI_SZ) ) {
                     
                if (0 == _wcsicmp( KeyName, szLegalNoticeTextKeyName) ) {

                    //
                    // check for commas and escape them with "," 
                    // k=7,a",",b,c
                    // pValueStr will be a,\0b\0c\0\0 which we should make
                    // a","\0b\0c\0\0
                    //

                    DWORD dwCommaCount = 0;

                    for ( DWORD dwIndex = 1; dwIndex < ValueLen/2 ; dwIndex++) {
                        if ( Value[dwIndex] == L',' )
                            dwCommaCount++;
                    }

                    if ( dwCommaCount > 0 ) {

                        //
                        // in this case we have to escape commas
                        //

                        PWSTR   pszValueEscaped;
                        DWORD   dwBytes = (ValueLen/2 + 1 + (dwCommaCount*2))*sizeof(WCHAR);

                        pszValueEscaped = (PWSTR)ScepAlloc(LMEM_ZEROINIT, dwBytes);

                        if (pszValueEscaped) {

                            memset(pszValueEscaped, '\0', dwBytes);
                            ValueLen = 2 * ScepEscapeString(Value,
                                                        ValueLen/2,
                                                        L',',
                                                        L'"',
                                                        pszValueEscaped
                                                       );

                            ScepFree(Value);
                            
                            Value = pszValueEscaped;

                        } else {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            goto Done;
                        }
                    }
                }
                                
                ScepConvertMultiSzToDelim(Value+1, ValueLen/2-1, L'\0', L',');

            }

            __try {

                ValBuf.Len = Value ? (ValueLen+2) : 0 ;
                ValBuf.Value = (UCHAR *)Value;

                SceClientBrowseCallback(
                        GpoID,
                        KeyName,
                        GpoName,
                        (SCEPR_SR_SECURITY_DESCRIPTOR *)&ValBuf
                        );
            } __except(EXCEPTION_EXECUTE_HANDLER) {

            }

            ScepFree(Value);
            Value = NULL;

            ScepFree(KeyName);
            KeyName = NULL;
        }

        //
        // read next line
        //

        rc = SceJetGetValue(
                    hSection,
                    SCEJET_NEXT_LINE,
                    NULL,
                    NULL,
                    0,
                    &KeyLen,
                    NULL,
                    0,
                    &ValueLen
                    );
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

Done:

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    if ( Value != NULL )
        ScepFree(Value);

    if ( KeyName != NULL )
        ScepFree(KeyName);

    //
    // close the section
    //
    SceJetCloseSection( &hSection, TRUE );

    return(rc);
}


BOOL
ScepSearchItemInChildren(
    IN PWSTR ItemName,
    IN DWORD NameLen,
    IN PSCE_OBJECT_CHILDREN_NODE *pArrObject,
    IN DWORD arrCount,
    OUT LONG *pFindIndex
    )
/*
Routine Description:

    Search the item name in the array specified. If found, the index to the
    array is returned in pFindIndex.

Return Value:

    TRUE    - find it
    FALSE   - doesn't find it
*/
{
    if ( pFindIndex == NULL ) {
        return(FALSE);
    }

    //
    // note pFindIndex stores the closest node, not necessary mean
    // the index is the match.
    //
    *pFindIndex = -1;

    if ( ItemName == NULL ||
         pArrObject == NULL ||
         arrCount == 0 ) {
        return(FALSE);
    }

    DWORD idxStart=0;
    DWORD idxEnd=arrCount-1;

    DWORD theIndex;
    INT CompFlag=-1;

    do {

        //
        // choose the middle
        //
        theIndex = (idxStart + idxEnd)/2;

        if ( pArrObject[theIndex] == NULL ||
             pArrObject[theIndex]->Name == NULL ) {
            //
            // this is a bad node, check the start node
            //
            while ( (pArrObject[idxStart] == NULL ||
                     pArrObject[idxStart]->Name == NULL) &&
                    idxStart <= idxEnd ) {

                idxStart++;
            }

            if ( idxStart <= idxEnd ) {

                //
                // check the start node
                //
                CompFlag = _wcsicmp(ItemName, pArrObject[idxStart]->Name);
                *pFindIndex = idxStart;

                if ( CompFlag == 0 ) {
                    // find it
                    break;

                } else if ( CompFlag < 0 ) {
                    //
                    // the item is less than idxStart - no match
                    //
                    break;

                } else {
                    //
                    // the item is between theStart and idxEnd
                    //
                    if ( idxStart == idxEnd ) {
                        // empty now. quit
                        break;
                    } else {
                        idxStart++;
                    }
                }
            }

        } else {

            CompFlag = _wcsicmp(ItemName, pArrObject[theIndex]->Name);
            *pFindIndex = theIndex;

            if ( CompFlag == 0 ) {
                // find it
                break;

            } else if ( CompFlag < 0 ) {
                //
                // the item is between index idxStart and theIndex
                //
                if ( theIndex == idxStart ) {
                    // empty now. quit
                    break;
                } else {
                    idxEnd = theIndex-1;
                }
            } else {
                //
                // the item is between theIndex and idxEnd
                //
                if ( theIndex == idxEnd ) {
                    // empty now. quit
                    break;
                } else {
                    idxStart = theIndex+1;
                }
            }

        }

    } while ( idxStart <= idxEnd );

    if ( CompFlag == 0 ) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


DWORD
ScepAddItemToChildren(
    IN PSCE_OBJECT_CHILDREN_NODE ThisNode OPTIONAL,
    IN PWSTR ItemName,
    IN DWORD NameLen,
    IN BOOL  IsContainer,
    IN BYTE  Status,
    IN DWORD ChildCount,
    IN OUT PSCE_OBJECT_CHILDREN_NODE **ppArrObject,
    IN OUT DWORD *pArrCount,
    IN OUT DWORD *pMaxCount,
    IN OUT LONG *pFindIndex
    )
/*
Routine Description:

    Add a node to the children array. If the node is allocated, the pointer
    will be added to the array; otherwise, a new allocation is made for the
    new node.

    The node's name will be first checked in the array for duplicate. If
    pFindIndex is specified (not -1), the index will be first used to locate
    the node. If the new node's name is found in the array, it won't be
    added.

Return Value:

    ERROR_DUP_NAME    duplicate node name is found, node is not added to the array
    ERROR_SUCCESS     succeed
    other errors
*/
{

    if ( ItemName == NULL ||
         ppArrObject == NULL ||
         pArrCount == NULL ||
         pMaxCount == NULL ||
         pFindIndex == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD rc=ERROR_SUCCESS;

    if ( *ppArrObject == NULL ||
         *pArrCount == 0 ) {

        *pArrCount = 0;
        *pMaxCount = 0;
        *pFindIndex = -1;

    } else if ( ( *pFindIndex < 0 ) ||
         ( *pFindIndex >= (LONG)(*pArrCount) ) ||
         ( (*ppArrObject)[*pFindIndex] == NULL ) ||
         ( (*ppArrObject)[*pFindIndex]->Name == NULL) ) {

        //
        // should search for the closest node
        //
        if ( ScepSearchItemInChildren(
                    ItemName,
                    NameLen,
                    *ppArrObject,
                    *pArrCount,
                    pFindIndex
                    ) ) {

            return(ERROR_DUP_NAME);
        }
    }

    INT CompFlag=-1;

    if ( *pFindIndex >= 0 ) {

        //
        // check if the closest node matches the new node
        //
        CompFlag = _wcsicmp( ItemName, (*ppArrObject)[*pFindIndex]->Name );

        if ( CompFlag == 0 ) {
            return(ERROR_DUP_NAME);
        }
    }

    PSCE_OBJECT_CHILDREN_NODE pNodeToAdd;

    if ( ThisNode == NULL ) {
        //
        // allocate a new node
        //
        pNodeToAdd = (PSCE_OBJECT_CHILDREN_NODE)ScepAlloc(0, sizeof(SCE_OBJECT_CHILDREN_NODE));

        if ( NameLen == 0 ) {
            NameLen = wcslen(ItemName);
        }

        if ( pNodeToAdd ) {
            pNodeToAdd->Name = (PWSTR)ScepAlloc(0, (NameLen+1)*sizeof(WCHAR));

            if ( pNodeToAdd->Name ) {
                wcscpy(pNodeToAdd->Name, ItemName);
                pNodeToAdd->IsContainer = IsContainer;
                pNodeToAdd->Status = Status;
                pNodeToAdd->Count = ChildCount;

            } else {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                ScepFree(pNodeToAdd);
                pNodeToAdd = NULL;
            }
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {

        pNodeToAdd = ThisNode;
    }

    if ( ERROR_SUCCESS == rc ) {

        LONG idxAdd, i;

        if ( *pFindIndex >= 0 ) {

            if ( CompFlag < 0 ) {
                //
                // add the new node before pFindIndex
                //
                idxAdd = *pFindIndex;

            } else {
                //
                // add the new node after pFindIndex
                //
                idxAdd = *pFindIndex+1;
            }

        } else {
            idxAdd = 0;
        }

        if ( *pArrCount >= *pMaxCount ) {
            //
            // there is not enough array nodes to hold the new node
            //
            PSCE_OBJECT_CHILDREN_NODE *pNewArray;
            PBYTE pTmpBuffer;

            pTmpBuffer = (PBYTE)ScepAlloc(0, 2*sizeof(DWORD)+(*pMaxCount+SCE_ALLOC_MAX_NODE)*sizeof(PSCE_OBJECT_CHILDREN_NODE));

            if ( pTmpBuffer == NULL ) {

                rc = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                //
                // need to shift two DWORDs for the array start
                //
                pNewArray = (PSCE_OBJECT_CHILDREN_NODE *)(pTmpBuffer + 2*sizeof(DWORD));

                LONG idxStart1, idxEnd1, idxStart2, idxEnd2;

                if ( *pFindIndex >= 0 ) {

                    if ( CompFlag < 0 ) {
                        //
                        // add the new node before pFindIndex
                        //
                        idxEnd1 = *pFindIndex-1;
                        idxStart2 = *pFindIndex;

                    } else {
                        //
                        // add the new node after pFindIndex
                        //

                        idxEnd1 = *pFindIndex;
                        idxStart2 = *pFindIndex+1;
                    }

                    idxStart1 = 0;
                    idxEnd2 = *pArrCount-1;

                } else {
                    idxStart1 = -1;
                    idxEnd1 = -1;
                    idxStart2 = 0;
                    idxEnd2 = *pArrCount-1;
                }

                //
                // make the copy
                //
                LONG j=0;
                for ( i=idxStart1; i<=idxEnd1 && i>=0; i++ ) {
                    pNewArray[j++] = (*ppArrObject)[i];
                }

                pNewArray[idxAdd] = pNodeToAdd;
                j = idxAdd+1;

                for ( i=idxStart2; i<=idxEnd2 && i>=0; i++ ) {
                    pNewArray[j++] = (*ppArrObject)[i];
                }

                (*pMaxCount) += SCE_ALLOC_MAX_NODE;
                (*pArrCount)++;

                //
                // free the old list
                //
                if ( *ppArrObject ) {
                    ScepFree((PBYTE)(*ppArrObject)-2*sizeof(DWORD));
                }
                *ppArrObject = pNewArray;

                *pFindIndex = idxAdd;

            }

        } else {
            //
            // the buffer is big enough, just add the node to the buffer
            //

            //
            // make the copy
            //
            for ( i=*pArrCount-1; i>=idxAdd && i>=0; i-- ) {
                (*ppArrObject)[i+1] = (*ppArrObject)[i];
            }

            (*ppArrObject)[idxAdd] = pNodeToAdd;

            (*pArrCount)++;

            *pFindIndex = idxAdd;
        }
    }

    //
    // release memory if it fails
    //
    if ( ERROR_SUCCESS != rc &&
         pNodeToAdd &&
         pNodeToAdd != ThisNode ) {

        ScepFree(pNodeToAdd->Name);
        ScepFree(pNodeToAdd);
    }

    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\misc.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    misc.cpp

Abstract:

    SCE Engine miscellaneous APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997 created

--*/
#include "headers.h"
#include "serverp.h"
#include <ntregapi.h>
#include <userenv.h>
#include <ntlsa.h>
#include <io.h>
#pragma hdrstop

extern "C" {
#include "dumpnt.h"

}

//#define SCE_DBG      1

NTSTATUS
ScepGetLsaDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo,
    PPOLICY_PRIMARY_DOMAIN_INFO *PolicyPrimaryDomainInfo
    );

DWORD
ScepGetEnvVarsFromProfile(
    IN PWSTR UserProfileName,
    IN PCWSTR VarName1,
    IN PCWSTR VarName2 OPTIONAL,
    OUT PWSTR *StrValue
    );



NTSTATUS
ScepOpenSamDomain(
    IN ACCESS_MASK  ServerAccess,
    IN ACCESS_MASK  DomainAccess,
    OUT PSAM_HANDLE pServerHandle,
    OUT PSAM_HANDLE pDomainHandle,
    OUT PSID        *DomainSid,
    OUT PSAM_HANDLE pBuiltinDomainHandle OPTIONAL,
    OUT PSID        *BuiltinDomainSid OPTIONAL
    )
/*
Routine Description

    This routine opens the local SAM server for account domain and builtin
    domain. The domain handles and their SIDs are returned.

*/
{
    NTSTATUS                     NtStatus;

    PPOLICY_ACCOUNT_DOMAIN_INFO  PolicyAccountDomainInfo=NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO  PolicyPrimaryDomainInfo=NULL;
    OBJECT_ATTRIBUTES            ObjectAttributes;
    SID_IDENTIFIER_AUTHORITY     NtAuthority = SECURITY_NT_AUTHORITY;

    if ( !pServerHandle || !pDomainHandle || !DomainSid ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // initialize output buffers
    //
    *pServerHandle = NULL;
    *pDomainHandle = NULL;
    *DomainSid = NULL;

    if ( pBuiltinDomainHandle ) {
        *pBuiltinDomainHandle = NULL;
    }
    if ( BuiltinDomainSid ) {
        *BuiltinDomainSid = NULL;
    }

    //
    // Get information for the account domain
    //

    NtStatus = ScepGetLsaDomainInfo(
                   &PolicyAccountDomainInfo,
                   &PolicyPrimaryDomainInfo
                   );

    if (!NT_SUCCESS(NtStatus)) {
        return( NtStatus );
    }

    //
    // Connect to the local SAM server
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );

    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  pServerHandle,
                  ServerAccess,
                  &ObjectAttributes
                  );

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // copy the SID to output buffer
        //
        DWORD SidLen = RtlLengthSid(PolicyAccountDomainInfo->DomainSid);

        *DomainSid = (PSID)ScepAlloc(0, SidLen);

        if ( *DomainSid != NULL ) {

            NtStatus = RtlCopySid(SidLen, *DomainSid, PolicyAccountDomainInfo->DomainSid);

        } else {

            NtStatus = STATUS_NO_MEMORY;
        }
    }

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // open the account domain
        //
        NtStatus = SamOpenDomain(
                      *pServerHandle,
                      DomainAccess,
                      PolicyAccountDomainInfo->DomainSid,
                      pDomainHandle
                      );

        if ( NT_SUCCESS(NtStatus) && BuiltinDomainSid != NULL ) {
            //
            // build the builtin domain sid
            //
            NtStatus = RtlAllocateAndInitializeSid(
                            &NtAuthority,
                            1,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            0, 0, 0, 0, 0, 0, 0,
                            BuiltinDomainSid
                            );

            if ( NT_SUCCESS(NtStatus) && pBuiltinDomainHandle != NULL ) {
                //
                // open the builtin domain
                //
                NtStatus = SamOpenDomain(
                                *pServerHandle,
                                DomainAccess,
                                *BuiltinDomainSid,
                                pBuiltinDomainHandle
                                );
            }
        }
    }

    //
    // free memory and clean up
    //
    if ( PolicyAccountDomainInfo != NULL ) {
        LsaFreeMemory( PolicyAccountDomainInfo );
    }
    if ( PolicyPrimaryDomainInfo != NULL ) {
        LsaFreeMemory( PolicyPrimaryDomainInfo );
    }

    if ( !NT_SUCCESS(NtStatus)) {

        SamCloseHandle( *pDomainHandle );
        *pDomainHandle = NULL;

        if ( pBuiltinDomainHandle ) {
            SamCloseHandle( *pBuiltinDomainHandle );
            *pBuiltinDomainHandle = NULL;
        }
        SamCloseHandle( *pServerHandle );
        *pServerHandle = NULL;

        ScepFree(*DomainSid);
        *DomainSid = NULL;

        if ( BuiltinDomainSid ) {
            SamFreeMemory(*BuiltinDomainSid);
            *BuiltinDomainSid = NULL;
        }

    }
    return(NtStatus);

}



NTSTATUS
ScepLookupNamesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PSCE_NAME_LIST NameList,
    OUT PUNICODE_STRING *Names,
    OUT PULONG *RIDs,
    OUT PSID_NAME_USE *Use,
    OUT PULONG CountOfName
    )
/* ++
Routine Description:

    This routine looks up one or more names in the SAM account domain and
    returns the relative IDs for each name in the list. The name list may
    be user list, group list, or alias list.

Arguments:

    DomainHandle - SAM handle to the account domain

    NameList    -- The list of names

    Names        - Translated UNICODE_STRING names. The name list must be freed by

    RIDs        -- List of relative IDs for each name

    Use         -- List of type for each name

    CoutnOfName  - The number of names in the list

Return value:

    NTSTATUS
-- */
{
    PSCE_NAME_LIST   pUser;
    ULONG           cnt;
    NTSTATUS        NtStatus=ERROR_SUCCESS;
    PUNICODE_STRING pUnicodeName=NULL;


    UNICODE_STRING uName;
    LPTSTR pTemp;

    //
    // Count how many names in the list
    //

    for (pUser=NameList, cnt=0;
         pUser != NULL;
         pUser = pUser->Next) {

        if ( pUser->Name == NULL ) {
            continue;
        }
        //
        // note, this may be bigger than supposed to
        //
        cnt++;
    }

    if ( cnt > 0 ) {
        //
        // Allocate memory for UNICODE_STRING names
        //
        pUnicodeName = (PUNICODE_STRING)RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            cnt * sizeof (UNICODE_STRING)
                            );
        if ( pUnicodeName == NULL ) {
            NtStatus = STATUS_NO_MEMORY;
            cnt = 0;
            goto Done;
        }

        //
        // Initialize each UNICODE_STRING
        //
        for (pUser=NameList, cnt=0;
             pUser != NULL;
             pUser = pUser->Next) {

            if ( pUser->Name == NULL ) {
                continue;
            }

            pTemp = wcschr(pUser->Name, L'\\');

            if ( pTemp ) {

                uName.Buffer = pUser->Name;
                uName.Length = ((USHORT)(pTemp-pUser->Name))*sizeof(TCHAR);

                if ( !ScepIsDomainLocal(&uName) ) {
                    ScepLogOutput3(1, 0, SCEDLL_NO_MAPPINGS, pUser->Name);
                    continue;
                }
                pTemp++;
            } else {
                pTemp = pUser->Name;
            }

            RtlInitUnicodeString(&(pUnicodeName[cnt]), pTemp);

            cnt++;
        }

        // lookup
        NtStatus = SamLookupNamesInDomain(
                        DomainHandle,
                        cnt,
                        pUnicodeName,
                        RIDs,
                        Use
                        );
        if ( !NT_SUCCESS(NtStatus) ) {
            RtlFreeHeap(RtlProcessHeap(), 0, pUnicodeName);
            pUnicodeName = NULL;
        }
    }
Done:

    *CountOfName = cnt;
    *Names = pUnicodeName;

    return(NtStatus);
}


NTSTATUS
ScepGetLsaDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo,
    PPOLICY_PRIMARY_DOMAIN_INFO *PolicyPrimaryDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.

    PolicyPrimaryDomainInfo - Receives a pointer to a
        POLICY_PRIMARY_DOMAIN_INFO structure containing the Primary
        domain info.


Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

             LsaOpenPolicy()
             LsaQueryInformationPolicy()
--*/

{
    NTSTATUS Status, IgnoreStatus;

    LSA_HANDLE PolicyHandle;
    OBJECT_ATTRIBUTES PolicyObjectAttributes;

    //
    // Open the policy database
    //

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    Status = LsaOpenPolicy( NULL,
                            &PolicyObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );
    if ( NT_SUCCESS(Status) ) {

        //
        // Query the account domain information
        //

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyAccountDomainInformation,
                                            (PVOID *)PolicyAccountDomainInfo );

        if ( NT_SUCCESS(Status) ) {

            //
            // Query the Primary domain information
            //

            Status = LsaQueryInformationPolicy( PolicyHandle,
                                                PolicyPrimaryDomainInformation,
                                                (PVOID *)PolicyPrimaryDomainInfo );
        }

        IgnoreStatus = LsaClose( PolicyHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return(Status);
}



VOID
ScepConvertLogonHours(
    IN PSCE_LOGON_HOUR   pLogonHours,
    OUT PUCHAR LogonHourBitMask
    )
/* ++
Routine Description:

    This routine converted the logon hour range in hours (for example, 7-20)
    to logon hour bit mask (for example, 0001 1111 1111 1111 1000 0000,
    for one day).


Arguments:

    pLogonHours      -  The logon hour range (in hours)

    LogonHourBitMask -  The converted logon hour bit mask. Each bit represents
                        an hour. There are total 21 bytes (21*8 bits in this
                        argument, which represents a week (7 * 24 = 21 * 8).
Return value:

    None
-- */
{   PSCE_LOGON_HOUR  pTemp;
    CHAR            BitMask[3]={0,0,0};
    ULONG           j;

    for ( pTemp=pLogonHours; pTemp != NULL; pTemp=pTemp->Next ) {

        for (j=pTemp->Start; j<pTemp->End; j++)
            BitMask[j / 8] |= 1 << (j % 8);
    }

    for ( j=0; j<7; j++ )
        strncpy((CHAR *)&(LogonHourBitMask[j*3]), BitMask,3);

}


DWORD
ScepConvertToSceLogonHour(
    IN PUCHAR LogonHourBitMask,
    OUT PSCE_LOGON_HOUR *pLogonHours
    )
/* ++
Routine Description:

    This routine converted the logon hour bit mask (for example,
    0001 1111 1111 1111 1000 0000 for one day) to SCE_LOGON_HOUR type,
    which stores the logon hour range (start, end).


Arguments:

    LogonHourBitMask -  The logon hour bit mask to convert. Each bit represents
                        an hour. There are total 21 bytes (21*8 bits in this
                        argument, which represents a week (7 * 24 = 21 * 8).

    pLogonHours      -  The logon hour range (in hours)

Return value:

    None
-- */
{
    BOOL    findStart = TRUE;
    DWORD   i, j, rc=NO_ERROR;
    DWORD   start=0,
            end=0;
    LONG   value;

    PSCE_LOGON_HOUR pLogon=NULL;

    if (pLogonHours == NULL )
        return(ERROR_INVALID_PARAMETER);


    for ( i=3; i<6; i++)
        for ( j=0; j<8; j++) {
            if ( findStart )
                value = 1;
            else
                value = 0;

            if ( (LogonHourBitMask[i] & (1 << j)) == value ) {

                if ( findStart ) {
                    start = (i-3)*8 + j;
                    findStart = FALSE;
                } else {
                    end = (i-3)*8 + j;
                    findStart = TRUE;
                }
                if ( findStart ) {
                    //
                    // find a pair
                    //
                    pLogon = (PSCE_LOGON_HOUR)ScepAlloc( (UINT)0, sizeof(SCE_LOGON_HOUR));
                    if ( pLogon == NULL ) {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                        return(rc);
                    }
                    pLogon->Start = start;
                    pLogon->End = end;
                    pLogon->Next = *pLogonHours;
                    *pLogonHours = pLogon;
                    pLogon = NULL;

                }

            }

        }

    if ( findStart == FALSE ) {
        // find start but not end, which means end=24
        end = 24;
        pLogon = (PSCE_LOGON_HOUR)ScepAlloc( (UINT)0, sizeof(SCE_LOGON_HOUR));
        if ( pLogon == NULL ) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            return(rc);
        }
        pLogon->Start = start;
        pLogon->End = end;
        pLogon->Next = *pLogonHours;
        *pLogonHours = pLogon;
        pLogon = NULL;

    }

    return(rc);
}



NTSTATUS
ScepGetGroupsForAccount(
    IN SAM_HANDLE       DomainHandle,
    IN SAM_HANDLE       BuiltinDomainHandle,
    IN SAM_HANDLE       UserHandle,
    IN PSID             AccountSid,
    OUT PSCE_NAME_LIST   *GroupList
    )
/* ++
Routine Description:

    This routine queries the user's group membership.

Arguments:

    DomainHandle    - The SAM handle of the SAM account domain

    BuiltindomainHandle - The SAM builtin domain handle

    UserHandle - The SAM account handle for the user

    AccountSid - The SID for the user

    GroupList       - The list of groups the user belongs to

Return value:

    NTSTATUS

-- */
{
    NTSTATUS            NtStatus=ERROR_SUCCESS;

    ULONG               GroupCount=0,
                        AliasCount=0;
    PULONG              Aliases=NULL;
    PGROUP_MEMBERSHIP   GroupAttributes=NULL;
    PULONG              GroupIds=NULL;
    PUNICODE_STRING     Names=NULL;
    PSID_NAME_USE       Use=NULL;

    DWORD               i;


    NtStatus = SamGetGroupsForUser(
                    UserHandle,
                    &GroupAttributes,
                    &GroupCount
                    );

    if ( GroupCount == 0 )
        NtStatus = ERROR_SUCCESS;

    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    //
    // See what local groups the account belongs to.
    // account domain
    //

    NtStatus = SamGetAliasMembership(
                    DomainHandle,
                    1,
                    &AccountSid,
                    &AliasCount,
                    &Aliases );

    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    if ( AliasCount != 0 || GroupCount != 0 ) {

        //
        // process each group's name in account domain
        //

        GroupIds = (PULONG)ScepAlloc((UINT)0,
                     (GroupCount+AliasCount)*sizeof(ULONG));

        if ( GroupIds == NULL ) {
            NtStatus = STATUS_NO_MEMORY;
            goto Done;
        }

        for ( i=0; i<GroupCount; i++)
            GroupIds[i] = GroupAttributes[i].RelativeId;

        for ( i=0; i<AliasCount; i++)
            GroupIds[i+GroupCount] = Aliases[i];

    }

    SamFreeMemory(GroupAttributes);
    GroupAttributes = NULL;

    SamFreeMemory(Aliases);
    Aliases = NULL;

    if ( AliasCount != 0 || GroupCount != 0 ) {

        // lookup names
        NtStatus = SamLookupIdsInDomain(
                        DomainHandle,
                        GroupCount+AliasCount,
                        GroupIds,
                        &Names,
                        &Use
                        );

        if ( !NT_SUCCESS(NtStatus) )
            goto Done;
    }

    for ( i=0; i<GroupCount+AliasCount; i++) {
        if ( GroupIds[i] == DOMAIN_GROUP_RID_USERS )
            continue;
        switch (Use[i]) {
        case SidTypeGroup:
        case SidTypeAlias:
        case SidTypeWellKnownGroup:
            if ( ScepAddToNameList(GroupList, Names[i].Buffer, Names[i].Length/2) != NO_ERROR) {
                NtStatus = STATUS_NO_MEMORY;
                goto Done;
            }
            break;
        default:
            break;
        }
    }

    if ( GroupIds ) {
        ScepFree(GroupIds);
        GroupIds = NULL;
    }

    if ( Names ) {
        SamFreeMemory(Names);
        Names = NULL;
    }

    if ( Use ) {
        SamFreeMemory(Use);
        Use = NULL;
    }

    //
    // check the builtin domain for alias membership
    //

    AliasCount=0;
    NtStatus = SamGetAliasMembership(
                    BuiltinDomainHandle,
                    1,
                    &AccountSid,
                    &AliasCount,
                    &Aliases );

    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    if ( AliasCount > 0 ) {

        NtStatus = SamLookupIdsInDomain(
                        BuiltinDomainHandle,
                        AliasCount,
                        Aliases,
                        &Names,
                        &Use
                        );

        if ( !NT_SUCCESS(NtStatus) )
            goto Done;
    }

    for ( i=0; i<AliasCount; i++) {
        if ( Aliases[i] == DOMAIN_GROUP_RID_USERS )
            continue;

        switch (Use[i]) {
        case SidTypeGroup:
        case SidTypeAlias:
        case SidTypeWellKnownGroup:
            if ( ScepAddToNameList(GroupList, Names[i].Buffer, Names[i].Length/2) != NO_ERROR) {
                NtStatus = STATUS_NO_MEMORY;
                goto Done;
            }
            break;
        default:
            break;
        }
    }

Done:

    if ( GroupAttributes != NULL )
        SamFreeMemory(GroupAttributes);

    if ( Aliases != NULL )
        SamFreeMemory(Aliases);

    if ( GroupIds != NULL )
        ScepFree(GroupIds);

    if ( Names != NULL )
        SamFreeMemory(Names);

    if ( Use != NULL )
        SamFreeMemory(Use);

    return(NtStatus);

}



ACCESS_MASK
ScepGetDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN SECURITY_INFORMATION SecurityInfo
    )
/*++
Routine Description:

    Gets the access required to open object to be able to set or get the
    specified security info.

Arguments:

    OpenType  - Flag indicating if the object is to be opened to read or
                write the DACL

    SecurityInfo - The Security information to read/write.

Return value:

    Access mask

-- */
{
    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    return (DesiredAccess);
}


SCESTATUS
ScepGetProfileOneArea(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN DWORD dwAccountFormat,
    OUT PSCE_PROFILE_INFO *ppInfoBuffer
    )
/* ++
Routine Description:

    A wrapper routine for GetDatabaseInfo except it get information
    for one area at a call. This routine also logs the errors occur inside
    GetSecrityProfileInfo

Arguments:

    hProfile    - Handle to a profile

    ProfileType - The type of the profile

    Area - The security area to read info from

    ppInfoBuffer - output buffer for the info

Return value:

    SCESTATUS returned from GetDatabaseInfo

-- */
{
    SCESTATUS rc;
    PSCE_ERROR_LOG_INFO  pErrlog=NULL;


    rc = ScepGetDatabaseInfo(
        hProfile,
        ProfileType,
        Area,
        dwAccountFormat,
        ppInfoBuffer,
        &pErrlog
        );

    ScepLogWriteError( pErrlog, 1 );
    ScepFreeErrorLog( pErrlog );

    return(rc);
}


SCESTATUS
ScepGetOneSection(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PWSTR Name,
    IN SCETYPE ProfileType,
    OUT PVOID *ppInfo
    )
/* ++
Routine Description:

    This routine reads information for one or more Area and logs errors to
    the log file. This routine should be only used by the SCP engine and
    the SAP engine.

Arguments:

    hProfile    - Handle to a profile

    ProfileType - The type of the profile

    Area - The security area to read info from

    Subarea - The subarea to read info from

    ppInfo - output buffer for the info

Return value:

    SCESTATUS

-- */
{
    SCESTATUS rc;
    PSCE_ERROR_LOG_INFO  pErrlog=NULL;

    if ( Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( Area == AREA_REGISTRY_SECURITY ||
         Area == AREA_FILE_SECURITY ||
         Area == AREA_DS_OBJECTS ) {

        rc = ScepGetObjectChildren(
                hProfile,
                ProfileType,
                Area,
                Name,
                SCE_ALL_CHILDREN,
                ppInfo,
                &pErrlog
                );
    } else {
        rc = ScepGetUserSection(
                hProfile,
                ProfileType,
                Name,
                ppInfo,
                &pErrlog
                );
    }

    ScepLogWriteError( pErrlog, 1 );
    ScepFreeErrorLog( pErrlog );

    return(rc);
}


NTSTATUS
ScepGetUserAccessAddress(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSID AccountSid,
    OUT PACCESS_MASK *pUserAccess,
    OUT PACCESS_MASK *pEveryone
    )
{
    NTSTATUS                NtStatus;
    PACL                    pAcl;
    BOOLEAN                 aclPresent, tFlag;
    DWORD                   i;
    PVOID                   pAce;
    PSID                    pSid;
    ACCESS_MASK             access;
    SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    PSID EveryoneSid=NULL;


    if ( AccountSid == NULL || pUserAccess == NULL || pEveryone == NULL )
        return(STATUS_INVALID_PARAMETER);

    *pUserAccess = NULL;
    *pEveryone = NULL;

    if ( pSecurityDescriptor == NULL )
        return(STATUS_SUCCESS);

    NtStatus = RtlGetDaclSecurityDescriptor(
                pSecurityDescriptor,
                &aclPresent,
                &pAcl,
                &tFlag);

    if ( NT_SUCCESS(NtStatus) )

        NtStatus = RtlAllocateAndInitializeSid(
                        &WorldAuth,
                        1,
                        SECURITY_CREATOR_OWNER_RID,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        &EveryoneSid );

    if ( NT_SUCCESS(NtStatus) ) {

        if ( pAcl != NULL && aclPresent ) {

            for ( i=0; i < pAcl->AceCount; i++) {
                NtStatus = RtlGetAce( pAcl, i, &pAce );
                if ( !NT_SUCCESS( NtStatus ) )
                    break;

                access = 0;
                pSid = NULL;

                switch ( ((PACE_HEADER)pAce)->AceType ) {
                case ACCESS_ALLOWED_ACE_TYPE:
                    pSid = (PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                    access = ((PACCESS_ALLOWED_ACE)pAce)->Mask;

                    if ( EqualSid( AccountSid, pSid ) )
                         *pUserAccess = &(((PACCESS_ALLOWED_ACE)pAce)->Mask);

                    else if ( EqualSid( EveryoneSid, pSid) )
                        *pEveryone = &(((PACCESS_ALLOWED_ACE)pAce)->Mask);

                    break;

                case ACCESS_DENIED_ACE_TYPE:
// do not look for denied ace type because it is not used here
//                    pSid = (PSID)&((PACCESS_DENIED_ACE)pAce)->SidStart;
//                    access = ((PACCESS_DENIED_ACE)pAce)->Mask;
                    break;
                default:
                    break;
                }

                if ( *pUserAccess != NULL && *pEveryone != NULL )
                    // stop the loop because both are found
                    break;
            }
        }
    }

    //
    // free EveryoneSid
    //
    if (EveryoneSid) {
        RtlFreeSid(EveryoneSid);
        EveryoneSid = NULL;
    }
    return(NtStatus);
}

BOOL
ScepLastBackSlash(
    IN PWSTR Name
    )
{
    if (Name == NULL )
        return(FALSE);

    if ( Name[wcslen(Name)-1] == L'\\')
        return(TRUE);
    else
        return(FALSE);

}


DWORD
ScepGetUsersHomeDirectory(
    IN UNICODE_STRING AssignedHomeDir,
    IN PWSTR UserProfileName,
    OUT PWSTR *UserHomeDir
    )
/*++
Routine Description:

    This routine gets user's default home directory. The home directory is
    determined 1) if it is assigned in the user's object (user profile), 2)
    if there is a HomePath environment variable defined for the user, and
    3). Harcoded.

Arguments:

    AssignedHomeDir - The home directory explicitly assigned in the user's
                      object.

    UserProfileName - The user's environment profile name

    UserHomeDir - The returned home directory for the user

Return Value:

    Win32 error code.

--*/
{
    DWORD                Win32rc=NO_ERROR;
    PWSTR                StrValue=NULL;

    PWSTR                SystemRoot=NULL;
    DWORD                DirSize=0;

    *UserHomeDir = NULL;

    //
    // if there is a home directory assigned in the user profile, use it.
    //
    if ( AssignedHomeDir.Length > 0 && AssignedHomeDir.Buffer != NULL ) {
        *UserHomeDir = (PWSTR)ScepAlloc( LMEM_ZEROINIT, AssignedHomeDir.Length+2);
        if ( *UserHomeDir == NULL )
            return(ERROR_NOT_ENOUGH_MEMORY);

        wcsncpy(*UserHomeDir, AssignedHomeDir.Buffer, AssignedHomeDir.Length/2);
        return(NO_ERROR);
    }

    //
    // Home directory is NULL in user profile, the HomePath environment
    // is searched.
    //

    Win32rc = ScepGetNTDirectory( &SystemRoot, &DirSize, SCE_FLAG_WINDOWS_DIR );
    if ( Win32rc != NO_ERROR ) {
        ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_QUERY_INFO, L"%WinDir%");
        return(Win32rc);
    }

    Win32rc = ScepGetEnvVarsFromProfile(
                        UserProfileName,
                        L"HomePath",
                        NULL,
                        &StrValue
                        );

    if ( Win32rc == NO_ERROR && StrValue != NULL ) {
        *UserHomeDir = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (wcslen(StrValue)+3)*sizeof(WCHAR));
        if ( *UserHomeDir == NULL )
            Win32rc = ERROR_NOT_ENOUGH_MEMORY;
        else {
            swprintf(*UserHomeDir+1, L":%s", StrValue);
            **UserHomeDir = SystemRoot[0];
        }
    } else
        Win32rc = NO_ERROR; // do not care if can't get environment variable's value

    if ( SystemRoot != NULL )
        ScepFree(SystemRoot);

    if ( StrValue != NULL )
        ScepFree( StrValue );

    return(Win32rc);
}


DWORD
ScepGetEnvVarsFromProfile(
    IN PWSTR UserProfileName,
    IN PCWSTR VarName1,
    IN PCWSTR VarName2 OPTIONAL,
    OUT PWSTR *StrValue
    )
{
    DWORD     rc;
    DWORD     RegType;


    rc = SceAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, NULL);

    if ( rc == ERROR_SUCCESS ) {
        rc = RegLoadKey(HKEY_USERS, L"TEMP", UserProfileName);

        if ( rc == ERROR_SUCCESS ) {
            rc = ScepRegQueryValue(
                     HKEY_USERS,
                     L"TEMP\\Environment",
                     VarName1,
                     (PVOID *)StrValue,
                     &RegType,
                     NULL
                     );

            if ( rc != ERROR_SUCCESS && VarName2 != NULL ) {
                rc = ScepRegQueryValue(
                         HKEY_USERS,
                         L"TEMP\\Environment",
                         VarName2,
                         (PVOID *)StrValue,
                         &RegType,
                         NULL
                         );
            }

            RegUnLoadKey(HKEY_USERS, L"TEMP");

        } else { //if ( rc == ERROR_ALREADY_IN_USE) {
            //
            // this profile already in use. Open the one in HKEY_CURRENT_USER
            //
            rc = ScepRegQueryValue(
                      HKEY_CURRENT_USER,
                      L"Environment",
                      VarName1,
                      (PVOID *)StrValue,
                      &RegType,
                      NULL
                      );

            if ( rc != ERROR_SUCCESS && VarName2 != NULL ) {
                rc = ScepRegQueryValue(
                         HKEY_CURRENT_USER,
                         L"Environment",
                         VarName2,
                         (PVOID *)StrValue,
                         &RegType,
                         NULL
                         );
            }

        }
        SceAdjustPrivilege(SE_RESTORE_PRIVILEGE, FALSE, NULL);
    }

    return(rc);
}


DWORD
ScepGetUsersTempDirectory(
    IN PWSTR UserProfileName,
    OUT PWSTR *UserTempDir
    )
/*++
Routine Description:

    This routine returns the user's temp directory. Temp directory for a
    user is determined 1) environment variable "TEMP" or "TMP" defined
    in the user's environment profile, or 2) Harcoded to %systemDrive%\TEMP

Arguments:

    UserProfileName - The user's environment profile name

    UserTempDir  - The returned temp directory for the user

Return Value:

    Win32 error code

--*/
{
    DWORD   rc=NO_ERROR;
    PWSTR   StrValue=NULL;

    PWSTR   SystemRoot=NULL;
    DWORD   DirSize=0;


    //
    // query the TEMP/TMP environment variable(s)
    //
    if ( UserProfileName != NULL ) {
        ScepGetEnvVarsFromProfile(
                UserProfileName,
                L"TEMP",
                L"TMP",
                &StrValue
                );
    }
    if ( StrValue != NULL ) {
        //
        // find the setting for temp dir
        //

        if ( wcsstr(_wcsupr(StrValue), L"%") != NULL ) {

            rc = ScepTranslateFileDirName( StrValue, UserTempDir );
        }
        if ( rc == NO_ERROR ) {
            ScepFree(StrValue);
        } else
            *UserTempDir = StrValue;

        StrValue = NULL;

    } else {
        //
        // hardcoded to %SystemDrive%\TEMP
        //
        rc = ScepGetNTDirectory( &SystemRoot, &DirSize, SCE_FLAG_WINDOWS_DIR );
        if ( rc != NO_ERROR ) {
            ScepLogOutput3(1, rc, SCEDLL_ERROR_QUERY_INFO, L"%WinDir%");
            return(rc);
        }
        *UserTempDir = (PWSTR)ScepAlloc( 0, 8*sizeof(WCHAR));
        if ( *UserTempDir == NULL )
            rc = ERROR_NOT_ENOUGH_MEMORY;
        else {
            swprintf(*UserTempDir+1, L":\\TEMP");
            **UserTempDir = SystemRoot[0];
        }
    }

    if (SystemRoot != NULL )
        ScepFree(SystemRoot);

    return(rc);
}


SCESTATUS
ScepGetRegKeyCase(
    IN PWSTR ObjName,
    IN DWORD BufOffset,
    IN DWORD BufLen
    )
{
    DWORD Win32rc;
    HKEY hKey=NULL;

    PWSTR Buffer=NULL;
    TCHAR Buffer1[MAX_PATH];
    DWORD BufSize, index;
    FILETIME        LastWriteTime;


    if ( BufOffset <= 0 || BufLen <= 0 ) {
        _wcsupr(ObjName);
        return(SCESTATUS_SUCCESS);
    }

    Buffer = (PWSTR)ScepAlloc(LMEM_ZEROINIT, BufOffset*sizeof(WCHAR));

    if ( Buffer != NULL ) {

        wcsncpy(Buffer, ObjName, BufOffset-1);

        Win32rc = ScepOpenRegistryObject(
                        SE_REGISTRY_KEY,
                        Buffer,
                        KEY_READ,
                        &hKey
                        );
        if ( Win32rc == NO_ERROR ) {

            index = 0;
            //
            // enumerate all subkeys of the key
            //
            do {
                memset(Buffer1, '\0', MAX_PATH*sizeof(WCHAR));
                BufSize = MAX_PATH;

                Win32rc = RegEnumKeyEx(hKey,
                                index,
                                Buffer1,
                                &BufSize,
                                NULL,
                                NULL,
                                NULL,
                                &LastWriteTime);

                if ( Win32rc == ERROR_SUCCESS ) {
                    index++;
                    //
                    // find if the subkey matches the object name
                    //
                    if ( _wcsicmp(ObjName+BufOffset, Buffer1) == 0 )
                        break;
                }

            } while ( Win32rc != ERROR_NO_MORE_ITEMS );

            RegCloseKey(hKey);

            if ( Win32rc == ERROR_SUCCESS ) {
                //
                // find it
                //
                if ( BufSize > BufLen )
                    BufSize = BufLen;

                wcsncpy(ObjName+BufOffset, Buffer1, BufSize);
                *(ObjName+BufOffset+BufSize) = L'\0';

            } else if ( Win32rc == ERROR_NO_MORE_ITEMS) {
                //
                // does not find it
                //
                Win32rc = ERROR_FILE_NOT_FOUND;
            }

        }
        ScepFree(Buffer);

    } else
        Win32rc = ERROR_NOT_ENOUGH_MEMORY;

    if ( Win32rc != NO_ERROR ) {
        //
        // convert everything to uppercase
        //
        _wcsupr(ObjName+BufOffset);
    }

    return(ScepDosErrorToSceStatus(Win32rc));

}


SCESTATUS
ScepGetFileCase(
    IN PWSTR ObjName,
    IN DWORD BufOffset,
    IN DWORD BufLen
    )
{

    intptr_t            hFile;
    struct _wfinddata_t    FileInfo;

    hFile = _wfindfirst(ObjName, &FileInfo);

    if ( hFile != -1 ) {

        wcsncpy(ObjName+BufOffset, FileInfo.name, BufLen);

        _findclose(hFile);

    } else
        return(ScepDosErrorToSceStatus(GetLastError()));

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepGetGroupCase(
    IN OUT PWSTR GroupName,
    IN DWORD Length
    )
{
    NTSTATUS                        NtStatus;

    SAM_HANDLE                      ServerHandle=NULL,
                                    DomainHandle=NULL,
                                    BuiltinDomainHandle=NULL,
                                    ThisDomain=NULL,
                                    GroupHandle=NULL;

    PSID                            DomainSid=NULL,
                                    BuiltinDomainSid=NULL;
    UNICODE_STRING                  Name;
    PULONG              GrpId=NULL;
    PSID_NAME_USE       GrpUse=NULL;
    PVOID               pNameInfo=NULL;

    NtStatus = ScepOpenSamDomain(
                        SAM_SERVER_READ | SAM_SERVER_EXECUTE,
                        DOMAIN_READ | DOMAIN_EXECUTE,
                        &ServerHandle,
                        &DomainHandle,
                        &DomainSid,
                        &BuiltinDomainHandle,
                        &BuiltinDomainSid
                       );
    if ( NT_SUCCESS(NtStatus) ) {

        RtlInitUnicodeString(&Name, GroupName);

        NtStatus = SamLookupNamesInDomain(
                        DomainHandle,
                        1,
                        &Name,
                        &GrpId,
                        &GrpUse
                        );
        ThisDomain = DomainHandle;

        if ( NtStatus == STATUS_NONE_MAPPED ) {
            //
            // not found in account domain. Lookup in the builtin domain
            //
            NtStatus = SamLookupNamesInDomain(
                            BuiltinDomainHandle,
                            1,
                            &Name,
                            &GrpId,
                            &GrpUse
                            );
            ThisDomain=BuiltinDomainHandle;
        }

        if ( NT_SUCCESS(NtStatus) ) {

            switch ( GrpUse[0] ) {
            case SidTypeGroup:
                NtStatus = SamOpenGroup(
                                ThisDomain,
                                GROUP_READ | GROUP_EXECUTE,
                                GrpId[0],
                                &GroupHandle
                                );
                if ( NT_SUCCESS(NtStatus) ) {

                    NtStatus = SamQueryInformationGroup(
                                    GroupHandle,
                                    GroupNameInformation,
                                    &pNameInfo
                                    );
                }

                break;
            case SidTypeAlias:
                NtStatus = SamOpenAlias(
                                ThisDomain,
                                ALIAS_READ | ALIAS_EXECUTE,
                                GrpId[0],
                                &GroupHandle
                                );
                if ( NT_SUCCESS(NtStatus) ) {

                    NtStatus = SamQueryInformationAlias(
                                    GroupHandle,
                                    AliasNameInformation,
                                    &pNameInfo
                                    );
                }
                break;
            default:
                NtStatus = STATUS_NONE_MAPPED;
                break;
            }

            if ( NT_SUCCESS(NtStatus) ) {
                //
                // get name information
                //
                if ( ((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Buffer != NULL &&
                     ((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Length > 0 ) {

                   if ( Length > (DWORD)(((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Length/2) ) {

                       wcsncpy(GroupName, ((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Buffer,
                                   ((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Length/2);
                   } else {
                       wcsncpy(GroupName, ((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Buffer,
                                   Length);
                   }

                } else
                    NtStatus = STATUS_NONE_MAPPED;

                SamFreeMemory(pNameInfo);
            }

            if (GroupHandle)
                SamCloseHandle(GroupHandle);

            SamFreeMemory(GrpId);
            SamFreeMemory(GrpUse);
        }
        SamCloseHandle( DomainHandle );
        SamCloseHandle( BuiltinDomainHandle );
        SamCloseHandle( ServerHandle );

        SamFreeMemory(DomainSid);
        RtlFreeSid(BuiltinDomainSid);
    }

    return(ScepDosErrorToSceStatus( RtlNtStatusToDosError(NtStatus) ));
}



VOID
ScepPrintSecurityDescriptor(
   IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
   IN BOOL ToDumpSD
   )
{
    if (pSecurityDescriptor != NULL) {

        if ( ToDumpSD )
            DumpSECURITY_DESCRIPTOR(pSecurityDescriptor);
        else
            printf("Security Descriptor\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\pfset.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    pfset.cpp

Abstract:

    Routines to set info to the jet database.

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

--*/

#include "headers.h"
#include "serverp.h"
#include "pfp.h"
#include "regvalue.h"
#pragma hdrstop

//#define SCE_DBG 1

SCESTATUS
ScepOpenPrevPolicyContext(
    IN PSCECONTEXT hProfile,
    OUT PSCECONTEXT *phPrevProfile
    );

SCESTATUS
ScepClosePrevPolicyContext(
    IN OUT PSCECONTEXT *phProfile
    );


SCESTATUS
ScepStartANewSection(
    IN PSCECONTEXT hProfile,
    IN OUT PSCESECTION *hSection,
    IN SCEJET_TABLE_TYPE ProfileType,
    IN PCWSTR SectionName
    )
/* ++
Routine Description:

    This routine open a JET section by Name. If the section exists, it is
    opened, else it is created.

Arguments:

    hProfile - The JET database handle

    hSection - the JET section handle to return

    ProfileType - the table to open

    SectionName - the JET section name

Return Value:

    SCESTATUS_SUCCESS

    SCESTATUS returned from  SceJetCloseSection,
                            SceJetAddSection,
                            SceJetOpenSection

-- */
{
    SCESTATUS  rc=SCESTATUS_SUCCESS;
    DOUBLE    SectionID;

    if ( *hSection != NULL ) {
        //
        // free the previous used section
        //
        rc = SceJetCloseSection( hSection, FALSE );
    }

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // SceJetAddSection will seek for the section name first.
        // if a match is found, the section id is returned, else add it.
        // this is good for SAP profile.
        //
        rc = SceJetAddSection(
                hProfile,
                SectionName,
                &SectionID
                );
        if ( rc == SCESTATUS_SUCCESS ) {

            rc = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        ProfileType,
                        hSection
                        );
        }
    }
    return( rc );

}


SCESTATUS
ScepCompareAndSaveIntValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN BOOL bReplaceExistOnly,
    IN DWORD BaseValue,
    IN DWORD CurrentValue
    )
/* ++
Routine Description:

    This routine compares DWORD value system settings with the baseline profile
    settings. If there is mismatch or unknown, the entry is saved in the SAP
    profile.

Arguments:

    hSection - The JET section context

    Name    - The entry name

    BaseLine- The baseline profile value to compare with

    CurrentValue - The current system setting (DWORD value)

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS  rc;
    TCHAR     StrValue[12];

    if ( Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( CurrentValue == SCE_NO_VALUE ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( ( CurrentValue == BaseValue) &&
         ( BaseValue != SCE_NO_VALUE) &&
         ( BaseValue != SCE_SNAPSHOT_VALUE) ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( bReplaceExistOnly &&
         (BaseValue == SCE_NO_VALUE) ) {
        return(SCESTATUS_SUCCESS);
    }

    memset(StrValue, '\0', 24);

    //
    // either mismatched/unknown
    // Save this entry
    //
    swprintf(StrValue, L"%d", CurrentValue);

    rc = SceJetSetLine( hSection, Name, FALSE, StrValue, wcslen(StrValue)*2, 0);

    switch ( BaseValue ) {
    case SCE_SNAPSHOT_VALUE:

        ScepLogOutput2(2, 0, StrValue);
        break;

    case SCE_NO_VALUE:

        if ( CurrentValue == SCE_ERROR_VALUE ) {
            ScepLogOutput3(2, 0, SCEDLL_STATUS_ERROR, Name);
        } else {
            ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
        }
        break;

    default:

        ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
        break;
    }

#ifdef SCE_DBG
   wprintf(L"rc=%d, Section: %d, %s=%d\n", rc, (DWORD)(hSection->SectionID), Name, CurrentValue);
#endif
    return(rc);

}


SCESTATUS
ScepCompareAndSaveStringValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PWSTR BaseValue,
    IN PWSTR CurrentValue,
    IN DWORD CurrentLen
    )
/* ++
Routine Description:

    This routine compares system settings in string with the baseline profile
    settings. If there is mismatch or unknown, the entry is saved in the SAP
    profile.

Arguments:

    hSection - The section handle

    Name    - The entry name

    BaseLine- The baseline profile value to compare with

    CurrentValue - The current system setting

    CurrentLen - The length of the current setting

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS  rc;

    if ( Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( CurrentValue == NULL )
        return(SCESTATUS_SUCCESS);

    rc = SceJetSetLine( hSection, Name, FALSE, CurrentValue, CurrentLen, 0);

    if ( BaseValue ) {
        if ( (ULONG_PTR)BaseValue == SCE_SNAPSHOT_VALUE ) {

            ScepLogOutput2(2, 0, CurrentValue);
        } else {

            ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
        }
    } else {
        ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
    }

#ifdef SCE_DBG
    wprintf(L"rc=%d, Section: %d, %s=%s\n", rc, (DWORD)(hSection->SectionID), Name, CurrentValue);
#endif

    return(rc);

}


SCESTATUS
ScepSaveObjectString(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN BOOL  IsContainer,
    IN BYTE  Flag,
    IN PWSTR Value OPTIONAL,
    IN DWORD ValueLen
    )
/* ++
Routine Description:

    This routine writes registry/file settings to the JET section. Registry/
    file setting includes a flag (mismatch/unknown) and the security
    descriptor in text format. The object setting is saved in the format of
    1 byte flag followed by the Value.

Arguments:

    hSection - the JET section handle

    Name    - The entry name

    IsContainer - TRUE = The object is a container
                  FALSE = The object is not a container

    Flag - the flag for object's setting
                1 - Mismatch
                0 - Unknown

    Value - The security descriptor in text

    ValueLen - the length of the text security descriptor

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER

    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS rc;
    DWORD    Len;
    PWSTR    ValueToSet=NULL;


    if ( hSection == NULL ||
         Name == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( Value != NULL )
        Len = ( ValueLen+1)*sizeof(WCHAR);
    else
        Len = sizeof(WCHAR);

    ValueToSet = (PWSTR)ScepAlloc( (UINT)0, Len+sizeof(WCHAR) );

    if ( ValueToSet == NULL )
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    //
    // The first byte is the flag, the second byte is IsContainer (1,0)
    //
    *((BYTE *)ValueToSet) = Flag;

    *((CHAR *)ValueToSet+1) = IsContainer ? '1' : '0';

    if ( Value != NULL ) {
        wcscpy(ValueToSet+1, Value);
        ValueToSet[ValueLen+1] = L'\0';  //terminate this string
    } else {
        ValueToSet[1] = L'\0';
    }

    rc = SceJetSetLine( hSection, Name, FALSE, ValueToSet, Len, 0);

    switch ( Flag ) {
    case SCE_STATUS_CHILDREN_CONFIGURED:
    case SCE_STATUS_NOT_CONFIGURED:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
        break;
    case SCE_STATUS_ERROR_NOT_AVAILABLE:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_ERROR, Name);
        break;
    case SCE_STATUS_GOOD:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_MATCH, Name);
        break;
    case SCE_STATUS_NEW_SERVICE:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_NEW, Name);
        break;
    case SCE_STATUS_NO_ACL_SUPPORT:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_NOACL, Name);
        break;
    default:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
        break;
    }

#ifdef SCE_DBG
    wprintf(L"rc=%d, Section: %d, %s=%s\n", rc, (DWORD)(hSection->SectionID), Name, ValueToSet);
#endif
    ScepFree( ValueToSet );

    return( rc );
}


SCESTATUS
ScepWriteNameListValue(
    IN LSA_HANDLE LsaPolicy OPTIONAL,
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSCE_NAME_LIST NameList,
    IN DWORD dwWriteOption,
    IN INT Status
    )
/* ++
Routine Description:

    This routine writes a key with a list of value to the JET section. The list
    of values is saved in a MULTI-SZ format which is separated by a NULL char and
    terminated by 2 NULLs. If the list is NULL, nothing is saved unless
    SaveEmptyList is set to TRUE, where a NULL value is saved with the key.

Arguments:

    hSection - the JET hsection handle

    Name - The key name

    NameList - the list of values

    SaveEmptyList - TRUE = save NULL value if the list is empty
                    FALSE = DO NOT save if the list is empty

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE

    SCESTATUS returned from SceJetSetLine

-- */
{   SCESTATUS    rc=SCESTATUS_SUCCESS;
    DWORD       TotalSize=0;
    PWSTR       Value=NULL;
    PSCE_NAME_LIST pName;
    PWSTR       pTemp=NULL;
    DWORD       Len;
    DWORD               i=0,j;
    DWORD               cntAllocated=0;
    SCE_TEMP_NODE       *tmpArray=NULL, *pa=NULL;
    PWSTR       SidString = NULL;


    for ( pName=NameList; pName != NULL; pName = pName->Next ) {

        if ( pName->Name == NULL ) {
            continue;
        }

        if ( dwWriteOption & SCE_WRITE_CONVERT ) {

            if ( i >= cntAllocated ) {
                //
                // array is not enough, reallocate
                //
                tmpArray = (SCE_TEMP_NODE *)ScepAlloc(LPTR, (cntAllocated+16)*sizeof(SCE_TEMP_NODE));

                if ( tmpArray ) {

                    //
                    // move pointers from the old array to the new array
                    //

                    if ( pa ) {
                        for ( j=0; j<cntAllocated; j++ ) {
                            tmpArray[j].Name = pa[j].Name;
                            tmpArray[j].Len = pa[j].Len;
                            tmpArray[j].bFree = pa[j].bFree;
                        }
                        ScepFree(pa);
                    }
                    pa = tmpArray;
                    tmpArray = NULL;


                    cntAllocated += 16;

                } else {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }
            }

            if ( LsaPolicy && wcschr(pName->Name, L'\\') ) {

                //
                // check if the name has a '\' in it, it should be translated to
                // *SID
                //
                pTemp = NULL;
                ScepConvertNameToSidString(LsaPolicy, pName->Name, FALSE, &pTemp, &Len);

                if ( pTemp ) {
                    pa[i].Name = pTemp;
                    pa[i].bFree = TRUE;
                } else {
                    pa[i].Name = pName->Name;
                    pa[i].bFree = FALSE;
                    Len= wcslen(pName->Name);
                }

            }

            else if (dwWriteOption & SCE_WRITE_LOCAL_TABLE &&
                     ScepLookupWellKnownName( 
                        pName->Name, 
                        LsaPolicy,
                        &SidString ) ) {

                pa[i].Name = SidString;
                pa[i].bFree = TRUE;
                Len = wcslen(SidString);

            }

            else {
                pa[i].Name = pName->Name;
                pa[i].bFree = FALSE;
                Len = wcslen(pName->Name);
            }
            pa[i].Len = Len;

            TotalSize += Len + 1;
            i++;
        } else {

            TotalSize += wcslen(pName->Name)+1;
        }
    }

    TotalSize ++;

    if ( SCESTATUS_SUCCESS == rc ) {

        if ( TotalSize > 1 ) {
            Value = (PWSTR)ScepAlloc( 0, (TotalSize+1)*sizeof(WCHAR));
            if ( Value == NULL )
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        if ( TotalSize > 1 ) {

            pTemp = Value;

            if ( dwWriteOption & SCE_WRITE_CONVERT ) {

                for (j=0; j<i; j++) {
                    if ( pa[j].Name ) {

                        if ( Status == 3 ) {
                            ScepLogOutput2(2, 0, pa[j].Name);
                        }

                        wcsncpy(pTemp, pa[j].Name, pa[j].Len);
                        pTemp += pa[j].Len;
                        *pTemp = L'\0';
                        pTemp++;
                    }
                }

            } else {

                for ( pName=NameList; pName != NULL; pName = pName->Next ) {

                    if ( pName->Name == NULL ) {
                        continue;
                    }
                    if ( Status == 3 ) {
                        ScepLogOutput2(2, 0, pName->Name);
                    }

                    Len = wcslen(pName->Name);
                    wcsncpy(pTemp, pName->Name, Len);
                    pTemp += Len;
                    *pTemp = L'\0';
                    pTemp++;
                }
            }

            *pTemp = L'\0';

        } else
            TotalSize = 0;

        if ( TotalSize > 0 || (dwWriteOption & SCE_WRITE_EMPTY_LIST) ) {
            rc = SceJetSetLine(
                        hSection,
                        Name,
                        FALSE,
                        Value,
                        TotalSize*sizeof(WCHAR),
                        0
                        );

            switch ( Status ) {
            case 1:
                ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
                break;
            case 3:  // no analyze, already printed
                break;

            case 2:
                ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
                break;
            }

#ifdef SCE_DBG
            if ( Value != NULL )
                wprintf(L"rc=%d, Section: %d, %s=%s\n", rc, (DWORD)(hSection->SectionID), Name, Value);
            else
                wprintf(L"rc=%d, Section: %d, %s=", rc, (DWORD)(hSection->SectionID), Name);
#endif
        }

        if ( Value != NULL )
            ScepFree(Value);
    }

    if ( pa ) {

        for ( j=0; j<i; j++ ) {
            if ( pa[j].Name && pa[j].bFree ) {
                ScepFree(pa[j].Name);
            }
        }
        ScepFree(pa);
    }

    return(rc);
}


SCESTATUS
ScepWriteNameStatusListValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSCE_NAME_STATUS_LIST NameList,
    IN BOOL SaveEmptyList,
    IN INT Status
    )
/* ++
Routine Description:

    This routine writes a key with a list of values to the JET section. The list
    of values is saved in a MULTI-SZ format which is separated by a NULL char and
    terminated by 2 NULLs. If the list is NULL, nothing is saved unless
    SaveEmptyList is set to TRUE, where a NULL value is saved with the key.

    The format in each string in the MULTI-SZ value is a 2 bytes Status field
    followed by the Name field. This structure is primarily used for privileges

Arguments:

    hSection - the JET hsection handle

    Name - The key name

    NameList - the list of values

    SaveEmptyList - TRUE = save NULL value if the list is empty
                    FALSE = DO NOT save if the list is empty

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE

    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS    rc=SCESTATUS_SUCCESS;
    DWORD       TotalSize=0;
    PWSTR       Value=NULL;
    PSCE_NAME_STATUS_LIST pName;
    PWSTR       pTemp=NULL;
    DWORD       Len;


    for ( pName=NameList; pName != NULL; pName = pName->Next ) {
        //
        // Privilege value is stored in 2 bytes
        //
        TotalSize += 2;
        if ( pName->Name != NULL)
            TotalSize += wcslen(pName->Name);
        TotalSize ++;
    }
    TotalSize ++;

    if ( TotalSize > 1 ) {
        Value = (PWSTR)ScepAlloc( 0, (TotalSize+1)*sizeof(WCHAR));
        if ( Value == NULL )
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        pTemp = Value;
        for ( pName=NameList; pName != NULL; pName = pName->Next ) {
            swprintf(pTemp, L"%02d", pName->Status);
            pTemp += 2;
            if ( pName->Name != NULL ) {
                Len = wcslen(pName->Name);
                wcsncpy(pTemp, pName->Name, Len);
                pTemp += Len;
            }
            *pTemp = L'\0';
            pTemp++;
        }
        *pTemp = L'\0';

    } else
        TotalSize = 0;

    if ( TotalSize > 0 || SaveEmptyList ) {
        rc = SceJetSetLine(
                    hSection,
                    Name,
                    FALSE,
                    Value,
                    TotalSize*sizeof(WCHAR),
                    0
                    );

        if ( Status == 1 )
            ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
        else if ( Status == 2 ) {
            ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
        }

#ifdef SCE_DBG
        wprintf(L"rc=%d, Section: %d, %s=%s\n", rc, (DWORD)(hSection->SectionID), Name, Value);
#endif
        if ( Value != NULL )
            ScepFree(Value);
    }

    return(rc);
}


SCESTATUS
ScepWriteSecurityDescriptorValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo
    )
/* ++
Routine Description:

    This routine writes a key with security descriptor value to the JET section.
    The security descriptor is converted into text format based on the secrurity
    information passed in.

Arguments:

    hSection - the JET hsection handle

    Name - The key name

    pSD  - The security descriptor

    SeInfo - the part of the security information to save

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE

    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS rc=SCESTATUS_SUCCESS;
    PWSTR SDspec=NULL;
    ULONG SDsize = 0;


    if ( hSection == NULL || Name == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pSD != NULL && SeInfo != 0 ) {

        rc = ConvertSecurityDescriptorToText (
                    pSD,
                    SeInfo,
                    &SDspec,
                    &SDsize
                    );
        if ( rc == NO_ERROR ) {
            rc = ScepCompareAndSaveStringValue(
                        hSection,
                        Name,
                        NULL,
                        SDspec,
                        SDsize*sizeof(WCHAR)
                        );
            ScepFree(SDspec);
        }
    }
#ifdef SCE_DBG
    wprintf(L"SD==>rc=%d, Section: %d, %s\n", rc, (DWORD)(hSection->SectionID), Name);
#endif
    return(rc);
}


SCESTATUS
ScepDuplicateTable(
    IN PSCECONTEXT hProfile,
    IN SCEJET_TABLE_TYPE TableType,
    IN LPSTR DupTableName,
    OUT PSCE_ERROR_LOG_INFO *pErrlog
    )
/* ++
Routine Description:

    This routine copies table structure and data from a SCP/SMP/SAP table to
    a table specified by DupTableName. This is used for the SAP table backup.

Arguments:

    hProfile - the JET database handle

    TableType - the table type -SCEJET_TABLE_SCP
                                SCEJET_TABLE_SAP
                                SCEJET_TABLE_SMP

    DupTableName - The new table's name

    pErrlog - the error list

Return Value:

    SCESTATUS_SUCCESS

-- */
{
    JET_ERR     JetErr;
    SCESTATUS    rc;

    SCECONTEXT   hProfile2;
    PSCESECTION  hSection1=NULL;
    PSCESECTION  hSection2=NULL;

    DOUBLE      SectionID=0, SaveID=0;
    DWORD       Actual;

    PWSTR       KeyName=NULL;
    PWSTR       Value=NULL;
    DWORD       KeyLen=0;
    DWORD       ValueLen=0;


    if ( hProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // Create a SCP section handle. the section ID is a dummy one
    //
    rc = SceJetOpenSection(
                hProfile,
                (DOUBLE)1,
                TableType,
                &hSection1
                );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc), pErrlog,
                              SCEERR_OPEN, L"SectionID 1");
        return(rc);
    }

    memset(&hProfile2, '\0', sizeof(SCECONTEXT));

    hProfile2.JetSessionID = hProfile->JetSessionID;
    hProfile2.JetDbID = hProfile->JetDbID;

    //
    // Delete the dup table then create it
    //
    SceJetDeleteTable(
            &hProfile2,
            DupTableName,
            TableType
            );
    rc = SceJetCreateTable(
            &hProfile2,
            DupTableName,
            TableType,
            SCEJET_CREATE_IN_BUFFER,
            NULL,
            NULL
            );
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc), pErrlog,
                               SCEERR_CREATE, L"backup table");
        goto Cleanup;
    }
    //
    // Move to the first line of the SCP table
    //
    JetErr = JetMove(hSection1->JetSessionID, hSection1->JetTableID, JET_MoveFirst, 0);

    while (JetErr == SCESTATUS_SUCCESS ) {

        //
        // get section ID
        //
        JetErr = JetRetrieveColumn(
                    hSection1->JetSessionID,
                    hSection1->JetTableID,
                    hSection1->JetColumnSectionID,
                    (void *)&SectionID,
                    8,
                    &Actual,
                    0,
                    NULL
                    );

        if ( JetErr != JET_errSuccess ) {
            ScepBuildErrorLogInfo( ERROR_READ_FAULT, pErrlog,
                                  SCEERR_QUERY_INFO,
                                  L"sectionID");
            rc = SceJetJetErrorToSceStatus(JetErr);
            break;
        }
#ifdef SCE_DBG
    printf("SectionID=%d, JetErr=%d\n", (DWORD)SectionID, JetErr);
#endif
        //
        // Prepare this Scep section
        //
        if ( SectionID != SaveID ) {
            SaveID = SectionID;
            //
            // Prepare this section
            //
            rc = SceJetOpenSection(
                        &hProfile2,
                        SectionID,
                        TableType,
                        &hSection2
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc), pErrlog,
                                     SCEERR_OPEN_ID,
                                     (DWORD)SectionID);
                break;
            }
        }

        //
        // get buffer size for key and value
        //
        rc = SceJetGetValue(
                    hSection1,
                    SCEJET_CURRENT,
                    NULL,
                    NULL,
                    0,
                    &KeyLen,
                    NULL,
                    0,
                    &ValueLen);

        if ( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                  SCEERR_QUERY_VALUE, L"current row");
            break;
        }

        //
        // allocate memory
        //
        if ( KeyLen > 0 ) {
            KeyName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, KeyLen+2);
            if ( KeyName == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                break;
            }
        }
        if ( ValueLen > 0 ) {
            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);
            if ( Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                break;
            }
        }
        //
        // get key and value
        //
        rc = SceJetGetValue(
                    hSection1,
                    SCEJET_CURRENT,
                    NULL,
                    KeyName,
                    KeyLen,
                    &KeyLen,
                    Value,
                    ValueLen,
                    &ValueLen);

        if ( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                  SCEERR_QUERY_VALUE,
                                  L"current row");
            break;
        }
#ifdef SCE_DBG
wprintf(L"\t%s=%s, rc=%d\n", KeyName, Value, rc);
#endif
        //
        // set this line to the dup table
        //
        rc = SceJetSetLine(
                    hSection2,
                    KeyName,
                    TRUE,
                    Value,
                    ValueLen,
                    0
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                 SCEERR_WRITE_INFO,
                                 KeyName);
            break;
        }
        ScepFree(KeyName);
        KeyName = NULL;

        ScepFree(Value);
        Value = NULL;

        //
        // Move to next line in the SCP table
        //
        JetErr = JetMove(hSection1->JetSessionID, hSection1->JetTableID, JET_MoveNext, 0);

    }

Cleanup:
    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // error occurs. Clean up the dup table
        //
#ifdef SCE_DBG
        printf("Error occurs. delete the dup table.\n");
#endif
        SceJetDeleteTable(
            &hProfile2,
            DupTableName,
            TableType
            );
    }

    if ( KeyName != NULL )
        ScepFree(KeyName);

    if ( Value != NULL )
        ScepFree(Value);

    SceJetCloseSection(&hSection1, TRUE);
    SceJetCloseSection(&hSection2, TRUE);

    return(rc);

}


SCESTATUS
ScepAddToPrivList(
    IN PSCE_NAME_STATUS_LIST *pPrivList,
    IN DWORD Rights,
    IN PWSTR Name,
    IN DWORD Len
    )
/* ++
Routine Description:

    This routine adds a privilege with optional group name to the list of
    privilege assignments

Arguments:

    pPrivList - the privilege list to add to. The structure of this list is
                    Status -- The privilege value
                    Name   -- The group's name where the priv is assigned
                              if Name is NULL, the privilege is directly assigned

    Rights    - The privilege(s) assigned through group Name

    Name      - The group's name

    Len       - The group's name length

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_NOT_ENOUGH_RESOURCE

-- */
{
    PSCE_NAME_STATUS_LIST pTemp;
    LONG                i;


    if ( pPrivList == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    for ( i=31; i>=0; i-- )
        if ( Rights & (1 << i) ) {
            for ( pTemp=*pPrivList; pTemp != NULL; pTemp = pTemp->Next ) {
                if ( (DWORD)i == pTemp->Status )
                    break;

            }
            if ( pTemp == NULL ) {
                //
                // add this one
                //
                pTemp = (PSCE_NAME_STATUS_LIST)ScepAlloc( LMEM_ZEROINIT, sizeof(SCE_NAME_STATUS_LIST));
                if ( pTemp == NULL )
                    return(SCESTATUS_NOT_ENOUGH_RESOURCE);

                if ( Name != NULL && Len > 0 ) {
                    pTemp->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Len+1)*sizeof(WCHAR));
                    if ( pTemp->Name == NULL) {
                        ScepFree(pTemp);
                        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
                    }
                    wcsncpy(pTemp->Name, Name, Len);
                }
#ifdef SCE_DBG
                wprintf(L"Add %d %s to privilege list\n", i, pTemp->Name);
#endif

                pTemp->Status = i;

                pTemp->Next = *pPrivList;
                *pPrivList = pTemp;
                pTemp = NULL;
            }
        }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepOpenPrevPolicyContext(
    IN PSCECONTEXT hProfile,
    OUT PSCECONTEXT *phPrevProfile
    )
{

    if ( hProfile == NULL || phPrevProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }


    *phPrevProfile = (PSCECONTEXT)LocalAlloc( LMEM_ZEROINIT, sizeof(SCECONTEXT));
    if ( *phPrevProfile == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    memcpy( *phPrevProfile, hProfile, sizeof(SCECONTEXT));

    DWORD ScpType = hProfile->Type;
    (*phPrevProfile)->Type &= ~(SCEJET_MERGE_TABLE_2 | SCEJET_MERGE_TABLE_1);

    SCESTATUS rc;
    //
    // now open the previous policy table
    //
    if ( ( ScpType & SCEJET_MERGE_TABLE_2 ) ) {
        //
        // the second table is the current one
        // so the first table is the previous one
        //
        rc = SceJetOpenTable(
                        *phPrevProfile,
                        "SmTblScp",
                        SCEJET_TABLE_SCP,
                        SCEJET_OPEN_READ_ONLY,
                        NULL
                        );
        (*phPrevProfile)->Type |= SCEJET_MERGE_TABLE_1;

    } else {
        rc = SceJetOpenTable(
                        *phPrevProfile,
                        "SmTblScp2",
                        SCEJET_TABLE_SCP,
                        SCEJET_OPEN_READ_ONLY,
                        NULL
                        );
        (*phPrevProfile)->Type |= SCEJET_MERGE_TABLE_2;
    }
/*
    if (  SCESTATUS_SUCCESS == rc ) {

        JET_COLUMNID  ColGpoID = (JET_COLUMNID)JET_tableidNil;
        JET_ERR       JetErr;
        JET_COLUMNDEF ColumnGpoIDDef;

        JetErr = JetGetTableColumnInfo(
                        (*phPrevProfile)->JetSessionID,
                        (*phPrevProfile)->JetScpID,
                        "GpoID",
                        (VOID *)&ColumnGpoIDDef,
                        sizeof(JET_COLUMNDEF),
                        JET_ColInfo
                        );
        if ( JET_errSuccess == JetErr ) {
            ColGpoID = ColumnGpoIDDef.columnid;

        } // else ignore error

        // temp storage for the column ID
        (*phPrevProfile)->JetSapValueID = ColGpoID;

    }
*/
    if ( rc != SCESTATUS_SUCCESS ) {

        LocalFree(*phPrevProfile);
        *phPrevProfile = NULL;
    }

    return(rc);
}

SCESTATUS
ScepClosePrevPolicyContext(
    IN OUT PSCECONTEXT *phProfile
    )
{
    if ( phProfile && *phProfile ) {

        //
        // just free the table because all other info are copied from the
        // current policy context and will be freed there
        //

        if ( (*phProfile)->JetScpID != JET_tableidNil ) {

            if ( (*phProfile)->JetScpID != (*phProfile)->JetSmpID ) {
                JetCloseTable(
                            (*phProfile)->JetSessionID,
                            (*phProfile)->JetScpID
                            );
            }
        }

        LocalFree(*phProfile);
        *phProfile = NULL;
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepCopyLocalToMergeTable(
    IN PSCECONTEXT hProfile,
    IN DWORD Options,
    IN DWORD CopyOptions,
    OUT PSCE_ERROR_LOG_INFO *pErrlog
    )
/* ++
Routine Description:

    This routine populate data from SCP table into SMP table. All data except
    those in the account profiles section(s) in SCP table will be copied over
    to SMP table. Account profiles section is converted into User List section
    format.

Arguments:

    hProfile - the JET database handle

Return Value:

    SCESTATUS_SUCCESS

-- */
{
    JET_ERR     JetErr;
    SCESTATUS    rc;

    PSCESECTION  hSectionScp=NULL;
    PSCESECTION  hSectionSmp=NULL;
    PSCESECTION  hSectionPrevScp=NULL;
    PSCECONTEXT  hPrevProfile=NULL;
    DOUBLE      SectionID=0, SavedID=0;
    DWORD       Actual;
    BOOL        bCopyIt=FALSE;
    BOOL        bCopyThisLine;
    BOOL        bConvert=FALSE; // to convert privilege accounts

    PWSTR       KeyName=NULL;
    PWSTR       Value=NULL;
    DWORD       KeyLen=0;
    DWORD       ValueLen=0;

    WCHAR            SectionName[256];

    if ( hProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( hProfile->JetScpID == hProfile->JetSmpID ) {
        // if it's the same table, return - shouldn't happen
        return(SCESTATUS_SUCCESS);
    }

    if ( hProfile->JetSapID == JET_tableidNil ) {
        // tattoo table doesn't exist, return - shouldn't happen
        return(SCESTATUS_SUCCESS);
    }

    //
    // get previous policy propagation info (if any)
    //

    if ( !(CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ) {
        rc = ScepOpenPrevPolicyContext(hProfile, &hPrevProfile);
        if ( SCESTATUS_RECORD_NOT_FOUND == rc ||
             SCESTATUS_PROFILE_NOT_FOUND == rc ) {
            //
            // the table doesn't exist - no previous policy prop
            // do not need to copy anything, just quit
            //
            return(SCESTATUS_SUCCESS);
        }
    }

    //
    // Create a SMP section handle. the section ID is a dummy one
    //
    rc = SceJetOpenSection(
                hProfile,
                (DOUBLE)1,
                (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ? SCEJET_TABLE_SMP : SCEJET_TABLE_TATTOO,
                &hSectionSmp
                );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc), pErrlog,
                              SCEERR_OPEN,
                              (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ? L"SMP" : L"TATTOO");

        if (hPrevProfile) ScepClosePrevPolicyContext(&hPrevProfile);

        return(rc);
    }

    LSA_HANDLE  LsaPolicy=NULL;
    PWSTR       pszNewValue=NULL;
    DWORD       NewLen=0;

    //
    // Move to the first line of the SCP table
    //
    JetErr = JetMove(hSectionSmp->JetSessionID, hSectionSmp->JetTableID, JET_MoveFirst, 0);

    while (JetErr == SCESTATUS_SUCCESS ) {
        //
        // get section ID
        //
        JetErr = JetRetrieveColumn(
                    hSectionSmp->JetSessionID,
                    hSectionSmp->JetTableID,
                    hSectionSmp->JetColumnSectionID,
                    (void *)&SectionID,
                    8,
                    &Actual,
                    0,
                    NULL
                    );

        if ( JetErr != JET_errSuccess ) {
            ScepBuildErrorLogInfo( ERROR_READ_FAULT, pErrlog,
                                   SCEERR_QUERY_INFO, L"sectionID");
            rc = SceJetJetErrorToSceStatus(JetErr);
            break;
        }
#ifdef SCE_DBG
    printf("SectionID=%d, JetErr=%d\n", (DWORD)SectionID, JetErr);
#endif
        if ( SectionID != SavedID ) {
            //
            // a new section. Look for the section's name to see if this section
            // is to be converted
            //
            SavedID = SectionID;

            Actual = 510;

            memset(SectionName, '\0', 512);
            rc = SceJetGetSectionNameByID(
                        hProfile,
                        SectionID,
                        SectionName,
                        &Actual
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo( ERROR_BAD_FORMAT, pErrlog,
                                     SCEERR_CANT_FIND_SECTION,
                                     (DWORD)SectionID
                                     );
                break;
            }
            if ( Actual > 0 )
                SectionName[Actual/sizeof(TCHAR)] = L'\0';
#ifdef SCE_DBG
    wprintf(L"SectionName=%s\n", SectionName);
#endif
            //
            // Compare section name with domain sections to convert
            //

            bCopyIt = TRUE;
            bConvert = FALSE;

            if ( (CopyOptions & SCE_LOCAL_POLICY_DC) ) {

                //
                // do not copy user rights if it's on a domain controller
                //
                if ( _wcsicmp(szPrivilegeRights, SectionName) == 0 ||
                     _wcsicmp(szSystemAccess, SectionName) == 0 ||
                     _wcsicmp(szKerberosPolicy, SectionName) == 0 ||
                     _wcsicmp(szAuditEvent, SectionName) == 0 ||
                    _wcsicmp(szGroupMembership, SectionName) == 0 ) {
                    bCopyIt = FALSE;

                } else if ( (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ) {
                    //
                    // migrate registry values only
                    //
                    if ( _wcsicmp(szRegistryValues, SectionName) != 0 )
                        bCopyIt = FALSE;
                }

            } else if ( (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ) {

                //
                // non DCs, should migrate all local policies
                //
                if ( _wcsicmp(szPrivilegeRights, SectionName) == 0 ) {
                    bConvert = TRUE;
                } else if ( (_wcsicmp(szSystemAccess, SectionName) != 0) &&
                            (_wcsicmp(szKerberosPolicy, SectionName) != 0) &&
                            (_wcsicmp(szRegistryValues, SectionName) != 0) &&
                            (_wcsicmp(szAuditEvent, SectionName) != 0) ) {
                    bCopyIt = FALSE;
                }
            }

/*
            if ( ( Options & SCE_NOCOPY_DOMAIN_POLICY) &&
                 ( (_wcsicmp(szSystemAccess, SectionName) == 0) ||
                   (_wcsicmp(szKerberosPolicy, SectionName) == 0) ) ) {

                bCopyIt = FALSE;

            } else if ( (_wcsicmp(szGroupMembership, SectionName) == 0) ||
                        (_wcsicmp(szRegistryKeys, SectionName) == 0) ||
                        (_wcsicmp(szFileSecurity, SectionName) == 0) ||
                        (_wcsicmp(szServiceGeneral, SectionName) == 0) ||
                        (_wcsicmp(szAuditApplicationLog, SectionName) == 0) ||
                        (_wcsicmp(szAuditSecurityLog, SectionName) == 0) ||
                        (_wcsicmp(szAuditSystemLog, SectionName) == 0) ||
                        (_wcsicmp(szAttachments, SectionName) == 0) ||
                        (_wcsicmp(szDSSecurity, SectionName) == 0)
                      ) {
                // do not copy areas other than account policy and local policy
                bCopyIt = FALSE;

            } else {

                bCopyIt = TRUE;
*/
            if ( bCopyIt ) {
                //
                // Prepare this Scep section
                //
                rc = SceJetOpenSection(
                            hProfile,
                            SectionID,
                            (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ? SCEJET_TABLE_TATTOO : SCEJET_TABLE_SCP,
                            &hSectionScp
                            );
                if ( rc != SCESTATUS_SUCCESS ) {
                    ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc), pErrlog,
                                         SCEERR_OPEN_ID,
                                         (DWORD)SectionID);
                    break;
                }

                if ( (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ) {
                    //
                    // open current policy propagation table
                    // do not care error here
                    //
                    SceJetOpenSection(
                            hProfile,
                            SectionID,
                            SCEJET_TABLE_SCP,
                            &hSectionPrevScp
                            );
/*              // should always copy tattoo value to the merged table
                // even if the setting doesn't exist in previous policy prop
                // this is to handle the dependent settings such as
                // retention perild and retention days
                } else if ( hPrevProfile ) {
                    //
                    // open previous policy propagation table
                    // do not care error here
                    //

                    SceJetOpenSection(
                            hPrevProfile,
                            SectionID,
                            SCEJET_TABLE_SCP,
                            &hSectionPrevScp
                            );
*/
                }
            }

        }

        if ( bCopyIt ) {
            //
            // get buffer size for key and value
            //
            rc = SceJetGetValue(
                        hSectionSmp,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        &KeyLen,
                        NULL,
                        0,
                        &ValueLen);

            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                      SCEERR_QUERY_VALUE, L"current row");
                break;
            }

            //
            // allocate memory
            //
            if ( KeyLen > 0 ) {
                KeyName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, KeyLen+2);
                if ( KeyName == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }
            }
            if ( ValueLen > 0 ) {
                Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);
                if ( Value == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }
            }
            //
            // get key and value
            //
            rc = SceJetGetValue(
                        hSectionSmp,
                        SCEJET_CURRENT,
                        NULL,
                        KeyName,
                        KeyLen,
                        &KeyLen,
                        Value,
                        ValueLen,
                        &ValueLen);

            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                      SCEERR_QUERY_VALUE, L"current row");
                break;
            }
#ifdef SCE_DBG
    wprintf(L"\t%s=%s, rc=%d\n", KeyName, Value, rc);
#endif
            bCopyThisLine = TRUE;

            //
            // check if this key exist in the previous prop
            //
            if ( hSectionPrevScp ) {

                rc = SceJetSeek(
                            hSectionPrevScp,
                            KeyName,
                            KeyLen,
                            SCEJET_SEEK_EQ_NO_CASE
                            );
                if ( SCESTATUS_RECORD_NOT_FOUND == rc ||
                     (hSectionPrevScp->JetColumnGpoID == 0) ) {

                    bCopyThisLine = FALSE;

                } else if ( SCESTATUS_SUCCESS == rc && (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ) {
                    //
                    // found. Let's check if this setting was from a GPO
                    // if in migration (build tattoo), a setting was not
                    // defined in GPO doesn't need a tattoo value
                    //
                    // for policy prop case, there may be undo settings in
                    // previous policy prop and they weren't reset successfully
                    // in previous prop. In this case, we still want to continue
                    // reset these settings. So these settings should be copied
                    // from the tattoo table to this policy table regardless if
                    // there is a domain setting defined for it in the previous
                    // policy propagation.
                    //
                    LONG GpoID = 0;

                    (void)JetRetrieveColumn(
                                hSectionPrevScp->JetSessionID,
                                hSectionPrevScp->JetTableID,
                                hSectionPrevScp->JetColumnGpoID,
                                (void *)&GpoID,
                                4,
                                &Actual,
                                0,
                                NULL
                                );

                    if ( GpoID == 0 ) {
                        //
                        // this is not a setting from a GPO
                        //
                        bCopyThisLine = FALSE;
                    }
                }
                rc = SCESTATUS_SUCCESS;
            }

            if ( bCopyThisLine ) {

                // Ignore tattoo memberof entries, but leave an empty
                // value so that group membership processing code can detect
                // there is an entry in tattoo table.

                if(NULL != Value &&
                   _wcsicmp(szGroupMembership, SectionName) == 0 &&
                   ScepWcstrr(KeyName, szMemberof) &&
                   !(CopyOptions & SCE_LOCAL_POLICY_MIGRATE)) 
                {
                    *Value = L'\0';
                    ValueLen = sizeof(WCHAR);
                }

                if ( bConvert ) {

                    rc = ScepConvertFreeTextAccountToSid(
                                &LsaPolicy,
                                Value,
                                ValueLen/sizeof(WCHAR),
                                &pszNewValue,
                                &NewLen
                                );

                    if ( rc == SCESTATUS_SUCCESS &&
                         pszNewValue ) {

                        ScepFree(Value);
                        Value = pszNewValue;
                        ValueLen = NewLen*sizeof(WCHAR);

                        pszNewValue = NULL;
                    } // if failed to convert, just use the name format
                }

                //
                // Process group membership section and restore any relative SIDs "#-RSID" to
                // "*S-domain SID-RSID". Do not apply during upgrade.
                //
                if ( _wcsicmp(szGroupMembership, SectionName) == 0 &&
                    !(CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ) {
                    rc = ScepConvertRelativeSidAccountToSid(
                                &LsaPolicy,
                                Value,
                                ValueLen/sizeof(WCHAR),
                                &pszNewValue,
                                &NewLen
                                );

                    if ( rc == SCESTATUS_SUCCESS &&
                         pszNewValue ) {

                        ScepFree(Value);
                        Value = pszNewValue;
                        ValueLen = NewLen*sizeof(WCHAR);

                        pszNewValue = NULL;
                    }
                }

                //
                // set this line to the SCP table
                //
                rc = SceJetSetLine(
                            hSectionScp,
                            KeyName,
                            TRUE,
                            Value,
                            ValueLen,
                            0
                            );
                if ( rc != SCESTATUS_SUCCESS ) {
                    ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                          SCEERR_WRITE_INFO,
                                         KeyName);
                    break;
                }
            }

            ScepFree(KeyName);
            KeyName = NULL;

            ScepFree(Value);
            Value = NULL;

        }
        //
        // Move to next line in the SCP table
        //
        JetErr = JetMove(hSectionSmp->JetSessionID, hSectionSmp->JetTableID, JET_MoveNext, 0);

    }


    if ( KeyName != NULL )
        ScepFree(KeyName);

    if ( Value != NULL )
        ScepFree(Value);

    SceJetCloseSection(&hSectionScp, TRUE);
    SceJetCloseSection(&hSectionSmp, TRUE);
    if ( hSectionPrevScp ) {
        SceJetCloseSection(&hSectionPrevScp, TRUE);
    }

    if (hPrevProfile)
        ScepClosePrevPolicyContext(&hPrevProfile);

    if ( LsaPolicy ) {
        LsaClose(LsaPolicy);
    }

    return(rc);

}


SCESTATUS
ScepWriteObjectSecurity(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PSCE_OBJECT_SECURITY ObjSecurity
    )
/*
    Get security for a single object
*/
{
    SCESTATUS        rc;
    PCWSTR          SectionName=NULL;
    PSCESECTION      hSection=NULL;
    DWORD           SDsize, Win32Rc;
    PWSTR           SDspec=NULL;

    if ( hProfile == NULL ||
         ObjSecurity == NULL ||
         ObjSecurity->Name == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    switch (Area) {
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        break;
    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        break;
#if 0
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        break;
#endif
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = ScepOpenSectionForName(
                hProfile,
                ProfileType,
                SectionName,
                &hSection
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // convert security descriptor
        //
        Win32Rc = ConvertSecurityDescriptorToText (
                            ObjSecurity->pSecurityDescriptor,
                            ObjSecurity->SeInfo,
                            &SDspec,
                            &SDsize
                            );

        if ( Win32Rc == NO_ERROR ) {

            if ( Area == AREA_DS_OBJECTS ) {
                //
                // ds needs to convert name
                //
                rc = ScepDosErrorToSceStatus(
                         ScepSaveDsStatusToSection(
                               ObjSecurity->Name,
                               ObjSecurity->IsContainer,
                               ObjSecurity->Status,
                               SDspec,
                               SDsize
                               ) );
            } else {
                rc = ScepSaveObjectString(
                            hSection,
                            ObjSecurity->Name,
                            ObjSecurity->IsContainer,
                            ObjSecurity->Status,
                            SDspec,
                            SDsize
                            );
            }
        } else
            rc = ScepDosErrorToSceStatus(Win32Rc);
    }

    SceJetCloseSection( &hSection, TRUE);

    if (SDspec)
        ScepFree(SDspec);

    return(rc);
}

SCESTATUS
ScepTattooCheckAndUpdateArray(
    IN OUT SCE_TATTOO_KEYS *pTattooKeys,
    IN OUT DWORD *pcTattooKeys,
    IN PWSTR KeyName,
    IN DWORD ConfigOptions,
    IN DWORD dwValue
    )
/*
Description:

    Add a new entry into the array which holds system (tatto) values for the settings

    The input/output buffer pTattooKeys is allocated outside this routine.

*/
{
    if ( pTattooKeys == NULL || pcTattooKeys == NULL ||
         KeyName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !(ConfigOptions & SCE_POLICY_TEMPLATE) ) {
        return(SCESTATUS_SUCCESS);
    }

    pTattooKeys[*pcTattooKeys].KeyName = KeyName;
    pTattooKeys[*pcTattooKeys].KeyLen = wcslen(KeyName);
    pTattooKeys[*pcTattooKeys].DataType = 'D';
    pTattooKeys[*pcTattooKeys].SaveValue = dwValue;
    pTattooKeys[*pcTattooKeys].Value = NULL;

//    ScepLogOutput3(3,0, SCESRV_POLICY_TATTOO_ADD, KeyName, *pcTattooKeys);

    (*pcTattooKeys)++;

    return(SCESTATUS_SUCCESS);
}

SCESTATUS
ScepTattooOpenPolicySections(
    IN PSCECONTEXT hProfile,
    IN PCWSTR SectionName,
    OUT PSCESECTION *phSectionDomain,
    OUT PSCESECTION *phSectionTattoo
    )
/*
Open the table/sections for the merged policy and the undo settings
*/
{

    if ( hProfile == NULL || SectionName == NULL ||
         phSectionDomain == NULL || phSectionTattoo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rCode;
    DOUBLE SectionID;

    *phSectionDomain = NULL;
    *phSectionTattoo = NULL;

    //
    // open the section for both tattoo table and effective policy table
    // get section id first
    //
    rCode = SceJetGetSectionIDByName(
                hProfile,
                SectionName,
                &SectionID
                );
    if ( rCode == SCESTATUS_SUCCESS ) {

        // open effective policy table
        rCode = SceJetOpenSection(
                    hProfile,
                    SectionID,
                    SCEJET_TABLE_SCP,
                    phSectionDomain
                    );
        if ( rCode == SCESTATUS_SUCCESS ) {

            // open tattoo table
            rCode = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        SCEJET_TABLE_TATTOO,
                        phSectionTattoo
                        );
            if ( rCode != SCESTATUS_SUCCESS ) {

                SceJetCloseSection(phSectionDomain, TRUE);
                *phSectionDomain = NULL;
            }
        }
    }

    //
    // log tattoo process
    //
    if ( rCode != 0 )
        ScepLogOutput3(1, 0,
                   SCESRV_POLICY_TATTOO_PREPARE,
                   ScepSceStatusToDosError(rCode),
                   SectionName);

    return(rCode);
}

SCESTATUS
ScepTattooManageOneStringValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN PWSTR Value,
    IN DWORD ValueLen,
    IN DWORD rc
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         KeyName == NULL || Value == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    PWSTR pNewValue=NULL;
    DWORD NewLen=ValueLen;
    SCESTATUS  rCode;

    if (Value && (ValueLen == 0) ) NewLen = wcslen(Value);

    if ( NewLen ) {
        //
        // the buffer passed may not be NULL terminated
        //
        pNewValue = (PWSTR)ScepAlloc(LPTR,(NewLen+1)*sizeof(WCHAR));
        if ( pNewValue == NULL ) return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        wcsncpy(pNewValue, Value, NewLen);
    }

    SCE_TATTOO_KEYS theKey;
    theKey.KeyName = KeyName;
    theKey.KeyLen = (KeyLen == 0) ? wcslen(KeyName) : KeyLen;
    theKey.Value = pNewValue;
    theKey.SaveValue = NewLen;
    theKey.DataType = 'S';

    rCode = ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc);

    if ( pNewValue ) ScepFree(pNewValue);

    return(rCode);
}

SCESTATUS
ScepTattooManageOneIntValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN DWORD Value,
    IN DWORD rc
    )
{

    if ( hSectionDomain == NULL || hSectionTattoo == NULL || KeyName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    SCE_TATTOO_KEYS theKey;
    theKey.KeyName = KeyName;
    theKey.KeyLen = (KeyLen == 0) ? wcslen(KeyName) : KeyLen;
    theKey.SaveValue = Value;
    theKey.DataType = 'D';
    theKey.Value = NULL;

    return(ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc));

}

SCESTATUS
ScepTattooManageOneIntValueWithDependency(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR DependentKeyName,
    IN DWORD DependentKeyLen OPTIONAL,
    IN PWSTR SaveKeyName,
    IN DWORD Value,
    IN DWORD rc
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         SaveKeyName == NULL || DependentKeyName == NULL)
        return(SCESTATUS_INVALID_PARAMETER);

    SCE_TATTOO_KEYS theKey;
    theKey.KeyName = DependentKeyName;
    theKey.KeyLen = (DependentKeyLen == 0) ? wcslen(DependentKeyName) : DependentKeyLen;
    theKey.SaveValue = Value;
    theKey.DataType = 'L';
    theKey.Value = SaveKeyName;

    return(ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc));

}

SCESTATUS
ScepTattooManageOneRegistryValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN PSCE_REGISTRY_VALUE_INFO pOneRegValue,
    IN DWORD rc
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         KeyName == NULL || pOneRegValue == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    SCESTATUS  rCode;


    SCE_TATTOO_KEYS theKey;
    theKey.KeyName = KeyName;
    theKey.KeyLen = (KeyLen == 0) ? wcslen(KeyName) : KeyLen;
    theKey.Value = (PWSTR)pOneRegValue;
    theKey.SaveValue = 0;
    theKey.DataType = 'R';

    rCode = ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc);

    return(rCode);
}

SCESTATUS
ScepTattooManageOneMemberListValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR GroupName,
    IN DWORD GroupLen OPTIONAL,
    IN PSCE_NAME_LIST pNameList,
    IN BOOL bDeleteOnly,
    IN DWORD rc
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         GroupName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    SCESTATUS  rCode;
    SCE_TATTOO_KEYS theKey;
    DWORD Len=GroupLen;

    if ( Len == 0 ) Len = wcslen(GroupName);
    Len += wcslen(szMembers);

    PWSTR KeyString = (PWSTR)ScepAlloc(0, (Len+1)*sizeof(WCHAR));
    if ( KeyString != NULL ) {

        swprintf(KeyString, L"%s%s", GroupName, szMembers);

        theKey.KeyName = KeyString;
        theKey.KeyLen = Len;
        theKey.Value = (PWSTR)pNameList;
        theKey.SaveValue = bDeleteOnly ? 1 : 0;
        theKey.DataType = 'M';

        rCode = ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc);

        ScepFree(KeyString);

    } else {
        rCode = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }
    return(rCode);
}

SCESTATUS
ScepTattooReadOneMemberOfListValue(
    IN PSCESECTION hSectionTattoo,
    IN PSID pGroupSid,
    OUT PSCE_NAME_LIST *ppTattooList
    )
{
    SCESTATUS rc = SCESTATUS_SUCCESS;
    PWSTR pszGroupSid = NULL;
    PWSTR pszKeyName = NULL;
    DWORD dwValueLen = 0;
    PWSTR pszValue = NULL;
    PWSTR pszTemp;

    // Build the key name in format "*SID_memberof"

    rc = ScepDosErrorToSceStatus(
            ScepConvertSidToPrefixStringSid(
                pGroupSid, &pszGroupSid));

    if(SCESTATUS_SUCCESS == rc)
    {
        pszKeyName = (PWSTR)ScepAlloc(0, 
            (wcslen(pszGroupSid)+wcslen(szMemberof)+1)*sizeof(WCHAR));
        
        if(!pszKeyName)
        {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    if(SCESTATUS_SUCCESS == rc)
    {
        wcscpy(pszKeyName, pszGroupSid);
        wcscat(pszKeyName, szMemberof);
    }

    // retrieve memberof data from tattoo table

    rc = SceJetGetValue(
                hSectionTattoo,
                SCEJET_EXACT_MATCH_NO_CASE,
                pszKeyName,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &dwValueLen);

    if(SCESTATUS_SUCCESS == rc)
    {
        pszValue = (PWSTR)ScepAlloc( LMEM_ZEROINIT, dwValueLen+2);

        if(!pszValue)
        {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    if(SCESTATUS_SUCCESS == rc)
    {
        rc = SceJetGetValue(
                    hSectionTattoo,
                    SCEJET_EXACT_MATCH_NO_CASE,
                    pszKeyName,
                    NULL,
                    0,
                    NULL,
                    pszValue,
                    dwValueLen,
                    &dwValueLen);
    }

    // build the memberof name list

    if(SCESTATUS_SUCCESS == rc)
    {
        pszTemp = pszValue;

        while(pszTemp && pszTemp[0])
        {
            rc = ScepAddToNameList(ppTattooList,
                                    pszTemp,
                                    0);
            if(STATUS_SUCCESS != rc)
            {
                rc = ScepDosErrorToSceStatus(rc);
                break;
            }

            pszTemp += wcslen(pszTemp)+1;
        }

        if(SCESTATUS_SUCCESS == rc)
        {
            pszTemp = pszValue;
            while(pszTemp && *pszTemp != L'\0')
            {
                DWORD dwLen = wcslen(pszTemp);
                *(pszTemp+dwLen) = L',';
                pszTemp = pszTemp+dwLen+1;
            }

            ScepLogOutput3(1, 0, SCEDLL_SCP_OLDTATTOO, pszValue); 
        }
    }

    if(pszGroupSid)
    {
        ScepFree(pszGroupSid);
    }
    if(pszKeyName)
    {
        ScepFree(pszKeyName);
    }
    if(pszValue)
    {
        ScepFree(pszValue);
    }
    return rc;
}

SCESTATUS
ScepTattooWriteOneMemberOfListValue(
    IN PSCESECTION hSectionTattoo,
    IN PSID pGroupSid,
    IN PSCE_NAME_LIST pNameList
    )
{
    SCESTATUS rc = SCESTATUS_SUCCESS;
    PWSTR pszGroupSid = NULL;
    PWSTR pszKeyName = NULL;
    PWSTR pszValue = NULL;
    PWSTR pszTemp;
    DWORD dwValueLen;
    PSCE_NAME_LIST pName;

    // Build the key name in format "*SID_memberof"

    rc = ScepDosErrorToSceStatus(
            ScepConvertSidToPrefixStringSid(
                pGroupSid, &pszGroupSid));

    if(SCESTATUS_SUCCESS == rc)
    {
        pszKeyName = (PWSTR)ScepAlloc(0, 
            (wcslen(pszGroupSid)+wcslen(szMemberof)+1)*sizeof(WCHAR));
        
        if(!pszKeyName)
        {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    if(SCESTATUS_SUCCESS == rc)
    {
        wcscpy(pszKeyName, pszGroupSid);
        wcscat(pszKeyName, szMemberof);
    }

    // if list is empty, delete entry from tattoo table
    if(!pNameList)
    {
        rc = SceJetDelete(
                hSectionTattoo,
                pszKeyName,
                FALSE,
                SCEJET_DELETE_LINE_NO_CASE);

        if(SCESTATUS_SUCCESS == rc)
        {
            ScepLogOutput3(1, 0, SCEDLL_SCP_DELETETATTOO); 
        }
        
        // entry might not be there

        if(SCESTATUS_RECORD_NOT_FOUND == rc)
        {
            rc = SCESTATUS_SUCCESS;
        }
    }
    else // list is not empty, write new entry to tattoo table
    {
        // calculate value size

        if(SCESTATUS_SUCCESS == rc)
        {
            dwValueLen = sizeof(WCHAR);

            for(pName = pNameList; pName; pName = pName->Next)
            {
                dwValueLen += (wcslen(pName->Name)+1)*sizeof(WCHAR);
            }
        }

        // allocate value

        if(SCESTATUS_SUCCESS == rc)
        {
            pszValue = (PWSTR) ScepAlloc(LMEM_ZEROINIT, dwValueLen);
            if(!pszValue)
            {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }
        }

        // build value from list

        if(SCESTATUS_SUCCESS == rc)
        {
            pszTemp = pszValue;

            for(pName = pNameList; pName; pName = pName->Next)
            {
                wcscpy(pszTemp, pName->Name);
                pszTemp += wcslen(pName->Name)+1;
            }
            
            *pszTemp = L'\0';
        }

        if(SCESTATUS_SUCCESS == rc)
        {
            rc = SceJetSetLine(
                    hSectionTattoo,
                    pszKeyName,
                    FALSE, // lowercase
                    pszValue,
                    dwValueLen,
                    0); // no GPOID
        }

        // if successfull, convert multisz to comma separated and write to log
        if(SCESTATUS_SUCCESS == rc)
        {
            pszTemp = pszValue;
            while(pszTemp && *pszTemp != L'\0')
            {
                DWORD dwLen = wcslen(pszTemp);
                *(pszTemp+dwLen) = L',';
                pszTemp = pszTemp+dwLen+1;
            }

            ScepLogOutput3(1, 0, SCEDLL_SCP_NEWTATTOO, pszValue); 
        }

        if(pszValue)
        {
            ScepFree(pszValue);
        }
    }

    if(pszGroupSid)
    {
        ScepFree(pszGroupSid);
    }

    if(pszKeyName)
    {
        ScepFree(pszKeyName);
    }

    return(rc);
}

SCESTATUS
ScepTattooManageOneServiceValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR ServiceName,
    IN DWORD ServiceLen OPTIONAL,
    IN PSCE_SERVICES pServiceNode,
    IN DWORD rc
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         ServiceName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    SCESTATUS  rCode;


    SCE_TATTOO_KEYS theKey;
    theKey.KeyName = ServiceName;
    theKey.KeyLen = (ServiceLen == 0) ? wcslen(ServiceName) : ServiceLen;
    theKey.Value = (PWSTR)pServiceNode;
    theKey.SaveValue = 0;
    theKey.DataType = 'V';

    rCode = ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc);

    return(rCode);
}

SCESTATUS
ScepTattooManageValues(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN SCE_TATTOO_KEYS *pTattooKeys,
    IN DWORD cTattooKeys,
    IN DWORD rc
    )
/*
Description:

    For each setting in the array, do the following:

    1) Check if the setting come from domain
    2) Check if there is a tattoo value already exist
    3) Save the new value from the array to the tattoo table if it doesn't exist
    4) Delete the tattoo value if the setting didn't come from domain and
       it has been reset successfully
*/
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         pTattooKeys == NULL || cTattooKeys == 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS     rCode=SCESTATUS_SUCCESS;
    SCESTATUS     rc2;
    BOOL          bTattooExist,bDomainExist;
    PWSTR         KeyString=NULL;
    PWSTR pTempKey;

    for ( DWORD i=0; i<cTattooKeys; i++) {

        if ( pTattooKeys[i].KeyName == NULL ) continue;
        if ( pTattooKeys[i].DataType == 'L' && pTattooKeys[i].Value == NULL ) continue;

        //
        // check if this setting exists in the tattoo table
        //
        bTattooExist = FALSE;
        rc2 = SCESTATUS_SUCCESS;

        if ( SCESTATUS_SUCCESS == SceJetSeek(
                                    hSectionTattoo,
                                    pTattooKeys[i].KeyName,
                                    pTattooKeys[i].KeyLen*sizeof(WCHAR),
                                    SCEJET_SEEK_EQ_NO_CASE
                                    ) ) {
            bTattooExist = TRUE;
        }

        //
        // check if the setting exists in the effective table
        //

        bDomainExist = FALSE;

        if ( SCESTATUS_SUCCESS == SceJetSeek(
                                    hSectionDomain,
                                    pTattooKeys[i].KeyName,
                                    pTattooKeys[i].KeyLen*sizeof(WCHAR),
                                    SCEJET_SEEK_EQ_NO_CASE
                                    ) ) {
            if ( !bTattooExist ) {
                //
                // if there is no tattoo value but there is a setting in domain table
                // this setting must come from domain
                //
                bDomainExist = TRUE;

            } else if ( hSectionDomain->JetColumnGpoID > 0 ) {

                //
                // check if GpoID > 0
                //

                LONG GpoID = 0;
                DWORD Actual;
                JET_ERR JetErr;

                JetErr = JetRetrieveColumn(
                                hSectionDomain->JetSessionID,
                                hSectionDomain->JetTableID,
                                hSectionDomain->JetColumnGpoID,
                                (void *)&GpoID,
                                4,
                                &Actual,
                                0,
                                NULL
                                );
                if ( JET_errSuccess != JetErr ) {
                    //
                    // if the column is nil (no value), it will return warning
                    // but the buffer pGpoID is trashed
                    //
                    GpoID = 0;
                }

                if ( GpoID > 0 ) {
                    bDomainExist = TRUE;
                }
            }

        }

        //
        // check if we need to save the tatto value or delete the tattoo value
        //
        if ( bDomainExist ) {

            pTempKey = pTattooKeys[i].KeyName;
            BOOL bSave = FALSE;

            if ( pTattooKeys[i].DataType == 'M' && pTattooKeys[i].SaveValue == 1 ) {
                //
                // delete only for group membership, don't do anything in this case
                //
            } else if ( !bTattooExist ) {
                //
                // domain setting is defined (the first time)
                // save the tattoo value
                //
                switch ( pTattooKeys[i].DataType ) {
                case 'D':
                    if ( pTattooKeys[i].SaveValue != SCE_NO_VALUE ) {

                        rc2 = ScepCompareAndSaveIntValue(hSectionTattoo,
                                        pTattooKeys[i].KeyName,
                                        FALSE,
                                        SCE_SNAPSHOT_VALUE,
                                        pTattooKeys[i].SaveValue
                                        );
                        bSave = TRUE;
                    }
                    break;
                case 'L':  // dependency DWORD type
                    pTempKey = pTattooKeys[i].Value;

                    if ( pTattooKeys[i].SaveValue != SCE_NO_VALUE ) {
                        rc2 = ScepCompareAndSaveIntValue(hSectionTattoo,
                                        pTattooKeys[i].Value,
                                        FALSE,
                                        SCE_SNAPSHOT_VALUE,
                                        pTattooKeys[i].SaveValue
                                        );
                        bSave = TRUE;
                    }

                    break;
                case 'S':
                    if ( pTattooKeys[i].Value ) {

                        rc2 = ScepCompareAndSaveStringValue(hSectionTattoo,
                                        pTattooKeys[i].KeyName,
                                        (PWSTR)(ULONG_PTR)SCE_SNAPSHOT_VALUE,
                                        pTattooKeys[i].Value,
                                        pTattooKeys[i].SaveValue*sizeof(WCHAR)
                                        );
                        bSave = TRUE;
                    }
                    break;
                case 'R': // registry values
                    if ( ((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->Value ) {

                        if ( REG_DWORD == ((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->ValueType ) {

                            DWORD RegData = _wtol(((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->Value);

                            rc2 = ScepSaveRegistryValue(hSectionTattoo,
                                                        pTattooKeys[i].KeyName,
                                                        REG_DWORD,
                                                        (PWSTR)&RegData,
                                                        sizeof(DWORD),
                                                        0
                                                        );
                        } else {

                            rc2 = ScepSaveRegistryValue(hSectionTattoo,
                                                        pTattooKeys[i].KeyName,
                                                        ((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->ValueType,
                                                        ((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->Value,
                                                        wcslen(((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->Value)*sizeof(WCHAR),
                                                        0
                                                        );
                        }
                        bSave = TRUE;
                    }
                    break;
                case 'M': // group member list
                    // allow empty member list to be saved
                    rc2 = ScepWriteNameListValue(
                            NULL,
                            hSectionTattoo,
                            pTattooKeys[i].KeyName,
                            (PSCE_NAME_LIST)(pTattooKeys[i].Value),
                            SCE_WRITE_EMPTY_LIST,
                            3
                            );
                    bSave = TRUE;

                    break;
                case 'V': // service

                    if ( pTattooKeys[i].Value ) {

                        rc2 = ScepSetSingleServiceSetting(
                                  hSectionTattoo,
                                  (PSCE_SERVICES)(pTattooKeys[i].Value)
                                  );
                        bSave = TRUE;

                    } else {
                        rc2 = SCESTATUS_INVALID_PARAMETER;
                    }
                    break;
                default:
                    rc2 = SCESTATUS_INVALID_PARAMETER;
                    break;
                }

                if ( rc2 != SCESTATUS_SUCCESS ) {

                    ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_SETTING,
                                   ScepSceStatusToDosError(rc2), pTempKey);
                    rCode = rc2;
                } else if ( bSave ) {
                    ScepLogOutput3(2, 0, SCESRV_POLICY_TATTOO_CHECK, pTempKey);
                }

            } else {

                //
                // check if there is any value to save
                //
                switch ( pTattooKeys[i].DataType ) {
                case 'D':
                case 'L':
                    if ( pTattooKeys[i].SaveValue != SCE_NO_VALUE )
                        bSave = TRUE;
                    break;
                case 'S':
                case 'V':
                    if ( pTattooKeys[i].Value ) bSave = TRUE;
                    break;
                case 'R':
                    if ( ((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->Value )
                        bSave = TRUE;
                    break;
                }

                if ( bSave )
                    ScepLogOutput3(3, 0, SCESRV_POLICY_TATTOO_EXIST, pTempKey);
            }

        } else {
            pTempKey = (pTattooKeys[i].DataType == 'L') ? pTattooKeys[i].Value : pTattooKeys[i].KeyName;

            if ( bTattooExist && ERROR_SUCCESS == rc ) {
                //
                // no domain setting defined
                // tattoo setting has been reset, delete the tattoo value
                // for dependency type, delete the right key
                //
                rc2 = SceJetDelete(hSectionTattoo,
                                pTempKey,
                                FALSE,
                                SCEJET_DELETE_LINE_NO_CASE);

                if ( rc2 == SCESTATUS_RECORD_NOT_FOUND) rc2 = SCESTATUS_SUCCESS;

                if ( rc2 != SCESTATUS_SUCCESS ) {

                    ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_REMOVE, ScepSceStatusToDosError(rc2), pTempKey);
                    rCode = rc2;
                } else {
                    ScepLogOutput3(2, 0, SCESRV_POLICY_TATTOO_REMOVE_SETTING, pTempKey);
                }
            } else if ( bTattooExist ) {
                //
                // undo value wan't reset properly
                //
                ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_RESET, pTempKey, rc );
            } else {
                //
                // there is no undo value
                //

//                ScepLogOutput3(3, 0, SCESRV_POLICY_TATTOO_NONEXIST, pTempKey );
            }
        }
    }

    return(rCode);

}

BOOL
ScepTattooIfQueryNeeded(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD Len,
    OUT BOOL *pbDomainExist,
    OUT BOOL *pbTattooExist
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL || KeyName == NULL || Len == 0 ) {
        return FALSE;
    }

    //
    // check if this setting exists in the tattoo table
    //
    BOOL bTattooExist = FALSE;

    if ( SCESTATUS_SUCCESS == SceJetSeek(
                                hSectionTattoo,
                                KeyName,
                                Len*sizeof(WCHAR),
                                SCEJET_SEEK_EQ_NO_CASE
                                ) ) {
        bTattooExist = TRUE;
    }

    //
    // check if the setting exists in the effective table
    //

    BOOL bDomainExist = FALSE;

    if ( SCESTATUS_SUCCESS == SceJetSeek(
                                hSectionDomain,
                                KeyName,
                                Len*sizeof(WCHAR),
                                SCEJET_SEEK_EQ_NO_CASE
                                ) ) {
        if ( !bTattooExist ) {
            //
            // if there is no tattoo value but there is a setting in domain table
            // this setting must come from domain
            //
            bDomainExist = TRUE;

        } else if ( hSectionDomain->JetColumnGpoID > 0 ) {

            //
            // check if GpoID > 0
            //

            LONG GpoID = 0;
            DWORD Actual;
            JET_ERR JetErr;

            JetErr = JetRetrieveColumn(
                            hSectionDomain->JetSessionID,
                            hSectionDomain->JetTableID,
                            hSectionDomain->JetColumnGpoID,
                            (void *)&GpoID,
                            4,
                            &Actual,
                            0,
                            NULL
                            );
            if ( JET_errSuccess != JetErr ) {
                //
                // if the column is nil (no value), it will return warning
                // but the buffer pGpoID is trashed
                //
                GpoID = 0;
            }

            if ( GpoID > 0 ) {
                bDomainExist = TRUE;
            }
        }
    }

    //
    // check if we need to save the tatto value or delete the tattoo value
    //
    if ( pbDomainExist ) *pbDomainExist = bDomainExist;
    if ( pbTattooExist ) *pbTattooExist = bTattooExist;

    if ( bDomainExist && !bTattooExist )
        return TRUE;

    return FALSE;
}


SCESTATUS
ScepDeleteOneSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE tblType,
    IN PCWSTR SectionName
    )
{
    PSCESECTION  hSection=NULL;
    SCESTATUS    rc;

    rc = ScepOpenSectionForName(
                 hProfile,
                 tblType,
                 SectionName,
                 &hSection
                 );

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = SceJetDelete( hSection, NULL, FALSE,SCEJET_DELETE_SECTION );

        SceJetCloseSection(&hSection, TRUE );

    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\pfp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    pfp.h

Abstract:

    Headers of jet database read/write

Author:

    Jin Huang (jinhuang) 09-Dec-1996

Revision History:

--*/

#ifndef _pfp_
#define _pfp_

#ifdef __cplusplus
extern "C" {
#endif

SCESTATUS
ScepStartANewSection(
    IN PSCECONTEXT hProfile,
    IN OUT PSCESECTION *hSection,
    IN SCEJET_TABLE_TYPE ProfileType,
    IN PCWSTR SectionName
    );

SCESTATUS
ScepOpenSectionForName(
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    IN PCWSTR     SectionName,
    OUT PSCESECTION *phSection
    );

SCESTATUS
ScepGetPrivileges(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN DWORD dwAccountFormat,
   OUT PVOID *pPrivileges,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

SCESTATUS
ScepAddToPrivList(
    IN PSCE_NAME_STATUS_LIST *pPrivList,
    IN DWORD Rights,
    IN PWSTR Name,
    IN DWORD Len
    );

SCESTATUS
ScepAddSidToPrivilegeList(
    OUT PSCE_PRIVILEGE_VALUE_LIST  *pPrivilegeList,
    IN PSID pSid,
    IN BOOL bReuseBuffer,
    IN DWORD PrivValue,
    OUT BOOL *pbBufferUsed
    );

SCESTATUS
ScepCompareAndSaveIntValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN BOOL bReplaceExistOnly,
    IN DWORD BaseValue,
    IN DWORD CurrentValue
    );

SCESTATUS
ScepCompareAndSaveStringValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PWSTR BaseValue,
    IN PWSTR CurrentValue,
    IN DWORD CurrentLen
    );

SCESTATUS
ScepSaveObjectString(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN BOOL  IsContainer,
    IN BYTE  Flag,
    IN PWSTR Value,
    IN DWORD ValueLen
    );

SCESTATUS
ScepWriteAUserSetting(
    IN PSCESECTION hSectionList,
    IN PWSTR UserName,
    IN PSCESECTION hSection,
    IN PSCE_USER_SETTING pPerUserSetting
    );

#define SCE_WRITE_EMPTY_LIST        0x1
#define SCE_WRITE_CONVERT           0x2
#define SCE_WRITE_LOCAL_TABLE       0x4

SCESTATUS
ScepWriteNameListValue(
    IN LSA_HANDLE LsaPolicy OPTIONAL,
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSCE_NAME_LIST NameList,
    IN DWORD dwWriteOption,
    IN INT Status
    );

SCESTATUS
ScepWriteNameStatusListValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSCE_NAME_STATUS_LIST NameList,
    IN BOOL SaveEmptyList,
    IN INT Status
    );

SCESTATUS
ScepWriteSecurityDescriptorValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo
    );

#define SCE_LOCAL_POLICY_MIGRATE        1L
#define SCE_LOCAL_POLICY_DC             2L

SCESTATUS
ScepCopyLocalToMergeTable(
    IN PSCECONTEXT hProfile,
    IN DWORD Options,
    IN DWORD CopyOptions,
    OUT PSCE_ERROR_LOG_INFO *pErrlog
    );

SCESTATUS
ScepGetSingleServiceSetting(
    IN PSCESECTION hSection,
    IN PWSTR ServiceName,
    OUT PSCE_SERVICES *pOneService
    );

SCESTATUS
ScepSetSingleServiceSetting(
    IN PSCESECTION hSection,
    IN PSCE_SERVICES pOneService
    );

SCESTATUS
ScepCompareSingleServiceSetting(
    IN PSCE_SERVICES pNode1,
    IN PSCE_SERVICES pNode2,
    OUT PBOOL pIsDifferent
    );

SCESTATUS
ScepCopyObjects(
    IN PSCECONTEXT hProfile,
    IN SCETYPE  ProfileType,
    IN PWSTR InfFile,
    IN PCWSTR SectionName,
    IN AREA_INFORMATION Area,
    IN OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetFixValueSection(
    IN PSCECONTEXT  hProfile,
    IN PCWSTR      SectionName,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN SCETYPE ProfileType,
    OUT PVOID pProfileInfo,
    OUT PSCESECTION *phSection,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

#define SCEBROWSE_DOMAIN_POLICY     0x1
#define SCEBROWSE_MULTI_SZ          0x2

SCESTATUS
ScepBrowseTableSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN PCWSTR SectionName,
    IN DWORD Options
    );

#define SCE_ERROR_STRING           TEXT("$#?Error?#$")

SCESTATUS
ScepTattooCheckAndUpdateArray(
    IN OUT SCE_TATTOO_KEYS *pTattooKeys,
    IN OUT DWORD *pcTattooKeys,
    IN PWSTR KeyName,
    IN DWORD ConfigOptions,
    IN DWORD dwValue
    );

SCESTATUS
ScepTattooOpenPolicySections(
    IN PSCECONTEXT hProfile,
    IN PCWSTR SectionName,
    OUT PSCESECTION *phSectionDomain,
    OUT PSCESECTION *phSectionTattoo
    );

SCESTATUS
ScepTattooManageOneStringValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN PWSTR Value,
    IN DWORD ValueLen,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageOneIntValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN DWORD Value,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageOneIntValueWithDependency(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR DependentKeyName,
    IN DWORD DependentKeyLen OPTIONAL,
    IN PWSTR SaveKeyName,
    IN DWORD Value,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageOneRegistryValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN PSCE_REGISTRY_VALUE_INFO pOneRegValue,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageOneMemberListValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR GroupName,
    IN DWORD GroupLen OPTIONAL,
    IN PSCE_NAME_LIST pNameList,
    IN BOOL bDeleteOnly,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageOneServiceValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR ServiceName,
    IN DWORD ServiceLen OPTIONAL,
    IN PSCE_SERVICES pServiceNode,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageValues(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN SCE_TATTOO_KEYS *pTattooKeys,
    IN DWORD cTattooKeys,
    IN DWORD rc
    );

BOOL
ScepTattooIfQueryNeeded(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD Len,
    OUT BOOL *pbDomainExist,
    OUT BOOL *pbTattooExist
    );

SCESTATUS
ScepDeleteOneSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE tblType,
    IN PCWSTR SectionName
    );

SCESTATUS
ScepTattooReadOneMemberOfListValue(
    IN PSCESECTION hSectionTattoo,
    IN PSID pGroupSid,
    OUT PSCE_NAME_LIST *ppTattooList
    );

SCESTATUS
ScepTattooWriteOneMemberOfListValue(
    IN PSCESECTION hSectionTattoo,
    IN PSID pGroupSid,
    IN PSCE_NAME_LIST pNameList
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\queue.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    queue.h

Abstract:

    prototypes for queue algorithms and data structures to handle policy notifications

Author:

    Vishnu Patankar (vishnup) 15-Aug-2000 created

--*/

#ifndef _queuep_
#define _queuep_

#include "splay.h"

#ifdef __cplusplus
extern "C" {
#endif


#define SCE_QUEUE_INFO_SAM          1L
#define SCE_QUEUE_INFO_AUDIT        2L
#define SCE_QUEUE_INFO_RIGHTS       4L

typedef enum _NOTIFICATIONQ_OPERATION_TYPE {
    ScepNotificationEnqueue = 1,
    ScepNotificationDequeue,
    ScepNotificationRetry,
    ScepNotificationProcess
} NOTIFICATIONQ_OPERATION_TYPE, *PNOTIFICATIONQ_OPERATION_TYPE;

#define SCEP_NUM_NOTIFICATION_SECONDS   300
#define SCEP_NUM_SHUTDOWN_SECONDS       60
#define SCEP_NUM_CHECK_EMPTY_SECONDS    60
#define SCEP_NUM_REST_SECONDS           20

#define SCEP_IS_SAM_OBJECT(ObjectType) ((ObjectType == SecurityDbObjectSamUser ||\
                                         ObjectType == SecurityDbObjectSamGroup ||\
                                         ObjectType == SecurityDbObjectSamAlias) ?\
                                         TRUE : FALSE)

#define MAX_SID_LENGTH      SID_MAX_SUB_AUTHORITIES*sizeof(DWORD)+10

#define SCE_NOTIFICATION_PATH           \
            SCE_ROOT_PATH TEXT("\\Notifications")

typedef struct _SCESRV_POLQUEUE_ {

   DWORD                    dwPending;
   SECURITY_DB_TYPE         DbType;
   SECURITY_DB_OBJECT_TYPE  ObjectType;
   SECURITY_DB_DELTA_TYPE   DeltaType;
   DWORD                    ExplicitLowRight;
   DWORD                    ExplicitHighRight;
   CHAR                     Sid[MAX_SID_LENGTH];
   struct _SCESRV_POLQUEUE_   *Next;

} SCESRV_POLQUEUE, *PSCESRV_POLQUEUE;


NTSTATUS
ScepQueueStartSystemThread(
    );

DWORD
ScepNotificationQInitialize(
    );

DWORD
ScepNotificationQSystemThreadFunc(
    );

VOID
ScepNotificationQDequeue(
    IN BOOL bAllNodes
    );

DWORD
ScepNotificationQEnqueue(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    IN PSCESRV_POLQUEUE pRetryQNode OPTIONAL
    );

VOID
ScepNotificationQFree(
    );

DWORD
ScepNotificationQFlush(
    );

DWORD
ScepNotificationQUnFlush(
    );

VOID
ScepNotificationQNodeLog(
    IN PSCESRV_POLQUEUE pQNode,
    IN NOTIFICATIONQ_OPERATION_TYPE    NotificationOp
    );

DWORD
ScepGetQueueInfo(
    OUT DWORD *pdwInfo,
    IN OUT PSCEP_SPLAY_TREE pRootNode OPTIONAL
    );

DWORD
ScepNotifyLogPolicy(
    IN DWORD ErrCode,
    IN BOOL  bLogTime,
    IN PWSTR Msg,
    IN DWORD DbType,
    IN DWORD ObjectType,
    IN PWSTR ObjectName OPTIONAL
    );

DWORD
ScepQueuePrepareShutdown(
    );

DWORD
ScepNotificationLogOpen(
   );

VOID
ScepNotificationLogClose(
   );

VOID
ScepBackupNotificationLogFile(
    );

VOID
ScepNotificationQCleanup(
    );

VOID
ScepNotificationQControl(
    IN DWORD Flag
    );

DWORD
ScepCheckAndWaitPolicyPropFinish();

//
// for debugging only
//

VOID
ScepDbgNotificationQDump(
    );

VOID
ScepDbgNotificationQDumpNode(
    IN PSCESRV_POLQUEUE pQNode
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\regvalue.cpp ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    regvalue.cpp

Abstract:

    Routines to read/write/configure registry value settings

    The following modules have links to registry values
        scejet.c    <SceJetAddSection>
        inftojet.c  <SceConvertpInfKeyValue>
        pfget.c     <ScepGetRegistryValues>
        config.c    <ScepConfigureRegistryValues>
        analyze.c   <ScepAnalyzeRegistryValues>

Author:

    Jin Huang (jinhuang) 07-Jan-1998

Revision History:

--*/


#include "headers.h"
#include "serverp.h"
#include "regvalue.h"
#include "pfp.h"


DWORD
ScepUnescapeAndAddCRLF(
    IN  PWSTR   pszSource,
    IN  OUT PWSTR   pszDest
    );

DWORD
ScepEscapeAndRemoveCRLF(
    IN  const PWSTR   pszSource,
    IN  const DWORD   dwSourceSize,
    IN  OUT PWSTR   pszDest
    );

SCESTATUS
ScepSaveRegistryValueToBuffer(
    IN DWORD RegType,
    IN PWSTR Value,
    IN DWORD dwBytes,
    IN OUT PSCE_REGISTRY_VALUE_INFO pRegValues
    );

SCESTATUS
ScepEnumAllRegValues(
    IN OUT PDWORD  pCount,
    IN OUT PSCE_REGISTRY_VALUE_INFO    *paRegValues
    );

DWORD
ScepAnalyzeOneRegistryValueNoValidate(
    IN HKEY hKey,
    IN PWSTR ValueName,
    IN PSCESECTION hSection OPTIONAL,
    IN DWORD dwAnalFlag,
    IN OUT PSCE_REGISTRY_VALUE_INFO pOneRegValue
    );

extern "C" {
VOID
pSetupGetRealSystemTime(
    OUT LPSYSTEMTIME RealSystemTime
    );
}


SCESTATUS
ScepGetRegistryValues(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_REGISTRY_VALUE_INFO * ppRegValues,
    OUT LPDWORD pValueCount,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine retrieves registry values to secure from the Jet database
   and stores in the output buffer ppRegValues

Arguments:

   hProfile     -  The profile handle context

   ppRegValues  -  the output array of registry values.

   pValueCount  -  the buffer to hold number of elements in the array

   Errlog       -  A buffer to hold all error codes/text encountered when
                   parsing the INF file. If Errlog is NULL, no further error
                   information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_BAD_FORMAT
               SCESTATUS_INVALID_DATA

--*/

{
    if ( !hProfile || !ppRegValues || !pValueCount ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS               rc;
    PSCESECTION             hSection=NULL;

    LPTSTR                  KeyName=NULL;
    DWORD                   KeyLen;

    DWORD                   i,j;
    LPTSTR                  ValueStr=NULL;
    LPTSTR                  Value=NULL;
    DWORD                   ValueLen;
    LONG                    dType;
    DWORD                   Status;
    DWORD                   dCount;


    rc = ScepOpenSectionForName(
                hProfile,
                (ProfileType==SCE_ENGINE_GPO) ? SCE_ENGINE_SCP : ProfileType,
                szRegistryValues,
                &hSection
                );
    if ( SCESTATUS_SUCCESS != rc ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog, SCEERR_OPEN,
                             szRegistryValues
                           );
        return(rc);
    }
    //
    // get total number of values in this section
    //
    *ppRegValues = NULL;

    rc = SceJetGetLineCount(
            hSection,
            NULL,
            FALSE,
            pValueCount
            );
    if ( SCESTATUS_SUCCESS == rc && *pValueCount > 0 ) {

        //
        // allocate memory for all objects
        //
        *ppRegValues = (PSCE_REGISTRY_VALUE_INFO)ScepAlloc( LMEM_ZEROINIT,
                                                 *pValueCount*sizeof(SCE_REGISTRY_VALUE_INFO) );
        if ( *ppRegValues ) {

            //
            // goto the first line of this section
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_PREFIX_MATCH,
                        NULL,
                        NULL,
                        0,
                        &KeyLen,
                        NULL,
                        0,
                        &ValueLen
                        );
            i=0;

            JET_COLUMNID  ColGpoID = 0;
            JET_ERR       JetErr;
            LONG          GpoID=0;
            DWORD         Actual;

            if ( ProfileType == SCE_ENGINE_GPO ) {
                JET_COLUMNDEF ColumnGpoIDDef;

                JetErr = JetGetTableColumnInfo(
                                hSection->JetSessionID,
                                hSection->JetTableID,
                                "GpoID",
                                (VOID *)&ColumnGpoIDDef,
                                sizeof(JET_COLUMNDEF),
                                JET_ColInfo
                                );
                if ( JET_errSuccess == JetErr ) {
                    ColGpoID = ColumnGpoIDDef.columnid;
                }
            }
            //
            // this count is for SCE_ENGINE_GPO type
            //
            dCount=0;

            while ( rc == SCESTATUS_SUCCESS ||
                    rc == SCESTATUS_BUFFER_TOO_SMALL ) {
                //
                // Get string key and a int value.
                //
                if ( i >= *pValueCount ) {
                    //
                    // more lines than allocated
                    //
                    rc = SCESTATUS_INVALID_DATA;
                    ScepBuildErrorLogInfo(ERROR_INVALID_DATA,
                                         Errlog,
                                         SCEERR_MORE_OBJECTS,
                                         *pValueCount
                                         );
                    break;
                }

                GpoID = 1;
                if ( ProfileType == SCE_ENGINE_GPO ) {

                    GpoID = 0;

                    if ( ColGpoID > 0 ) {

                        //
                        // query if the setting comes from a GPO
                        // get GPO ID field from the current line
                        //
                        JetErr = JetRetrieveColumn(
                                        hSection->JetSessionID,
                                        hSection->JetTableID,
                                        ColGpoID,
                                        (void *)&GpoID,
                                        4,
                                        &Actual,
                                        0,
                                        NULL
                                        );

                    }
                }

                if ( GpoID <= 0 ) {
                    //
                    // read next line
                    //
                    rc = SceJetGetValue(
                                hSection,
                                SCEJET_NEXT_LINE,
                                NULL,
                                NULL,
                                0,
                                &KeyLen,
                                NULL,
                                0,
                                &ValueLen
                                );
                    continue;
                }

                dCount++;

                //
                // allocate memory for the group name and value string
                //
                KeyName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, KeyLen+2);

                if ( KeyName ) {

                    Value = (PWSTR)ScepAlloc(LMEM_ZEROINIT, ValueLen+2);

                    if ( Value ) {

                        rc = SceJetGetValue(
                                hSection,
                                SCEJET_CURRENT,
                                NULL,
                                KeyName,
                                KeyLen,
                                &KeyLen,
                                Value,
                                ValueLen,
                                &ValueLen
                                );

                        if ( rc == SCESTATUS_SUCCESS ||
                             rc == SCESTATUS_BUFFER_TOO_SMALL ) {

                            rc = SCESTATUS_SUCCESS;

                            if ( ValueLen > 0 )
                                Value[ValueLen/2] = L'\0';

                            KeyName[KeyLen/2] = L'\0';

                            if ( ValueLen > 0 && Value[0] != L'\0' ) {
                                //
                                // the first ansi character is the value type,
                                // second ansi character is the status (if in SAP)
                                // should be terminated by L'\0'
                                //
                                //dType = _wtol(Value);
                                dType = *((CHAR *)Value) - '0';
                                if ( *((CHAR *)Value+1) >= '0' ) {
                                    Status = *((CHAR *)Value+1) - '0';
                                } else {
                                    Status = 0;
                                }

//                                if ( *(Value+2) ) { // a char and a null delimiter
                                if ( ValueLen > 4 ) { // a char and a null delimiter
                                    //
                                    // the second field and after is the registry value
                                    // convert the multi-sz delimeter to ,
                                    //

                                    if ( dType == REG_MULTI_SZ &&
                                         (0 == _wcsicmp( KeyName, szLegalNoticeTextKeyName) ) ) {

                                        //
                                        // check for commas and escape them with "," so the UI etc.
                                        // understands this, since, at this point for lines such as
                                        // k=7,a",",b,c
                                        // pValueStr will be a,\0b\0c\0\0 which we should make
                                        // a","\0b\0c\0\0
                                        //

                                        DWORD dwCommaCount = 0;
                                        j = 0;

                                        for ( j=2; j< ValueLen/2 ; j++) {
                                            if ( Value[j] == L',' )
                                                dwCommaCount++;
                                        }

                                        if ( dwCommaCount > 0 ) {

                                            //
                                            // in this case we have to escape commas
                                            //

                                            PWSTR   pszValueEscaped;
                                            DWORD   dwBytes = (ValueLen/2 + 1 + dwCommaCount*2) * sizeof(WCHAR);

                                            pszValueEscaped = (PWSTR)ScepAlloc(LMEM_ZEROINIT, dwBytes);

                                            if (pszValueEscaped) {

                                                memset(pszValueEscaped, '\0', dwBytes);
                                                ValueLen = 2 * ScepEscapeString(Value,
                                                                            ValueLen/2,
                                                                            L',',
                                                                            L'"',
                                                                            pszValueEscaped
                                                                           );

                                                ScepFree(Value);

                                                Value = pszValueEscaped;

                                            } else {
                                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                            }
                                        }
                                    }

                                    ScepConvertMultiSzToDelim(Value+2, ValueLen/2-2, L'\0', L',');


                                    ValueStr = (PWSTR)ScepAlloc(0, (ValueLen/2-1)*sizeof(WCHAR));

                                    if ( ValueStr ) {

                                        wcscpy(ValueStr, Value+2);
                                        ValueStr[ValueLen/2-2] = L'\0';

                                    } else {
                                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                    }
                                } // else no value available


                                //
                                // assign name to the output buffer
                                //
                                (*ppRegValues)[i].FullValueName = KeyName;
                                KeyName = NULL;

                                (*ppRegValues)[i].ValueType = dType;

                                (*ppRegValues)[i].Value = ValueStr;
                                (*ppRegValues)[i].Status = Status;

                                ValueStr = NULL;

                                //
                                // increment the count
                                //
                                i++;

                            } else {
                                // shouldn't be possible to get into this loop
                                // if it does, ignore this one
                                rc = SCESTATUS_INVALID_DATA;
                            }

                        } else if ( rc != SCESTATUS_RECORD_NOT_FOUND ){
                            ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                                 Errlog,
                                                 SCEERR_QUERY_VALUE,
                                                 szRegistryValues
                                               );
                        }

                        if ( Value ) {
                            ScepFree(Value);
                            Value = NULL;
                        }

                        if ( ValueStr ) {
                            ScepFree(ValueStr);
                            ValueStr = NULL;
                        }

                    } else {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    }

                    //
                    // remember to free the KeyName
                    //
                    if ( KeyName ) {
                        ScepFree(KeyName);
                        KeyName = NULL;
                    }

                    if ( rc != SCESTATUS_SUCCESS ) {
                        break;
                    }
                    //
                    // read next line
                    //
                    rc = SceJetGetValue(
                                hSection,
                                SCEJET_NEXT_LINE,
                                NULL,
                                NULL,
                                0,
                                &KeyLen,
                                NULL,
                                0,
                                &ValueLen
                                );
                } else {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                }

            }

        } else {

            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND ||
         rc == SCESTATUS_BUFFER_TOO_SMALL ) {
        rc = SCESTATUS_SUCCESS;
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // free memory
        //
        ScepFreeRegistryValues( ppRegValues, *pValueCount );
        *ppRegValues = NULL;

    } else if ( ProfileType == SCE_ENGINE_GPO &&
                *pValueCount > dCount ) {
        //
        // reallocate the output buffer
        //

        if ( dCount > 0 ) {

            PSCE_REGISTRY_VALUE_INFO pTempRegValues = *ppRegValues;

            //
            // allocate memory for all objects
            //
            *ppRegValues = (PSCE_REGISTRY_VALUE_INFO)ScepAlloc( LMEM_ZEROINIT,
                                                     dCount*sizeof(SCE_REGISTRY_VALUE_INFO) );
            if ( *ppRegValues ) {

                for ( i=0,j=0; i<*pValueCount; i++ ) {

                    if ( pTempRegValues[i].Value ) {
                        (*ppRegValues)[j].FullValueName = pTempRegValues[i].FullValueName;
                        (*ppRegValues)[j].Value = pTempRegValues[i].Value;
                        (*ppRegValues)[j].ValueType = pTempRegValues[i].ValueType;
                        (*ppRegValues)[j].Status = pTempRegValues[i].Status;
                        j++;

                    } else if ( pTempRegValues[i].FullValueName ) {
                        ScepFree( pTempRegValues[i].FullValueName );
                    }
                }

                ScepFree( pTempRegValues );

                *pValueCount = dCount;

            } else {

                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                *pValueCount = 0;
            }

        } else {

            //
            // no registry value from the GPO settings are found
            //
            ScepFreeRegistryValues( ppRegValues, *pValueCount );
            *ppRegValues = NULL;
            *pValueCount = 0;
        }

    }

    //
    // close the section
    //
    SceJetCloseSection(&hSection, TRUE);

    return(rc);
}

DWORD
ScepSetDriverSigningPolicy( 
    BYTE Policy)
/* ++

Routine Description:

   This routine configures driver signing policy through a private API
   that ensures the value is not being reset by the code signing
   "anti-tampering" feature.

Arguments:

   bPolicy - new policy to set

Return value:

    win32 error

-- */
{
    DWORD Err;
    HKEY hKey;
    DWORD dwData = 0, dwSize, dwType;
    BYTE NewPolicy;
    SYSTEMTIME RealSystemTime;                                                   
                                                                                 
    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("System\\WPA\\PnP"),
                       0,                   
                       KEY_READ,
                       &hKey
                      );

    if(Err != ERROR_SUCCESS) {
        return Err;
    }

    dwSize = sizeof(dwData);

    Err = RegQueryValueEx(hKey,
                          TEXT("seed"),
                          NULL,
                          &dwType,
                          (PBYTE)&dwData,
                          &dwSize
                         );

    if(Err == ERROR_SUCCESS) {

        if(dwType != REG_DWORD) {

            Err = ERROR_DATATYPE_MISMATCH;

        } else if(dwSize != sizeof(dwData)) {

            Err = ERROR_INVALID_DATA;

        } else {

            RealSystemTime.wDayOfWeek = LOWORD(&hKey) | 4;
            RealSystemTime.wMinute = LOWORD(dwData);
            RealSystemTime.wYear = HIWORD(dwData);
            RealSystemTime.wMilliseconds = (LOWORD(&dwType)&~3072)|(((WORD)(Policy&3))<<10);
            pSetupGetRealSystemTime(&RealSystemTime);

            RealSystemTime.wDayOfWeek = LOWORD(&hKey) | 4;
            pSetupGetRealSystemTime(&RealSystemTime);
            NewPolicy = (BYTE)(((RealSystemTime.wMilliseconds+2)&15)^8)/4;

            if(Policy != NewPolicy) {

                Err = ERROR_FUNCTION_FAILED;
            }
        }
    }

    RegCloseKey(hKey);

    return Err;
}


SCESTATUS
ScepConfigureRegistryValues(
    IN PSCECONTEXT hProfile OPTIONAL,
    IN PSCE_REGISTRY_VALUE_INFO pRegValues,
    IN DWORD ValueCount,
    IN PSCE_ERROR_LOG_INFO *pErrLog,
    IN DWORD ConfigOptions,
    OUT PBOOL pAnythingSet
    )
/* ++

Routine Description:

   This routine configure registry values in the area of security
   policy.

Arguments:

   pRegValues - The array of registry values to configure

   ValueCount - the number of values to configure

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_OTHER_ERROR

-- */
{
   if ( !pRegValues || ValueCount == 0 ) {
      //
      // if no info to configure
      //
      return SCESTATUS_SUCCESS;
   }

   DWORD           rc;
   SCESTATUS       Saverc=SCESTATUS_SUCCESS;

   PWSTR           pStart, pTemp, pValue;
   HKEY            hKey=NULL;
   HKEY            hKeyRoot;
   PSCESECTION     hSectionDomain=NULL;
   PSCESECTION     hSectionTattoo=NULL;
   SCE_REGISTRY_VALUE_INFO OneRegValue;


   if ( pAnythingSet )
       *pAnythingSet = FALSE;

   if ( (ConfigOptions & SCE_POLICY_TEMPLATE) && hProfile ) {
       ScepTattooOpenPolicySections(
                     hProfile,
                     szRegistryValues,
                     &hSectionDomain,
                     &hSectionTattoo
                     );
   }

   for ( DWORD i=0; i<ValueCount; i++ ) {

       if ( !pRegValues[i].FullValueName ||
            !pRegValues[i].Value ) {
           //
           // no value to configure
           //
           continue;
       }

       ScepLogOutput3(2, 0, SCEDLL_SCP_CONFIGURE, pRegValues[i].FullValueName);

       //
       // look for the first \\
       //
       pStart = wcschr(pRegValues[i].FullValueName, L'\\') ;
       if ( !pStart ) {
           Saverc = SCESTATUS_INVALID_DATA;

           if ( pErrLog ) {
               ScepBuildErrorLogInfo(Saverc,pErrLog, SCEDLL_SCP_ERROR_CONFIGURE,
                                     pRegValues[i].FullValueName);
           } else {
               ScepLogOutput3(1, Saverc, SCEDLL_SCP_ERROR_CONFIGURE, pRegValues[i].FullValueName);
           }

           if ( ConfigOptions & SCE_RSOP_CALLBACK )

               ScepRsopLog(SCE_RSOP_REGISTRY_VALUE_INFO, Saverc, pRegValues[i].FullValueName, 0, 0);

           continue;
       }
       //
       // find the root key
       //
       if ( (7 == pStart-pRegValues[i].FullValueName) &&
            (0 == _wcsnicmp(L"MACHINE", pRegValues[i].FullValueName, 7)) ) {

           hKeyRoot = HKEY_LOCAL_MACHINE;

       } else if ( (5 == pStart-pRegValues[i].FullValueName) &&
                   (0 == _wcsnicmp(L"USERS", pRegValues[i].FullValueName, 5)) ) {
           hKeyRoot = HKEY_USERS;

       } else if ( (12 == pStart-pRegValues[i].FullValueName) &&
                   (0 == _wcsnicmp(L"CLASSES_ROOT", pRegValues[i].FullValueName, 12)) ) {
           hKeyRoot = HKEY_CLASSES_ROOT;

       } else {
           Saverc = SCESTATUS_INVALID_DATA;
           if ( pErrLog ) {
               ScepBuildErrorLogInfo(Saverc,pErrLog, SCEDLL_SCP_ERROR_CONFIGURE,
                                     pRegValues[i].FullValueName);
           } else {
               ScepLogOutput3(1, Saverc, SCEDLL_SCP_ERROR_CONFIGURE, pRegValues[i].FullValueName);
           }

           if ( ConfigOptions & SCE_RSOP_CALLBACK )

               ScepRsopLog(SCE_RSOP_REGISTRY_VALUE_INFO, Saverc, pRegValues[i].FullValueName, 0, 0);

           continue;
       }
       //
       // find the value name
       //
       pValue = pStart+1;

       do {
           pTemp = wcschr(pValue, L'\\');
           if ( pTemp ) {
               pValue = pTemp+1;
           }
       } while ( pTemp );

       if ( pValue == pStart+1 ) {
           Saverc = SCESTATUS_INVALID_DATA;
           if ( pErrLog ) {
               ScepBuildErrorLogInfo(Saverc,pErrLog, SCEDLL_SCP_ERROR_CONFIGURE,
                                     pRegValues[i].FullValueName);
           } else {
               ScepLogOutput3(1, Saverc, SCEDLL_SCP_ERROR_CONFIGURE, pRegValues[i].FullValueName);
           }

           if ( ConfigOptions & SCE_RSOP_CALLBACK )

               ScepRsopLog(SCE_RSOP_REGISTRY_VALUE_INFO, Saverc, pRegValues[i].FullValueName, 0, 0);

           continue;
       }

       //
       // terminate the subkey for now
       //
       *(pValue-1) = L'\0';

       //
       // set the value
       // always create the key if it does not exist.
       //
       rc = RegCreateKeyEx(hKeyRoot,
                            pStart+1,
                            0,
                            NULL,
                            0,
                            KEY_READ | KEY_SET_VALUE,
                            NULL,
                            &hKey,
                            NULL
                            );

       if ( rc == ERROR_SUCCESS ||
            rc == ERROR_ALREADY_EXISTS ) {
/*
       if(( rc = RegOpenKeyEx(hKeyRoot,
                              pStart+1,
                              0,
                              KEY_SET_VALUE,
                              &hKey
                              )) == ERROR_SUCCESS ) {
*/

           //
           // restore the char
           //
           *(pValue-1) = L'\\';

           OneRegValue.FullValueName = NULL;
           OneRegValue.Value = NULL;

           BOOL bLMSetting = FALSE;

           if ( (REG_DWORD == pRegValues[i].ValueType) &&
                _wcsicmp(SCEP_LMC_SETTING, pRegValues[i].FullValueName) == 0 ) {

               //
               // check if dcpromo upgrade in progress
               //
               DWORD dwInSetup=0;
               DWORD dwUpgraded=0;

               ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                           SCE_ROOT_PATH,
                           TEXT("PromoteUpgradeInProgress"),
                           &dwUpgraded
                           );

               if ( dwUpgraded ) {

                   //
                   // in dcpromo upgrade, we need to do special check about
                   // this setting
                   //
                   bLMSetting = TRUE;

               } else {

                   //
                   // check if in setup upgrade
                   //
                   dwUpgraded=0;

                   ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                               TEXT("System\\Setup"),
                               TEXT("SystemSetupInProgress"),
                               &dwInSetup
                               );

                   if ( dwInSetup ) {

                       //
                       // if system is upgraded, the state is stored in registry
                       // by SCE client at very beginning of GUI setup
                       //

                       ScepRegQueryIntValue(
                               HKEY_LOCAL_MACHINE,
                               SCE_ROOT_PATH,
                               TEXT("SetupUpgraded"),
                               (DWORD *)&dwUpgraded
                               );

                       if ( dwUpgraded ) {

                           //
                           // in setup upgrade, we need to do special check about
                           // this setting
                           //
                           bLMSetting = TRUE;
                       }
                   }
               }
           }


           //
           // if in policy propagation, query the existing value
           //
           if ( ( (ConfigOptions & SCE_POLICY_TEMPLATE) && hProfile ) ||
                bLMSetting ) {

               OneRegValue.FullValueName = pRegValues[i].FullValueName;
               OneRegValue.ValueType = pRegValues[i].ValueType;
               OneRegValue.Status = 0;

               DWORD rc2 = ScepAnalyzeOneRegistryValueNoValidate(
                                              hKey,
                                              pValue,
                                              NULL,
                                              SCEREG_VALUE_SYSTEM,
                                              &OneRegValue
                                              );
               if ( ERROR_SUCCESS != rc2 ) {
                   if ( !bLMSetting ) {

                       ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_QUERY, rc2, pRegValues[i].FullValueName);

                   } else if ( ERROR_FILE_NOT_FOUND != rc2 ) {

                       ScepLogOutput3(1, 0, SCESRV_SETUPUPD_ERROR_LMCOMPAT, rc2, pRegValues[i].FullValueName);
                   }
               }
           }

           if ( REG_DWORD == pRegValues[i].ValueType ) {
               //
               // REG_DWORD type, value is a dword
               //
               LONG RegValue = _wtol(pRegValues[i].Value);

               if ( !bLMSetting || OneRegValue.Value == NULL ||
                    _wtol(OneRegValue.Value) <= RegValue ) {

                   rc = RegSetValueEx( hKey,
                                       pValue,
                                       0,
                                       REG_DWORD,
                                       (BYTE *)&RegValue,
                                       sizeof(DWORD)
                                     );
               } else {

                   //
                   // for LMCompatibility level, if in setup, set this value only if
                   // current system setting is less than configuration, or not defined
                   //
                   ScepLogOutput3(2, 0, SCESRV_SETUPUPD_IGNORE_LMCOMPAT, pRegValues[i].FullValueName);
               }

           } else if ( -1 == pRegValues[i].ValueType ) {
               //
               // delete the registry value
               //
               rc = RegDeleteValue(hKey, pValue);
               //
               // if the value doesn't exist, ignore the error
               //
               if ( ERROR_FILE_NOT_FOUND == rc )
                   rc = ERROR_SUCCESS;

           } else {

               PBYTE           pRegBytes=NULL;
               DWORD           nLen;

               nLen = wcslen(pRegValues[i].Value);

               if ( REG_MULTI_SZ == pRegValues[i].ValueType || REG_QWORD == pRegValues[i].ValueType) {
                   //
                   // translate the comma delimited string to multi-sz string
                   //

                   //
                   // LegalNoticeText is special cased i.e. \0 should be converted to \r\n
                   // and commas should be unescaped before writing this value into the registry
                   //

                   BOOL bIsLegalNoticeText = FALSE;

                   if ( !(REG_MULTI_SZ == pRegValues[i].ValueType &&
                        (0 == _wcsicmp(szLegalNoticeTextKeyName, pRegValues[i].FullValueName ) ) ) ) {

                        pRegBytes = (PBYTE)ScepAlloc(0, (nLen+2)*sizeof(WCHAR));

                        if ( pRegBytes ) {

                            wcscpy((PWSTR)pRegBytes, pRegValues[i].Value);
                            ((PWSTR)pRegBytes)[nLen] = L'\0';
                            ((PWSTR)pRegBytes)[nLen+1] = L'\0';

                            ScepConvertMultiSzToDelim((PWSTR)pRegBytes,
                                                      nLen+1,
                                                      L',',
                                                      L'\0'
                                                     );
                        } else {

                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    else {

                        DWORD dwCommaCount = 0;
                        DWORD dwBytes;

                        bIsLegalNoticeText = TRUE;

                        for ( DWORD dwIndex = 0; dwIndex <= nLen; dwIndex++) {
                            if ( pRegValues[i].Value[dwIndex] == L',' )
                                dwCommaCount++;
                        }

                        dwBytes = (nLen + dwCommaCount + 2)*sizeof(WCHAR);

                        pRegBytes = (PBYTE)ScepAlloc(0, dwBytes);

                        if ( pRegBytes ) {

                            memset(pRegBytes, '\0', dwBytes);
                            //
                            // unescape the "," and add \r\n wherever there is a ,
                            //

                            nLen = ScepUnescapeAndAddCRLF( pRegValues[i].Value, (PWSTR) pRegBytes);

                        } else {

                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }

                    }

                    if ( rc == NO_ERROR ) {

                        //
                        // engine/UI treat LegalNoticeText as REG_MULTI_SZ but
                        // we force it to be REG_SZ for compatibility sake
                        //

                        rc = RegSetValueEx( hKey,
                                            pValue,
                                            0,
                                            bIsLegalNoticeText ? REG_SZ : pRegValues[i].ValueType,
                                            pRegBytes,
                                            (nLen+2)*sizeof(WCHAR)
                                          );

                        ScepFree(pRegBytes);

                    }

               } else if ( REG_BINARY == pRegValues[i].ValueType ) {

                   if ( nLen > 0 ) {

                       //
                       // binary type, translate the unicode string to binary data
                       // 4 bytes (2 wchars) to 1 byte
                       //

                       DWORD           newLen;
                       newLen = nLen/2;

                       if ( nLen % 2 ) {
                           newLen++;   // pad a leading 0
                       }

                       pRegBytes = (PBYTE)ScepAlloc(0, newLen);

                       if ( pRegBytes ) {

                           BYTE dByte;

                           for ( INT j=newLen-1; j>=0; j-- ) {

                               if ( nLen % 2 ) {
                                   // odd number of chars
                                   dByte = (pRegValues[i].Value[j*2]-L'0') % 16;
                                   if ( j*2 >= 1 ) {
                                       dByte += ((pRegValues[i].Value[j*2-1]-L'0') % 16) * 16;
                                   }
                               } else {
                                   // even number of chars
                                   dByte = (pRegValues[i].Value[j*2+1]-L'0') % 16;
                                   dByte += ((pRegValues[i].Value[j*2]-L'0') % 16) * 16;
                               }
                                pRegBytes[j] = dByte;
                           }

                           // Special case for code signing policy, this value is protected from
                           // "tampering" so we need to set it through their API to avoid being
                           // overwritten.

                           if (_wcsicmp(
                                   SCEP_DRIVER_SIGNING_SETTING, 
                                   pRegValues[i].FullValueName) == 0 ) {

                               rc = ScepSetDriverSigningPolicy(*pRegBytes);

                            } else {

                                rc = RegSetValueEx( hKey,
                                                    pValue,
                                                    0,
                                                    REG_BINARY,
                                                    pRegBytes,
                                                    newLen
                                                    );
                            }

                           ScepFree(pRegBytes);

                       } else {
                           rc = ERROR_NOT_ENOUGH_MEMORY;
                       }
                   }

               } else {
                   //
                   // sz type, expand_sz
                   //

                   rc = RegSetValueEx( hKey,
                                       pValue,
                                       0,
                                       pRegValues[i].ValueType,
                                       (BYTE *)(pRegValues[i].Value),
                                       (nLen)*sizeof(WCHAR)
                                     );
               }
           }

           //
           // manage the tattoo value
           //
           if ( (ConfigOptions & SCE_POLICY_TEMPLATE) && hProfile ) {
               //
               // if can't query system setting (OneRegValue.Value == NULL)
               // (may be because they are deleted e.g. demotion)
               // we still need to delete the tattoo values
               //
               ScepTattooManageOneRegistryValue(hSectionDomain,
                                                hSectionTattoo,
                                                pRegValues[i].FullValueName,
                                                0,
                                                &OneRegValue,
                                                rc
                                                );
           }

           if ( OneRegValue.Value ) ScepFree(OneRegValue.Value);

           RegCloseKey( hKey );

       }

       if ( NO_ERROR != rc ) {

           if ( pErrLog ) {
               ScepBuildErrorLogInfo(rc,pErrLog, SCEDLL_ERROR_SET_INFO,
                                     pRegValues[i].FullValueName);

           }

           if ( ERROR_FILE_NOT_FOUND != rc &&
                ERROR_PATH_NOT_FOUND != rc ) {

               ScepLogOutput3(1, rc, SCEDLL_ERROR_SET_INFO, pRegValues[i].FullValueName);
               Saverc = ScepDosErrorToSceStatus(rc);
           }

       }

       if ( ConfigOptions & SCE_RSOP_CALLBACK )

           ScepRsopLog(SCE_RSOP_REGISTRY_VALUE_INFO, rc, pRegValues[i].FullValueName, 0, 0);

       if ( pAnythingSet ) {
           *pAnythingSet = TRUE;
       }
   }

   if ( hSectionDomain ) SceJetCloseSection(&hSectionDomain, TRUE);
   if ( hSectionTattoo ) SceJetCloseSection(&hSectionTattoo, TRUE);

   return(Saverc);
}


DWORD
ScepUnescapeAndAddCRLF(
    IN  PWSTR   pszSource,
    IN  OUT PWSTR   pszDest
    )
/* ++

Routine Description:

   Primarily used just before configuration

   Unescapes commas i.e. a","\0b\0c\0\0 -> a,\0b\0c\0\0

   Also replaces , with \r\n


Arguments:

    pszSource       -   The source string

    dwSourceChars   -   The number of chars in pszSource

    pszDest       -   The destination string

Return value:

   Number of characters copied to the destination

-- */
{

    DWORD   dwCharsCopied = 0;

    while (pszSource[0] != L'\0') {

        if (0 == wcsncmp(pszSource, L"\",\"", 3)) {

            pszDest[0] = L',';
            ++dwCharsCopied;

            ++pszDest;
            pszSource +=3;

        }
        else if (pszSource[0] == L',') {

            pszDest[0] = L'\r';
            pszDest[1] = L'\n';
            dwCharsCopied +=2;

            pszDest +=2 ;
            ++pszSource;

        }
        else {

            pszDest[0] = pszSource[0];
            ++dwCharsCopied;

            ++pszDest;
            ++pszSource;
        }
    }

    pszDest = L'\0';
    ++dwCharsCopied;

    return dwCharsCopied;
}


DWORD
ScepEscapeAndRemoveCRLF(
    IN  const PWSTR   pszSource,
    IN  const DWORD   dwSourceSize,
    IN  OUT PWSTR   pszDest
    )
/* ++

Routine Description:

   Primarily used before analysis

   Escapes commas i.e. a,\0b\0c\0\0 -> a","\0b\0c\0\0

   Also replaces \r\n with ,

   This routine is the inverse of ScepUnescapeAndAddCRLF


Arguments:

    pszSource       -   The source string

    dwSourceChars   -   The number of chars in pszSource

    pszDest       -   The destination string

Return value:

   Number of characters copied to the destination

-- */

{

    DWORD   dwSourceIndex = 0;
    DWORD   dwCopiedChars = 0;

    while (dwSourceIndex < dwSourceSize) {

        if (0 == wcsncmp(pszSource + dwSourceIndex, L"\r\n", 2)) {

            pszDest[0] = L',';

            ++pszDest;
            ++dwCopiedChars;
            dwSourceIndex +=2;

        }
        else if (pszSource[dwSourceIndex] == L',') {

            pszDest[0] = L'"';
            pszDest[1] = L',';
            pszDest[2] = L'"';

            pszDest +=3 ;
            dwCopiedChars +=3 ;
            ++dwSourceIndex;

        }
        else {

            pszDest[0] = pszSource[dwSourceIndex];

            ++pszDest;
            ++dwCopiedChars;
            ++dwSourceIndex;
        }
    }

    pszDest = L'\0';

    return dwCopiedChars;
}


SCESTATUS
ScepAnalyzeRegistryValues(
    IN PSCECONTEXT hProfile,
    IN DWORD dwAnalFlag,
    IN PSCE_PROFILE_INFO pSmpInfo
    )
/* ++

Routine Description:

   This routine analyze registry values in the area of security
   policy.

Arguments:

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_OTHER_ERROR

-- */
{
   if ( !pSmpInfo ) {
       return SCESTATUS_INVALID_PARAMETER;
   }

   if ( (dwAnalFlag != SCEREG_VALUE_SYSTEM) && !hProfile ) {
       return SCESTATUS_INVALID_PARAMETER;
   }

   SCESTATUS       Saverc=SCESTATUS_SUCCESS;

   if ( dwAnalFlag != SCEREG_VALUE_ROLLBACK ) {
       Saverc = ScepEnumAllRegValues(
                &(pSmpInfo->RegValueCount),
                &(pSmpInfo->aRegValues)
                );
   }

   if ( Saverc != SCESTATUS_SUCCESS ) {
       return(Saverc);
   }

   if ( pSmpInfo->RegValueCount == 0 ||
        pSmpInfo->aRegValues == NULL ) {
      //
      // if no info to configure
      //
      return SCESTATUS_SUCCESS;
   }

   DWORD           rc;
   DWORD           i;
   PSCESECTION     hSection=NULL;
   SCEJET_TABLE_TYPE tblType;

   if ( dwAnalFlag != SCEREG_VALUE_SYSTEM ) {
       //
       // query value from system doesn't require accessing the database
       //
       switch ( dwAnalFlag ) {
       case SCEREG_VALUE_SNAPSHOT:
       case SCEREG_VALUE_FILTER:
       case SCEREG_VALUE_ROLLBACK:
           tblType = SCEJET_TABLE_SMP;
           break;
       default:
           tblType = SCEJET_TABLE_SAP;
           break;
       }
       //
       // Prepare a new section
       // for delay filter mode, data is written to the SMP (local) table
       // when the setting is different from the effective setting (changed outside GPO)
       //
       Saverc = ScepStartANewSection(
                   hProfile,
                   &hSection,
                   tblType,
                   szRegistryValues
                   );
       if ( Saverc != SCESTATUS_SUCCESS ) {
           ScepLogOutput3(1, ScepSceStatusToDosError(Saverc),
                          SCEDLL_SAP_START_SECTION, (PWSTR)szRegistryValues);
           return(Saverc);
       }
   }

   for ( i=0; i<pSmpInfo->RegValueCount; i++ ) {

       if ( dwAnalFlag == SCEREG_VALUE_SYSTEM ) {
           //
           // mark the status field
           //
           (pSmpInfo->aRegValues)[i].Status = SCE_STATUS_ERROR_NOT_AVAILABLE;

       }

       if ( !((pSmpInfo->aRegValues)[i].FullValueName) ) {
           continue;
       }

       ScepLogOutput3(2, 0, SCEDLL_SAP_ANALYZE, (pSmpInfo->aRegValues)[i].FullValueName);


       rc = ScepAnalyzeOneRegistryValue(
                        hSection,
                        dwAnalFlag,
                        &((pSmpInfo->aRegValues)[i])
                        );

       if ( SCESTATUS_INVALID_PARAMETER == rc ||
            SCESTATUS_INVALID_DATA == rc ) {
           continue;
       }

       if ( SCESTATUS_SUCCESS != rc ) {
           Saverc = rc;

           break;
       }
   }

   //
   // close the section
   //

   SceJetCloseSection( &hSection, TRUE);

   return(Saverc);

}

SCESTATUS
ScepAnalyzeOneRegistryValue(
    IN PSCESECTION hSection OPTIONAL,
    IN DWORD dwAnalFlag,
    IN OUT PSCE_REGISTRY_VALUE_INFO pOneRegValue
    )
{
    SCESTATUS       Saverc=SCESTATUS_SUCCESS;
    PWSTR           pStart, pTemp, pValue;
    HKEY            hKey=NULL, hKeyRoot;
    DWORD           rc=0;


    if ( pOneRegValue == NULL ||
         pOneRegValue->FullValueName == NULL ) {
        return(SCESTATUS_INVALID_DATA);
    }

    if ( hSection == NULL &&
         (SCEREG_VALUE_ANALYZE == dwAnalFlag ||
          SCEREG_VALUE_ROLLBACK == dwAnalFlag) ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // look for the first \\
    //
    pStart = wcschr(pOneRegValue->FullValueName, L'\\') ;

    if ( !pStart ) {
        //
        // if it's in snapshot mode, ignore bogus reg value names
        //
        Saverc = SCESTATUS_INVALID_DATA;
        if ( SCEREG_VALUE_ANALYZE == dwAnalFlag ) {

           //
           // error analyzing the value, save it
           //
           ScepSaveRegistryValue(
                    hSection,
                    pOneRegValue->FullValueName,
                    pOneRegValue->ValueType,
                    NULL,
                    0,
                    SCE_STATUS_ERROR_NOT_AVAILABLE
                    );
        }
        return(Saverc);
    }

    //
    // find the root key
    //
    if ( (7 == pStart-pOneRegValue->FullValueName) &&
        (0 == _wcsnicmp(L"MACHINE", pOneRegValue->FullValueName, 7)) ) {

       hKeyRoot = HKEY_LOCAL_MACHINE;

    } else if ( (5 == pStart-pOneRegValue->FullValueName) &&
               (0 == _wcsnicmp(L"USERS", pOneRegValue->FullValueName, 5)) ) {
       hKeyRoot = HKEY_USERS;

    } else if ( (12 == pStart-pOneRegValue->FullValueName) &&
               (0 == _wcsnicmp(L"CLASSES_ROOT", pOneRegValue->FullValueName, 12)) ) {
       hKeyRoot = HKEY_CLASSES_ROOT;

    } else {

       //
       // if it's in snapshot mode, ignore bogus reg value names
       //
       Saverc = SCESTATUS_INVALID_DATA;
       if ( SCEREG_VALUE_ANALYZE == dwAnalFlag ) {
           //
           // error analyzing the value, save it
           //
           ScepSaveRegistryValue(
                    hSection,
                    pOneRegValue->FullValueName,
                    pOneRegValue->ValueType,
                    NULL,
                    0,
                    SCE_STATUS_ERROR_NOT_AVAILABLE
                    );
       }
       return(Saverc);
   }

   //
   // find the value name
   //
   pValue = pStart+1;

   do {
       pTemp = wcschr(pValue, L'\\');
       if ( pTemp ) {
           pValue = pTemp+1;
       }
   } while ( pTemp );

   if ( pValue == pStart+1 ) {

       //
       // if it's in snapshot mode, ignore bogus reg value names
       //
       Saverc = SCESTATUS_INVALID_DATA;
       if ( SCEREG_VALUE_ANALYZE == dwAnalFlag ) {

           //
           // error analyzing the value, save it
           //
           ScepSaveRegistryValue(
                    hSection,
                    pOneRegValue->FullValueName,
                    pOneRegValue->ValueType,
                    NULL,
                    0,
                    SCE_STATUS_ERROR_NOT_AVAILABLE
                    );
       }
       return(Saverc);
   }

   //
   // terminate the subkey for now
   //
   *(pValue-1) = L'\0';

   if(( rc = RegOpenKeyEx(hKeyRoot,
                          pStart+1,
                          0,
                          KEY_READ,
                          &hKey
                          )) == ERROR_SUCCESS ) {

       //
       // resotre the char
       //
       *(pValue-1) = L'\\';

       rc = ScepAnalyzeOneRegistryValueNoValidate(hKey,
                                                 pValue,
                                                 hSection,
                                                 dwAnalFlag,
                                                 pOneRegValue
                                               );
       //
       // close the key
       //
       RegCloseKey(hKey);

   } else {

       //
       // restore the char
       //
       *(pValue-1) = L'\\';

       //
       // error analyzing the value, or it doesn't exist, save it
       //
       if ( (SCEREG_VALUE_ANALYZE == dwAnalFlag) ||
            (SCEREG_VALUE_ROLLBACK == dwAnalFlag) ) {

           ScepSaveRegistryValue(
                    hSection,
                    pOneRegValue->FullValueName,
                    (SCEREG_VALUE_ANALYZE == dwAnalFlag) ? pOneRegValue->ValueType : -1,
                    NULL,
                    0,
                    (SCEREG_VALUE_ANALYZE == dwAnalFlag) ? SCE_STATUS_ERROR_NOT_AVAILABLE : 0
                    );
       }

       if ( rc == ERROR_FILE_NOT_FOUND ||
            rc == ERROR_PATH_NOT_FOUND ||
            rc == ERROR_INVALID_HANDLE ||
            rc == ERROR_ACCESS_DENIED ) {

           rc = ERROR_SUCCESS;
       }
   }

   if ( rc != NO_ERROR ) {
       ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_ANALYZE, pOneRegValue->FullValueName);

       Saverc = ScepDosErrorToSceStatus(rc);
   }

   return(Saverc);

}

DWORD
ScepAnalyzeOneRegistryValueNoValidate(
    IN HKEY hKey,
    IN PWSTR ValueName,
    IN PSCESECTION hSection OPTIONAL,
    IN DWORD dwAnalFlag,
    IN OUT PSCE_REGISTRY_VALUE_INFO pOneRegValue
    )
/*
Query and/or compare one registry value without validating the value name, etc.
The validation should be done outside of this routine.

This routine is primarily defined for sharing in both configuration and analysis.

*/
{
   if ( hKey == NULL || ValueName == NULL || pOneRegValue == NULL )
       return(ERROR_INVALID_PARAMETER);

   DWORD           rc;
   DWORD           dSize=0;
   DWORD           RegType=pOneRegValue->ValueType;
   DWORD           RegData=0;
   PWSTR           strValue=NULL;
   BOOL            bIsLegalNoticeText = FALSE;


   if ( SCEREG_VALUE_SYSTEM == dwAnalFlag ) {
       //
       // reset the status field, it's not error'ed
       //
       pOneRegValue->Status = 0;
   }

   if(( rc = RegQueryValueEx(hKey,
                             ValueName,
                             0,
                             &RegType,
                             NULL,
                             &dSize
                             )) == ERROR_SUCCESS ) {

       //
       // we treat REG_DWORD_BIG_ENDIAN the same as REG_DWORD
       //
       if ( RegType == REG_DWORD_BIG_ENDIAN ) {
           RegType = REG_DWORD;
       }

       if ( 0 == _wcsicmp( pOneRegValue->FullValueName, szLegalNoticeTextKeyName)) {

           bIsLegalNoticeText = TRUE;

           RegType = REG_MULTI_SZ;

       } else if (  RegType != pOneRegValue->ValueType ) {
           //
           // if it's a wrong type, we assure it's not the value we found
           //
           rc = ERROR_FILE_NOT_FOUND;

       }

       if ( ERROR_SUCCESS == rc ) {

           switch (RegType) {
           case REG_DWORD:

               dSize = sizeof(DWORD);
               rc = RegQueryValueEx(hKey,
                                      ValueName,
                                      0,
                                      &RegType,
                                      (BYTE *)&RegData,
                                      &dSize
                                     );
               break;
           default:

               //
               // can be REG_BINARY, REG_MULTI_SZ, REG_SZ, and REG_EXPAND_SZ
               // everything else is treated as REG_SZ
               //

               strValue = (PWSTR)ScepAlloc(0, dSize + 4);
               dSize += 2;

               if ( strValue ) {

                   memset(strValue, 0, dSize + 4 - 2);
                   rc = RegQueryValueEx(hKey,
                                          ValueName,
                                          0,
                                          &RegType,
                                          (BYTE *)strValue,
                                          &dSize
                                         );

                   if (bIsLegalNoticeText) {
                       RegType = REG_MULTI_SZ;
                   }

               } else {
                   rc = ERROR_NOT_ENOUGH_MEMORY;
               }

               break;
           }
       }
   }

   if ( rc == NO_ERROR ) {

       DWORD dwStatus = SCE_STATUS_NOT_CONFIGURED;
       if ( SCEREG_VALUE_SNAPSHOT == dwAnalFlag ||
            SCEREG_VALUE_ROLLBACK == dwAnalFlag )
           dwStatus = 0;

       switch ( RegType ) {
       case REG_DWORD:
       case REG_DWORD_BIG_ENDIAN:

           if ( pOneRegValue->Value == NULL ||
                (SCEREG_VALUE_SNAPSHOT == dwAnalFlag)  ) {

               if ( SCEREG_VALUE_SYSTEM == dwAnalFlag ) {
                   //
                   // add the value to OneRegValue buffer
                   //
                   rc = ScepSaveRegistryValueToBuffer(
                                REG_DWORD,
                                (PWSTR)&RegData,
                                sizeof(DWORD),
                                pOneRegValue
                                );

               } else if ( SCEREG_VALUE_FILTER != dwAnalFlag ) {

                   //
                   // not configured, or snapshot the current value
                   //
                   rc = ScepSaveRegistryValue(
                                hSection,
                                pOneRegValue->FullValueName,
                                REG_DWORD,
                                (PWSTR)&RegData,
                                sizeof(DWORD),
                                dwStatus
                                );
               } // else for the delay filter, only query the reg values configured

           } else if ( (LONG)RegData != _wtol(pOneRegValue->Value) ) {

               rc = ScepSaveRegistryValue(
                            hSection,
                            pOneRegValue->FullValueName,
                            REG_DWORD,
                            (PWSTR)&RegData,
                            sizeof(DWORD),
                            0
                            );
           }
           break;

       case REG_BINARY:

           DWORD           nLen;
           if ( pOneRegValue->Value ) {
               nLen = wcslen(pOneRegValue->Value);
           } else {
               nLen = 0;
           }

           if ( pOneRegValue->Value == NULL ||
                (SCEREG_VALUE_SNAPSHOT == dwAnalFlag) ||
                nLen == 0 ) {

               if ( SCEREG_VALUE_SYSTEM == dwAnalFlag ) {

                   //
                   // add the value to OneRegValue buffer
                   //
                   rc = ScepSaveRegistryValueToBuffer(
                                RegType,
                                strValue,
                                dSize,
                                pOneRegValue
                                );

               } else if ( SCEREG_VALUE_FILTER != dwAnalFlag ) {
                   //
                   // not configured, or snapshot the current value
                   //
                   rc = ScepSaveRegistryValue(
                                hSection,
                                pOneRegValue->FullValueName,
                                RegType,
                                strValue,
                                dSize,
                                dwStatus
                                );
               }

           } else if ( strValue ) {

               DWORD           newLen;

               newLen = nLen/2;

               if ( nLen % 2 ) {
                   newLen++;   // pad a leading 0
               }

               PBYTE pRegBytes = (PBYTE)ScepAlloc(0, newLen);

               if ( pRegBytes ) {

                   BYTE dByte;

                   for ( INT j=newLen-1; j>=0; j-- ) {

                       if ( nLen % 2 ) {
                           // odd number of chars
                           dByte = (pOneRegValue->Value[j*2]-L'0') % 16;
                           if ( j*2 >= 1 ) {
                               dByte += ((pOneRegValue->Value[j*2-1]-L'0') % 16) * 16;
                           }
                       } else {
                           // even number of chars
                           dByte = (pOneRegValue->Value[j*2+1]-L'0') % 16;
                           dByte += ((pOneRegValue->Value[j*2]-L'0') % 16) * 16;
                       }
                        pRegBytes[j] = dByte;
                   }

                   if ( memcmp(strValue, pRegBytes, dSize) == 0 ) {

                       //
                       // matched, do not do anything
                       //

                   } else {

                       //
                       // mismatched, save the binary data
                       //
                       rc = ScepSaveRegistryValue(
                                    hSection,
                                    pOneRegValue->FullValueName,
                                    RegType,
                                    strValue,
                                    dSize,
                                    0
                                    );
                   }

                   ScepFree(pRegBytes);

               } else {
                   //
                   // out of memory
                   //
                   rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
               }

           } else {

               //
               // mismatched, save the binary data
               //
               rc = ScepSaveRegistryValue(
                            hSection,
                            pOneRegValue->FullValueName,
                            RegType,
                            strValue,
                            dSize,
                            0
                            );
           }
           break;

       case REG_MULTI_SZ:
       case REG_QWORD:

           if ( strValue ) {

               if ( !(RegType == REG_MULTI_SZ &&
                    (0 == _wcsicmp( pOneRegValue->FullValueName, szLegalNoticeTextKeyName) ) ) ) {

                   ScepConvertMultiSzToDelim(strValue, dSize/2, L'\0', L',');

               }
               else {

                   DWORD dwCommaCount = 0;
                   PWSTR strValueNew;
                   DWORD dwBytes;

                   for (DWORD dwIndex=0; dwIndex < dSize/2; dwIndex++) {
                       if ( strValue[dwIndex] == L',' )
                           dwCommaCount++;
                   }

                   dwBytes = (dSize/2+dwCommaCount * 2 + 1) * sizeof(WCHAR);
                   strValueNew = (PWSTR)ScepAlloc(0, dwBytes);

                   if (strValueNew) {

                       memset(strValueNew, '\0', dwBytes);

                       dSize = 2 + 2 * ScepEscapeAndRemoveCRLF( strValue, dSize/2, strValueNew);

                       ScepFree(strValue);

                       strValue = strValueNew;
                   }
                   else {

                       rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                       break;

                   }

               }

           }
           // fall through
       default:

           if ( pOneRegValue->Value == NULL ||
                (SCEREG_VALUE_SNAPSHOT == dwAnalFlag) ) {

               if ( SCEREG_VALUE_SYSTEM == dwAnalFlag ) {

                   //
                   // add the value to OneRegValue buffer
                   //
                   rc = ScepSaveRegistryValueToBuffer(
                                RegType,
                                strValue,
                                dSize,
                                pOneRegValue
                                );

               } else if ( SCEREG_VALUE_FILTER != dwAnalFlag ) {
                   rc = ScepSaveRegistryValue(
                                hSection,
                                pOneRegValue->FullValueName,
                                RegType,
                                strValue,
                                dSize,
                                dwStatus
                                );
               }
           } else if ( strValue && bIsLegalNoticeText &&
                       (pOneRegValue->ValueType != RegType)) {
               //
               // legalnotice text special case
               // must be old template is used
               // each comma is escaped with two quotes
               //

               DWORD Len = wcslen(pOneRegValue->Value);
               PWSTR NewValue = (PWSTR)ScepAlloc(LPTR, Len*3*sizeof(WCHAR));

               if ( NewValue ) {

                   ScepEscapeAndRemoveCRLF(pOneRegValue->Value, Len, NewValue);

                   if ( _wcsicmp(NewValue, strValue) != 0 ) {
                       //
                       // mismatched, save the item to the database
                       //
                       rc = ScepSaveRegistryValue(
                                    hSection,
                                    pOneRegValue->FullValueName,
                                    RegType,
                                    strValue,
                                    dSize,
                                    0
                                    );
                   }

                   ScepFree(NewValue);

               } else {
                   rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
               }


           } else if ( strValue &&
                _wcsicmp(pOneRegValue->Value, strValue) == 0 ) {
               //
               // matched, do not do anything
               //
           } else {
               //
               // mismatched, save the item to the database
               //
               rc = ScepSaveRegistryValue(
                            hSection,
                            pOneRegValue->FullValueName,
                            RegType,
                            strValue,
                            dSize,
                            0
                            );
           }
           break;
       }

       rc = ScepSceStatusToDosError(rc);

   } else {

       //
       // error analyzing the value, or it doesn't exist, save it
       // if the registry value doesn't exist, doesn't mean it's 0
       // just log an "not available" status in this case
       //
       if ( (SCEREG_VALUE_ANALYZE == dwAnalFlag) ||
            (SCEREG_VALUE_ROLLBACK == dwAnalFlag) ) {

           ScepSaveRegistryValue(
                    hSection,
                    pOneRegValue->FullValueName,
                    (SCEREG_VALUE_ANALYZE == dwAnalFlag) ? pOneRegValue->ValueType : -1,
                    NULL,
                    0,
                    (SCEREG_VALUE_ANALYZE == dwAnalFlag) ? SCE_STATUS_ERROR_NOT_AVAILABLE : 0
                    );
       }

       if ( rc == ERROR_FILE_NOT_FOUND ||
            rc == ERROR_PATH_NOT_FOUND ||
            rc == ERROR_INVALID_HANDLE ||
            rc == ERROR_ACCESS_DENIED ) {

           rc = ERROR_SUCCESS;
       }
   }

   //
   // free buffer
   //
   if ( strValue ) {
       ScepFree(strValue);
       strValue = NULL;
   }

   return(rc);

}


SCESTATUS
ScepSaveRegistryValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN DWORD RegType,
    IN PWSTR CurrentValue,
    IN DWORD CurrentBytes,
    IN DWORD Status
    )
/* ++
Routine Description:

    This routine compares system settings in string with the baseline profile
    settings. If there is mismatch or unknown, the entry is saved in the SAP
    profile.

Arguments:

    hSection - The section handle

    Name    - The entry name

    RegType  - the registry value type

    CurrentValue - The current system setting

    CurrentBytes - The length of the current setting

    Status - the status of this registry vlue analyzed

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS  rc;

    if ( Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( CurrentValue == NULL &&
         REG_DWORD == RegType &&
         Status == 0 ) {
        //
        // only return if it's a DWORD type and saving for mismatch status
        // for other types, NULL should be treated as ""
        return(SCESTATUS_SUCCESS);
    }

    //
    // build a buffer containing type and value
    // note MULTI_SZ must be converted to null delimited
    //

    if ( REG_DWORD == RegType ) {

        TCHAR StrValue[20];
        memset(StrValue, '\0', 40);

        *((CHAR *)StrValue) = (BYTE)RegType + '0';

        if ( Status == 0) {
           *((CHAR *)StrValue+1) = SCE_STATUS_MISMATCH + '0';
        } else {
            *((CHAR *)StrValue+1) = (BYTE)Status + '0';
        }
        StrValue[1] = L'\0';

        if ( CurrentValue ) {
            swprintf(StrValue+2, L"%d", *CurrentValue);
        }
        rc = SceJetSetLine( hSection, Name, FALSE, StrValue, (2+wcslen(StrValue+2))*2, 0);

    } else {

        PWSTR StrValue;

        if ( (CurrentBytes % 2) && REG_BINARY == RegType ) {
            StrValue = (PWSTR)ScepAlloc(0, CurrentBytes+9);
        }
        else {
            StrValue = (PWSTR)ScepAlloc(0, CurrentBytes+8);   // 4 wide chars: one for type, one delim, and two NULL
        }

        if ( StrValue ) {

            memset(StrValue, 0, sizeof(StrValue));
            *((CHAR *)StrValue) = (BYTE)RegType + '0';

            if ( Status == 0) {
               *((CHAR *)StrValue+1) = SCE_STATUS_MISMATCH + '0';
            } else {
                *((CHAR *)StrValue+1) = (BYTE)Status + '0';
            }
            StrValue[1] = L'\0';

            if ( CurrentValue ) {
                if (REG_BINARY == RegType && CurrentBytes == 1) {
                    swprintf(StrValue+2, L"%d", *CurrentValue);
                }
                else {
                    memcpy(StrValue+2, (PBYTE)CurrentValue, CurrentBytes);
                }
            }

            if ( (CurrentBytes % 2) && REG_BINARY == RegType ) {
                StrValue[CurrentBytes/2+3] = L'\0';
                StrValue[CurrentBytes/2+4] = L'\0';
            }
            else {
                StrValue[CurrentBytes/2+2] = L'\0';
                StrValue[CurrentBytes/2+3] = L'\0';
            }

            if ( REG_MULTI_SZ == RegType || REG_QWORD == RegType ) {
                //
                // convert the , to null
                //
                ScepConvertMultiSzToDelim(StrValue+2, CurrentBytes/2, L',', L'\0');

            }

            if ( (CurrentBytes % 2) && REG_BINARY == RegType ) {
                rc = SceJetSetLine( hSection, Name, FALSE, StrValue, CurrentBytes+7, 0);
            }
            else {
                rc = SceJetSetLine( hSection, Name, FALSE, StrValue, CurrentBytes+6, 0);
            }

            ScepFree(StrValue);

        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    switch (Status) {
    case SCE_STATUS_ERROR_NOT_AVAILABLE:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_ERROR, Name);
        break;
    case SCE_STATUS_NOT_CONFIGURED:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
        break;
    default:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
        break;
    }

    return(rc);

}

SCESTATUS
ScepSaveRegistryValueToBuffer(
    IN DWORD RegType,
    IN PWSTR Value,
    IN DWORD dwBytes,
    IN OUT PSCE_REGISTRY_VALUE_INFO pRegValues
    )
/* ++
Routine Description:

    This routine saves the registry value to the buffer

Arguments:

    RegType  - the registry value type

    Value - The current system setting

    dwBytes - The length of the current setting

    pRegValues - the buffer for this registry value to save to

-- */
{
    SCESTATUS  rc=SCESTATUS_SUCCESS;

    if ( pRegValues == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( Value == NULL || dwBytes == 0 ) {
        // nothing to save
        return(SCESTATUS_SUCCESS);
    }

    //
    // build a buffer containing type and value
    // note MULTI_SZ must be converted to null delimited
    //

    if ( REG_DWORD == RegType ) {

        TCHAR StrValue[20];
        DWORD   *pdwValue = (DWORD *)Value;
        memset(StrValue, '\0', 40);

        _ultow(*pdwValue, StrValue, 10);

        PWSTR pValue = (PWSTR)ScepAlloc(0, (wcslen(StrValue)+1)*2);

        if ( pValue ) {

            wcscpy(pValue, StrValue);

            pRegValues->Value = pValue;
            pRegValues->ValueType = RegType;

        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }

    } else {

        PWSTR StrValue;

        if ( (dwBytes % 2) && REG_BINARY == RegType ) {
            StrValue = (PWSTR)ScepAlloc(LPTR, dwBytes+5);
        } else {
            StrValue = (PWSTR)ScepAlloc(LPTR, dwBytes+4);   // 2 wide chars: two NULL
        }

        if ( StrValue ) {

            if (REG_BINARY == RegType && dwBytes == 1) {
                swprintf(StrValue, L"%d", *Value);
            } else {
                memcpy(StrValue, (PBYTE)Value, dwBytes);
            }

            if ( (dwBytes % 2) && REG_BINARY == RegType ) {
                StrValue[dwBytes/2+1] = L'\0';
                StrValue[dwBytes/2+2] = L'\0';
            }
            else {
                StrValue[dwBytes/2+0] = L'\0';
                StrValue[dwBytes/2+1] = L'\0';
            }


            pRegValues->Value = StrValue;
            pRegValues->ValueType = RegType;

        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    return(rc);

}


SCESTATUS
ScepEnumAllRegValues(
    IN OUT PDWORD  pCount,
    IN OUT PSCE_REGISTRY_VALUE_INFO    *paRegValues
    )
/*
Routine Description:

    Enumerate all registry values supported by SCE from registry.

Arguments:

    pCount          - the number of reg values to output

    paRegValues     - the array of registry values to output

Return Value:


*/
{
   DWORD   Win32Rc;
   HKEY    hKey=NULL;
   PSCE_NAME_STATUS_LIST pnsList=NULL;
   DWORD   nAdded=0;


   Win32Rc = RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE,
                     SCE_ROOT_REGVALUE_PATH,
                     0,
                     KEY_READ,
                     &hKey
                     );

   DWORD cSubKeys = 0;
   DWORD nMaxLen;

   if ( Win32Rc == ERROR_SUCCESS ) {

      //
      // enumerate all subkeys of the key
      //

      Win32Rc = RegQueryInfoKey (
                                hKey,
                                NULL,
                                NULL,
                                NULL,
                                &cSubKeys,
                                &nMaxLen,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );
   }

   if ( Win32Rc == ERROR_SUCCESS && cSubKeys > 0 ) {

      PWSTR   szName = (PWSTR)ScepAlloc(0, (nMaxLen+2)*sizeof(WCHAR));

      if ( !szName ) {
         Win32Rc = ERROR_NOT_ENOUGH_MEMORY;

      } else {

         DWORD   BufSize;
         DWORD   index = 0;

         do {

            BufSize = nMaxLen+1;
            Win32Rc = RegEnumKeyEx(
                                  hKey,
                                  index,
                                  szName,
                                  &BufSize,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

            if ( ERROR_SUCCESS == Win32Rc ) {

               index++;

               //
               // get the full registry key name and Valuetype
               //
               cSubKeys = REG_SZ;

               //
               // query ValueType, if error, default REG_SZ
               //
               ScepRegQueryIntValue( hKey,
                                    szName,
                                    SCE_REG_VALUE_TYPE,
                                    &cSubKeys
                                    );

               if ( cSubKeys < REG_SZ || cSubKeys > REG_MULTI_SZ ) {
                  cSubKeys = REG_SZ;
               }

               //
               // convert the path name
               //
               ScepConvertMultiSzToDelim(szName, BufSize, L'/', L'\\');

               //
               // compare with the input array, if not exist,
               // add it
               //
               for ( DWORD i=0; i<*pCount; i++ ) {
                  if ( (*paRegValues)[i].FullValueName &&
                       _wcsicmp(szName, (*paRegValues)[i].FullValueName) == 0 ) {
                     break;
                  }
               }

               if ( i >= *pCount ) {
                  //
                  // did not find a match, add it
                  //
                  if ( SCESTATUS_SUCCESS != ScepAddToNameStatusList(&pnsList,
                                                                   szName,
                                                                   BufSize,
                                                                   cSubKeys) ) {

                     Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                     break;
                  }
                  nAdded++;
               }

            } else if ( ERROR_NO_MORE_ITEMS != Win32Rc ) {
               break;
            }

         } while ( Win32Rc != ERROR_NO_MORE_ITEMS );

         if ( Win32Rc == ERROR_NO_MORE_ITEMS ) {
            Win32Rc = ERROR_SUCCESS;
         }


         //
         // free the enumeration buffer
         //
         ScepFree(szName);
      }
   }

   if ( hKey ) {

      RegCloseKey(hKey);
   }


   if ( ERROR_SUCCESS == Win32Rc ) {
      //
      // add the name list to the output arrays
      //
      DWORD nNewCount = *pCount + nAdded;
      PSCE_REGISTRY_VALUE_INFO aNewArray;

      if ( nNewCount ) {

         aNewArray = (PSCE_REGISTRY_VALUE_INFO)ScepAlloc(0, nNewCount*sizeof(SCE_REGISTRY_VALUE_INFO));

         if ( aNewArray ) {

            DWORD i;
            for ( i=0; i<*pCount; i++ ) {
               aNewArray[i].FullValueName = (*paRegValues)[i].FullValueName;
               aNewArray[i].Value = (*paRegValues)[i].Value;
               aNewArray[i].ValueType = (*paRegValues)[i].ValueType;
            }

            i=0;
            for ( PSCE_NAME_STATUS_LIST pns=pnsList;
                pns; pns=pns->Next ) {

               if ( pns->Name && i < nAdded ) {

                  aNewArray[*pCount+i].FullValueName = pns->Name;
                  pns->Name = NULL;
                  aNewArray[*pCount+i].Value = NULL;
                  aNewArray[*pCount+i].ValueType = pns->Status;

                  i++;

               }
            }

            //
            // free the original array
            // all components in the array are already transferred to the new array
            //
            ScepFree(*paRegValues);
            *pCount = nNewCount;
            *paRegValues = aNewArray;

         } else {

            Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
         }
      }
   }

   if ( ERROR_FILE_NOT_FOUND == Win32Rc ||
        ERROR_PATH_NOT_FOUND == Win32Rc ) {
       //
       // no value has been registered
       //
       Win32Rc = ERROR_SUCCESS;
   }

   //
   // free the name status list
   //
   SceFreeMemory(pnsList, SCE_STRUCT_NAME_STATUS_LIST);

   return( ScepDosErrorToSceStatus(Win32Rc) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\queue.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    queue.cpp

Abstract:

    queue algorithms and data structures to handle policy notifications

Author:

    Vishnu Patankar (vishnup) 15-Aug-2000 created

--*/
#include "serverp.h"
#include "sceutil.h"
#include "queue.h"
#include "sddl.h"

extern HINSTANCE MyModuleHandle;
static HANDLE  hNotificationThread = NULL;
static HANDLE  ghEventNotificationQEnqueue = NULL;
static HANDLE  ghEventPolicyPropagation = NULL;
HANDLE  ghEventSamFilterAndPolicyPropExclusion = NULL;

static BOOL    gbShutdownForNotification = FALSE;
static HANDLE  hNotificationLogFile = INVALID_HANDLE_VALUE;

#define SCEPOL_NOTIFY_DEBUG_LEVEL           L"PolicyDebugLevel"
#define SCEPOL_NOTIFY_LOG_SIZE              L"PolicyLogSize"
#define SCEPOL_NOTIFY_MAX_PDC_WAIT          L"PolicyMaxWaitPDCSync"
#define SCEPOL_NOTIFY_PDC_RETRY_INTERVAL    L"PolicyPDCSyncRetryInterval"
#define SCEPOL_NOTIFY_ALLOW_PDC_DIFF        L"PolicyAllowedDiffTime"
#define SCEPOL_NOTIFY_REQUIRE_PDC_SYNC      L"PolicyRequirePDCSync"

//
// turn-on logging until registry queried by system thread (at least until testing)
//

static DWORD gdwNotificationLog = 2;
DWORD gdwMaxPDCWait = 30*24*60;
DWORD gdwPDCRetry = 20;
DWORD gdwRequirePDCSync = 1;
BOOL  gbCheckSync = FALSE;

BOOL bQueriedProductTypeForNotification = FALSE;
static NT_PRODUCT_TYPE ProductTypeForNotification;
static CRITICAL_SECTION NotificationQSync;

#define SCEP_MAX_RETRY_NOTIFICATIONQ_NODES 1000
#define SCEP_NOTIFICATION_RETRY_COUNT 10
#define SCEP_NOTIFICATION_LOGFILE_SIZE 0x1 << 20
#define SCEP_NOTIFICATION_EVENT_TIMEOUT_SECS 600
#define SCEP_MINIMUM_DISK_SPACE  5 * (0x1 << 20)

#define SCEP_NOTIFICATION_EVENT  L"E_ScepNotificationQEnqueue"
#define SCEP_POLICY_PROP_EVENT   L"E_ScepPolicyPropagation"


//
// queue head needs to be accessed in server.cpp
//
PSCESRV_POLQUEUE pNotificationQHead=NULL;
static PSCESRV_POLQUEUE pNotificationQTail=NULL;
static DWORD gdwNumNotificationQNodes = 0;
static DWORD gdwNumNotificationQRetryNodes = 0;

static BOOL gbSuspendQueue=FALSE;

PWSTR   OpTypeTable[] = {
    L"Enqueue",
    L"Dequeue",
    L"Retry",
    L"Process"
};

DWORD
ScepCheckAndWaitFreeDiskSpaceInSysvol();

//
// todo - consider exception handling in the enqueue routine (in case we claim a critsec and av)
//


DWORD
ScepNotificationQInitialize(
    )
/*
Routine Description:

    This function is called when SCE server data is initialized (system startup).

    This function initializes data/buffer/state related to queue
    management, for example, the queue, critical sections, global variables, etc.

    This function also checks for any saved queue items from previous system
    shutdown and initializes the queue with the saved items.

Arguments:

    None

Return Value:

    Win32 error code
*/
{

    DWORD   rc = ERROR_SUCCESS;

    //
    // initialize head and tail to reflect an empty queue
    //

    pNotificationQHead = NULL;
    pNotificationQTail = NULL;


    //
    // initialize the log file on DCs only (for perf reasons no need to do so for non-DCs)
    // (assuming that this routine is called before ScepQueueStartSystemThread)
    //

    if ( RtlGetNtProductType( &ProductTypeForNotification ) ) {

        if (ProductTypeForNotification != NtProductLanManNt )

            gdwNotificationLog = 0;

        bQueriedProductTypeForNotification = TRUE;

    }

    ScepNotificationLogOpen();

    //
    // this critical section is used to sequentialize writes to the queue
    // reads need not be protected against/from
    //

    ScepNotifyLogPolicy(0, TRUE, L"Initialize NotificationQSync", 0, 0, NULL );

    InitializeCriticalSection(&NotificationQSync);

    //
    // check for any saved queue items from previous system
    // initialize queue with these items from some persistent store
    //

    rc = ScepNotificationQUnFlush();

    ScepNotifyLogPolicy(rc, FALSE, L"Unflush Notification Queue", 0, 0, NULL );

    return rc;
}


NTSTATUS
ScepQueueStartSystemThread(
    )
/*
Routine Description:

    This function is called when SCE server is started (system startup) after
    RPC server starts listening.

    This function creates a worker thread. The worker thread manages the queue.
    If the thread fails to get created, an error is returned.

Arguments:

    None

Return Value:

    Dos error code

*/
{
    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwThreadId = 0;
    WCHAR   pszMsg[MAX_PATH];


    //
    // ProductType of the machine is initialized into a thread global variable to be
    // used by policy filter. The type determines where to save the policy changes (DB or GP).
    // Based on the product type, different policy notification APIs are called.
    //

    if ( !bQueriedProductTypeForNotification && !RtlGetNtProductType( &ProductTypeForNotification ) ) {

        //
        // on failure, ProductTypeForNotification = NtProductWinNt, continue
        //

        ScepNotifyLogPolicy(ERROR_BAD_ENVIRONMENT, TRUE, L"Get product type", 0, 0, NULL );

    }

    if (ProductTypeForNotification == NtProductLanManNt ) {


        //
        // create a manual reset event whose initial state is set
        // this event enforces mutual exclusion between SAM filter
        // notifications and SCE policy propagation
        //

        ghEventSamFilterAndPolicyPropExclusion = CreateEvent(
                                                            NULL,
                                                            TRUE,
                                                            TRUE,
                                                            SCEP_SAM_FILTER_POLICY_PROP_EVENT
                                                            );

        if ( ghEventSamFilterAndPolicyPropExclusion ) {

            ScepNotifyLogPolicy(0, FALSE, L"Successfully created event E_ScepSamFilterAndPolicyPropExclusion ", 0, 0, NULL );

            //
            // create an event which is signalled when a node is enqueued into the notification queue
            // this event helps the notification system thread to wait efficiently
            //

            ghEventNotificationQEnqueue = CreateEvent(
                                                     NULL,
                                                     FALSE,
                                                     FALSE,
                                                     SCEP_NOTIFICATION_EVENT
                                                     );

            if ( ghEventNotificationQEnqueue ) {

                ScepNotifyLogPolicy(0, FALSE, L"Successfully created event E_ScepNotificationQEnqueue ", 0, 0, NULL );

                //
                // create an event for policy propagation
                //

                ghEventPolicyPropagation = CreateEvent(
                                                      NULL,
                                                      FALSE,
                                                      FALSE,
                                                      SCEP_POLICY_PROP_EVENT
                                                      );

                if ( ghEventPolicyPropagation ) {

                    ScepNotifyLogPolicy(0, FALSE, L"Successfully created event E_ScepPolicyPropagation", 0, 0, NULL );

                    //
                    // Create a worker thread that's always running in
                    // services this thread constantly monitors notifications inserted into
                    // the NotificationQ by LSA's threads and processes them
                    //

                    hNotificationThread = CreateThread(
                                                      NULL,
                                                      0,
                                                      (PTHREAD_START_ROUTINE)ScepNotificationQSystemThreadFunc,
                                                      NULL,
                                                      0,
                                                      (LPDWORD)&dwThreadId
                                                      );

                    if (hNotificationThread) {

                        pszMsg[0] = L'\0';

                        swprintf(pszMsg, L"Thread %x", dwThreadId);

                        ScepNotifyLogPolicy(0, TRUE, L"Create Notification Thread Success", 0, 0, pszMsg );

                    }

                    else {

                        rc = GetLastError();

                        ScepNotifyLogPolicy(rc, TRUE, L"Create Notification Thread Failure", 0, 0, NULL );

                        ScepNotificationQCleanup();

                    }
                }

                else {

                    rc = GetLastError();

                    ScepNotifyLogPolicy(rc, FALSE, L"Error creating event E_ScepPolicyPropagation", 0, 0, NULL );

                    ScepNotificationQCleanup();

                }
            }

            else {

                rc = GetLastError();

                ScepNotifyLogPolicy(rc, FALSE, L"Error creating event E_ScepNotificationQEnqueue ", 0, 0, NULL );

                ScepNotificationQCleanup();

            }
        }

        else {

            rc = GetLastError();

            ScepNotifyLogPolicy(rc, FALSE, L"Error creating event E_ScepSamFilterAndPolicyPropExclusion ", 0, 0, NULL );

            ScepNotificationQCleanup();

        }

    } else {

        ScepNotifyLogPolicy(0, FALSE, L"Policy filter is not designed for non domain controllers", 0, 0, NULL );

        //
        // if changed to DC, have to reboot so cleanup anyway
        //

        ScepNotificationQCleanup();

    }

    if (ERROR_SUCCESS != rc && hNotificationThread)
    {
        CloseHandle(hNotificationThread);
        hNotificationThread = NULL;
    }

    return rc;
}

DWORD
ScepQueuePrepareShutdown(
    )
/*
Routine Description:

    This function is called when SCE server is requested to shut down (system
    shutdown) after RPC server stops listening.

    This function waits for SCEP_NOTIFICATION_TIMEOUT period to allow the system thread
    finish up with the queue items. After the timeout, it kills the worker
    thread and saves the pending queue items.

Arguments:

    None

Return Value:

    Dos error code
*/
{

    ScepNotifyLogPolicy(0, TRUE, L"System shutdown", 0, 0, NULL );

    //
    // gracefully shutdown the notification system thread by setting a global
    //

    gbShutdownForNotification = TRUE;

    //
    // if notification thread is never initialized, there is no point to wait
    // which may delay services.exe shutdown
    //
    if ( ghEventNotificationQEnqueue ) {

        // sleep for 10 seconds first
        // then check the queue for empty
        Sleep( 10*000 );

        if ( pNotificationQHead ) {

            Sleep( SCEP_NUM_SHUTDOWN_SECONDS * 1000 );
        }
    }

    if (hNotificationThread &&
        WAIT_TIMEOUT == WaitForSingleObjectEx(
            hNotificationThread,
            SCEP_NUM_SHUTDOWN_SECONDS * 1000,
            FALSE)) {
        // wait for the notification thread to terminate before deleting
        // the critical section
        ScepNotifyLogPolicy(0, FALSE, L"Terminating Notification Thread", 0, 0, NULL );
        DWORD rc = RtlNtStatusToDosError(NtTerminateThread(
                hNotificationThread,
                STATUS_SYSTEM_SHUTDOWN
                ));

        ScepNotifyLogPolicy(rc, FALSE, L"Terminated Notification Thread", 0, 0, NULL );
    }

    DeleteCriticalSection(&NotificationQSync);

    if (hNotificationThread) {
        CloseHandle(hNotificationThread);
    }

    (void) ShutdownEvents();

    return ERROR_SUCCESS;
}

VOID
ScepNotificationQDequeue(
    IN BOOL bAllNodes
    )
/*
Routine Description:

    This function pops one node from the queue.

    The queue is a singly linked list ->->-> which pushes at tail(rightmost) and pops
    from the head(leftmost)

Arguments:

    None

Return Value:

    None
*/
{

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, TRUE, L"Entered NotificationQSync for Dequeueing", 0, 0, NULL );

    do {

        if ( pNotificationQHead ) {

            PSCESRV_POLQUEUE pQNode = pNotificationQHead;

            if ( pNotificationQTail == pNotificationQHead ) {
                //
                // there is only one node in the queue
                //
                pNotificationQTail = NULL;
            }

            //
            // move head to the next one
            //
            pNotificationQHead = pNotificationQHead->Next;

            //
            // log and free the node
            //

            ScepNotificationQNodeLog(pQNode, ScepNotificationDequeue);

            ScepFree(pQNode);

            -- gdwNumNotificationQNodes;
        }

        //
        // if request to dequeue all nodes, loop through the queue until head is empty
        //

    } while ( bAllNodes && pNotificationQHead );

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync after Dequeueing", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return;
}

DWORD
ScepNotificationQEnqueue(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    IN PSCESRV_POLQUEUE pRetryQNode OPTIONAL
    )

/*
Description:

    This function is called to add a notification to the queue. Note that
    only two notifications for the same data are added to the queue.

    The operation is protected from other reads/writes.
    Access check is already done outside of this function.

    Either the created threads call this routine or the system calls this routine.
    In the former case, pQNode = NULL

Arguments:

    DbType              -   SAM or LSA
    DeltaType           -   type of change (add. delete etc.). For SAM accounts, we'll only get delete since
                            some user rights may have to be removed.
    ObjectType          -   SECURITY_DB_OBJECT_TYPE such as SAM group, LSA account etc.
    ObjectSid           -   sid of the object being notified (might be NULL if ObjectType ==
                            SecurityDbObjectLsaPolicy i.e. auditing info etc.)
    ExplicitLowRight    -   Bitmask of user rights (lower 32 rights)
    ExplicitHighRight   -   Bitmask of user rights (higher 32 rights)
    pRetryQNode         -   If caller is not the system thread ScepNotificationQSystemThreadFunc,
                            this parameter is NULL since memory needs to be allocated. If caller
                            is not the system thread, we only have to do pointer manipulations.

Return Value:

    Win32 error code
*/
{
    DWORD rc    =   ERROR_SUCCESS;

    //
    // on Whistler, only allow notifications on DCs
    // on Windows 2000, all products are allowed.
    //

    if (ProductTypeForNotification != NtProductLanManNt ) {

        //
        // what error is okay to return ?
        //

        return ERROR_SUCCESS;

    }

    //
    // check parameters
    //

    if ( DbType == SecurityDbLsa &&
         ObjectType == SecurityDbObjectLsaAccount &&
         ObjectSid == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( DbType == SecurityDbSam &&
         SCEP_IS_SAM_OBJECT(ObjectType) &&
         ObjectSid == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // if the number of retried notifications is over certain limit (this is yet to be finalized)
    //  -   on a PDC we consider a full sync at reboot, stall future notifications from happening,
    //      set some registry key to indicate that a full sync is needed at reboot
    //  -   on other DCs we continue as if nothing happened
    //

    if ( gdwNumNotificationQRetryNodes >= SCEP_MAX_RETRY_NOTIFICATIONQ_NODES ) {

        //
        // log an error
        // suggest to do a full sync ???
        //

        ScepNotifyLogPolicy(ERROR_NOT_ENOUGH_QUOTA, TRUE, L"Queue length is over the maximal limit.", 0, 0, NULL );

        return  ERROR_NOT_ENOUGH_QUOTA;
    }

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, TRUE, L"Entered NotificationQSync for Enqueueing", 0, 0, NULL );

    //
    // if we are enqueueing due to a retry
    //      dequeue it (adjust pointers only)
    //      do not free the memory associated with this node (will be reused in enqueue)
    //

    if ( pRetryQNode && pNotificationQHead ) {

        //
        // this code fragment is similar to a dequeue except that the node is not freed
        //

        if ( pNotificationQTail == pNotificationQHead ) {
            //
            // there is only one node in the queue
            //
            pNotificationQTail = NULL;
        }

        //
        // move head to the next one
        //
        pNotificationQHead = pNotificationQHead->Next;

        -- gdwNumNotificationQNodes;
    }

    //
    // check to see if there is a duplicate notification
    //

    PSCESRV_POLQUEUE pQNode = pNotificationQHead;
    PSCESRV_POLQUEUE pQNodeDuplicate1 = NULL;
    PSCESRV_POLQUEUE pQNodeDuplicate2 = NULL;
    DWORD dwMatchedInstance = 0;

    while ( pQNode ) {

        //
        // SAM notification
        //

        if ( DbType == SecurityDbSam &&
             pQNode->DbType == DbType &&
             SCEP_IS_SAM_OBJECT(ObjectType) &&
             SCEP_IS_SAM_OBJECT(pQNode->ObjectType) &&
             pQNode->ObjectType == ObjectType &&
             RtlEqualSid(ObjectSid, (PSID)(pQNode->Sid))) {

                dwMatchedInstance++;

        }
        else if (DbType == SecurityDbSam &&
                  pQNode->DbType == SecurityDbSam && 
                 ObjectType == SecurityDbObjectSamDomain &&
                 pQNode->ObjectType == SecurityDbObjectSamDomain) {
            
            dwMatchedInstance++;
        }

        //
        // LSA notification
        //

        else if ( DbType == SecurityDbLsa &&
                  pQNode->DbType == DbType &&
                  ObjectType == SecurityDbObjectLsaAccount &&
                  pQNode->ObjectType == ObjectType &&
                  ExplicitLowRight == pQNode->ExplicitLowRight &&
                  ExplicitHighRight == pQNode->ExplicitHighRight &&
                  RtlEqualSid(ObjectSid, (PSID)(pQNode->Sid))) {

                    dwMatchedInstance++;
        }

        if ( dwMatchedInstance == 1 )
            pQNodeDuplicate1 = pQNode;
        else if ( dwMatchedInstance == 2 )
            pQNodeDuplicate2 = pQNode;

        if ( dwMatchedInstance == 2 ) {

            break;

        }

        pQNode = pQNode->Next;
    }

    if ( !pQNode ) {

        //
        // did not find two instances of the same kind of notification
        // enqueue this notification
        //

        PSCESRV_POLQUEUE pNewItem = NULL;

        if (pRetryQNode == NULL) {

            pNewItem = (PSCESRV_POLQUEUE)ScepAlloc(0, sizeof(SCESRV_POLQUEUE));

            if ( pNewItem ) {
                //
                // initialize the new node
                //
                pNewItem->dwPending = 1;
                pNewItem->DbType = DbType;
                pNewItem->ObjectType = ObjectType;
                pNewItem->DeltaType = DeltaType;
                pNewItem->ExplicitLowRight = ExplicitLowRight;
                pNewItem->ExplicitHighRight = ExplicitHighRight;
                pNewItem->Next = NULL;

                if ( ObjectSid ) {

                    RtlCopySid (MAX_SID_LENGTH, (PSID)(pNewItem->Sid), ObjectSid);

                } else {

                    RtlZeroMemory(pNewItem->Sid, MAX_SID_LENGTH);

                }


            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;

            }
        }
        else {
            pNewItem = pRetryQNode;
            pNewItem->Next = NULL;
        }

        //
        // enqueue the notification
        //

        if (pNewItem) {

            if ( pNotificationQTail ) {

                pNotificationQTail->Next = pNewItem;
                pNotificationQTail = pNewItem;

            } else {

                pNotificationQHead = pNotificationQTail = pNewItem;

            }

            //
            // awake the notification system thread only if queue is non-empty
            // multiple signalling is fine since the event stays signalled
            //

            if ( !SetEvent( ghEventNotificationQEnqueue ) ) {

                rc = GetLastError();

                ScepNotifyLogPolicy(rc, FALSE, L"Error signaling event E_ScepNotificationQEnqueue", 0, 0, NULL );

            }

            ScepNotificationQNodeLog(pNewItem, pRetryQNode ? ScepNotificationRetry : ScepNotificationEnqueue);

            ++ gdwNumNotificationQNodes;

        } else {
            //
            // log the error
            //
            ScepNotifyLogPolicy(rc, FALSE, L"Error allocating buffer for the enqueue operation.", 0, 0, NULL );
        }
    }

    if (pRetryQNode ) {

        //
        // if duplicates, update the retry counts (should be same for instances of
        // the same notification
        //

        if ( pQNodeDuplicate1 ) {
            // increment the retry count if it has not been
            if ( pQNodeDuplicate1->dwPending <= 1 ) gdwNumNotificationQRetryNodes++;

            pQNodeDuplicate1->dwPending = pRetryQNode->dwPending;
        }

        if ( pQNodeDuplicate2 ) {

            // increment the retry count if it has not been
            if ( pQNodeDuplicate2->dwPending <= 1 ) gdwNumNotificationQRetryNodes++;

            pQNodeDuplicate2->dwPending = pRetryQNode->dwPending;
        }
    }

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync for Enqueueing", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return(rc);
}

DWORD
ScepNotificationQSystemThreadFunc(
    )
/*
Description:

    The thread will iterate through the notification queue to process each
    notification (calling existing functions). If a notification fails to be
    processed, the notification is added back to the end of the queue.

    For certain errors, such as sysvol is not ready, or hard disk is full,
    the system thread will sleep for some time then restart the process.

    Each notification node in the queue will have a retry count. After the node
    is retried for SCEP_NOTIFICATION_RETRY_COUNT times, the node will be removed
    from the queue (so that policy propagation is not blocked forever) and the
    error will be logged to event log.

    The system thread should provide logging for the operations/status (success
    and failure).

    Read/Write to the queue should be protected from other reads/writes.

    ProductType of the machine should be initialized into a thread global variable to
    be used by policy filter. The type determines where to save the policy changes
    (DB or GP). Based on the product type, different policy notification APIs are called.

Arguments:

    None

Return Value:

    Win32 error code
*/
{


    //
    // loop through the queue
    // for each queue node, call the function to process
    // in Whistler, only process notification on DCs
    // in Windows 2000, process notificatioon on all products
    //

    PSCESRV_POLQUEUE    pQNode = pNotificationQHead;
    DWORD   dwMatchedInstance = 0;
    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwLogSize=0;
    DWORD   dwProcessedNode=0;

    //
    // this thread is always running looking to process notifications in the queue
    //

    (void) InitializeEvents(L"SceSrv");

    while (1) {

        if (pQNode) {

            //
            // query registry flag for log level (until now it is set to 2 because if
            // anything bad happens before this, we need to log it)
            // query only if first node
            //

            if (ERROR_SUCCESS != ScepRegQueryIntValue(
                                                     HKEY_LOCAL_MACHINE,
                                                     SCE_ROOT_PATH,
                                                     SCEPOL_NOTIFY_DEBUG_LEVEL,
                                                     &gdwNotificationLog
                                                     )) {
                //
                // set the value to 2, in case the registry value doesn't exist
                //

                gdwNotificationLog = 2;

            }

            //
            // get log file size
            //
            if (ERROR_SUCCESS != ScepRegQueryIntValue(
                                             HKEY_LOCAL_MACHINE,
                                             SCE_ROOT_PATH,
                                             SCEPOL_NOTIFY_LOG_SIZE,
                                             &dwLogSize
                                             )) {
                dwLogSize = 0;
            }

            //
            // minimum log size 1MB
            //
            if ( dwLogSize > 0 ) dwLogSize = dwLogSize * (1 << 10);  // number of KB
            if ( dwLogSize < SCEP_NOTIFICATION_LOGFILE_SIZE ) dwLogSize = SCEP_NOTIFICATION_LOGFILE_SIZE;

            if ( !gbCheckSync ) {

                //
                // query Maximum wait time values
                //
                if (ERROR_SUCCESS != ScepRegQueryIntValue(
                                                         HKEY_LOCAL_MACHINE,
                                                         SCE_ROOT_PATH,
                                                         SCEPOL_NOTIFY_MAX_PDC_WAIT,
                                                         &gdwMaxPDCWait
                                                         )) {
                    //
                    // set the value to default 30 days, in case the registry value doesn't exist
                    //

                    gdwMaxPDCWait = 30*24*60;

                }

                if (ERROR_SUCCESS != ScepRegQueryIntValue(
                                                         HKEY_LOCAL_MACHINE,
                                                         SCE_ROOT_PATH,
                                                         SCEPOL_NOTIFY_PDC_RETRY_INTERVAL,
                                                         &gdwPDCRetry
                                                         )) {
                    //
                    // set the value to default 20 minutes, in case the registry value doesn't exist
                    //

                    gdwPDCRetry = 20;

                }

                if (ERROR_SUCCESS != ScepRegQueryIntValue(
                                                         HKEY_LOCAL_MACHINE,
                                                         SCE_ROOT_PATH,
                                                         SCEPOL_NOTIFY_REQUIRE_PDC_SYNC,
                                                         &gdwRequirePDCSync
                                                         )) {
                    //
                    // set the value to default TRUE, in case the registry value doesn't exist
                    //

                    gdwRequirePDCSync = 1;

                }
            }

        } else {

            //
            // no notifications - wait efficiently/responsively for an enqueue event
            // it's an auto reset event - so will get reset after it goes past when signalled
            //

            //
            // timeout is SCEP_NOTIFICATION_EVENT_TIMEOUT_SECS since we need to periodically
            // check for system shutdown if there are no enqueue events at all
            //

            while (1) {

                rc = WaitForSingleObjectEx(
                                                ghEventNotificationQEnqueue,
                                                SCEP_NOTIFICATION_EVENT_TIMEOUT_SECS*1000,
                                                FALSE
                                                );
                if ( rc == -1 )
                    rc = GetLastError();

                if ( gbShutdownForNotification )
                    break;

                //
                // if event was signalled and wait happened successfully, move on
                //

                if ( rc == WAIT_OBJECT_0 )
                    break;

                //
                // if timeout, then continue waiting otherwise exit since some other wait status was returned
                //

                if ( rc != WAIT_TIMEOUT ) {

                    ScepNotifyLogPolicy(rc, TRUE, L"Unexpected wait status while notification system thread waits for E_ScepNotificationQEnqueue", 0, 0, NULL );
                    break;

                }

            }

            //
            // if error in waiting or system shutdown, break out of the outermost while
            // loop - system thread will eventually exit
            //

            if ( gbShutdownForNotification )
                break;

        }

        while ( pQNode ) {

            if ( gbShutdownForNotification )
                break;

            if ( dwProcessedNode >= 10 ) {

                if ( gdwNotificationLog && (hNotificationLogFile != INVALID_HANDLE_VALUE) ) {

                    //
                    // backup the log if it's over the limit and start afresh
                    //
                    if ( dwLogSize < GetFileSize(hNotificationLogFile, NULL) ) {

                        ScepBackupNotificationLogFile();

                    }

                    else {

                        //
                        // GetFileSize potentially mangles the file handle - so set it back to EOF
                        //

                        SetFilePointer (hNotificationLogFile, 0, NULL, FILE_END);

                    }
                }

                //
                // check free disk space
                //
                ScepCheckAndWaitFreeDiskSpaceInSysvol();

                dwProcessedNode = 0;

            }

            if ( pQNode->dwPending > 1 &&
                 ( gdwNumNotificationQNodes == 1 ||
                   (gdwNumNotificationQNodes == gdwNumNotificationQRetryNodes) ) ) {
                //
                // if this is a retried node, should sleep for some time before retry
                // if it's the only node or all nodes are retried.
                //
                ScepNotifyLogPolicy(0, FALSE, L"Retried node, taking a break.", 0, 0, NULL );

                Sleep( SCEP_NUM_REST_SECONDS * 1000 );
            }

            //
            // process this notification
            //
            BOOL bWaitTimeout=FALSE;

            rc = ScepNotifyProcessOneNodeDC(
                                           pQNode->DbType,
                                           pQNode->ObjectType,
                                           pQNode->DeltaType,
                                           pQNode->Sid,
                                           pQNode->ExplicitLowRight,
                                           pQNode->ExplicitHighRight,
                                           &bWaitTimeout
                                           );

            ScepNotificationQNodeLog(pQNode, ScepNotificationProcess);

            if (rc == ERROR_SUCCESS) {

                if (pQNode->dwPending > 1) {

                    //
                    // this was a retried node that is being dequeued
                    //

                    if ( gdwNumNotificationQRetryNodes > 0 )
                        -- gdwNumNotificationQRetryNodes;

                }

                ScepNotificationQDequeue(FALSE);

            } else if ( (WAIT_TIMEOUT == rc ||
                         ERROR_DOMAIN_CONTROLLER_NOT_FOUND == rc ||
                         ERROR_INVALID_DOMAIN_ROLE == rc )
                        && bWaitTimeout ) {

                //
                // The process was timed out waiting for PDC synchronization.
                //
                // Since we have waited gdwMaxPDCWait minutes for the PDC become
                // accessible and it still timed out (could due to network
                // problem), all changes in the local box are old (because they
                // don't synchronize with the rest of the domain anymore.
                //
                // Remove all nodes from the queue and log a big error event
                // for the notification dropout
                //

                ScepNotificationQDequeue(TRUE);

                gdwNumNotificationQRetryNodes = 0;

                //
                // logs an event and let the change go through
                //
                UINT idMsg=0;

                switch ( rc ) {
                case WAIT_TIMEOUT:
                    idMsg = SCESRV_POLICY_ERROR_FILE_OUTOFSYNC;
                    break;

                case ERROR_DOMAIN_CONTROLLER_NOT_FOUND:
                    idMsg = SCESRV_POLICY_ERROR_LOCALDC;
                    break;

                default:
                    idMsg = SCESRV_POLICY_ERROR_PDCROLE;
                    break;
                }

                LogEvent(MyModuleHandle,
                         STATUS_SEVERITY_ERROR,
                         SCEEVENT_ERROR_POLICY_PDCTIMEOUT,
                         idMsg
                         );

            } else {

                //
                // For certain errors, such as sysvol is not ready or hard disk is full,
                // this thread will sleep for some time then restart the process (next node).
                //

                if (rc == ERROR_FILE_NOT_FOUND ||
                    rc == ERROR_OBJECT_NOT_FOUND ||
                    rc == ERROR_MOD_NOT_FOUND ||
                    rc == ERROR_EXTENDED_ERROR) {

                    ScepNotifyLogPolicy(rc, FALSE, L"Sleeping due to processing error", 0, 0, NULL );

                    Sleep( SCEP_NUM_NOTIFICATION_SECONDS * 1000 );

                }

                //
                // Each notification node in the queue will have a retry count.
                // After the node is retried for SCEP_NOTIFICATION_RETRY_COUNT times, the node
                // will be removed from the queue (so that policy propagation is not blocked
                // forever) and the error is logged
                //

                if ( pQNode->dwPending >= SCEP_NOTIFICATION_RETRY_COUNT) {

                    ScepNotifyLogPolicy(0, FALSE, L"Retry count exceeded", 0, 0, NULL );

                    //
                    // should log to the event log
                    //

                    if ( (pQNode->DbType == SecurityDbLsa &&
                          pQNode->ObjectType == SecurityDbObjectLsaAccount) ||
                         (pQNode->DbType == SecurityDbSam &&
                          (pQNode->ObjectType == SecurityDbObjectSamUser ||
                           pQNode->ObjectType == SecurityDbObjectSamGroup ||
                           pQNode->ObjectType == SecurityDbObjectSamAlias )) ) {
                        //
                        // user rights
                        //
                        UNICODE_STRING UnicodeStringSid;

                        UnicodeStringSid.Buffer = NULL;
                        UnicodeStringSid.Length = 0;
                        UnicodeStringSid.MaximumLength = 0;

                        if ( pQNode->Sid ) {
                            RtlConvertSidToUnicodeString(&UnicodeStringSid,
                                                  pQNode->Sid,
                                                  TRUE );

                        }

                        LogEvent(MyModuleHandle,
                                 STATUS_SEVERITY_ERROR,
                                 SCEEVENT_ERROR_QUEUE_RETRY_TIMEOUT,
                                 IDS_ERROR_SAVE_POLICY_GPO_ACCOUNT,
                                 rc,
                                 UnicodeStringSid.Buffer ? UnicodeStringSid.Buffer : L""
                                 );

                        RtlFreeUnicodeString( &UnicodeStringSid );

                    } else {
                        LogEvent(MyModuleHandle,
                                 STATUS_SEVERITY_ERROR,
                                 SCEEVENT_ERROR_QUEUE_RETRY_TIMEOUT,
                                 IDS_ERROR_SAVE_POLICY_GPO_OTHER,
                                 rc
                                 );
                    }

                    if ( gdwNumNotificationQRetryNodes > 0 )
                        -- gdwNumNotificationQRetryNodes;

                    ScepNotificationQDequeue(FALSE);

                }
                else {

                    //
                    // this node is being retried
                    //

                    if ( pQNode->dwPending == 1 )
                        ++ gdwNumNotificationQRetryNodes;

                    ++ pQNode->dwPending;

                    ScepNotifyLogPolicy(0, FALSE, L"Retry count within bounds", 0, 0, NULL );

                    //
                    // no error can happen since only pointer manipulation for retry-enqueue
                    //

                    ScepNotificationQEnqueue(
                                            pQNode->DbType,
                                            pQNode->DeltaType,
                                            pQNode->ObjectType,
                                            pQNode->Sid,
                                            pQNode->ExplicitLowRight,
                                            pQNode->ExplicitHighRight,
                                            pQNode
                                            );

                }

            }

            pQNode = pNotificationQHead;
            dwProcessedNode++;

        }

        if ( gbShutdownForNotification )
            break;
        //
        // this thread has to keep being fed
        //      - some other thread might have enqueued new notification nodes
        //      - no other thread dequeues notification nodes (hence no need to protect reads)

        pQNode = pNotificationQHead;
    }

    //
    // should never get in here unless a shutdown happens
    // flush any queue items to some persistent store
    //

    rc = ScepNotificationQFlush();

    ScepNotifyLogPolicy(rc, TRUE, L"Flushing notification queue to disk", 0, 0, NULL );

    ScepNotificationQCleanup();

    ScepNotifyLogPolicy(0, FALSE, L"Notification thread exiting", 0, 0, NULL );

    ExitThread(rc);

    return ERROR_SUCCESS;
}

//
// todo - this routine really has not changed from polsrv.cpp
//

DWORD
ScepNotifyLogPolicy(
    IN DWORD ErrCode,
    IN BOOL  bLogTime,
    IN PWSTR Msg,
    IN DWORD DbType,
    IN DWORD ObjectType,
    IN PWSTR ObjectName OPTIONAL
    )
/*
Description:

    The main logging routine that logs notification information to
    %windir%\\security\\logs\\scepol.log.

Arguments:

    ErrCode     -   the error code to log
    bLogTime    -   if TRUE, log a timestamp
    Msg         -   the string message to log (not loczlized since it is detailed debugging)
    DbType      -   LSA/SAM
    ObjectType  -   SECURITY_DB_OBJECT_TYPE such as SAM group, LSA account etc.
    ObjectName  -   can be NULL - usually carries a message

Return Value:

    Win32 error code
*/
{

    switch ( gdwNotificationLog ) {
    case 0:
        // do not log anything
        return ERROR_SUCCESS;
        break;
    case 1:
        // log error only
        if ( ErrCode == 0 ) {
            return ERROR_SUCCESS;
        }
        break;
    default:
        break;
    }

    if (hNotificationLogFile != INVALID_HANDLE_VALUE) {

        //
        // print a time stamp
        //

        if ( bLogTime ) {

            LARGE_INTEGER CurrentTime;
            LARGE_INTEGER SysTime;
            TIME_FIELDS   TimeFields;
            NTSTATUS      NtStatus;

            NtStatus = NtQuerySystemTime(&SysTime);

            RtlSystemTimeToLocalTime (&SysTime,&CurrentTime);

            if ( NT_SUCCESS(NtStatus) &&
                 (CurrentTime.LowPart != 0 || CurrentTime.HighPart != 0) ) {

                memset(&TimeFields, 0, sizeof(TIME_FIELDS));

                RtlTimeToTimeFields (
                            &CurrentTime,
                            &TimeFields
                            );
                if ( TimeFields.Month > 0 && TimeFields.Month <= 12 &&
                     TimeFields.Day > 0 && TimeFields.Day <= 31 &&
                     TimeFields.Year > 1600 ) {

                    ScepWriteVariableUnicodeLog(hNotificationLogFile, TRUE,
                                                L"\r\n----------------%02d/%02d/%04d %02d:%02d:%02d",
                                                TimeFields.Month,
                                                TimeFields.Day,
                                                TimeFields.Year,
                                                TimeFields.Hour,
                                                TimeFields.Minute,
                                                TimeFields.Second);
                } else {
                    ScepWriteVariableUnicodeLog(hNotificationLogFile, TRUE,
                                                L"\r\n----------------%08x 08x",
                                                CurrentTime.HighPart,
                                                CurrentTime.LowPart);
                }
            } else {
                ScepWriteSingleUnicodeLog(hNotificationLogFile, TRUE, L"\r\n----------------Unknown time");
            }

        }

        //
        // print operation status code
        //
        if ( ErrCode ) {
            ScepWriteVariableUnicodeLog(hNotificationLogFile, FALSE,
                                        L"Thread %x\tError=%d",
                                        GetCurrentThreadId(),
                                        ErrCode
                                        );

        } else {
            ScepWriteVariableUnicodeLog(hNotificationLogFile, FALSE,
                                        L"Thread %x\t",
                                        GetCurrentThreadId()
                                        );
        }

        //
        // operation type
        //

        switch (DbType) {
        case SecurityDbLsa:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tLSA");
            break;
        case SecurityDbSam:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tSAM");
            break;
        default:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"");
            break;
        }

        //
        // print object type
        //

        switch (ObjectType) {
        case SecurityDbObjectLsaPolicy:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tPolicy");
            break;
        case SecurityDbObjectLsaAccount:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tAccount");
            break;
        case SecurityDbObjectSamDomain:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tDomain");
            break;
        case SecurityDbObjectSamUser:
        case SecurityDbObjectSamGroup:
        case SecurityDbObjectSamAlias:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tAccount");
            break;
        default:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"");
            break;
        }

        BOOL bCRLF;

        __try {

            //
            // print the name(s)
            //

            if ( Msg ) {
                bCRLF = FALSE;
            } else {
                bCRLF = TRUE;
            }
            if ( ObjectName ) {

                ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\t");
                ScepWriteSingleUnicodeLog(hNotificationLogFile, bCRLF, ObjectName);
            }

            if ( Msg ) {
                ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\t");
                ScepWriteSingleUnicodeLog(hNotificationLogFile, TRUE, Msg);
            }

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            CloseHandle( hNotificationLogFile );

            hNotificationLogFile = INVALID_HANDLE_VALUE;

            return(ERROR_INVALID_PARAMETER);
        }

    } else {
        return(GetLastError());
    }

    return(ERROR_SUCCESS);
}


VOID
ScepNotificationQFree(
    )
/*
Routine Description:

    This function frees the notification queue.

Arguments:

    None

Return Value:

    None
*/
{

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, TRUE, L"Entered NotificationQSync for freeing queue", 0, 0, NULL );

    if ( pNotificationQHead ) {

        PSCESRV_POLQUEUE pQNode = pNotificationQHead;
        PSCESRV_POLQUEUE pQNodeToFree = NULL;

        while ( pQNode ) {

            pQNodeToFree = pQNode;

            pQNode = pQNode->Next;

            ScepFree(pQNodeToFree);

        }

        pNotificationQHead = NULL;

    }

    pNotificationQTail = NULL;

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync for freeing queue ", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return;
}

DWORD
ScepNotificationQFlush(
    )
/*
Routine Description:

    This function flushes the notification queue to some persistent store.

Arguments:

    None

Return Value:

    None
*/
{

    DWORD   rc = ERROR_SUCCESS;

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, TRUE, L"Entered NotificationQSync for flushing queue", 0, 0, NULL );

    if ( pNotificationQHead ) {

        PSCESRV_POLQUEUE pQNode = pNotificationQHead;

        HKEY hKey = NULL;
        int i=1;
        HKEY hKeySub=NULL;
        WCHAR SubKeyName[10];

        rc = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                           SCE_NOTIFICATION_PATH,
                           0,
                           NULL, // LPTSTR lpClass,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE, // KEY_SET_VALUE,
                           NULL, // &SecurityAttributes,
                           &hKey,
                           NULL
                          );

        if ( ERROR_SUCCESS == rc ) {

            while ( pQNode ) {

                //
                // write pQNode to persistent store using available APIs
                //
                memset(SubKeyName, '\0', 20);
                swprintf(SubKeyName, L"%9d",i);

                rc = RegCreateKeyEx(
                           hKey,
                           SubKeyName,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE,
                           NULL,
                           &hKeySub,
                           NULL
                          );

                if ( ERROR_SUCCESS == rc ) {
                    //
                    // save the node information as registry values
                    //

                    RegSetValueEx (hKeySub,
                                    L"Pending",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->dwPending),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"DbType",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->DbType),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"ObjectType",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->ObjectType),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"DeltaType",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->DeltaType),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"LowRight",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->ExplicitLowRight),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"HighRight",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->ExplicitHighRight),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"Sid",
                                    0,
                                    REG_BINARY,
                                    (BYTE *)&(pQNode->Sid),
                                    MAX_SID_LENGTH
                                   );

                } else {
                    //
                    // log the failure
                    //
                    ScepNotifyLogPolicy(rc, FALSE, L"Failed to save notification node.", pQNode->DbType, pQNode->ObjectType, NULL );
                }

                if ( hKeySub ) {

                    RegCloseKey( hKeySub );
                    hKeySub = NULL;
                }

                i++;
                pQNode = pQNode->Next;

            }

        } else {

            //
            // log the failure
            //
            ScepNotifyLogPolicy(rc, FALSE, L"Failed to open notification store.", 0, 0, SCE_NOTIFICATION_PATH );
        }

        if ( hKey ) {
            RegCloseKey(hKey);
        }

    } else {
        //
        // log the queue is empty
        //
        ScepNotifyLogPolicy(0, FALSE, L"Queue is empty.", 0, 0, NULL);
    }

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync for flushing queue", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return rc;
}


DWORD
ScepNotificationQUnFlush(
    )
/*
Routine Description:

    This function initializes the notification queue from some persistent store
    such as registry/textfile.

Arguments:

    None

Return Value:

    None
*/
{

    DWORD   rc = ERROR_SUCCESS;

    DWORD DbType=0;
    DWORD DeltaType=0;
    DWORD ObjectType=0;
    CHAR  ObjectSid[MAX_SID_LENGTH];
    DWORD ExplicitLowRight=0;
    DWORD ExplicitHighRight=0;

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, FALSE, L"Entered NotificationQSync for unflushing queue", 0, 0, NULL );

    memset(ObjectSid, '\0', MAX_SID_LENGTH);

    HKEY hKey=NULL;

    rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                       SCE_NOTIFICATION_PATH,
                       0,
                       KEY_READ,
                       &hKey
                      );

    if ( ERROR_SUCCESS == rc ) {

        HKEY hKeySub=NULL;
        DWORD dwIndex=0;
        DWORD cbSubKey=10;
        WCHAR SubKeyName[10];
        DWORD cbData;
        DWORD dwPending=0;
        DWORD RegType;

        //
        // enumerate all subkeys and save each node
        //
        do {

            memset(SubKeyName, '\0', 20);
            cbSubKey = 10;

            rc = RegEnumKeyEx (hKey,
                               dwIndex,
                               SubKeyName,
                               &cbSubKey,
                               NULL,
                               NULL,
                               NULL,
                               NULL
                               );
            if ( ERROR_SUCCESS == rc ) {
                dwIndex++;

                //
                // open the sub key
                //
                rc = RegOpenKeyEx (hKey,
                                   SubKeyName,
                                   0,
                                   KEY_READ,
                                   &hKeySub
                                  );

                if ( ERROR_SUCCESS == rc ) {

                    //
                    // query all registry values
                    //
                    cbData = sizeof(DWORD);
                    rc = RegQueryValueEx (
                            hKeySub,
                            L"Pending",
                            NULL,
                            &RegType,
                            (LPBYTE)&dwPending,
                            &cbData
                            );

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = sizeof(DWORD);
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"DbType",
                                NULL,
                                &RegType,
                                (LPBYTE)&DbType,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = sizeof(DWORD);
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"ObjectType",
                                NULL,
                                &RegType,
                                (LPBYTE)&ObjectType,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = sizeof(DWORD);
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"DeltaType",
                                NULL,
                                &RegType,
                                (LPBYTE)&DeltaType,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = sizeof(DWORD);
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"LowRight",
                                NULL,
                                &RegType,
                                (LPBYTE)&ExplicitLowRight,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = sizeof(DWORD);
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"HighRight",
                                NULL,
                                &RegType,
                                (LPBYTE)&ExplicitHighRight,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = MAX_SID_LENGTH;
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"Sid",
                                NULL,
                                &RegType,
                                (LPBYTE)ObjectSid,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {
                        //
                        // add it to the queue
                        //

                        ScepNotificationQEnqueue(
                                                (SECURITY_DB_TYPE)DbType,
                                                (SECURITY_DB_DELTA_TYPE)DeltaType,
                                                (SECURITY_DB_OBJECT_TYPE)ObjectType,
                                                (PSID)ObjectSid,
                                                ExplicitLowRight,
                                                ExplicitHighRight,
                                                NULL
                                                );
                    }
                }


                if ( ERROR_SUCCESS != rc ) {
                    //
                    // log the error
                    //
                    ScepNotifyLogPolicy(rc, FALSE, L"Failed to query notification a node.", 0, 0, SubKeyName );
                }

                //
                // close handle
                //
                if ( hKeySub ) {
                    RegCloseKey(hKeySub);
                    hKeySub = NULL;
                }
            }

        } while ( rc != ERROR_NO_MORE_ITEMS );

    } else if ( ERROR_FILE_NOT_FOUND != rc ) {
        //
        // log the error
        //
        ScepNotifyLogPolicy(rc, FALSE, L"Failed to open the notification store", 0, 0, NULL );
    }

    if ( ERROR_FILE_NOT_FOUND == rc ) rc = ERROR_SUCCESS;

    //
    // close the handle
    //
    if ( hKey ) {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync for unflushing queue", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return rc;
}


DWORD
ScepGetQueueInfo(
    OUT DWORD *pdwInfo,
    OUT PSCEP_SPLAY_TREE pRootNode OPTIONAL
    )
/*
Routine Description:

    Loops through all pending notifications and returns the notification type & unique
    sid-list to the caller.

Arguments:

    pdwInfo         -   bitmask of types SCE_QUEUE_INFO_SAM, SCE_QUEUE_INFO_AUDIT, SCE_QUEUE_INFO_RIGHTS
    pRootNode       -   the root node pointing to splay tree structure.
                        Note: this is an optional parameter - if NULL, only pdwInfo needs to be 
                        filled i.e. caller is looking for SCE_QUEUE_INFO_SAM only

Return Value:

    Win32 error code
*/
{

    DWORD   dwInfo = 0;
    DWORD   rc = ERROR_SUCCESS;
    BOOL    bExists;
    BOOL    bSamDomainInfoOnly = FALSE;

    if ( pdwInfo == NULL )
        return ERROR_INVALID_PARAMETER;

    if (NULL == pRootNode) {
        bSamDomainInfoOnly = TRUE;
    }

    *pdwInfo = 0;

    if (ProductTypeForNotification != NtProductLanManNt ) {
        //
        // none DCs, the queue should always be empty.
        //
        ScepNotifyLogPolicy(0, TRUE, L"Wks/Srv Notification queue is empty", 0, 0, NULL );
        return rc;
    }

    PWSTR StringSid=NULL;

    ScepNotifyLogPolicy(0, 
                        TRUE, 
                        bSamDomainInfoOnly ? L"Building Notification queue info for SecurityDbObjectSamDomain only" : L"Building Notification queue info",
                        0, 
                        0, 
                        NULL );

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, FALSE, L"Entered NotificationQSync for building queue info", 0, 0, NULL );

    if ( pNotificationQHead ) {

        PSCESRV_POLQUEUE pQNode = pNotificationQHead;

        while ( pQNode ) {

            if ( (SCEP_IS_SAM_OBJECT(pQNode->ObjectType) ||
                  pQNode->ObjectType == SecurityDbObjectLsaAccount) ) {

                dwInfo |= SCE_QUEUE_INFO_RIGHTS;

            }

            else if ( pQNode->ObjectType == SecurityDbObjectSamDomain ) {

                dwInfo |= SCE_QUEUE_INFO_SAM;

                if (bSamDomainInfoOnly) {
                    //
                    // at least one SAM domain notification in queue
                    //
                    break;
                }
            }

            else if ( pQNode->ObjectType == SecurityDbObjectLsaPolicy ) {

                dwInfo |= SCE_QUEUE_INFO_AUDIT;

            }

            if ( !bSamDomainInfoOnly ) {
                if ( RtlValidSid( (PSID)pQNode->Sid )) {


                    rc = ScepSplayInsert( (PVOID)(pQNode->Sid), pRootNode, &bExists );

                    ConvertSidToStringSid( (PSID)(pQNode->Sid), &StringSid );

                    if ( !bExists ) {
                        ScepNotifyLogPolicy(rc, FALSE, L"Add SID", 0, pQNode->ObjectType, StringSid );
                    } else {
                        ScepNotifyLogPolicy(rc, FALSE, L"Duplicate SID", 0, pQNode->ObjectType, StringSid );
                    }

                    LocalFree(StringSid);
                    StringSid = NULL;

                    if (rc != ERROR_SUCCESS ) {
                        break;
                    }

                } else {

                    ScepNotifyLogPolicy(0, FALSE, L"Add Info", 0, pQNode->ObjectType, NULL );
                }
            }

            pQNode = pQNode->Next;

        }

        if ( rc != ERROR_SUCCESS ) {

            if (!bSamDomainInfoOnly) {

                ScepNotifyLogPolicy(rc, FALSE, L"Error building Notification queue info", 0, 0, NULL );

                ScepSplayFreeTree( &pRootNode, FALSE );
            }

        } else {

            *pdwInfo = dwInfo;
        }

    }

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync for building queue info", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return rc;
}


VOID
ScepNotificationQNodeLog(
    IN PSCESRV_POLQUEUE pQNode,
    IN NOTIFICATIONQ_OPERATION_TYPE    NotificationOp
    )
/*
Routine Description:

    Dump the node info to the log file

Arguments:

    pQNode          -   pointer to node to dump
    NotificationOp  -   type of queue operation

Return Value:

    None
*/
{
    WCHAR   pwszTmpBuf[MAX_PATH*2];
    PWSTR   pszStringSid  = NULL;

    pwszTmpBuf[0] = L'\0';

    if ( pQNode == NULL ||
         gdwNotificationLog == 0 ||
         NotificationOp > ScepNotificationProcess ||
         NotificationOp < ScepNotificationEnqueue) {
        return;
    }

    switch (NotificationOp) {

    case ScepNotificationEnqueue:
        wcscpy(pwszTmpBuf, L"Enqueue");
        break;
    case ScepNotificationDequeue:
        wcscpy(pwszTmpBuf, L"Dequeue");
        break;
    case ScepNotificationRetry:
        wcscpy(pwszTmpBuf, L"Retry");
        break;
    case ScepNotificationProcess:
        wcscpy(pwszTmpBuf, L"Process");
        break;
    default:
        return;
    }

    ScepConvertSidToPrefixStringSid( (PSID)(pQNode->Sid), &pszStringSid );

    swprintf(pwszTmpBuf, L"Op: %s, Num Instances: %d, Num Retry Instances: %d, Retry count: %d, LowRight: %d, HighRight: %d, Sid: %s, DbType: %d, ObjectType: %d, DeltaType: %d",
             OpTypeTable[NotificationOp-1],
             gdwNumNotificationQNodes,
             gdwNumNotificationQRetryNodes,
             pQNode->dwPending,
             pQNode->ExplicitLowRight,
             pQNode->ExplicitHighRight,
             pszStringSid == NULL ? L"0" : pszStringSid,
             pQNode->DbType,
             pQNode->ObjectType,
             pQNode->DeltaType);

    ScepFree( pszStringSid );

    ScepNotifyLogPolicy(0, FALSE, L"", 0, 0, pwszTmpBuf );

    return;

}


DWORD
ScepNotificationLogOpen(
   )
/* ++
Routine Description:

   Open a handle to the notification log file %windir%\\security\\logs\\scepol.log
   and stash it in a global handle.

Arguments:

    None

Return value:

   Win32 error code

-- */
{
    DWORD  rc=NO_ERROR;

    if ( !gdwNotificationLog ) {
        return(rc);
    }

    //
    // build the log file name %windir%\security\logs\scepol.log
    //

    WCHAR LogName[MAX_PATH+51];

    LogName[0] = L'\0';
    GetSystemWindowsDirectory(LogName, MAX_PATH);
    LogName[MAX_PATH] = L'\0';

    wcscat(LogName, L"\\security\\logs\\scepol.log\0");

    hNotificationLogFile = CreateFile(LogName,
                                      GENERIC_WRITE,
                                      FILE_SHARE_READ,
                                      NULL,
                                      OPEN_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

    if ( INVALID_HANDLE_VALUE != hNotificationLogFile ) {

/*
        DWORD dwBytesWritten;

        SetFilePointer (hNotificationLogFile, 0, NULL, FILE_BEGIN);

        CHAR TmpBuf[3];
        TmpBuf[0] = (CHAR)0xFF;
        TmpBuf[1] = (CHAR)0xFE;
        TmpBuf[2] = '\0';

        WriteFile (hNotificationLogFile, (LPCVOID)TmpBuf, 2,
                   &dwBytesWritten,
                   NULL);
*/

        //
        // set to file end since we do not want to erase older logs unless we wrap around
        //

        SetFilePointer (hNotificationLogFile, 0, NULL, FILE_END);

    }


    if ( hNotificationLogFile == INVALID_HANDLE_VALUE ) {
        rc = GetLastError();
    }

    return rc;
}

VOID
ScepNotificationLogClose(
   )
/* ++
Routine Description:

   Close the handle to the notification log file %windir%\\security\\logs\\scepol.log.

Arguments:

    None

Return value:

   Win32 error code

-- */
{
   if ( INVALID_HANDLE_VALUE != hNotificationLogFile ) {
       CloseHandle( hNotificationLogFile );
   }

   hNotificationLogFile = INVALID_HANDLE_VALUE;

   return;
}


VOID
ScepBackupNotificationLogFile(
    )
/* ++
Routine Description:

   Backup the log file to %windir%\\security\\logs\\scepol.log.old and start afresh.

Arguments:

    None

Return value:

   None

-- */
{
    //
    // make sure local variables are not over the stack limit (1KB)
    //
    UINT cLen = GetSystemWindowsDirectory(NULL, 0);

    if ( cLen == 0 ) return;

    PWSTR LogName=NULL, LogNameOld=NULL;

    SafeAllocaAllocate(LogName, (cLen+50)*sizeof(WCHAR));
    SafeAllocaAllocate(LogNameOld, (cLen+50)*sizeof(WCHAR));

    if ( LogName && LogNameOld ) {

        LogName[0] = L'\0';
        GetSystemWindowsDirectory(LogName, cLen+1);
        LogName[cLen+1] = L'\0';

        wcscpy(LogNameOld, LogName);

        wcscat(LogName, L"\\security\\logs\\scepol.log\0");

        wcscat(LogNameOld, L"\\security\\logs\\scepol.log.old\0");

        EnterCriticalSection(&NotificationQSync);

        ScepNotificationLogClose();

        DWORD rc=0, rc2=0;

        if ( !CopyFile( LogName, LogNameOld, FALSE ) )
            rc = GetLastError();

        //
        // clear the file after handle is closed and then recreate the log file and handle
        //

        if ( !DeleteFile(LogName) )
            rc2 = GetLastError();

        ScepNotificationLogOpen();

        LeaveCriticalSection(&NotificationQSync);

        swprintf(LogName, L"Wrapping log file: Copy(%d), Delete(%d)\0", rc, rc2);

        ScepNotifyLogPolicy(0, TRUE, LogName, 0, 0, NULL );

    }

    SafeAllocaFree(LogName);
    SafeAllocaFree(LogNameOld);

    return;
}


VOID
ScepNotificationQCleanup(
    )
/* ++
Routine Description:

   Perform cleanup operations

Arguments:

    None

Return value:

   None

-- */
{
    ScepNotificationQFree();

    if ( ghEventNotificationQEnqueue ) {
        CloseHandle( ghEventNotificationQEnqueue );
        ghEventNotificationQEnqueue = NULL;
    }

    if ( ghEventPolicyPropagation ) {
        CloseHandle( ghEventPolicyPropagation );
        ghEventPolicyPropagation = NULL;
    }

    ScepNotificationLogClose();

}

VOID
ScepNotificationQControl(
    IN DWORD Flag
    )
{
    if (ProductTypeForNotification == NtProductLanManNt ) {
        //
        // only control the queue process on DCs
        //
        BOOL b = (Flag > 0);

        if ( b != gbSuspendQueue ) {
            //
            // log it.
            //
            if ( !b ) {

                gbSuspendQueue = b;

                //
                // if the queue should be resumed, set the event
                //
                if ( !SetEvent( ghEventPolicyPropagation ) ) {

                    DWORD rc = GetLastError();

                    ScepNotifyLogPolicy(rc, FALSE, L"Error signaling event E_ScepPolicyPropagation", 0, 0, NULL );

                } else {
                    ScepNotifyLogPolicy(0, FALSE, L"Signaling event E_ScepPolicyPropagation", 0, 0, NULL );
                }

            } else {
                //
                // should reset the event before setting the global flag
                //
                ResetEvent( ghEventPolicyPropagation );

                gbSuspendQueue = b;

                ScepNotifyLogPolicy(0, FALSE, L"Resetting event E_ScepPolicyPropagation", 0, 0, NULL );
            }

            if ( b )
                ScepNotifyLogPolicy(0, FALSE, L"Suspend flag is set.", 0, 0, NULL );
            else
                ScepNotifyLogPolicy(0, FALSE, L"Resume flag is set", 0, 0, NULL );

        }

    }

    return;
}

DWORD
ScepCheckAndWaitPolicyPropFinish()
{

    DWORD rc=ERROR_SUCCESS;

    while (gbSuspendQueue ) {

        //
        // the queue should be suspended
        //
        rc = WaitForSingleObjectEx(
                                ghEventPolicyPropagation,
                                SCEP_NOTIFICATION_EVENT_TIMEOUT_SECS*1000,
                                FALSE
                                );
        if ( rc == -1 )
            rc = GetLastError();

        if ( gbShutdownForNotification )
            break;

        //
        // if event was signalled and wait happened successfully, move on
        //

        if ( rc == WAIT_OBJECT_0 ) {

            ScepNotifyLogPolicy(0, TRUE, L"Queue process is resumed from policy propagation", 0, 0, NULL );
            break;
        }

        //
        // if timeout, then continue waiting otherwise exit since some other wait status was returned
        //

        if ( rc != WAIT_TIMEOUT ) {

            ScepNotifyLogPolicy(rc, TRUE, L"Unexpected wait status while notification system thread waits for E_ScepPolicyPropagation", 0, 0, NULL );
            break;
        }
    }

    return rc;
}

DWORD
ScepCheckAndWaitFreeDiskSpaceInSysvol()
/*
Description:
    Saving policy into sysvol requires that some amount of disk space is available.
    If free disk space is below 5M, we should suspend the node processing and wait
    for disk space freed up.

*/
{
    //
    // Get the sysvol share path name in the format of \\ComputerName\Sysvol\
    //

    WCHAR Buffer[MAX_PATH+10];
    DWORD dSize=MAX_PATH+2;
    DWORD rc=ERROR_SUCCESS;
    ULARGE_INTEGER BytesCaller, BytesTotal, BytesFree;
    int cnt = 0;

    Buffer[0] = L'\\';
    Buffer[1] = L'\\';
    Buffer[2] = L'\0';

    if ( !GetComputerName(Buffer+2, &dSize) )
        return GetLastError();

    Buffer[MAX_PATH+2] = L'\0';

    wcscat(Buffer, TEXT("\\sysvol\\"));

    BytesCaller.QuadPart = 0;
    BytesTotal.QuadPart = 0;
    BytesFree.QuadPart = 0;

    while ( BytesCaller.QuadPart < SCEP_MINIMUM_DISK_SPACE &&
            cnt < 40 ) {

        if ( !GetDiskFreeSpaceEx(Buffer, &BytesCaller, &BytesTotal, &BytesFree) ) {

            rc = GetLastError();
            break;
        }

        if ( BytesCaller.QuadPart < SCEP_MINIMUM_DISK_SPACE ) {
            //
            // sleep for 15 minutes then check again
            //
            LogEvent(MyModuleHandle,
                     STATUS_SEVERITY_WARNING,
                     SCEEVENT_WARNING_LOW_DISK_SPACE,
                     IDS_FREE_DISK_SPACE,
                     BytesCaller.LowPart
                     );
            //
            // sleep for 15 minutes
            //
            Sleep(15*60*1000);

        }
        cnt++;
    }

    return rc;
}

VOID
ScepDbgNotificationQDump(
    )
/* ++
Routine Description:

   Dump the notification queue to console - could dump to disk if needed

Arguments:

    None

Return value:

   None

-- */
{

    EnterCriticalSection(&NotificationQSync);

    DWORD   dwNodeNum = 0;

    wprintf(L"\nTotal no. of queue nodes = %d", gdwNumNotificationQNodes);

        if ( pNotificationQHead ) {

        PSCESRV_POLQUEUE pQNode = pNotificationQHead;

        while ( pQNode ) {

            wprintf(L"\nNode no. %d", dwNodeNum++);

            ScepDbgNotificationQDumpNode(pQNode);

            pQNode = pQNode->Next;

        }
    }

    LeaveCriticalSection(&NotificationQSync);

}

VOID
ScepDbgNotificationQDumpNode(
    IN PSCESRV_POLQUEUE pQNode
    )
/*
Routine Description:

    Dump the node info to the console

Arguments:

    pQNode          -   pointer to node to dump

Return Value:

    None
*/
{
    PWSTR   pszStringSid  = NULL;

    if ( pQNode == NULL ) {
        return;
    }

    ScepConvertSidToPrefixStringSid( (PSID)(pQNode->Sid), &pszStringSid );

    wprintf( L"\nRetry count: %d, LowRight: %d, HighRight: %d, Sid: %s, DbType: %d, ObjectType: %d\n",
             pQNode->dwPending,
             pQNode->ExplicitLowRight,
             pQNode->ExplicitHighRight,
             pszStringSid == NULL ? L"0" : pszStringSid,
             pQNode->DbType,
             pQNode->ObjectType);

    ScepFree( pszStringSid );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\regvalue.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    kerberos.h

Abstract:

    Headers of apis for registry values

Author:

    Jin Huang (jinhuang) 07-Jan-1998 created

Revision History:

--*/

#ifndef _sce_registryValue_
#define _sce_registryValue_

#ifdef __cplusplus
extern "C" {
#endif

#define SCEREG_VALUE_SNAPSHOT   1
#define SCEREG_VALUE_ANALYZE    2
#define SCEREG_VALUE_FILTER     3
#define SCEREG_VALUE_SYSTEM     4
#define SCEREG_VALUE_ROLLBACK   5

SCESTATUS
ScepGetRegistryValues(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_REGISTRY_VALUE_INFO * ppRegValues,
    OUT LPDWORD pValueCount,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepConfigureRegistryValues(
    IN PSCECONTEXT hProfile,
    IN PSCE_REGISTRY_VALUE_INFO pRegValues,
    IN DWORD ValueCount,
    IN PSCE_ERROR_LOG_INFO *pErrLog,
    IN DWORD ConfigOptions,
    OUT PBOOL pAnythingSet
    );

SCESTATUS
ScepAnalyzeRegistryValues(
    IN PSCECONTEXT hProfile,
    IN DWORD dwAnalFlag,
    IN PSCE_PROFILE_INFO pSmpInfo
    );

SCESTATUS
ScepAnalyzeOneRegistryValue(
    IN PSCESECTION hSection OPTIONAL,
    IN DWORD dwAnalFlag,
    IN OUT PSCE_REGISTRY_VALUE_INFO pOneRegValue
    );

SCESTATUS
ScepSaveRegistryValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN DWORD RegType,
    IN PWSTR CurrentValue,
    IN DWORD CurrentBytes,
    IN DWORD Status
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\polsrv.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    polsvr.cpp

Abstract:

    Server routines to get policy notification

Author:

    Jin Huang (jinhuang) 17-Jun-1998

Revision History:

-*/

#include "headers.h"
#include "serverp.h"
#include "pfp.h"
#include "scesetup.h"
#include "queue.h"
#include <sddl.h>
#include <ntldap.h>

//#include <gpedit.h>
//#include <initguid.h>
//#include <gpeditp.h>
#include <io.h>

#pragma hdrstop

DWORD
ScepNotifyGetAuditPolicies(
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    OUT BOOL *pbChanged
    );

DWORD
ScepNotifyPrivilegeChanges(
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID AccountSid,
    IN BOOL bAccountDeleted,
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN OUT PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    OUT BOOL *pbChanged
    );

SCESTATUS
ScepNotifySaveFixValueSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName
    );

SCESTATUS
ScepNotifySavedAuditPolicy(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo
    );

SCESTATUS
ScepNotifySavedPrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pPrivList,
    IN PSCE_PRIVILEGE_ASSIGNMENT pMergedList
    );

SCESTATUS
ScepNotifySavedSystemAccess(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo
    );

//*************************************************
DWORD
ScepNotifyGetChangedPolicies(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL,
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    OUT BOOL *pbChanged
    )
/*
Routine Description:

    Determine if policy has been changed in this notification (DbType and ObjectType).

    If the effective policy buffer (pScpInfo) exists, should compare with
    effective policy buffer because that's the last policy configured
    on the system which may come from a domain GPO. If There is no effective
    policy (such as in seutp clean install), the local policy should be
    used to compare.

Arguments:

    pSmpInfo    - local policy

    pScpInfo    - effective policy

    pbChanged   - if the policy is changed, it's set to TRUE

*/
{

    if ( pSmpInfo == NULL || pbChanged == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbChanged = FALSE;

    DWORD rc=ERROR_INVALID_PARAMETER;

    switch ( DbType) {
    case SecurityDbLsa:

        //
        // LSA policy changes
        //

        if ( ObjectType == SecurityDbObjectLsaPolicy ) {
            //
            // maybe audit policy is changed
            //

            rc = ScepNotifyGetAuditPolicies(pSmpInfo, pScpInfo, bSaveToLocal, pbChanged);

        } else {
            //
            // account policy is changed (user rights)
            //
            rc = ScepNotifyPrivilegeChanges(DeltaType,
                                            ObjectSid,
                                            FALSE,
                                            pSmpInfo,
                                            pScpInfo,
                                            bSaveToLocal,
                                            ExplicitLowRight,
                                            ExplicitHighRight,
                                            pbChanged);

        }

        break;

    case SecurityDbSam:

        //
        // SAM password and account policy changes
        //
        if ( ObjectType == SecurityDbObjectSamDomain ) {

            rc = ScepAnalyzeSystemAccess(pSmpInfo,
                                         pScpInfo,
                                         SCEPOL_SAVE_BUFFER |
                                          (bSaveToLocal ? SCEPOL_SAVE_DB : 0 ),
                                         pbChanged,
                                         NULL
                                        );

            ScepNotifyLogPolicy(rc, FALSE, L"Query/compare system access", DbType, ObjectType, NULL);

        } else {

            //
            // account is deleted. Should delete it from user rights
            //
            rc = ScepNotifyPrivilegeChanges(DeltaType,
                                            ObjectSid,
                                            TRUE,
                                            pSmpInfo,
                                            pScpInfo,
                                            bSaveToLocal,
                                            ExplicitLowRight,
                                            ExplicitHighRight,
                                            pbChanged);
        }

        break;

    default:

        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
}


DWORD
ScepNotifyGetAuditPolicies(
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    OUT BOOL *pbChanged
    )
/*
Routine Description:

    Determine if audit policy has been changed in this notification.

    If the effective policy buffer (pScpInfo) exists, should compare with
    effective policy buffer because that's the last policy configured
    on the system which may come from a domain GPO. If There is no effective
    policy (such as in seutp clean install), the local policy should be
    used to compare.

Arguments:

    pSmpInfo    - local policy

    pScpInfo    - effective policy

    pbChanged   - if the audit policy is changed, it's set to TRUE

*/
{

    LSA_HANDLE      lsaHandle=NULL;
    NTSTATUS        status;
    DWORD           rc;

    //
    // check if auditing policy is defined in the storage
    //

    PSCE_PROFILE_INFO pTmpInfo;

    if ( pScpInfo ) {
        pTmpInfo = pScpInfo;
    } else {
        pTmpInfo = pSmpInfo;
    }

    DWORD *pdwTemp = (DWORD *)&(pTmpInfo->AuditSystemEvents);
    BOOL bDefined=FALSE;

    for ( DWORD i=0; i<9; i++ ) {
        if ( *pdwTemp != SCE_NO_VALUE ) {
            bDefined = TRUE;
            break;
        }
        pdwTemp++;
    }

    if ( !bDefined ) {
        ScepNotifyLogPolicy(0, FALSE, L"No audit policy is defined", SecurityDbLsa, SecurityDbObjectLsaPolicy, NULL );
        return ERROR_SUCCESS;
    }

    //
    // open Lsa policy for read/write
    //

    ScepNotifyLogPolicy(0, FALSE, L"Open LSA", SecurityDbLsa, SecurityDbObjectLsaPolicy, NULL );

    status = ScepOpenLsaPolicy(
                    POLICY_VIEW_AUDIT_INFORMATION |
                    POLICY_AUDIT_LOG_ADMIN,
                    &lsaHandle,
                    TRUE
                    );

    if ( !NT_SUCCESS(status) ) {

        lsaHandle = NULL;
        rc = RtlNtStatusToDosError( status );

        ScepNotifyLogPolicy(rc, FALSE, L"Open failed", SecurityDbLsa, SecurityDbObjectLsaPolicy, NULL );

        return(rc);
    }

    PPOLICY_AUDIT_EVENTS_INFO pAuditEvent=NULL;

    //
    // Query audit event information
    //

    status = LsaQueryInformationPolicy( lsaHandle,
                                      PolicyAuditEventsInformation,
                                      (PVOID *)&pAuditEvent
                                    );
    rc = RtlNtStatusToDosError( status );

    ScepNotifyLogPolicy(rc, FALSE, L"Query Audit", SecurityDbLsa, SecurityDbObjectLsaPolicy, NULL );

    if ( NT_SUCCESS( status ) ) {

        //
        // restore the auditing mode
        //
        DWORD *pdwAuditAddr=&(pTmpInfo->AuditSystemEvents);
        DWORD *pdwLocalAudit=&(pSmpInfo->AuditSystemEvents);

        DWORD dwVal;

        for ( ULONG i=0; i<pAuditEvent->MaximumAuditEventCount && i<9; i++ ) {
            //
            // because secedit buffer is not defined in the exact same sequence as
            // POLICY_AUDIT_EVENT_TYPE, have to case this
            //
            dwVal = pAuditEvent->AuditingMode ? pAuditEvent->EventAuditingOptions[i] : 0;
            switch ( i ) {
            case AuditCategoryDetailedTracking:
                if ( pTmpInfo->AuditProcessTracking != SCE_NO_VALUE &&
                     pTmpInfo->AuditProcessTracking != dwVal ) {
                    // save the setting in local policy table
                    pSmpInfo->AuditProcessTracking = dwVal;
                    *pbChanged = TRUE;
                } else if ( bSaveToLocal ) {
                    //
                    // turn this item off to indicate this one is not changed
                    //
                    pSmpInfo->AuditProcessTracking = SCE_NO_VALUE;
                }
                break;
            case AuditCategoryPolicyChange:
                if ( pTmpInfo->AuditPolicyChange != SCE_NO_VALUE &&
                     pTmpInfo->AuditPolicyChange != dwVal ) {
                    pSmpInfo->AuditPolicyChange = dwVal;
                    *pbChanged = TRUE;
                } else if ( bSaveToLocal ) {
                    //
                    // turn this item off to indicate this one is not changed
                    //
                    pSmpInfo->AuditPolicyChange = SCE_NO_VALUE;
                }
                break;
            case AuditCategoryAccountManagement:
                if ( pTmpInfo->AuditAccountManage != SCE_NO_VALUE &&
                     pTmpInfo->AuditAccountManage != dwVal ) {
                    pSmpInfo->AuditAccountManage = dwVal;
                    *pbChanged = TRUE;
                } else if ( bSaveToLocal ) {
                    //
                    // turn this item off to indicate this one is not changed
                    //
                    pSmpInfo->AuditAccountManage = SCE_NO_VALUE;
                }
                break;
            default:
                if ( pdwAuditAddr[i] != SCE_NO_VALUE &&
                     pdwAuditAddr[i] != dwVal ) {
                    pdwLocalAudit[i] = dwVal;
                    *pbChanged = TRUE;
                } else if ( bSaveToLocal ) {
                    //
                    // turn this item off to indicate this one is not changed
                    //
                    pdwLocalAudit[i] = SCE_NO_VALUE;
                }
                break;
            }
        }

        LsaFreeMemory((PVOID)pAuditEvent);
    }

    LsaClose( lsaHandle );

    return(rc);

}


DWORD
ScepNotifyPrivilegeChanges(
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID AccountSid,
    IN BOOL bAccountDeleted,
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN OUT PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    IN BOOL *pbChanged
    )
/*
Routine Description:

    Determine if user rights has been changed in this notification.

    If the effective policy buffer (pScpInfo) exists, should compare with
    effective policy buffer because that's the last policy configured
    on the system which may come from a domain GPO. If There is no effective
    policy (such as in seutp clean install), the local policy should be
    used to compare.

    User rights should all come in the exact same format as defined in policy
    storage (for example, SID string or free text names). There is no account
    lookup in the query.

Arguments:

    pSmpInfo    - local policy

    pScpInfo    - effective policy

    pbChanged   - if the user rights is changed, it's set to TRUE

*/
{
    if ( AccountSid == NULL || pSmpInfo == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // open Lsa policy
    //
    LSA_HANDLE      lsaHandle=NULL;
    NTSTATUS        NtStatus;
    DWORD           rc=0;

    //
    // open Lsa policy for read/write
    //

    ScepNotifyLogPolicy(0, FALSE, L"Open LSA", SecurityDbLsa, SecurityDbObjectLsaAccount, NULL );

//    GENERIC_READ | GENERIC_EXECUTE |  bug in LsaOpenPolicy, can't pass in generic access

    NtStatus = ScepOpenLsaPolicy(
                    POLICY_VIEW_LOCAL_INFORMATION |
                    POLICY_LOOKUP_NAMES,
                    &lsaHandle,
                    TRUE
                    );

    if ( !NT_SUCCESS(NtStatus) ) {

        lsaHandle = NULL;
        ScepNotifyLogPolicy(RtlNtStatusToDosError(NtStatus),
                            FALSE,
                            L"Open Failed",
                            SecurityDbLsa,
                            SecurityDbObjectLsaAccount,
                            NULL );
        return ( RtlNtStatusToDosError( NtStatus ) );

    }

    ScepNotifyLogPolicy(0,
                        FALSE,
                        L"Open completed",
                        SecurityDbLsa,
                        SecurityDbObjectLsaAccount,
                        NULL );

    PWSTR StringSid=NULL;
    DWORD StringLen=0;

    //
    // convert sid to sid string
    //
    ScepConvertSidToPrefixStringSid(AccountSid, &StringSid);

    ScepNotifyLogPolicy(0, FALSE, L"Convert to string SID", SecurityDbLsa, SecurityDbObjectLsaAccount, StringSid );

    LPTSTR AccountName = NULL;
    DWORD  Len=0;

    if ( !bAccountDeleted ) {

        //
        // translate account sid to name
        //

        BOOL bFromAccountDomain = ScepIsSidFromAccountDomain( AccountSid );

        NtStatus = ScepConvertSidToName(
                            lsaHandle,
                            AccountSid,
                            bFromAccountDomain,
                            &AccountName,
                            &Len
                            );

        rc = RtlNtStatusToDosError(NtStatus);

        ScepNotifyLogPolicy(rc,
                            FALSE,
                            L"Get Account Name",
                            SecurityDbLsa,
                            SecurityDbObjectLsaAccount,
                            AccountName ? AccountName : StringSid);

    }

    DWORD dwPrivLowHeld, dwPrivHighHeld;

    if ( AccountName || StringSid ) {

        NtStatus = STATUS_SUCCESS;
        //
        // find out the account name pointer (without domain prefix)
        //
        PWSTR pNameStart = NULL;

        if ( AccountName ) {
            pNameStart = wcschr(AccountName, L'\\');

            if ( pNameStart ) {
                //
                // domain relative account, check if this is from a foreign domain
                //
                UNICODE_STRING u;
                u.Buffer = AccountName;
                u.Length = ((USHORT)(pNameStart-AccountName))*sizeof(WCHAR);

                if ( ScepIsDomainLocal(&u) ) {
                    //
                    // local domain (builtin, account, ...)
                    // this can be used to match free text accounts
                    //
                    pNameStart++;
                } else {
                    //
                    // account from a foreign domain
                    // do not allow mapping of free text accounts
                    //
                    pNameStart = NULL;
                }
            } else pNameStart = AccountName;
        }

        if ( StringSid ) StringLen = wcslen(StringSid);

        if ( DeltaType == SecurityDbDelete ) {

            dwPrivLowHeld = 0;
            dwPrivHighHeld = 0;

        } else if ( ExplicitLowRight != 0 ||
                    ExplicitHighRight != 0 ) {

            dwPrivLowHeld = ExplicitLowRight;
            dwPrivHighHeld = ExplicitHighRight;

        } else {

            //
            // get all privileges assigned to this account
            //

            NtStatus = ScepGetAccountExplicitRight(
                                lsaHandle,
                                AccountSid,
                                &dwPrivLowHeld,
                                &dwPrivHighHeld
                                );
        }

        rc = RtlNtStatusToDosError(NtStatus);

        WCHAR Msg[50];
        swprintf(Msg, L"Get Priv/Right %8x %8x\0", dwPrivHighHeld, dwPrivLowHeld);

        ScepNotifyLogPolicy(rc,
                            FALSE,
                            Msg,
                            SecurityDbLsa,
                            SecurityDbObjectLsaAccount,
                            AccountName ? AccountName : StringSid );

        if ( NT_SUCCESS(NtStatus) ) {

            //
            // loop through each privilege defined in SCE to add/remove the account
            //
            PSCE_PRIVILEGE_ASSIGNMENT pTemp, pTemp2;
            PSCE_NAME_LIST pName, pParent, pName2, pParent2;
            INT i;

            for ( pTemp2=pSmpInfo->OtherInfo.smp.pPrivilegeAssignedTo;
                  pTemp2 != NULL; pTemp2=pTemp2->Next ) {
                pTemp2->Status = SCE_STATUS_NOT_CONFIGURED;
            }

            if ( pScpInfo && bSaveToLocal ) {
                //
                // !!!do this only when save to database!!!
                // if there is effective policy, compare with effective rights
                // modify both effective policy list and local policy list
                //
                for ( pTemp=pScpInfo->OtherInfo.smp.pPrivilegeAssignedTo;
                      pTemp != NULL; pTemp=pTemp->Next ) {

                    pTemp->Status = 0;

                    i = ScepLookupPrivByName(pTemp->Name);

                    if ( i > -1 ) {

                        //
                        // find the local policy match
                        //
                        for ( pTemp2=pSmpInfo->OtherInfo.smp.pPrivilegeAssignedTo;
                              pTemp2 != NULL; pTemp2=pTemp2->Next ) {
                            if ( _wcsicmp(pTemp->Name, pTemp2->Name) == 0 ) {
                                // find it
                                break;
                            }
                        }

                        //
                        // compare with effective policy
                        // try to find in string sid first, then full account name,
                        // and last free text account
                        //
                        for ( pName=pTemp->AssignedTo, pParent=NULL;
                              pName != NULL; pParent=pName, pName = pName->Next ) {
                            if ( (StringSid && _wcsicmp(StringSid, pName->Name) == 0) ||
                                 (AccountName && _wcsicmp(AccountName, pName->Name) == 0) ||
                                 (pNameStart && _wcsicmp(pNameStart, pName->Name) == 0) ) {
                                // find it
                                break;
                            }
                        }

                        //
                        // also find the match in local policy (if there is any)
                        // try to find in string sid first, then full account name,
                        // and last free text account
                        //
                        if ( pTemp2 ) {

                            pTemp2->Status = 0;

                            for ( pName2=pTemp2->AssignedTo, pParent2=NULL;
                                  pName2 != NULL; pParent2=pName2, pName2 = pName2->Next ) {
                                if ( (StringSid && _wcsicmp(StringSid, pName2->Name) == 0) ||
                                     (AccountName && _wcsicmp(AccountName, pName2->Name) == 0) ||
                                     (pNameStart && _wcsicmp(pNameStart, pName2->Name) == 0) ) {
                                    // find it
                                    break;
                                }
                            }
                        } else {
                            pName2 = NULL;
                            pParent2 = NULL;
                        }

                        //
                        // now adjust the lists
                        //
                        if ( ( ( i < 32 ) && ( dwPrivLowHeld & (1 << i) ) ) ||
                             ( ( i >= 32 ) && ( dwPrivHighHeld & (1 << (i-32) ) ) ) ) {

                            if ( pName == NULL ) {
                                //
                                // add this node to effective list
                                //
                                rc = ScepAddToNameList(&(pTemp->AssignedTo),
                                                       StringSid ? StringSid : AccountName,
                                                       StringSid ? StringLen : Len);

                                *pbChanged = TRUE;
                                pTemp->Status = SCE_STATUS_MISMATCH;

                                if ( rc != ERROR_SUCCESS ) {
                                    break;
                                }
                            }
                            if ( (pTemp2 != NULL) && (pName2 == NULL) ) {
                                //
                                // should add this node to local policy node
                                //
                                rc = ScepAddToNameList(&(pTemp2->AssignedTo),
                                                        StringSid ? StringSid : AccountName,
                                                        StringSid ? StringLen : Len);

                                *pbChanged = TRUE;
                                pTemp2->Status = SCE_STATUS_MISMATCH;

                                if ( rc != ERROR_SUCCESS ) {
                                    break;
                                }
                            }

                        } else {

                            if ( pName ) {

                                //
                                // should remove it from effective list
                                //
                                if ( pParent ) {
                                    pParent->Next = pName->Next;
                                } else {
                                    pTemp->AssignedTo = pName->Next;
                                }

                                pName->Next = NULL;
                                ScepFree(pName->Name);
                                ScepFree(pName);
                                pName = NULL;

                                *pbChanged = TRUE;
                                pTemp->Status = SCE_STATUS_MISMATCH;
                            }

                            if ( pTemp2 && pName2 ) {
                                //
                                // should remove it from local list
                                //
                                if ( pParent2 ) {
                                    pParent2->Next = pName2->Next;
                                } else {
                                    pTemp2->AssignedTo = pName2->Next;
                                }

                                pName2->Next = NULL;
                                ScepFree(pName2->Name);
                                ScepFree(pName2);
                                pName2 = NULL;

                                *pbChanged = TRUE;
                                pTemp2->Status = SCE_STATUS_MISMATCH;
                            }
                        }

                        if ( i < 32 ) {

                            dwPrivLowHeld &= ~(1 << i);
                        } else {
                            dwPrivHighHeld &= ~(1 << (i-32) );
                        }
                    }
                }
            }

            for ( pTemp=pSmpInfo->OtherInfo.smp.pPrivilegeAssignedTo;
                  pTemp != NULL; pTemp=pTemp->Next ) {

                if ( pTemp->Status != SCE_STATUS_NOT_CONFIGURED ) {
                    //
                    // this one was already checked in previous loop
                    //
                    continue;
                }

                //
                // when get here, this privilege must not be found
                // in the effective right list (or the effective
                // right list is NULL)
                //
                pTemp->Status = 0;

                i = ScepLookupPrivByName(pTemp->Name);

                if ( i > -1 ) {

                    //
                    // detect if anything changed (with the local policy)
                    //

                    for ( pName=pTemp->AssignedTo, pParent=NULL;
                          pName != NULL; pParent=pName, pName = pName->Next ) {
                        if ( (StringSid && _wcsicmp(StringSid, pName->Name) == 0) ||
                             (AccountName && _wcsicmp(AccountName, pName->Name) == 0) ||
                             (pNameStart && _wcsicmp(pNameStart, pName->Name) == 0) ) {
                            // find it
                            break;
                        }
                    }

                   if ( ( ( i < 32 ) && ( dwPrivLowHeld & (1 << i) ) ) ||
                        ( ( i >= 32 ) && ( dwPrivHighHeld & (1 << (i-32) ) ) ) ) {

                       if ( pName == NULL ) {
                           //
                           // should add this node
                           //
                           rc = ScepAddToNameList(&(pTemp->AssignedTo),
                                                   StringSid ? StringSid : AccountName,
                                                   StringSid ? StringLen : Len);

                           *pbChanged = TRUE;
                           pTemp->Status = SCE_STATUS_MISMATCH;

                           if ( rc != ERROR_SUCCESS ) {
                               break;
                           }
                       }

                   } else {

                       if ( pName ) {

                           //
                           // should remove it
                           //
                           if ( pParent ) {
                               pParent->Next = pName->Next;
                           } else {
                               pTemp->AssignedTo = pName->Next;
                           }

                           pName->Next = NULL;
                           ScepFree(pName->Name);
                           ScepFree(pName);
                           pName = NULL;

                           *pbChanged = TRUE;
                           pTemp->Status = SCE_STATUS_MISMATCH;
                       }
                   }

                   if ( i < 32 ) {

                       dwPrivLowHeld &= ~(1 << i);
                   } else {
                       dwPrivHighHeld &= ~(1 << (i-32) );
                   }

                }
            }

#if 0
            //
            // if the privilege is not covered by the template/db,
            // do not trap it becuase user explicitly exclude this one.
            //
            if ( rc == ERROR_SUCCESS &&
                 ( dwPrivLowHeld || dwPrivHighHeld ) ) {

                //
                // other new privileges added which are not in the template
                //

                for ( i=0; i<cPrivCnt; i++) {

                    if ( ( ( i < 32 ) && ( dwPrivLowHeld & (1 << i) ) ) ||
                         ( ( i >= 32 ) && ( dwPrivHighHeld & (1 << (i-32) ) ) ) ) {

                        //
                        // add this account/right to the list
                        //

                        rc = ERROR_NOT_ENOUGH_MEMORY;

                        pTemp = (PSCE_PRIVILEGE_ASSIGNMENT)ScepAlloc( LMEM_ZEROINIT,
                                                                      sizeof(SCE_PRIVILEGE_ASSIGNMENT) );
                        if ( pTemp ) {
                            pTemp->Name = (PWSTR)ScepAlloc( (UINT)0, (wcslen(SCE_Privileges[i].Name)+1)*sizeof(WCHAR));

                            if ( pTemp->Name != NULL ) {

                                wcscpy(pTemp->Name, SCE_Privileges[i].Name);
                                pTemp->Status = SCE_STATUS_GOOD;
                                pTemp->AssignedTo = NULL;

                                rc = ScepAddToNameList(&(pTemp->AssignedTo),
                                                        StringSid ? StringSid : AccountName,
                                                        StringSid ? StringLen : Len);

                                *pbChanged = TRUE;

                                if ( rc != ERROR_SUCCESS ) {

                                    ScepFree(pTemp->Name);
                                }

                            }

                            if ( ERROR_SUCCESS != rc ) {

                                ScepFree(pTemp);
                            }

                        }

                        if ( ERROR_SUCCESS == rc ) {
                            //
                            // add this node to the list
                            //
                            pTemp->Next = pSceInfo->OtherInfo.smp.pPrivilegeAssignedTo;
                            pSceInfo->OtherInfo.smp.pPrivilegeAssignedTo = pTemp;
                            pTemp = NULL;

                        } else {

                            break;
                        }

                    }

                } // loop to the next privilege
            }  // there are new privileges added to the template
#endif

            ScepNotifyLogPolicy(rc,
                                FALSE,
                                L"Rights Modified",
                                SecurityDbLsa,
                                SecurityDbObjectLsaAccount,
                                AccountName ? AccountName : StringSid);

        } // success getting current privileges assigned to the account
    }

    if ( AccountName ) {
        LocalFree(AccountName);
    }

    if ( StringSid ) {
        LocalFree(StringSid);
    }

    LsaClose( lsaHandle );

    return rc;
}


DWORD
ScepNotifySaveChangedPolicies(
    IN PSCECONTEXT hProfile,
    IN SECURITY_DB_TYPE DbType,
    IN AREA_INFORMATION Area,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pMergedInfo OPTIONAL
    )
{

    if ( hProfile == NULL || pInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS    rc;

    rc = SceJetStartTransaction( hProfile );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( Area & AREA_SECURITY_POLICY ) {

            //
            // handle auditing policy
            //

            if ( DbType == SecurityDbLsa ) {
                rc = ScepNotifySavedAuditPolicy(hProfile,
                                                pInfo
                                               );
            } else {
                rc = ScepNotifySavedSystemAccess(hProfile,
                                                pInfo
                                               );
            }
        }

        if ( (SCESTATUS_SUCCESS == rc) &&
             (Area & AREA_PRIVILEGES) ) {

            //
            // handle user rights.
            //

            rc = ScepNotifySavedPrivileges(hProfile,
                                           pInfo->OtherInfo.smp.pPrivilegeAssignedTo,
                                           pMergedInfo ? pMergedInfo->OtherInfo.smp.pPrivilegeAssignedTo : NULL
                                          );
        }

        if ( rc == SCESTATUS_SUCCESS ) {
           //
           // needs return code for commiting the transaction
           //
           rc = SceJetCommitTransaction(hProfile, 0);

        }
        if ( rc != SCESTATUS_SUCCESS ) {

            SceJetRollback(hProfile, 0);
        }
    }


    return( ScepSceStatusToDosError(rc) );
}


SCESTATUS
ScepNotifySavedAuditPolicy(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo
    )
{
    SCE_KEY_LOOKUP       EventKeys[]={
        {(PWSTR)TEXT("AuditSystemEvents"),  offsetof(struct _SCE_PROFILE_INFO, AuditSystemEvents),   'D'},
        {(PWSTR)TEXT("AuditLogonEvents"),   offsetof(struct _SCE_PROFILE_INFO, AuditLogonEvents),    'D'},
        {(PWSTR)TEXT("AuditObjectAccess"),  offsetof(struct _SCE_PROFILE_INFO, AuditObjectAccess),   'D'},
        {(PWSTR)TEXT("AuditPrivilegeUse"),  offsetof(struct _SCE_PROFILE_INFO, AuditPrivilegeUse),   'D'},
        {(PWSTR)TEXT("AuditPolicyChange"),  offsetof(struct _SCE_PROFILE_INFO, AuditPolicyChange),   'D'},
        {(PWSTR)TEXT("AuditAccountManage"), offsetof(struct _SCE_PROFILE_INFO, AuditAccountManage),  'D'},
        {(PWSTR)TEXT("AuditProcessTracking"),offsetof(struct _SCE_PROFILE_INFO, AuditProcessTracking),'D'},
        {(PWSTR)TEXT("AuditDSAccess"),      offsetof(struct _SCE_PROFILE_INFO, AuditDSAccess),       'D'},
        {(PWSTR)TEXT("AuditAccountLogon"),  offsetof(struct _SCE_PROFILE_INFO, AuditAccountLogon),   'D'}};

    DWORD cKeys = sizeof(EventKeys) / sizeof(SCE_KEY_LOOKUP);


    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    return( ScepNotifySaveFixValueSection(
                hProfile,
                pInfo,
                EventKeys,
                cKeys,
                szAuditEvent
                ) );
}

SCESTATUS
ScepNotifySavedSystemAccess(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo
    )
{
    SCE_KEY_LOOKUP AccessKeys[] = {
        {(PWSTR)TEXT("MinimumPasswordAge"),     offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordAge),    'D'},
        {(PWSTR)TEXT("MaximumPasswordAge"),     offsetof(struct _SCE_PROFILE_INFO, MaximumPasswordAge),    'D'},
        {(PWSTR)TEXT("MinimumPasswordLength"),  offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordLength), 'D'},
        {(PWSTR)TEXT("PasswordComplexity"),     offsetof(struct _SCE_PROFILE_INFO, PasswordComplexity),    'D'},
        {(PWSTR)TEXT("PasswordHistorySize"),    offsetof(struct _SCE_PROFILE_INFO, PasswordHistorySize),   'D'},
        {(PWSTR)TEXT("LockoutBadCount"),        offsetof(struct _SCE_PROFILE_INFO, LockoutBadCount),       'D'},
        {(PWSTR)TEXT("ResetLockoutCount"),      offsetof(struct _SCE_PROFILE_INFO, ResetLockoutCount),     'D'},
        {(PWSTR)TEXT("LockoutDuration"),        offsetof(struct _SCE_PROFILE_INFO, LockoutDuration),       'D'},
        {(PWSTR)TEXT("RequireLogonToChangePassword"),offsetof(struct _SCE_PROFILE_INFO, RequireLogonToChangePassword),'D'},
        {(PWSTR)TEXT("ForceLogoffWhenHourExpire"),offsetof(struct _SCE_PROFILE_INFO, ForceLogoffWhenHourExpire),'D'},
        {(PWSTR)TEXT("ClearTextPassword"),      offsetof(struct _SCE_PROFILE_INFO, ClearTextPassword),     'D'}
        };
    DWORD cKeys = sizeof(AccessKeys) / sizeof(SCE_KEY_LOOKUP);


    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    return( ScepNotifySaveFixValueSection(
                hProfile,
                pInfo,
                AccessKeys,
                cKeys,
                szSystemAccess
                ) );
}


SCESTATUS
ScepNotifySaveFixValueSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName
    )
{

    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL, hSectionScp=NULL;

    DWORD       i;
    UINT        Offset;
    DWORD       valNewScep;

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                SectionName,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        DWORD dwThisTable = hProfile->Type & 0xF0L;

        if ( SCEJET_MERGE_TABLE_1 == dwThisTable ||
             SCEJET_MERGE_TABLE_2 == dwThisTable ) {

            if ( SCESTATUS_SUCCESS != ScepOpenSectionForName(
                                        hProfile,
                                        SCE_ENGINE_SCP,
                                        SectionName,
                                        &hSectionScp
                                        ) ) {
                hSectionScp = NULL;
            }
        }

        for ( i=0; i<cKeys; i++) {

            //
            // get settings in AccessLookup table
            //

            Offset = Keys[i].Offset;

            switch ( Keys[i].BufferType ) {
            case 'B':
                break;

            case 'D':

                valNewScep = *((DWORD *)((CHAR *)pInfo+Offset));

                //
                // update the SMP entry
                //
                rc = ScepCompareAndSaveIntValue(
                            hSectionSmp,
                            Keys[i].KeyString,
                            FALSE,
                            SCE_NO_VALUE,
                            valNewScep
                            );

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    //
                    // if not find for delete, ignore the error
                    //
                    rc = SCESTATUS_SUCCESS;

                } else if ( SCESTATUS_SUCCESS == rc &&
                            hSectionScp ) {

                    //
                    // update the SCP entry, ignore error
                    //
                    ScepCompareAndSaveIntValue(
                            hSectionScp,
                            Keys[i].KeyString,
                            FALSE,
                            SCE_NO_VALUE,
                            valNewScep
                            );
                }

                break;

            default:
                break;
            }

            if ( rc != SCESTATUS_SUCCESS ) {
                break;
            }
        }

        if ( hSectionScp ) {
            SceJetCloseSection(&hSectionScp, TRUE);
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);

}


SCESTATUS
ScepNotifySavedPrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pPrivList,
    IN PSCE_PRIVILEGE_ASSIGNMENT pMergedList OPTIONAL
    )
/*
Routine Description:

    Update privileges from

Arguements:

    hProfile - the jet database handle

    pPrivList    - the changed privilege buffer

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL, hSectionScp=NULL;
    PSCE_PRIVILEGE_ASSIGNMENT pPriv;

    if ( hProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pPrivList == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    LSA_HANDLE lsaHandle=NULL;

/*  no need to lookup account in save
    rc = RtlNtStatusToDosError(
            ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &lsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {

        lsaHandle = NULL;

        ScepNotifyLogPolicy(rc, FALSE, L"Open failed", SecurityDbLsa, SecurityDbObjectLsaPolicy, NULL );

        return(ScepDosErrorToSceStatus(rc));
    }
*/
    //
    // open smp section for privileges
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szPrivilegeRights,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        // if SCP is different then SMP, open it

        DWORD dwThisTable = hProfile->Type & 0xF0L;


        if ( SCEJET_MERGE_TABLE_1 == dwThisTable ||
             SCEJET_MERGE_TABLE_2 == dwThisTable ) {

            if ( SCESTATUS_SUCCESS != ScepOpenSectionForName(
                                        hProfile,
                                        SCE_ENGINE_SCP,
                                        szPrivilegeRights,
                                        &hSectionScp
                                        ) ) {
                hSectionScp = NULL;
            }
        }

        for ( pPriv=pPrivList; pPriv != NULL; pPriv = pPriv->Next ) {
            //
            // Process each privilege in the new list
            // Update SMP with new value
            //
            if ( pPriv->Status == SCE_STATUS_MISMATCH ) {

                //
                // this is in name format, should convert it
                //
                rc = ScepWriteNameListValue(
                        lsaHandle,
                        hSectionSmp,
                        pPriv->Name,
                        pPriv->AssignedTo,
                        SCE_WRITE_EMPTY_LIST, //  | SCE_WRITE_CONVERT, no need to lookup
                        0
                        );

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    rc = SCESTATUS_SUCCESS;

                } else if ( rc != SCESTATUS_SUCCESS) {
                    break;
                }
            }
        }

        if ( hSectionScp && pMergedList ) {

            for ( pPriv=pMergedList; pPriv != NULL; pPriv = pPriv->Next ) {
                //
                // Process each privilege in the new list
                // Update SCP with new value, don't care error
                //
                if ( pPriv->Status == SCE_STATUS_MISMATCH ) {

                    //
                    // this is in name format, convert it
                    //
                    rc = ScepWriteNameListValue(
                            lsaHandle,
                            hSectionScp,
                            pPriv->Name,
                            pPriv->AssignedTo,
                            SCE_WRITE_EMPTY_LIST, // no need to lookup | SCE_WRITE_CONVERT,
                            0
                            );

                    rc = SCESTATUS_SUCCESS;

                }
            }

        }

        if ( hSectionScp ) {
            SceJetCloseSection(&hSectionScp, TRUE);
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    if ( lsaHandle ) {
        LsaClose(lsaHandle);
    }

    return(rc);

}

DWORD
ScepNotifyGetDefaultGPOTemplateName(
    IN UNICODE_STRING DnsDomainName,
    IN PWSTR ComputerName OPTIONAL,
    IN BOOL bDomainPolicy,
    IN DWORD dwInSetup,
    OUT LPTSTR *pTemplateName
    )
/*
Description:

    This function builds and returns a full path Group Policy Template
    name (gpttmpl.inf) in a specified GPO - default domain GPO or default
    domain controller GPO.


    In NT4 upgrade, because DS is not created yet, a temporary file is used in
    %windir%\security\filtemp.inf

    In NT5 upgrade, because network is not running in setup (sysvol share is not
    accessible), the GPO template is referenced with absolute path, e.g.
    %windir%\sysvol\sysvol\<dns name>\.... If sysvol path can't be queried,
    the temporary file as in NT4 case is used.

    Outside setup when DS/network is running, the GPO template is referenced
    with the DNS UNC path, e.g, \\<computername>\sysvol\<dns name>\...
    If ComputerName is passed in, the parameter will be used; otherwise, the
    local computer name is queried and used.

Parameters:

    DnsDomainName - Domain's DNS name used in the path

    ComputerName  - name for the computer to connect to

    bDomainPolicy - TRUE = default domain GPO; FALSE = default domain controller GPO

    dwInSetup     - != 0 in setup (NT4 or NT5)

    pTemplateName - the output template full path name

Return Value:

    Win32 error

*/
{

    if ( ( dwInSetup != SCEGPO_INSETUP_NT4 &&
           ( DnsDomainName.Buffer == NULL ||
             DnsDomainName.Length == 0)) ||
           pTemplateName == NULL ) {

        return(ERROR_INVALID_PARAMETER);
    }

    //
    // we have to replace the first DNS name with computer name
    // because it might point to a remote machine where
    // we don't have write access.
    //


    TCHAR Buffer[MAX_PATH+1];
    DWORD dSize=MAX_PATH;
    PWSTR SysvolPath=NULL;

    Buffer[0] = L'\0';
    BOOL bDefaultToNT4 = FALSE;

    if ( dwInSetup == SCEGPO_INSETUP_NT5 ) {
        //
        // query the sysvol path from netlogon\parameters\sysvol registry value
        //

        DWORD RegType;
        DWORD rc = ScepRegQueryValue(HKEY_LOCAL_MACHINE,
                               L"System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
                               L"Sysvol",
                               (PVOID *)&SysvolPath,
                               &RegType,
                               NULL
                              );

        if ( ERROR_SUCCESS != rc || SysvolPath == NULL || RegType != REG_SZ) {

            //
            // if fails to query the sysvol path, default to NT4 setup case
            // where the changes are saved in the temp file
            //
            bDefaultToNT4 = TRUE;
            if ( SysvolPath ) {
                ScepFree(SysvolPath);
                SysvolPath = NULL;
            }
        }
    }

    if ( dwInSetup == SCEGPO_INSETUP_NT5 ||
         dwInSetup == SCEGPO_INSETUP_NT4 ) {
        //
        // temp file name is stored in %windir% directory
        //
        GetSystemWindowsDirectory(Buffer, MAX_PATH);

    } else if ( ComputerName == NULL ) {
        //
        // get current computer name
        //
        GetComputerName(Buffer, &dSize);

    } else {

        //
        // use the passed in computer name
        //
        wcscpy(Buffer, ComputerName);
    }

    Buffer[MAX_PATH] = L'\0';

    dSize = wcslen(Buffer);

    DWORD Len;
    DWORD rc=ERROR_SUCCESS;


    if ( dwInSetup == SCEGPO_INSETUP_NT4 ||
        (dwInSetup == SCEGPO_INSETUP_NT5 && bDefaultToNT4) ) {
        //
        // in setup, use the temp GPO file name
        //

        Len = dSize + wcslen(TEXT("\\security\\filtemp.inf"));

        *pTemplateName = (PWSTR)LocalAlloc(LPTR, (Len+2)*sizeof(TCHAR));

        if ( *pTemplateName ) {

            swprintf(*pTemplateName, L"%s\\security\\filtemp.inf\0", Buffer);

            //
            // create the registry value for post setup
            //

            ScepRegSetIntValue( HKEY_LOCAL_MACHINE,
                                SCE_ROOT_PATH,
                                TEXT("PolicyChangedInSetup"),
                                1
                                );

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        return rc;
    }

    if ( dwInSetup == SCEGPO_INSETUP_NT5 ||
         dwInSetup == SCEGPO_INSETUP_NT4 ) {

        //
        // in NT5 setup upgrade, should use SysvolPath
        // SysvolPath should not be NULL when get here
        // but let's check it to avoid prefix errors
        //
        if ( SysvolPath == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dSize = wcslen(SysvolPath);
        Len = dSize + 1;

    } else {

        Len = 2 + dSize + wcslen(TEXT("\\sysvol\\"));
    }

    Len +=  (   DnsDomainName.Length/sizeof(TCHAR) +
                wcslen(TEXT("\\Policies\\{}\\Machine\\")) +
                wcslen(GPTSCE_TEMPLATE) );

    if ( bDomainPolicy ) {

        Len += wcslen(STR_DEFAULT_DOMAIN_GPO_GUID);

    } else {

        Len += wcslen(STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID);
    }

    //
    // allocate buffer for the final GPO name
    //
    PWSTR GpoTemplateName = (PWSTR)LocalAlloc(LPTR, (Len+2)*sizeof(TCHAR));

    if ( GpoTemplateName ) {

        DWORD indx=0;

        if ( dwInSetup == SCEGPO_INSETUP_NT5 ||
             dwInSetup == SCEGPO_INSETUP_NT4 ) {
            swprintf(GpoTemplateName, L"%s\\", SysvolPath);
            indx = 1;
        } else {
            swprintf(GpoTemplateName, L"\\\\%s\\sysvol\\", Buffer);
            indx = 10;
        }

        wcsncpy(GpoTemplateName+indx+dSize, DnsDomainName.Buffer, DnsDomainName.Length/2);

        if ( bDomainPolicy ) {
            swprintf(GpoTemplateName+indx+dSize+DnsDomainName.Length/2,
                     L"\\Policies\\{%s}\\Machine\\%s\0",
                     STR_DEFAULT_DOMAIN_GPO_GUID, GPTSCE_TEMPLATE );

        } else {
            swprintf(GpoTemplateName+indx+dSize+DnsDomainName.Length/2,
                     L"\\Policies\\{%s}\\Machine\\%s\0",
                     STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID, GPTSCE_TEMPLATE );

        }

        //
        // check to see if the template exists
        //
        if ( SCEGPO_NOCHECK_EXISTENCE != dwInSetup ) {

            if ( 0xFFFFFFFF == GetFileAttributes(GpoTemplateName) ) {

                rc = ERROR_OBJECT_NOT_FOUND;

                LocalFree(GpoTemplateName);
                GpoTemplateName = NULL;

            }
        }

    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // free the buffers if it fails
    //
    if ( SysvolPath ) {
        ScepFree(SysvolPath);
    }

    *pTemplateName = GpoTemplateName;

    return rc;

}

DWORD
ScepNotifySaveNotifications(
    IN PWSTR TemplateName,
    IN SECURITY_DB_TYPE  DbType,
    IN SECURITY_DB_OBJECT_TYPE  ObjectType,
    IN SECURITY_DB_DELTA_TYPE  DeltaType,
    IN PSID ObjectSid OPTIONAL
    )
{
    if ( TemplateName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD rc=ERROR_SUCCESS;

    if ( SecurityDbLsa == DbType &&
         SecurityDbObjectLsaPolicy == ObjectType ) {
        //
        // LSA policy changes
        //

        if ( !WritePrivateProfileString(L"Policies",
                                        L"LsaPolicy",
                                        L"1",
                                        TemplateName
                                       ) ) {
            rc = GetLastError();
        }

    } else if ( SecurityDbSam == DbType &&
                ObjectType != SecurityDbObjectSamUser &&
                ObjectType != SecurityDbObjectSamGroup &&
                ObjectType != SecurityDbObjectSamAlias ) {

        //
        // if it's not for deleted account, update the SAM policy section
        //

        if ( !WritePrivateProfileString(L"Policies",
                                        L"SamPolicy",
                                        L"1",
                                        TemplateName
                                       ) ) {
            rc = GetLastError();
        }

    } else if ( ObjectSid &&
                (SecurityDbLsa == DbType || SecurityDbSam == DbType ) ) {

        //
        // account policy is changed (user rights)
        // get all privileges assigned to this account
        //

        DWORD dwPrivLowHeld=0, dwPrivHighHeld=0;

        if ( DeltaType == SecurityDbDelete ) {

            dwPrivLowHeld = 0;
            dwPrivHighHeld = 0;

        } else {

            LSA_HANDLE      lsaHandle=NULL;

            NTSTATUS NtStatus = ScepOpenLsaPolicy(
                                    POLICY_VIEW_LOCAL_INFORMATION |
                                        POLICY_LOOKUP_NAMES,
                                    &lsaHandle,
                                    TRUE
                                    );

            if ( NT_SUCCESS(NtStatus) ) {

                NtStatus = ScepGetAccountExplicitRight(
                                    lsaHandle,
                                    ObjectSid,
                                    &dwPrivLowHeld,
                                    &dwPrivHighHeld
                                    );
                LsaClose( lsaHandle );
            }
        }

        PWSTR SidString=NULL;

        if ( ConvertSidToStringSid(ObjectSid,
                                   &SidString
                                  ) &&
             SidString ) {

            TCHAR tmpBuf[40];
            swprintf(tmpBuf, L"%d %d %d\0", (DWORD)DeltaType, dwPrivLowHeld, dwPrivHighHeld);

            if ( !WritePrivateProfileString(L"Accounts",
                                            SidString,
                                            tmpBuf,
                                            TemplateName
                                           ) ) {
                rc = GetLastError();
            }

            LocalFree(SidString);

        } else {
            rc = GetLastError();
        }

    }

    return rc;
}


DWORD
ScepNotifyUpdateGPOVersion(
    IN PWSTR GpoTemplateName,
    IN BOOL bDomainPolicy
    )
/*
Update the version # (in DS and gpt.ini) for machine policy change
property gPCMachineExtensionNames is not changed because security extension
guid should already be there (by default).

*/
{
    if ( GpoTemplateName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD rc=ERROR_SUCCESS;
    DWORD dwVersion = 0;

    //
    // check gpt.ini existance
    //
    // build full path of gpt.ini first
    //
    PWSTR pTemp = wcsstr( GpoTemplateName, L"\\Machine\\");

    if ( pTemp == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    PWSTR pszVersionFile = (PWSTR)LocalAlloc(0, (pTemp-GpoTemplateName+wcslen(TEXT("\\gpt.ini"))+1)*sizeof(WCHAR));

    if ( pszVersionFile == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcsncpy(pszVersionFile, GpoTemplateName, (size_t)(pTemp-GpoTemplateName));
    pszVersionFile[pTemp-GpoTemplateName] = L'\0';

    wcscat(pszVersionFile, TEXT("\\gpt.ini"));

    /*
    DWORD dwVersion = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, pszVersionFile);

    if ( dwVersion == 0 ) {
        //
        // couldn't find version #, this is bad
        //
        rc = ERROR_FILE_NOT_FOUND;

    } 
    */

	
    DWORD dwFileAttributes = GetFileAttributes(pszVersionFile);

    if(INVALID_FILE_ATTRIBUTES == dwFileAttributes){

        rc = GetLastError();

    } else {

        //
        // bind to DS, get DS root
        //

        PLDAP phLdap = ldap_open(NULL, LDAP_PORT);

        if ( phLdap == NULL ) {

            rc = ERROR_FILE_NOT_FOUND;

        } else {
            rc = ldap_bind_s(phLdap,
                            NULL,
                            NULL,
                            LDAP_AUTH_SSPI);

            if ( rc == ERROR_SUCCESS ) {

                LDAPMessage *Message = NULL;          // for LDAP calls.
                PWSTR    Attribs[3];                  // for LDAP calls.
                LDAPMessage *Entry = NULL;
                PWSTR DsRootName=NULL;

                Attribs[0] = LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W;   // ntldap.h
                Attribs[1] = NULL;
                Attribs[2] = NULL;

                rc = ldap_search_s(phLdap,
                                  L"",
                                  LDAP_SCOPE_BASE,
                                  L"(objectClass=*)",
                                  Attribs,
                                  0,
                                  &Message);

                if( rc == ERROR_SUCCESS ) {

                    //
                    // read the first entry.
                    // we did base level search, we have only one entry.
                    // Entry does not need to be freed (it is freed with the message)
                    //
                    Entry = ldap_first_entry(phLdap, Message);
                    if(Entry != NULL) {

                        PWSTR *Values = ldap_get_values(phLdap, Entry, Attribs[0]);

                        if(Values != NULL) {

                            DsRootName = (PWSTR)LocalAlloc(0, (wcslen(Values[0])+1)*sizeof(WCHAR));

                            if ( DsRootName ) {
                                wcscpy(DsRootName, Values[0]);
                            } else {
                                rc = ERROR_NOT_ENOUGH_MEMORY;
                            }

                            ldap_value_free(Values);
                        } else
                            rc = LdapMapErrorToWin32(phLdap->ld_errno);

                    } else
                        rc = LdapMapErrorToWin32(phLdap->ld_errno);

                    Entry = NULL;

                }

                //
                // ldap_search can return failure and still allocate the buffer
                //
                if ( Message ) {
                    ldap_msgfree(Message);
                    Message = NULL;
                }

                if ( DsRootName ) {
                    //
                    // query version from DS, if failed, query version from gpt.ini
                    //
                    Attribs[0] = L"distinguishedName";
                    Attribs[1] = L"versionNumber";
                    Attribs[2] = NULL;


                    WCHAR szFilter[128];

                    if ( bDomainPolicy ) {
                        swprintf(szFilter, L"( &(objectClass=groupPolicyContainer)(cn={%s}) )", STR_DEFAULT_DOMAIN_GPO_GUID);
                    } else {
                        swprintf(szFilter, L"( &(objectClass=groupPolicyContainer)(cn={%s}) )", STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID);
                    }

                    phLdap->ld_options = 0; // no chased referrel

                    rc = ldap_search_s(
                              phLdap,
                              DsRootName,
                              LDAP_SCOPE_SUBTREE,
                              szFilter,
                              Attribs,
                              0,
                              &Message);

                    if( rc == ERROR_SUCCESS ) {

                        //
                        // read the first entry.
                        // we did base level search, we have only one entry.
                        // Entry does not need to be freed (it is freed with the message)
                        //
                        Entry = ldap_first_entry(phLdap, Message);
                        if(Entry != NULL) {

                            PWSTR *Values = ldap_get_values(phLdap, Entry, Attribs[0]);

                            if(Values != NULL) {
                                if ( Values[0] == NULL ) {
                                    //
                                    // unknown error.
                                    //
                                    rc = ERROR_FILE_NOT_FOUND;
                                } else {

                                    PWSTR *pszVersions = ldap_get_values(phLdap, Entry, Attribs[1]);

                                    if ( pszVersions && pszVersions[0] ) {
                                        //
                                        // this is the version number
                                        //
                                        dwVersion = _wtol(pszVersions[0]);
                                    }

                                    if ( pszVersions ) {
                                        ldap_value_free(pszVersions);
                                    }

                                    //
                                    // Value[0] is the base GPO name,
                                    // now modify the version #
                                    //

                                    PLDAPMod        rgMods[2];
                                    LDAPMod         Mod;
                                    PWSTR           rgpszVals[2];
                                    WCHAR           szVal[32];
                                    USHORT uMachine, uUser;

                                    //
                                    // split the version # for machine and user
                                    //
                                    uUser = (USHORT) HIWORD(dwVersion);
                                    uMachine = (USHORT) LOWORD(dwVersion);

                                    //
                                    // increament version number and skip zero
                                    // when it overflows and go to one.
                                    // because zero is treated specially by
                                    // the group policy engine and will lead
                                    // to skip the GPO processing
                                    //
									
                                    uMachine++;
                                    if(0 == uMachine)
                                        uMachine++;
                                    
                                    dwVersion = (ULONG) MAKELONG (uMachine, uUser);

                                    rgMods[0] = &Mod;
                                    rgMods[1] = NULL;

                                    memset(szVal, '\0', 32*2);
                                    swprintf(szVal, L"%d", dwVersion);

                                    rgpszVals[0] = szVal;
                                    rgpszVals[1] = NULL;

                                    //
                                    // lets set version number back
                                    //
                                    Mod.mod_op      = LDAP_MOD_REPLACE;
                                    Mod.mod_values  = rgpszVals;
                                    Mod.mod_type    = L"versionNumber";

                                    //
                                    // Now, we'll do the write
                                    //
                                    rc = ldap_modify_s(phLdap,
                                                           Values[0],
                                                           rgMods
                                                           );

                                    if ( rc == ERROR_ALREADY_EXISTS )
                                        rc = ERROR_SUCCESS;

                                    if ( rc == ERROR_SUCCESS ) {
                                        //
                                        // update version in gpt.ini
                                        //
                                        WritePrivateProfileString (TEXT("General"), TEXT("Version"), szVal, pszVersionFile);

                                    }

                                }

                                ldap_value_free(Values);

                            } else
                                rc = LdapMapErrorToWin32(phLdap->ld_errno);
                        } else
                            rc = LdapMapErrorToWin32(phLdap->ld_errno);

                    }

                    LocalFree(DsRootName);

                    //
                    // ldap_search can return failure and still allocate the buffer
                    //
                    if ( Message ) {
                        ldap_msgfree(Message);
                        Message = NULL;
                    }
                }
            }

            ldap_unbind(phLdap);
        }
    }

    LocalFree(pszVersionFile);

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\scejet.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scejet.c

Abstract:

    Sce-Jet service APIs

Author:

    Jin Huang (jinhuang) 13-Jan-1997

Revision History:

--*/

#include "serverp.h"
#include <io.h>

#include <objbase.h>
#include <initguid.h>

#include <crtdbg.h>
#include <stddef.h>
#include <atlconv.h>
#include <atlbase.h>

//#define SCEJET_DBG    1

//
// should be controlled by critical section for static variables
//

static JET_INSTANCE    JetInstance=0;
static BOOL            JetInited=FALSE;
static BOOL            JetInitAttempted=FALSE;
extern CRITICAL_SECTION JetSync;




#define SCE_JET_CORRUPTION_ERROR(Err) (Err == JET_errDatabaseCorrupted ||\
                                       Err == JET_errDiskIO ||\
                                       Err == JET_errReadVerifyFailure ||\
                                       Err == JET_errBadPageLink ||\
                                       Err == JET_errDbTimeCorrupted ||\
                                       Err == JET_errLogFileCorrupt ||\
                                       Err == JET_errCheckpointCorrupt ||\
                                       Err == JET_errLogCorruptDuringHardRestore ||\
                                       Err == JET_errLogCorruptDuringHardRecovery ||\
                                       Err == JET_errCatalogCorrupted ||\
                                       Err == JET_errDatabaseDuplicate)

DEFINE_GUID(CLSID_SceWriter,0x9cb9311a, 0x6b16, 0x4d5c, 0x85, 0x3e, 0x53, 0x79, 0x81, 0x38, 0xd5, 0x51);
// 9cb9311a-6b16-4d5c-853e-53798138d551

typedef struct _FIND_CONTEXT_ {
    DWORD           Length;
    WCHAR           Prefix[SCEJET_PREFIX_MAXLEN];
} SCEJET_FIND_CONTEXT;

//
// each thread has its own FindContext
//
SCEJET_FIND_CONTEXT Thread FindContext;


JET_ERR
SceJetpSeek(
    IN PSCESECTION hSection,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength,
    IN SCEJET_SEEK_FLAG SeekBit,
    IN BOOL bOkNoMatch
    );

JET_ERR
SceJetpCompareLine(
    IN PSCESECTION   hSection,
    IN JET_GRBIT    grbit,
    IN PWSTR        LinePrefix OPTIONAL,
    IN DWORD        PrefixLength,
    OUT INT         *Result,
    OUT DWORD       *ActualLength OPTIONAL
    );

JET_ERR
SceJetpMakeKey(
    IN JET_SESID SessionID,
    IN JET_TABLEID  TableID,
    IN DOUBLE SectionID,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength
    );

JET_ERR
SceJetpBuildUpperLimit(
    IN PSCESECTION hSection,
    IN PWSTR      LinePrefix,
    IN DWORD      Len,
    IN BOOL       bReserveCase
    );

SCESTATUS
SceJetpGetAvailableSectionID(
    IN PSCECONTEXT cxtProfile,
    OUT DOUBLE *SectionID
    );

SCESTATUS
SceJetpAddAllSections(
    IN PSCECONTEXT cxtProfile
    );

SCESTATUS
SceJetpConfigJetSystem(
    IN JET_INSTANCE *hinstance
    );

SCESTATUS
SceJetpGetValueFromVersion(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TableName,
    IN LPSTR ColumnName,
    OUT LPSTR Value OPTIONAL,
    IN DWORD  ValueLen, // number of bytes
    OUT PDWORD pRetLen
    );

SCESTATUS
SceJetpAddGpo(
    IN PSCECONTEXT cxtProfile,
    IN JET_TABLEID TableID,
    IN JET_COLUMNID GpoIDColumnID,
    IN PCWSTR      Name,
    OUT LONG       *pGpoID
    );

//
// Code to handle profile
//
SCESTATUS
SceJetOpenFile(
    IN LPSTR       ProfileFileName,
    IN SCEJET_OPEN_TYPE Flags,
    IN DWORD       dwTableOptions,
    OUT PSCECONTEXT  *cxtProfile
    )
/* ++
Routine Description:

    This routine opens the profile (database) and outputs the context handle.
    The information returned in the context handle include the Jet session ID,
    Jet database ID, Jet table ID for SCP table, Jet column ID for column
    "Name" and "Value" in the SCP table, and optional information for SAP and
    SMP table.

    If the context handle passed in contains not NULL information, this routine
    will close all tables and the database in the context (use the same session).

    The context handle must be freed by LocalFree after its use.

    A new jet session is created when the context handle is created.

Arguments:

    ProfileFileName - ASCII name of a database (profile)

    Flags           - flags to open the database

    cxtProfile      - the context handle (See SCECONTEXT structure)

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_PROFILE_NOT_FOUND
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_BAD_FORMAT
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_OTHER_ERROR

-- */
{
    JET_ERR     JetErr;
    SCESTATUS   rc;
    BOOL        FreeContext=FALSE;
    JET_GRBIT   JetDbFlag;
    DWORD dwScpTable=0;


    if ( ProfileFileName == NULL || cxtProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( *cxtProfile && ScepIsValidContext(*cxtProfile) ) {
        __try {
            //
            // Close previous opened database
            //
            rc = SceJetCloseFile(
                            *cxtProfile,
                            FALSE,
                            FALSE
                            );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // this is a invalid pointer
            //
            *cxtProfile = NULL;
        }
    }

    if ( *cxtProfile == NULL ) {
        //
        // no session
        //
        *cxtProfile = (PSCECONTEXT)LocalAlloc( LMEM_ZEROINIT, sizeof(SCECONTEXT));
        if ( *cxtProfile == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
        (*cxtProfile)->Type = 0xFFFFFF02L;
        (*cxtProfile)->JetSessionID = JET_sesidNil;
        (*cxtProfile)->JetDbID = JET_dbidNil;
        (*cxtProfile)->OpenFlag = SCEJET_OPEN_READ_WRITE;
        (*cxtProfile)->JetScpID = JET_tableidNil;
        (*cxtProfile)->JetSapID = JET_tableidNil;
        (*cxtProfile)->JetSmpID = JET_tableidNil;
        (*cxtProfile)->JetTblSecID = JET_tableidNil;

        FreeContext = TRUE;

    }

    //
    // Begin a session
    //
    if ( (*cxtProfile)->JetSessionID == JET_sesidNil ) {
        JetErr = JetBeginSession(
                        JetInstance,
                        &((*cxtProfile)->JetSessionID),
                        NULL,
                        NULL
                        );
        rc = SceJetJetErrorToSceStatus(JetErr);
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    switch (Flags) {
    case SCEJET_OPEN_EXCLUSIVE:
    case SCEJET_OPEN_NOCHECK_VERSION:
        JetDbFlag = 0;  // read & write
//        JetDbFlag = JET_bitDbExclusive;
        (*cxtProfile)->OpenFlag = SCEJET_OPEN_EXCLUSIVE;
        break;
    case SCEJET_OPEN_READ_ONLY:
        JetDbFlag = JET_bitDbReadOnly;

        (*cxtProfile)->OpenFlag = Flags;
        break;
    default:
        JetDbFlag = 0;
        (*cxtProfile)->OpenFlag = SCEJET_OPEN_READ_WRITE;
        break;
    }

    //
    // Attach database
    //
    JetErr = JetAttachDatabase(
                    (*cxtProfile)->JetSessionID,
                    ProfileFileName,
                    JetDbFlag
                    );
#ifdef SCEJET_DBG
    printf("Attach database JetErr=%d\n", JetErr);
#endif
    if ( JetErr == JET_wrnDatabaseAttached )
        JetErr = JET_errSuccess;

    rc = SceJetJetErrorToSceStatus(JetErr);
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    //
    // Open database
    //
    JetErr = JetOpenDatabase(
                    (*cxtProfile)->JetSessionID,
                    ProfileFileName,
                    NULL,
                    &((*cxtProfile)->JetDbID),
                    JetDbFlag  //JET_bitDbExclusive
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);
#ifdef SCEJET_DBG
    printf("Open database %s return code %d (%d) \n", ProfileFileName, rc, JetErr);
#endif
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    if ( Flags != SCEJET_OPEN_NOCHECK_VERSION ) {

        //
        // Check database format (for security manager, version#)
        //
        rc = SceJetCheckVersion( *cxtProfile, NULL );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

#ifdef SCEJET_DBG
    printf("Open: Version check OK\n");
#endif
    }

    //
    // Open section table. must be there
    //
    rc = SceJetOpenTable(
                    *cxtProfile,
                    "SmTblSection",
                    SCEJET_TABLE_SECTION,
                    Flags,
                    NULL
                    );

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    //
    // open smp table -- optional
    //
    rc = SceJetOpenTable(
                    *cxtProfile,
                    "SmTblSmp",
                    SCEJET_TABLE_SMP,
                    Flags,
                    NULL
                    );

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    //
    // get the last used merge table (SCP) to open
    // shouldn't fail
    // 1 - SmTblScp  2 - SmTblScp2  0 - no policy merge
    //
    DWORD Actual;

    rc = SceJetpGetValueFromVersion(
                *cxtProfile,
                "SmTblVersion",
                "LastUsedMergeTable",
                (LPSTR)&dwScpTable,
                4, // number of bytes
                &Actual
                );

    if ( (dwScpTable != SCEJET_MERGE_TABLE_1) &&
         (dwScpTable != SCEJET_MERGE_TABLE_2) ) {

        dwScpTable = SCEJET_LOCAL_TABLE;
    }

    rc = SCESTATUS_SUCCESS;
    (*cxtProfile)->Type &= 0xFFFFFF0FL;

    if ( dwTableOptions & SCE_TABLE_OPTION_MERGE_POLICY ) {
        //
        // in policy propagation
        //
        if ( ( dwScpTable == SCEJET_MERGE_TABLE_2 ) ) {
            //
            // the second table is already propped
            //
            rc = SceJetOpenTable(
                            *cxtProfile,
                            "SmTblScp",
                            SCEJET_TABLE_SCP,
                            Flags,
                            NULL
                            );
            (*cxtProfile)->Type |= SCEJET_MERGE_TABLE_1;

        } else {
            rc = SceJetOpenTable(
                            *cxtProfile,
                            "SmTblScp2",
                            SCEJET_TABLE_SCP,
                            Flags,
                            NULL
                            );
            (*cxtProfile)->Type |= SCEJET_MERGE_TABLE_2;
        }
    } else {

        switch ( dwScpTable ) {
        case SCEJET_MERGE_TABLE_2:
            //
            // the second table
            //
            rc = SceJetOpenTable(
                            *cxtProfile,
                            "SmTblScp2",
                            SCEJET_TABLE_SCP,
                            Flags,
                            NULL
                            );
            break;

        case SCEJET_MERGE_TABLE_1:

            rc = SceJetOpenTable(
                            *cxtProfile,
                            "SmTblScp",
                            SCEJET_TABLE_SCP,
                            Flags,
                            NULL
                            );

            break;

        default:
            //
            // open SMP table instead, because SCP table doesn't have information
            //
            (*cxtProfile)->JetScpID = (*cxtProfile)->JetSmpID;
            (*cxtProfile)->JetScpSectionID = (*cxtProfile)->JetSmpSectionID;
            (*cxtProfile)->JetScpNameID = (*cxtProfile)->JetSmpNameID;
            (*cxtProfile)->JetScpValueID = (*cxtProfile)->JetSmpValueID;
            (*cxtProfile)->JetScpGpoID = 0;

            break;
        }

        (*cxtProfile)->Type |= dwScpTable;
    }

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    if ( dwTableOptions & SCE_TABLE_OPTION_TATTOO ) {

        rc = SceJetOpenTable(
                        *cxtProfile,
                        "SmTblTattoo",
                        SCEJET_TABLE_TATTOO,
                        Flags,
                        NULL
                        );

    } else {
        //
        // open sap table -- optional
        //
        rc = SceJetOpenTable(
                        *cxtProfile,
                        "SmTblSap",
                        SCEJET_TABLE_SAP,
                        Flags,
                        NULL
                        );
    }

Done:

    if ( rc != SCESTATUS_SUCCESS ) {
        SceJetCloseFile(
                *cxtProfile,
                FALSE,
                FALSE
                );

        if ( FreeContext == TRUE ) {
            if ( (*cxtProfile)->JetSessionID != JET_sesidNil ) {
                JetEndSession(
                    (*cxtProfile)->JetSessionID,
                    JET_bitForceSessionClosed
                    );
            }
            LocalFree(*cxtProfile);
            *cxtProfile = NULL;
        }
    }

    return(rc);

}


SCESTATUS
SceJetCreateFile(
    IN LPSTR        ProfileFileName,
    IN SCEJET_CREATE_TYPE    Flags,
    IN DWORD        dwTableOptions,
    OUT PSCECONTEXT  *cxtProfile
    )
/* ++
Routine Description:

    This routine creates a database (profile) and outputs the context handle.
    See comments in SceJetOpenFile for information contained in the context.

    If the database name already exists in the system, there are 3 options:
        Flags = SCEJET_OVERWRITE_DUP - the existing database will be erased and
                                          recreated.
        Flags = SCEJET_OPEN_DUP      - the existing database will be opened and
                                          format is checked
        Flags = SCEJET_OPEN_DUP_EXCLUSIVE - the existing database will be opened
                                            exclusively.
        Flags = SCEJET_RETURN_ON_DUP - a error code SCESTATUS_FILE_EXIST is returned.

    When creating the database, only SCP table is created initially. SAP and SMP
    tables will be created when analysis is performed.

    The context handle must be freed by LocalFree after its use.

Arguments:

    ProfileFileName - ASCII name of a database to create.

    Flags           - This flag is used when there is an duplicate database
                            SCEJET_OVERWRITE_DUP
                            SCEJET_OPEN_DUP
                            SCEJET_OPEN_DUP_EXCLUSIVE
                            SCEJET_RETURN_ON_DUP

    cxtProfile      - The context handle

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_PROFILE_NOT_FOUND
    SCESTATUS_OBJECT_EXIST
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_CANT_DELETE
    SCESTATUS_OTHER_ERROR

    SCESTATUS from SceJetOpenFile

-- */
{
    JET_ERR     JetErr;
    SCESTATUS    rc=SCESTATUS_SUCCESS;
    BOOL        FreeContext=FALSE;
    DWORD       Len;
    FLOAT       Version=(FLOAT)1.2;
    JET_TABLEID TableID;
    JET_COLUMNID ColumnID;


    if ( ProfileFileName == NULL || cxtProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( *cxtProfile && ScepIsValidContext(*cxtProfile) ) {
        //
        // Close previous opened database
        //
        rc = SceJetCloseFile(
                        *cxtProfile,
                        FALSE,
                        FALSE
                        );
    } else {
        *cxtProfile = NULL;
    }

    if ( *cxtProfile == NULL ) {
        //
        // no session
        //
        *cxtProfile = (PSCECONTEXT)LocalAlloc( LMEM_ZEROINIT, sizeof(SCECONTEXT));
        if ( *cxtProfile == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
        (*cxtProfile)->Type = 0xFFFFFF02L;
        (*cxtProfile)->JetSessionID = JET_sesidNil;
        (*cxtProfile)->JetDbID = JET_dbidNil;
        (*cxtProfile)->OpenFlag = SCEJET_OPEN_READ_WRITE;
        (*cxtProfile)->JetScpID = JET_tableidNil;
        (*cxtProfile)->JetSapID = JET_tableidNil;
        (*cxtProfile)->JetSmpID = JET_tableidNil;
        (*cxtProfile)->JetTblSecID = JET_tableidNil;

        FreeContext = TRUE;

    }

    (*cxtProfile)->Type &= 0xFFFFFF0FL;

    //
    // Begin a session
    //
    if ( (*cxtProfile)->JetSessionID == JET_sesidNil ) {
        JetErr = JetBeginSession(
                        JetInstance,
                        &((*cxtProfile)->JetSessionID),
                        NULL,
                        NULL
                        );
        rc = SceJetJetErrorToSceStatus(JetErr);
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
    }
    //
    // Create database
    //
    JetErr = JetCreateDatabase(
                    (*cxtProfile)->JetSessionID,
                    ProfileFileName,
                    NULL,
                    &((*cxtProfile)->JetDbID),
                    JET_bitDbExclusive
                    );
    if ( JET_errFileNotFound == JetErr ) {
        //
        // if no access to create a file in the path
        // ESENT returns this error. It's fixed in ESE98
        // we have to mask it to access denied error for now
        //
        JetErr = JET_errFileAccessDenied;
    }
#ifdef SCEJET_DBG
    printf("Create database %s JetErr = %d\n", ProfileFileName, JetErr);
#endif
    rc = SceJetJetErrorToSceStatus(JetErr);

    (*cxtProfile)->OpenFlag = SCEJET_OPEN_EXCLUSIVE;

    if ( rc == SCESTATUS_OBJECT_EXIST ) {
        switch ( Flags ) {
        case SCEJET_OVERWRITE_DUP:
            //
            // erase the database
            //

            JetDetachDatabase(
                    (*cxtProfile)->JetSessionID,
                    ProfileFileName
                    );

            if ( !DeleteFileA(ProfileFileName) &&
                 GetLastError() != ERROR_FILE_NOT_FOUND ) {

                ScepLogOutput3(1,GetLastError(), SCEDLL_ERROR_DELETE_DB );
            }

            //
            // if delete database failed, log the error but continue to
            // create the database. This call will fail with Jet error.
            //
            JetErr = JetCreateDatabase(
                            (*cxtProfile)->JetSessionID,
                            ProfileFileName,
                            NULL,
                            &((*cxtProfile)->JetDbID),
                            JET_bitDbExclusive
                            );
            if ( JET_errFileNotFound == JetErr ) {
                //
                // if no access to create a file in the path
                // ESENT returns this error. It's fixed in ESE98
                // we have to mask it to access denied error for now
                //
                JetErr = JET_errFileAccessDenied;
            }

            rc = SceJetJetErrorToSceStatus(JetErr);

            break;

        case SCEJET_OPEN_DUP:
            //
            // Open the database
            //
            rc = SceJetOpenFile(
                    ProfileFileName,
                    SCEJET_OPEN_READ_WRITE,
                    dwTableOptions,
                    cxtProfile
                    );
            goto Done;
            break;

        case SCEJET_OPEN_DUP_EXCLUSIVE:
            //
            // Open the database
            //
            rc = SceJetOpenFile(
                    ProfileFileName,
                    SCEJET_OPEN_EXCLUSIVE,
                    dwTableOptions,
                    cxtProfile
                    );
            goto Done;
            break;
        }
    }

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;
#ifdef SCEJET_DBG
    printf("Create/Open database\n");
#endif

    //
    // create required tables - SmTblVersion
    //

    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblVersion",
                    SCEJET_TABLE_VERSION,
                    SCEJET_CREATE_IN_BUFFER,
                    &TableID,
                    &ColumnID
                    );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    //
    // insert one record into the version table
    //
    JetErr = JetPrepareUpdate((*cxtProfile)->JetSessionID,
                              TableID,
                              JET_prepInsert
                              );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // set value "1.2" in "Version" column
        //

        JetErr = JetSetColumn(
                        (*cxtProfile)->JetSessionID,
                        TableID,
                        ColumnID,
                        (void *)&Version,
                        4,
                        0, //JET_bitSetOverwriteLV,
                        NULL
                        );

        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc != SCESTATUS_SUCCESS ) {
            //
            // if setting fails, cancel the prepared record
            //
            JetPrepareUpdate( (*cxtProfile)->JetSessionID,
                              TableID,
                              JET_prepCancel
                              );
        } else {

            //
            // Setting columns succeed. Update the record
            //
            JetErr = JetUpdate( (*cxtProfile)->JetSessionID,
                               TableID,
                               NULL,
                               0,
                               &Len
                               );
            rc = SceJetJetErrorToSceStatus(JetErr);
        }
    }

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

#ifdef SCEJET_DBG
    printf("create version table\n");
#endif
    //
    // create section table and insert pre-defined sections
    //
    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblSection",
                    SCEJET_TABLE_SECTION,
                    SCEJET_CREATE_IN_BUFFER,
                    NULL,
                    NULL
                    );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

#ifdef SCEJET_DBG
    printf("create section table\n");
#endif

    rc = SceJetpAddAllSections(
                *cxtProfile
                );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

#ifdef SCEJET_DBG
    printf("add sections\n");
#endif


    //
    // create scp table
    //
    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblScp",
                    SCEJET_TABLE_SCP,
                    SCEJET_CREATE_IN_BUFFER,
                    NULL,
                    NULL
                    );
#ifdef SCEJET_DBG
    printf("Create table scp %d\n", rc);
#endif
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    if ( dwTableOptions & SCE_TABLE_OPTION_MERGE_POLICY ) {
        (*cxtProfile)->Type |= SCEJET_MERGE_TABLE_1;
    } else {
        (*cxtProfile)->Type |= SCEJET_LOCAL_TABLE;
    }

    //
    // create scp table
    //
    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblSmp",
                    SCEJET_TABLE_SMP,
                    SCEJET_CREATE_IN_BUFFER,
                    NULL,
                    NULL
                    );
#ifdef SCEJET_DBG
    printf("Create table smp %d\n", rc);
#endif

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblScp2",
                    SCEJET_TABLE_SCP,
                    SCEJET_CREATE_NO_TABLEID,
                    NULL,
                    NULL
                    );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblGpo",
                    SCEJET_TABLE_GPO,
                    SCEJET_CREATE_NO_TABLEID,
                    NULL,
                    NULL
                    );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    if ( dwTableOptions & SCE_TABLE_OPTION_TATTOO ) {
        rc = SceJetCreateTable(
                        *cxtProfile,
                        "SmTblTattoo",
                        SCEJET_TABLE_TATTOO,
                        SCEJET_CREATE_IN_BUFFER,
                        NULL,
                        NULL
                        );
    }

Done:

    //
    // clearn up if error out
    //
    if ( rc != SCESTATUS_SUCCESS ) {

        SceJetCloseFile(
                *cxtProfile,
                FALSE,
                FALSE
                );
        if ( FreeContext == TRUE ) {
            if ( (*cxtProfile)->JetSessionID != JET_sesidNil ) {
                JetEndSession(
                    (*cxtProfile)->JetSessionID,
                    JET_bitForceSessionClosed
                    );
            }
            LocalFree(*cxtProfile);
            *cxtProfile = NULL;
        }
    }

    return(rc);

}


SCESTATUS
SceJetCloseFile(
    IN PSCECONTEXT   hProfile,
    IN BOOL         TermSession,
    IN BOOL         Terminate
    )
/* ++
Routine Description:

    This routine closes a context handle, which closes all tables opened in
    the database and then closes the database.

    Terminate parameter is ignored and Jet engine is not stoppped when this parameter
    is set to TRUE, because there might be other clients using Jet and Jet writer is
    dependent on it.

Arguments:

    hProfile    - The context handle

    Terminate   - TRUE = Terminate the Jet session and engine.

Return value:

    SCESTATUS_SUCCESS

-- */
{

    JET_ERR     JetErr;


    if ( hProfile == NULL )
        goto Terminate;

    CHAR szDbName[1025];

    //
    // Close SCP table if it is opened
    //
    if ( (hProfile->JetScpID != JET_tableidNil) ) {

        if ( hProfile->JetScpID != hProfile->JetSmpID ) {
            JetErr = JetCloseTable(
                        hProfile->JetSessionID,
                        hProfile->JetScpID
                        );
        }
        hProfile->JetScpID = JET_tableidNil;
    }
    //
    // Close SAP table if it is opened
    //
    if ( hProfile->JetSapID != JET_tableidNil ) {
        JetErr = JetCloseTable(
                    hProfile->JetSessionID,
                    hProfile->JetSapID
                    );
        hProfile->JetSapID = JET_tableidNil;
    }
    //
    // Close SMP table if it is opened
    //
    if ( hProfile->JetSmpID != JET_tableidNil ) {
        JetErr = JetCloseTable(
                    hProfile->JetSessionID,
                    hProfile->JetSmpID
                    );
        hProfile->JetSmpID = JET_tableidNil;
    }

    //
    // get database name
    // do not care if there is error
    //
    szDbName[0] = '\0';
    szDbName[1024] = '\0';

    if ( hProfile->JetDbID != JET_dbidNil ) {

        JetGetDatabaseInfo(hProfile->JetSessionID,
                           hProfile->JetDbID,
                           (void *)szDbName,
                           1024,
                           JET_DbInfoFilename
                           );

        //
        // Close the database
        //
        JetErr = JetCloseDatabase(
                        hProfile->JetSessionID,
                        hProfile->JetDbID,
                        0
                        );
        hProfile->JetDbID = JET_dbidNil;

        //
        // should detach the database if the database name is not NULL
        // the database is always attached when it's to open
        // do not care error
        //
        if ( szDbName[0] != '\0' ) {
            JetDetachDatabase(hProfile->JetSessionID, szDbName);
        }
    }

    if ( TermSession || Terminate ) {
        if ( hProfile->JetSessionID != JET_sesidNil ) {

            JetEndSession(
                hProfile->JetSessionID,
                JET_bitForceSessionClosed
                );
            hProfile->JetSessionID = JET_sesidNil;
        }

        hProfile->Type = 0;

        LocalFree(hProfile);
    }

Terminate:

/*
    if ( Terminate ) {

        JetTerm(JetInstance);
        JetInstance = 0;
        JetInited = FALSE;

    }
*/
    return(SCESTATUS_SUCCESS);

}


//
// Code to handle sections
//

SCESTATUS
SceJetOpenSection(
    IN PSCECONTEXT   hProfile,
    IN DOUBLE        SectionID,
    IN SCEJET_TABLE_TYPE        tblType,
    OUT PSCESECTION   *hSection
    )
/* ++
Routine Description:

    This routine saves table and section information in the section context
    handle for other section API's use. SCP, SAP, and SMP tables have the
    same section names. The table type indicates which table this section is
    in.

    The section context handle must be freed by LocalFree after its use.

Arguments:

    hProfile    - The profile context handle

    SectionID   - ID of the section to open

    tblType     - The type of the table for this section
                        SCEJET_TABLE_SCP
                        SCEJET_TABLE_SAP
                        SCEJET_TABLE_SMP

    hSection    - The seciton context handle

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_NOT_ENOUGH_RESOURCE

-- */
{
    if ( hProfile == NULL ||
         hSection == NULL ||
         SectionID == (DOUBLE)0 ||
         (tblType != SCEJET_TABLE_SCP &&
          tblType != SCEJET_TABLE_SAP &&
          tblType != SCEJET_TABLE_SMP &&
          tblType != SCEJET_TABLE_TATTOO) )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( hProfile->JetSessionID == JET_sesidNil ||
         hProfile->JetDbID == JET_dbidNil ||
         (tblType == SCEJET_TABLE_SCP && hProfile->JetScpID == JET_tableidNil ) ||
         (tblType == SCEJET_TABLE_SMP && hProfile->JetSmpID == JET_tableidNil ) ||
         (tblType == SCEJET_TABLE_SAP && hProfile->JetSapID == JET_tableidNil ) ||
         (tblType == SCEJET_TABLE_TATTOO && hProfile->JetSapID == JET_tableidNil ) )
        return(SCESTATUS_BAD_FORMAT);


    if ( *hSection == NULL ) {
        //
        // Allocate memory
        //
        *hSection = (PSCESECTION)LocalAlloc( (UINT)0, sizeof(SCESECTION));
        if ( *hSection == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
    }

    (*hSection)->SectionID = SectionID;

    //
    // assign other info to the section context
    //
    (*hSection)->JetSessionID = hProfile->JetSessionID;
    (*hSection)->JetDbID = hProfile->JetDbID;

    switch (tblType) {
    case SCEJET_TABLE_SCP:
        (*hSection)->JetTableID = hProfile->JetScpID;
        (*hSection)->JetColumnSectionID = hProfile->JetScpSectionID;
        (*hSection)->JetColumnNameID = hProfile->JetScpNameID;
        (*hSection)->JetColumnValueID = hProfile->JetScpValueID;
        (*hSection)->JetColumnGpoID = hProfile->JetScpGpoID;
        break;
    case SCEJET_TABLE_SAP:
    case SCEJET_TABLE_TATTOO:
        (*hSection)->JetTableID = hProfile->JetSapID;
        (*hSection)->JetColumnSectionID = hProfile->JetSapSectionID;
        (*hSection)->JetColumnNameID = hProfile->JetSapNameID;
        (*hSection)->JetColumnValueID = hProfile->JetSapValueID;
        (*hSection)->JetColumnGpoID = 0;
        break;
    default:
        (*hSection)->JetTableID = hProfile->JetSmpID;
        (*hSection)->JetColumnSectionID = hProfile->JetSmpSectionID;
        (*hSection)->JetColumnNameID = hProfile->JetSmpNameID;
        (*hSection)->JetColumnValueID = hProfile->JetSmpValueID;
        (*hSection)->JetColumnGpoID = 0;
        break;
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
SceJetGetLineCount(
    IN PSCESECTION hSection,
    IN PWSTR      LinePrefix OPTIONAL,
    IN BOOL       bExactCase,
    OUT DWORD      *Count
    )
/* ++
Fucntion Description:

    This routine counts the number of lines matching the LinePrefix (Key)
    in the section. If LinePrefix is NULL, all lines is counted.

Arguments:

    hSection    - The context handle for the section.

    LinePrefix  - The whole or partial key to match. If NULL, all lines in the
                    section is counted.

    Count       - The output count.

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_OTHER_ERROR

-- */
{
    SCESTATUS    rc;
    JET_ERR     JetErr;
    DWORD       Len;
    INT         Result=0;
    SCEJET_SEEK_FLAG  SeekFlag;


    if ( hSection == NULL || Count == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // initialize
    //
    *Count = 0;

    if ( LinePrefix == NULL ) {
        Len = 0;
        SeekFlag = SCEJET_SEEK_GE;
    } else {
        Len = wcslen(LinePrefix)*sizeof(WCHAR);

        if ( bExactCase )
            SeekFlag = SCEJET_SEEK_GE;
        else
            SeekFlag = SCEJET_SEEK_GE_NO_CASE;
    }

    //
    // seek the first occurance
    //

    rc = SceJetSeek(
                hSection,
                LinePrefix,
                Len,
                SeekFlag
                );

    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
        // no matching record is found
        return(SCESTATUS_SUCCESS);
    }

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // Find the record or the next record
        // Define the upper index range
        //
        if ( Len <= 247 ) {

            JetErr = SceJetpBuildUpperLimit(
                            hSection,
                            LinePrefix,
                            Len,
                            bExactCase
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);
            if ( rc != SCESTATUS_SUCCESS )
                return(rc);

            //
            // count from the current position to the end of the range
            //
            JetErr = JetIndexRecordCount(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            (unsigned long *)Count,
                            (unsigned long)0xFFFFFFFF   // maximal count
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);

            //
            // reset the index range. don't care the error code returned
            //
            JetErr = JetSetIndexRange(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            JET_bitRangeRemove
                            );

        } else {
            //
            // Prefix is longer than 247. The index built does not contan all info
            // loop through each record to count
            //
            do {
                // current record is the same.
                *Count = *Count + 1;
                //
                // move to next record
                //
                JetErr = JetMove(hSection->JetSessionID,
                                 hSection->JetTableID,
                                 JET_MoveNext,
                                 0
                                 );
                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( rc == SCESTATUS_SUCCESS ) {
                    // check the record

                    JetErr = SceJetpCompareLine(
                                    hSection,
                                    JET_bitSeekGE,
                                    LinePrefix,
                                    Len,
                                    &Result,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);
                }

            } while ( rc == SCESTATUS_SUCCESS && Result == 0 );
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
            rc = SCESTATUS_SUCCESS;

    }

    return(rc);
}



SCESTATUS
SceJetDelete(
    IN PSCESECTION  hSection,
    IN PWSTR       LinePrefix,
    IN BOOL        bObjectFolder,
    IN SCEJET_DELETE_TYPE    Flags
    )
/* ++
Fucntion Description:

    This routine deletes the current record, prefix records, or the whole
    section, depending on the Flags.

Arguments:

    hSection    - The context handle of the section

    LinePrefix  - The prefix to start with for the deleted lines. This value
                  is only used when Flags is set to SCEJET_DELETE_PARTIAL

    Flags       - Options
                    SCEJET_DELETE_SECTION
                    SCEJET_DELETE_LINE
                    SCEJET_DELETE_PARTIAL

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_ACCESS_DEINED
    SCESTATUS_RECORD_NOT_FOUND
    SCESTATUS_OTHER_ERROR

-- */
{
    JET_ERR     JetErr;
    SCESTATUS    rc;
    INT         Result = 0;
    PWSTR       TempPrefix=NULL;
    DWORD       Len;
    SCEJET_SEEK_FLAG  SeekFlag;
    PWSTR  NewPrefix=NULL;
    DOUBLE      SectionID;
    DWORD       Actual;


    if ( hSection == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( Flags == SCEJET_DELETE_PARTIAL ||
         Flags == SCEJET_DELETE_PARTIAL_NO_CASE ) {

        if ( LinePrefix == NULL )
            return(SCESTATUS_INVALID_PARAMETER);

        Len = wcslen(LinePrefix);
        //
        // delete this node exact match first
        //
        if ( Flags == SCEJET_DELETE_PARTIAL )
            SeekFlag = SCEJET_SEEK_EQ;
        else
            SeekFlag = SCEJET_SEEK_EQ_NO_CASE;

        rc = SceJetSeek(hSection,
                        LinePrefix,
                        Len*sizeof(WCHAR),
                        SeekFlag
                        );

        if ( rc == SCESTATUS_SUCCESS ) {
            JetErr = JetDelete(hSection->JetSessionID, hSection->JetTableID);
            rc = SceJetJetErrorToSceStatus(JetErr);
        }

        if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
            rc = SCESTATUS_SUCCESS;
        }

        if ( rc == SCESTATUS_SUCCESS ) {

            if ( bObjectFolder &&
                 LinePrefix[Len-1] != L'\\' ) {

                Len++;
                NewPrefix = (PWSTR)ScepAlloc(0, (Len+1)*sizeof(WCHAR));

                if ( NewPrefix == NULL ) {
                    return(SCESTATUS_NOT_ENOUGH_RESOURCE);
                }
                wcscpy(NewPrefix, LinePrefix);
                wcscat(NewPrefix, L"\\");
            }

        } else {
            return(rc);
        }

        Len = Len*sizeof(WCHAR);

    }

    if ( Flags == SCEJET_DELETE_LINE ||
         Flags == SCEJET_DELETE_LINE_NO_CASE ) {
        if ( LinePrefix == NULL ) {
            //
            // delete current line
            // check the current's sectionID before deleting
            //

            rc = SceJetJetErrorToSceStatus(JetRetrieveColumn(
                                                    hSection->JetSessionID,
                                                    hSection->JetTableID,
                                                    hSection->JetColumnSectionID,
                                                    (void *)&SectionID,
                                                    8,
                                                    &Actual,
                                                    0,
                                                    NULL
                                                    ));


            if (rc == SCESTATUS_SUCCESS && hSection->SectionID != SectionID)
                rc = SCESTATUS_RECORD_NOT_FOUND;

            if (rc == SCESTATUS_SUCCESS) {
                JetErr = JetDelete(hSection->JetSessionID, hSection->JetTableID);
                rc = SceJetJetErrorToSceStatus(JetErr);
            }

        } else {
            if ( Flags == SCEJET_DELETE_LINE )
                SeekFlag = SCEJET_SEEK_EQ;
            else
                SeekFlag = SCEJET_SEEK_EQ_NO_CASE;

            rc = SceJetSeek(hSection,
                               LinePrefix,
                               wcslen(LinePrefix)*sizeof(WCHAR),
                               SeekFlag
                               );
            if ( rc == SCESTATUS_SUCCESS ) {
                JetErr = JetDelete(hSection->JetSessionID, hSection->JetTableID);
                rc = SceJetJetErrorToSceStatus(JetErr);
            }

        }

        return(rc);
    }

    if ( Flags == SCEJET_DELETE_SECTION ||
         Flags == SCEJET_DELETE_PARTIAL ||
         Flags == SCEJET_DELETE_PARTIAL_NO_CASE ) {

        if ( Flags == SCEJET_DELETE_SECTION ) {
             //
            // delete the whole section
            // seek the first line of the section
            //
            TempPrefix = NULL;
            Len = 0;
            SeekFlag = SCEJET_SEEK_GE;
        } else {
            //
            // delete all lines begin with the prefix
            // seek the first line of the prefix
            //
            if ( NewPrefix ) {
                TempPrefix = NewPrefix;
            } else {
                TempPrefix = LinePrefix;
            }
            if ( Flags == SCEJET_DELETE_PARTIAL_NO_CASE )
                SeekFlag = SCEJET_SEEK_GE_NO_CASE;
            else
                SeekFlag = SCEJET_SEEK_GE;
        }

        rc = SceJetSeek(hSection, TempPrefix, Len, SeekFlag);

        if ( rc != SCESTATUS_SUCCESS ) {
            if ( NewPrefix ) {
                ScepFree(NewPrefix);
            }
            return(rc);
        }

        do {

            //
            // delete current line
            //
            JetErr = JetDelete(hSection->JetSessionID, hSection->JetTableID);
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc != SCESTATUS_SUCCESS )
                break;

            //
            // move cursor to next line
            //
            JetErr = JetMove(hSection->JetSessionID,
                             hSection->JetTableID,
                             JET_MoveNext,
                             0
                             );
            if ( JetErr == JET_errSuccess ) {
                //
                // compare section ID
                //
                JetErr = SceJetpCompareLine(
                                hSection,
                                JET_bitSeekGE,
                                TempPrefix,
                                Len,
                                &Result,
                                NULL
                                );

                if ( JetErr == JET_errSuccess && Result != 0 )
                    JetErr = JET_errRecordNotFound;

            }

            if ( JetErr == JET_errRecordDeleted ) {
                //
                // skip the deleted record
                //
                JetErr = JET_errSuccess;
                Result = 0;
            }
            rc = SceJetJetErrorToSceStatus(JetErr);


        } while ( rc == SCESTATUS_SUCCESS && Result == 0 );

        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
            rc = SCESTATUS_SUCCESS;

        if ( NewPrefix ) {
            ScepFree(NewPrefix);
        }

        return(rc);
    }

    return(SCESTATUS_SUCCESS);
}

SCESTATUS
SceJetDeleteAll(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TblName OPTIONAL,
    IN SCEJET_TABLE_TYPE  TblType
    )
/* ++
Fucntion Description:

    This routine deletes everything in the table (specified by name or by type)

Arguments:

    cxtProfile  - The context handle of the database

    TblName     - optional table name to delete (if not to use the table id in context)

    TblType     - specify the table type to use the table id in context, ignored
                    if TblName is specified.

Return Value:

-- */
{
    JET_ERR     JetErr;
    SCESTATUS    rc;

    JET_TABLEID     tmpTblID;

    if ( cxtProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( TblName ) {

        JetErr = JetOpenTable(
                        cxtProfile->JetSessionID,
                        cxtProfile->JetDbID,
                        TblName,
                        NULL,
                        0,
                        0,
                        &tmpTblID
                        );
        if ( JET_errSuccess != JetErr ) {
            return(SceJetJetErrorToSceStatus(JetErr));
        }

    } else {

        switch ( TblType ) {
        case SCEJET_TABLE_SCP:
            tmpTblID = cxtProfile->JetScpID;
            break;
        case SCEJET_TABLE_SMP:
            tmpTblID = cxtProfile->JetSmpID;
            break;
        case SCEJET_TABLE_SAP:
        case SCEJET_TABLE_TATTOO:
            tmpTblID = cxtProfile->JetSapID;
            break;
        case SCEJET_TABLE_SECTION:
            tmpTblID = cxtProfile->JetTblSecID;
            break;
        default:
            return(SCESTATUS_INVALID_PARAMETER);
        }
    }

    //
    // move cursor to next line
    //
    JetErr = JetMove(cxtProfile->JetSessionID,
                     tmpTblID,
                     JET_MoveFirst,
                     0
                     );

    while ( JET_errSuccess == JetErr ) {

        //
        // delete current line
        //
        JetErr = JetDelete(cxtProfile->JetSessionID, tmpTblID);

        //
        // move cursor to next line
        //
        JetErr = JetMove(cxtProfile->JetSessionID,
                         tmpTblID,
                         JET_MoveNext,
                         0
                         );

    }

    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

    if ( TblName ) {
        JetCloseTable(cxtProfile->JetSessionID, tmpTblID);
    }

    return(rc);
}


SCESTATUS
SceJetCloseSection(
    IN PSCESECTION   *hSection,
    IN BOOL         DestroySection
    )
/* ++
Fucntion Description:

    Closes a section context handle.

Arguments:

    hSection    - The section context handle to close

Return Value:

    SCE_SUCCESS

-- */
{
    if ( hSection == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( *hSection != NULL ) {
        (*hSection)->JetColumnSectionID = 0;
        (*hSection)->JetColumnNameID = 0;
        (*hSection)->JetColumnValueID = 0;

        (*hSection)->SectionID = (DOUBLE)0;

        if ( DestroySection ) {
            ScepFree(*hSection);
            *hSection = NULL;
        }

    }

    return(SCESTATUS_SUCCESS);
}


//
// Code to handle line
//
SCESTATUS
SceJetGetValue(
    IN PSCESECTION hSection,
    IN SCEJET_FIND_TYPE    Flags,
    IN PWSTR      LinePrefix OPTIONAL,
    IN PWSTR      ActualName  OPTIONAL,
    IN DWORD      NameBufLen,
    OUT DWORD      *RetNameLen OPTIONAL,
    IN PWSTR      Value       OPTIONAL,
    IN DWORD      ValueBufLen,
    OUT DWORD      *RetValueLen OPTIONAL
    )
/* ++
Fucntion Description:

    This routine retrieves a line from the opened section or close the
    previous search context. When Flag is SCEJET_EXACT_MATCH, this routine
    returns the exact matched line for LinePrefix (LinePrefix can't be NULL).
    If this routine is used to get multiple lines, a SCEJET_PREFIX_MATCH
    must be used for the Flags when the first time it is called. If LinePrefix
    is NULL, the first line in the section is returned; otherwise, the first
    line matching the prefix is returned. When continous call is made for the
    same prefix, use SCEJET_NEXT_LINE for the Flags. LinePrefix is not used
    for continous calls. When finish with the continuous calls, a
    SCEJET_CLOSE_VALUE must be used to close the search handle context.

    ActualName and Value contains the actual name and value stored in the
    database for the current line. If these two buffers are not big enough,
    an error will return SCE_BUFFER_TOO_SMALL.

    Passing NULL for ActualName or Value will return the required length for
    that buffer if the RetLength buffer is not NULL.

Arguments:

    hSection    - The context handle of the section

    LinePrefix  - The prefix for the line to start with. This is used only
                    when Flags is set to SCEJET_PREFIX_MATCH

    Flags       - Options for the operation
                    SCEJET_EXACT_MATCH
                    SCEJET_PREFIX_MATCH
                    SCEJET_NEXT_LINE
                    SCEJET_CLOSE_VALUE
                    SCEJET_CURRENT              -- get current record's value

    ActualName  - The buffer for column "Name"

    NameBufLen  - The buffer length of ActualName

    RetNameLen  - the required buffer length for "Name" column

    Value       - The buffer for column "Value"

    ValueBufLen - The buffer length of Value

    RetValueLen - The required buffer length for "Value" column


Return Value:

    SCESTATUS_SUCCESS if success
    SCESTATUS_RECORD_NOT_FOUND if no more match
    other errors:
        SCESTATUS_INVALID_PARAMETER
        SCESTATUS_BUFFER_TOO_SMALL
        SCESTATUS_OTHER_ERROR


-- */
{
    JET_ERR         JetErr;
    SCESTATUS        rc=SCESTATUS_SUCCESS;
    SCESTATUS        rc1;
    DWORD           Len=0;

    JET_RETINFO     RetInfo;
    WCHAR           Buffer[128];
    PVOID           pTemp=NULL;
    INT             Result=0;
    SCEJET_SEEK_FLAG   SeekFlag=SCEJET_SEEK_GT;


    if ( hSection == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( Flags == SCEJET_CLOSE_VALUE ) {
        //
        // close the index range
        //
        if ( FindContext.Length > 0 ) {
            memset(FindContext.Prefix, '\0', FindContext.Length);
            FindContext.Length = 0;
        }

        JetErr = JetSetIndexRange(
                     hSection->JetSessionID,
                     hSection->JetTableID,
                     JET_bitRangeRemove
                     );
        if ( JetErr != JET_errSuccess &&
             JetErr != JET_errKeyNotMade &&
             JetErr != JET_errNoCurrentRecord ) {

            return(SceJetJetErrorToSceStatus(JetErr));
        }
        return(SCESTATUS_SUCCESS);
    }

    //
    // when name/value is requested (not NULL), the return length buffer
    // cannot be NULL.
    // both return length buffer cannot be NULL at the same time
    //
    if ( (ActualName != NULL && RetNameLen == NULL) ||
         (Value != NULL && RetValueLen == NULL) ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    switch ( Flags ) {

    case SCEJET_EXACT_MATCH:
    case SCEJET_EXACT_MATCH_NO_CASE:

        if ( LinePrefix == NULL )
            return(SCESTATUS_INVALID_PARAMETER);

        Len = wcslen(LinePrefix)*sizeof(WCHAR);

        if ( Flags == SCEJET_EXACT_MATCH )
            SeekFlag = SCEJET_SEEK_EQ;
        else
            SeekFlag = SCEJET_SEEK_EQ_NO_CASE;

        rc = SceJetSeek(
                    hSection,
                    LinePrefix,
                    Len,
                    SeekFlag
                    );
        break;


    case SCEJET_PREFIX_MATCH:
    case SCEJET_PREFIX_MATCH_NO_CASE:

        if ( LinePrefix != NULL ) {
            Len = wcslen(LinePrefix)*sizeof(WCHAR);

            if ( Len > SCEJET_PREFIX_MAXLEN )
                return(SCESTATUS_PREFIX_OVERFLOW);

        } else {
            Len = 0;
        }

        if ( Flags == SCEJET_PREFIX_MATCH )
            SeekFlag = SCEJET_SEEK_GE;
        else
            SeekFlag = SCEJET_SEEK_GE_NO_CASE;

        rc = SceJetSeek(
                        hSection,
                        LinePrefix,
                        Len,
                        SeekFlag
                        );

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // remember the find context
            //
            if ( Len > 247 ) {

                //
                // in reality JET doesn't allow keys of more than 255 bytes
                //
                wcsncpy(FindContext.Prefix, LinePrefix, SCEJET_PREFIX_MAXLEN-2);

                if ( Flags == SCEJET_PREFIX_MATCH_NO_CASE )
                    _wcslwr(FindContext.Prefix);

                FindContext.Length = Len;
            }
            //
            // set the upper range limit
            //
            JetErr = SceJetpBuildUpperLimit(
                        hSection,
                        LinePrefix,
                        Len,
                        (Flags == SCEJET_PREFIX_MATCH)
                        );
            rc = SceJetJetErrorToSceStatus(JetErr);
        }
        break;

    case SCEJET_NEXT_LINE:
        //
        // Move to next line
        //
        JetErr = JetMove(hSection->JetSessionID,
                        hSection->JetTableID,
                        JET_MoveNext,
                        0);
        //
        // compare to the prefix
        //
        if ( JetErr == JET_errSuccess && FindContext.Length > 0 ) {

#ifdef SCEJET_DBG
            printf("NextLine: Length is greater than 247\n");
#endif
            JetErr = SceJetpCompareLine(
                            hSection,
                            JET_bitSeekGE,
                            FindContext.Prefix,
                            FindContext.Length,
                            &Result,
                            NULL
                            );
            if ( JetErr == JET_errSuccess && Result != 0 )
                JetErr = JET_errRecordNotFound;

        }
        rc = SceJetJetErrorToSceStatus(JetErr);
        break;

    default:
        //
        // Everything else passed in is treated as the current line
        //
        rc = SCESTATUS_SUCCESS;
        break;
    }

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // Get this line's value
    //
    RetInfo.ibLongValue = 0;
    RetInfo.itagSequence = 1;
    RetInfo.cbStruct = sizeof(JET_RETINFO);

    if ( ActualName != NULL || RetNameLen != NULL ) {
        //
        // get name field (long binary)
        // if ActualName is NULL, then get the actual bytes
        //
        if ( ActualName != NULL ) {
            Len = NameBufLen;
            pTemp = (void *)ActualName;
        } else {
            Len = 256;
            pTemp = (void *)Buffer;
        }

        JetErr = JetRetrieveColumn(
                        hSection->JetSessionID,
                        hSection->JetTableID,
                        hSection->JetColumnNameID,
                        pTemp,
                        Len,
                        RetNameLen,
                        0,
                        &RetInfo
                        );
#ifdef SCEJET_DBG
        printf("\tJetErr=%d, Len=%d, RetNameLen=%d\n", JetErr, Len, *RetNameLen);
#endif
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_BUFFER_TOO_SMALL ) {
            //
            // if only length is requested, don't care buffer_too_small
            //
            if ( ActualName == NULL )
                rc = SCESTATUS_SUCCESS;
        }

        if ( rc != SCESTATUS_SUCCESS &&
             rc != SCESTATUS_BUFFER_TOO_SMALL )
            return(rc);
    }

    if ( Value != NULL || RetValueLen != NULL ) {
        //
        // Get value field
        // if Value is NULL, then get the actual bytes
        //

        if ( Value != NULL ) {
            Len = ValueBufLen;
            pTemp = (PVOID)Value;
        } else {
            Len = 256;
            pTemp = (PVOID)Buffer;
        }

        JetErr = JetRetrieveColumn(
                        hSection->JetSessionID,
                        hSection->JetTableID,
                        hSection->JetColumnValueID,
                        pTemp,
                        Len,
                        RetValueLen,
                        0,
                        &RetInfo
                        );
#ifdef SCEJET_DBG
        printf("\tJetErr=%d, Len=%d, RetValueLen=%d\n", JetErr, Len, *RetValueLen);
#endif
        rc1 = SceJetJetErrorToSceStatus(JetErr);

        if ( rc1 == SCESTATUS_BUFFER_TOO_SMALL ) {
            //
            // if only length is requested, don't care buffer_too_small
            //
            if ( Value == NULL )
                rc1 = SCESTATUS_SUCCESS;
        }

        if ( rc1 != SCESTATUS_SUCCESS &&
             rc1 != SCESTATUS_BUFFER_TOO_SMALL )
            return(rc1);

        //
        // rc is the status from retrieving Name field
        //
        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
        else
            return(rc1);
    }

    return(rc);
}


SCESTATUS
SceJetSetLine(
    IN PSCESECTION hSection,
    IN PWSTR      Name,
    IN BOOL       bReserveCase,
    IN PWSTR      Value,
    IN DWORD      ValueLen,
    IN LONG       GpoID
    )
/* ++
Fucntion Description:

    This routine writes the Name and Value to the section (hSection).
    If a exact matched name is found, overwrite, else insert a new
    record.

Arguments:

    hSection    - The context handle of the section

    Name        - The info set to Column "Name"

    Value       - The info set to Column "Value"

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_OTHER_ERROR
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_DATA_OVERFLOW

-- */
{
    JET_ERR     JetErr;
    DWORD       Len;
    SCESTATUS    rc;
    DWORD       prep;
    JET_SETINFO SetInfo;
    PWSTR       LwrName=NULL;

    if ( hSection == NULL ||
         Name == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    Len = wcslen(Name)*sizeof(WCHAR);

    if ( Len <= 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( bReserveCase ) {
        LwrName = Name;

    } else {
        //
        // lower cased
        //
        LwrName = (PWSTR)ScepAlloc(0, Len+2);
        if ( LwrName == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
        wcscpy(LwrName, Name);
        LwrName = _wcslwr(LwrName);

    }

    SetInfo.cbStruct = sizeof(JET_SETINFO);
    SetInfo.itagSequence = 1;
    SetInfo.ibLongValue = 0;

    //
    // check to see if the same key name already exists
    //
    JetErr = SceJetpSeek(
                    hSection,
                    LwrName,
                    Len,
                    SCEJET_SEEK_EQ,
                    FALSE
                    );

    if ( JetErr == JET_errSuccess ||
         JetErr == JET_errRecordNotFound ) {
        if ( JetErr == JET_errSuccess )
            // find a match. overwrite the value
            prep = JET_prepReplace;
        else
            // no match. prepare the record for insertion
            prep = JET_prepInsert;

        JetErr = JetBeginTransaction(hSection->JetSessionID);

        if ( JetErr == JET_errSuccess ) {
            JetErr = JetPrepareUpdate(hSection->JetSessionID,
                                      hSection->JetTableID,
                                      prep
                                      );
            if ( JetErr != JET_errSuccess ) {
                //
                // rollback the transaction
                //
                JetRollback(hSection->JetSessionID,0);
            }
        }
    }

    if ( JetErr != JET_errSuccess)
        return(SceJetJetErrorToSceStatus(JetErr));


    if ( prep == JET_prepInsert ) {
        //
        // set the sectionID column
        //
        JetErr = JetSetColumn(
                        hSection->JetSessionID,
                        hSection->JetTableID,
                        hSection->JetColumnSectionID,
                        (void *)&(hSection->SectionID),
                        8,
                        0, //JET_bitSetOverwriteLV,
                        NULL
                        );
        if ( JetErr == JET_errSuccess ) {
            //
            // set the new key in "Name" column
            //
            JetErr = JetSetColumn(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            hSection->JetColumnNameID,
                            (void *)LwrName,
                            Len,
                            0, //JET_bitSetOverwriteLV,
                            &SetInfo
                            );
        }

    }

    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // set value column
        //

        JetErr = JetSetColumn(
                        hSection->JetSessionID,
                        hSection->JetTableID,
                        hSection->JetColumnValueID,
                        (void *)Value,
                        ValueLen,
                        0, //JET_bitSetOverwriteLV,
                        &SetInfo
                        );
        if ( JetErr == JET_errSuccess ) {
            //
            // if GPO ID is provided and there is a GPOID column, set it
            //
            if ( GpoID > 0 && hSection->JetColumnGpoID > 0 ) {

                JetErr = JetSetColumn(
                                hSection->JetSessionID,
                                hSection->JetTableID,
                                hSection->JetColumnGpoID,
                                (void *)&GpoID,
                                sizeof(LONG),
                                0,
                                NULL
                                );
                if ( JET_errColumnNotUpdatable == JetErr ) {
                    JetErr = JET_errSuccess;
                }
            }
            // else
            // if can't find the column, ignore the error
            //

            if ( JET_errSuccess == JetErr ) {

                //
                // Setting columns succeed. Update the record
                //
                JetErr = JetUpdate(hSection->JetSessionID,
                                   hSection->JetTableID,
                                   NULL,
                                   0,
                                   &Len
                                   );

            }

        }
        rc = SceJetJetErrorToSceStatus(JetErr);

    }

    if ( rc == SCESTATUS_SUCCESS )
        JetCommitTransaction(hSection->JetSessionID, JET_bitCommitLazyFlush);

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // if setting fails, cancel the prepared record
        //
        JetPrepareUpdate(hSection->JetSessionID,
                          hSection->JetTableID,
                          JET_prepCancel
                          );
        //
        // Rollback the transaction
        //
        JetRollback(hSection->JetSessionID,0);

    }

    if ( LwrName != Name ) {
        ScepFree(LwrName);
    }

    return(rc);

}


//
// Exported helper APIs
//
SCESTATUS
SceJetCreateTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType,
    IN SCEJET_CREATE_FLAG nFlags,
    OUT JET_TABLEID *TableID OPTIONAL,
    OUT JET_COLUMNID *ColumnID OPTIONAL
    )
/* ++
Routine Description:

    This routine creates a table in the database opened in the context handle.
    SCP/SAP/SMP tables created in the database have 3 columns: Section, Name,
    and Value, with one index "SectionKey" which is Section+Name ascending.
    Version table has only one column "Version".

Arguments:

    cxtProfile  - The context handle

    tblName     - ASCII name of the table to create

    tblType     - The type of the table. It may be one of the following
                    SCEJET_TABLE_SCP
                    SCEJET_TABLE_SAP
                    SCEJET_TABLE_SMP
                    SCEJET_TABLE_VERSION
                    SCEJET_TABLE_SECTION
                    SCEJET_TABLE_TATTOO
                    SCEJET_TABLE_GPO

    TableID     - SmTblVersion table id when tblType = SCEJET_TABLE_VERSION.

    ColumnID    - The column ID for Version when tblType = SCEJET_TABLE_VERSION

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_OBJECT_EXIST
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR


-- */
{
    JET_ERR             JetErr;
    SCESTATUS            rc;
    JET_TABLECREATE     TableCreate;
    JET_COLUMNCREATE    ColumnCreate[5];
    JET_INDEXCREATE     IndexCreate[2];
    DWORD               numColumns;


    if ( cxtProfile == NULL || tblName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( TableID ) {
        *TableID = JET_tableidNil;
    }

    if ( ColumnID ) {
        *ColumnID = 0;
    }

    switch ( tblType ) {
    case SCEJET_TABLE_VERSION:

        if ( TableID == NULL || ColumnID == NULL )
            return(SCESTATUS_INVALID_PARAMETER);
        //
        // There is only one column in this table
        //
        ColumnCreate[0].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[0].szColumnName = "Version";
        ColumnCreate[0].coltyp = JET_coltypIEEESingle;
        ColumnCreate[0].cbMax = 4;
        ColumnCreate[0].grbit = JET_bitColumnNotNULL;
        ColumnCreate[0].pvDefault = NULL;
        ColumnCreate[0].cbDefault = 0;
        ColumnCreate[0].cp = 0;
        ColumnCreate[0].columnid = 0;

        ColumnCreate[1].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[1].szColumnName = "AnalyzeTimeStamp";
        ColumnCreate[1].coltyp = JET_coltypBinary;
        ColumnCreate[1].cbMax = 16; // should be 8 bytes - change later
        ColumnCreate[1].grbit = 0;
        ColumnCreate[1].pvDefault = NULL;
        ColumnCreate[1].cbDefault = 0;
        ColumnCreate[1].cp = 0;
        ColumnCreate[1].columnid = 0;

        ColumnCreate[2].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[2].szColumnName = "ConfigTimeStamp";
        ColumnCreate[2].coltyp = JET_coltypBinary;
        ColumnCreate[2].cbMax = 16; // should be 8 bytes - change later
        ColumnCreate[2].grbit = 0;
        ColumnCreate[2].pvDefault = NULL;
        ColumnCreate[2].cbDefault = 0;
        ColumnCreate[2].cp = 0;
        ColumnCreate[2].columnid = 0;

        ColumnCreate[3].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[3].szColumnName = "LastUsedMergeTable";
        ColumnCreate[3].coltyp = JET_coltypLong;
        ColumnCreate[3].cbMax = 4;
        ColumnCreate[3].grbit = 0;
        ColumnCreate[3].pvDefault = NULL;
        ColumnCreate[3].cbDefault = 0;
        ColumnCreate[3].cp = 0;
        ColumnCreate[3].columnid = 0;

        ColumnCreate[4].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[4].szColumnName = "ProfileDescription";
        ColumnCreate[4].coltyp = JET_coltypLongBinary;
        ColumnCreate[4].cbMax = 1024;
        ColumnCreate[4].grbit = 0;
        ColumnCreate[4].pvDefault = NULL;
        ColumnCreate[4].cbDefault = 0;
        ColumnCreate[4].cp = 0;
        ColumnCreate[4].columnid = 0;

        //
        // Assign table info
        //
        TableCreate.cbStruct = sizeof(JET_TABLECREATE);
        TableCreate.szTableName = tblName;
        TableCreate.szTemplateTableName = NULL;
        TableCreate.ulPages = 1;
        TableCreate.ulDensity = 90;
        TableCreate.rgcolumncreate = ColumnCreate;
        TableCreate.cColumns = 5;
        TableCreate.rgindexcreate = NULL;
        TableCreate.cIndexes = 0;
        TableCreate.grbit = 0;
        TableCreate.tableid = 0;

        break;

    case SCEJET_TABLE_SCP:
    case SCEJET_TABLE_SAP:
    case SCEJET_TABLE_SMP:
    case SCEJET_TABLE_TATTOO:

        //
        // There are 3 columns in each table.
        // Assign each column info
        //
        ColumnCreate[0].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[0].szColumnName = "SectionID";
        ColumnCreate[0].coltyp = JET_coltypIEEEDouble;
        ColumnCreate[0].cbMax = 8;
        ColumnCreate[0].grbit = JET_bitColumnNotNULL;
        ColumnCreate[0].pvDefault = NULL;
        ColumnCreate[0].cbDefault = 0;
        ColumnCreate[0].cp = 0;
        ColumnCreate[0].columnid = 0;

        ColumnCreate[1].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[1].szColumnName = "Name";
        ColumnCreate[1].coltyp = JET_coltypLongBinary;
        ColumnCreate[1].cbMax = 1024;
        ColumnCreate[1].grbit = 0;  //JET_bitColumnNotNULL;
        ColumnCreate[1].pvDefault = NULL;
        ColumnCreate[1].cbDefault = 0;
        ColumnCreate[1].cp = 0;
        ColumnCreate[1].columnid = 0;

        ColumnCreate[2].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[2].szColumnName = "Value";
        ColumnCreate[2].coltyp = JET_coltypLongBinary;
        ColumnCreate[2].cbMax = (unsigned long)0x7FFFFFFF;    // 2GB
        ColumnCreate[2].grbit = 0;
        ColumnCreate[2].pvDefault = NULL;
        ColumnCreate[2].cbDefault = 0;
        ColumnCreate[2].cp = 0;
        ColumnCreate[2].columnid = 0;

        numColumns = 3;

        if ( tblType == SCEJET_TABLE_SCP ) {

            ColumnCreate[3].cbStruct = sizeof(JET_COLUMNCREATE);
            ColumnCreate[3].szColumnName = "GpoID";
            ColumnCreate[3].coltyp = JET_coltypLong;
            ColumnCreate[3].cbMax = 4;
            ColumnCreate[3].grbit = 0;
            ColumnCreate[3].pvDefault = NULL;
            ColumnCreate[3].cbDefault = 0;
            ColumnCreate[3].cp = 0;
            ColumnCreate[3].columnid = 0;

            numColumns = 4;
        }

        //
        // Assign index info - one index in each table.
        //
        memset(IndexCreate, 0, sizeof(JET_INDEXCREATE) );
        IndexCreate[0].cbStruct = sizeof(JET_INDEXCREATE);
        IndexCreate[0].szIndexName = "SectionKey";
        IndexCreate[0].szKey = "+SectionID\0+Name\0\0";
        IndexCreate[0].cbKey = 18;
        IndexCreate[0].grbit = 0; // JET_bitIndexPrimary; // | JET_bitIndexUnique;
        IndexCreate[0].ulDensity = 50;
        //
        // Assign table info
        //
        TableCreate.cbStruct = sizeof(JET_TABLECREATE);
        TableCreate.szTableName = tblName;
        TableCreate.szTemplateTableName = NULL;
        TableCreate.ulPages = 20;
        TableCreate.ulDensity = 50;
        TableCreate.rgcolumncreate = ColumnCreate;
        TableCreate.cColumns = numColumns;
        TableCreate.rgindexcreate = IndexCreate;
        TableCreate.cIndexes = 1;
        TableCreate.grbit = 0;
        TableCreate.tableid = 0;

        break;

    case SCEJET_TABLE_SECTION:
        //
        // There are 2 columns in this table.
        // Assign each column info
        //
        ColumnCreate[0].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[0].szColumnName = "SectionID";
        ColumnCreate[0].coltyp = JET_coltypIEEEDouble;
        ColumnCreate[0].cbMax = 8;
        ColumnCreate[0].grbit = JET_bitColumnNotNULL;
        ColumnCreate[0].pvDefault = NULL;
        ColumnCreate[0].cbDefault = 0;
        ColumnCreate[0].cp = 0;
        ColumnCreate[0].columnid = 0;

        ColumnCreate[1].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[1].szColumnName = "Name";
        ColumnCreate[1].coltyp = JET_coltypBinary;
        ColumnCreate[1].cbMax = 255;
        ColumnCreate[1].grbit = JET_bitColumnNotNULL;
        ColumnCreate[1].pvDefault = NULL;
        ColumnCreate[1].cbDefault = 0;
        ColumnCreate[1].cp = 0;
        ColumnCreate[1].columnid = 0;

        //
        // Assign index info - one index in each table.
        //
        memset(IndexCreate, 0, 2*sizeof(JET_INDEXCREATE) );
        IndexCreate[0].cbStruct = sizeof(JET_INDEXCREATE);
        IndexCreate[0].szIndexName = "SectionKey";
        IndexCreate[0].szKey = "+Name\0\0";
        IndexCreate[0].cbKey = 7;
        IndexCreate[0].grbit = JET_bitIndexPrimary; // | JET_bitIndexUnique;
        IndexCreate[0].ulDensity = 80;

        IndexCreate[1].cbStruct = sizeof(JET_INDEXCREATE);
        IndexCreate[1].szIndexName = "SecID";
        IndexCreate[1].szKey = "+SectionID\0\0";
        IndexCreate[1].cbKey = 12;
        IndexCreate[1].grbit = 0;
        IndexCreate[1].ulDensity = 80;
        //
        // Assign table info
        //
        TableCreate.cbStruct = sizeof(JET_TABLECREATE);
        TableCreate.szTableName = tblName;
        TableCreate.szTemplateTableName = NULL;
        TableCreate.ulPages = 10;
        TableCreate.ulDensity = 80;
        TableCreate.rgcolumncreate = ColumnCreate;
        TableCreate.cColumns = 2;
        TableCreate.rgindexcreate = IndexCreate;
        TableCreate.cIndexes = 2;
        TableCreate.grbit = 0;
        TableCreate.tableid = 0;

        break;

    case SCEJET_TABLE_GPO:
        //
        // There are 3 columns in this table.
        // Assign each column info
        //
        ColumnCreate[0].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[0].szColumnName = "GpoID";
        ColumnCreate[0].coltyp = JET_coltypLong;
        ColumnCreate[0].cbMax = 4;
        ColumnCreate[0].grbit = JET_bitColumnNotNULL;
        ColumnCreate[0].pvDefault = NULL;
        ColumnCreate[0].cbDefault = 0;
        ColumnCreate[0].cp = 0;
        ColumnCreate[0].columnid = 0;

        ColumnCreate[1].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[1].szColumnName = "Name";
        ColumnCreate[1].coltyp = JET_coltypBinary;
        ColumnCreate[1].cbMax = 255;
        ColumnCreate[1].grbit = JET_bitColumnNotNULL;
        ColumnCreate[1].pvDefault = NULL;
        ColumnCreate[1].cbDefault = 0;
        ColumnCreate[1].cp = 0;
        ColumnCreate[1].columnid = 0;

        ColumnCreate[2].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[2].szColumnName = "DisplayName";
        ColumnCreate[2].coltyp = JET_coltypBinary;
        ColumnCreate[2].cbMax = 255;
        ColumnCreate[2].grbit = 0;
        ColumnCreate[2].pvDefault = NULL;
        ColumnCreate[2].cbDefault = 0;
        ColumnCreate[2].cp = 0;
        ColumnCreate[2].columnid = 0;

        //
        // Assign index info - one index in each table.
        //
        memset(IndexCreate, 0, 2*sizeof(JET_INDEXCREATE) );
        IndexCreate[0].cbStruct = sizeof(JET_INDEXCREATE);
        IndexCreate[0].szIndexName = "SectionKey";
        IndexCreate[0].szKey = "+GpoID\0\0";
        IndexCreate[0].cbKey = 8;
        IndexCreate[0].grbit = JET_bitIndexPrimary; // | JET_bitIndexUnique;
        IndexCreate[0].ulDensity = 80;

        IndexCreate[1].cbStruct = sizeof(JET_INDEXCREATE);
        IndexCreate[1].szIndexName = "GpoName";
        IndexCreate[1].szKey = "+Name\0\0";
        IndexCreate[1].cbKey = 7;
        IndexCreate[1].grbit = 0;
        IndexCreate[1].ulDensity = 80;

        //
        // Assign table info
        //
        TableCreate.cbStruct = sizeof(JET_TABLECREATE);
        TableCreate.szTableName = tblName;
        TableCreate.szTemplateTableName = NULL;
        TableCreate.ulPages = 10;
        TableCreate.ulDensity = 80;
        TableCreate.rgcolumncreate = ColumnCreate;
        TableCreate.cColumns = 3;
        TableCreate.rgindexcreate = IndexCreate;
        TableCreate.cIndexes = 2;
        TableCreate.grbit = 0;
        TableCreate.tableid = 0;

        break;

    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // Create the table, column, and index together
    //
    JetErr = JetCreateTableColumnIndex(
                    cxtProfile->JetSessionID,
                    cxtProfile->JetDbID,
                    &TableCreate
                    );

    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( SCESTATUS_OBJECT_EXIST == rc &&
         TableCreate.tableid != JET_tableidNil ) {
        rc = SCESTATUS_SUCCESS;

    } else if ( rc == SCESTATUS_SUCCESS &&
                TableCreate.tableid == JET_tableidNil ) {

        rc = SCESTATUS_OTHER_ERROR;
    }

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // Save the tableid and columnid in the context
        //
        if ( SCEJET_CREATE_NO_TABLEID == nFlags ) {
            //
            // do not need table ID to be returned
            //
            if ( TableCreate.tableid != JET_tableidNil ) {
                JetCloseTable(
                    cxtProfile->JetSessionID,
                    TableCreate.tableid
                    );
            }

        } else {

            if ( tblType == SCEJET_TABLE_VERSION ) {

                *TableID = TableCreate.tableid;
                *ColumnID = ColumnCreate[0].columnid;

            } else if ( TableID ) {
                *TableID = TableCreate.tableid;

            } else {

                switch ( tblType ) {
                case SCEJET_TABLE_SCP:
                    cxtProfile->JetScpID = TableCreate.tableid;
                    cxtProfile->JetScpSectionID = ColumnCreate[0].columnid;
                    cxtProfile->JetScpNameID = ColumnCreate[1].columnid;
                    cxtProfile->JetScpValueID = ColumnCreate[2].columnid;
                    cxtProfile->JetScpGpoID = ColumnCreate[3].columnid;
                    break;
                case SCEJET_TABLE_SMP:
                    cxtProfile->JetSmpID = TableCreate.tableid;
                    cxtProfile->JetSmpSectionID = ColumnCreate[0].columnid;
                    cxtProfile->JetSmpNameID = ColumnCreate[1].columnid;
                    cxtProfile->JetSmpValueID = ColumnCreate[2].columnid;
                    break;
                case SCEJET_TABLE_SAP:
                case SCEJET_TABLE_TATTOO: // use the SAP handle
                    cxtProfile->JetSapID = TableCreate.tableid;
                    cxtProfile->JetSapSectionID = ColumnCreate[0].columnid;
                    cxtProfile->JetSapNameID = ColumnCreate[1].columnid;
                    cxtProfile->JetSapValueID = ColumnCreate[2].columnid;
                    break;
                case SCEJET_TABLE_SECTION:
                    cxtProfile->JetTblSecID = TableCreate.tableid;
                    cxtProfile->JetSecNameID = ColumnCreate[1].columnid;
                    cxtProfile->JetSecID = ColumnCreate[0].columnid;
                    break;
                }
            }

            if ( tblType != SCEJET_TABLE_VERSION ) {

                //
                // Set current index in this table
                //
                JetErr = JetSetCurrentIndex(
                                cxtProfile->JetSessionID,
                                TableCreate.tableid,
                                "SectionKey"
                                );
                rc = SceJetJetErrorToSceStatus(JetErr);
            }
        }
    }

    return(rc);
}


SCESTATUS
SceJetOpenTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType,
    IN SCEJET_OPEN_TYPE OpenType,
    OUT JET_TABLEID *TableID
    )
/* ++
Routine Description:

    This routine opens a table, gets column IDs for the column "Name" and
    "Value" and saves them in the context.

Arguments:

    cxtProfile  - The context handle

    tblName     - ASCII name of a table to open

    tblType     - The type of the table. It may be one of the following
                    SCEJET_TABLE_SCP
                    SCEJET_TABLE_SAP
                    SCEJET_TABLE_SMP
                    SCEJET_TABLE_VERSION
                    SCEJET_TABLE_SECTION
                    SCEJET_TABLE_GPO
                    SCEJET_TABLE_TATTOO
Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_BAD_FORMAT
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_OTHER_ERROR

-- */
{
    JET_ERR         JetErr;
    JET_TABLEID     *tblID;
    JET_TABLEID     tmpTblID;
    JET_COLUMNDEF   ColumnDef;
    JET_COLUMNID    NameID=0;
    JET_COLUMNID    ValueID=0;
    JET_COLUMNID    SectionID=0;
    JET_COLUMNID    GpoColID=0;
    SCESTATUS       rc;
    JET_GRBIT       grbit=0;

    if ( cxtProfile == NULL || tblName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    // get address of table id

    if ( TableID ) {
        tblID = TableID;

    } else {

        switch (tblType) {
        case SCEJET_TABLE_SCP:
            tblID = &(cxtProfile->JetScpID);
            break;
        case SCEJET_TABLE_SAP:
        case SCEJET_TABLE_TATTOO:
            tblID = &(cxtProfile->JetSapID);
            break;
        case SCEJET_TABLE_SMP:
            tblID = &(cxtProfile->JetSmpID);
            break;
        case SCEJET_TABLE_SECTION:
            tblID = &(cxtProfile->JetTblSecID);
            break;

        default:
            return(SCESTATUS_INVALID_PARAMETER);
        }
    }

    if ( OpenType == SCEJET_OPEN_READ_ONLY ) {
        grbit = JET_bitTableReadOnly;
    }

    // open this table
    JetErr = JetOpenTable(
                    cxtProfile->JetSessionID,
                    cxtProfile->JetDbID,
                    tblName,
                    NULL,
                    0,
                    grbit,
                    &tmpTblID
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS )
        *tblID = tmpTblID;

    if ( TableID ) {
        return(rc);
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // SCP and SMP table must exist. SAP and Tattoo tables are optional.
        //
        if ( tblType != SCEJET_TABLE_SCP &&
             tblType != SCEJET_TABLE_SMP &&
             tblType != SCEJET_TABLE_SECTION &&
             ( rc == SCESTATUS_BAD_FORMAT ||
               rc == SCESTATUS_PROFILE_NOT_FOUND) ) {
            return(SCESTATUS_SUCCESS);
        }
        return(rc);
    }

    //
    // get column id for Column "SectionID"
    //
    JetErr = JetGetTableColumnInfo(
                    cxtProfile->JetSessionID,
                    *tblID,
                    "SectionID",
                    (VOID *)&ColumnDef,
                    sizeof(JET_COLUMNDEF),
                    0
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);
    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }
    SectionID = ColumnDef.columnid;

    //
    // get column id for Column "Name"
    //
    JetErr = JetGetTableColumnInfo(
                    cxtProfile->JetSessionID,
                    *tblID,
                    "Name",
                    (VOID *)&ColumnDef,
                    sizeof(JET_COLUMNDEF),
                    0
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);
    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }
    NameID = ColumnDef.columnid;

    if ( tblType == SCEJET_TABLE_SCP ||
         tblType == SCEJET_TABLE_SAP ||
         tblType == SCEJET_TABLE_SMP ||
         tblType == SCEJET_TABLE_TATTOO ) {

        //
        // get column id for Column "Value"
        //
        JetErr = JetGetTableColumnInfo(
                        cxtProfile->JetSessionID,
                        *tblID,
                        "Value",
                        (VOID *)&ColumnDef,
                        sizeof(JET_COLUMNDEF),
                        0
                        );
        rc = SceJetJetErrorToSceStatus(JetErr);
        if ( rc != SCESTATUS_SUCCESS ) {
            return(rc);
        }
        ValueID = ColumnDef.columnid;

        if ( tblType == SCEJET_TABLE_SCP ) {
            //
            // get column id for column GpoID
            //
            JetErr = JetGetTableColumnInfo(
                            cxtProfile->JetSessionID,
                            *tblID,
                            "GpoID",
                            (VOID *)&ColumnDef,
                            sizeof(JET_COLUMNDEF),
                            0
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);
            if ( rc != SCESTATUS_SUCCESS ) {
                return(rc);
            }
            GpoColID = ColumnDef.columnid;
        }
    }

    //
    // save the column ids
    //
    switch (tblType) {
    case SCEJET_TABLE_SCP:
        cxtProfile->JetScpSectionID = SectionID;
        cxtProfile->JetScpNameID = NameID;
        cxtProfile->JetScpValueID = ValueID;
        cxtProfile->JetScpGpoID = GpoColID;
        break;
    case SCEJET_TABLE_SAP:
    case SCEJET_TABLE_TATTOO:
        cxtProfile->JetSapSectionID = SectionID;
        cxtProfile->JetSapNameID = NameID;
        cxtProfile->JetSapValueID = ValueID;
        break;
    case SCEJET_TABLE_SMP:
        cxtProfile->JetSmpSectionID = SectionID;
        cxtProfile->JetSmpNameID = NameID;
        cxtProfile->JetSmpValueID = ValueID;
        break;
    case SCEJET_TABLE_SECTION:
        cxtProfile->JetSecID = SectionID;
        cxtProfile->JetSecNameID = NameID;
   }

    //
    // Set current index
    //

    JetErr = JetSetCurrentIndex(
                    cxtProfile->JetSessionID,
                    *tblID,
                    "SectionKey"
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);

    return(rc);

}


SCESTATUS
SceJetDeleteTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType
    )
{
    JET_ERR         JetErr;
    JET_TABLEID     *tblID;
    SCESTATUS        rc=SCESTATUS_SUCCESS;


    if ( cxtProfile == NULL || tblName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    // get address of table id
    switch (tblType) {
    case SCEJET_TABLE_SCP:
        tblID = &(cxtProfile->JetScpID);
        break;
    case SCEJET_TABLE_SAP:
    case SCEJET_TABLE_TATTOO:
        tblID = &(cxtProfile->JetSapID);
        break;
    case SCEJET_TABLE_SMP:
        tblID = &(cxtProfile->JetSmpID);
        break;
    case SCEJET_TABLE_SECTION:
        tblID = &(cxtProfile->JetTblSecID);
        break;
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    // close this table
    if ( *tblID != JET_tableidNil ) {
        JetErr = JetCloseTable(
                        cxtProfile->JetSessionID,
                        *tblID
                        );
        rc = SceJetJetErrorToSceStatus(JetErr);
        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        *tblID = JET_tableidNil;

        //
        // reset each column id
        //
        switch (tblType) {
        case SCEJET_TABLE_SCP:
            cxtProfile->JetScpSectionID = 0;
            cxtProfile->JetScpNameID = 0;
            cxtProfile->JetScpValueID = 0;
            cxtProfile->JetScpGpoID = 0;
            break;
        case SCEJET_TABLE_SAP:
        case SCEJET_TABLE_TATTOO:
            cxtProfile->JetSapSectionID = 0;
            cxtProfile->JetSapNameID = 0;
            cxtProfile->JetSapValueID = 0;
            break;
        case SCEJET_TABLE_SMP:
            cxtProfile->JetSmpSectionID = 0;
            cxtProfile->JetSmpNameID = 0;
            cxtProfile->JetSmpValueID = 0;
            break;
        case SCEJET_TABLE_SECTION:
            cxtProfile->JetSecNameID = 0;
            cxtProfile->JetSecID = 0;
            break;
        }
    }

    JetErr = JetDeleteTable(cxtProfile->JetSessionID,
                            cxtProfile->JetDbID,
                            tblName
                            );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_BAD_FORMAT )
        rc = SCESTATUS_SUCCESS;

    return(rc);

}


SCESTATUS
SceJetCheckVersion(
    IN PSCECONTEXT   cxtProfile,
    OUT FLOAT *pVersion OPTIONAL
    )
/* ++
Routine Description:

    This routine checks the version table in the database to see if the
    database is for the security manager, also if the version # is the
    correct one.

    The version table is named "SmTblVersion" and has a Version column
    in it. The current version # is 1.2

Arguments:

    cxtProfile  - The profile context

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR
    SCESTATUS from SceJetOpenTable

-- */
{
    SCESTATUS        rc;
    FLOAT           Version=(FLOAT)1.0;
    DWORD           Actual;


    if ( cxtProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = SceJetpGetValueFromVersion(
                cxtProfile,
                "SmTblVersion",
                "Version",
                (LPSTR)&Version,
                4, // number of bytes
                &Actual
                );

    if ( rc == SCESTATUS_SUCCESS ||
         rc == SCESTATUS_BUFFER_TOO_SMALL ) {

        if ( Version != (FLOAT)1.2 )
            rc = SCESTATUS_BAD_FORMAT;
        else
            rc = SCESTATUS_SUCCESS;
    }

    if ( pVersion ) {
        *pVersion = Version;
    }

    return(rc);
}


SCESTATUS
SceJetGetSectionIDByName(
    IN PSCECONTEXT cxtProfile,
    IN PCWSTR Name,
    OUT DOUBLE *SectionID OPTIONAL
    )
/* ++
Routine Description:

    This routine retrieve the section ID for the name in the Section table.
    If SectionID is NULL, this routine really does a seek by name. The cursor
    will be on the record if there is a successful match.

Arguments:

    cxtProfile  - The profile context handle

    Name        - The section name looked for

    SectionID   - The output section ID if there is a successful match

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_RECORD_NOT_FOUND
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR

-- */
{
    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Actual;
    PWSTR     LwrName=NULL;
    DWORD     Len;

    if ( cxtProfile == NULL || Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( cxtProfile->JetTblSecID <= 0) {
        //
        // Section table is not opened yet
        //
        rc = SceJetOpenTable(
                        cxtProfile,
                        "SmTblSection",
                        SCEJET_TABLE_SECTION,
                        SCEJET_OPEN_READ_ONLY,
                        NULL
                        );

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
    }

    //
    // set current index to SectionKey (the name)
    //
    JetErr = JetSetCurrentIndex(
                cxtProfile->JetSessionID,
                cxtProfile->JetTblSecID,
                "SectionKey"
                );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    Len = wcslen(Name);
    LwrName = (PWSTR)ScepAlloc(0, (Len+1)*sizeof(WCHAR));

    if ( LwrName != NULL ) {

        wcscpy(LwrName, Name);
        LwrName = _wcslwr(LwrName);

        JetErr = JetMakeKey(
                    cxtProfile->JetSessionID,
                    cxtProfile->JetTblSecID,
                    (VOID *)LwrName,
                    Len*sizeof(WCHAR),
                    JET_bitNewKey
                    );

        if ( JetErr == JET_errKeyIsMade ) {
            //
            // Only one key is needed, it may return this code, even on success.
            //
            JetErr = JET_errSuccess;
        }
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {
            JetErr = JetSeek(
                        cxtProfile->JetSessionID,
                        cxtProfile->JetTblSecID,
                        JET_bitSeekEQ
                        );
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // find the section name, retrieve column SectionID
                //
                if ( SectionID != NULL) {
                    JetErr = JetRetrieveColumn(
                                    cxtProfile->JetSessionID,
                                    cxtProfile->JetTblSecID,
                                    cxtProfile->JetSecID,
                                    (void *)SectionID,
                                    8,
                                    &Actual,
                                    0,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);
                }

            }

        }
        ScepFree(LwrName);

    } else
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

    return(rc);

}


SCESTATUS
SceJetGetSectionNameByID(
    IN PSCECONTEXT cxtProfile,
    IN DOUBLE SectionID,
    OUT PWSTR Name OPTIONAL,
    IN OUT LPDWORD pNameLen OPTIONAL
    )
/* ++
Routine Description:

    This routine retrieve the section name for the ID in the Section table.
    If Name is NULL, this routine really does a seek by ID. The cursor will
    be on the record if there is a successful match.

Arguments:

    cxtProfile  - The profile context handle

    SectionID   - The section ID looking for

    Name        - The optional output buffer for section name

    pNameLen  - The name buffer's length


Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_RECORD_NOT_FOUND
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR

-- */
{
    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Actual;


    if ( cxtProfile == NULL || (Name != NULL && pNameLen == NULL) )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( cxtProfile->JetTblSecID <= 0) {
        //
        // Section table is not opened yet
        //
        rc = SceJetOpenTable(
                        cxtProfile,
                        "SmTblSection",
                        SCEJET_TABLE_SECTION,
                        SCEJET_OPEN_READ_ONLY,
                        NULL
                        );

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
    }

    //
    // set current index to SecID (the ID)
    //
    JetErr = JetSetCurrentIndex(
                cxtProfile->JetSessionID,
                cxtProfile->JetTblSecID,
                "SecID"
                );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    JetErr = JetMakeKey(
                cxtProfile->JetSessionID,
                cxtProfile->JetTblSecID,
                (VOID *)(&SectionID),
                8,
                JET_bitNewKey
                );

    if ( JetErr == JET_errKeyIsMade ) {
        //
        // Only one key is needed, it may return this code, even on success.
        //
        JetErr = JET_errSuccess;
    }
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        JetErr = JetSeek(
                    cxtProfile->JetSessionID,
                    cxtProfile->JetTblSecID,
                    JET_bitSeekEQ
                    );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // find the section ID, retrieve column Name
            //
            if ( Name != NULL ) {
                JetErr = JetRetrieveColumn(
                            cxtProfile->JetSessionID,
                            cxtProfile->JetTblSecID,
                            cxtProfile->JetSecNameID,
                            (void *)Name,
                            *pNameLen,
                            &Actual,
                            0,
                            NULL
                            );
                *pNameLen = Actual;
                rc = SceJetJetErrorToSceStatus(JetErr);
            }
        }

    }

    return(rc);

}


SCESTATUS
SceJetAddSection(
    IN PSCECONTEXT cxtProfile,
    IN PCWSTR      Name,
    OUT DOUBLE *SectionID
    )
/* ++
Routine Description:

Arguments:

Return Value:

-- */
{
    SCESTATUS  rc;
    DWORD     Len;
    JET_ERR   JetErr;
    PWSTR     LwrName=NULL;


    if ( cxtProfile == NULL ||
         Name == NULL ||
        SectionID == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = SceJetGetSectionIDByName(
                    cxtProfile,
                    Name,
                    SectionID
                    );
    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
        //
        // the record is not there. add it in
        // get the next available section ID first.
        //
        Len = wcslen(Name)*sizeof(WCHAR);
        LwrName = (PWSTR)ScepAlloc(0, Len+2);

        if ( LwrName != NULL ) {

            rc = SceJetpGetAvailableSectionID(
                        cxtProfile,
                        SectionID
                        );
            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // add a record to the section table
                //
                JetErr = JetPrepareUpdate(cxtProfile->JetSessionID,
                                          cxtProfile->JetTblSecID,
                                          JET_prepInsert
                                          );
                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // set SectionID and name
                    //

                    JetErr = JetSetColumn(
                                    cxtProfile->JetSessionID,
                                    cxtProfile->JetTblSecID,
                                    cxtProfile->JetSecID,
                                    (void *)SectionID,
                                    8,
                                    0, //JET_bitSetOverwriteLV,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);

                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // set Name column
                        //
                        wcscpy(LwrName, Name);
                        LwrName = _wcslwr(LwrName);

                        JetErr = JetSetColumn(
                                        cxtProfile->JetSessionID,
                                        cxtProfile->JetTblSecID,
                                        cxtProfile->JetSecNameID,
                                        (void *)LwrName,
                                        Len,
                                        0,
                                        NULL
                                        );
                        rc = SceJetJetErrorToSceStatus(JetErr);

                    }

                    if ( rc != SCESTATUS_SUCCESS ) {
                        //
                        // if setting fails, cancel the prepared record
                        //
                        JetPrepareUpdate( cxtProfile->JetSessionID,
                                          cxtProfile->JetTblSecID,
                                          JET_prepCancel
                                          );
                    } else {

                        //
                        // Setting columns succeed. Update the record
                        //
                        JetErr = JetUpdate(cxtProfile->JetSessionID,
                                           cxtProfile->JetTblSecID,
                                           NULL,
                                           0,
                                           &Len
                                           );
                        rc = SceJetJetErrorToSceStatus(JetErr);
                    }
                }
            }
            ScepFree(LwrName);
        }
    }

    return(rc);
}


SCESTATUS
SceJetDeleteSectionID(
    IN PSCECONTEXT cxtProfile,
    IN DOUBLE SectionID,
    IN PCWSTR  Name
    )
/* ++
Routine Description:

    This routine deletes a record from the SmTblSection table. If SectionID
    is not 0, the record will be deleted by ID if there is a match on ID.
    Otherwise, the record will be deleted by Name if there is a match on Name.

Arguments:

    cxtProfile  - The profile context handle

    SectionID   - The SectionID to delete (if it is not 0)

    Name        - The section name to delete (if it is not NULL ).

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_OTHER_ERROR

    SCESTATUS from SceJetGetSectionIDByName
    SCESTATUS from SceJetGetSectionNameByID

-- */
{
    SCESTATUS    rc;
    JET_ERR     JetErr;


    if ( cxtProfile == NULL )
        return(SCESTATUS_INVALID_PARAMETER);


    if ( SectionID > (DOUBLE)0 ) {
        //
        // delete by SectionID
        //
        rc = SceJetGetSectionNameByID(
                    cxtProfile,
                    SectionID,
                    NULL,
                    NULL
                    );

        if ( rc == SCESTATUS_SUCCESS ) {
            // find it
            JetErr = JetDelete(cxtProfile->JetSessionID, cxtProfile->JetTblSecID);
            rc = SceJetJetErrorToSceStatus(JetErr);

        }

        return(rc);

    }

    if ( Name != NULL && wcslen(Name) > 0 ) {
        //
        // delete by Name
        //
        rc = SceJetGetSectionIDByName(
                    cxtProfile,
                    Name,
                    NULL
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            // find it
            JetErr = JetDelete(cxtProfile->JetSessionID, cxtProfile->JetTblSecID);
            rc = SceJetJetErrorToSceStatus(JetErr);

        }

        return(rc);
    }

    return(SCESTATUS_INVALID_PARAMETER);

}


//
// Other private APIs
//
JET_ERR
SceJetpSeek(
    IN PSCESECTION hSection,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength,
    IN SCEJET_SEEK_FLAG SeekBit,
    IN BOOL bOkNoMatch
    )
/* ++
Routine Description:

    This routine seeks to the current key as built with SceJetpMakeKey.
    If there is no records start with the SectionID+LinePrefix, a
    JET_errRecordNotFound is returned. This is similar to exact or partial
    match search.

    There is a 255 bytes limit on Jet engine's index. If SectionID plus
    the line prefix is over this limit, this routine will scroll to the next
    record until find a line starting with SectionID + LinePrefix.

Arguments:

    hSection    - the context handle of the section

    LinePrefix  - The prefix for fields to start with

    PrefixLength- The length of the prefix in BYTES

    grbit       - The option for JetSeek

Return Value:

    JET_ERR returned from JetMakeKey,JetSeek,JetRetrieveColumn, JetMove

-- */
{
    JET_ERR     JetErr;
    INT         Result=0;
    JET_GRBIT   grbit;
    DWORD       Actual;

    //
    // make the key first
    //
    JetErr = SceJetpMakeKey(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    hSection->SectionID,
                    LinePrefix,
                    PrefixLength
                    );
    if ( JetErr != JET_errSuccess ) {
        return(JetErr);
    }
    //
    // Call Jet engine's JetSeek to take to the first line
    // to start with.
    //
    switch ( SeekBit ) {
    case SCEJET_SEEK_EQ:
        grbit = JET_bitSeekEQ;
        break;
    case SCEJET_SEEK_GT:
        if ( LinePrefix != NULL && PrefixLength > 247 )
            grbit = JET_bitSeekGE;
        else
            grbit = JET_bitSeekGT;
        break;
    default:
        grbit = JET_bitSeekGE;
    }
    JetErr = JetSeek(
                hSection->JetSessionID,
                hSection->JetTableID,
                grbit
                );

    if ( JetErr == JET_errSuccess ||
         JetErr == JET_wrnSeekNotEqual ) {

        if ( LinePrefix != NULL && PrefixLength > 247 ) {
            //
            // info is truncated
            // The current record may be before the actual one
            //
            do {
                //
                // check the current record
                //
                JetErr = SceJetpCompareLine(
                                hSection,
                                grbit,
                                LinePrefix,
                                PrefixLength,
                                &Result,
                                &Actual
                                );
                if ( JetErr == JET_errSuccess &&
                    ( Result < 0 || (Result == 0 && SeekBit == SCEJET_SEEK_GT) )) {
                    //
                    // current record's data is less than the prefix, move to next
                    //
                    JetErr = JetMove(hSection->JetSessionID,
                                     hSection->JetTableID,
                                     JET_MoveNext,
                                     0
                                     );
                    if ( JetErr == JET_errNoCurrentRecord )
                        JetErr = JET_errRecordNotFound;
                }
            } while ( JetErr == JET_errSuccess &&
                      ( (Result < 0 && SeekBit != SCEJET_SEEK_EQ) ||
                        (Result == 0 && SeekBit == SCEJET_SEEK_GT) ) );

            if ( SeekBit == SCEJET_SEEK_EQ && JetErr == JET_errSuccess &&
                 Result == 0 && Actual > PrefixLength ) {
                //
                // no exact match
                //
                return(JET_errRecordNotFound);

            } // for SEEK_GE check, see below

        } else {
            //
            // Prefix is not overlimit. Check the current record only.
            //
            if (SeekBit != SCEJET_SEEK_EQ)
                JetErr = SceJetpCompareLine(
                        hSection,
                        grbit,
                        LinePrefix,
                        PrefixLength,
                        &Result,
                        0
                        );
        }

        if ( JetErr == JET_errSuccess && Result > 0 ) {
            if ( SeekBit == SCEJET_SEEK_EQ ) {
                //
                // Prefix is less than the current line, which is OK if for SEEK_GE and SEEK_GT
                //
                return(JET_errRecordNotFound);

            } else if ( SeekBit == SCEJET_SEEK_GE && LinePrefix && PrefixLength && !bOkNoMatch ) {
                //
                return(JET_errRecordNotFound);
            }
        }

    }

    return(JetErr);
}


JET_ERR
SceJetpCompareLine(
    IN PSCESECTION   hSection,
    IN JET_GRBIT    grbit,
    IN PWSTR        LinePrefix OPTIONAL,
    IN DWORD        PrefixLength,
    OUT INT         *Result,
    OUT DWORD       *ActualLength OPTIONAL
    )
/* ++
Routine Description:

    This routine comapre the current line with the SectionID in the section
    handle and name column with LinePrefix if LinePrefix is not NULL. The
    purpose of this routine is to see if the cursor is still on a record
    which has the same sectionID and prefix.

    The comparsion result is output from Result. If JET_errSuccess returns
    and Result < 0, the current record is BEFORE the prefix; If Result = 0,
    the current record has the same key with prefix; If Result > 0, the
    current record is AFTER the prefix. If no more record is available to
    be compared, JET_errRecordNotFound returns. Any other error occurs inside
    the routine is returned.

Arguments:

    hSection    - the section handle

    LinePrefix  - The prefix to match

    PrefixLength - The number of BYTES in LinePrefix

Return Value:

    JET_errSuccess
    JET_errRecordNotFound
    JET_errOutOfMemory
    JET_ERR returned from JetRetrieveColumn

-- */
{
    JET_ERR     JetErr;
    DOUBLE      SectionID;
    DWORD       Actual;
    JET_RETINFO RetInfo;
    PWSTR       Buffer=NULL;

//    *Result = 0;
//    return(JET_errSuccess);
    //
    // Compare the section first
    //
    JetErr = JetRetrieveColumn(
                hSection->JetSessionID,
                hSection->JetTableID,
                hSection->JetColumnSectionID,
                (void *)&SectionID,
                8,
                &Actual,
                0,
                NULL
                );
    if ( JetErr == JET_errNoCurrentRecord )
        return(JET_errRecordNotFound);

    else if ( JetErr != JET_errSuccess )
        return(JetErr);

    if ( hSection->SectionID < SectionID ) {
        *Result = 1;
//        if ( grbit != JET_bitSeekGT )
            return(JET_errRecordNotFound);

    } else if ( hSection->SectionID == SectionID )
        *Result = 0;
    else
        *Result = -1;

    if ( *Result != 0 || grbit == JET_bitSeekGT )
        return(JetErr);

    //
    // check Name column
    //
    if ( LinePrefix != NULL && PrefixLength > 0 ) {
        RetInfo.ibLongValue = 0;
        RetInfo.cbStruct = sizeof(JET_RETINFO);
        RetInfo.itagSequence = 1;

        Buffer = (PWSTR)LocalAlloc(LMEM_ZEROINIT, PrefixLength+2);
        if ( Buffer == NULL )
            return(JET_errOutOfMemory);

        JetErr = JetRetrieveColumn(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    hSection->JetColumnNameID,
                    (void *)Buffer,
                    PrefixLength,
                    &Actual,
                    0,
                    &RetInfo
                    );

        if ( JetErr == JET_errNoCurrentRecord )
            JetErr = JET_errRecordNotFound;

        if ( JetErr != JET_errSuccess &&
             JetErr != JET_wrnBufferTruncated ) {

            if ( JetErr > 0 ) {
                // warnings, do not return equal
                JetErr = JET_errSuccess;
                *Result = 1;
            }
            LocalFree(Buffer);
            return(JetErr);
        }

        JetErr = JET_errSuccess;

        //
        // Compare the first PrefixLength bytes.
        //
        *Result = _wcsnicmp(Buffer,
                           LinePrefix,
                           PrefixLength/sizeof(WCHAR));
//printf("Compare %ws to %ws for Length %d: Result=%d\n", Buffer, LinePrefix, PrefixLength/2, *Result);
        LocalFree(Buffer);

        if ( ActualLength != NULL )
            *ActualLength = Actual;
    }

    return(JetErr);
}


JET_ERR
SceJetpMakeKey(
    IN JET_SESID SessionID,
    IN JET_TABLEID TableID,
    IN DOUBLE SectionID,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength
    )
/* ++
Routine Description:

    This routine constructs a normalized key value for Seek. It constructs
    the section name in the section context first. Then the LinePrefix is
    added if it is not NULL.

    The scp, sap and smp tables all have one index which is Section+Name.

Arguments:

    SessionID   - the Jet session ID

    TableID     - The Jet table ID to work in

    SectionID   - The ID in column "SectionID"

    LinePrefix  - The prefix for fields to start with

    PrefixLength- The length of the prefix in BYTES

Return Value:

    JET_ERR from JetMakeKey
-- */
{
    JET_ERR         JetErr;
    JET_GRBIT       grbit;


    if ( LinePrefix == NULL ) {
        grbit = JET_bitNewKey; // | JET_bitStrLimit;  having StrLimit set takes you to the next key
    } else {
        grbit = JET_bitNewKey;
    }

    //
    // Add section ID to the key
    //
    JetErr = JetMakeKey(
                SessionID,
                TableID,
                (VOID *)(&SectionID),
                8,
                grbit
                );

    if ( JetErr != JET_errSuccess )
        return(JetErr);

    //
    // add prefix to the key if it is not NULL
    //
    if ( LinePrefix != NULL ) {
        JetErr = JetMakeKey(
                    SessionID,
                    TableID,
                    (VOID *)LinePrefix,
                    PrefixLength,
                    JET_bitSubStrLimit
                    );
    }

    if ( JetErr == JET_errKeyIsMade ) {
        //
        // When 2 keys are provided, it may return this code, even on success.
        //
        JetErr = JET_errSuccess;
    }

    return(JetErr);

}


JET_ERR
SceJetpBuildUpperLimit(
    IN PSCESECTION hSection,
    IN PWSTR      LinePrefix,
    IN DWORD      Len,
    IN BOOL       bReserveCase
    )
/* ++
Function Descripton:

    This routine builts an upper index range based on a section and an
    optional prefix. If prefix is NULL, the upper limit is the next
    available sectionID. If prefix is not NULL, the upper limit is the
    last character 's next character in the key.

    For example, if prefix is a\b\c\d\e\f\g, the upper limit is then
    a\b\c\d\e\f\h. If prefix is over 247 (index limit), e.g.,

    aaa...\b..\c...\d...\e...\f\x\t\y\z

                              ^
                              |
                            the 247th byte.
    then the upper limit is built to aaa...\b..\c...\d...\e...\g

Arguments:

    hSection    - The seciton's handle

    LinePrefix  - The prefix

    Len         - The number of bytes in the prefix

Return Value:

    JET_ERR from SceJetpMakeKey, JetSetIndexRange

-- */
{
    JET_ERR     JetErr;
    DWORD       indx;
    WCHAR       UpperLimit[128];


    if ( Len == 0 ) {
        // no prefix. The upper limit is the next available section ID
        JetErr = SceJetpMakeKey(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    hSection->SectionID+(DOUBLE)1,
                    NULL,
                    0
                    );

    } else {

        memset(UpperLimit, 0, 128*sizeof(WCHAR));

        if ( Len < 247 )
            // prefix is not overlimit.
            // The upper limit is the last character + 1
            indx = Len / sizeof(WCHAR);
        else
            // prefix is overlimit (247)
            // built range on 247 bytes
            indx = 123;

        wcsncpy(UpperLimit, LinePrefix, indx);
        UpperLimit[indx] = L'\0';

        if ( !bReserveCase ) {
            _wcslwr(UpperLimit);
        }
        UpperLimit[indx-1] = (WCHAR) (UpperLimit[indx-1] + 1);

        JetErr = SceJetpMakeKey(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    hSection->SectionID,
                    UpperLimit,
                    Len
                    );
    }

    if ( JetErr != JET_errSuccess )
        return(JetErr);

    //
    // set upper limit
    //
    JetErr = JetSetIndexRange(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    JET_bitRangeUpperLimit //| JET_bitRangeInclusive
                    );

    return(JetErr);
}


SCESTATUS
SceJetJetErrorToSceStatus(
    IN JET_ERR  JetErr
    )
/* ++
Routine Description:

    This routine converts error returned from Jet engine (JET_ERR) to SCESTATUS.

Arguments:

    JetErr  - The error returned from Jet engine

Return Value:

    All available SCESTATUS error codes

-- */
{
    SCESTATUS rc;

    switch ( JetErr ) {
    case JET_errSuccess:
    case JET_wrnSeekNotEqual:
    case JET_wrnNoErrorInfo:
    case JET_wrnColumnNull:
    case JET_wrnColumnSetNull:
    case JET_wrnTableEmpty:
    case JET_errAlreadyInitialized:

        rc = SCESTATUS_SUCCESS;
        break;

    case JET_errDatabaseInvalidName:

        rc = SCESTATUS_INVALID_PARAMETER;
        break;

    case JET_errNoCurrentRecord:
    case JET_errRecordNotFound:

        rc = SCESTATUS_RECORD_NOT_FOUND;
        break;

    case JET_errColumnDoesNotFit:
    case JET_errColumnTooBig:

        rc = SCESTATUS_INVALID_DATA;
        break;

    case JET_errDatabaseDuplicate:
    case JET_errTableDuplicate:
    case JET_errColumnDuplicate:
    case JET_errIndexDuplicate:
    case JET_errKeyDuplicate:

        rc = SCESTATUS_OBJECT_EXIST;
        break;

    case JET_wrnBufferTruncated:

        rc = SCESTATUS_BUFFER_TOO_SMALL;
        break;

    case JET_errFileNotFound:
    case JET_errDatabaseNotFound:

        rc = SCESTATUS_PROFILE_NOT_FOUND;
        break;

    case JET_errObjectNotFound:
    case JET_errIndexNotFound:
    case JET_errColumnNotFound:
    case JET_errDatabaseCorrupted:

        rc = SCESTATUS_BAD_FORMAT;
        break;

    case JET_errTooManyOpenDatabases:
    case JET_errTooManyOpenTables:
    case JET_errDiskFull:
    case JET_errOutOfMemory:
    case JET_errVersionStoreOutOfMemory:

        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        break;

    case JET_errPermissionDenied:
    case JET_errFileAccessDenied:
    case JET_errTableInUse:
    case JET_errTableLocked:
    case JET_errWriteConflict:

        rc = SCESTATUS_ACCESS_DENIED;
        break;

    case JET_errFeatureNotAvailable:
    case JET_errQueryNotSupported:
    case JET_errSQLLinkNotSupported:
    case JET_errLinkNotSupported:
    case JET_errIllegalOperation:

        rc = SCESTATUS_SERVICE_NOT_SUPPORT;
        break;

    default:
//printf("JetErr=%d\n", JetErr);
        rc = SCESTATUS_OTHER_ERROR;
        break;
    }
    return(rc);
}



SCESTATUS
SceJetpGetAvailableSectionID(
    IN PSCECONTEXT cxtProfile,
    OUT DOUBLE *SectionID
    )
/* ++
Routine Description:


Arguments:

    cxtProfile  - The profile context handle

    SectionID   - The output section ID


Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_RECORD_NOT_FOUND
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR

-- */
{
    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Actual;


    if ( cxtProfile == NULL || SectionID == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( cxtProfile->JetTblSecID <= 0) {
        //
        // Section table is not opened yet
        //
        rc = SceJetOpenTable(
                        cxtProfile,
                        "SmTblSection",
                        SCEJET_TABLE_SECTION,
                        SCEJET_OPEN_READ_ONLY,
                        NULL
                        );

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
    }

    *SectionID = (DOUBLE)0;

    //
    // set current index to SecID (the ID)
    //
    JetErr = JetSetCurrentIndex(
                cxtProfile->JetSessionID,
                cxtProfile->JetTblSecID,
                "SecID"
                );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // Move to the last record
    //
    JetErr = JetMove(
                  cxtProfile->JetSessionID,
                  cxtProfile->JetTblSecID,
                  JET_MoveLast,
                  0
                  );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // find the section ID, retrieve column Name
        //
        JetErr = JetRetrieveColumn(
                    cxtProfile->JetSessionID,
                    cxtProfile->JetTblSecID,
                    cxtProfile->JetSecID,
                    (void *)SectionID,
                    8,
                    &Actual,
                    0,
                    NULL
                    );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // The next available ID is current ID + 1
            //
            *SectionID = *SectionID + (DOUBLE)1;
        }
    } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

        *SectionID = (DOUBLE)1;
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);

}


SCESTATUS
SceJetpAddAllSections(
    IN PSCECONTEXT cxtProfile
    )
/* ++
Routine Description:

    This routine adds all pre-defined sections into the section table.
    This routine is used when creating the section table.

Arguments:

    cxtProfile - The profile context

Return Value:

    SCESTATUS from SceJetAddSection

-- */
{
    SCESTATUS rc;
    DOUBLE SectionID;


    rc = SceJetAddSection(
        cxtProfile,
        szSystemAccess,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szPrivilegeRights,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szGroupMembership,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szAccountProfiles,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szRegistryKeys,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szFileSecurity,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szDSSecurity,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szAuditSystemLog,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szAuditSecurityLog,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szAuditApplicationLog,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szAuditEvent,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szUserList,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szKerberosPolicy,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szServiceGeneral,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szRegistryValues,
        &SectionID
        );

    return(rc);
}


SCESTATUS
SceJetpConfigJetSystem(
    IN JET_INSTANCE *hinstance
    )
{
    SCESTATUS rc=SCESTATUS_SUCCESS;
    DWORD    Win32rc;
    JET_ERR  JetErr;

    DWORD    Len;
    PWSTR SysRoot=NULL;

    PWSTR ProfileLocation=NULL;
    CHAR FileName[512];

    PSECURITY_DESCRIPTOR pSD=NULL;
    SECURITY_INFORMATION SeInfo;
    DWORD SDsize;

    //
    // the default Jet working directory is always in %SystemRoot%\security
    // no matter who is logged on.
    // this way allows one jet working directory
    //
    Len =  0;
    Win32rc = ScepGetNTDirectory( &SysRoot, &Len, SCE_FLAG_WINDOWS_DIR );

    if ( Win32rc == NO_ERROR ) {

        if ( SysRoot != NULL ) {
            Len += 9;  // profile location

            ProfileLocation = (PWSTR)ScepAlloc( 0, (Len+1)*sizeof(WCHAR));

            if ( ProfileLocation == NULL ) {

                Win32rc = ERROR_NOT_ENOUGH_MEMORY;
            } else {

                swprintf(ProfileLocation, L"%s\\Security", SysRoot );
                ProfileLocation[Len] = L'\0';
            }

            ScepFree(SysRoot);

        } else
            Win32rc = ERROR_INVALID_DATA;
    }

    if ( Win32rc == NO_ERROR ) {

#ifdef SCEJET_DBG
    wprintf(L"Default location: %s\n", ProfileLocation);
#endif
        //
        // convert WCHAR into ANSI
        //
        memset(FileName, '\0', 512);
        Win32rc = RtlNtStatusToDosError(
                      RtlUnicodeToMultiByteN(
                            (PCHAR)FileName,
                            512,
                            NULL,
                            ProfileLocation,
                            Len*sizeof(WCHAR)
                            ));

        if ( Win32rc == NO_ERROR ) {
            //
            // a backslash is required by Jet
            //
            strcat(FileName, "\\");

            //
            // set everyone change, admin full control to the directory
            // the directory is created in the function.
            //
            Win32rc = ConvertTextSecurityDescriptor (
                            L"D:P(A;CIOI;GRGW;;;WD)(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)",
                            &pSD,
                            &SDsize,
                            &SeInfo
                            );
            if ( Win32rc == NO_ERROR ) {

                ScepChangeAclRevision(pSD, ACL_REVISION);

                rc = ScepCreateDirectory(
                            ProfileLocation,
                            TRUE,      // a dir name
                            pSD        // take parent's security setting
                            );
#ifdef SCEJET_DBG
    if ( rc != SCESTATUS_SUCCESS )
        wprintf(L"Cannot create directory %s\n", ProfileLocation );
#endif

                if ( rc == SCESTATUS_SUCCESS ) {

                    __try {

                        JetErr = JetSetSystemParameter( hinstance, 0, JET_paramSystemPath, 0, (const char *)FileName );

                        rc = SceJetJetErrorToSceStatus(JetErr);

                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        //
                        // esent is not loaded
                        //
                        rc = SCESTATUS_MOD_NOT_FOUND;
                    }
                }

                if ( rc == SCESTATUS_SUCCESS ) {

                    JetErr = JetSetSystemParameter( hinstance, 0, JET_paramTempPath, 0, (const char *)FileName );

                    if ( JetErr == JET_errSuccess ) {
                        JetErr = JetSetSystemParameter( hinstance, 0, JET_paramLogFilePath, 0, (const char *)FileName );

                        if ( JetErr == JET_errSuccess ) {
                            JetErr = JetSetSystemParameter( hinstance, 0, JET_paramDatabasePageSize, 4096, NULL );
                        }
                    }

                    rc = SceJetJetErrorToSceStatus(JetErr);

                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // set log size to 1M
                        //
                        JetSetSystemParameter( hinstance, 0, JET_paramLogFileSize, 1024, NULL );
                        //
                        // defer the event log to when event log service is available
                        // (for example, in NT setup, there is no event log)
                        //
                        JetSetSystemParameter( hinstance, 0, JET_paramEventLogCache, 128, NULL );

                        JetSetSystemParameter( hinstance, 0, JET_paramMaxVerPages, 128, NULL );

                        //
                        // set minimize = maximum cache size to disable DBA in jet
                        // recommended setting for minimum is 4 * number of sessions
                        // maximum is up to the app (for performance)
                        //

                        JetSetSystemParameter( hinstance, 0, JET_paramMaxSessions, 64, NULL );

                        //
                        // performance is about 10% faster when using cache size 512 than 256
                        //

                        JetSetSystemParameter( hinstance, 0, JET_paramStartFlushThreshold, 50, NULL ); // sugguested by Exchange
                        JetSetSystemParameter( hinstance, 0, JET_paramStopFlushThreshold, 100, NULL ); // suggested by Exchange

                        //
                        // can't set to 512 because that's Jet's default value
                        // jet won't turn off DBA if value is set to 512.
                        //
                        JetSetSystemParameter( hinstance, 0, JET_paramCacheSizeMax, 496, NULL );  //256

                        JetSetSystemParameter( hinstance, 0, JET_paramCacheSizeMin, 496, NULL );  //256

                        //
                        // other system parameters, such as memory size in beta2
                        //
                        JetErr = JetSetSystemParameter( hinstance, 0, JET_paramCircularLog, 1, NULL );

                        JetErr = JetSetSystemParameter( hinstance, 0, JET_paramNoInformationEvent, 1, NULL );

                    }
                }

                ScepFree(pSD);

            }
        }

        ScepFree(ProfileLocation);
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = ScepDosErrorToSceStatus(Win32rc);
    }

    return(rc);
}



SCESTATUS
SceJetGetTimeStamp(
    IN PSCECONTEXT   cxtProfile,
    OUT PLARGE_INTEGER ConfigTimeStamp,
    OUT PLARGE_INTEGER AnalyzeTimeStamp
    )
/* ++
Routine Description:

    This routine queries the time stamp of last analysis.

    The time stamp is saved in the "SmTblVersion" table.

Arguments:

    cxtProfile  - The profile context

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR
    SCESTATUS from SceJetOpenTable

-- */
{
    SCESTATUS        rc=SCESTATUS_SUCCESS;
    DWORD           RetLen = 0;

    if (cxtProfile == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // Open version table
    //
    if ( ConfigTimeStamp != NULL ) {

        rc = SceJetpGetValueFromVersion(
                    cxtProfile,
                    "SmTblVersion",
                    "ConfigTimeStamp",
                    (CHAR*)ConfigTimeStamp, //TimeStamp,
                    8,  // 16, // number of bytes
                    &RetLen
                    );
        if ( rc == SCESTATUS_SUCCESS ||
             rc == SCESTATUS_BUFFER_TOO_SMALL )
            rc = SCESTATUS_SUCCESS;

        if ( RetLen < 8 ) {
            (*ConfigTimeStamp).LowPart = 0;
            (*ConfigTimeStamp).HighPart = 0;
        }
    }

    if ( AnalyzeTimeStamp != NULL ) {

        rc |= SceJetpGetValueFromVersion(
                    cxtProfile,
                    "SmTblVersion",
                    "AnalyzeTimeStamp",
                    (CHAR*)AnalyzeTimeStamp, //TimeStamp,
                    8,  // 16, // number of bytes
                    &RetLen
                    );

        if ( rc == SCESTATUS_SUCCESS ||
             rc == SCESTATUS_BUFFER_TOO_SMALL )
            rc = SCESTATUS_SUCCESS;

        if ( RetLen < 8 ) {
            (*AnalyzeTimeStamp).LowPart = 0;
            (*AnalyzeTimeStamp).HighPart = 0;
        }
    }

    return(rc);
}



SCESTATUS
SceJetSetTimeStamp(
    IN PSCECONTEXT   cxtProfile,
    IN BOOL        Flag,
    IN LARGE_INTEGER NewTimeStamp
    )
/* ++
Routine Description:

    This routine sets the time stamp (LARGE_INTEGER) of a analysis.

    The time stamp is saved in the "SmTblVersion" table.

Arguments:

    cxtProfile  - The profile context

    Flag        - indicates analyze or configure
                    Flag = TRUE - AnalyzeTimeStamp
                    Flag = FALSE - ConfigTimeStamp

    NewTimeStamp - the new time stamp of a analysis

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR
    SCESTATUS from SceJetOpenTable

-- */
{
    SCESTATUS        rc;

#ifdef SCE_JETDBG
    CHAR            CharTimeStamp[17];

    sprintf(CharTimeStamp, "%08x%08x", NewTimeStamp.HighPart, NewTimeStamp.LowPart);
    CharTimeStamp[16] = '\0';

    printf("New time stamp is %s\n", CharTimeStamp);
#endif

    if ( cxtProfile == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }
    //
    // set
    //
    if ( Flag ) {

        rc = SceJetSetValueInVersion(
                    cxtProfile,
                    "SmTblVersion",
                    "AnalyzeTimeStamp",
                    (PWSTR)(&NewTimeStamp), //(PWSTR)CharTimeStamp,
                    8, // 16, // number of bytes
                    JET_prepReplace
                    );
    } else {

        rc = SceJetSetValueInVersion(
                    cxtProfile,
                    "SmTblVersion",
                    "ConfigTimeStamp",
                    (PWSTR)(&NewTimeStamp), //(PWSTR)CharTimeStamp,
                    8, // 16, // number of bytes
                    JET_prepReplace
                    );
    }
    return(rc);
}


SCESTATUS
SceJetGetDescription(
    IN PSCECONTEXT   cxtProfile,
    OUT PWSTR *Description
    )
/* ++
Routine Description:

    This routine queries the profile description from the "SmTblVersion" table.

Arguments:

    cxtProfile  - The profile context

    Description - The description buffer

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR
    SCESTATUS from SceJetOpenTable

-- */
{
    SCESTATUS        rc;
    DWORD           RetLen = 0;

    if ( cxtProfile == NULL || Description == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // Open version table
    //
    rc = SceJetpGetValueFromVersion(
                cxtProfile,
                "SmTblVersion",
                "ProfileDescription",
                NULL,
                0, // number of bytes
                &RetLen
                );

    if ( rc == SCESTATUS_BUFFER_TOO_SMALL ) {

        *Description = (PWSTR)ScepAlloc( LPTR, RetLen+2 );

        if ( *Description == NULL )
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        rc = SceJetpGetValueFromVersion(
                    cxtProfile,
                    "SmTblVersion",
                    "ProfileDescription",
                    (LPSTR)(*Description),
                    RetLen, // number of bytes
                    &RetLen
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepFree( *Description );
            *Description = NULL;
        }
    }

    return(rc);
}


SCESTATUS
SceJetpGetValueFromVersion(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TableName,
    IN LPSTR ColumnName,
    OUT LPSTR Value OPTIONAL,
    IN DWORD  ValueLen, // number of bytes
    OUT PDWORD pRetLen
    )
{
    SCESTATUS   rc;
    JET_TABLEID     TableID;
    JET_ERR         JetErr;
    JET_COLUMNDEF   ColumnDef;

    //
    // Open version table
    //
    rc = SceJetOpenTable(
                    cxtProfile,
                    TableName,
                    SCEJET_TABLE_VERSION,
                    SCEJET_OPEN_READ_ONLY,
                    &TableID
                    );
    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // go to the first record
        //
        JetErr = JetMove(cxtProfile->JetSessionID,
                         TableID,
                         JET_MoveFirst,
                         0
                         );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS) {
            //
            // get column ID for "Version"
            //
            JetErr = JetGetTableColumnInfo(
                            cxtProfile->JetSessionID,
                            TableID,
                            ColumnName,
                            (VOID *)&ColumnDef,
                            sizeof(JET_COLUMNDEF),
                            0
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // retrieve the column
                //
                JetErr = JetRetrieveColumn(
                                cxtProfile->JetSessionID,
                                TableID,
                                ColumnDef.columnid,
                                (void *)Value,
                                ValueLen,
                                pRetLen,
                                0,
                                NULL
                                );
                rc = SceJetJetErrorToSceStatus(JetErr);
            }
        }
        JetCloseTable(cxtProfile->JetSessionID, TableID);
    }

    return(rc);

}


SCESTATUS
SceJetSetValueInVersion(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TableName,
    IN LPSTR ColumnName,
    IN PWSTR Value,
    IN DWORD ValueLen, // number of bytes
    IN DWORD Prep
    )
{
    SCESTATUS   rc;
    DWORD      Len;
    JET_TABLEID     TableID;
    JET_ERR         JetErr;
    JET_COLUMNDEF   ColumnDef;


    if ( cxtProfile == NULL || TableName == NULL || ColumnName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // Open version table
    //
    rc = SceJetOpenTable(
                    cxtProfile,
                    TableName,
                    SCEJET_TABLE_VERSION,
                    SCEJET_OPEN_READ_WRITE, // read and write
                    &TableID
                    );
    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // go to the first record
        //
        JetErr = JetMove(cxtProfile->JetSessionID,
                         TableID,
                         JET_MoveFirst,
                         0
                         );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS) {
            //
            // get column ID for "Version"
            //
            JetErr = JetGetTableColumnInfo(
                            cxtProfile->JetSessionID,
                            TableID,
                            ColumnName,
                            (VOID *)&ColumnDef,
                            sizeof(JET_COLUMNDEF),
                            0
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {

                JetErr = JetPrepareUpdate(cxtProfile->JetSessionID,
                                          TableID,
                                          Prep
                                          );
                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // set value
                    //

                    JetErr = JetSetColumn(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    ColumnDef.columnid,
                                    (void *)Value,
                                    ValueLen,
                                    0, //JET_bitSetOverwriteLV,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);

                    if ( rc != SCESTATUS_SUCCESS ) {
                        //
                        // if setting fails, cancel the prepared record
                        //
                        JetPrepareUpdate( cxtProfile->JetSessionID,
                                          TableID,
                                          JET_prepCancel
                                          );
                    } else {

                        //
                        // Setting columns succeed. Update the record
                        //
                        JetErr = JetUpdate( cxtProfile->JetSessionID,
                                           TableID,
                                           NULL,
                                           0,
                                           &Len
                                           );
                        rc = SceJetJetErrorToSceStatus(JetErr);
                    }
                }
            }
        }
        JetCloseTable(cxtProfile->JetSessionID, TableID);
    }

    return(rc);
}


SCESTATUS
SceJetSeek(
    IN PSCESECTION hSection,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength,
    IN SCEJET_SEEK_FLAG SeekBit
    )
{
    PWSTR LwrPrefix=NULL;
    SCESTATUS rc;
    SCEJET_SEEK_FLAG NewSeekBit;

    if ( hSection == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( LinePrefix != NULL && SeekBit > SCEJET_SEEK_GE ) {
        //
        // do lowercase search
        //
        LwrPrefix = (PWSTR)ScepAlloc(0, PrefixLength+sizeof(WCHAR));

        if ( LwrPrefix == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        } else {
            wcscpy(LwrPrefix, LinePrefix);
            LwrPrefix = _wcslwr(LwrPrefix);

            switch ( SeekBit ) {
            case SCEJET_SEEK_GT_NO_CASE:
                NewSeekBit = SCEJET_SEEK_GT;
                break;
            case SCEJET_SEEK_EQ_NO_CASE:
                NewSeekBit = SCEJET_SEEK_EQ;
                break;
            default:
                NewSeekBit = SCEJET_SEEK_GE;
                break;
            }

            rc = SceJetJetErrorToSceStatus(
                        SceJetpSeek(
                                    hSection,
                                    LwrPrefix,
                                    PrefixLength,
                                    NewSeekBit,
                                    (SeekBit == SCEJET_SEEK_GE_DONT_CARE)
                                    ));
            ScepFree(LwrPrefix);
        }
    } else {
        //
        // do case sensitive search, or NULL search
        //
        rc = SceJetJetErrorToSceStatus(
                    SceJetpSeek(
                                hSection,
                                LinePrefix,
                                PrefixLength,
                                SeekBit,
                                FALSE
                                ));
    }

    return(rc);

}

SCESTATUS
SceJetMoveNext(
    IN PSCESECTION hSection
    )
{
    JET_ERR  JetErr;
    INT      Result;

    if ( hSection == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // skip deleted records
    //
    do {
        JetErr = JetMove(hSection->JetSessionID,
                         hSection->JetTableID,
                         JET_MoveNext,
                         0
                         );
        if ( JetErr == JET_errSuccess ) {
            // compare section ID
            JetErr = SceJetpCompareLine(
                hSection,
                JET_bitSeekGE,
                NULL,
                0,
                &Result,
                NULL
                );
            if ( JetErr == JET_errSuccess && Result != 0 )
                JetErr = JET_errRecordNotFound;

        }

    } while ( JetErr == JET_errRecordDeleted );


    return(SceJetJetErrorToSceStatus(JetErr));

}

/*

SCESTATUS
SceJetRenameLine(
    IN PSCESECTION hSection,
    IN PWSTR      Name,
    IN PWSTR      NewName,
    IN BOOL       bReserveCase
    )
{
    PWSTR       LwrName=NULL;
    DWORD       Len;
    JET_ERR     JetErr;
    JET_SETINFO SetInfo;


    if ( !hSection || !Name || !NewName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    Len = wcslen(NewName)*sizeof(WCHAR);

    if ( Len <= 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( bReserveCase ) {
        LwrName = NewName;

    } else {
        //
        // lower cased
        //
        LwrName = (PWSTR)ScepAlloc(0, Len+2);
        if ( LwrName == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
        wcscpy(LwrName, NewName);
        LwrName = _wcslwr(LwrName);

    }

    SetInfo.cbStruct = sizeof(JET_SETINFO);
    SetInfo.itagSequence = 1;
    SetInfo.ibLongValue = 0;

    //
    // check to see if the same key name already exists
    //
    JetErr = SceJetSeek(
                    hSection,
                    Name,
                    wcslen(Name)*sizeof(WCHAR),
                    SCEJET_SEEK_EQ_NO_CASE
                    );

    if ( JetErr == JET_errSuccess ) {
        //
        // find a match. overwrite the value
        //
        JetErr = JetBeginTransaction(hSection->JetSessionID);

        if ( JetErr == JET_errSuccess ) {
            JetErr = JetPrepareUpdate(hSection->JetSessionID,
                                      hSection->JetTableID,
                                      JET_prepReplace
                                      );
            if ( JetErr == JET_errSuccess ) {
                //
                // set the new key in "Name" column
                //
                JetErr = JetSetColumn(
                                hSection->JetSessionID,
                                hSection->JetTableID,
                                hSection->JetColumnNameID,
                                (void *)LwrName,
                                Len,
                                JET_bitSetOverwriteLV,
                                &SetInfo
                                );
            }

            if ( JET_errSuccess == JetErr ) {
                //
                // commit the transaction
                //
                JetCommitTransaction(hSection->JetSessionID, JET_bitCommitLazyFlush);
            } else {
                //
                // rollback the transaction
                //
                JetRollback(hSection->JetSessionID,0);
            }
            JetPrepareUpdate(hSection->JetSessionID,
                              hSection->JetTableID,
                              JET_prepCancel
                              );
        }
    }

    if ( LwrName != NewName ) {
        ScepFree(LwrName);
    }

    return( SceJetJetErrorToSceStatus(JetErr) );
}
*/



SCESTATUS
SceJetRenameLine(
    IN PSCESECTION hSection,
    IN PWSTR      Name,
    IN PWSTR      NewName,
    IN BOOL       bReserveCase
    )
{
    PWSTR       Value=NULL;
    DWORD       ValueLen;
    SCESTATUS   rc;
    JET_ERR     JetErr;


    if ( !hSection || !Name || !NewName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                Name,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueLen
                );

    if ( SCESTATUS_SUCCESS == rc ) {
        //
        // continue only when this record is found.
        //
        if ( ValueLen ) {
            Value = (PWSTR)ScepAlloc(0, ValueLen+2);

            if ( Value ) {
                rc = SceJetGetValue(
                            hSection,
                            SCEJET_CURRENT,
                            NULL,
                            NULL,
                            0,
                            NULL,
                            Value,
                            ValueLen,
                            &ValueLen
                            );
            } else
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }

        if ( SCESTATUS_SUCCESS == rc ) {

            JetErr = JetBeginTransaction(hSection->JetSessionID);

            if ( JetErr == JET_errSuccess ) {
                //
                // now delete this line
                //
                rc = SceJetDelete(hSection, NULL, FALSE, SCEJET_DELETE_LINE);

                if ( SCESTATUS_SUCCESS == rc ) {
                    //
                    // add the new line in.
                    //
                    rc = SceJetSetLine(
                            hSection,
                            NewName,
                            bReserveCase,
                            Value,
                            ValueLen,
                            0
                            );
                }

                if ( SCESTATUS_SUCCESS == rc ) {
                    //
                    // commit the transaction
                    //
                    JetCommitTransaction(hSection->JetSessionID, JET_bitCommitLazyFlush);
                } else {
                    //
                    // rollback the transaction
                    //
                    JetRollback(hSection->JetSessionID,0);
                }
            } else
                rc = SceJetJetErrorToSceStatus(JetErr);

        }
    }

    return( rc );
}

//////////////////////////////////////////////////////////////
//
//  Helpers
//
//////////////////////////////////////////////////////////////

VOID
SceJetInitializeData()
//
// only be called during server initialization code
//
{
   JetInited = FALSE;
   JetInstance = 0;
}

SCESTATUS
SceJetInitialize(
    OUT JET_ERR *pJetErr OPTIONAL
    )
/*
Routine Description:

    Initialize jet engine for sce server

Arguments:

    None

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc=SCESTATUS_SUCCESS;
    JET_ERR JetErr=0;

    //
    // cancel any pending timer queue
    //
    ScepServerCancelTimer();

    EnterCriticalSection(&JetSync);

    if ( !JetInited ) {

        //
        // set system configuration for Jet engine
        //
        rc = SceJetpConfigJetSystem( &JetInstance);
        if ( SCESTATUS_SUCCESS == rc ) {

            //
            // initialize jet engine
            //
            __try {

                JetErr = JetInit(&JetInstance);

                JetInitAttempted = TRUE;

                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( JetErr == JET_errSuccess ) {

                    JetInited = TRUE;

                    //
                    // if failed to initialize Jet writer (for backup/restore)
                    // don't fail the engine
                    //
                } else {

                    //
                    // this will happen only if jet cannot recover the
                    // database by itself (JetInit() claims to attempt recovery only)
                    // repair might help - so only spew out a message advising the user
                    //
                    // map error so setup/policy propagation clients
                    // can log events
                    //

//                    if ( SCE_JET_CORRUPTION_ERROR(JetErr) ) {

                        rc = SCESTATUS_JET_DATABASE_ERROR;

                        ScepLogOutput3(0, ERROR_DATABASE_FAILURE, SCEDLL_ERROR_RECOVER_DB );
//                    }
                    JetInstance = 0;
                }

            } __except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // for some reason, esent is not loaded
                //
                rc = SCESTATUS_MOD_NOT_FOUND;
                JetInstance = 0;
            }

        } else {
            JetInstance = 0;
        }
    }

    LeaveCriticalSection(&JetSync);

    if ( pJetErr ) *pJetErr = JetErr;

    return(rc);
}


SCESTATUS
SceJetTerminate(BOOL bCleanVs)
/*
Routine Description:

    Terminate jet engine

Arguments:

    bCleanVs  - if to clean up the version store completely

Return Value:

    SCESTATUS
*/
{

    EnterCriticalSection(&JetSync);

    //
    // destroy the jet backup/restore writer
    //
    if ( JetInited || JetInstance ) {

        if ( bCleanVs ) {
            //
            // clean up version store
            //
            JetTerm2(JetInstance, JET_bitTermComplete);
        } else {
            //
            // do not clean up version store
            //
            JetTerm(JetInstance);
        }
        JetInstance = 0;
        JetInited = FALSE;
    }

    LeaveCriticalSection(&JetSync);

    return(SCESTATUS_SUCCESS);
}

SCESTATUS
SceJetTerminateNoCritical(BOOL bCleanVs)
/*
Routine Description:

    Terminate jet engine, NOT critical sectioned!!!

Arguments:

    bCleanVs  - if to clean up the version store completely

Return Value:

    SCESTATUS
*/
{
    //
    // the critical section is entered outside of this function
    //
    // destroy the jet backup/restore writer
    //
    if ( JetInited || JetInstance ) {

        if ( bCleanVs ) {
            //
            // clean up version store
            //
            JetTerm2(JetInstance, JET_bitTermComplete);
        } else {
            //
            // do not clean up version store
            //
            JetTerm(JetInstance);
        }
        JetInstance = 0;
        JetInited = FALSE;
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
SceJetStartTransaction(
    IN PSCECONTEXT cxtProfile
    )
/*
Routine Description:

    Start a transaction on the session

Arguments:

    cxtProfile  - the database context

Return Value:

    SCESTATUS
*/
{
    JET_ERR  JetErr;

    if ( cxtProfile == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    JetErr = JetBeginTransaction( cxtProfile->JetSessionID);

    return( SceJetJetErrorToSceStatus(JetErr));

}

SCESTATUS
SceJetCommitTransaction(
    IN PSCECONTEXT cxtProfile,
    IN JET_GRBIT grbit
    )
/*
Routine Description:

    Commit a transaction on the session

Arguments:

    cxtProfile  - the database context

    grbit       - flag for the commission

Return Value:

    SCESTATUS
*/
{
    JET_ERR     JetErr;

    if ( cxtProfile == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    JetErr = JetCommitTransaction(cxtProfile->JetSessionID, grbit );

    return( SceJetJetErrorToSceStatus(JetErr) );

}

SCESTATUS
SceJetRollback(
    IN PSCECONTEXT cxtProfile,
    IN JET_GRBIT grbit
    )
/*
Routine Description:

    Rollback a transaction on the session

Arguments:

    cxtProfile  - the database context

    grbit       - the flag for transaction rollback

Return Value:

    SCESTATUS
*/
{
    JET_ERR     JetErr;

    if ( cxtProfile == NULL )
        return(SCESTATUS_SUCCESS);

    __try {
        JetErr = JetRollback(cxtProfile->JetSessionID, grbit);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        JetErr = JET_errOutOfMemory;
    }
    return( SceJetJetErrorToSceStatus(JetErr) );

}


BOOL
SceJetDeleteJetFiles(
    IN PWSTR DbFileName
    )
{
   TCHAR TempFileName[MAX_PATH];
   PWSTR SysRoot=NULL;
   DWORD SysLen;
   DWORD rc;
   intptr_t            hFile;
   struct _wfinddata_t    fInfo;


   BOOL bRet = FALSE;

   EnterCriticalSection(&JetSync);

   if ( JetInitAttempted == TRUE && 
        JetInited == FALSE ) {

       SysLen =  0;
       rc = ScepGetNTDirectory( &SysRoot, &SysLen, SCE_FLAG_WINDOWS_DIR );

       if ( rc == NO_ERROR && SysRoot != NULL ) {

           swprintf(TempFileName, L"%s\\Security\\res1.log\0", SysRoot);
           TempFileName[MAX_PATH-1] = L'\0';

           DeleteFile(TempFileName);

           swprintf(TempFileName, L"%s\\Security\\res2.log\0", SysRoot);
           TempFileName[MAX_PATH-1] = L'\0';

           DeleteFile(TempFileName);

           //
           // delete edb files
           //
           swprintf(TempFileName, L"%s\\Security\\edb*.*\0", SysRoot);
           TempFileName[MAX_PATH-1] = L'\0';

           hFile = _wfindfirst(TempFileName, &fInfo);

           if ( hFile != -1 ) {

               do {

                   swprintf(TempFileName, L"%s\\Security\\%s\0", SysRoot, fInfo.name);
                   TempFileName[MAX_PATH-1] = L'\0';

                   DeleteFile(TempFileName);

               } while ( _wfindnext(hFile, &fInfo) == 0 );

               _findclose(hFile);
           }

           //
           // delete temp files
           //
           swprintf(TempFileName, L"%s\\Security\\tmp*.edb\0", SysRoot);
           TempFileName[MAX_PATH-1] = L'\0';

           hFile = _wfindfirst(TempFileName, &fInfo);

           if ( hFile != -1 ) {

               do {

                   swprintf(TempFileName, L"%s\\Security\\%s\0", SysRoot, fInfo.name);
                   TempFileName[MAX_PATH-1] = L'\0';

                   DeleteFile(TempFileName);

               } while ( _wfindnext(hFile, &fInfo) == 0 );

               _findclose(hFile);
           }

           ScepFree(SysRoot);

           //
           // delete the database file if it's passed in.
           //
           if ( DbFileName ) {
               DeleteFile(DbFileName);
           }

           bRet = TRUE;

       }
   }

   LeaveCriticalSection(&JetSync);

   return(bRet);

}


SCESTATUS
SceJetSetCurrentLine(
    IN PSCESECTION hSection,
    IN PWSTR      Value,
    IN DWORD      ValueLen
    )
/* ++
Fucntion Description:

    This routine writes the Value to the current line in section (hSection).
    Make sure the cursor is on the right line before calling this API

Arguments:

    hSection    - The context handle of the section

    Value       - The info set to Column "Value"

    ValueLen    - The size of the value field.

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_OTHER_ERROR
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_DATA_OVERFLOW

-- */
{
    JET_ERR     JetErr;
    DWORD       Len;
    SCESTATUS    rc;
    DWORD       prep;
    JET_SETINFO SetInfo;

    if ( hSection == NULL ||
         Value == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SetInfo.cbStruct = sizeof(JET_SETINFO);
    SetInfo.itagSequence = 1;
    SetInfo.ibLongValue = 0;

    prep = JET_prepReplace;

    JetErr = JetBeginTransaction(hSection->JetSessionID);

    if ( JetErr == JET_errSuccess ) {
        JetErr = JetPrepareUpdate(hSection->JetSessionID,
                                  hSection->JetTableID,
                                  prep
                                  );
        if ( JetErr != JET_errSuccess ) {
            //
            // rollback the transaction
            //
            JetRollback(hSection->JetSessionID,0);
        }
    }

    if ( JetErr != JET_errSuccess)
        return(SceJetJetErrorToSceStatus(JetErr));


    //
    // set value column
    //

    JetErr = JetSetColumn(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    hSection->JetColumnValueID,
                    (void *)Value,
                    ValueLen,
                    0, //JET_bitSetOverwriteLV,
                    &SetInfo
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( JetErr == JET_errSuccess ) {
        //
        // Setting columns succeed. Update the record
        //
        JetErr = JetUpdate(hSection->JetSessionID,
                           hSection->JetTableID,
                           NULL,
                           0,
                           &Len
                           );
    } else {
        goto CleanUp;
    }

    if ( rc == SCESTATUS_SUCCESS )
        JetCommitTransaction(hSection->JetSessionID, JET_bitCommitLazyFlush);

CleanUp:

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // if setting fails, cancel the prepared record
        //
        JetPrepareUpdate(hSection->JetSessionID,
                          hSection->JetTableID,
                          JET_prepCancel
                          );
        //
        // Rollback the transaction
        //
        JetRollback(hSection->JetSessionID,0);

    }

    return(rc);

}


BOOL
ScepIsValidContext(
    PSCECONTEXT context
    )
{
    if ( context == NULL ) {
        return FALSE;
    }

    __try {

        if ( (context->Type & 0xFFFFFF02L) == 0xFFFFFF02L ) {

            return TRUE;

        } else {

            return FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        return FALSE;
    }

}


LONG
SceJetGetGpoIDByName(
    IN PSCECONTEXT cxtProfile,
    IN PWSTR       szGpoName,
    IN BOOL        bAdd
    )
/*
Routine Description:

    Search for a GPO by name in the GPO table. If bAdd is TRUE and the GPO name
    is not found, it will be added to the GPO table

Arguments:

    cxtProfile    - the database handle

    szGpoName   - the GPO name

    bAdd        - TRUE to add the GPO name to the GPO table if it's not found

Return Value:

    The GPO ID. If -1 is returned, GetLastError to get the SCE error code.

*/
{


    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Actual;
    PWSTR     LwrName=NULL;
    DWORD     Len;

    if ( cxtProfile == NULL || szGpoName == NULL ||
         szGpoName[0] == L'\0' ) {

        SetLastError(SCESTATUS_INVALID_PARAMETER);
        return (-1);
    }

    JET_TABLEID  TableID;

    rc = SceJetOpenTable(
                    cxtProfile,
                    "SmTblGpo",
                    SCEJET_TABLE_GPO,
                    bAdd ? SCEJET_OPEN_READ_WRITE : SCEJET_OPEN_READ_ONLY,
                    &TableID
                    );

    if ( rc != SCESTATUS_SUCCESS ) {
        SetLastError(rc);
        return(-1);
    }

    JET_COLUMNDEF ColumnDef;
    LONG GpoID = 0;

    JetErr = JetGetTableColumnInfo(
                    cxtProfile->JetSessionID,
                    TableID,
                    "GpoID",
                    (VOID *)&ColumnDef,
                    sizeof(JET_COLUMNDEF),
                    JET_ColInfo
                    );

    if ( JET_errSuccess == JetErr ) {

        //
        // set current index to SectionKey (the name)
        //
        JetErr = JetSetCurrentIndex(
                    cxtProfile->JetSessionID,
                    TableID,
                    "GpoName"
                    );

    }

    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // search for the name
        //
        Len = wcslen(szGpoName);
        LwrName = (PWSTR)ScepAlloc(0, (Len+1)*sizeof(WCHAR));

        if ( LwrName != NULL ) {

            wcscpy(LwrName, szGpoName);
            LwrName = _wcslwr(LwrName);

            JetErr = JetMakeKey(
                        cxtProfile->JetSessionID,
                        TableID,
                        (VOID *)LwrName,
                        Len*sizeof(WCHAR),
                        JET_bitNewKey
                        );

            if ( JetErr == JET_errKeyIsMade ) {
                //
                // Only one key is needed, it may return this code, even on success.
                //
                JetErr = JET_errSuccess;
            }
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {

                JetErr = JetSeek(
                            cxtProfile->JetSessionID,
                            TableID,
                            JET_bitSeekEQ
                            );
                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // find the Gpo name, retrieve gpo id
                    //
                    JetErr = JetRetrieveColumn(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    ColumnDef.columnid,
                                    (void *)&GpoID,
                                    4,
                                    &Actual,
                                    0,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);

                } else if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {

                    GpoID = 0;
                    rc = SCESTATUS_SUCCESS;

                    if ( bAdd ) {

                        //
                        // if not found and add is requested
                        //
                        rc = SceJetpAddGpo(cxtProfile,
                                          TableID,
                                          ColumnDef.columnid,
                                          LwrName,
                                          &GpoID
                                         );
                    }

                }

            }

            ScepFree(LwrName);

        } else
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    JetCloseTable( cxtProfile->JetSessionID, TableID );

    if ( rc != SCESTATUS_SUCCESS ) {
        SetLastError(rc);
        GpoID = -1;
    }

    return(GpoID);

}


SCESTATUS
SceJetGetGpoNameByID(
    IN PSCECONTEXT cxtProfile,
    IN LONG GpoID,
    OUT PWSTR Name OPTIONAL,
    IN OUT LPDWORD pNameLen,
    OUT PWSTR DisplayName OPTIONAL,
    IN OUT LPDWORD pDispNameLen
    )
/* ++
Routine Description:

    This routine retrieve the GPO name for the ID in the GPO table.
    If Name is NULL, this routine really does a seek by ID. The cursor will
    be on the record if there is a successful match.

Arguments:

    cxtProfile  - The profile context handle

    GpoID       - The GPO ID looking for

    Name        - The optional output buffer for section name

    pNameLen    - The name buffer's length


Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_RECORD_NOT_FOUND
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR

-- */
{
    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Actual;


    if ( cxtProfile == NULL ||
         ( pDispNameLen == NULL && pNameLen == NULL) ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( GpoID <= 0 ) {
        return(SCESTATUS_RECORD_NOT_FOUND);
    }

    //
    // reset buffers
    //
    if ( Name == NULL && pNameLen ) {
        *pNameLen = 0;
    }

    if ( DisplayName == NULL && pDispNameLen ) {
        *pDispNameLen = 0;
    }

    JET_TABLEID  TableID=0;

    //
    // Open GPO table
    //
    rc = SceJetOpenTable(
                    cxtProfile,
                    "SmTblGpo",
                    SCEJET_TABLE_GPO,
                    SCEJET_OPEN_READ_ONLY,
                    &TableID
                    );

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // set current index to SecID (the ID)
    //
    JetErr = JetSetCurrentIndex(
                cxtProfile->JetSessionID,
                TableID,
                "SectionKey"
                );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {

        JetErr = JetMakeKey(
                    cxtProfile->JetSessionID,
                    TableID,
                    (void *)(&GpoID),
                    4,
                    JET_bitNewKey
                    );

        if ( JetErr == JET_errKeyIsMade ) {
            //
            // Only one key is needed, it may return this code, even on success.
            //
            JetErr = JET_errSuccess;
        }
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {

            JetErr = JetSeek(
                        cxtProfile->JetSessionID,
                        TableID,
                        JET_bitSeekEQ
                        );
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {

                //
                // find the GPO ID, retrieve column Name if requested
                //

                if ( pNameLen != NULL ) {

                    JET_COLUMNDEF ColumnDef;

                    JetErr = JetGetTableColumnInfo(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    "Name",
                                    (VOID *)&ColumnDef,
                                    sizeof(JET_COLUMNDEF),
                                    JET_ColInfo
                                    );

                    rc = SceJetJetErrorToSceStatus(JetErr);

                    if ( SCESTATUS_SUCCESS == rc ) {

                        JetErr = JetRetrieveColumn(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    ColumnDef.columnid,
                                    (void *)Name,
                                    *pNameLen,
                                    &Actual,
                                    0,
                                    NULL
                                    );
                        *pNameLen = Actual;
                    }

                    rc = SceJetJetErrorToSceStatus(JetErr);
                }

                //
                // retrieve column DisplayName if requested
                //

                if ( ( SCESTATUS_SUCCESS == rc) &&
                     ( pDispNameLen != NULL) ) {

                    JET_COLUMNDEF ColumnDef;

                    JetErr = JetGetTableColumnInfo(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    "DisplayName",
                                    (VOID *)&ColumnDef,
                                    sizeof(JET_COLUMNDEF),
                                    JET_ColInfo
                                    );

                    rc = SceJetJetErrorToSceStatus(JetErr);

                    if ( SCESTATUS_SUCCESS == rc ) {

                        JetErr = JetRetrieveColumn(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    ColumnDef.columnid,
                                    (void *)DisplayName,
                                    *pDispNameLen,
                                    &Actual,
                                    0,
                                    NULL
                                    );
                        *pDispNameLen = Actual;
                    }

                    rc = SceJetJetErrorToSceStatus(JetErr);
                }
            }
        }

    }

    JetCloseTable( cxtProfile->JetSessionID, TableID);

    return(rc);

}


SCESTATUS
SceJetpAddGpo(
    IN PSCECONTEXT cxtProfile,
    IN JET_TABLEID TableID,
    IN JET_COLUMNID GpoIDColumnID,
    IN PCWSTR      Name,
    OUT LONG       *pGpoID
    )
/* ++
Routine Description:

Arguments:

Return Value:

-- */
{
    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Len;

    if ( cxtProfile == NULL ||
         Name == NULL ||
        pGpoID == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    *pGpoID = 0;

    //
    // get the next available GPO ID first.
    // set current index to the ID
    //
    JetErr = JetSetCurrentIndex(
                cxtProfile->JetSessionID,
                TableID,
                "SectionKey"
                );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // Move to the last record
    //
    JetErr = JetMove(
                  cxtProfile->JetSessionID,
                  TableID,
                  JET_MoveLast,
                  0
                  );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // find the GPO ID, retrieve column Name
        //
        JetErr = JetRetrieveColumn(
                    cxtProfile->JetSessionID,
                    TableID,
                    GpoIDColumnID,
                    (void *)pGpoID,
                    4,
                    &Len,
                    0,
                    NULL
                    );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // The next available ID is current ID + 1
            //
            *pGpoID = *pGpoID + 1;
        }

    } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

        *pGpoID = 1;
        rc = SCESTATUS_SUCCESS;
    }

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // add a record to the GPO table
        //
        JetErr = JetPrepareUpdate(cxtProfile->JetSessionID,
                                  TableID,
                                  JET_prepInsert
                                  );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // set GpoID
            //

            JetErr = JetSetColumn(
                            cxtProfile->JetSessionID,
                            TableID,
                            GpoIDColumnID,
                            (void *)pGpoID,
                            4,
                            0, //JET_bitSetOverwriteLV,
                            NULL
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // set Name column
                //

                JET_COLUMNDEF ColumnDef;

                JetErr = JetGetTableColumnInfo(
                                cxtProfile->JetSessionID,
                                TableID,
                                "Name",
                                (VOID *)&ColumnDef,
                                sizeof(JET_COLUMNDEF),
                                JET_ColInfo
                                );

                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( SCESTATUS_SUCCESS == rc ) {

                    Len = wcslen(Name)*sizeof(WCHAR);

                    JetErr = JetSetColumn(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    ColumnDef.columnid,
                                    (void *)Name,
                                    Len,
                                    0,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);
                }

            }

            if ( rc != SCESTATUS_SUCCESS ) {
                //
                // if setting fails, cancel the prepared record
                //
                JetPrepareUpdate( cxtProfile->JetSessionID,
                                  TableID,
                                  JET_prepCancel
                                  );
            } else {

                //
                // Setting columns succeed. Update the record
                //
                JetErr = JetUpdate(cxtProfile->JetSessionID,
                                   TableID,
                                   NULL,
                                   0,
                                   &Len
                                   );
                rc = SceJetJetErrorToSceStatus(JetErr);
            }
        }
    }

    return(rc);
}

//
// request the GPO ID (if there is any) for the object
//
SCESTATUS
SceJetGetGpoID(
    IN PSCESECTION hSection,
    IN PWSTR      ObjectName,
    IN JET_COLUMNID JetColGpoID OPTIONAL,
    OUT LONG      *pGpoID
    )
{
    if ( hSection == NULL || ObjectName == NULL || pGpoID == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    *pGpoID = 0;

    JET_COLUMNID  ColGpoID = 0;

    if ( JetColGpoID == 0 ) {

        ColGpoID = hSection->JetColumnGpoID;
    } else {
        ColGpoID = JetColGpoID;
    }

    if ( ColGpoID > 0 ) {

        rc = SceJetSeek(
                    hSection,
                    ObjectName,
                    wcslen(ObjectName)*sizeof(WCHAR),
                    SCEJET_SEEK_EQ_NO_CASE
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            DWORD Actual;
            JET_ERR JetErr;

            JetErr = JetRetrieveColumn(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            ColGpoID,
                            (void *)pGpoID,
                            4,
                            &Actual,
                            0,
                            NULL
                            );
            if ( JET_errSuccess != JetErr ) {
                //
                // if the column is nil (no value), it will return warning
                // but the buffer pGpoID is trashed
                //
                *pGpoID = 0;
            }

            rc = SceJetJetErrorToSceStatus(JetErr);
        }

    } else {
        rc = SCESTATUS_RECORD_NOT_FOUND;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\scejetp.h ===
/*++
Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    scejetp.h

Abstract:

    Header for scejet.c - Sce-Jet service APIs

Author:


Revision History:


--*/

#ifndef _SCEJETP_
#define _SCEJETP_

#include <esent.h>

#ifdef __cplusplus
extern "C" {
#endif
//
// type used when open a table and a section
//
typedef enum _SCEJET_TABLE_TYPE {

    SCEJET_TABLE_SCP,
    SCEJET_TABLE_SAP,
    SCEJET_TABLE_SMP,
    SCEJET_TABLE_VERSION,
    SCEJET_TABLE_SECTION,
    SCEJET_TABLE_GPO,
    SCEJET_TABLE_TATTOO

} SCEJET_TABLE_TYPE;

typedef enum _SCEJET_CREATE_FLAG {

    SCEJET_CREATE_IN_BUFFER,
    SCEJET_CREATE_NO_TABLEID

} SCEJET_CREATE_FLAG;

//
// type used when open a database file
//
typedef enum _SCEJET_OPEN_TYPE {

    SCEJET_OPEN_READ_WRITE=0,
    SCEJET_OPEN_EXCLUSIVE,
    SCEJET_OPEN_READ_ONLY,
    SCEJET_OPEN_NOCHECK_VERSION

} SCEJET_OPEN_TYPE;

//
// type used when create a database file
//
typedef enum _SCEJET_CREATE_TYPE {

    SCEJET_RETURN_ON_DUP=0,
    SCEJET_OVERWRITE_DUP,
    SCEJET_OPEN_DUP,
    SCEJET_OPEN_DUP_EXCLUSIVE

} SCEJET_CREATE_TYPE;

//
// type used when delete lines
//
typedef enum _SCEJET_DELETE_TYPE {

    SCEJET_DELETE_LINE=0,
    SCEJET_DELETE_LINE_NO_CASE,
    SCEJET_DELETE_PARTIAL,
    SCEJET_DELETE_PARTIAL_NO_CASE,
    SCEJET_DELETE_SECTION

} SCEJET_DELETE_TYPE;

//
// type used when find a line
//
typedef enum _SCEJET_FIND_TYPE {
    SCEJET_CURRENT=0,
    SCEJET_EXACT_MATCH,
    SCEJET_PREFIX_MATCH,
    SCEJET_NEXT_LINE,
    SCEJET_CLOSE_VALUE,
    SCEJET_EXACT_MATCH_NO_CASE,
    SCEJET_PREFIX_MATCH_NO_CASE

} SCEJET_FIND_TYPE;


typedef enum _SCEJET_SEEK_FLAG {

    SCEJET_SEEK_GT=0,
    SCEJET_SEEK_EQ,
    SCEJET_SEEK_GE,
    SCEJET_SEEK_GT_NO_CASE,
    SCEJET_SEEK_EQ_NO_CASE,
    SCEJET_SEEK_GE_NO_CASE,
    SCEJET_SEEK_GE_DONT_CARE

} SCEJET_SEEK_FLAG;

#define SCEJET_PREFIX_MAXLEN     1024

typedef struct _SCE_CONTEXT {
    DWORD       Type;
    JET_SESID   JetSessionID;
    JET_DBID    JetDbID;
    SCEJET_OPEN_TYPE   OpenFlag;
    // scp table
    JET_TABLEID  JetScpID;
    JET_COLUMNID JetScpSectionID;
    JET_COLUMNID JetScpNameID;
    JET_COLUMNID JetScpValueID;
    JET_COLUMNID JetScpGpoID;
    // sap table
    JET_TABLEID  JetSapID;
    JET_COLUMNID JetSapSectionID;
    JET_COLUMNID JetSapNameID;
    JET_COLUMNID JetSapValueID;
    // smp table
    JET_TABLEID  JetSmpID;
    JET_COLUMNID JetSmpSectionID;
    JET_COLUMNID JetSmpNameID;
    JET_COLUMNID JetSmpValueID;
    // section table
    JET_TABLEID  JetTblSecID;
    JET_COLUMNID JetSecNameID;
    JET_COLUMNID JetSecID;
} SCECONTEXT, *PSCECONTEXT;

typedef struct _SCE_SECTION {
    JET_SESID   JetSessionID;
    JET_DBID    JetDbID;
    JET_TABLEID JetTableID;
    JET_COLUMNID JetColumnSectionID;
    JET_COLUMNID JetColumnNameID;
    JET_COLUMNID JetColumnValueID;
    JET_COLUMNID JetColumnGpoID;
    DOUBLE   SectionID;
} SCESECTION, *PSCESECTION;



//
// To Open existing profile database.
//
#define SCE_TABLE_OPTION_MERGE_POLICY           0x1
#define SCE_TABLE_OPTION_TATTOO                 0x2
#define SCE_TABLE_OPTION_DEMOTE_TATTOO          0x4

SCESTATUS
SceJetOpenFile(
    IN LPSTR        ProfileFileName,
    IN SCEJET_OPEN_TYPE Flags,
    IN DWORD        dwTableOptions,
    OUT PSCECONTEXT   *hProfile
    );

//
// To create a new profile
//
SCESTATUS
SceJetCreateFile(
    IN LPSTR      ProfileFileName,
    IN SCEJET_CREATE_TYPE    Flags,
    IN DWORD        dwTableOptions,
    OUT PSCECONTEXT *hProfile
    );

//
// close the profile database.
//
SCESTATUS
SceJetCloseFile(
    IN PSCECONTEXT   hProfile,
    IN BOOL         TermSession,
    IN BOOL         Terminate
    );

//
// To Open a section in the profile.
//
SCESTATUS
SceJetOpenSection(
    IN PSCECONTEXT    hProfile,
    IN DOUBLE        SectionID,
    IN SCEJET_TABLE_TYPE    tblType,
    OUT PSCESECTION   *hSection
    );

//
// To get line count in the section.
//
SCESTATUS
SceJetGetLineCount(
    IN PSCESECTION hSection,
    IN PWSTR      LinePrefix OPTIONAL,
    IN BOOL       bExactCase,
    OUT DWORD      *Count
    );

//
// To delete a section or current line
//
SCESTATUS
SceJetDelete(
    IN PSCESECTION  hSection,
    IN PWSTR        LinePrefix,
    IN BOOL         bObjectFolder,
    IN SCEJET_DELETE_TYPE   Flags
    );

SCESTATUS
SceJetDeleteAll(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TblName OPTIONAL,
    IN SCEJET_TABLE_TYPE  TblType
    );

//
// close a section context.
//
SCESTATUS
SceJetCloseSection(
    IN PSCESECTION   *hSection,
    IN BOOL         DestroySection
    );

//
// To get the line matching the name in the section.
//
SCESTATUS
SceJetGetValue(
    IN PSCESECTION hSection,
    IN SCEJET_FIND_TYPE    Flags,
    IN PWSTR      LinePrefix OPTIONAL,
    IN PWSTR      ActualName  OPTIONAL,
    IN DWORD      NameBufLen,
    OUT DWORD      *RetNameLen OPTIONAL,
    IN PWSTR      Value       OPTIONAL,
    IN DWORD      ValueBufLen,
    OUT DWORD      *RetValueLen OPTIONAL
    );

//
// To set a line in the section (placed alphabetically by the name)
//
SCESTATUS
SceJetSetLine(
    IN PSCESECTION hSection,
    IN PWSTR      Name,
    IN BOOL       bReserveCase,
    IN PWSTR      Value,
    IN DWORD      ValueLen,
    IN LONG       GpoID
    );

//
// other helper APIs
//

SCESTATUS
SceJetCreateTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType,
    IN SCEJET_CREATE_FLAG nFlags,
    IN JET_TABLEID *TableID OPTIONAL,
    IN JET_COLUMNID *ColumnID OPTIONAL
    );

SCESTATUS
SceJetOpenTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType,
    IN SCEJET_OPEN_TYPE OpenType,
    OUT JET_TABLEID *TableID
    );

SCESTATUS
SceJetDeleteTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType
    );

SCESTATUS
SceJetCheckVersion(
    IN PSCECONTEXT   cxtProfile,
    OUT FLOAT *pVersion OPTIONAL
    );

SCESTATUS
SceJetGetSectionIDByName(
    IN PSCECONTEXT cxtProfile,
    IN PCWSTR Name,
    OUT DOUBLE *SectionID
    );

SCESTATUS
SceJetGetSectionNameByID(
    IN PSCECONTEXT cxtProfile,
    IN DOUBLE SectionID,
    OUT PWSTR Name OPTIONAL,
    IN OUT LPDWORD pNameLen OPTIONAL
    );

SCESTATUS
SceJetAddSection(
    IN PSCECONTEXT cxtProfile,
    IN PCWSTR      Name,
    OUT DOUBLE *SectionID
    );

SCESTATUS
SceJetDeleteSectionID(
    IN PSCECONTEXT cxtProfile,
    IN DOUBLE SectionID,
    IN PCWSTR  Name
    );

SCESTATUS
SceJetGetTimeStamp(
    IN PSCECONTEXT   cxtProfile,
    OUT PLARGE_INTEGER ConfigTimeStamp,
    OUT PLARGE_INTEGER AnalyzeTimeStamp
    );

SCESTATUS
SceJetSetTimeStamp(
    IN PSCECONTEXT   cxtProfile,
    IN BOOL         Flag,
    IN LARGE_INTEGER NewTimeStamp
    );

SCESTATUS
SceJetGetDescription(
    IN PSCECONTEXT   cxtProfile,
    OUT PWSTR *Description
    );

SCESTATUS
SceJetStartTransaction(
    IN PSCECONTEXT cxtProfile
    );

SCESTATUS
SceJetCommitTransaction(
    IN PSCECONTEXT cxtProfile,
    IN JET_GRBIT grbit
    );

SCESTATUS
SceJetRollback(
    IN PSCECONTEXT cxtProfile,
    IN JET_GRBIT grbit
    );

SCESTATUS
SceJetSetValueInVersion(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TableName,
    IN LPSTR ColumnName,
    IN PWSTR Value,
    IN DWORD ValueLen, // number of bytes
    IN DWORD Prep
    );

SCESTATUS
SceJetSeek(
    IN PSCESECTION hSection,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength,
    IN SCEJET_SEEK_FLAG SeekBit
    );

SCESTATUS
SceJetMoveNext(
    IN PSCESECTION hSection
    );

SCESTATUS
SceJetJetErrorToSceStatus(
    IN JET_ERR  JetErr
    );

SCESTATUS
SceJetRenameLine(
    IN PSCESECTION hSection,
    IN PWSTR      Name,
    IN PWSTR      NewName,
    IN BOOL       bReserveCase
    );

SCESTATUS
SceJetInitialize(OUT JET_ERR *pJetErr OPTIONAL);


SCESTATUS
SceJetTerminate(BOOL bCleanVs);

SCESTATUS
SceJetTerminateNoCritical(BOOL bCleanVs);

VOID
SceJetInitializeData();

BOOL
SceJetDeleteJetFiles(
    IN PWSTR DbFileName OPTIONAL
    );

SCESTATUS
SceJetSetCurrentLine(
    IN PSCESECTION hSection,
    IN PWSTR      Value,
    IN DWORD      ValueLen
    );

#define SCEJET_MERGE_TABLE_1        0x10L
#define SCEJET_MERGE_TABLE_2        0x20L
#define SCEJET_LOCAL_TABLE          0x30L

BOOL
ScepIsValidContext(
    PSCECONTEXT context
    );

SCESTATUS
SceJetGetGpoNameByID(
    IN PSCECONTEXT cxtProfile,
    IN LONG GpoID,
    OUT PWSTR Name OPTIONAL,
    IN OUT LPDWORD pNameLen,
    OUT PWSTR DisplayName OPTIONAL,
    IN OUT LPDWORD pDispNameLen
    );

LONG
SceJetGetGpoIDByName(
    IN PSCECONTEXT cxtProfile,
    IN PWSTR       szGpoName,
    IN BOOL        bAdd
    );

SCESTATUS
SceJetGetGpoID(
    IN PSCESECTION hSection,
    IN PWSTR      ObjectName,
    IN JET_COLUMNID JetColGpoID OPTIONAL,
    OUT LONG      *pGpoID
    );

#ifdef __cplusplus
}
#endif

#endif  // _SCEJETP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\scerpc_s_stub.c ===
#include "scerpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\scep.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scep.h

Abstract:

    This module defines the data structures and function prototypes
    for the security managment utility

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

--*/

#ifndef _scep_
#define _scep_

#include "splay.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// system variables
//

#define SCE_RENAME_ADMIN       1
#define SCE_RENAME_GUEST       2
#define SCE_DISABLE_ADMIN      3
#define SCE_DISABLE_GUEST      4

#define SCE_CASE_DONT_CARE    0
#define SCE_CASE_REQUIRED     1
#define SCE_CASE_PREFERED     2

typedef struct _LOCAL_ROOT {
   TCHAR drive[5];
   BOOL  boot;
   BOOL  aclSupport;
} LOCAL_ROOT;

typedef enum _SCE_ATTACHMENT_TYPE_ {

   SCE_ATTACHMENT_SERVICE,
   SCE_ATTACHMENT_POLICY

} SCE_ATTACHMENT_TYPE;

typedef enum _SECURITY_OPEN_TYPE
{
    READ_ACCESS_RIGHTS = 0,
    WRITE_ACCESS_RIGHTS,
    MODIFY_ACCESS_RIGHTS,
} SECURITY_OPEN_TYPE, *PSECURITY_OPEN_TYPE;

//
// data structures used for secmgr
//
typedef struct _SCE_OBJECT_TREE {
    PWSTR                       Name;
    PWSTR                       ObjectFullName;
    BOOL                        IsContainer;
    BYTE                        Status;
    SECURITY_INFORMATION        SeInfo;
    PSECURITY_DESCRIPTOR        pSecurityDescriptor;
    PSECURITY_DESCRIPTOR        pApplySecurityDescriptor;
    PWSTR                       *aChildNames;
    DWORD                       dwSize_aChildNames;
    struct _SCE_OBJECT_CHILD_LIST *ChildList;
    struct _SCE_OBJECT_TREE *Parent;
}SCE_OBJECT_TREE, *PSCE_OBJECT_TREE;


typedef struct _SCE_OBJECT_CHILD_LIST {

    PSCE_OBJECT_TREE                Node;
    struct _SCE_OBJECT_CHILD_LIST   *Next;

} SCE_OBJECT_CHILD_LIST, *PSCE_OBJECT_CHILD_LIST;

typedef enum _SCE_SUBOBJECT_TYPE {

    SCE_ALL_CHILDREN,
    SCE_IMMEDIATE_CHILDREN

} SCE_SUBOBJECT_TYPE;

//
// prototypes defined in misc.c
//

NTSTATUS
ScepOpenSamDomain(
    IN ACCESS_MASK  ServerAccess,
    IN ACCESS_MASK  DomainAccess,
    OUT PSAM_HANDLE pServerHandle,
    OUT PSAM_HANDLE pDomainHanele,
    OUT PSID        *DomainSid,
    OUT PSAM_HANDLE pBuiltinDomainHandle OPTIONAL,
    OUT PSID        *BuiltinDomainSid OPTIONAL
    );

NTSTATUS
ScepLookupNamesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PSCE_NAME_LIST NameList,
    OUT PUNICODE_STRING *Names,
    OUT PULONG *RIDs,
    OUT PSID_NAME_USE *Use,
    OUT PULONG CountOfName
    );


NTSTATUS
ScepGetLsaDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo,
    PPOLICY_PRIMARY_DOMAIN_INFO *PolicyPrimaryDomainInfo
    );

DWORD
ScepGetTempDirectory(
    IN PWSTR HomeDir,
    OUT PWSTR TempDirectory
    );

VOID
ScepConvertLogonHours(
    IN PSCE_LOGON_HOUR   pLogonHours,
    OUT PUCHAR LogonHourBitMask
    );

DWORD
ScepConvertToSceLogonHour(
    IN PUCHAR LogonHourBitMask,
    OUT PSCE_LOGON_HOUR   *pLogonHours
    );

NTSTATUS
ScepGetGroupsForAccount(
    IN SAM_HANDLE       DomainHandle,
    IN SAM_HANDLE       BuiltinDomainHandle,
    IN SAM_HANDLE       UserHandle,
    IN PSID             AccountSid,
    OUT PSCE_NAME_LIST      *GroupList
    );

ACCESS_MASK
ScepGetDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN SECURITY_INFORMATION SecurityInfo
    );

#define SCE_ACCOUNT_SID         0x1
#define SCE_ACCOUNT_SID_STRING  0x2

SCESTATUS
ScepGetProfileOneArea(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN DWORD dwAccountFormat,
    OUT PSCE_PROFILE_INFO *ppInfoBuffer
    );

SCESTATUS
ScepGetOneSection(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PWSTR Name,
    IN SCETYPE ProfileType,
    OUT PVOID *ppInfo
    );

NTSTATUS
ScepGetUserAccessAddress(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSID AccountSid,
    OUT PACCESS_MASK *pUserAccess,
    OUT PACCESS_MASK *pEveryone
    );

BOOL
ScepLastBackSlash(
    IN PWSTR Name
    );

DWORD
ScepGetUsersHomeDirectory(
    IN UNICODE_STRING AssignedHomeDir,
    IN PWSTR UserProfileName,
    OUT PWSTR *UserHomeDir
    );

DWORD
ScepGetUsersTempDirectory(
    IN PWSTR UserProfileName,
    OUT PWSTR *UserTempDir
    );

DWORD
ScepGetUsersProfileName(
    IN UNICODE_STRING AssignedProfile,
    IN PSID AccountSid,
    IN BOOL bDefault,
    OUT PWSTR *UserProfilePath
    );

SCESTATUS
ScepGetRegKeyCase(
    IN PWSTR ObjName,
    IN DWORD BufOffset,
    IN DWORD BufLen
    );

SCESTATUS
ScepGetFileCase(
    IN PWSTR ObjName,
    IN DWORD BufOffset,
    IN DWORD BufLen
    );

SCESTATUS
ScepGetGroupCase(
    IN OUT PWSTR GroupName,
    IN DWORD Length
    );

//
// prototypes defined in pfget.c
//

SCESTATUS
ScepGetUserSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR Name,
    OUT PVOID *ppInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepWriteObjectSecurity(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PSCE_OBJECT_SECURITY ObjSecurity
    );

//
// function defined in inftojet.c
//

SCESTATUS
SceJetConvertInfToJet(
    IN PCWSTR InfFile,
    IN LPSTR JetDbName,
    IN SCEJET_CREATE_TYPE Flags,
    IN DWORD Options,
    IN AREA_INFORMATION Area
    );

SCESTATUS
ScepDeleteInfoForAreas(
    IN PSCECONTEXT hProfile,
    IN SCETYPE tblType,
    IN AREA_INFORMATION Area
    );
//
// analyze.cpp
//

DWORD
ScepCompareAndAddObject(
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo,
    IN BOOL AddObject,
    OUT PBYTE IsDifferent OPTIONAL
    );

DWORD
ScepGetNamedSecurityInfo(
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN SECURITY_INFORMATION ProfileSeInfo,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    );

DWORD
ScepSaveDsStatusToSection(
    IN PWSTR ObjectName,
    IN BOOL  IsContainer,
    IN BYTE  Flag,
    IN PWSTR Value,
    IN DWORD ValueLen
    );

SCESTATUS
ScepSaveMemberMembershipList(
    IN LSA_HANDLE LsaPolicy,
    IN PCWSTR szSuffix,
    IN PWSTR GroupName,
    IN DWORD GroupLen,
    IN PSCE_NAME_LIST pList,
    IN INT Status
    );

SCESTATUS
ScepRaiseErrorString(
    IN PSCESECTION hSectionIn OPTIONAL,
    IN PWSTR KeyName,
    IN PCWSTR szSuffix OPTIONAL
    );

// DsObject.cpp

SCESTATUS
ScepConfigureDsSecurity(
    IN PSCE_OBJECT_TREE   pObject
    );

DWORD
ScepAnalyzeDsSecurity(
    IN PSCE_OBJECT_TREE pObject
    );

SCESTATUS
ScepEnumerateDsObjectRoots(
    IN PLDAP pLdap OPTIONAL,
    OUT PSCE_OBJECT_LIST *pRoots
    );

DWORD
ScepConvertJetNameToLdapCase(
    IN PWSTR JetName,
    IN BOOL bLastComponent,
    IN BYTE bCase,
    OUT PWSTR *LdapName
    );

SCESTATUS
ScepLdapOpen(
    OUT PLDAP *pLdap OPTIONAL
    );

SCESTATUS
ScepLdapClose(
    IN OUT PLDAP *pLdap OPTIONAL
    );

SCESTATUS
ScepDsObjectExist(
    IN PWSTR ObjectName
    );

SCESTATUS
ScepEnumerateDsOneLevel(
    IN PWSTR ObjectName,
    OUT PSCE_NAME_LIST *pNameList
    );

// dsgroups.cpp

SCESTATUS
ScepConfigDsGroups(
    IN PSCE_GROUP_MEMBERSHIP pGroupMembership,
    IN DWORD ConfigOptions
    );

SCESTATUS
ScepAnalyzeDsGroups(
    IN PSCE_GROUP_MEMBERSHIP pGroupMembership
    );

//
// editsave.cpp
//

BYTE
ScepGetObjectAnalysisStatus(
    IN PSCESECTION hSection,
    IN PWSTR KeyName,
    IN BOOL bLookForParent
    );

//
// config.cpp
//
#define SCE_BUILD_IGNORE_UNKNOWN        0x1
#define SCE_BUILD_ACCOUNT_SID           0x2
#define SCE_BUILD_ENUMERATE_PRIV        0x4
#define SCE_BUILD_ACCOUNT_SID_STRING    0x8

NTSTATUS
ScepBuildAccountsToRemove(
    IN LSA_HANDLE PolicyHandle,
    IN DWORD PrivLowMask,
    IN DWORD PrivHighMask,
    IN DWORD dwBuildRule,
    IN PSCE_PRIVILEGE_VALUE_LIST pTemplateList OPTIONAL,
    IN DWORD Options OPTIONAL,
    IN OUT PSCEP_SPLAY_TREE pIgnoreAccounts OPTIONAL,
    OUT PSCE_PRIVILEGE_VALUE_LIST *pRemoveList
    );

SCESTATUS
ScepEnumAttachmentSections(
    IN PSCECONTEXT cxtProfile,
    OUT PSCE_NAME_LIST *ppList
    );

SCESTATUS
ScepConvertFreeTextAccountToSid(
    IN OUT LSA_HANDLE *pPolicyHandle,
    IN PWSTR mszAccounts,
    IN ULONG dwLen,
    OUT PWSTR *pmszNewAccounts,
    OUT DWORD *pNewLen
    );

SCESTATUS
ScepConvertRelativeSidAccountToSid(
    IN OUT LSA_HANDLE *pPolicyHandle,
    IN PWSTR mszAccounts,
    IN ULONG dwLen,
    OUT PWSTR *pmszNewAccounts,
    OUT DWORD *pNewLen
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\scesrvrc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scesrvrc.h

Abstract:

    This module defines resource IDs for strings

Author:

    Jin Huang (Jinhuang) 17-Sept.-1997

Revision History:

--*/
#ifndef __scedllrc__
#define __scedllrc__

#include "commonrc.h"

#define SCEDLL_SCP_INIT_ERROR               7101
#define SCEDLL_SCP_INIT_SUCCESS             7102
#define SCEDLL_SCP_READ_PROFILE             7103

#define SCEDLL_SCP_BEGIN_POLICY             7104
#define SCEDLL_SCP_ACCESS_ERROR             7105
#define SCEDLL_SCP_ACCESS_SUCCESS           7106
#define SCEDLL_SCP_AUDIT_ERROR              7107
#define SCEDLL_SCP_AUDIT_SUCCESS            7108

#define SCEDLL_SCP_BEGIN_PRIVILEGES         7109
#define SCEDLL_SCP_PRIVILEGES_ERROR         7110
#define SCEDLL_SCP_PRIVILEGES_SUCCESS       7111

#define SCEDLL_SCP_BEGIN_USERSETTING        7112
#define SCEDLL_SCP_USERSETTING_ERROR        7113
#define SCEDLL_SCP_USERSETTING_SUCCESS      7114

#define SCEDLL_SCP_BEGIN_GROUPMGMT          7115
#define SCEDLL_SCP_GROUPMGMT_ERROR          7116
#define SCEDLL_SCP_GROUPMGMT_SUCCESS        7117

#define SCEDLL_SCP_BEGIN_REGISTRY           7118
#define SCEDLL_SCP_REGISTRY_ERROR           7119
#define SCEDLL_SCP_REGISTRY_SUCCESS         7120

#define SCEDLL_SCP_BEGIN_FILE               7121
#define SCEDLL_SCP_FILE_ERROR               7122
#define SCEDLL_SCP_FILE_SUCCESS             7123

#define SCEDLL_SCP_BEGIN_DS                 7124
#define SCEDLL_SCP_DS_ERROR                 7125
#define SCEDLL_SCP_DS_SUCCESS               7126

#define SCEDLL_SCP_BEGIN_GENERALSVC         7127
#define SCEDLL_SCP_GENERALSVC_ERROR         7128
#define SCEDLL_SCP_GENERALSVC_SUCCESS       7129

#define SCEDLL_SCP_BEGIN_ATTACHMENT         7130
#define SCEDLL_SCP_ATTACHMENT_ERROR         7131
#define SCEDLL_SCP_ATTACHMENT_SUCCESS       7132

#define SCEDLL_SCP_KERBEROS_ERROR           7133
#define SCEDLL_SCP_KERBEROS_SUCCESS         7134

#define SCEDLL_SCP_REGVALUES_ERROR          7135
#define SCEDLL_SCP_REGVALUES_SUCCESS        7136

#define SCEDLL_SCP_UNINIT                   7137

#define SCEDLL_SCP_ADMIN_NOT_ALLOWED        7138
#define SCEDLL_SCP_GUEST_NOT_ALLOWED        7139
#define SCEDLL_SCP_ADD                      7140
#define SCEDLL_SCP_ADDTO                    7141
#define SCEDLL_SCP_CANNOT_REMOVE            7142
#define SCEDLL_SCP_CONFIGURE                7143
#define SCEDLL_SCP_ERROR_ADD                7144
#define SCEDLL_SCP_ERROR_ADDTO              7145
#define SCEDLL_SCP_ERROR_ADMINISTRATOR      7146
#define SCEDLL_SCP_ERROR_CONFIGURE          7147
#define SCEDLL_SCP_ERROR_EVENT_AUDITING     7148
#define SCEDLL_SCP_ERROR_GUEST              7149
#define SCEDLL_SCP_ERROR_LOGSETTINGS        7150
#define SCEDLL_SCP_ERROR_KERBEROS           7151
#define SCEDLL_SCP_ERROR_LOCKOUT            7152
#define SCEDLL_SCP_ERROR_LOGOFF             7153
#define SCEDLL_SCP_ERROR_PASSWORD           7154
#define SCEDLL_SCP_ERROR_REMOVE             7155
#define SCEDLL_SCP_ERROR_UAS                7156
#define SCEDLL_SCP_ERROR_USERSETTINGS       7157
#define SCEDLL_SCP_EVENT_AUDITING           7158
#define SCEDLL_SCP_KERBEROS                 7159
#define SCEDLL_SCP_LOCKOUT                  7160
#define SCEDLL_SCP_LOGOFF                   7161
#define SCEDLL_SCP_LOGSETTINGS              7162
#define SCEDLL_SCP_NOT_SUPPORT              7163
#define SCEDLL_SCP_OTHER_POLICY             7164
#define SCEDLL_SCP_PASSWORD                 7165
#define SCEDLL_SCP_REMOVE                   7166
#define SCEDLL_SCP_RENAME_ADMIN             7167
#define SCEDLL_SCP_RENAME_GUEST             7168
#define SCEDLL_SCP_TAKE_OWNER               7169
#define SCEDLL_SCP_UAS                      7170
#define SCEDLL_SCP_USERSETTINGS             7171
#define SCEDLL_SCP_ERROR_REGVALUES          7172
#define SCEDLL_SCP_ERROR_STOP               7173
#define SCEDLL_SCP_ERROR_START              7174
#define SCEDLL_SCP_ERROR_OPENFORSTOP        7175
#define SCEDLL_SCP_ERROR_OPENFORSTART       7176
#define SCEDLL_SCP_DISABLE_ADMIN            7177
#define SCEDLL_SCP_ENABLE_ADMIN             7178
#define SCEDLL_SCP_DISABLE_GUEST            7179
#define SCEDLL_SCP_ENABLE_GUEST             7180

#define SCEDLL_SAP_INIT_ERROR               7181
#define SCEDLL_SAP_INIT_SUCCESS             7182
#define SCEDLL_SAP_READ_PROFILE             7183

#define SCEDLL_SAP_BEGIN_POLICY             7184
#define SCEDLL_SAP_ACCESS_ERROR             7185
#define SCEDLL_SAP_ACCESS_SUCCESS           7186
#define SCEDLL_SAP_AUDIT_ERROR              7187
#define SCEDLL_SAP_AUDIT_SUCCESS            7188
#define SCEDLL_SAP_POLICY_ERROR             7189

#define SCEDLL_SAP_BEGIN_PRIVILEGES         7190
#define SCEDLL_SAP_PRIVILEGES_ERROR         7191
#define SCEDLL_SAP_PRIVILEGES_SUCCESS       7192

#define SCEDLL_SAP_BEGIN_USERSETTING        7193
#define SCEDLL_SAP_USERSETTING_ERROR        7194
#define SCEDLL_SAP_USERSETTING_SUCCESS      7195

#define SCEDLL_SAP_BEGIN_GROUPMGMT          7196
#define SCEDLL_SAP_GROUPMGMT_ERROR          7197
#define SCEDLL_SAP_GROUPMGMT_SUCCESS        7198

#define SCEDLL_SAP_BEGIN_REGISTRY           7199
#define SCEDLL_SAP_REGISTRY_ERROR           7200
#define SCEDLL_SAP_REGISTRY_SUCCESS         7201

#define SCEDLL_SAP_BEGIN_FILE               7202
#define SCEDLL_SAP_FILE_ERROR               7203
#define SCEDLL_SAP_FILE_SUCCESS             7204

#define SCEDLL_SAP_BEGIN_DS                 7205
#define SCEDLL_SAP_DS_ERROR                 7206
#define SCEDLL_SAP_DS_SUCCESS               7207

#define SCEDLL_SAP_BEGIN_GENERALSVC         7208
#define SCEDLL_SAP_GENERALSVC_ERROR         7209
#define SCEDLL_SAP_GENERALSVC_SUCCESS       7210

#define SCEDLL_SAP_BEGIN_ATTACHMENT         7211
#define SCEDLL_SAP_ATTACHMENT_ERROR         7212
#define SCEDLL_SAP_ATTACHMENT_SUCCESS       7213

#define SCEDLL_SAP_KERBEROS_ERROR           7214
#define SCEDLL_SAP_KERBEROS_SUCCESS         7215

#define SCEDLL_SAP_REGVALUES_ERROR          7216
#define SCEDLL_SAP_REGVALUES_SUCCESS        7217

#define SCEDLL_SAP_UNINIT                   7218

#define SCEDLL_SAP_ANALYZE                  7220
#define SCEDLL_SAP_ERROR_ACL                7221
#define SCEDLL_SAP_ERROR_ADD                7222
#define SCEDLL_SAP_ERROR_ADMINISTRATOR      7223
#define SCEDLL_SAP_ERROR_ANALYZE            7224
#define SCEDLL_SAP_ERROR_ENUMERATE          7225
#define SCEDLL_SAP_ERROR_EVENT_AUDITING     7226
#define SCEDLL_SAP_ERROR_GUEST              7227
#define SCEDLL_SAP_ERROR_KERBEROS           7228
#define SCEDLL_SAP_ERROR_LOCKOUT            7229
#define SCEDLL_SAP_ERROR_LOGOFF             7230
#define SCEDLL_SAP_ERROR_OUT                7231
#define SCEDLL_SAP_ERROR_PASSWORD           7232
#define SCEDLL_SAP_ERROR_SAVE               7233
#define SCEDLL_SAP_ERROR_SECURITY           7234
#define SCEDLL_SAP_ERROR_UAS                7235
#define SCEDLL_SAP_EVENT_AUDITING           7236
#define SCEDLL_SAP_IGNORE_TEMPLATE          7237
#define SCEDLL_SAP_KERBEROS                 7238
#define SCEDLL_SAP_LOCKOUT                  7239
#define SCEDLL_SAP_LOGOFF                   7240
#define SCEDLL_SAP_LOGSETTINGS              7241
#define SCEDLL_SAP_NOT_SUPPORT              7242
#define SCEDLL_SAP_OTHER_POLICY             7243
#define SCEDLL_SAP_PASSWORD                 7244
#define SCEDLL_SAP_START_SECTION            7245
#define SCEDLL_SAP_UAS                      7246
#define SCEDLL_SAP_ERROR_LSA_ANON_LOOKUP    7247

#define SCEDLL_ACCOUNT_DOMAIN               7250
#define SCEDLL_ADMIN_LOGON                  7251
#define SCEDLL_ADMINISTRATORS_SID           7252
#define SCEDLL_BEGIN_INIT                   7253
#define SCEDLL_BEGIN_RECOVERY               7254
#define SCEDLL_CANNOT_FIND                  7255
#define SCEDLL_CREATE_TABLE                 7256
#define SCEDLL_DELETE_TABLE                 7257
#define SCEDLL_ENGINE_STATUS_RESET          7258
#define SCEDLL_ERROR_ADJUST                 7259
#define SCEDLL_ERROR_ALIAS_MEMBER           7260
#define SCEDLL_ERROR_ALIAS_MEMBEROF         7261
#define SCEDLL_ERROR_ANALYZE_MEMBEROF       7262
#define SCEDLL_ERROR_ANALYZE_MEMBERS        7263
#define SCEDLL_ERROR_BUILD_SD               7264
#define SCEDLL_ERROR_COMPUTESD              7265
#define SCEDLL_ERROR_CONVERT                7266
#define SCEDLL_ERROR_CONVERT_LDAP           7267
#define SCEDLL_ERROR_CONVERT_SECTION        7268
#define SCEDLL_ERROR_CREATE                 7269
#define SCEDLL_ERROR_DELETE                 7270
#define SCEDLL_ERROR_GENERATE               7271
#define SCEDLL_ERROR_IGNORE_POLICY          7249
#define SCEDLL_ERROR_LOAD                   7272
#define SCEDLL_ERROR_LOOKUP                 7273
#define SCEDLL_ERROR_OPEN                   7274
#define SCEDLL_ERROR_PROCESS_UNICODE        7275
#define SCEDLL_ERROR_QUERY_EVENT_AUDITING   7276
#define SCEDLL_ERROR_QUERY_INFO             7277
#define SCEDLL_ERROR_QUERY_LOCKOUT          7278
#define SCEDLL_ERROR_QUERY_LOGOFF           7279
#define SCEDLL_ERROR_QUERY_LOGSETTINGS      7280
#define SCEDLL_ERROR_QUERY_PASSWORD         7281
#define SCEDLL_ERROR_QUERY_SECURITY         7282
#define SCEDLL_ERROR_QUERY_UAS              7283
#define SCEDLL_ERROR_QUERY_VOLUME           7284
#define SCEDLL_ERROR_SAVE_REGISTRY          7285
#define SCEDLL_ERROR_SET_INFO               7286
#define SCEDLL_ERROR_SET_SECURITY           7287
#define SCEDLL_ERROR_START_TRANS            7288
#define SCEDLL_ERROR_TAKE_OWNER             7289
#define SCEDLL_ERROR_USER_MEMBER            7290
#define SCEDLL_ERROR_WRITE_INFO             7291
#define SCEDLL_EVENT_IS_OFF                 7292
#define SCEDLL_EVENT_RESTORED               7293
#define SCEDLL_FIND_DBLOCATION              7294
#define SCEDLL_GENERATE_TEMPLATE            7295
#define SCEDLL_INVALID_GROUP                7296
#define SCEDLL_INVALID_PATH                 7297
#define SCEDLL_INVALID_SECURITY             7298
#define SCEDLL_INVALID_USER                 7299
#define SCEDLL_LOAD_ATTACHMENT              7300
#define SCEDLL_LOGFILE_INVALID              7301
#define SCEDLL_LSA_POLICY                   7302
#define SCEDLL_NO_ACL_SUPPORT               7303
#define SCEDLL_NO_DETAIL                    7304
#define SCEDLL_NO_MAPPINGS                  7305
#define SCEDLL_NOT_GROUP                    7306
#define SCEDLL_PROCESS_TEMPLATE             7307
#define SCEDLL_SEPARATOR                    7308
#define SCEDLL_TAB_SEPARATOR                7309
#define SCEDLL_TIMESTAMP_ERROR              7310
#define SCEDLL_TOTAL_TICKS_ERROR            7311
#define SCEDLL_UNKNOWN_DBLOCATION           7312
#define SCEDLL_UNKNOWN_LOGON_USER           7313
#define SCEDLL_USER_OBJECT                  7314
#define SCEDLL_USERRIGHT_NOT_DEFINED        7315
#define SCEDLL_PROCESS                      7316
#define SCEDLL_COPY_LOCAL                   7317
#define SCEDLL_ERROR_COPY                   7318
#define SCEDLL_ERROR_DELETE_DB              7319
#define SCEDLL_ERROR_RECOVER_DB             7320

#define SCEDLL_STATUS_ERROR                 7321
#define SCEDLL_STATUS_MATCH                 7322
#define SCEDLL_STATUS_MISMATCH              7323
#define SCEDLL_STATUS_NC                    7324
#define SCEDLL_STATUS_NEW                   7325
#define SCEDLL_STATUS_NOACL                 7326

#define SCESRV_ALIAS_NAME_SERVER_OPS        7370
#define SCESRV_ALIAS_NAME_ACCOUNT_OPS       7371
#define SCESRV_ALIAS_NAME_PRINT_OPS         7372
#define SCESRV_ALIAS_CREATE                 7373
#define SCESRV_ALIAS_UNSUPPORTED            7374

#define SCEDLL_COPY_DEFAULT                 7380
#define SCEDLL_ERROR_COPY_DEFAULT           7381

#define IDS_WARNING                         7385
#define IDS_ERROR                           7386

#define IDS_REGISTRY_DELAY_FILTER           7387
#define IDS_ERROR_LOOKUP                    7388
#define IDS_ERROR_CONVERT_SID               7389
#define IDS_COPY_DOMAIN_GPO                 7390
#define IDS_COPY_OU_GPO                     7391
#define IDS_COPY_PRIVILEGE_UPGRADE          7392
#define IDS_COPY_PRIVILEGE_FRESH            7393
#define IDS_ERROR_GET_PROCADDR              7394
#define IDS_COPY_ONE_PRIVILEGE              7395

#define IDS_NO_ANALYSIS                     7396
#define IDS_NO_ANALYSIS_FRESH               7397
#define IDS_ANALYSIS_MISMATCH               7398
#define IDS_ERROR_OPEN_LOG                  7399
#define IDS_ERROR_BIND                      7400
#define IDS_FAIL                            7401

#define SCESRV_POLICY_TATTOO_PREPARE        7405
#define SCESRV_POLICY_TATTOO_ERROR_RESET    7406
#define SCESRV_POLICY_TATTOO_CHECK          7407
#define SCESRV_POLICY_TATTOO_ERROR_CREATE   7408
#define SCESRV_POLICY_TATTOO_ERROR_SETTING  7409
#define SCESRV_POLICY_TATTOO_ERROR_QUERY    7410
#define SCESRV_POLICY_TATTOO_REMOVE_SETTING 7411
#define SCESRV_POLICY_TATTOO_EXIST          7412
#define SCESRV_POLICY_TATTOO_NONEXIST       7413
#define SCESRV_POLICY_TATTOO_QUERY          7414
#define SCESRV_POLICY_TATTOO_ADD            7415
#define SCESRV_POLICY_TATTOO_ERROR_REMOVE   7416
#define SCESRV_POLICY_TATTOO_ARRAY          7417

#define SCEDLL_SCP_BEGIN_REGISTRY_64KEY     7418
#define SCEDLL_SCP_BEGIN_REGISTRY_32KEY     7419

#define SCESRV_ENFORCE_DENY_LOCAL_RIGHT     7420
#define SCESRV_ENFORCE_DENY_NETWORK_RIGHT   7421
#define SCESRV_ENFORCE_NETWORK_RIGHT        7422
#define SCESRV_ENFORCE_LOCAL_RIGHT          7423
#define SCESRV_ERROR_ENFORCE_NETWORK_RIGHT  7424
#define SCESRV_ERROR_ENFORCE_LOCAL_RIGHT    7425

#define SCESRV_POLICY_PENDING_SAM           7430
#define SCESRV_POLICY_PENDING_AUDIT         7431
#define SCESRV_POLICY_PENDING_REMOVE_RIGHTS 7432
#define SCESRV_POLICY_PENDING_RIGHTS        7433
#define SCESRV_POLICY_PENDING_QUERY         7434
#define SCESRV_ERROR_PRIVATE_LSA            7435
#define SCESRV_ERROR_QUERY_ACCOUNT_RIGHTS   7436

#define IDS_ERROR_SAVE_POLICY_GPO_ACCOUNT   7437
#define IDS_ERROR_SAVE_POLICY_GPO_OTHER     7438
#define SCESRV_POLICY_ERROR_SPLAY_INITIALIZE  7439

#define SCEDLL_CONVERT_ROOT_NON_NTFS            7450
#define SCEDLL_CONVERT_ROOT_ERROR_QUERY_VOLUME  7451
#define SCEDLL_CONVERT_ROOT_NOT_FIXED_VOLUME    7452
#define SCEDLL_CONVERT_ROOT_NTFS_VOLUME         7453
#define SCEDLL_CONVERT_ERROR_PROFILES_DIR       7454
#define SCEDLL_CONVERT_SUCCESS_PROFILES_DIR     7455
#define SCEDLL_CONVERT_ERROR_TEMPLATE_APPLY     7456
#define SCEDLL_CONVERT_SUCCESS_TEMPLATE_APPLY   7457
#define SCEDLL_CONVERT_ERROR_DACL               7458
#define SCEDLL_CONVERT_ERROR_MARTA              7459
#define SCEDLL_CONVERT_ERROR_EVENT_WAIT         7460
#define SCEDLL_CONVERT_SUCCESS_EVENT_WAIT       7461
#define SCEDLL_CONVERT_SUCCESS_REGVAL_QUERY     7462
#define SCEDLL_CONVERT_ERROR_REGVAL_QUERY       7463
#define SCEDLL_CONVERT_OUT_OF_MEMORY            7464
#define SCEDLL_CONVERT_NOTEXIST_REGVAL          7465
#define SCEDLL_CONVERT_STATUS_CREATING_THREAD    7466
#define SCEDLL_CONVERT_SUCCESS_MARTA       7467
#define SCEDLL_CONVERT_ERROR_IIS_DIR       7468
#define SCEDLL_CONVERT_SUCCESS_IIS_DIR     7469

#define IDS_ERROR_CONVERT_PARAMETER         7470
#define IDS_ERROR_CONVERT_BAD_ENV_VAR       7471
#define IDS_INFO_CONVERT_DRIVE              7472
#define IDS_ERROR_CONVERT_PROD_TYPE         7473

#define SCEDLL_CONVERT_BAD_ENV_VAR          7474
#define SCEDLL_CONVERT_ERROR_DLL_FUNCTION   7475
#define SCEDLL_CONVERT_ERROR_DLL_LOAD       7476
#define SCEDLL_CONVERT_ERROR_EVENT_HANDLE   7477
#define SCEDLL_CONVERT_PROD_TYPE    7478

#define SCEDLL_ERROR_QUERYING_ACCOUNT_RIGHTS 7479
#define SCESRV_POLICY_TATTOO_NOT_REMOVE_MEMBERS  7480
#define IDS_FREE_DISK_SPACE                  7481

#define SCEDLL_SCP_ERROR_LSAPOLICY_QUERY        7490
#define SCEDLL_SCP_ERROR_LSAPOLICY_SET          7491
#define SCEDLL_SCP_ERROR_LSAPOLICY_BUILDDACL    7492
#define SCEDLL_SCP_ERROR_LSAPOLICY_SD_INIT      7493
#define SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ        7494
#define SCEDLL_SCP_INFO_LSAPOLICY_EXISTING_SDDL       7495
#define SCEDLL_SCP_INFO_LSAPOLICY_COMPUTED_SDDL       7496

#define SCEDLL_SCP_LSAPOLICY    7497
#define SCEDLL_SAP_LSAPOLICY    7498

#define SCEDLL_SCP_ERROR_DISABLE_ADMIN      7500
#define SCEDLL_SCP_ERROR_DISABLE_GUEST      7501
#define SCEDLL_SAP_ERROR_DISABLE_ADMIN      7502
#define SCEDLL_SAP_ERROR_DISABLE_GUEST      7503

#define SCEDLL_CANNOT_FIND_INDS             7505
#define SCEDLL_EMPTY_MEMBERSHIP             7506
#define SCEDLL_SCP_ERROR_NOREMOVE           7507

#define SCESRV_SETUPUPD_ERROR_LMCOMPAT      7508
#define SCESRV_SETUPUPD_IGNORE_LMCOMPAT     7509

#define SCESRV_POLICY_ERROR_VERIFY_SYNC     7510
#define SCESRV_POLICY_ERROR_LOCALDC         7511
#define SCESRV_POLICY_ERROR_PDCROLE         7512
#define SCESRV_POLICY_ERROR_FILE_OUTOFSYNC  7513

#define SCESRV_POLICY_NEW_PENDING_SAM       7514
#define SCESRV_POLICY_PENDING_REQUERY       7515
#define SCESRV_POLICY_PENDING_SAM_REQUERY   7516
#define SCESRV_POLICY_SAM_RESET_FILTER_SYNC 7517
#define SCESRV_POLICY_SAM_SET_FILTER_SYNC   7518
#define SCEDLL_SCP_ERROR_REMOVEFROM         7519
#define SCEDLL_SCP_SUCCESS_REMOVEFROM       7520
#define SCEDLL_SCP_SUCCESS_ADDTO            7521
#define SCEDLL_SCP_OLDTATTOO                7522
#define SCEDLL_SCP_NEWTATTOO                7523
#define SCEDLL_SCP_DELETETATTOO             7524
#define SCEDLL_SCP_SUCCESS_ADDTO_ALREADYADDED 7525
#define SCEDLL_SCP_SUCCESS_REMOVEFROM_ALREADYREMOVED 7526 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\scesrv.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    scesrv.cpp

Abstract:

    SCE Engine initialization

Author:

    Jin Huang (jinhuang) 23-Jan-1998 created

--*/
#include "serverp.h"
#include <locale.h>
#include "authz.h"
#include <alloca.h>

extern HINSTANCE MyModuleHandle;
AUTHZ_RESOURCE_MANAGER_HANDLE ghAuthzResourceManager = NULL;

#include "scesrv.h"

/*=============================================================================
**  Procedure Name:     DllMain
**
**  Arguments:
**
**
**
**  Returns:    0 = SUCCESS
**             !0 = ERROR
**
**  Abstract:
**
**  Notes:
**
**===========================================================================*/
BOOL WINAPI DllMain(
    IN HANDLE DllHandle,
    IN ULONG ulReason,
    IN LPVOID Reserved )
{

    switch(ulReason) {

    case DLL_PROCESS_ATTACH:

        MyModuleHandle = (HINSTANCE)DllHandle;

        //
        // initizlize server and thread data
        //
        setlocale(LC_ALL, ".OCP");

        (VOID) ScepInitServerData();

#if DBG == 1
        DebugInitialize();
#endif
        //
        // initialize dynamic stack allocation
        //

        SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT,
                             SAFEALLOCA_USE_DEFAULT,
                             NULL,
                             NULL
                            );

        break;

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        (VOID) ScepUninitServerData();

#if DBG == 1
        DebugUninit();
#endif
        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;
}

DWORD
WINAPI
ScesrvInitializeServer(
    IN PSVCS_START_RPC_SERVER pStartRpcServer
    )
{
    NTSTATUS NtStatus;
    NTSTATUS StatusConvert = STATUS_SUCCESS;
    DWORD    rc;
    DWORD   rcConvert;
    PWSTR   pszDrives = NULL;
    DWORD   dwWchars = 0;

    NtStatus = ScepStartServerServices(); // pStartRpcServer );
    rc = RtlNtStatusToDosError(NtStatus);

/* remove code to check "DemoteInProgress" value and trigger policy propagation
   because demoting a DC will always have policy re-propagated at reboot

*/


    //
    //  if this key exists, some FAT->NTFS conversion happened and we need to set security
    //  so spawn a thread to configure security after autostart service event is signalled.
    //  LSA etc. are guaranteed to be started when this event is signalled
    //

    DWORD dwRegType = REG_NONE;

    rcConvert = ScepRegQueryValue(
                                 HKEY_LOCAL_MACHINE,
                                 SCE_ROOT_PATH,
                                 L"FatNtfsConvertedDrives",
                                 (PVOID *) &pszDrives,
                                 &dwRegType,
                                 NULL
                                 );

    //
    // at least one C: type drive should be there
    //

    if ( dwRegType != REG_MULTI_SZ || (pszDrives && wcslen(pszDrives) < 2) ) {

        if (pszDrives) {
            LocalFree(pszDrives);
        }

        rcConvert = ERROR_INVALID_PARAMETER;

    }

    //
    // if there is at least one drive scheduled to set security (dwWchars >= 4), pass this info
    // to the spawned thread along with an indication that we are in reboot (so it can loop
    // through all drives as queried)
    //

    if (rcConvert == ERROR_SUCCESS ) {

        if (pszDrives) {

            //
            // need to spawn some other event waiter thread that will call this function
            // thread will free pszDrives
            //

            StatusConvert = RtlQueueWorkItem(
                                        ScepWaitForServicesEventAndConvertSecurityThreadFunc,
                                        pszDrives,
                                        WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION
                                        ) ;
        }

        else if ( pszDrives ) {

            LocalFree( pszDrives );

        }

    }

    if ( rcConvert == ERROR_SUCCESS && pszDrives ) {

        //
        // since event log is not ready, log success or error
        // to logfile only if there is some drive to convert
        //

        WCHAR   LogFileName[MAX_PATH + 50];

        LogFileName[0] = L'\0';
        GetSystemWindowsDirectory( LogFileName, MAX_PATH );
        LogFileName[MAX_PATH] = L'\0';

        //
        // same log file is used by this thread as well as the actual configuration
        // thread ScepWaitForServicesEventAndConvertSecurityThreadFunc - so use it
        // here and close it
        //

        wcscat(LogFileName, L"\\security\\logs\\convert.log");

        ScepEnableDisableLog(TRUE);

        ScepSetVerboseLog(3);

        if ( ScepLogInitialize( LogFileName ) == ERROR_INVALID_NAME ) {

            ScepLogOutput3(1,0, SCEDLL_LOGFILE_INVALID, LogFileName );

        }

        rcConvert = RtlNtStatusToDosError(StatusConvert);

        ScepLogOutput3(0,0, SCEDLL_CONVERT_STATUS_CREATING_THREAD, rcConvert, L"ScepWaitForServicesEventAndConvertSecurityThreadFunc");

        ScepLogClose();

    }

    //
    // use AUTHZ for LSA Policy Setting access check - don't care about error now
    //

    AuthzInitializeResourceManager(
                                  0,
                                  NULL,
                                  NULL,
                                  NULL,
                                  L"SCE",
                                  &ghAuthzResourceManager );

    return(rc);
}


DWORD
WINAPI
ScesrvTerminateServer(
    IN PSVCS_STOP_RPC_SERVER pStopRpcServer
    )
{
    NTSTATUS NtStatus;
    DWORD    rc;

    NtStatus = ScepStopServerServices( TRUE ); //, pStopRpcServer );
    rc = RtlNtStatusToDosError(NtStatus);

    if (ghAuthzResourceManager)
        AuthzFreeResourceManager( ghAuthzResourceManager );

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\service.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    service.cpp

Abstract:

    Routines to configure/analyze general settings of services plus
    some helper APIs

Author:

    Jin Huang (jinhuang) 25-Jun-1997

Revision History:

--*/
#include "headers.h"
#include "serverp.h"
#include "service.h"
#include "pfp.h"

//#define SCESVC_DBG 1

DWORD ScepPollOnServiceStartStop(
    IN  BOOL        bPollOnStart,
    IN  SC_HANDLE   hService
    );

VOID
ScepStopServiceAndAncestorServices(
    IN SC_HANDLE hScManager,
    IN PWSTR pszServiceName
    );


SCESTATUS
ScepConfigureGeneralServices(
    IN PSCECONTEXT hProfile,
    IN PSCE_SERVICES pServiceList,
    IN DWORD ConfigOptions
    )
/*
Routine Descripton:

    Configure startup and security descriptor settings for the list of
    services passed in.

Arguments:

    pServiceList - the list of services to configure

Return Value:

    SCE status
*/
{
    SCESTATUS      SceErr=SCESTATUS_SUCCESS;
    PSCE_SERVICES  pNode;
    DWORD          nServices=0;
    BOOL           bDoneSettingSaclDacl = FALSE;
    NTSTATUS  NtStatus = 0;
    SID_IDENTIFIER_AUTHORITY IdAuth=SECURITY_NT_AUTHORITY;
    DWORD          rcSaveRsop = ERROR_SUCCESS;

    PSCESECTION    hSectionDomain=NULL;
    PSCESECTION    hSectionTattoo=NULL;
    PSCE_SERVICES  pServiceCurrent=NULL;
    DWORD          ServiceLen=0;
    BOOL           bIgnoreStartupType = FALSE;          

    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         ScepIsSystemShutDown() ) {

        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    if ( pServiceList != NULL ) {

        SC_HANDLE hScManager;
        //
        // open the manager
        //
        hScManager = OpenSCManager(
                        NULL,
                        NULL,
                        SC_MANAGER_ALL_ACCESS
//                        SC_MANAGER_CONNECT |
//                        SC_MANAGER_QUERY_LOCK_STATUS |
//                        SC_MANAGER_MODIFY_BOOT_CONFIG
                        );

        SC_HANDLE hService=NULL;
        DWORD rc=NO_ERROR;

        if ( NULL == hScManager ) {

            rc = GetLastError();
            ScepLogOutput3(1, rc, SCEDLL_ERROR_OPEN, L"Service Control Manager");

            ScepPostProgress(TICKS_GENERAL_SERVICES,
                             AREA_SYSTEM_SERVICE,
                             NULL);

            return( ScepDosErrorToSceStatus(rc) );
        }

        LPQUERY_SERVICE_CONFIG pConfig=NULL;
        DWORD BytesNeeded;

        //
        // Adjust privilege for setting SACL
        //
        rc = SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, TRUE, NULL );

        //
        // if can't adjust privilege, ignore (will error out later if SACL is requested)
        //

        if ( rc != NO_ERROR ) {

            ScepLogOutput3(1, rc, SCEDLL_ERROR_ADJUST, L"SE_SECURITY_PRIVILEGE");
            rc = NO_ERROR;
        }

        //
        // Adjust privilege for setting ownership (if required)
        //
        rc = SceAdjustPrivilege( SE_TAKE_OWNERSHIP_PRIVILEGE, TRUE, NULL );

        //
        // if can't adjust privilege, ignore (will error out later if acls need to be written)
        //

        if ( rc != NO_ERROR ) {

            ScepLogOutput3(1, rc, SCEDLL_ERROR_ADJUST, L"SE_TAKE_OWNERSHIP_PRIVILEGE");
            rc = NO_ERROR;
        }

        //
        // get AdminsSid in case need to take ownership later
        //
        NtStatus = RtlAllocateAndInitializeSid(
            &IdAuth,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0,
            0,
            0,
            0,
            0,
            0,
            &AdminsSid );

        //
        // open the policy/tattoo tables
        //
        if ( ConfigOptions & SCE_POLICY_TEMPLATE ) {

            ScepTattooOpenPolicySections(
                          hProfile,
                          szServiceGeneral,
                          &hSectionDomain,
                          &hSectionTattoo
                          );
        }

        //
        // Loop through each service to set general setting
        //
        for ( pNode=pServiceList;
              pNode != NULL && rc == NO_ERROR; pNode = pNode->Next ) {

            //
            // to ignore startup type, the inf template will have svcname,,"SDDL"
            // on import, the database gets svcname,0,"SDDL"
            // so we have to ignore the startuptype of 0 for this service
            //

            if (pNode->Startup == 0) {
                bIgnoreStartupType = TRUE;
            }

            //
            // print the service name
            //
            if ( nServices < TICKS_GENERAL_SERVICES ) {
                ScepPostProgress(1,
                             AREA_SYSTEM_SERVICE,
                             pNode->ServiceName);
                nServices++;
            }

            ScepLogOutput3(2,0, SCEDLL_SCP_CONFIGURE, pNode->ServiceName);

            if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                 ScepIsSystemShutDown() ) {

                rc = ERROR_NOT_SUPPORTED;
                break;
            }

            ServiceLen = 0;
            if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                 hSectionDomain && hSectionTattoo ) {
                //
                // check if we need to query current setting for the service
                //
                ServiceLen = wcslen(pNode->ServiceName);

                if ( ScepTattooIfQueryNeeded(hSectionDomain, hSectionTattoo,
                                             pNode->ServiceName, ServiceLen, NULL, NULL ) ) {

                    rc = ScepQueryAndAddService(
                                hScManager,
                                pNode->ServiceName,
                                NULL,
                                &pServiceCurrent
                                );
                    if ( ERROR_SUCCESS != rc ) {
                        ScepLogOutput3(1,0,SCESRV_POLICY_TATTOO_ERROR_QUERY,rc,pNode->ServiceName);
                        rc = NO_ERROR;
                    } else {
                        ScepLogOutput3(3,0,SCESRV_POLICY_TATTOO_QUERY,pNode->ServiceName);
                    }
                }
            }

            bDoneSettingSaclDacl = FALSE;
            rcSaveRsop = ERROR_SUCCESS;
            //
            // open the service
            //
            hService = OpenService(
                            hScManager,
                            pNode->ServiceName,
                            SERVICE_QUERY_CONFIG |
                            SERVICE_CHANGE_CONFIG |
                            READ_CONTROL |
                            WRITE_DAC |
//                            WRITE_OWNER |               owner can't be set for a service
                            ACCESS_SYSTEM_SECURITY
                           );

            // if access was denied, try to take ownership
            // and try to open service again

            if (hService == NULL &&
                (ERROR_ACCESS_DENIED == (rc = GetLastError())) &&
                pNode->General.pSecurityDescriptor) {

                DWORD   rcTakeOwnership = NO_ERROR;

                if (AdminsSid) {

                    if ( NO_ERROR == (rcTakeOwnership = SetNamedSecurityInfo(
                        (LPWSTR)pNode->ServiceName,
                        SE_SERVICE,
                        OWNER_SECURITY_INFORMATION,
                        AdminsSid,
                        NULL,
                        NULL,
                        NULL
                        ))) {

                        //
                        // ownership changed, open service again and set SACL and DACL
                        // get a handle to set security
                        //


                        if ( hService = OpenService(
                                hScManager,
                                pNode->ServiceName,
                                READ_CONTROL |
                                WRITE_DAC |
                                ACCESS_SYSTEM_SECURITY
                                ))  {

                            if ( SetServiceObjectSecurity(
                                        hService,
                                        pNode->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                                        pNode->General.pSecurityDescriptor
                                        ) )  {

                                bDoneSettingSaclDacl = TRUE;

                                CloseServiceHandle(hService);
                                hService = NULL;

                                //
                                // re-open the service only if there are other config info
                                // to set (startup type).
                                // So when NOSTARTTYPE is set, do not need to reopen the service
                                //
                                if (FALSE == bIgnoreStartupType) {

                                    if (!(hService = OpenService(
                                                 hScManager,
                                                 pNode->ServiceName,
                                                 SERVICE_QUERY_CONFIG |
                                                 SERVICE_CHANGE_CONFIG
                                                 )) ) {

                                        rc = GetLastError();
                                    }
                                    else {

                                        //
                                        //clear any error we have seen so far since everything has succeeded
                                        //

                                        rc = NO_ERROR;
                                    }
                                }

                            } else {
                                //
                                // shouldn't fail here unless Service Control Manager
                                // fails for some reason.
                                //
                                rc = GetLastError();

                            }

                        } else {
                            //
                            // still fail to open the service to set DACL. this should
                            // not happen for admin logons since the current logon is
                            // one of the owner. But for normal user logon, this could
                            // fail (actually normal user logon should fail to set
                            // the owner

                            rc = GetLastError();

                        }

                    }

                } else {
                    //
                    // AdminSid failed to be initialized, get the error
                    //
                    rcTakeOwnership = RtlNtStatusToDosError(NtStatus);
                }

                if ( NO_ERROR != rcTakeOwnership || NO_ERROR != rc ) {
                    //
                    // log the error occurred in take ownership process
                    // reset error back to access denied so it will also be
                    // logged as failure to open the service
                    //

                    if (NO_ERROR != rcTakeOwnership)

                        ScepLogOutput3(2,rcTakeOwnership, SCEDLL_ERROR_TAKE_OWNER, (LPWSTR)pNode->ServiceName);

                    else

                        ScepLogOutput3(2, rc, SCEDLL_ERROR_OPEN, (LPWSTR)pNode->ServiceName);

                    rc = ERROR_ACCESS_DENIED;
                }

            }

            if ( hService != NULL ) {

                if (bIgnoreStartupType == TRUE) {
                    //
                    // do not configure service start type
                    //

                    if ( pNode->General.pSecurityDescriptor != NULL ) {

                        if ( !SetServiceObjectSecurity(
                                    hService,
                                    pNode->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                                    pNode->General.pSecurityDescriptor
                                    ) ) {

                            rc = GetLastError();
                        }
                        else
                            bDoneSettingSaclDacl = TRUE;
                    }

                } else {

                    //
                    // Phase-1 (in phase-2 the service will be started/stopped real-time)
                    //

                    //
                    // query the length of config
                    //
                    
                    if ( !QueryServiceConfig(
                                hService,
                                NULL,
                                0,
                                &BytesNeeded
                                ) ) {

                        rc = GetLastError();

                        if ( rc == ERROR_INSUFFICIENT_BUFFER ) {

                            pConfig = (LPQUERY_SERVICE_CONFIG)ScepAlloc(0, BytesNeeded);

                            if ( pConfig != NULL ) {
                                //
                                // the real query of config
                                //
                                if ( QueryServiceConfig(
                                            hService,
                                            pConfig,
                                            BytesNeeded,
                                            &BytesNeeded
                                            ) ) {
                                    rc = ERROR_SUCCESS;

                                    //
                                    // change pConfig->dwStartType to the new value
                                    //
                                    if ( pNode->Startup != (BYTE)(pConfig->dwStartType) ) {
                                        //
                                        // configure the service startup
                                        //
                                        if ( !ChangeServiceConfig(
                                                    hService,
                                                    pConfig->dwServiceType,
                                                    pNode->Startup,
                                                    pConfig->dwErrorControl,
                                                    pConfig->lpBinaryPathName,
                                                    pConfig->lpLoadOrderGroup,
                                                    NULL,
                                                    pConfig->lpDependencies,
                                                    NULL,
                                                    NULL,
                                                    pConfig->lpDisplayName
                                                    ) ) {

                                            rc = GetLastError();

                                        }
                                    }

                                    if ( rc == NO_ERROR &&
                                        pNode->General.pSecurityDescriptor != NULL &&
                                        !bDoneSettingSaclDacl) {

                                        if ( !SetServiceObjectSecurity(
                                                    hService,
                                                    pNode->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                                                    pNode->General.pSecurityDescriptor
                                                    ) ) {

                                            rc = GetLastError();
                                        }
                                        else
                                            bDoneSettingSaclDacl = TRUE;
                                    }

                                } else {

                                    rc = GetLastError();

                                    ScepLogOutput3(3,rc, SCEDLL_ERROR_QUERY_INFO, pNode->ServiceName);
                                }

                                ScepFree(pConfig);
                                pConfig = NULL;

                            } else {
                                //
                                // cannot allocate pConfig
                                //
                                rc = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        } else {

                            ScepLogOutput3(3,rc, SCEDLL_ERROR_QUERY_INFO, pNode->ServiceName);
                        }

                    } else {
                        //
                        // should not fall in here
                        //
                        rc = ERROR_SUCCESS;
                    }
                }

                CloseServiceHandle (hService);
                hService = NULL;

                if ( rc != NO_ERROR ) {

                    ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_CONFIGURE, pNode->ServiceName);

                    rcSaveRsop = rc;

                    if ( ERROR_INVALID_OWNER == rc ||
                         ERROR_INVALID_PRIMARY_GROUP == rc ||
                         ERROR_INVALID_SECURITY_DESCR == rc ||
                         ERROR_INVALID_ACL == rc ||
                         ERROR_ACCESS_DENIED == rc ) {

                        gWarningCode = rc;
                        rc = NO_ERROR;
                    }
                }
            } else {
                //
                // cannot open the service or some error taking ownership
                //
                if (rc != NO_ERROR) {
                    ScepLogOutput3(1, rc, SCEDLL_ERROR_OPEN, pNode->ServiceName);
                    // either of setting security/startup type failed - save it for RSOP log
                    rcSaveRsop = (rcSaveRsop == ERROR_SUCCESS ? rc: rcSaveRsop);
                    if ( rc ==  ERROR_SERVICE_DOES_NOT_EXIST )
                        rc = NO_ERROR;
                }
            }

            if (ConfigOptions & SCE_RSOP_CALLBACK)

                ScepRsopLog(SCE_RSOP_SERVICES_INFO,
                        rcSaveRsop != NO_ERROR ? rcSaveRsop : rc,
                        pNode->ServiceName,
                        0,
                        0);

            if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                 hSectionDomain && hSectionTattoo ) {
                //
                // manage the tattoo value of this one
                //

                ScepTattooManageOneServiceValue(
                                   hSectionDomain,
                                   hSectionTattoo,
                                   pNode->ServiceName,
                                   ServiceLen,
                                   pServiceCurrent,
                                   rc
                                   );
            }

            if ( pServiceCurrent ) {
                SceFreePSCE_SERVICES(pServiceCurrent);
                pServiceCurrent = NULL;
            }

            bIgnoreStartupType = FALSE;

        }
            
        if ( !(ConfigOptions & SCE_SERVICE_NO_REALTIME_ENFORCE) ) {

            //
            // real-time start/stop only if NOT in setup/dcpromo 
            // i.e. whenever SCE_SETUP_SERVICE_NOSTARTTYPE was used before
            //

            //
            // Phase-2 (in phase-1 the startup-type was only configured but not enforced real-time)
            //

            for ( pNode=pServiceList; pNode != NULL ; pNode = pNode->Next ) {

                if (pNode->Startup == SERVICE_DISABLED) {

                    //
                    // we should also stop the ancestor services
                    //
                    
                    ScepStopServiceAndAncestorServices(hScManager, pNode->ServiceName);

                }

                else if (pNode->Startup == SERVICE_AUTO_START) {

                    //
                    // if the service type is "automatic", we should start the service 
                    // Note: dependencies are already taken care of by SCM
                    //
                    
                    if ( hService = OpenService(
                                               hScManager,
                                               pNode->ServiceName,
                                               SERVICE_START | SERVICE_QUERY_STATUS
                                               )) {

                        SERVICE_STATUS ServiceStatus;

                        if (!StartService(hService,
                                            0,
                                            NULL
                                           )) {
                            if ( ERROR_SERVICE_ALREADY_RUNNING != GetLastError() ) {
                                ScepLogOutput3(2, GetLastError(), SCEDLL_SCP_ERROR_START, pNode->ServiceName);
                            }
                        }

                        else {

                            DWORD dwError;

                            dwError = ScepPollOnServiceStartStop( TRUE , hService );

                            if ( dwError != ERROR_SUCCESS ) {
                                ScepLogOutput3(2, dwError, SCEDLL_SCP_ERROR_START, pNode->ServiceName);
                            }

                        }

                        CloseServiceHandle (hService);
                        hService = NULL;

                    } else {
                            ScepLogOutput3(2, GetLastError(), SCEDLL_SCP_ERROR_OPENFORSTART, pNode->ServiceName);
                    }
                }
            }
        }

        CloseServiceHandle (hScManager);

        if (AdminsSid) {
            RtlFreeSid(AdminsSid);
            AdminsSid = NULL;
        }

        SceAdjustPrivilege( SE_TAKE_OWNERSHIP_PRIVILEGE, FALSE, NULL );
        SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, FALSE, NULL );

        SceErr = ScepDosErrorToSceStatus(rc);
    }

    if ( nServices < TICKS_GENERAL_SERVICES ) {

        ScepPostProgress(TICKS_GENERAL_SERVICES-nServices,
                         AREA_SYSTEM_SERVICE,
                         NULL);
    }

    SceJetCloseSection(&hSectionDomain, TRUE);
    SceJetCloseSection(&hSectionTattoo, TRUE);

    return(SceErr);

}


DWORD ScepPollOnServiceStartStop(
    IN  BOOL        bPollOnStart,
    IN  SC_HANDLE   hService
    ) 
/*
Routine Descripton:

    This routine polls on a service until it is really started
    or stopped using time-slice hints.

Arguments:

    bPollOnStart    -   if TRUE (FALSE), polls until really started (stopped)
    hService        -   handle to service to poll on

Return Value:

    win32 error code - ERROR_SUCCESS or other error
*/
{ 
    SERVICE_STATUS ssStatus; 
    DWORD dwOldCheckPoint; 
    DWORD dwStartTickCount;
    DWORD dwWaitTime;
    DWORD dwStatus = ERROR_SUCCESS;
   
    //
    // Check the status until the service is no longer pending (start or stop)
    //
 
    if (!QueryServiceStatus( 
            hService,
            &ssStatus) )
    {
        dwStatus = GetLastError();
        goto ExitHandler;
    }
 
    //
    // Save the tick count and initial checkpoint.
    //

    dwStartTickCount = GetTickCount();
    dwOldCheckPoint = ssStatus.dwCheckPoint;

    //
    // Poll until service has started or stopped
    //
    
    while (!((bPollOnStart && ssStatus.dwCurrentState == SERVICE_RUNNING) || 
            (!bPollOnStart && ssStatus.dwCurrentState == SERVICE_STOPPED ))) 
    { 
        
        //
        // Do not wait longer than the wait hint. A good interval is 
        // one tenth the wait hint, but no less than 1 second and no 
        // more than 10 seconds. 
        //
 
        dwWaitTime = ssStatus.dwWaitHint / 10;

        if( dwWaitTime < 1000 )
            dwWaitTime = 1000;
        else if ( dwWaitTime > 10000 )
            dwWaitTime = 10000;

        Sleep( dwWaitTime );
        
        //
        // Check the status again. 
        //
 
        if (!QueryServiceStatus( 
                hService,
                &ssStatus) )
        {
            dwStatus = GetLastError();
            goto ExitHandler;
        }

 
        if ( ssStatus.dwCheckPoint > dwOldCheckPoint )
        {
            //
            // The service is making progress since the checkpoint has been updated.
            //

            dwStartTickCount = GetTickCount();
            dwOldCheckPoint = ssStatus.dwCheckPoint;
        }
        else
        {
            if(GetTickCount()-dwStartTickCount > ssStatus.dwWaitHint)
            {
                //
                // No progress made within the wait hint - stop polling
                //

                break;
            }
        }
    } 
 
    //
    // final check on desired condition
    //

    if (!((bPollOnStart && ssStatus.dwCurrentState == SERVICE_RUNNING) || 
          (!bPollOnStart && ssStatus.dwCurrentState == SERVICE_STOPPED )))
        dwStatus = ERROR_SERVICE_REQUEST_TIMEOUT;

ExitHandler:

        return dwStatus;

} 


VOID
ScepStopServiceAndAncestorServices(
    IN SC_HANDLE hScManager,
    IN PWSTR pszServiceName
    )
/*
Routine Description:

    Stop the named service and all other services that are dependent on it.

Arguments:

    hScManager      -   handle to the Service Control Manager
    pszServiceName  -   name of the service to be stopped

Return Value:

    None:
*/
{
    SC_HANDLE hService=NULL;
    LPENUM_SERVICE_STATUS pArrServices = NULL;
    
    if ( hService = OpenService(
                               hScManager,
                               pszServiceName,
                               SERVICE_STOP  | SERVICE_ENUMERATE_DEPENDENTS  | SERVICE_QUERY_STATUS
                               )) {
        
        //
        // get an array of ancestor services, greatest-ancestor first
        //

        DWORD   dwBufSizeSupplied = 0;
        DWORD   dwBufSizeRequired = 0;
        DWORD   dwNumServicesReturned = 0;

        //
        // first, get the required size of the array
        //

        if (!EnumDependentServices(
                                  hService,
                                  SERVICE_STATE_ALL,
                                  pArrServices,
                                  0,
                                  &dwBufSizeRequired,
                                  &dwNumServicesReturned
                                  )) {

            if (ERROR_MORE_DATA != GetLastError()) {
            
                ScepLogOutput3(2, GetLastError(), SCEDLL_SCP_ERROR_STOP, pszServiceName);
            
                goto ExitHandler;
            }
        }

        pArrServices = (ENUM_SERVICE_STATUS *) LocalAlloc (LMEM_ZEROINIT, dwBufSizeRequired);

        if (pArrServices == NULL) {

            ScepLogOutput3(2, ERROR_NOT_ENOUGH_MEMORY, SCEDLL_SCP_ERROR_STOP, pszServiceName);
            
            goto ExitHandler;
        }

        //
        // second, get the array of dependent services
        //
        
        if (!EnumDependentServices(
                                  hService,
                                  SERVICE_STATE_ALL,
                                  pArrServices,
                                  dwBufSizeRequired,
                                  &dwBufSizeRequired,
                                  &dwNumServicesReturned
                                  )) {

            ScepLogOutput3(2, GetLastError(), SCEDLL_SCP_ERROR_STOP, pszServiceName);

            goto ExitHandler;

        }

        //
        // first stop all the ancestor services
        // if any of them fails to stop, log it and continue
        //

        for (DWORD   dwServiceIndex = 0; dwServiceIndex < dwNumServicesReturned; dwServiceIndex++ ) {

            SC_HANDLE hAncestorService = NULL;

            if ( hAncestorService = OpenService(
                                hScManager,
                                pArrServices[dwServiceIndex].lpServiceName,
                                SERVICE_STOP | SERVICE_QUERY_STATUS
                                ))  {

                SERVICE_STATUS ServiceStatus;

                if (!ControlService(hAncestorService,
                               SERVICE_CONTROL_STOP,
                               &ServiceStatus
                              )) {
                    if ( ERROR_SERVICE_NOT_ACTIVE != GetLastError() ) {
                        ScepLogOutput3(2, GetLastError(), SCEDLL_SCP_ERROR_STOP, pArrServices[dwServiceIndex].lpServiceName);
                    }
                }

                else {
                    
                    //
                    // move on only if this service stopped
                    //

                    DWORD   dwError;

                    dwError = ScepPollOnServiceStartStop( FALSE , hAncestorService );

                    if ( dwError != ERROR_SUCCESS ) {
                        ScepLogOutput3(2, dwError, SCEDLL_SCP_ERROR_STOP, pArrServices[dwServiceIndex].lpServiceName);
                    }
                }



                CloseServiceHandle (hAncestorService);
                hAncestorService = NULL;

            } else {
                ScepLogOutput3(2, GetLastError(), SCEDLL_SCP_ERROR_OPENFORSTOP, pArrServices[dwServiceIndex].lpServiceName);
            }

        }

        LocalFree ( pArrServices );
        pArrServices = NULL;

        //
        // finally, stop the service itself
        //
        
        SERVICE_STATUS ServiceStatus;

        if (!ControlService(hService,
                            SERVICE_CONTROL_STOP,
                            &ServiceStatus
                           )) {
            
            if ( ERROR_SERVICE_NOT_ACTIVE != GetLastError() ) {
                ScepLogOutput3(2, GetLastError(), SCEDLL_SCP_ERROR_STOP, pszServiceName);
            }
        }
        else {

            DWORD   dwError;

            dwError = ScepPollOnServiceStartStop( FALSE , hService );

            if ( dwError != ERROR_SUCCESS ) {
                ScepLogOutput3(2, dwError, SCEDLL_SCP_ERROR_STOP, pszServiceName);
            }

        }

        CloseServiceHandle (hService);
        hService = NULL;

    } else {
        ScepLogOutput3(2, GetLastError(), SCEDLL_SCP_ERROR_OPENFORSTOP, pszServiceName);
    }

ExitHandler:
    
    if ( hService )
        CloseServiceHandle (hService);
    
    if ( pArrServices )
        LocalFree ( pArrServices );

}


SCESTATUS
ScepAnalyzeGeneralServices(
    IN PSCECONTEXT hProfile,
    IN DWORD Options
    )
/*
Routine Description:

    Analyze all available services on the current system.

    The base profile (SCEP) is in hProfile

Arguments:

    hProfile - the database context handle

Return Value:

    SCE status
*/
{
    if ( hProfile == NULL ) {

        ScepPostProgress(TICKS_GENERAL_SERVICES,
                         AREA_SYSTEM_SERVICE,
                         NULL);

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;
    PSCE_SERVICES pServiceList=NULL;
    DWORD nServices=0;

    rc = SceEnumerateServices( &pServiceList, FALSE );
    rc = ScepDosErrorToSceStatus(rc);

    if ( rc == SCESTATUS_SUCCESS ) {

        PSCESECTION hSectionScep=NULL, hSectionSap=NULL;
        //
        // open the sap section. If it is not there, creates it
        //
        rc = ScepStartANewSection(
                    hProfile,
                    &hSectionSap,
                    (Options & SCE_GENERATE_ROLLBACK) ? SCEJET_TABLE_SMP : SCEJET_TABLE_SAP,
                    szServiceGeneral
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            PSCE_SERVICES pNode = pServiceList;
            //
            // open SCEP section. should be success always because the StartANewSection
            // creates the section if it is not there
            //
            rc = ScepOpenSectionForName(
                        hProfile,
                        (Options & SCE_GENERATE_ROLLBACK) ? SCE_ENGINE_SMP : SCE_ENGINE_SCP,  // SCE_ENGINE_SMP,
                        szServiceGeneral,
                        &hSectionScep
                        );

            if ( rc == SCESTATUS_SUCCESS ) {

                //
                // analyze each service
                //
                PSCE_SERVICES pOneService=NULL;
                BOOL IsDifferent;

                for ( pNode=pServiceList;
                      pNode != NULL; pNode=pNode->Next ) {

                    ScepLogOutput3(2, 0, SCEDLL_SAP_ANALYZE, pNode->ServiceName);

                    if ( nServices < TICKS_SPECIFIC_SERVICES ) {

                        ScepPostProgress(1,
                                         AREA_SYSTEM_SERVICE,
                                         NULL);
                        nServices++;
                    }

                    //
                    // get setting from the SMP profile
                    //
                    rc = ScepGetSingleServiceSetting(
                                 hSectionScep,
                                 pNode->ServiceName,
                                 &pOneService
                                 );


                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // there is a SMP entry for the service, compare and save
                        //
                        rc = ScepCompareSingleServiceSetting(
                                        pOneService,
                                        pNode,
                                        &IsDifferent
                                        );

                        if ( rc == SCESTATUS_SUCCESS && IsDifferent ) {
                            //
                            // write the service as mismatch
                            //
                            pNode->Status = (Options & SCE_GENERATE_ROLLBACK) ? 0 : SCE_STATUS_MISMATCH;
                            pNode->SeInfo = pOneService->SeInfo;

                            rc = ScepSetSingleServiceSetting(
                                      hSectionSap,
                                      pNode
                                      );
                        }

                    } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

                        //
                        // this service is not defined
                        //
                        if ( !(Options & SCE_GENERATE_ROLLBACK) ) {
                            //
                            // save the record with not configured status
                            //
                            pNode->Status = SCE_STATUS_NOT_CONFIGURED;

                            rc = ScepSetSingleServiceSetting(
                                      hSectionSap,
                                      pNode
                                      );
                        } else {
                            //
                            // ignore this one
                            //
                            rc = SCESTATUS_SUCCESS;
                        }
                    }

                    SceFreePSCE_SERVICES(pOneService);
                    pOneService = NULL;

                    if ( rc != SCESTATUS_SUCCESS ) {
                        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                       SCEDLL_SAP_ERROR_ANALYZE, pNode->ServiceName);

                        if ( SCESTATUS_ACCESS_DENIED == rc ) {
                            gWarningCode = ScepSceStatusToDosError(rc);

                            if ( !(Options & SCE_GENERATE_ROLLBACK) ) {

                                //
                                // raise a error status
                                //
                                pNode->Status = SCE_STATUS_ERROR_NOT_AVAILABLE;

                                rc = ScepSetSingleServiceSetting(
                                          hSectionSap,
                                          pNode
                                          );
                            }
                            rc = SCESTATUS_SUCCESS;
                        } else {

                            break;
                        }
                    }

                }

                SceJetCloseSection(&hSectionScep, TRUE);
            }

            if ( !(Options & SCE_GENERATE_ROLLBACK ) ) {

                //
                // raise any error item
                //
                for ( PSCE_SERVICES pNodeTmp=pNode; pNodeTmp != NULL; pNodeTmp = pNodeTmp->Next ) {

                    pNodeTmp->Status = SCE_STATUS_ERROR_NOT_AVAILABLE;

                    ScepSetSingleServiceSetting(
                              hSectionSap,
                              pNode
                              );
                }
            }

            SceJetCloseSection(&hSectionSap, TRUE);
        }
        if ( rc != SCESTATUS_SUCCESS )
            ScepLogOutput3(1, ScepSceStatusToDosError(rc), SCEDLL_SAP_ERROR_OUT);

    }

    if ( nServices < TICKS_GENERAL_SERVICES ) {

        ScepPostProgress(TICKS_GENERAL_SERVICES-nServices,
                         AREA_SYSTEM_SERVICE,
                         NULL);
    }

    SceFreePSCE_SERVICES(pServiceList);
    return(rc);

}


SCESTATUS
ScepGetSingleServiceSetting(
    IN PSCESECTION hSection,
    IN PWSTR ServiceName,
    OUT PSCE_SERVICES *pOneService
    )
/*
Routine Description:

    Get service settings for the service from the section

Arguments:

    hSection - the section handle

    ServiceName - the service name

    pOneService - the service settings

Return Value:

    SCE status
*/
{
    if ( hSection == NULL || ServiceName == NULL || pOneService == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;
    DWORD ValueLen;
    //
    // seek to the record and get length for name and value
    //
    rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                ServiceName,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueLen
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        PWSTR Value=NULL;

        //
        // allocate memory for the service name and value string
        //
        Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);
        if ( Value != NULL ) {
            //
            // Get the service and its value
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        Value,
                        ValueLen,
                        &ValueLen
                        );

            if ( rc == SCESTATUS_SUCCESS ) {

                Value[ValueLen/2] = L'\0';

                DWORD Win32Rc=NO_ERROR;
                PSECURITY_DESCRIPTOR pTempSD=NULL;
                DWORD SDsize=0;
                SECURITY_INFORMATION SeInfo=0;

                if ( ValueLen >= 2 && Value[1] != L'\0' ) {

                    //
                    // convert to security descriptor
                    //
                    Win32Rc = ConvertTextSecurityDescriptor(
                                       Value+1,
                                       &pTempSD,
                                       &SDsize,
                                       &SeInfo
                                       );
                }

                if ( Win32Rc == NO_ERROR ) {

                    ScepChangeAclRevision(pTempSD, ACL_REVISION);

                    //
                    // create this service node
                    //
                    *pOneService = (PSCE_SERVICES)ScepAlloc( LMEM_FIXED, sizeof(SCE_SERVICES) );

                    if ( *pOneService != NULL ) {

                        (*pOneService)->ServiceName = (PWSTR)ScepAlloc(LMEM_FIXED,
                                                  (wcslen(ServiceName)+1)*sizeof(WCHAR));
                        if ( (*pOneService)->ServiceName != NULL ) {

                            wcscpy( (*pOneService)->ServiceName, ServiceName);
                            (*pOneService)->DisplayName = NULL;
                            (*pOneService)->Status = *((BYTE *)Value);
                            (*pOneService)->Startup = *((BYTE *)Value+1);
                            (*pOneService)->General.pSecurityDescriptor = pTempSD;
                            (*pOneService)->SeInfo = SeInfo;
                            (*pOneService)->Next = NULL;

                            //
                            // DO NOT free the following buffers
                            //
                            pTempSD = NULL;

                        } else {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            ScepFree(*pOneService);
                        }

                    } else {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    }
                    if ( pTempSD != NULL ) {
                        ScepFree(pTempSD);
                    }

                } else {
                    rc = ScepDosErrorToSceStatus(Win32Rc);
                }
            }
            ScepFree(Value);

        } else
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    return(rc);
}


SCESTATUS
ScepCompareSingleServiceSetting(
    IN PSCE_SERVICES pNode1,
    IN PSCE_SERVICES pNode2,
    OUT PBOOL pIsDifferent
    )
/*
Routine Description:

    Comare two service settings.

Arguments:

    pNode1  - the first service

    pNode2  - the second service

    pIsDifferent    - output TRUE if different

Return Value:

    SCE status
*/
{
    SCESTATUS rc=SCESTATUS_SUCCESS;

    //
    // if Startup == 0, we should ignore comparing the startup types symmetrically
    //

    if ( pNode1->Startup == 0 || pNode2->Startup == 0 || pNode1->Startup == pNode2->Startup ) {

        BYTE resultSD = 0;
        rc = ScepCompareObjectSecurity(
                    SE_SERVICE,
                    FALSE,
                    pNode1->General.pSecurityDescriptor,
                    pNode2->General.pSecurityDescriptor,
                    pNode1->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                    &resultSD
                    );
        if ( resultSD ) {
            *pIsDifferent = TRUE;
        } else
            *pIsDifferent = FALSE;

    } else
        *pIsDifferent = TRUE;

    return(rc);
}


SCESTATUS
ScepSetSingleServiceSetting(
    IN PSCESECTION hSection,
    IN PSCE_SERVICES pOneService
    )
/*
Routine Description:

    Set service settings for the service from the section

Arguments:

    hSection - the section handle

    pOneService - the service settings

Return Value:

    SCE status
*/
{
    if ( hSection == NULL || pOneService == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;
    PWSTR SDspec=NULL;
    DWORD SDsize=0;


    if ( (pOneService->Status != SCE_STATUS_NOT_ANALYZED) &&
         (pOneService->Status != SCE_STATUS_ERROR_NOT_AVAILABLE) &&
         (pOneService->General.pSecurityDescriptor != NULL) ) {

        DWORD Win32Rc;

        Win32Rc = ConvertSecurityDescriptorToText (
                    pOneService->General.pSecurityDescriptor,
                    pOneService->SeInfo,
                    &SDspec,
                    &SDsize  // number of w-chars
                    );
        rc = ScepDosErrorToSceStatus(Win32Rc);

    }

    if ( rc == SCESTATUS_SUCCESS ) {

        PWSTR Value=NULL;
        DWORD ValueLen;

        ValueLen = (SDsize+1)*sizeof(WCHAR);

        Value = (PWSTR)ScepAlloc( (UINT)0, ValueLen+sizeof(WCHAR) );

        if ( Value != NULL ) {

            //
            // The first byte is status, the second byte is startup
            //
            *((BYTE *)Value) = pOneService->Status;

            *((BYTE *)Value+1) = pOneService->Startup;

            if ( SDspec != NULL ) {

                wcscpy(Value+1, SDspec);
            }

            Value[SDsize+1] = L'\0';  //terminate this string

            //
            // set the value
            //
            rc = SceJetSetLine(
                        hSection,
                        pOneService->ServiceName,
                        FALSE,
                        Value,
                        ValueLen,
                        0
                        );

            ScepFree( Value );

            switch ( pOneService->Status ) {
            case SCE_STATUS_ERROR_NOT_AVAILABLE:
                ScepLogOutput3(2, 0, SCEDLL_STATUS_ERROR, pOneService->ServiceName);

                break;

            case SCE_STATUS_NOT_CONFIGURED:

                ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, pOneService->ServiceName);

                break;

            case SCE_STATUS_NOT_ANALYZED:

                ScepLogOutput3(2, 0, SCEDLL_STATUS_NEW, pOneService->ServiceName);

                break;

            default:

                ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, pOneService->ServiceName);
                break;
            }

        } else
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    if ( SDspec != NULL ) {
        ScepFree( SDspec );
    }

    return(rc);
}


SCESTATUS
ScepInvokeSpecificServices(
    IN PSCECONTEXT hProfile,
    IN BOOL bConfigure,
    IN SCE_ATTACHMENT_TYPE aType
    )
/*
Routine Description:

    Call each service engine for configure or analyze

Arguments:

    hProfile - the profile handle

    bConfigure - TRUE = to configure, FALSE=to analyze

    aType - attachment type "services" or "policy"

Return Value:

    SCE status
*/
{
    //
    // for posting progress
    //

    DWORD nServices=0;
    AREA_INFORMATION Area=0;
    DWORD nMaxTicks=0;

    switch(aType) {
    case SCE_ATTACHMENT_SERVICE:
        Area = AREA_SYSTEM_SERVICE;
        nMaxTicks = TICKS_SPECIFIC_SERVICES;
        break;
    case SCE_ATTACHMENT_POLICY:
        Area = AREA_SECURITY_POLICY;
        nMaxTicks = TICKS_SPECIFIC_POLICIES;
        break;
    }

    if ( hProfile == NULL ) {

        ScepPostProgress(nMaxTicks,
                         Area,
                         NULL);

        return(SCESTATUS_INVALID_PARAMETER);
    }
    //
    // call available service engines to configure specific setting
    //
    SCESTATUS SceErr ;
    PSCE_SERVICES pSvcEngineList=NULL;
    SCEP_HANDLE sceHandle;
    SCESVC_CALLBACK_INFO sceCbInfo;

    SceErr = ScepEnumServiceEngines(&pSvcEngineList, aType);

    if ( SceErr == SCESTATUS_SUCCESS) {

        HINSTANCE hDll;
        PF_ConfigAnalyzeService pfTemp;

        for ( PSCE_SERVICES pNode=pSvcEngineList;
              pNode != NULL; pNode = pNode->Next ) {

            ScepLogOutput3(2, 0, SCEDLL_LOAD_ATTACHMENT, pNode->ServiceName);

            if ( nServices < nMaxTicks ) {

                ScepPostProgress(1, Area, pNode->ServiceName);
                nServices++;
            }
            //
            // load the dll.
            //
            hDll = LoadLibrary(pNode->General.ServiceEngineName);

            if ( hDll != NULL ) {

                if ( bConfigure ) {
                    //
                    // call SceSvcAttachmentConfig from the dll
                    //
                    pfTemp = (PF_ConfigAnalyzeService)
                                      GetProcAddress(hDll,
                                                     "SceSvcAttachmentConfig") ;
                } else {
                    //
                    // call SceSvcAttachmentAnalyze from the dll
                    //
                    pfTemp = (PF_ConfigAnalyzeService)
                                      GetProcAddress(hDll,
                                                     "SceSvcAttachmentAnalyze") ;

                }
                if ( pfTemp != NULL ) {
                    //
                    // prepare the handle first
                    //
                    sceHandle.hProfile = (PVOID)hProfile;
                    sceHandle.ServiceName = (PCWSTR)(pNode->ServiceName);

                    sceCbInfo.sceHandle = &sceHandle;
                    sceCbInfo.pfQueryInfo = &SceCbQueryInfo;
                    sceCbInfo.pfSetInfo = &SceCbSetInfo;
                    sceCbInfo.pfFreeInfo = &SceSvcpFreeMemory;
                    sceCbInfo.pfLogInfo = &ScepLogOutput2;

                    //
                    // call the SceSvcAttachmentConfig/Analyze from the DLL
                    //
                    __try {

                        SceErr = (*pfTemp)((PSCESVC_CALLBACK_INFO)&sceCbInfo);

                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        SceErr = SCESTATUS_SERVICE_NOT_SUPPORT;
                    }

                } else {
                    //
                    // this API is not supported
                    //
                    SceErr = SCESTATUS_SERVICE_NOT_SUPPORT;
                }

                //
                // try to free the library handle. If it fails, just leave it
                // to to the process to terminate
                //
                FreeLibrary(hDll);

            } else
                SceErr = SCESTATUS_SERVICE_NOT_SUPPORT;

            if ( SceErr == SCESTATUS_SERVICE_NOT_SUPPORT ) {
                if ( bConfigure )
                    ScepLogOutput3(1, ScepSceStatusToDosError(SceErr),
                                   SCEDLL_SCP_NOT_SUPPORT);
                else
                    ScepLogOutput3(1, ScepSceStatusToDosError(SceErr),
                                   SCEDLL_SAP_NOT_SUPPORT);
                SceErr = SCESTATUS_SUCCESS;

            } else if ( SceErr != SCESTATUS_SUCCESS &&
                        SceErr != SCESTATUS_RECORD_NOT_FOUND ) {
                ScepLogOutput3(1, ScepSceStatusToDosError(SceErr),
                              SCEDLL_ERROR_LOAD, pNode->ServiceName);
            }

            if ( SceErr != SCESTATUS_SUCCESS &&
                 SceErr != SCESTATUS_SERVICE_NOT_SUPPORT &&
                 SceErr != SCESTATUS_RECORD_NOT_FOUND )
                break;
        }
        //
        // free the buffer
        //
        SceFreePSCE_SERVICES(pSvcEngineList);

    } else if ( SceErr != SCESTATUS_SUCCESS &&
                SceErr != SCESTATUS_PROFILE_NOT_FOUND &&
                SceErr != SCESTATUS_RECORD_NOT_FOUND ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(SceErr),
                      SCEDLL_SAP_ERROR_ENUMERATE, L"services");
    }

    if ( SceErr == SCESTATUS_PROFILE_NOT_FOUND ||
         SceErr == SCESTATUS_RECORD_NOT_FOUND ||
         SceErr == SCESTATUS_SERVICE_NOT_SUPPORT ) {
        //
        // no service engine defined
        //
        SceErr = SCESTATUS_SUCCESS;

    }

    if ( nServices < nMaxTicks ) {

        ScepPostProgress(nMaxTicks-nServices,
                         Area,
                         NULL);
    }

    return(SceErr);
}



SCESTATUS
ScepEnumServiceEngines(
    OUT PSCE_SERVICES *pSvcEngineList,
    IN SCE_ATTACHMENT_TYPE aType
    )
/*
Routine Description:

    Query all services which has a service engine for security manager
    The service engine information is in the registry:

    MACHINE\Software\Microsoft\Windows NT\CurrentVersion\SeCEdit

Arguments:

    pSvcEngineList - the service engine list

    aType - attachment type (service or policy)

Return Value:

    SCE status
*/
{
    if ( pSvcEngineList == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD   Win32Rc;
    HKEY    hKey=NULL;

    switch ( aType ) {
    case SCE_ATTACHMENT_SERVICE:
        Win32Rc = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  SCE_ROOT_SERVICE_PATH,
                  0,
                  KEY_READ,
                  &hKey
                  );
        break;
    case SCE_ATTACHMENT_POLICY:

        Win32Rc = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  SCE_ROOT_POLICY_PATH,
                  0,
                  KEY_READ,
                  &hKey
                  );
        break;
    default:
        return SCESTATUS_INVALID_PARAMETER;
    }

    if ( Win32Rc == ERROR_SUCCESS ) {

        TCHAR   Buffer[MAX_PATH];
        DWORD   BufSize;
        DWORD   index = 0;
        DWORD   EnumRc;
        FILETIME        LastWriteTime;
        PWSTR   BufTmp=NULL;
        PWSTR   EngineName=NULL;
        DWORD   RegType;

        //
        // enumerate all subkeys of the key
        //
        do {
            memset(Buffer, '\0', MAX_PATH*sizeof(WCHAR));
            BufSize = MAX_PATH;

            EnumRc = RegEnumKeyEx(
                            hKey,
                            index,
                            Buffer,
                            &BufSize,
                            NULL,
                            NULL,
                            NULL,
                            &LastWriteTime);

            if ( EnumRc == ERROR_SUCCESS ) {
                index++;
                //
                // get the service name, query service engine name
                //

                BufSize += wcslen(SCE_ROOT_SERVICE_PATH) + 1; //62;
                BufTmp = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                if ( BufTmp != NULL ) {

                    switch ( aType ) {
                    case SCE_ATTACHMENT_SERVICE:

                        swprintf(BufTmp, L"%s\\%s", SCE_ROOT_SERVICE_PATH, Buffer);

                        Win32Rc = ScepRegQueryValue(
                                        HKEY_LOCAL_MACHINE,
                                        BufTmp,
                                        L"ServiceAttachmentPath",
                                        (PVOID *)&EngineName,
                                        &RegType,
                                        NULL
                                        );
                        break;

                    case SCE_ATTACHMENT_POLICY:
                        // policies
                        swprintf(BufTmp, L"%s\\%s", SCE_ROOT_POLICY_PATH, Buffer);

                        Win32Rc = ScepRegQueryValue(
                                        HKEY_LOCAL_MACHINE,
                                        BufTmp,
                                        L"PolicyAttachmentPath",
                                        (PVOID *)&EngineName,
                                        &RegType,
                                        NULL
                                        );
                        break;
                    }

                    if ( Win32Rc == ERROR_SUCCESS ) {
                        //
                        // get the service engine name and service name
                        // add them to the service node
                        //
                        Win32Rc = ScepAddOneServiceToList(
                                        Buffer,   // service name
                                        NULL,
                                        0,
                                        (PVOID)EngineName,
                                        0,
                                        FALSE,
                                        pSvcEngineList
                                        );
                        //
                        // free the buffer if it's not added to the list
                        //
                        if ( Win32Rc != ERROR_SUCCESS && EngineName ) {
                            ScepFree(EngineName);
                        }
                        EngineName = NULL;

                    } else if ( Win32Rc == ERROR_FILE_NOT_FOUND ) {
                        //
                        // if no service engine name, ignore this service
                        //
                        Win32Rc = ERROR_SUCCESS;
                    }

                    ScepFree(BufTmp);
                    BufTmp = NULL;

                } else {
                    Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                }

                if ( Win32Rc != ERROR_SUCCESS ) {
                    break;
                }
            }

        } while ( EnumRc != ERROR_NO_MORE_ITEMS );

        RegCloseKey(hKey);

        //
        // remember the error code from enumeration
        //
        if ( EnumRc != ERROR_SUCCESS && EnumRc != ERROR_NO_MORE_ITEMS ) {
            if ( Win32Rc == ERROR_SUCCESS )
                Win32Rc = EnumRc;
        }

    }

    if ( Win32Rc != NO_ERROR && *pSvcEngineList != NULL ) {
        //
        // free memory allocated for the list
        //

        SceFreePSCE_SERVICES(*pSvcEngineList);
        *pSvcEngineList = NULL;
    }

    return( ScepDosErrorToSceStatus(Win32Rc) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\serverp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    serverp.h

Abstract:

    This module defines the data structures and function prototypes
    for the security managment utility

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

    jinhuang 26-Jan-1998   splitted for client-server

--*/

#ifndef _serverp_
#define _serverp_

#include "headers.h"

#include <ntsam.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <ntdddisk.h>
#define OEMRESOURCE     // setting this gets OBM_ constants in windows.h
#include <winspool.h>
#include <ddeml.h>
#include <commdlg.h>
#include <commctrl.h>
#include <cfgmgr32.h>
//#include <objbase.h>
#include <userenv.h>
#include <regstr.h>
#include <setupbat.h>
#include <aclapi.h>
#include <winldap.h>

#include "scejetp.h"
//
// the following header is defined as a c header so both c and cpp can
// link to the client lib
//
#include "scesvc.h"
#include "scerpc.h"

#include "scep.h"
#include "srvutil.h"
#include "srvrpcp.h"
#include "scesrvrc.h"
#include "sceutil.h"
#include "service.h"

#ifdef __cplusplus
extern "C" {
#endif

#if _WIN32_WINNT>=0x0500

#include <dsgetdc.h>
#include <ntdsapi.h>

typedef DWORD (WINAPI *PFNDSGETDCNAME)(LPCTSTR, LPCTSTR, GUID *, LPCTSTR, ULONG, PDOMAIN_CONTROLLER_INFO *);
typedef DWORD (WINAPI *PFNNETAPIFREE)(LPVOID);


#endif

#define Thread  __declspec( thread )

#define SCEP_LMC_SETTING L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\LmCompatibilityLevel"
#define SCEP_SECURE_CHANNEL_SIGNING_SETTING L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\RequireSignOrSeal"
#define SCEP_SECURITY_SIGNATURE_SETTING L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\EnableSecuritySignature"
#define SCEP_DRIVER_SIGNING_SETTING L"MACHINE\\Software\\Microsoft\\Driver Signing\\Policy"

extern DWORD Thread     gCurrentTicks;
extern DWORD Thread     gTotalTicks;
extern BYTE  Thread     cbClientFlag;
extern DWORD Thread     gWarningCode;
extern BOOL  Thread     gbInvalidData;
extern BOOL  Thread     bLogOn;
extern INT   Thread     gDebugLevel;

extern DWORD Thread     gMaxRegTicks;
extern DWORD Thread     gMaxFileTicks;
extern DWORD Thread     gMaxDsTicks;

extern NT_PRODUCT_TYPE  Thread ProductType;
extern PSID             Thread AdminsSid;


#define SCE_RPC_SERVER_ACTIVE       L"SCE_RPC_SERVER_ACTIVE"
#define SCE_RPC_SERVER_STOPPED      L"SCE_RPC_SERVER_STOPPED"

//
// prototypes in server.cpp
//

VOID
ScepInitServerData();

VOID
ScepUninitServerData();

NTSTATUS
ScepStartServerServices();

NTSTATUS
ScepStopServerServices(
    IN BOOL bShutDown
    );

SCESTATUS
ScepPostProgress(
   IN DWORD Delta,
   IN AREA_INFORMATION Area,
   IN LPTSTR szName OPTIONAL
   );

SCESTATUS
ScepRsopLog(
   IN AREA_INFORMATION Area,
   IN DWORD dwConfigStatus,
   IN wchar_t *pStatusInfo OPTIONAL,
   IN DWORD dwPrivLow OPTIONAL,
   IN DWORD dwPrivHigh OPTIONAL
   );

BOOL
ScepIsSystemShutDown();

SCESTATUS
ScepServerCancelTimer();

//
// prototypes in errlog.c
//

SCESTATUS
ScepSetVerboseLog(
    IN INT dbgLevel
    );

SCESTATUS
ScepEnableDisableLog(
   IN BOOL bOnOff
   );

//
// prototypes defined in tree.c
//

SCESTATUS
ScepBuildObjectTree(
    IN OUT PSCE_OBJECT_TREE *ParentNode,
    IN OUT PSCE_OBJECT_CHILD_LIST *ChildHead,
    IN ULONG Level,
    IN WCHAR Delim,
    IN PCWSTR ObjectFullName,
    IN BOOL IsContainer,
    IN BYTE Status,
    IN PSECURITY_DESCRIPTOR pInfSecurityDescriptor,
    IN SECURITY_INFORMATION InfSeInfo
    );

SCESTATUS
ScepCalculateSecurityToApply(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    );

SCESTATUS
ScepConfigureObjectTree(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    IN DWORD ConfigOptions
    );

SCESTATUS
ScepFreeObject2Security(
    IN PSCE_OBJECT_CHILD_LIST  NodeList,
    IN BOOL bFreeComputedSDOnly
    );

DWORD
ScepSetSecurityWin32(
    IN PCWSTR ObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType
    );

DWORD
ScepSetSecurityObjectOnly(
    IN PCWSTR ObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType,
    OUT PBOOL pbHasChild
    );

DWORD
ScepGetNewSecurity(
    IN LPTSTR ObjectName,
    IN PSECURITY_DESCRIPTOR pParentSD OPTIONAL,
    IN PSECURITY_DESCRIPTOR pObjectSD OPTIONAL,
    IN BYTE nFlag,
    IN BOOLEAN bIsContainer,
    IN SECURITY_INFORMATION SeInfo,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *ppNewSD
    );

SCESTATUS
ScepSetupResetLocalPolicy(
    IN PSCECONTEXT          Context,
    IN AREA_INFORMATION     Area,
    IN PCWSTR               SectionName OPTIONAL,
    IN SCETYPE              ProfileType,
    IN BOOL                 bKeepBasicPolicy
    );

DWORD
ScepAddSidStringToNameList(
    IN OUT PSCE_NAME_LIST *ppNameList,
    IN PSID pSid
    );

DWORD
ScepNotifyProcessOneNodeDC(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID ObjectSid,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    OUT BOOL *pbTimeout
    );

VOID
ScepConfigureConvertedFileSecurityThreadFunc(
    IN PVOID pV
    );

VOID
ScepWaitForServicesEventAndConvertSecurityThreadFunc(
    IN PVOID pV
    );

DWORD
ScepServerConfigureSystem(
    IN  PWSTR   InfFileName,
    IN  PWSTR   DatabaseName,
    IN  PWSTR   LogFileName,
    IN  DWORD   ConfigOptions,
    IN  AREA_INFORMATION  Area
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\service.h ===
//depot/private/vishnup_branch/DS/security/services/scerpc/server/service.h#1 - branch change 359 (text)
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    service.h

Abstract:

    Private headers for service.cpp

Author:

    Jin Huang (jinhuang) 25-Jan-1998

Revision History:

--*/

#ifndef _servicep_
#define _servicep_

#ifdef __cplusplus
extern "C" {
#endif


SCESTATUS
ScepConfigureGeneralServices(
    IN PSCECONTEXT hProfile,
    IN PSCE_SERVICES pServiceList,
    IN DWORD ConfigOptions
    );

SCESTATUS
ScepAnalyzeGeneralServices(
    IN PSCECONTEXT hProfile,
    IN DWORD Options
    );

SCESTATUS
ScepInvokeSpecificServices(
    IN PSCECONTEXT hProfile,
    IN BOOL bConfigure,
    IN SCE_ATTACHMENT_TYPE aType
    );

SCESTATUS
ScepEnumServiceEngines(
    OUT PSCE_SERVICES *pSvcEngineList,
    IN SCE_ATTACHMENT_TYPE aType
    );

//
// attachment engine call back functions
//
SCESTATUS
SceCbQueryInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    OUT PVOID               *ppvInfo,
    OUT PSCE_ENUMERATION_CONTEXT psceEnumHandle
    );

SCESTATUS
SceCbSetInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    IN PVOID                pvInfo
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\server.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    server.cpp

Abstract:

    Server (main) module

Author:

    Jin Huang (jinhuang) 28-Jan-1998

Revision History:

--*/
#include "serverp.h"
#include "service.h"
#include "ntrpcp.h"
#include "pfp.h"
#include "infp.h"
#include "sceutil.h"
#include "queue.h"
#include <io.h>
#include <lm.h>
#include <lmapibuf.h>
//
// thread global variables
//

DWORD Thread     gCurrentTicks=0;
DWORD Thread     gTotalTicks=0;
BYTE  Thread     cbClientFlag=0;
DWORD Thread     gWarningCode=0;
BOOL  Thread     gbInvalidData=FALSE;
BOOL  Thread     bLogOn=TRUE;
INT   Thread     gDebugLevel=-1;

extern DWORD gdwMaxPDCWait;
extern DWORD gdwPDCRetry;
extern DWORD gdwRequirePDCSync;
extern BOOL  gbCheckSync;

NT_PRODUCT_TYPE  Thread ProductType=NtProductWinNt;
PSID             Thread AdminsSid=NULL;

extern DWORD Thread     t_pebSize;
extern LPVOID Thread    t_pebClient;
extern LSA_HANDLE        Thread LsaPrivatePolicy;
extern HINSTANCE MyModuleHandle;

static PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo=NULL;
static BOOL gbSystemShutdown=FALSE;
static HANDLE hTimerQueue=NULL;

//
// database context list to keep tracking all client requested context
// so that they can be freed properly.
// if yes, we do not need to do this.
//

typedef struct _SCESRV_CONTEXT_LIST_ {

   PSCECONTEXT              Context;
   struct _SCESRV_CONTEXT_LIST_   *Next;
   struct _SCESRV_CONTEXT_LIST_   *Prior;

} SCESRV_CONTEXT_LIST, *PSCESRV_CONTEXT_LIST;

static PSCESRV_CONTEXT_LIST   pOpenContexts=NULL;
static CRITICAL_SECTION ContextSync;

//
// database task list to control simultaneous database operations under
// the same context (jet session)
//

typedef struct _SCESRV_DBTASK_ {

   PSCECONTEXT              Context;
   CRITICAL_SECTION         Sync;
   DWORD                    dInUsed;
   BOOL                     bCloseReq;
   struct _SCESRV_DBTASK_   *Next;
   struct _SCESRV_DBTASK_   *Prior;

} SCESRV_DBTASK, *PSCESRV_DBTASK;

static PSCESRV_DBTASK   pDbTask=NULL;
static CRITICAL_SECTION TaskSync;

#define SCE_TASK_LOCK       0x01L
#define SCE_TASK_CLOSE      0x02L

//
// engine task list to control simultaneous configuration/analysis engines
//

typedef struct _SCESRV_ENGINE_ {

   LPTSTR                   Database;
   struct _SCESRV_ENGINE_   *Next;
   struct _SCESRV_ENGINE_   *Prior;

} SCESRV_ENGINE, *PSCESRV_ENGINE;

static PSCESRV_ENGINE   pEngines=NULL;
static CRITICAL_SECTION EngSync;

//
// jet enigne synchronization
//

CRITICAL_SECTION JetSync;

//
// flag for stop request
//
static BOOL        bStopRequest=FALSE;
static BOOL        bDbStopped=FALSE;
static BOOL        bEngStopped=FALSE;

static CRITICAL_SECTION RpcSync;
static BOOL RpcStarted = FALSE;
static BOOL ServerInited = FALSE;

static CRITICAL_SECTION CloseSync;

static HINSTANCE hSceCliDll=NULL;
static PFSCEINFWRITEINFO pfSceInfWriteInfo=NULL;
static PFSCEGETINFO pfSceGetInfo=NULL;

extern PSCESRV_POLQUEUE pNotificationQHead;
#define SCE_POLICY_MAX_WAIT 24
static DWORD gPolicyWaitCount=0;

#define SERVICE_SAMSS       TEXT("SamSS")

SCESTATUS
ScepGenerateAttachmentSections(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName,
    IN SCE_ATTACHMENT_TYPE aType
    );

SCESTATUS
ScepGenerateWMIAttachmentSections(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName
    );

SCESTATUS
ScepGenerateOneAttachmentSection(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName,
    IN LPTSTR SectionName,
    IN BOOL bWMISection
    );

VOID
ScepWaitForSamSS(
    IN PVOID pContext
    );

SCESTATUS
ScepConvertServices(
    IN OUT PVOID *ppServices,
    IN BOOL bSRForm
    );

SCESTATUS
ScepFreeConvertedServices(
    IN PVOID pServices,
    IN BOOL bSRForm
    );

DWORD
ScepConfigureConvertedFileSecurityImmediate(
    IN PWSTR  pszDriveName
    );

DWORD
ScepWaitForSynchronizeWithPDC(
    IN UNICODE_STRING DnsDomainName,
    IN PWSTR LocalTemplateName,
    OUT BOOL *pbTimeout
    );

DWORD
ScepVerifyPDCRole(
    IN PWSTR pComputerName,
    OUT BOOL *pbIsPDC
    );

////////////////////////////////////////////////////////////////////////
//
// Server Control APIs
//
////////////////////////////////////////////////////////////////////////

VOID
ScepInitServerData()
/*
Routine Description:

    Initialize global data for the server

Arguments:

    None

Return Value:

    None
*/
{
    //
    // initialize RPC server controls
    //

    InitializeCriticalSection(&RpcSync);
    RpcStarted = FALSE;
    ServerInited = FALSE;
    //
    // flag to indicate if the server is requested to stop.
    //
    bStopRequest = TRUE;  // will be reset when server is started up so this will
                          // block all RPC calls before server is ready

    //
    // database operation pending tasks control
    //
    pDbTask=NULL;
    InitializeCriticalSection(&TaskSync);

    //
    // configuration/analysis engine task control
    //
    pEngines=NULL;
    InitializeCriticalSection(&EngSync);

    //
    // should also remember all created database context so that
    // resource can be freed when server is shutting down
    //

    InitializeCriticalSection(&CloseSync);

    pOpenContexts = NULL;
    InitializeCriticalSection(&ContextSync);

    bEngStopped = FALSE;
    bDbStopped = FALSE;

    //
    // jet engine synchronization
    //
    InitializeCriticalSection(&JetSync);

    //
    // initialize jet engine globals
    //
    SceJetInitializeData();

    //
    // initialize queue related stuff
    //
    ScepNotificationQInitialize();

    return;
}


VOID
ScepUninitServerData()
/*
Routine Description:

    UnInitialize global data for the server

Arguments:

    None

Return Value:

    None
*/
{
    //
    // delete the critical sections
    //

    DeleteCriticalSection(&RpcSync);

    DeleteCriticalSection(&TaskSync);

    DeleteCriticalSection(&EngSync);

    DeleteCriticalSection(&CloseSync);

    DeleteCriticalSection(&ContextSync);

    DeleteCriticalSection(&JetSync);

    return;
}


NTSTATUS
ScepStartServerServices()
/*++

Routine Description:

    It starts the server services.

Arguments:

    None.

Return Value:

    NT status.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RPC_STATUS        RpcStatus;

    //
    // start RPC server
    //

    EnterCriticalSection(&RpcSync);

    if ( !RpcStarted ) {

        //
        // use secure RPC
        //
        Status = RpcServerRegisterAuthInfo(
                        NULL,
                        RPC_C_AUTHN_WINNT,
                        NULL,
                        NULL
                        );

        if ( NT_SUCCESS(Status) ) {

            RpcStatus = RpcpAddInterface( L"scerpc",
                                          scerpc_ServerIfHandle);

            if ( RpcStatus != RPC_S_OK ) {
                //
                // can't add RPC interface
                //
                Status = I_RpcMapWin32Status(RpcStatus);

            } else {

                //
                // The first argument specifies the minimum number of threads to
                // be created to handle calls; the second argument specifies the
                // maximum number of concurrent calls allowed.  The last argument
                // indicates not to wait.
                //

                RpcStatus = RpcServerListen(1,12345, 1);

                if ( RpcStatus == RPC_S_ALREADY_LISTENING ) {
                    RpcStatus = RPC_S_OK;
                }

                Status = I_RpcMapWin32Status(RpcStatus);

                if ( RpcStatus == RPC_S_OK ) {
                    RpcStarted = TRUE;
                }
            }
        }
    }

    if ( NT_SUCCESS(Status) ) {

        //
        // RPC server started
        // jet engine will be initialized when a database call comes in
        //

        intptr_t            hFile;
        struct _wfinddata_t    FileInfo;

        PWSTR szCompLog=NULL, szCompSav=NULL;

        SafeAllocaAllocate(szCompLog, (MAX_PATH+50)*sizeof(WCHAR));
        SafeAllocaAllocate(szCompSav, (MAX_PATH*2+20)*sizeof(WCHAR));

        //
        // delete the component log file
        //

        if ( szCompLog && szCompSav ) {

            szCompLog[0] = L'\0';
            GetSystemWindowsDirectory(szCompLog, MAX_PATH);
            szCompLog[MAX_PATH-1] = L'\0';

            DWORD WindirLen = wcslen(szCompLog);

            wcscpy(szCompSav, szCompLog);

            wcscat(szCompLog, L"\\security\\logs\\scecomp.log\0");
            wcscat(szCompSav, L"\\security\\logs\\scecomp.old\0");

            CopyFile(szCompLog, szCompSav, FALSE);

            DeleteFile(szCompLog);

            //
            // clean up temp files
            //

            wcscpy(szCompLog+WindirLen, L"\\security\\sce*.tmp");


            hFile = _wfindfirst(szCompLog, &FileInfo);

            if ( hFile != -1 ) {

                do {

                    wcscpy(szCompSav+WindirLen, L"\\security\\");
                    wcscat(szCompSav, FileInfo.name);

                    DeleteFile(szCompSav);

                } while ( _wfindnext(hFile, &FileInfo) == 0 );

                _findclose(hFile);
            }

            //
            // reset the stop request flag
            //

            bEngStopped = FALSE;
            bDbStopped = FALSE;
            bStopRequest = FALSE;

        } else {
            Status = STATUS_NO_MEMORY;
        }

        SafeAllocaFree(szCompLog);
        SafeAllocaFree(szCompSav);
    }

    pEngines = NULL;
    pOpenContexts = NULL;
    pDbTask = NULL;

    //
    // start a system thread to handle notifications
    // if the thread can't be started, return failure to services.exe
    // which will reboot.
    //
    if ( NT_SUCCESS(Status) ) {
        Status = ScepQueueStartSystemThread();
    }

    LeaveCriticalSection(&RpcSync);

    if ( NT_SUCCESS(Status) ) {
        //
        // launch a worker thread to wait for SAMSS service
        // the only failure case would be out of memory, in which case,
        // return the error to initialize code (to shutdown the system).
        //
        Status = RtlQueueWorkItem(
                        ScepWaitForSamSS,
                        NULL,
                        WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION
                        ) ;
    }

    return(Status);
}

VOID
ScepWaitForSamSS(
    IN PVOID pContext
    )
{
    //
    // make sure this function handles server temination
    // If for some reason, the wait times out, set ServerInited to TRUE
    // and let RPC threads continue to perform the task (and may fail later on)
    //

    DWORD rc = ERROR_SUCCESS;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    ULONG Timeout;
    ULONG TimeSleep;
    SERVICE_STATUS ServiceStatus;

    Timeout = 600; // 600 second timeout

    //
    // Open a handle to the Netlogon Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        rc = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        SERVICE_SAMSS,
                        SERVICE_QUERY_STATUS );

    if ( ServiceHandle == NULL ) {
        rc = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Loop waiting for the SamSS service to start.
    //

    for (;;) {

        //
        // Query the status of the SamSS service.
        //
        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {

            rc = GetLastError();
            goto Cleanup;
        }

        //
        // Return or continue waiting depending on the state of
        //  the netlogon service.
        //

        switch( ServiceStatus.dwCurrentState) {
        case SERVICE_RUNNING:
            rc = ERROR_SUCCESS;
            ServerInited = TRUE;
            goto Cleanup;

        case SERVICE_STOPPED:

            //
            // If Netlogon failed to start,
            //  error out now.  The caller has waited long enough to start.
            //
            if ( ServiceStatus.dwWin32ExitCode != ERROR_SERVICE_NEVER_STARTED ){
                rc = ERROR_NOT_SUPPORTED;
                goto Cleanup;
            }

            //
            // If SamSs has never been started on this boot,
            //  continue waiting for it to start.
            //

            break;

        //
        // If SamSS is trying to start up now,
        //  continue waiting for it to start.
        //
        case SERVICE_START_PENDING:
            break;

        //
        // Any other state is bogus.
        //
        default:
            rc = ERROR_NOT_SUPPORTED;
            goto Cleanup;

        }

        //
        // if server is shutting down, break this loop
        //

        if ( bStopRequest ) {
            break;
        }

        //
        // sleep for ten seconds;
        //
        if ( Timeout > 5 ) {
            TimeSleep = 5;
        } else {
            TimeSleep = Timeout;
        }

        Sleep(TimeSleep*1000);

        Timeout -= TimeSleep;

        if ( Timeout == 0 ) {
            rc = ERROR_NOT_SUPPORTED;
            goto Cleanup;
        }

    }

    ServerInited = TRUE;

Cleanup:
    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }

    if ( ERROR_SUCCESS != rc ) {

        //
        // even if it failed to wait for SAMSS service
        // still set the init flag to let RPC threads go through
        // after sleep for the timeout
        //

        if ( Timeout > 0 ) {
            Sleep(Timeout*1000);  // timeout second
        }

        ServerInited = TRUE;
    }

}


NTSTATUS
ScepStopServerServices(
    IN BOOL bShutDown
    )
/*++

Routine Description:

    It stops the server services. This include:
        Blocking all new RPC requests
        Stop RPC server
        wait for all active database operations to finish
        Close all context handles
        Terminate jet engine

Arguments:

    bShutdown  - if the server is shutting down.

Return Value:

    NT status.

--*/
{
    NTSTATUS    Status=STATUS_SUCCESS;
    RPC_STATUS RpcStatus;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER CurrentTime;
    DWORD dStartSeconds;
    DWORD dCurrentSeconds;

    //
    // no need to critical section this one because there
    // should be only one writer to this variable and I
    // don't care the readers
    //
    gbSystemShutdown = bShutDown;

    EnterCriticalSection(&RpcSync);

    //
    // block new RPC requests
    //

    bStopRequest = TRUE;

    ScepServerCancelTimer();

    //
    // stop RPC server
    //

    if ( RpcStarted ) {

        //
        // use secure RPC
        //
        RpcStatus = RpcServerUnregisterIf(scerpc_ServerIfHandle,
                                          0,
                                          1);

        if ( RpcStatus == RPC_S_OK ) {

            RpcStatus = RpcMgmtStopServerListening(NULL);
        }

        if ( RpcStatus == RPC_S_OK ) {

            RpcStatus = RpcMgmtWaitServerListen();
        }

        Status = I_RpcMapWin32Status(RpcStatus);

        if ( RpcStatus == RPC_S_OK ) {
            //
            // reset the flag
            //
            RpcStarted = FALSE;
        }
    }

    // db task
    EnterCriticalSection(&TaskSync);

    if ( pDbTask ) {

        bDbStopped = FALSE;
        LeaveCriticalSection(&TaskSync);

        NtQuerySystemTime(&StartTime);
        RtlTimeToSecondsSince1980 (&StartTime, &dStartSeconds);

        while ( !bDbStopped ) {
            //
            // wait until remove task routine removes everything
            // wait maximum 1 minutes in case some tasks are dead or looping
            //
            NtQuerySystemTime(&CurrentTime);
            RtlTimeToSecondsSince1980 (&CurrentTime, &dCurrentSeconds);

            if ( dCurrentSeconds - dStartSeconds > 60 ) {
                //
                // too long, break it
                //
                break;
            }
        }

    } else {
        //
        // new tasks are already blocked by bStopRequest
        // so pDbTask won't be !NULL again
        //
        LeaveCriticalSection(&TaskSync);
    }

    // engine task
    EnterCriticalSection(&EngSync);

    if ( pEngines ) {

        bEngStopped = FALSE;
        LeaveCriticalSection(&EngSync);

        NtQuerySystemTime(&StartTime);
        RtlTimeToSecondsSince1980 (&StartTime, &dStartSeconds);

        while ( !bEngStopped ) {
            //
            // wait until remove task routine removes everything
            // wait maximum 1 minutes in case some tasks are dead or looping
            //
            NtQuerySystemTime(&CurrentTime);
            RtlTimeToSecondsSince1980 (&CurrentTime, &dCurrentSeconds);

            if ( dCurrentSeconds - dStartSeconds > 60 ) {
                //
                // too long, break it
                //
                break;
            }
        }

    } else {
        //
        // new tasks are already blocked by bStopRequest
        // so pEngines won't be !NULL again
        //
        LeaveCriticalSection(&EngSync);

    }

    //
    // close all client's contexts
    //

    EnterCriticalSection(&ContextSync);

    PSCESRV_CONTEXT_LIST pList=pOpenContexts;
    PSCESRV_CONTEXT_LIST pTemp;

    while ( pList ) {

       __try {
           if ( pList->Context && ScepIsValidContext(pList->Context) ) {

               ScepCloseDatabase(pList->Context);

               pTemp = pList;
               pList = pList->Next;

               ScepFree(pTemp);

           } else {
               // it's already freed
               break;
           }
       } __except (EXCEPTION_EXECUTE_HANDLER) {
           break;
       }
    }

    pOpenContexts = NULL;

    LeaveCriticalSection(&ContextSync);

    //
    // check policy tasks
    //
    ScepQueuePrepareShutdown();

    if ( DnsDomainInfo ) {

        //
        // there is no other threads, free DnsDomainInfo
        //

        LsaFreeMemory( DnsDomainInfo );
        DnsDomainInfo = NULL;
    }

    //
    // terminate jet engine
    //

    SceJetTerminate(TRUE);

    SceJetDeleteJetFiles(NULL);

    LeaveCriticalSection(&RpcSync);

    return(Status);
}

SCESTATUS
ScepRsopLog(
   IN AREA_INFORMATION Area,
   IN DWORD dwConfigStatus,
   IN wchar_t *pStatusInfo OPTIONAL,
   IN DWORD dwPrivLow OPTIONAL,
   IN DWORD dwPrivHigh OPTIONAL
   )
/*
Routine Description:

    Call back to client for logging RSOP diagnosis mode data

Arguments:

    Area - the area being logged (used in client side in conjunction with last parameter pStatusInfo)

    dwConfigStatus - error/success code of the particular setting in question

   pStatusInfo - finer information regarding the above area (specific setting name etc.)
*/
{
    //
    // call back to client
    //
    __try {

        SceClientCallbackRsopLog(Area, dwConfigStatus, pStatusInfo, dwPrivLow, dwPrivHigh);

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

return(SCESTATUS_SUCCESS);
}

SCESTATUS
ScepPostProgress(
   IN DWORD Delta,
   IN AREA_INFORMATION Area,
   IN LPTSTR szName OPTIONAL
   )
/*
Routine Description:

    Call back to client for the progress of current thread, if client set
    the callback flag.

Arguments:

    Delta - Ticks changes since last callback

    szName - the current item name
*/
{

   if ( cbClientFlag ) {

       //
       // callback is requested
       //

       gCurrentTicks += Delta;

       //
       // call back to client
       //
       __try {

           switch (cbClientFlag ) {
           case SCE_CALLBACK_DELTA:
               SceClientCallback(Delta,0,0,(wchar_t *)szName);
               break;

           case SCE_CALLBACK_TOTAL:
               if ( Area ) {
                   SceClientCallback(gCurrentTicks, gTotalTicks, Area, (wchar_t *)szName);
               }
               break;
           }

       } __except(EXCEPTION_EXECUTE_HANDLER) {

           return(SCESTATUS_INVALID_PARAMETER);
       }
   }

   return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepValidateAndLockContext(
    IN PSCECONTEXT Context,
    IN BYTE LockFlag,
    IN BOOL bRequireWrite,
    OUT PSCESRV_DBTASK *ppTask OPTIONAL
    )
/*
Routine Description:

    Validate the context handle is SCE context handle.
    If the same context (same session) is already used for another
    database operation, this operation will be in waiting (a critical
    section pointer is returned)

Arguments:

    Context     - the context handle

    bLock       - TRUE=perform the lock

    ppTask      - the output task pointer

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc = SCESTATUS_INVALID_PARAMETER;

    if ( (LockFlag & SCE_TASK_LOCK) && !ppTask ) {
        //
        // if willing to lock, ppTask must NOT be NULL
        //
        return(rc);
    }

    if ( !Context ) {
        //
        // contents of the context will be checked within the critical section
        // because other threads might free the context within there.
        //
        return(rc);
    }

    if ( ppTask ) {
        *ppTask = NULL;
    }

    //
    // lock the task list and verify the context
    //

    EnterCriticalSection(&TaskSync);

    if ( bStopRequest ) {
        LeaveCriticalSection(&TaskSync);
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    if ( ScepIsValidContext(Context) &&
         ( Context->JetSessionID != JET_sesidNil ) &&
         ( Context->JetDbID != JET_dbidNil) ) {

        rc = SCESTATUS_SUCCESS;

        if ( bRequireWrite &&
             ( SCEJET_OPEN_READ_ONLY == Context->OpenFlag ) ) {
            //
            // write operation is requested but the database is only granted
            // read only access to this context.
            //
            rc = SCESTATUS_ACCESS_DENIED;
        } else {
            //
            // check if esent delay load successful
            //
            DWORD dbVersion;

            __try {
                JetGetDatabaseInfo(Context->JetSessionID,
                                   Context->JetDbID,
                                   (void *)&dbVersion,
                                   sizeof(DWORD),
                                   JET_DbInfoVersion
                                   );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // esent.dll is not loaded (delay) successfully
                //
                rc = SCESTATUS_MOD_NOT_FOUND;
            }
        }

    } else {
        rc = SCESTATUS_INVALID_PARAMETER;
    }

    if ( SCESTATUS_SUCCESS == rc && LockFlag ) {

        PSCESRV_DBTASK pdb = pDbTask;

        while ( pdb ) {
            if ( pdb->Context &&
                 pdb->Context->JetSessionID == Context->JetSessionID &&
                 pdb->Context->JetDbID == Context->JetDbID ) {
                break;
            }
            pdb = pdb->Next;
        }

        if ( pdb && pdb->Context ) {

            //
            // find the same context address and same session
            // critical section is in pdb->Sync
            //

            if ( pdb->bCloseReq ) {

                //
                // error this thread out because another thread is closing the
                // same context
                //

                rc = SCESTATUS_ACCESS_DENIED;

            } else if ( LockFlag & SCE_TASK_CLOSE ) {

                //
                // close on this context is requested but there are other
                // thread running under this context, so just turn on the flag
                // and the context will be closed when all pending tasks
                // are done
                //

                pdb->bCloseReq = TRUE;

            } else {

                //
                // request a lock, it's ok for this task to continue
                //

                pdb->dInUsed++;
                *ppTask = pdb;
            }

        } else {

            //
            // did not find the same context, this operation is ok to go
            // but need to add itself to the list
            //

            if ( LockFlag & SCE_TASK_CLOSE ) {

                //
                // a close context is requested, other threads using
                // the same context will be invalidated after this context
                // is freed
                //

                rc = ScepCloseDatabase(Context);

            } else if ( LockFlag & SCE_TASK_LOCK ) {

                PSCESRV_DBTASK NewDbTask = (PSCESRV_DBTASK)ScepAlloc(0, sizeof(SCESRV_DBTASK));

                if ( NewDbTask ) {
                    //
                    // new node is created
                    //
                    NewDbTask->Context = Context;
                    NewDbTask->Prior = NULL;
                    NewDbTask->dInUsed = 1;
                    NewDbTask->bCloseReq = FALSE;

                    InitializeCriticalSection(&(NewDbTask->Sync));

                    //
                    // link it to the db task list
                    //

                    NewDbTask->Next = pDbTask;

                    if ( pDbTask ) {
                        pDbTask->Prior = NewDbTask;
                    }

                    pDbTask = NewDbTask;

                    *ppTask = NewDbTask;

                } else {

                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                }

            } else {
                //
                // no lock, no close, just return
                //
            }
        }

    }

    LeaveCriticalSection(&TaskSync);

    return(rc);
}


SCESTATUS
ScepRemoveTask(
    PSCESRV_DBTASK pTask
    )
/*
Routine Description:

    Remove the task (context) from dbtask table if there is no other
    thread running in the same context.

Arguments:


    pTask       - the task node containing context and critical section

Return Value:

    SCESTATUS
*/
{

    if ( !pTask ) {
        return(SCESTATUS_SUCCESS);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    EnterCriticalSection(&TaskSync);

    //
    // find the task pointer in the task list for verification
    //

    PSCESRV_DBTASK pdb = pDbTask;

    while ( pdb && (ULONG_PTR)pdb != (ULONG_PTR)pTask ) {

        pdb = pdb->Next;
    }

    if ( pdb ) {

        //
        // find the same task node
        //

        pdb->dInUsed--;

        if ( 0 == pdb->dInUsed ) {

            //
            // nobody is using this task node
            // remove it
            //

            if ( pdb->Prior ) {

                pdb->Prior->Next = pdb->Next;

            } else {
                //
                // no parent node, set the static variable
                //
                pDbTask = pdb->Next;

            }

            //
            // this is a double link list, remember to remove the Prior link
            //

            if ( pdb->Next ) {
                pdb->Next->Prior = pdb->Prior;
            }

            //
            // if close request is send, close this database
            //

            if ( pdb->bCloseReq && pdb->Context ) {

                ScepCloseDatabase(pdb->Context);
            }

            //
            // delete the critical section
            //
            DeleteCriticalSection(&(pdb->Sync));

            //
            // free the memory used by this node
            //

            ScepFree(pdb);

        } else {

            //
            // other thread is using this task node for database operation
            // do nothing
            //
        }

    } else {

        //
        // can't find the task node in global the task list
        //
        rc = SCESTATUS_INVALID_PARAMETER;

    }

    //
    // if stop is requested, notify the server that db task is done
    //
    if ( bStopRequest && !pDbTask ) {
        bDbStopped = TRUE;
    }

    LeaveCriticalSection(&TaskSync);

    return(rc);
}


SCESTATUS
ScepLockEngine(
    IN LPTSTR DatabaseName
    )
/*
Routine Description:

    Lock the database for configuration/analysis.

    Only one engine can run on the same database for configuration or
    analysis because first it's meaningless to have multiple engines
    running toward the same system, and second, the database is changed
    by the engine (table may be deleted, so on...)

    OpenDatabase is not locked by this lock, because each OpenDatabase
    has its own session and cursor and no operations such as delete the
    database or delete a table can be done with that context.

Arguments:

    DefProfile - the database name

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc;

    if ( !DatabaseName ) {
        //
        // if willing to lock, ppTask must NOT be NULL
        //
        return(SCESTATUS_INVALID_PARAMETER);
    }

    EnterCriticalSection(&EngSync);

    if ( bStopRequest ) {
        LeaveCriticalSection(&EngSync);
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    PSCESRV_ENGINE pe = pEngines;

    while ( pe ) {
        if ( pe->Database &&
             0 == _wcsicmp(pe->Database, DatabaseName) ) {
            break;
        }
        pe = pe->Next;
    }

    if ( pe ) {

        //
        // find the same database running by other threads
        //

        rc = SCESTATUS_ALREADY_RUNNING;

    } else {

        //
        // did not find the same database, this operation is ok to go
        // but need to add itself to the list
        //

        PSCESRV_ENGINE NewEng = (PSCESRV_ENGINE)ScepAlloc(0, sizeof(SCESRV_ENGINE));

        if ( NewEng ) {

            //
            // new node is created
            //
            NewEng->Database = (LPTSTR)ScepAlloc(LPTR, (wcslen(DatabaseName)+1)*sizeof(TCHAR));

            if ( NewEng->Database ) {

                wcscpy(NewEng->Database, DatabaseName);

                NewEng->Next = pEngines;
                NewEng->Prior = NULL;

                if ( pEngines ) {
                    pEngines->Prior = NewEng;
                }

                pEngines = NewEng;

                rc = SCESTATUS_SUCCESS;

            } else {

                ScepFree(NewEng);
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

        } else {

            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    LeaveCriticalSection(&EngSync);

    return(rc);

}

SCESTATUS
ScepUnlockEngine(
    IN LPTSTR DatabaseName
    )
/*
Routine Description:

    Unlock the database.

Arguments:

    DatabaseName - the database name

Return Value:

    SCESTATUS
*/
{
    if ( !DatabaseName ) {
        //
        // if no database name, just return
        //
        return(SCESTATUS_SUCCESS);
    }

    EnterCriticalSection(&EngSync);

    PSCESRV_ENGINE pe = pEngines;

    while ( pe && pe->Database &&
            0 != _wcsicmp(pe->Database, DatabaseName) ) {
        pe = pe->Next;
    }

    if ( pe ) {

        //
        // find the database, unlock it.
        //
        if ( pe->Prior ) {

            pe->Prior->Next = pe->Next;

        } else {

            //
            // no parent node, set the static variable
            //

            pEngines = pe->Next;

        }

        //
        // this is a double link list, remember to remove the Prior link
        //

        if ( pe->Next ) {
            pe->Next->Prior = pe->Prior;
        }

        //
        // free the node
        //

        if ( pe->Database ) {
            ScepFree(pe->Database);
        }

        ScepFree(pe);
    }

    //
    // if stop is requested, notify the server that engine are done
    //
    if ( bStopRequest && !pEngines ) {
        bEngStopped = TRUE;
    }

    LeaveCriticalSection(&EngSync);

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepAddToOpenContext(
    IN PSCECONTEXT Context
    )
{
    if ( !Context ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS  rc=SCESTATUS_SUCCESS;

    __try {
        if ( ScepIsValidContext(Context) ) {

            PSCESRV_CONTEXT_LIST pList=pOpenContexts;

            //
            // note, ContextSync is already entered before this function is called
            //

            while ( pList ) {

                if ( pList->Context &&
                     pList->Context->JetSessionID == Context->JetSessionID &&
                     pList->Context->JetDbID == Context->JetDbID ) {
//                     0 == memcmp(pList->Context, Context, sizeof(SCECONTEXT)) ) {
                    break;
                }
                pList = pList->Next;
            }

            if ( !pList ) {

                //
                // did not find this open context, add it
                //
                pList = (PSCESRV_CONTEXT_LIST)ScepAlloc(0, sizeof(SCESRV_CONTEXT_LIST));

                if ( pList ) {
                    pList->Context = Context;
                    pList->Prior = NULL;
                    pList->Next = pOpenContexts;

                    if ( pOpenContexts ) {
                        pOpenContexts->Prior = pList;
                    }
                    pOpenContexts = pList;

                } else {

                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                }

            }

        } else {
            rc = SCESTATUS_INVALID_PARAMETER;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = SCESTATUS_INVALID_PARAMETER;
    }

    return(rc);
}

BOOL
ScepNoActiveContexts()
{

    BOOL bExist=FALSE;

    //
    // any active task ?
    //
    EnterCriticalSection(&TaskSync);

    if ( pDbTask ) {
        bExist = TRUE;
    }

    LeaveCriticalSection(&TaskSync);

    if ( bExist ) {
        return FALSE;
    }

    //
    // any active db engine task ?
    //
    EnterCriticalSection(&EngSync);

    if ( pEngines ) {
        bExist = TRUE;
    }

    LeaveCriticalSection(&EngSync);

    if ( bExist ) {
        return FALSE;
    }

    //
    // any open contexts ?
    //
    EnterCriticalSection(&ContextSync);

    if ( pOpenContexts ) {
        bExist = TRUE;
    }

    LeaveCriticalSection(&ContextSync);

    return !bExist;
}


VOID
pDelayShutdownFunc(
    IN PVOID Context,
    IN UCHAR Timeout
    )
{

    if ( TryEnterCriticalSection(&JetSync) ) {

        if ( hTimerQueue ) {
            //
            // it's necessary to do this check because there might be another thread
            // cancelled this timer (after it's fired)
            //
            if ( ScepNoActiveContexts() ) {

                SceJetTerminateNoCritical(TRUE);  // clean version store (FALSE);
            }

            //
            // 4. Note that UNLIKE before, EVERY timer needs to be deleted by calling
            // RtlDeleteTimer even if they are one shot objects and have fired.
            //
            DeleteTimerQueueTimer( NULL, hTimerQueue, NULL );

            //
            // do not call CloseHandle because the handle will be closed by the
            // timer function.

            hTimerQueue = NULL;
        }

        LeaveCriticalSection(&JetSync);

    } else {
        //
        // there is other thread holding off this one.
        // This means there is still active clients, or a new client
        // coming in, just return. htimerQueue will be reset by another thread
        //
    }
}


BOOL
ScepIfTerminateEngine()
{
    //
    // if system is requesting a shutdown, don't do
    // anything, because the active clients and jet engine will be shutdown
    //
    if ( ScepIsSystemShutDown() ) {
        return TRUE;
    }

    if ( ScepNoActiveContexts() ) {
        //
        // use JetSync to control timer queue
        //
        EnterCriticalSection(&JetSync);

        DWORD Interval = 6*60*1000 ;   // 6 minutes

        if ( !CreateTimerQueueTimer(
                        &hTimerQueue,
                        NULL,
                        pDelayShutdownFunc,
                        NULL,
                        Interval,
                        0,
                        0 ) ) {
            hTimerQueue = NULL;
        }

        LeaveCriticalSection(&JetSync);

        return TRUE;

    } else {
        return FALSE;
    }
}

SCESTATUS
ScepServerCancelTimer()
{

    EnterCriticalSection(&JetSync);

    if (hTimerQueue ) {

        DeleteTimerQueueTimer(
                NULL,
                hTimerQueue,
                (HANDLE)-1
                );
        hTimerQueue = NULL;
    }

    LeaveCriticalSection(&JetSync);

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepValidateAndCloseDatabase(
    IN PSCECONTEXT Context
    )
{
    SCESTATUS rc;


    EnterCriticalSection(&CloseSync);

    if ( ScepIsValidContext(Context) ) {

        rc = SCESTATUS_SUCCESS;

    } else {

        rc = SCESTATUS_INVALID_PARAMETER;
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        LeaveCriticalSection(&CloseSync);
        return(rc);
    }

    //
    // be able to access the first byte
    //

    EnterCriticalSection(&ContextSync);


    PSCESRV_CONTEXT_LIST pList=pOpenContexts;

    while ( pList && ((ULONG_PTR)(pList->Context) != (ULONG_PTR)Context ||
                      pList->Context->JetSessionID != Context->JetSessionID ||
                      pList->Context->JetDbID != Context->JetDbID) ) {
        pList = pList->Next;
    }

    if ( pList ) {
        //
        // find the open context, remove it from the open context list
        // NOTE: both Prior and Next should be handled
        //

        if ( pList->Prior ) {

            pList->Prior->Next = pList->Next;
        } else {

            pOpenContexts = pList->Next;
        }

        if ( pList->Next ) {
            pList->Next->Prior = pList->Prior;
        }

        //
        // free pList, do not call CloseDatabase because it will
        // be closed in the following call.
        //
        ScepFree(pList);

    }

    LeaveCriticalSection(&ContextSync);

    //
    // if there are other threads running using the
    // same database context, the close request is
    // turned on. When all threads using the context
    // finish, the context is closed.
    //
    // this client calling close won't have to wait
    // for other threads using the same context
    //

    rc = ScepValidateAndLockContext(
                    (PSCECONTEXT)Context,
                    SCE_TASK_CLOSE,
                    FALSE,
                    NULL);

    LeaveCriticalSection(&CloseSync);

    //
    // start a timer queue to check to see if there is active tasks/contexts
    // if not, terminate jet engine
    //
    ScepIfTerminateEngine();

    return(rc);
}


SCEPR_STATUS
SceSvcRpcQueryInfo(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_SVCINFO_TYPE SceSvcType,
    IN wchar_t *ServiceName,
    IN wchar_t *Prefix OPTIONAL,
    IN BOOL bExact,
    OUT PSCEPR_SVCINFO __RPC_FAR *ppvInfo,
    IN OUT PSCEPR_ENUM_CONTEXT psceEnumHandle
    )
/*
Routine Description:

    Retrieve information for the service from the database. If there are
    more than the maximum allowed records for the service, only maximum
    allowed records are returned. Client must use the enumeration handle
    to make next query.

    If during the enumeration, another client using the same context (which
    is wired but it's possible) to change the information for this service,
    the first client may get incorrect information.

    The recommend solution is to use another context handle when doing the
    update.

Arguments:

    Context     - the context handle

    SceSvcType  - the info type requested

    ServiceName - the service name for which info is requested

    Prefix      - optional key prefix

    bExact      - TRUE = exact match on key

    ppvInfo     - output buffer

    psceEnumHandle - the enumeration handle (used for next enumeration)

Return Value:

    SCEPR_STATUS
*/
{
    SCESTATUS rc;
    BOOL    bAdminSidInToken = FALSE;

    UINT ClientLocalFlag = 0;

    if ( !ServiceName || !ppvInfo || !psceEnumHandle ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( rc );
    }

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;

    }


    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        //
        // query the information now
        //
#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            __try {

                rc = SceSvcpQueryInfo(
                    (PSCECONTEXT)Context,
                    (SCESVC_INFO_TYPE)SceSvcType,
                    (PCWSTR)ServiceName,
                    (PWSTR)Prefix,
                    bExact,
                    (PVOID *)ppvInfo,
                    (PSCE_ENUMERATION_CONTEXT)psceEnumHandle
                    );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                //
                // free ppvInfo if it's allocated
                //
                SceSvcpFreeMemory(*ppvInfo);

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceSvcRpcSetInfo(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_SVCINFO_TYPE SceSvcType,
    IN wchar_t *ServiceName,
    IN wchar_t *Prefix OPTIONAL,
    IN BOOL bExact,
    IN PSCEPR_SVCINFO pvInfo
    )
/*
Routine Description:

    Write information for the service to the database.

Arguments:

    Context     - the context handle

    SceSvcType  - the info type requested

    ServiceName - the service name for which info is requested

    Prefix      - optional key prefix

    bExact      - TRUE = exact match on key

    pvInfo     - output buffer

Return Value:

    SCEPR_STATUS
*/
{
    SCESTATUS rc;
    BOOL    bAdminSidInToken = FALSE;

    UINT ClientLocalFlag = 0;

    if ( !ServiceName || !pvInfo ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( rc );
    }

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // set the information now
            //

            __try {

                rc = SceSvcpSetInfo(
                        (PSCECONTEXT)Context,
                        (SCESVC_INFO_TYPE)SceSvcType,
                        (LPTSTR)ServiceName,
                        (LPTSTR)Prefix,
                        bExact,
                        0,
                        (PVOID)pvInfo
                        );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}


DWORD
SceRpcSetupUpdateObject(
    IN SCEPR_CONTEXT Context,
    IN wchar_t *ObjectFullName,
    IN DWORD ObjectType,
    IN UINT nFlag,
    IN wchar_t *SDText
    )
/*
Routine Description:

    Update object's security settings.

Arguments:

    Context     - the context handle

    ObjectFullName - the object's full path name

    ObjectType  - the object type

    nFlag       - the update flag

    SDText      - the SDDL text for the object

Return Value:

    DWORD
*/
{
    if ( !ObjectFullName || !SDText ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD rc;

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;

    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {

#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // update object, return code is DWORD
            //
                rc = ScepSetupUpdateObject(
                            (PSCECONTEXT)Context,
                            (LPTSTR)ObjectFullName,
                            (SE_OBJECT_TYPE)ObjectType,
                            nFlag,
                            (LPTSTR)SDText
                            );

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif
        } __except(EXCEPTION_EXECUTE_HANDLER) {

           rc = ERROR_EXCEPTION_IN_SERVICE;
        }

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    } else {

        rc = ScepSceStatusToDosError(rc);
    }

    RpcRevertToSelf();

    return(rc);
}



DWORD
SceRpcSetupMoveFile(
    IN SCEPR_CONTEXT Context,
    IN wchar_t *OldName,
    IN wchar_t *NewName OPTIONAL,
    IN wchar_t *SDText OPTIONAL
    )
/*
Routine Description:

    Rename or delete a object in the section.

Arguments:

    Context     - the context handle

    SectionName - the object's section name

    OldName     - existing name

    NewName     - new name to rename to, if NULL, the existing object is deleted

Return Value:

    DWORD
*/
{
    if ( !OldName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    DWORD rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;

    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {

#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
                //
                // update object, return code is DWORD
                //

                rc = ScepSetupMoveFile(
                            (PSCECONTEXT)Context,
                            (LPTSTR)OldName,
                            (LPTSTR)NewName,
                            (LPTSTR)SDText
                            );

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif

        } __except(EXCEPTION_EXECUTE_HANDLER) {

           rc = ERROR_EXCEPTION_IN_SERVICE;
        }

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    } else {

        rc = ScepSceStatusToDosError(rc);
    }

    RpcRevertToSelf();

    return(rc);
}


DWORD
SceRpcGenerateTemplate(
    IN handle_t binding_h,
    IN wchar_t *JetDbName OPTIONAL,
    IN wchar_t *LogFileName OPTIONAL,
    OUT SCEPR_CONTEXT __RPC_FAR *pContext
    )
/*
Routine Description:

    Request a context handle to generate a template from the
    database. If database name is not provided, the default database
    used.

Arguments:

    JetDbName    - optional database name, if NULL, the default is used.

    LogFileName  - the log file name

    pContext     - the output context handle

Return Value:

    DWORD
*/
{
    if ( !pContext ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    DWORD rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // there is no need to check delay loaded DLLs since now we have a exception hander
    // (defined in sources)
    // initialize jet engine in system context
    //

    rc = ScepSceStatusToDosError( SceJetInitialize(NULL) );

    if ( ERROR_SUCCESS != rc ) {
        return(rc);
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        *pContext = NULL;
        //
        // terminate jet engine if there is no other clients
        //
        ScepIfTerminateEngine();

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // get the default database name if needed
    // and call open database on it.
    //
    // OpenDatabase is not blocked by any task.
    //

    EnterCriticalSection(&ContextSync);

    PWSTR DefProfile=NULL;

    __try {
        //
        // figure out the default database name
        // catch exception if the input buffer are bogus
        //
        rc = ScepGetDefaultDatabase(
                 JetDbName,
                 0,
                 LogFileName,
                 NULL,
                 &DefProfile
                 );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = ERROR_EXCEPTION_IN_SERVICE;
    }

    if ( NO_ERROR == rc && DefProfile ) {

        //
        // initialize to open the database
        //

        ScepLogOutput3(0,0, SCEDLL_BEGIN_INIT);

        ScepLogOutput3(2,0, SCEDLL_FIND_DBLOCATION, DefProfile);

        //
        // open the database
        //

        rc = ScepOpenDatabase((PCWSTR)DefProfile,
                              0, // do not require analysis info,
                              SCEJET_OPEN_READ_ONLY,
                              (PSCECONTEXT *)pContext);

        rc = ScepSceStatusToDosError(rc);

        if ( ERROR_SUCCESS != rc ) {
            ScepLogOutput3(1, rc, SCEDLL_ERROR_OPEN, DefProfile);
        }
    }

    if (DefProfile != NULL && DefProfile != JetDbName ) {

        ScepFree( DefProfile );
    }

    ScepLogClose();

    if ( *pContext ) {
        //
        // if a context is to be returned, add it to the open context list
        //
        ScepAddToOpenContext((PSCECONTEXT)(*pContext));
        rc = ERROR_SUCCESS;

    } else {

        rc = ERROR_FILE_NOT_FOUND;
    }

    LeaveCriticalSection(&ContextSync);

    RpcRevertToSelf();

    if ( ERROR_SUCCESS != rc ) {
        //
        // terminate jet engine if no other clients
        //
        ScepIfTerminateEngine();
    }

    return(rc);
}



SCEPR_STATUS
SceRpcConfigureSystem(
    IN handle_t binding_h,
    IN wchar_t *InfFileName OPTIONAL,
    IN wchar_t *DatabaseName OPTIONAL,
    IN wchar_t *LogFileName OPTIONAL,
    IN DWORD ConfigOptions,
    IN AREAPR Area,
    IN DWORD pebSize,
    IN UCHAR *pebClient OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    )
/*
Routine Description:

    Configure the system using the Inf template and/or existing
    database info

Arguments:

    See ScepConfigureSystem

Return Value:

    SCEPR_STATUS
*/
{
    SCESTATUS rc;

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }


    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;

    }

    RpcRevertToSelf();


    if ( bStopRequest ) {

        if ( !ServerInited ) {
            //
            // server is in the middle of initialization
            // client calls to server too early, should wait for some time
            // (maximum 3 seconds)
            //
            INT cnt=0;
            while (cnt < 6) {
                Sleep(500);  // .5 second
                if ( ServerInited ) {
                    break;
                }
                cnt++;
            }

            if ( bStopRequest ) {
                //
                // if it's still in stop mode, return failure
                //
                return(SCESTATUS_SERVICE_NOT_SUPPORT);
            }
        } else {

            return(SCESTATUS_SERVICE_NOT_SUPPORT);
        }
    }

    //
    // initialize jet engine in system context
    //
    JET_ERR JetErr=0;
    BOOL bAdminLogon=FALSE;

    rc = SceJetInitialize(&JetErr);

    if ( rc != SCESTATUS_SUCCESS ) {

        if ( ((JetErr > JET_errUnicodeTranslationBufferTooSmall) &&
              (JetErr < JET_errInvalidLoggedOperation) &&
              (JetErr != JET_errLogDiskFull)) ||
             (JetErr == JET_errFileNotFound) ) {
            //
            // something is wrong with Jet log files or with other temparary databases
            // if I am in setup and using system database (admin logon) or
            // am in dcpromo, delete the Jet log files and try again
            //
            //
            // impersonate the client, return DWORD error code
            //

            if ( RPC_S_OK ==  RpcImpersonateClient( NULL ) ) {

                ScepIsAdminLoggedOn(&bAdminLogon, TRUE);

                RpcRevertToSelf();

                if ( bAdminLogon &&
                     (DatabaseName == NULL || SceIsSystemDatabase(DatabaseName) )) {
                    //
                    // system database and admin logon
                    // delete the Jet log files now.
                    //
                    SceJetDeleteJetFiles(NULL);

                    //
                    // try to initialize again (in system context)
                    //
                    rc = SceJetInitialize(&JetErr);
                }
            }

        }

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
    }

    //
    // impersonate the client, return DWORD error code
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        ScepIfTerminateEngine();

        return( ScepDosErrorToSceStatus(rc) );
    }


    //
    // get the database name
    //

    LPTSTR DefProfile=NULL;

    __try {
        //
        // catch exception if the input parameters are bogus
        //
        rc = ScepGetDefaultDatabase(
                 (LPCTSTR)DatabaseName,
                 ConfigOptions,
                 (LPCTSTR)LogFileName,
                 &bAdminLogon,
                 &DefProfile
                 );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = ERROR_EXCEPTION_IN_SERVICE;
    }

    if ( ERROR_SUCCESS == rc && DefProfile ) {

        //
        // validate access to the database
        //
        rc = ScepDatabaseAccessGranted( DefProfile,
                                        FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                                        TRUE
                                      );
    }

    rc = ScepDosErrorToSceStatus(rc);

    if ( SCESTATUS_SUCCESS == rc && DefProfile ) {

        //
        // validate the database to see if there is any configuration/
        // analysis running on other threads
        //

        rc = ScepLockEngine(DefProfile);

        if ( SCESTATUS_ALREADY_RUNNING == rc &&
             (ConfigOptions & SCE_DCPROMO_WAIT ) ) {
            //
            // will wait for max one minute
            //
            DWORD DcpromoWaitCount = 0;

            while ( TRUE ) {

                Sleep(5000);  // 5 seconds

                rc = ScepLockEngine(DefProfile);

                DcpromoWaitCount++;

                if ( SCESTATUS_SUCCESS == rc ||
                     DcpromoWaitCount >= 12 ) {
                    break;
                }
            }
        }

        if ( SCESTATUS_SUCCESS == rc ) {

            t_pebClient = (LPVOID)pebClient;
            t_pebSize = pebSize;

            //
            // it's ok to continue this operation
            // no other threads are running configuration/analysis
            // based on the same database
            //

            DWORD dOptions = ConfigOptions;
            if ( !DatabaseName ||
                 ( bAdminLogon && SceIsSystemDatabase(DatabaseName)) ) {

                dOptions |= SCE_SYSTEM_DB;
            }

            __try {
                //
                // catch exception if InfFileName, or pebClient/pdWarning are bogus
                //
                rc = ScepConfigureSystem(
                        (LPCTSTR)InfFileName,
                        DefProfile,
                        dOptions,
                        bAdminLogon,
                        (AREA_INFORMATION)Area,
                        pdWarning
                        );
            } __except(EXCEPTION_EXECUTE_HANDLER) {

               rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

            //
            // make sure private LSA handle is closed (to avoid deadlock)
            //
            if ( LsaPrivatePolicy ) {

                ScepNotifyLogPolicy(0, TRUE, L"Policy Prop: Private LSA handle is to be released", 0, 0, NULL );

                LsaClose(LsaPrivatePolicy);
                LsaPrivatePolicy = NULL;

            }

            //
            // unlock the engine for this database
            //

            ScepUnlockEngine(DefProfile);
        }
    }

    if ( DefProfile && DefProfile != DatabaseName ) {
        ScepFree(DefProfile);

    }

    ScepLogClose();

    //
    // change context back
    //

    RpcRevertToSelf();

    //
    // start a timer queue to check to see if there is active tasks/contexts
    // if not, terminate jet engine
    //
    ScepIfTerminateEngine();

    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceRpcGetDatabaseInfo(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_TYPE ProfileType,
    IN AREAPR Area,
    OUT PSCEPR_PROFILE_INFO __RPC_FAR *ppInfoBuffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Get information from the context database.

Arguments:

    Note: the InfoBuffer will always be the output buffer. Client site will
    pass in a address of NULL buffer to start with for any area information
    then merge this output buffer with the one clients called in.

    Have to marshlling security descriptor data to add a length in pServices

    See ScepGetDatabaseInfo

Return Value:

    SCEPR_STATUS
*/
{
    if ( !ppInfoBuffer ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {
            //
            // catch exception if Context, ppInfoBuffer, Errlog are bogus pointers
            //
#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
                //
                // query the information now
                //

                rc = ScepGetDatabaseInfo(
                            (PSCECONTEXT)Context,
                            (SCETYPE)ProfileType,
                            (AREA_INFORMATION)Area,
                            0,
                            (PSCE_PROFILE_INFO *)ppInfoBuffer,
                            (PSCE_ERROR_LOG_INFO *)Errlog
                            );

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // free ppInfoBuffer if it's allocated
            //
            SceFreeProfileMemory( (PSCE_PROFILE_INFO)(*ppInfoBuffer));
            *ppInfoBuffer = NULL;

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

        __try {

            if ( *ppInfoBuffer && (*ppInfoBuffer)->pServices ) {
                //
                // marshell the SCEPR_SERVICES structure for the security
                // descriptor
                //
                for ( PSCE_SERVICES ps=(PSCE_SERVICES)((*ppInfoBuffer)->pServices);
                      ps != NULL; ps = ps->Next ) {

                    if ( ps->General.pSecurityDescriptor ) {
                        //
                        // if there is a security descriptor, it must be self relative
                        // because the SD is returned from SDDL apis.
                        //
                        ULONG nLen = RtlLengthSecurityDescriptor (
                                            ps->General.pSecurityDescriptor);

                        if ( nLen > 0 ) {
                            //
                            // create a wrapper node to contain the security descriptor
                            //

                            PSCEPR_SR_SECURITY_DESCRIPTOR pNewWrap;
                            pNewWrap = (PSCEPR_SR_SECURITY_DESCRIPTOR)ScepAlloc(0, sizeof(SCEPR_SR_SECURITY_DESCRIPTOR));
                            if ( pNewWrap ) {

                                //
                                // assign the wrap to the structure
                                //
                                pNewWrap->SecurityDescriptor = (UCHAR *)(ps->General.pSecurityDescriptor);
                                pNewWrap->Length = nLen;

                                ps->General.pSecurityDescriptor = (PSECURITY_DESCRIPTOR)pNewWrap;

                            } else {
                                //
                                // no memory is available, but still continue to parse all nodes
                                //
                                nLen = 0;
                            }
                        }

                        if ( nLen == 0 ) {
                            //
                            // something wrong with this security descriptor
                            // free the buffer
                            //
                            ScepFree(ps->General.pSecurityDescriptor);
                            ps->General.pSecurityDescriptor = NULL;
                            ps->SeInfo = 0;
                        }

                    }
                }
            }

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }
    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceRpcGetObjectChildren(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_TYPE ProfileType,
    IN AREAPR Area,
    IN wchar_t *ObjectPrefix,
    OUT PSCEPR_OBJECT_CHILDREN __RPC_FAR *Buffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Get immediate children of the object from the context database

Arguments:

    See ScepGetObjectChildren

Return Value:

    SCEPR_STATUS
*/
{
    if ( !ObjectPrefix || !Buffer ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // prevent empty strings
    //
    if ( ObjectPrefix[0] == L'\0' ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {

#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
                //
                // query the information now
                //

                rc = ScepGetObjectChildren(
                            (PSCECONTEXT)Context,
                            (SCETYPE)ProfileType,
                            (AREA_INFORMATION)Area,
                            (PWSTR)ObjectPrefix,
                            SCE_IMMEDIATE_CHILDREN,
                            (PVOID *)Buffer,
                            (PSCE_ERROR_LOG_INFO *)Errlog
                            );

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // free Buffer if already allocated
            //
            SceFreeMemory( (PVOID)(*Buffer), SCE_STRUCT_OBJECT_CHILDREN);
            *Buffer = NULL;

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);

}



SCEPR_STATUS
SceRpcOpenDatabase(
    IN handle_t binding_h,
    IN wchar_t *DatabaseName,
    IN DWORD OpenOption,
    OUT SCEPR_CONTEXT __RPC_FAR *pContext
    )
/*
Routine Description:

    Request a context handle for the database. If bAnalysisRequired is set
    to TRUE, this routine also checks if there is analysis information
    in the database and return error is no analysis info is available.

Arguments:

    DatabaseName - database name

    OpenOption   - SCE_OPEN_OPTION_REQUIRE_ANALYSIS
                        require analysis information in the database
                  SCE_OPEN_OPTION_TATTOO
                        open the tattoo table instead (in system database)

    pContext     - the output context handle

Return Value:

    SCEPR_STATUS
*/
{
    if ( !pContext || !DatabaseName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    SCESTATUS rc;

    //
    // initialize jet engine in system context
    //
    rc = SceJetInitialize(NULL);

    if ( SCESTATUS_SUCCESS != rc ) {
        return(rc);
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        *pContext = NULL;
        rc = ScepDosErrorToSceStatus(rc);

    } else {


        BOOL    bAdminSidInToken = FALSE;

        rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

        if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
            RpcRevertToSelf();
            return SCESTATUS_SPECIAL_ACCOUNT;
        }


        //
        // OpenDatabase is not blocked by any task.
        //

        EnterCriticalSection(&ContextSync);

        __try {

            rc = ScepOpenDatabase(
                        (PCWSTR)DatabaseName,
                        OpenOption,
                        SCEJET_OPEN_READ_WRITE,
                        (PSCECONTEXT *)pContext
                        );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }

        if ( *pContext && SCESTATUS_SUCCESS == rc ) {
            //
            // if a context is to be returned, add it to the open context list
            //
            ScepAddToOpenContext((PSCECONTEXT)(*pContext));
        }

        LeaveCriticalSection(&ContextSync);

        RpcRevertToSelf();
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // make sure jet engine is terminated if no other acitve clients
        //
        ScepIfTerminateEngine();
    }

    return(rc);
}


SCEPR_STATUS
SceRpcCloseDatabase(
    IN OUT SCEPR_CONTEXT *pContext
    )
/*
Routine Description:

    Request to close the context. If other threads on working under the
    same context, the close request is send to the task list and when
    all pending tasks on the same context are done, the context is freed.

    This API does not wait for the closure of the database.

Arguments:

    Context     - the database context

Return Value:

    SCEPR_STATUS
*/
{
    SCESTATUS rc;

    //
    // impersonate the client
    //

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    //
    // remove this from the open context too
    //


    if ( pContext && *pContext ) {

        rc = ScepValidateAndCloseDatabase((PSCECONTEXT)(*pContext));

        *pContext = NULL;

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcGetDatabaseDescription(
    IN SCEPR_CONTEXT Context,
    OUT wchar_t __RPC_FAR **Description
    )
/*
Routine Description:

    Query database description from the context

Arguments:

    Context     - the database context

    Description - the output buffer of description

Return Value:

    SCEPR_STATUS
*/
{
    if ( !Context || !Description ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // the context needs to be locked in case another thread
    // is calling close database on it
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // do not need to lock the context because
            // it's reading information from one record table
            //

            rc = SceJetGetDescription(
                      (PSCECONTEXT)Context,
                      (PWSTR *)Description
                      );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceRpcGetDBTimeStamp(
    IN SCEPR_CONTEXT Context,
    OUT PLARGE_INTEGER ptsConfig,
    OUT PLARGE_INTEGER ptsAnalysis
    )
/*
Routine Description:

    Query the last configuration and analysis time stamp from the context.

Arguments:

    Context     - the database context

    ptsConfig   - the last configuration time stamp

    ptsAnalysis - the last analysis time stamp

Return Value:

    SCEPR_STATUS
*/
{
    if ( !Context || !ptsConfig || !ptsAnalysis ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // the context needs to be locked in case another thread
    // is calling close database on it
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // do not need to lock the context because
            // it's reading information from one record table
            //

            rc = SceJetGetTimeStamp(
                     (PSCECONTEXT)Context,
                     ptsConfig,
                     ptsAnalysis
                     );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);

}


SCEPR_STATUS
SceRpcGetObjectSecurity(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_TYPE DbProfileType,
    IN AREAPR Area,
    IN wchar_t *ObjectName,
    OUT PSCEPR_OBJECT_SECURITY __RPC_FAR *ObjSecurity
    )
/*
Routine Description:

    Query security settings for an object from the context database.

Arguments:

    Context     - the database context

    DbProfileType   - the database table type

    Area        - the security area (file, registry, so on.)

    ObjectName  - the object's full name

    ObjSecurity - object security settings structure

Return Value:

    SCEPR_STATUS
*/
{
    if ( !Context || !ObjSecurity || !ObjectName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    SCESTATUS rc;


    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // query the information now
            //

            rc = ScepGetObjectSecurity(
                        (PSCECONTEXT)Context,
                        (SCETYPE)DbProfileType,
                        (AREA_INFORMATION)Area,
                        (PWSTR)ObjectName,
                        (PSCE_OBJECT_SECURITY *)ObjSecurity
                        );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

        //
        // convert the security descriptor
        //
        if ( ( SCESTATUS_SUCCESS == rc ) &&
             *ObjSecurity &&
             (*ObjSecurity)->pSecurityDescriptor ) {

            //
            // there is a security descriptor, it must be self relative
            // because it's returned from the SDDL api.
            //
            ULONG nLen = RtlLengthSecurityDescriptor (
                                (PSECURITY_DESCRIPTOR)((*ObjSecurity)->pSecurityDescriptor));

            if ( nLen > 0 ) {
                //
                // create a wrapper node to contain the security descriptor
                //

                PSCEPR_SR_SECURITY_DESCRIPTOR pNewWrap;
                pNewWrap = (PSCEPR_SR_SECURITY_DESCRIPTOR)ScepAlloc(0, sizeof(SCEPR_SR_SECURITY_DESCRIPTOR));
                if ( pNewWrap ) {

                    //
                    // assign the wrap to the structure
                    //
                    pNewWrap->SecurityDescriptor = (UCHAR *)((*ObjSecurity)->pSecurityDescriptor);
                    pNewWrap->Length = nLen;

                    (*ObjSecurity)->pSecurityDescriptor = (SCEPR_SR_SECURITY_DESCRIPTOR *)pNewWrap;

                } else {
                    //
                    // no memory is available, but still continue to parse all nodes
                    //
                    nLen = 0;
                }
            }

            if ( nLen == 0 ) {
                //
                // something wrong with this security descriptor
                // free the buffer
                //
                ScepFree((*ObjSecurity)->pSecurityDescriptor);
                (*ObjSecurity)->pSecurityDescriptor = NULL;
                (*ObjSecurity)->SeInfo = 0;
            }

        }

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcGetAnalysisSummary(
    IN SCEPR_CONTEXT Context,
    IN AREAPR Area,
    OUT PDWORD pCount
    )
/*
Routine Description:

    Query security settings for an object from the context database.

Arguments:

    Context     - the database context

    Area        - the security area (file, registry, so on.)

    pCount      - the output count

Return Value:

    SCEPR_STATUS
*/
{
    if ( !Context || !pCount ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // query the information now
            //

            rc = ScepGetAnalysisSummary(
                        (PSCECONTEXT)Context,
                        (AREA_INFORMATION)Area,
                        pCount
                        );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcAnalyzeSystem(
    IN handle_t binding_h,
    IN wchar_t *InfFileName OPTIONAL,
    IN wchar_t *DatabaseName OPTIONAL,
    IN wchar_t *LogFileName OPTIONAL,
    IN AREAPR Area,
    IN DWORD AnalyzeOptions,
    IN DWORD pebSize,
    IN UCHAR *pebClient OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    )
/*
Routine Description:

    Analyze the system using the Inf template and/or existing
    database info

Arguments:

    See ScepAnalyzeSystem

Return Value:

    SCEPR_STATUS
*/
{
    SCESTATUS rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // initialize jet engine in system context
    //
    rc = SceJetInitialize(NULL);

    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }

    //
    // impersonate the client, return DWORD error code
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        ScepIfTerminateEngine();

        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // get the database name
    //

    BOOL bAdminLogon=FALSE;
    LPTSTR DefProfile=NULL;

    __try {

        rc = ScepGetDefaultDatabase(
                 (AnalyzeOptions & SCE_GENERATE_ROLLBACK) ? NULL : (LPCTSTR)DatabaseName,
                 AnalyzeOptions,
                 (LPCTSTR)LogFileName,
                 &bAdminLogon,
                 &DefProfile
                 );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        rc = ERROR_EXCEPTION_IN_SERVICE;
    }

    if ( (AnalyzeOptions & SCE_GENERATE_ROLLBACK)
         && !bAdminLogon  ) {
        //
        // only allow admin to use system database to generate rollback
        // is this the correct design?
        //
        rc = ERROR_ACCESS_DENIED;
    }

    if ( ERROR_SUCCESS == rc && DefProfile ) {

        //
        // validate access to the database
        //
        rc = ScepDatabaseAccessGranted( DefProfile,
                                        FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                                        TRUE
                                      );
    }

    rc = ScepDosErrorToSceStatus(rc);

    if ( SCESTATUS_SUCCESS == rc && DefProfile ) {

        //
        // validate the database to see if there is any configuration/
        // analysis running on other threads
        //

        rc = ScepLockEngine(DefProfile);

        if ( SCESTATUS_SUCCESS == rc ) {

            t_pebClient = (LPVOID)pebClient;
            t_pebSize = pebSize;

            //
            // it's ok to continue this operation
            // no other threads are running configuration/analysis
            // based on the same database
            //

            DWORD dOptions = AnalyzeOptions;
            if ( !(AnalyzeOptions & SCE_GENERATE_ROLLBACK) ) {
                if ( !DatabaseName ||
                    ( bAdminLogon && SceIsSystemDatabase(DatabaseName)) ) {

                    dOptions |= SCE_SYSTEM_DB;
                }
            }

            __try {

                rc = ScepAnalyzeSystem(
                        (LPCTSTR)InfFileName,
                        DefProfile,
                        dOptions,
                        bAdminLogon,
                        (AREA_INFORMATION)Area,
                        pdWarning,
                        (AnalyzeOptions & SCE_GENERATE_ROLLBACK) ? DatabaseName : NULL
                        );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

            //
            // unlock the engine for this database
            //

            ScepUnlockEngine(DefProfile);
        }
    }

    if ( DefProfile && DefProfile != DatabaseName ) {
        ScepFree(DefProfile);

    }

    ScepLogClose();

    //
    // change context back
    //

    RpcRevertToSelf();

    //
    // start a timer queue to check to see if there is active tasks/contexts
    // if not, terminate jet engine
    //
    ScepIfTerminateEngine();

    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceRpcUpdateDatabaseInfo(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_TYPE ProfileType,
    IN AREAPR Area,
    IN PSCEPR_PROFILE_INFO pInfo,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update database in the context using pInfo

Arguments:

    Context     - the database context

    ProfileType - the database table type

    Area        - the security area (security policy... except objects's area)

    pInfo       - the info to update

Return Value:

    SCEPR_STATUS
*/
{
    if ( !Context || !pInfo ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }


    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        PSCEPR_SERVICES pOldServices = pInfo->pServices;

        //
        // Convert SCEPR_PROFILE_INFO into SCE_PROFILE_INFO
        //
        if ( (Area & AREA_SYSTEM_SERVICE) &&
             pOldServices ) {

            rc = ScepConvertServices( (PVOID *)&(pInfo->pServices), TRUE );

        } else {
            pInfo->pServices = NULL;
        }


        if ( SCESTATUS_SUCCESS == rc ) {

            //
            // lock the context
            //

            if ( pTask ) {
                EnterCriticalSection(&(pTask->Sync));
            }

            __try {

    #ifdef SCE_JET_TRAN
                rc = SceJetJetErrorToSceStatus(
                        JetSetSessionContext(
                            ((PSCECONTEXT)Context)->JetSessionID,
                            (ULONG_PTR)Context
                            ));

                if ( SCESTATUS_SUCCESS == rc ) {
    #endif
                    //
                    // update the information now
                    //

                    if ( dwMode & SCE_UPDATE_LOCAL_POLICY ) {

                        //
                        // update local policy only
                        //
                        rc = ScepUpdateLocalTable(
                                    (PSCECONTEXT)Context,
                                    (AREA_INFORMATION)Area,
                                    (PSCE_PROFILE_INFO)pInfo,
                                    dwMode
                                    );
                    } else {
                        //
                        // update the database (SMP and SAP)
                        //
                        rc = ScepUpdateDatabaseInfo(
                                    (PSCECONTEXT)Context,
                                    (AREA_INFORMATION)Area,
                                    (PSCE_PROFILE_INFO)pInfo
                                    );
                    }

    #ifdef SCE_JET_TRAN
                    JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

                }
    #endif

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

            //
            // unlock the context
            //

            if ( pTask ) {
                LeaveCriticalSection(&(pTask->Sync));
            }

            ScepFreeConvertedServices( pInfo->pServices, FALSE );

        }

        pInfo->pServices = pOldServices;

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcUpdateObjectInfo(
    IN SCEPR_CONTEXT Context,
    IN AREAPR Area,
    IN wchar_t *ObjectName,
    IN DWORD NameLen,
    IN BYTE ConfigStatus,
    IN BOOL IsContainer,
    IN SCEPR_SR_SECURITY_DESCRIPTOR *pSD OPTIONAL,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    )
/*
Routine Description:

    Update object's security settings in the database.

Arguments:

    See ScepUpdateObjectInfo

Return Value:

    SCEPR_STATUS
*/
{
    if ( !Context || !ObjectName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }
#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // update the object info now
            //

            __try {

                rc = ScepUpdateObjectInfo(
                            (PSCECONTEXT)Context,
                            (AREA_INFORMATION)Area,
                            (PWSTR)ObjectName,
                            NameLen,
                            ConfigStatus,
                            IsContainer,
                            pSD ? (PSECURITY_DESCRIPTOR)(pSD->SecurityDescriptor) : NULL,
                            SeInfo,
                            pAnalysisStatus
                            );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcStartTransaction(
    IN SCEPR_CONTEXT Context
    )
/*
Routine Description:

    Start a transaction on the context. If other threads sharing the same
    context, their changes will also be controlled by this transaction.

    It's the caller's responsible to not share the same context for
    transactioning.

Arguments:

    See SceJetStartTransaction

Return Value:

    SCEPR_STATUS
*/
{
    if ( !Context ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        //
        // start transaction on this context
        //
#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            rc = SceJetStartTransaction(
                        (PSCECONTEXT)Context
                        );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcCommitTransaction(
    IN SCEPR_CONTEXT Context
    )
/*
Routine Description:

    Commit a transaction on the context. If other threads sharing the same
    context, their changes will also be controlled by this transaction.

    It's the caller's responsible to not share the same context for
    transactioning.

Arguments:

    See SceJetCommitTransaction

Return Value:

    SCEPR_STATUS
*/
{
    if ( !Context ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        //
        // set the context to the jet session so thread id is not used for this
        // operation.
        //
#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // commit transaction on this context
            //

            rc = SceJetCommitTransaction(
                        (PSCECONTEXT)Context,
                        0
                        );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcRollbackTransaction(
    IN SCEPR_CONTEXT Context
    )
/*
Routine Description:

    Rollback a transaction on the context. If other threads sharing the same
    context, their changes will also be controlled by this transaction.

    It's the caller's responsible to not share the same context for
    transactioning.

Arguments:

    See SceJetRollback

Return Value:

    SCEPR_STATUS
*/
{
    if ( !Context ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        //
        // set the context to the jet session so thread id is not used for this
        // operation.
        //

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // rollback transaction on this context
            //

            rc = SceJetRollback(
                        (PSCECONTEXT)Context,
                        0
                        );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);
        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceRpcGetServerProductType(
    IN handle_t binding_h,
    OUT PSCEPR_SERVER_TYPE srvProduct
    )
/*
Routine Description:

    Get SCE server's product type

Arguments:

Return Value:

*/
{
    if ( !srvProduct ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // impersonate the client
    //

    BOOL    bAdminSidInToken = FALSE;
    DWORD rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;

    }

    ScepGetProductType((PSCE_SERVER_TYPE)srvProduct);

    RpcRevertToSelf();

    return(SCESTATUS_SUCCESS);
}



SCEPR_STATUS
SceSvcRpcUpdateInfo(
    IN SCEPR_CONTEXT Context,
    IN wchar_t *ServiceName,
    IN PSCEPR_SVCINFO Info
    )
/*
Routine Description:

    Update information for the service to the database.

Arguments:

    Context     - the context handle

    ServiceName - the service name for which info is requested

    Info     - output buffer

Return Value:

    SCEPR_STATUS
*/
{
    if ( !Context || !ServiceName || !Info ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // update the service info now
            //

            __try {

                rc = SceSvcpUpdateInfo(
                        (PSCECONTEXT)Context,
                        (LPCTSTR)ServiceName,
                        (PSCESVC_CONFIGURATION_INFO)Info
                        );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcCopyObjects(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_TYPE ProfileType,
    IN wchar_t *InfFileName,
    IN AREAPR Area,
    OUT PSCEPR_ERROR_LOG_INFO *pErrlog OPTIONAL
    )
/*
Routine Description:

    Update information for the service to the database.

Arguments:

    Context     - the context handle

    InfFileName - the inf template name to copy to

    Area        - which area(s) to copy

    pErrlog     - the error log buffer

Return Value:

    SCEPR_STATUS
*/
{
    if ( !Context || !InfFileName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    if ( !Area ) {
        //
        // nothing to copy
        //
        return(SCESTATUS_SUCCESS);
    }

    if ( ProfileType != SCE_ENGINE_SCP &&
         ProfileType != SCE_ENGINE_SMP ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // impersonate the client
    //

    SCESTATUS rc;

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif

            //
            // query the information now
            //

            if ( Area & AREA_REGISTRY_SECURITY ) {

                rc = ScepCopyObjects(
                        (PSCECONTEXT)Context,
                        (SCETYPE)ProfileType,
                        (LPTSTR)InfFileName,
                        szRegistryKeys,
                        AREA_REGISTRY_SECURITY,
                        (PSCE_ERROR_LOG_INFO *)pErrlog
                        );
            }

            if ( SCESTATUS_SUCCESS == rc &&
                 Area & AREA_FILE_SECURITY ) {

                rc = ScepCopyObjects(
                        (PSCECONTEXT)Context,
                        (SCETYPE)ProfileType,
                        (LPTSTR)InfFileName,
                        szFileSecurity,
                        AREA_FILE_SECURITY,
                        (PSCE_ERROR_LOG_INFO *)pErrlog
                        );
            }
#if 0
            if ( SCESTATUS_SUCCESS == rc &&
                 Area & AREA_DS_OBJECTS ) {

                rc = ScepCopyObjects(
                        (PSCECONTEXT)Context,
                        (SCETYPE)ProfileType,
                        (LPTSTR)InfFileName,
                        szDSSecurity,
                        AREA_DS_OBJECTS,
                        (PSCE_ERROR_LOG_INFO *)pErrlog
                        );
            }
#endif
            if ( SCESTATUS_SUCCESS == rc &&
                 Area & AREA_SYSTEM_SERVICE ) {

                rc = ScepCopyObjects(
                        (PSCECONTEXT)Context,
                        (SCETYPE)ProfileType,
                        (LPTSTR)InfFileName,
                        szServiceGeneral,
                        AREA_SYSTEM_SERVICE,
                        (PSCE_ERROR_LOG_INFO *)pErrlog
                        );
            }

            SCESVC_INFO_TYPE iType;
            switch ( ProfileType ) {
            case SCE_ENGINE_SCP:
                iType = SceSvcMergedPolicyInfo;
                break;
            case SCE_ENGINE_SMP:
                iType = SceSvcConfigurationInfo;
                break;
            }

            if ( SCESTATUS_SUCCESS == rc &&
                 ( Area & AREA_SYSTEM_SERVICE) ) {

                rc = ScepGenerateAttachmentSections(
                        (PSCECONTEXT)Context,
                        iType,
                        (LPTSTR)InfFileName,
                        SCE_ATTACHMENT_SERVICE
                        );
            }
            if ( SCESTATUS_SUCCESS == rc &&
                 (Area & AREA_SECURITY_POLICY) ) {

                rc = ScepGenerateAttachmentSections(
                        (PSCECONTEXT)Context,
                        iType,
                        (LPTSTR)InfFileName,
                        SCE_ATTACHMENT_POLICY
                        );
            }
            if ( SCESTATUS_SUCCESS == rc &&
                 ( Area & AREA_ATTACHMENTS) ) {

                rc = ScepGenerateWMIAttachmentSections(
                        (PSCECONTEXT)Context,
                        iType,
                        (LPTSTR)InfFileName
                        );
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}

SCEPR_STATUS
SceRpcSetupResetLocalPolicy(
    IN SCEPR_CONTEXT  Context,
    IN AREAPR         Area,
    IN wchar_t        *OneSectionName OPTIONAL,
    IN DWORD          PolicyOptions
    )
{
    SCESTATUS rc;

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // remove policies from the local table
            //
            if ( PolicyOptions & SCE_RESET_POLICY_SYSPREP ) {

                ScepSetupResetLocalPolicy((PSCECONTEXT)Context,
                                               (AREA_INFORMATION)Area,
                                               NULL,
                                               SCE_ENGINE_SMP,
                                               FALSE
                                              );
                ScepSetupResetLocalPolicy((PSCECONTEXT)Context,
                                               (AREA_INFORMATION)Area,
                                               NULL,
                                               SCE_ENGINE_SCP,
                                               FALSE
                                              );

                rc = ScepSetupResetLocalPolicy((PSCECONTEXT)Context,
                                               (AREA_INFORMATION)Area,
                                               NULL,
                                               SCE_ENGINE_SAP,  // for the tattoo table
                                               FALSE
                                              );
            } else {

                if ( PolicyOptions & SCE_RESET_POLICY_TATTOO ) {
                    // after dcpromo, we need to reset the tattoo values
                    rc = ScepSetupResetLocalPolicy((PSCECONTEXT)Context,
                                                   (AREA_INFORMATION)Area,
                                                   (PCWSTR)OneSectionName,
                                                   SCE_ENGINE_SAP, // for the tattoo table
                                                   FALSE
                                                  );
                }

                rc = ScepSetupResetLocalPolicy((PSCECONTEXT)Context,
                                               (AREA_INFORMATION)Area,
                                               (PCWSTR)OneSectionName,
                                               SCE_ENGINE_SMP,
                                               (PolicyOptions & SCE_RESET_POLICY_KEEP_LOCAL)
                                              );

                if ( (PolicyOptions & SCE_RESET_POLICY_ENFORCE_ATREBOOT ) &&
                    ( (((PSCECONTEXT)Context)->Type & 0xF0L) == SCEJET_MERGE_TABLE_1 ||
                      (((PSCECONTEXT)Context)->Type & 0xF0L) == SCEJET_MERGE_TABLE_2 ) &&
                    ((PSCECONTEXT)Context)->JetScpID != ((PSCECONTEXT)Context)->JetSmpID ) {
                    //
                    // there is effective policy table already in the database
                    // (and this is in setup upgrade)
                    // update local group policy table to trigger a policy prop at reboot
                    //

                    ScepEnforcePolicyPropagation();
                }
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);

}



SCESTATUS
ScepGenerateAttachmentSections(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName,
    IN SCE_ATTACHMENT_TYPE aType
    )
{
    SCESTATUS rc;
    PSCE_SERVICES    pServiceList=NULL, pNode;

    rc = ScepEnumServiceEngines( &pServiceList, aType );

    if ( rc == SCESTATUS_SUCCESS ) {

       for ( pNode=pServiceList; pNode != NULL; pNode=pNode->Next) {
           //
           // generate section for one attachment
           //
           rc = ScepGenerateOneAttachmentSection(hProfile,
                                                 InfoType,
                                                 InfFileName,
                                                 pNode->ServiceName,
                                                 FALSE
                                                );

           if ( rc != SCESTATUS_SUCCESS ) {
               ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                             SCEDLL_ERROR_CONVERT_SECTION, pNode->ServiceName );
               break;
           }
       }

       SceFreePSCE_SERVICES(pServiceList);

    }

    if ( rc == SCESTATUS_PROFILE_NOT_FOUND ||
                rc == SCESTATUS_RECORD_NOT_FOUND ) {
        // if no service exist, just ignore
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);

}

SCESTATUS
ScepGenerateWMIAttachmentSections(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName
    )
{
    SCESTATUS rc;
    PSCE_NAME_LIST    pList=NULL, pNode;

    rc = ScepEnumAttachmentSections( hProfile, &pList);

    if ( rc == SCESTATUS_SUCCESS ) {

       for ( pNode=pList; pNode != NULL; pNode=pNode->Next) {

           //
           // generate section for one attachment
           //
           rc = ScepGenerateOneAttachmentSection(hProfile,
                                                 InfoType,
                                                 InfFileName,
                                                 pNode->Name,
                                                 TRUE
                                                );

           if ( rc != SCESTATUS_SUCCESS ) {
               ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                             SCEDLL_ERROR_CONVERT_SECTION, pNode->Name );
               break;
           }
       }

       ScepFreeNameList(pList);

    }

    if ( rc == SCESTATUS_PROFILE_NOT_FOUND ||
                rc == SCESTATUS_RECORD_NOT_FOUND ) {
        // if no service exist, just ignore
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);

}

SCESTATUS
ScepGenerateOneAttachmentSection(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName,
    IN LPTSTR SectionName,
    IN BOOL bWMISection
    )
{
    //
    // read inf info for the section
    //
    SCESTATUS rc;
    SCE_ENUMERATION_CONTEXT sceEnumHandle=0;
    DWORD CountReturned;
    PSCESVC_CONFIGURATION_INFO pAttachInfo=NULL;

    do {

       CountReturned = 0;

       rc = SceSvcpQueryInfo(
                hProfile,
                InfoType,
                SectionName,
                NULL,
                FALSE,
                (PVOID *)&pAttachInfo,
                &sceEnumHandle
                );

       if ( rc == SCESTATUS_SUCCESS && pAttachInfo != NULL &&
            pAttachInfo->Count > 0 ) {
           //
           // got something
           //
           CountReturned = pAttachInfo->Count;

           //
           // copy each line
           //
           for ( DWORD i=0; i<pAttachInfo->Count; i++ ) {

               if ( pAttachInfo->Lines[i].Key == NULL ||
                    pAttachInfo->Lines[i].Value == NULL ) {
                   continue;
               }

               if ( !WritePrivateProfileString(
                               SectionName,
                               pAttachInfo->Lines[i].Key,
                               pAttachInfo->Lines[i].Value,
                               InfFileName
                               ) ) {

                   rc = ScepDosErrorToSceStatus(GetLastError());
                   break;
               }
           }

           if ( bWMISection ) {

               //
               // make sure to create the szAttachments section
               //
               if ( !WritePrivateProfileString(
                               szAttachments,
                               SectionName,
                               L"Include",
                               InfFileName
                               ) ) {

                   rc = ScepDosErrorToSceStatus(GetLastError());
               }
           }
       }

       SceSvcpFreeMemory((PVOID)pAttachInfo);
       pAttachInfo = NULL;

    } while ( rc == SCESTATUS_SUCCESS && CountReturned > 0 );

    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
       rc = SCESTATUS_SUCCESS;
    }

    return rc;

}

void __RPC_USER
SCEPR_CONTEXT_rundown( SCEPR_CONTEXT Context)
{

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return;
    }

    //
    // this client is shutting down
    //

    rc = ScepValidateAndCloseDatabase((PSCECONTEXT)Context);

    RpcRevertToSelf();

    return;
}



SCESTATUS
ScepOpenDatabase(
    IN PCWSTR DatabaseName,
    IN DWORD  OpenOption,
    IN SCEJET_OPEN_TYPE OpenType,
    OUT PSCECONTEXT *pContext
    )
/*
Routine Description:

    This routine opens the database and returns a context handle.
    OpenDatabase can be called by multiple clients for the same database
    and we do not block multiple access because each client will get
    a duplicate database cursor and have their own working tables.

    When a database is changed by other clients, all cursors will be
    synchronized. Clients who had retrived "old" data are responsible
    to refresh their data buffer. No notification is provided at this
    point.

Arguments:

Return Value:


*/
{
    if ( !DatabaseName || !pContext ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS    rc;
    //
    // check access of the database (with current client token)
    //
    DWORD Access=0;

    if ( SCEJET_OPEN_READ_ONLY == OpenType ) {

//      BUG in ESENT
//      Even ask for read only, ESENT still writes to the database
//        Access = FILE_GENERIC_READ;
        Access = FILE_GENERIC_READ | FILE_GENERIC_WRITE;
    } else {
        Access = FILE_GENERIC_READ | FILE_GENERIC_WRITE;
    }

    rc = ScepDatabaseAccessGranted((LPTSTR)DatabaseName,
                                   Access,
                                   FALSE
                                  );

    if ( rc != ERROR_SUCCESS ) {

        ScepLogOutput2(1,rc,L"%s", DatabaseName);

        return( ScepDosErrorToSceStatus(rc) );
    }

    DWORD       Len;
    DWORD       MBLen=0;
    PCHAR       FileName=NULL;
    NTSTATUS    NtStatus;

    //
    // convert WCHAR into ANSI
    //

    Len = wcslen( DatabaseName );

    NtStatus = RtlUnicodeToMultiByteSize(&MBLen, (PWSTR)DatabaseName, Len*sizeof(WCHAR));

    if ( !NT_SUCCESS(NtStatus) ) {
        //
        // cannot get the length, set default to 512
        //
        MBLen = 512;
    }

    FileName = (PCHAR)ScepAlloc( LPTR, MBLen+2);

    if ( FileName == NULL ) {
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    } else {

        NtStatus = RtlUnicodeToMultiByteN(
                        FileName,
                        MBLen+1,
                        NULL,
                        (PWSTR)DatabaseName,
                        Len*sizeof(WCHAR)
                        );

        if ( !NT_SUCCESS(NtStatus) ) {
            rc = SCESTATUS_PROFILE_NOT_FOUND;

        } else {

            //
            // make sure the context buffer is initialized
            //

            *pContext = NULL;

            rc = SceJetOpenFile(
                        (LPSTR)FileName,
                        OpenType, //SCEJET_OPEN_READ_WRITE,
                        (OpenOption == SCE_OPEN_OPTION_TATTOO ) ? SCE_TABLE_OPTION_TATTOO : 0,
                        pContext
                        );

            if ( (OpenOption == SCE_OPEN_OPTION_REQUIRE_ANALYSIS ) &&
                 SCESTATUS_SUCCESS == rc &&
                 *pContext ) {

                if ( (*pContext)->JetSapID == JET_tableidNil ) {

                    //
                    // no analysis information is available
                    //

                    rc = SCESTATUS_PROFILE_NOT_FOUND;

                    //
                    // free handle
                    //

                    SceJetCloseFile(
                            *pContext,
                            TRUE,
                            FALSE
                            );
                    *pContext = NULL;
                }

            }
        }
        ScepFree( FileName );

    }

    return(rc);
}


SCESTATUS
ScepCloseDatabase(
    IN PSCECONTEXT Context
    )
{
    SCESTATUS rc;

    if ( !Context ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    __try {

        if ( ScepIsValidContext(Context) ) {

            //
            // be able to access the first byte
            //

            rc = SceJetCloseFile(
                    Context,
                    TRUE,
                    FALSE
                    );
        } else {
            //
            // this context is not our context or already be freed
            //
            rc = SCESTATUS_INVALID_PARAMETER;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        rc = SCESTATUS_INVALID_PARAMETER;
    }

    return(rc);

}

DWORD
SceRpcControlNotificationQProcess(
    IN handle_t binding_h,
    IN DWORD Flag
    )
/*
Description:

    This function should be called by a system thread to control that policy
    notification queue process should be suspended or resumed.

    The purpose of this function is to protect policy changes being overwritten
    by policy proapgation when the GPO file is copied/imported into the database

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    DWORD rc=ERROR_SUCCESS;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        ScepNotifyLogPolicy(rc, FALSE, L"Impersonation Failed", 0, 0, NULL );
        return( rc );
    }

    //
    // perform access check to make sure that only
    // system thread can make the call
    //
    HANDLE hToken = NULL;

    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY,
                          TRUE,
                          &hToken)) {

        rc = GetLastError();

        ScepNotifyLogPolicy(rc, FALSE, L"Fail to query token", 0, 0, NULL );

        RpcRevertToSelf();

        return( rc );
    }

    BOOL b=FALSE;

    rc = RtlNtStatusToDosError( ScepIsSystemContext(hToken, &b) );

    if ( rc != ERROR_SUCCESS || !b ) {

        CloseHandle(hToken);

        ScepNotifyLogPolicy(rc, FALSE, L"Not system context", 0, 0, NULL );

        RpcRevertToSelf();

        return( rc ? rc : ERROR_ACCESS_DENIED );
    }

    CloseHandle(hToken);

    //
    // even though there might be a shutdown request
    // we need to let the control go through
    //

    if ( Flag ) {

        ScepNotifyLogPolicy(0, TRUE, L"RPC enter Suspend queue.", 0, 0, NULL );
        //
        // this thread is called from policy propagation which is guaranteed to
        // run by one thread (system context). No need to protect the global buffer
        //
        gPolicyWaitCount++;

        if ( pNotificationQHead ) {

            if ( gPolicyWaitCount < SCE_POLICY_MAX_WAIT ) {
                //
                // queue is not empty, should not propagate policy
                //
                ScepNotifyLogPolicy(0, FALSE, L"Queue is not empty, abort.", 0, 0, NULL );

                RpcRevertToSelf();

                return (ERROR_OVERRIDE_NOCHANGES);

            } else {

                ScepNotifyLogPolicy(0, FALSE, L"Resetting policy wait count.", 0, 0, NULL );
                gPolicyWaitCount = 0;

            }
        } else {
            gPolicyWaitCount = 0;
        }

    } else {

        ScepNotifyLogPolicy(0, TRUE, L"RPC enter Resume queue.", 0, 0, NULL );
    }

    //
    // now set the control flag
    //

    ScepNotificationQControl(Flag);

    RpcRevertToSelf();

    return(rc);
}

DWORD
SceRpcNotifySaveChangesInGP(
    IN handle_t binding_h,
    IN DWORD DbType,
    IN DWORD DeltaType,
    IN DWORD ObjectType,
    IN PSCEPR_SID ObjectSid OPTIONAL,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight
    )
/*
Description:

    This function should be called by a system thread to notify that policy
    in LSA/SAM databases are changed programmatically by other applications.
    The purpose of this function is to synchronize policy store with LSA/SAM
    databases so that application changes won't be overwritten by next
    policy propagation.

    This function will add the notification to a queue for server to process.
    Only system context can add a node to the queue.

*/
{

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    //
    // even though there might be a shutdown request
    // we need to let notification saved before allowing shutdown
    //

    DWORD rc=ERROR_SUCCESS;

    ScepNotifyLogPolicy(0, TRUE, L"Notified DC", DbType, ObjectType, NULL );

    if ( ObjectSid ) {

        __try {

            if ( !RtlValidSid(ObjectSid) ) {
                rc = GetLastError();
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            // objectsid buffer is invalid
            rc = ERROR_EXCEPTION_IN_SERVICE;
        }

        if ( rc != ERROR_SUCCESS ) {
            ScepNotifyLogPolicy(0, FALSE, L"Invalid Sid", DbType, ObjectType, NULL );
            return(rc);
        }
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        ScepNotifyLogPolicy(rc, FALSE, L"Impersonation Failed", DbType, ObjectType, NULL );
        return( rc );
    }

    //
    // perform access check to make sure that only
    // system thread can make the call
    //
    HANDLE hToken = NULL;

    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY,
                          TRUE,
                          &hToken)) {

        rc = GetLastError();

        ScepNotifyLogPolicy(rc, FALSE, L"Fail to query token", DbType, ObjectType, NULL );

        RpcRevertToSelf();

        return( rc );
    }

    BOOL b=FALSE;

    rc = RtlNtStatusToDosError( ScepIsSystemContext(hToken, &b) );

    if ( rc != ERROR_SUCCESS || !b ) {

        CloseHandle(hToken);

        ScepNotifyLogPolicy(rc, FALSE, L"Not system context", DbType, ObjectType, NULL );

        RpcRevertToSelf();

        return( rc ? rc : ERROR_ACCESS_DENIED );
    }

    CloseHandle(hToken);

    //
    // Add the request to the "queue" for further process
    //
    rc = ScepNotificationQEnqueue((SECURITY_DB_TYPE)DbType,
                                  (SECURITY_DB_DELTA_TYPE)DeltaType,
                                  (SECURITY_DB_OBJECT_TYPE)ObjectType,
                                  (PSID)ObjectSid,
                                  ExplicitLowRight,
                                  ExplicitHighRight,
                                  NULL
                                  );

    RpcRevertToSelf();

    return(rc);
}

DWORD
ScepNotifyProcessOneNodeDC(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID ObjectSid,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    OUT BOOL *pbTimeout
    )
/*
Description:

    This function is called by the queue management thread to process one
    notification node in the queue. This function will determine which group
    policy template to save to and what are the differences between current
    state of LSA/SAM and group policy.

    Group policy is only modified when there is a difference detected. Group
    policy version # is updated on save. This function is always called in a
    single system thread.

    if scecli.dll fails to be loaded, ERROR_MOD_NOT_FOUND will be returned.

    if sysvol share is not ready, the error returned will be ERROR_FILE_NOT_FOUND.
    However if the template file doesn't exist (deleted), ERROR_FILE_NOT_FOUND will
    also be returned. This case is handled the same way as the share/path doesn't
    exist (error logged and retried) because the GPOs are required to be there for
    replication purpose. But in the future, when the dependency is removed from
    domain controllers GPO, we might need to separate the two cases (one success,
    one failure).

    If disk is full, the error returned will be ERROR_EXTENDED_ERROR.

*/
{

    //
    // query if I am in setup
    //
    DWORD dwInSetup = 0;
    DWORD rc=0;

    *pbTimeout = FALSE;

    ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                TEXT("System\\Setup"),
                TEXT("SystemSetupInProgress"),
                &dwInSetup
                );

    PWSTR TemplateName=NULL;
    BOOL bAccountGPO=FALSE;

    if ( DbType == SecurityDbSam &&
         !SCEP_IS_SAM_OBJECT(ObjectType) ) {
        //
        // if it's for deleted account, should update user right GPO
        // otherwise, update the account GPO
        //
        bAccountGPO = TRUE;
    }

    if ( dwInSetup && !IsNT5()) {

        //
        // if it's in setup, group policy templates are not available (DS is down)
        // save the notifications to a temperaory store and process the
        // store at next system start up.
        //
        ScepNotifyLogPolicy(0, FALSE, L"In setup", DbType, ObjectType, NULL );

        UNICODE_STRING tmp;
        tmp.Length = 0;
        tmp.Buffer = NULL;

        //
        // get the default template name
        //
        rc = ScepNotifyGetDefaultGPOTemplateName(
                                tmp,
                                NULL,
                                bAccountGPO,
                                SCEGPO_INSETUP_NT4,
                                &TemplateName
                                );

        if ( ERROR_SUCCESS == rc && TemplateName ) {

            //
            // save the transaction in this temp file
            //
            rc = ScepNotifySaveNotifications(TemplateName,
                                            (SECURITY_DB_TYPE)DbType,
                                            (SECURITY_DB_OBJECT_TYPE)ObjectType,
                                            (SECURITY_DB_DELTA_TYPE)DeltaType,
                                            (PSID)ObjectSid
                                             );

            ScepNotifyLogPolicy(rc, FALSE, L"Notification Saved", DbType, ObjectType, TemplateName );

        } else {

            ScepNotifyLogPolicy(rc, FALSE, L"Error get file path", DbType, ObjectType, NULL );
        }

        //
        // free TemplateName
        //
        LocalFree(TemplateName);

        return rc;
    }

    //
    // let's check if scecli is loaded in the process
    // once it's loaded, it will stay loaded.
    //
    if ( hSceCliDll == NULL )
        hSceCliDll = LoadLibrary(TEXT("scecli.dll"));

    if ( hSceCliDll ) {
        if ( pfSceInfWriteInfo == NULL ) {
            pfSceInfWriteInfo = (PFSCEINFWRITEINFO)GetProcAddress(
                                                   hSceCliDll,
                                                   "SceWriteSecurityProfileInfo");
        }

        if ( pfSceGetInfo == NULL ) {
            pfSceGetInfo = (PFSCEGETINFO)GetProcAddress(
                                                   hSceCliDll,
                                                   "SceGetSecurityProfileInfo");
        }
    }

    //
    // if shutdown/stop service is requested, or client functions can't be found
    // quit now
    //

    if ( bStopRequest || !hSceCliDll ||
         !pfSceInfWriteInfo || !pfSceGetInfo ) {

        if ( bStopRequest ) {
            ScepNotifyLogPolicy(0, FALSE, L"Leave - Stop Requested", DbType, ObjectType, NULL );
        } else {
            rc = ERROR_MOD_NOT_FOUND;
            ScepNotifyLogPolicy(0, FALSE, L"Leave - Can't load scecli.dll or GetProcAddr", DbType, ObjectType, NULL );
        }

        return(rc);
    }

    //
    // domain DNS name is required to access the sysvol portion of group policy
    // templates.
    //
    // This information is only queried once and saved in the static global buffer.
    //
    if ( (DnsDomainInfo == NULL) ||
         (DnsDomainInfo->DnsDomainName.Buffer == NULL) ) {

        //
        // free the old buffer
        //
        if ( DnsDomainInfo ) {
            LsaFreeMemory(DnsDomainInfo);
            DnsDomainInfo = NULL;
        }

        OBJECT_ATTRIBUTES ObjectAttributes;
        LSA_HANDLE LsaPolicyHandle;

        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );

        NTSTATUS Status = LsaOpenPolicy( NULL,
                                         &ObjectAttributes,
                                         POLICY_VIEW_LOCAL_INFORMATION,
                                         &LsaPolicyHandle );

        if ( NT_SUCCESS(Status) ) {

            Status = LsaQueryInformationPolicy( LsaPolicyHandle,
                                                PolicyDnsDomainInformation,
                                                ( PVOID * )&DnsDomainInfo );

            LsaClose( LsaPolicyHandle );
        }

        rc = RtlNtStatusToDosError(Status);
    }

    //
    // get the template name (full UNC path) in sysvol
    //
    if ( ERROR_SUCCESS == rc &&
         DnsDomainInfo &&
         (DnsDomainInfo->DnsDomainName.Buffer) ) {

        rc = ScepNotifyGetDefaultGPOTemplateName(
                                (UNICODE_STRING)(DnsDomainInfo->DnsDomainName),
                                NULL,
                                bAccountGPO,
                                dwInSetup ? SCEGPO_INSETUP_NT5 : 0,
                                &TemplateName
                                );
    }

    ScepNotifyLogPolicy(rc, FALSE, L"Get template name", DbType, ObjectType, TemplateName);

    if ( ERROR_SUCCESS == rc && TemplateName ) {

        //
        // Check to see if the current DC is advertised to be a DC and
        // and synchronized with the PDC policy
        //
        // Note, this check is bypassed in setup, is only done for the
        // domain controller GPO, and for every 10 nodes processed
        //

        if ( gdwRequirePDCSync && (dwInSetup == 0) && !bAccountGPO &&
             !gbCheckSync ) {

            if ( ERROR_SUCCESS != ( rc = ScepWaitForSynchronizeWithPDC(
                                         (UNICODE_STRING)(DnsDomainInfo->DnsDomainName),
                                         TemplateName,
                                         pbTimeout)) ) {

                if ( *pbTimeout ) {
                    //
                    // we ran into maximum time out, must return and drop all nodes
                    // free TemplateName
                    //
                    LocalFree(TemplateName);

                    return rc;

                } else {

                    //
                    // logs an event and let the change go through
                    //
                    LogEvent(MyModuleHandle,
                             STATUS_SEVERITY_ERROR,
                             SCEEVENT_ERROR_POLICY_PDCVERIFY,
                             SCESRV_POLICY_ERROR_VERIFY_SYNC,
                             rc
                             );
                }
            }

            //
            // PDC is already checked, set the flag now
            //
            gbCheckSync = TRUE;
        }

        AREA_INFORMATION Area;
        PSCE_PROFILE_INFO pSceInfo=NULL;

        //
        // open template to get the existing template info
        //

        SCE_HINF hProfile;

        hProfile.Type = (BYTE)SCE_INF_FORMAT;

        rc = SceInfpOpenProfile(
                TemplateName,
                &(hProfile.hInf)
                );

        rc = ScepSceStatusToDosError(rc);

        if ( ERROR_SUCCESS == rc ) {

            if ( (DbType == SecurityDbLsa &&
                  ObjectType == SecurityDbObjectLsaAccount) ||
                 (DbType == SecurityDbSam &&
                  (ObjectType == SecurityDbObjectSamUser ||
                   ObjectType == SecurityDbObjectSamGroup ||
                   ObjectType == SecurityDbObjectSamAlias )) ) {
                Area = AREA_ATTACHMENTS; // just create the buffer;
            } else {
                Area = AREA_SECURITY_POLICY;
            }

            //
            // load informatin from the template (GP)
            //
            rc = (*pfSceGetInfo)(
                        (PVOID)&hProfile,
                        SCE_ENGINE_SCP,
                        Area,
                        &pSceInfo,
                        NULL
                        );

            rc = ScepSceStatusToDosError(rc);

            if ( ERROR_SUCCESS != rc ) {

                ScepNotifyLogPolicy(rc, FALSE, L"Error read inf", DbType, ObjectType, TemplateName);
            }

            if ( Area == AREA_ATTACHMENTS ) {
                //
                // now get the real settings for user rights
                //
                Area = AREA_PRIVILEGES;

                if ( pSceInfo ) {

                    rc = SceInfpGetPrivileges(
                                hProfile.hInf,
                                FALSE,
                                &(pSceInfo->OtherInfo.smp.pPrivilegeAssignedTo),
                                NULL
                                );

                    rc = ScepSceStatusToDosError(rc);

                    if ( ERROR_SUCCESS != rc ) {
                        ScepNotifyLogPolicy(rc, FALSE, L"Error read privileges from template", DbType, ObjectType, TemplateName);
                    }
                }
            }

            SceInfpCloseProfile(hProfile.hInf);

        } else {

            ScepNotifyLogPolicy(rc, FALSE, L"Error open inf", DbType, ObjectType, TemplateName);
        }

        if ( ERROR_SUCCESS == rc && pSceInfo ) {

            //
            // SMP and INF takes the same structure
            //
            pSceInfo->Type = SCE_ENGINE_SMP;

            BOOL bChanged = FALSE;

            ScepIsDomainLocal(NULL);

            //
            // check if there is difference between current state of LSA
            // and group policy templates.
            //
            rc = ScepNotifyGetChangedPolicies(
                            (SECURITY_DB_TYPE)DbType,
                            (SECURITY_DB_DELTA_TYPE)DeltaType,
                            (SECURITY_DB_OBJECT_TYPE)ObjectType,
                            (PSID)ObjectSid,
                            pSceInfo,
                            NULL,
                            FALSE,  // not save to DB
                            ExplicitLowRight,
                            ExplicitHighRight,
                            &bChanged
                            );

            if ( ERROR_SUCCESS == rc && bChanged ) {
                //
                // no error, get the policy for the area changed
                // now, write it back to the template
                //

                ScepNotifyLogPolicy(0, FALSE, L"Save", DbType, ObjectType, NULL );

                ScepCheckAndWaitPolicyPropFinish();

                PSCE_ERROR_LOG_INFO pErrList=NULL;

                rc = (*pfSceInfWriteInfo)(
                                TemplateName,
                                Area,
                                (PSCE_PROFILE_INFO)pSceInfo,
                                &pErrList
                                );

                ScepNotifyLogPolicy(rc, FALSE, L"Save operation", DbType, ObjectType, NULL );

                for (PSCE_ERROR_LOG_INFO pErr = pErrList; pErr != NULL; pErr = pErr->next) {

                   ScepNotifyLogPolicy(pErr->rc, FALSE, L"Save operation error", DbType, ObjectType, pErr->buffer );
                }

                ScepFreeErrorLog(pErrList);

                rc = ScepSceStatusToDosError(rc);

                //
                // only update version # of the GPO if it's not access denied or file not found
                // if verion # failed to update, still continue but in which case
                // the change will probably not get replicated and applied on
                // other DCs right away
                //

                if ( ERROR_ACCESS_DENIED != rc &&
                     ERROR_FILE_NOT_FOUND != rc ) {

                    DWORD rc2 = ScepNotifyUpdateGPOVersion( TemplateName,
                                                            bAccountGPO );

                    ScepNotifyLogPolicy(rc2, FALSE, L"GPO Version updated", DbType, ObjectType, NULL );
                }

            } else if ( ERROR_SUCCESS == rc ) {
                //
                // nothing changed
                //
                ScepNotifyLogPolicy(0, FALSE, L"No change", DbType, ObjectType, NULL );
            }

        }

        //
        // free any memory allocated
        //
        SceFreeMemory( (PVOID)pSceInfo, Area);
        ScepFree(pSceInfo);

    } else {

        ScepNotifyLogPolicy(rc, FALSE, L"Error get file path", DbType, ObjectType, NULL );
    }

    //
    // free TemplateName
    //
    LocalFree(TemplateName);

    return rc;
}

DWORD
ScepWaitForSynchronizeWithPDC(
    IN UNICODE_STRING DnsDomainName,
    IN PWSTR LocalTemplateName,
    OUT BOOL *pbTimeout
    )
/*
Description:

    Wait and verify that local DC is advertised and PDC is available.

    When PDC is available, check the last modified time of local policy
    template is equal or newer than the one on PDC. If the local copy is
    too old, wait and check again until timeout.

Arguments:

    DnsDomainName - the dns domain name which may be needed in template path

    LocalTemplateName - the template full path name on the local DC.

    pbTimeout  - output to indicate if maximum wait has been reached.

*/
{

    WCHAR           SysName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD           Len;
    DWORD           rc=ERROR_SUCCESS;

    DWORD dwDCWait = 0;
    DWORD dwMaxWaitCount = gdwMaxPDCWait / gdwPDCRetry + 1;

    //
    //  make sure current DC is advertised
    //

    PDOMAIN_CONTROLLER_INFOW    DCInfo=NULL;
    PDOMAIN_CONTROLLER_INFOW    PDCInfo=NULL;
    PWSTR pComputerName=NULL;
    PWSTR pTemp=NULL;

    WIN32_FIND_DATA *LocalFileData=NULL;
    WIN32_FIND_DATA *PDCFileData=NULL;
    LARGE_INTEGER FileTime1;
    LARGE_INTEGER FileTime2;

    HANDLE hLocal=INVALID_HANDLE_VALUE;
    HANDLE hPDC = INVALID_HANDLE_VALUE;
    PWSTR PDCTemplateName=NULL;

    //
    // dynamic allocate stack buffer
    //
    SafeAllocaAllocate(LocalFileData, sizeof(WIN32_FIND_DATA));
    if ( LocalFileData == NULL ) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    SafeAllocaAllocate(PDCFileData, sizeof(WIN32_FIND_DATA));

    if ( PDCFileData == NULL ) {
        SafeAllocaFree(LocalFileData);
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    do {

        ScepNotifyLogPolicy(0, TRUE, L"Verify Sync: Check synchronization with PDC", 0, 0, NULL );

        SysName[0] = L'\0';
        Len = MAX_COMPUTERNAME_LENGTH;

        if ( !GetComputerName(SysName, &Len) ) {
            rc = GetLastError();

            ScepNotifyLogPolicy(rc, FALSE, L"Verify Sync: Failed to get computer name", 0, 0, NULL );

            //
            // do not return, let it fail in DsGetDcName so we can get the maximum wait
            //
        }

        //
        // get local DC status
        //
        rc = DsGetDcName(SysName,
                          NULL,
                          NULL,
                          NULL,
                          DS_IS_DNS_NAME,
                          &DCInfo
                          );

        if ( ERROR_SUCCESS == rc ) {

            //
            // current DC is available, check the DS role
            // local DC role should be accurate
            //

            if ( 0 == (DCInfo->Flags & DS_PDC_FLAG) ) {

                //
                // local DC is not a PDC, check PDC role
                // get the PDC name first
                //

                rc = DsGetDcName(NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  DS_IS_FLAT_NAME | DS_PDC_REQUIRED,
                                  &PDCInfo
                                  );

                if ( ERROR_SUCCESS == rc ) {

                    //
                    // Even though DsGetDcName tells the DS role is a PDC,
                    // it may not be (e.g., FSMO is transferred).
                    //
                    // Talk to the DC remotely to confirm. If the DC is not
                    // hosting a PDC role, let the code wait and retry
                    // since DsGetDcName cache will be eventually updated with
                    // the correct PDC info
                    //

                    pComputerName = PDCInfo->DomainControllerName;
                    //
                    // skip the backslashes
                    //
                    while ( *pComputerName == L'\\' ) pComputerName++;

                    //
                    // search for . to extract the computer name
                    //
                    pTemp = wcschr(pComputerName, L'.');
                    if ( pTemp ) *pTemp = L'\0';


                    BOOL bIsPDC = TRUE;

                    rc = ScepVerifyPDCRole(pComputerName, &bIsPDC);

                    //
                    // verify that the PDC name returned is indeed a PDC
                    //
                    if ( ERROR_SUCCESS != rc ) {

                        ScepNotifyLogPolicy(rc, FALSE, L"Verify Sync: Fail to verify PDC role for ", 0, 0, pComputerName );
                        rc = ERROR_INVALID_DOMAIN_ROLE;

                    } else if ( !bIsPDC ) {

                        ScepNotifyLogPolicy(0, FALSE, L"Verify Sync: Computer is not really in PDC role.", 0, 0, pComputerName );
                        rc = ERROR_INVALID_DOMAIN_ROLE;

                    } else {

                        //
                        // get the timestamp of gpttmpl.inf from the PDC
                        //
                        PDCTemplateName=NULL;

                        rc = ScepNotifyGetDefaultGPOTemplateName(DnsDomainName,
                                                                 pComputerName,
                                                                 FALSE,
                                                                 SCEGPO_NOCHECK_EXISTENCE,
                                                                 &PDCTemplateName
                                                                );

                        ScepNotifyLogPolicy(rc, FALSE, L"Verify Sync: Get template name on PDC", 0, 0, PDCTemplateName );

                        if ( ERROR_SUCCESS != rc ) {
                            //
                            // if failed to build a template name, it must because of out of memory
                            // no need to loop for this kind of failure
                            //
                            break;

                        } else {

                            if ( 0xFFFFFFFF == GetFileAttributes(PDCTemplateName) ) {

                                //
                                // current PDC template is not reachable, try again
                                // this could be become of network problem.
                                //
                                rc = GetLastError();
                                ScepNotifyLogPolicy(rc, FALSE, L"Verify Sync: PDC template is not accessible. Try again later", 0, 0, NULL );

                            } else {

                                //
                                // get local timestamp
                                //
                                memset(LocalFileData, '\0', sizeof(WIN32_FIND_DATA));
                                memset(PDCFileData, '\0', sizeof(WIN32_FIND_DATA));

                                hLocal=INVALID_HANDLE_VALUE;
                                hPDC = INVALID_HANDLE_VALUE;

                                hLocal = FindFirstFile(LocalTemplateName, LocalFileData);
                                if ( hLocal != INVALID_HANDLE_VALUE ) {

                                    FindClose(hLocal);
                                    hLocal = NULL;

                                    //
                                    // get PDC time stamp
                                    //

                                    hPDC = FindFirstFile(PDCTemplateName, PDCFileData);

                                    if ( hPDC != INVALID_HANDLE_VALUE ) {

                                        FindClose(hPDC);
                                        hPDC = NULL;

                                        FileTime1.LowPart = LocalFileData->ftLastWriteTime.dwLowDateTime;
                                        FileTime1.HighPart = LocalFileData->ftLastWriteTime.dwHighDateTime;

                                        FileTime2.LowPart = PDCFileData->ftLastWriteTime.dwLowDateTime;
                                        FileTime2.HighPart = PDCFileData->ftLastWriteTime.dwHighDateTime;

                                        //
                                        // get time difference in minutes
                                        //
                                        LONG lDiff = 0;

                                        if ( FileTime2.QuadPart != FileTime1.QuadPart ) {
                                            lDiff = (LONG) ((FileTime2.QuadPart - FileTime1.QuadPart) / 10000000);
                                            lDiff /= 60;

                                            if ( lDiff >= 0 ) lDiff ++;
                                            else lDiff --;
                                        }

                                        WCHAR szTime[32];
                                        swprintf(szTime, L"%d minutes\0", lDiff);

                                        if ( lDiff <= 0 ) {
                                            //
                                            // the local copy is newer or within the allowed delta window
                                            // so this check is passed
                                            //
                                            ScepNotifyLogPolicy(0, FALSE, L"Verify Sync: Local copy is within range from PDC", 0, 0, szTime );
                                            break;

                                        } else {

                                            ScepNotifyLogPolicy(0, FALSE, L"Verify Sync: Local copy is out of range from PDC", 0, 0, szTime );
                                            rc = WAIT_TIMEOUT;
                                        }

                                    } else {

                                        rc = GetLastError();
                                        ScepNotifyLogPolicy(rc, FALSE, L"Verify Sync: Failed to get PDC file time", 0, 0, PDCTemplateName );
                                    }

                                } else {

                                    //
                                    // if it cannot query file time on the local box
                                    // something is wrong locally, do not retry
                                    //
                                    rc = GetLastError();
                                    ScepNotifyLogPolicy(rc, FALSE, L"Verify Sync: Failed to get local file time", 0, 0, LocalTemplateName );

                                    break;

                                }

                            }

                            //
                            // mask the error so that caller knows if it reaches maximum wait
                            //
                            if ( ERROR_SUCCESS != rc ) {

                                rc = WAIT_TIMEOUT;
                            }

                        }

                    }

                } else {

                    //
                    // current PDC is not available, try again
                    //

                    ScepNotifyLogPolicy(rc, FALSE, L"Verify Sync: Fail to get PDC info. Try again later", 0, 0, NULL );
                    rc = ERROR_INVALID_DOMAIN_ROLE;
                }

            } else {

                //
                // local DC is already a PDC, no need to check
                // break the loop
                //
                ScepNotifyLogPolicy(0, FALSE, L"Verify Sync: Local DC is a PDC", 0, 0, NULL );

                break;
            }


        } else {

            ScepNotifyLogPolicy(rc, FALSE, L"Verify Sync: Fail to get local DC info. Try again later", 0, 0, NULL );

            rc = ERROR_DOMAIN_CONTROLLER_NOT_FOUND;
        }

        //
        // restore the name
        //
        if ( pTemp ) {
            *pTemp = L'.';
            pTemp=NULL;
        }

        //
        // free buffers
        //

        if ( PDCInfo ) {
            NetApiBufferFree(PDCInfo);
            PDCInfo = NULL;
        }
        pComputerName = NULL;

        if ( DCInfo ) {
            NetApiBufferFree(DCInfo);
            DCInfo = NULL;
        }

        if ( PDCTemplateName ) {
            ScepFree(PDCTemplateName);
            PDCTemplateName = NULL;
        }

        //
        // sleep for some time and try again
        //
        Sleep(gdwPDCRetry*60*1000);
        dwDCWait++;

    } while ( dwDCWait < dwMaxWaitCount );


    if ( dwDCWait >= dwMaxWaitCount &&
         ERROR_SUCCESS != rc ) {

        //
        // something fails/times out when verifying the PDC, log a message
        //

        switch ( rc ) {
        case ERROR_DOMAIN_CONTROLLER_NOT_FOUND:

            ScepNotifyLogPolicy(0, TRUE, L"Verify Sync: Local DC is not advertised", 0, 0, NULL );
            *pbTimeout = TRUE;
            break;
        case ERROR_INVALID_DOMAIN_ROLE:

            ScepNotifyLogPolicy(0, TRUE, L"Verify Sync: PDC role cannot be found", 0, 0, NULL );
            *pbTimeout = TRUE;
            break;
        case WAIT_TIMEOUT:

            ScepNotifyLogPolicy(0, TRUE, L"Verify Sync: Local policy is not or may not be synchronized with PDC", 0, 0, NULL );
            *pbTimeout = TRUE;
            break;
        }
    }


    //
    // restore the name
    //
    if ( pTemp ) {
        *pTemp = L'.';
    }

    //
    // free buffers
    //

    if ( PDCInfo ) {
        NetApiBufferFree(PDCInfo);
    }

    if ( DCInfo ) {
        NetApiBufferFree(DCInfo);
    }

    if ( PDCTemplateName )
        ScepFree(PDCTemplateName);


    SafeAllocaFree(PDCFileData);
    SafeAllocaFree(LocalFileData);

    return rc;

}

DWORD
ScepVerifyPDCRole(
    IN PWSTR pComputerName,
    OUT BOOL *pbIsPDC
    )
/*
Description:

    For the given computer name (returned from DsGetDcName for PDC role),
    verify that it's indeed hold a PDC FSMO at the current time.

    DsGetDcName may returned cached name for the PDC which may not be
    in function, or PDC FSMO may be transferred.

    This is to guarantee that we always compare with PDC policy

Arguments:

    pComputerName - the computer name for the proposed PDC

    pbIsPDC - When return code is success, TRUE = PDC, FALSE = non PDC

Return Value:

    Win32 error
*/

{
    if ( pComputerName == NULL || pbIsPDC == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }


    NTSTATUS                    NtStatus;
    LSA_OBJECT_ATTRIBUTES       attributes;
    SECURITY_QUALITY_OF_SERVICE service;
    LSA_HANDLE                  PolicyHandle=NULL;
    DWORD                       rc=0;

    memset( &attributes, 0, sizeof(attributes) );
    attributes.Length = sizeof(attributes);
    attributes.SecurityQualityOfService = &service;
    service.Length = sizeof(service);
    service.ImpersonationLevel= SecurityImpersonation;
    service.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    service.EffectiveOnly = TRUE;

    LSA_UNICODE_STRING SystemName;

    SystemName.Buffer = pComputerName;
    SystemName.Length = wcslen(pComputerName)*sizeof(WCHAR);
    SystemName.MaximumLength = SystemName.Length + 2;

    //
    // open the remote lsa
    //

    NtStatus = LsaOpenPolicy(
                    &SystemName,
                    &attributes,
                    POLICY_VIEW_LOCAL_INFORMATION,
                    &PolicyHandle
                    );

    rc = RtlNtStatusToDosError(NtStatus);

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // query LSA server role from the remote computer
        //
        PPOLICY_LSA_SERVER_ROLE_INFO pServerRole=NULL;

        NtStatus = LsaQueryInformationPolicy(PolicyHandle,
                                             PolicyLsaServerRoleInformation,
                                             (PVOID *)&pServerRole
                                            );

        rc = RtlNtStatusToDosError(NtStatus);

        if ( NT_SUCCESS(NtStatus) ) {

            //
            // check the role and set output appropriately
            //
            if ( PolicyServerRolePrimary == pServerRole->LsaServerRole ) {
                *pbIsPDC = TRUE;
            } else {
                *pbIsPDC = FALSE;
            }

            LsaFreeMemory(pServerRole);

            rc = ERROR_SUCCESS;
        }

        LsaClose(PolicyHandle);
    }

    return(rc);
}


SCEPR_STATUS
SceRpcBrowseDatabaseTable(
    IN handle_t binding_h,
    IN wchar_t *DatabaseName OPTIONAL,
    IN SCEPR_TYPE ProfileType,
    IN AREAPR Area,
    IN BOOL bDomainPolicyOnly
    )
{

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    SCESTATUS rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // initialize jet engine in system context
    //
    rc = SceJetInitialize(NULL);

    if ( SCESTATUS_SUCCESS != rc ) {
        return(rc);
    }

    //
    // impersonate the client, return DWORD error code
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        //
        // if no other active clients, terminate jet engine
        //
        ScepIfTerminateEngine();

        return( ScepDosErrorToSceStatus(rc) );

    }


    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }


    //
    // get the database name
    //

    BOOL bAdminLogon=FALSE;
    LPTSTR DefProfile=NULL;
    PSCECONTEXT hProfile=NULL;

    __try {

        rc = ScepGetDefaultDatabase(
                 (LPCTSTR)DatabaseName,
                 0,
                 NULL,
                 &bAdminLogon,
                 &DefProfile
                 );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        rc = ERROR_EXCEPTION_IN_SERVICE;
    }

    rc = ScepDosErrorToSceStatus(rc);

    if ( SCESTATUS_SUCCESS == rc && DefProfile ) {

        //
        // OpenDatabase is not blocked by any task.
        //

        EnterCriticalSection(&ContextSync);

        DWORD Option=0;
        if ( ProfileType == SCE_ENGINE_SAP ) {
            if ( bDomainPolicyOnly )
                Option = SCE_OPEN_OPTION_TATTOO;
            else
                Option = SCE_OPEN_OPTION_REQUIRE_ANALYSIS;
        }

        rc = ScepOpenDatabase(
                    (PCWSTR)DefProfile,
                    Option,
                    SCEJET_OPEN_READ_ONLY,
                    &hProfile
                    );

        if ( SCESTATUS_SUCCESS == rc ) {
            //
            // a new context is opened, add it to the open context list
            //

            if ( (ProfileType != SCE_ENGINE_SAP) && bDomainPolicyOnly &&
                 ( (hProfile->Type & 0xF0L) != SCEJET_MERGE_TABLE_1 ) &&
                 ( (hProfile->Type & 0xF0L) != SCEJET_MERGE_TABLE_2 ) ) {
                //
                // there is no merged policy table
                //
                rc = SceJetCloseFile(
                        hProfile,
                        TRUE,
                        FALSE
                        );

                rc = SCESTATUS_PROFILE_NOT_FOUND;
                hProfile = NULL;

            } else {

                ScepAddToOpenContext(hProfile);
            }
        } else {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_OPEN, DefProfile);
        }

        LeaveCriticalSection(&ContextSync);

        if ( DefProfile != DatabaseName )
            ScepFree(DefProfile);
        DefProfile = NULL;
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        if ( ProfileType == SCE_ENGINE_SCP ) {
            switch ( (hProfile->Type & 0xF0L) ) {
            case SCEJET_MERGE_TABLE_1:
                SceClientBrowseCallback(
                        0,
                        L"Merged Policy Table 1",
                        NULL,
                        NULL
                        );
                break;
            case SCEJET_MERGE_TABLE_2:
                SceClientBrowseCallback(
                        0,
                        L"Merged Policy Table 2",
                        NULL,
                        NULL
                        );
                break;
            default:

                SceClientBrowseCallback(
                        0,
                        L"There is no merged policy table. Local policy table is used.",
                        NULL,
                        NULL
                        );
                break;
            }

        }
        //
        // browse the information now
        //
        DWORD dwBrowseOptions;

        if ( (ProfileType != SCE_ENGINE_SAP) && bDomainPolicyOnly ) {
            dwBrowseOptions = SCEBROWSE_DOMAIN_POLICY;
        } else {
            dwBrowseOptions = 0;
        }

        if ( Area & AREA_SECURITY_POLICY ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szSystemAccess,
                        dwBrowseOptions
                        );

            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szKerberosPolicy,
                            dwBrowseOptions
                            );
            }

            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szAuditEvent,
                            dwBrowseOptions
                            );
            }

            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szAuditSystemLog,
                            dwBrowseOptions
                            );
            }

            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szAuditSecurityLog,
                            dwBrowseOptions
                            );
            }
            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szAuditApplicationLog,
                            dwBrowseOptions
                            );
            }
            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szRegistryValues,
                            dwBrowseOptions | SCEBROWSE_MULTI_SZ
                            );
            }
        }

        if ( (Area & AREA_PRIVILEGES) &&
             (SCESTATUS_SUCCESS == rc) ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szPrivilegeRights,
                        dwBrowseOptions | SCEBROWSE_MULTI_SZ
                        );
        }
        if ( (Area & AREA_GROUP_MEMBERSHIP) &&
             (SCESTATUS_SUCCESS == rc) ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szGroupMembership,
                        dwBrowseOptions | SCEBROWSE_MULTI_SZ
                        );
        }
        if ( (Area & AREA_SYSTEM_SERVICE) &&
             (SCESTATUS_SUCCESS == rc) ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szServiceGeneral,
                        dwBrowseOptions
                        );
        }

        if ( (Area & AREA_REGISTRY_SECURITY) &&
             (SCESTATUS_SUCCESS == rc) ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szRegistryKeys,
                        dwBrowseOptions
                        );
        }
        if ( (Area & AREA_FILE_SECURITY) &&
             (SCESTATUS_SUCCESS == rc) ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szFileSecurity,
                        dwBrowseOptions
                        );
        }

        if ( (Area & AREA_ATTACHMENTS) &&
             (SCESTATUS_SUCCESS == rc) ) {

            PSCE_NAME_LIST    pList=NULL;

            rc = ScepEnumAttachmentSections( hProfile, &pList);

            if ( rc == SCESTATUS_SUCCESS ) {

                for ( PSCE_NAME_LIST pNode=pList; pNode != NULL; pNode=pNode->Next) {

                    rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            pNode->Name,
                            dwBrowseOptions
                            );
                    if ( SCESTATUS_SUCCESS != rc ) {
                        break;
                    }
                }
            }

            ScepFreeNameList(pList);
        }

        ScepValidateAndCloseDatabase(hProfile);
        hProfile = NULL;

    } else {

        //
        // start a timer queue to check to see if there is active tasks/contexts
        // if not, terminate jet engine
        //
        ScepIfTerminateEngine();

    }

    ScepLogClose();

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}

BOOL
ScepIsSystemShutDown()
{

    return(gbSystemShutdown);

}

SCESTATUS
ScepConvertServices(
    IN OUT PVOID *ppServices,
    IN BOOL bSRForm
    )
{
    if ( !ppServices ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    PSCE_SERVICES pTemp = (PSCE_SERVICES)(*ppServices);
    SCESTATUS rc=SCESTATUS_SUCCESS;

    PSCE_SERVICES pNewNode;
    PSCE_SERVICES pNewServices=NULL;

    while ( pTemp ) {

        pNewNode = (PSCE_SERVICES)ScepAlloc(0,sizeof(SCE_SERVICES));

        if ( pNewNode ) {

            pNewNode->ServiceName = pTemp->ServiceName;
            pNewNode->DisplayName = pTemp->DisplayName;
            pNewNode->Status = pTemp->Status;
            pNewNode->Startup = pTemp->Startup;
            pNewNode->SeInfo = pTemp->SeInfo;

            pNewNode->General.pSecurityDescriptor = NULL;

            pNewNode->Next = pNewServices;
            pNewServices = pNewNode;

            if ( bSRForm ) {
                //
                // Service node is in SCEPR_SERVICES structure
                // convert it to SCE_SERVICES structure
                // in this case, just use the self relative security descriptor
                //
                if ( pTemp->General.pSecurityDescriptor) {
                    pNewNode->General.pSecurityDescriptor = ((PSCEPR_SERVICES)pTemp)->pSecurityDescriptor->SecurityDescriptor;
                }

            } else {

                //
                // Service node is in SCE_SERVICES strucutre
                // convert it to SCEPR_SERVICES structure
                //
                // make the SD to self relative format and PSCEPR_SR_SECURITY_DESCRIPTOR
                //

                if ( pTemp->General.pSecurityDescriptor ) {

                    if ( !RtlValidSid ( pTemp->General.pSecurityDescriptor ) ) {
                        rc = SCESTATUS_INVALID_PARAMETER;
                        break;
                    }

                    //
                    // get the length
                    //
                    DWORD nLen = 0;
                    DWORD NewLen;
                    PSECURITY_DESCRIPTOR pSD;
                    PSCEPR_SR_SECURITY_DESCRIPTOR pNewWrap;

                    RtlMakeSelfRelativeSD( pTemp->General.pSecurityDescriptor,
                                           NULL,
                                           &nLen
                                         );

                    if ( nLen > 0 ) {

                        pSD = (PSECURITY_DESCRIPTOR)ScepAlloc(LMEM_ZEROINIT, nLen);

                        if ( !pSD ) {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            break;
                        }

                        NewLen = nLen;

                        rc = ScepDosErrorToSceStatus(
                               RtlNtStatusToDosError(
                                 RtlMakeSelfRelativeSD( pTemp->General.pSecurityDescriptor,
                                                        pSD,
                                                        &NewLen
                                                      ) ) );

                        if ( SCESTATUS_SUCCESS == rc ) {

                            //
                            // create a wrapper node to contain the security descriptor
                            //

                            pNewWrap = (PSCEPR_SR_SECURITY_DESCRIPTOR)ScepAlloc(0, sizeof(SCEPR_SR_SECURITY_DESCRIPTOR));
                            if ( pNewWrap ) {

                                //
                                // assign the wrap to the structure
                                //
                                pNewWrap->SecurityDescriptor = (UCHAR *)pSD;
                                pNewWrap->Length = nLen;

                            } else {
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            }
                        }

                        if ( SCESTATUS_SUCCESS != rc ) {
                            ScepFree(pSD);
                            break;
                        }

                        //
                        // now link the SR_SD to the list
                        //
                        ((PSCEPR_SERVICES)pNewNode)->pSecurityDescriptor = pNewWrap;

                    } else {
                        //
                        // something is wrong with the SD
                        //
                        rc = SCESTATUS_INVALID_PARAMETER;
                        break;
                    }
                }
            }

        } else {
            //
            // all allocated buffer are in the list of pNewServices
            //
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            break;
        }

        pTemp = pTemp->Next;
    }

    if ( SCESTATUS_SUCCESS != rc ) {

        //
        // free pNewServices
        //
        ScepFreeConvertedServices( (PVOID)pNewServices, !bSRForm );
        pNewServices = NULL;
    }

    *ppServices = (PVOID)pNewServices;

    return(rc);
}


SCESTATUS
ScepFreeConvertedServices(
    IN PVOID pServices,
    IN BOOL bSRForm
    )
{

    if ( pServices == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    PSCEPR_SERVICES pNewNode = (PSCEPR_SERVICES)pServices;

    PSCEPR_SERVICES pTempNode;

    while ( pNewNode ) {

        if ( bSRForm && pNewNode->pSecurityDescriptor ) {

            //
            // free this allocated buffer (PSCEPR_SR_SECURITY_DESCRIPTOR)
            //
            if ( pNewNode->pSecurityDescriptor->SecurityDescriptor ) {
                ScepFree( pNewNode->pSecurityDescriptor->SecurityDescriptor);
            }
            ScepFree(pNewNode->pSecurityDescriptor);
        }

        //
        // also free the PSCEPR_SERVICE node (but not the names referenced by this node)
        //
        pTempNode = pNewNode;
        pNewNode = pNewNode->Next;

        ScepFree(pTempNode);
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
SceRpcGetSystemSecurity(
    IN handle_t binding_h,
    IN AREAPR                 Area,
    IN DWORD                  Options,
    OUT PSCEPR_PROFILE_INFO __RPC_FAR *ppInfoBuffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Query system security settings)

    Only password, account lockout, kerberos, audit, user rights, and
    SCE registry values are queried.

    multile threads doing get/set system security are not blocked. In
    other words, system security settings are not exclusive.
*/

{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    DWORD rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    __try {
        //
        // catch exception if InfFileName, or pebClient/pdWarning are bogus
        //
        rc = ScepGetSystemSecurity(
                (AREA_INFORMATION)Area,
                Options,
                (PSCE_PROFILE_INFO *)ppInfoBuffer,
                (PSCE_ERROR_LOG_INFO *)Errlog
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = SCESTATUS_EXCEPTION_IN_SERVER;
    }

    RpcRevertToSelf();

    return(rc);
}

SCESTATUS
SceRpcGetSystemSecurityFromHandle(
    IN SCEPR_CONTEXT          Context,  // must be a context point to system db
    IN AREAPR                 Area,
    IN DWORD                  Options,
    OUT PSCEPR_PROFILE_INFO __RPC_FAR *ppInfoBuffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Query local security policy from the system (directly)

    Only password, account lockout, kerberos, audit, user rights, and
    SCE registry values are queried.

    multile threads doing get/set system security are not blocked. In
    other words, system security settings are not exclusive.
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    DWORD rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // should we validate the profile handle?
    // it's not used here so it's not validated now.
    //

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    __try {
        //
        // catch exception if InfFileName, or pebClient/pdWarning are bogus
        //
        rc = ScepGetSystemSecurity(
                (AREA_INFORMATION)Area,
                Options,
                (PSCE_PROFILE_INFO *)ppInfoBuffer,
                (PSCE_ERROR_LOG_INFO *)Errlog
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = SCESTATUS_EXCEPTION_IN_SERVER;
    }

    RpcRevertToSelf();

    return(rc);
}

SCEPR_STATUS
SceRpcSetSystemSecurityFromHandle(
    IN SCEPR_CONTEXT          Context,  // must be a context point to system db
    IN AREAPR                 Area,
    IN DWORD                  Options,
    IN PSCEPR_PROFILE_INFO __RPC_FAR pInfoBuffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Set local security policy to the system (directly)

    Only password, account lockout, kerberos, audit, user rights, and
    SCE registry values are set.

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    DWORD rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // should we validate the profile handle?
    // it's not used here so it's not validated now.
    //

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    __try {
        //
        // catch exception if InfFileName, or pebClient/pdWarning are bogus
        //
        rc = ScepSetSystemSecurity(
                (AREA_INFORMATION)Area,
                Options,
                (PSCE_PROFILE_INFO)pInfoBuffer,
                (PSCE_ERROR_LOG_INFO *)Errlog
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = SCESTATUS_EXCEPTION_IN_SERVER;
    }

    RpcRevertToSelf();

    return(rc);
}


SCEPR_STATUS
SceRpcSetSystemSecurity(
    IN handle_t binding_h,
    IN AREAPR                 Area,
    IN DWORD                  Options,
    IN PSCEPR_PROFILE_INFO __RPC_FAR pInfoBuffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Set local security policy to the system (directly)

    Only password, account lockout, kerberos, audit, user rights, and
    SCE registry values are set.

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    DWORD rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    __try {
        //
        // catch exception if InfFileName, or pebClient/pdWarning are bogus
        //
        rc = ScepSetSystemSecurity(
                (AREA_INFORMATION)Area,
                Options,
                (PSCE_PROFILE_INFO)pInfoBuffer,
                (PSCE_ERROR_LOG_INFO *)Errlog
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = SCESTATUS_EXCEPTION_IN_SERVER;
    }

    RpcRevertToSelf();

    return(rc);
}


SCEPR_STATUS
SceRpcSetDatabaseSetting(
    IN SCEPR_CONTEXT  Context,
    IN SCEPR_TYPE     ProfileType,
    IN wchar_t *SectionName,
    IN wchar_t *KeyName,
    IN PSCEPR_VALUEINFO pValueInfo OPTIONAL
    )
/*
Set or delete value from the given key

if pValueInfo is NULL, delete the key

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    if ( SCEPR_SMP != ProfileType ) {
        return SCESTATUS_INVALID_PARAMETER;
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;
    PSCESECTION hSection=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {
            //
            // catch exception if Context, ppInfoBuffer, Errlog are bogus pointers
            //
#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
                //
                // query the information now
                //

                rc = ScepOpenSectionForName(
                            (PSCECONTEXT)Context,
                            (SCETYPE)ProfileType,
                            SectionName,
                            &hSection
                            );

                if ( SCESTATUS_SUCCESS == rc ) {

                    if ( pValueInfo == NULL || pValueInfo->Value == NULL ) {
                        // delete the key
                        rc = SceJetDelete(
                            hSection,
                            KeyName,
                            FALSE,
                            SCEJET_DELETE_LINE_NO_CASE
                            );

                    } else {
                        // set the value
                        rc = SceJetSetLine(
                                   hSection,
                                   KeyName,
                                   FALSE,
                                   (PWSTR)pValueInfo->Value,
                                   pValueInfo->ValueLen,
                                   0
                                   );
                    }

                    SceJetCloseSection(&hSection, TRUE);
                }

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // free ppInfoBuffer if it's allocated
            //

            if ( hSection )
                SceJetCloseSection(&hSection, TRUE);

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);

}

SCEPR_STATUS
SceRpcGetDatabaseSetting(
    IN SCEPR_CONTEXT  Context,
    IN SCEPR_TYPE     ProfileType,
    IN wchar_t *SectionName,
    IN wchar_t *KeyName,
    OUT PSCEPR_VALUEINFO *pValueInfo
    )
/*
Routine Description:

    Get information for the particular key from the context database.

Arguments:

Return Value:

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    if ( !pValueInfo ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( SCEPR_SMP != ProfileType ) {
        return SCESTATUS_INVALID_PARAMETER;
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;
    PSCESECTION hSection=NULL;
    PWSTR Value=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {
            //
            // catch exception if Context, ppInfoBuffer, Errlog are bogus pointers
            //
#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
                //
                // query the information now
                //

                rc = ScepOpenSectionForName(
                            (PSCECONTEXT)Context,
                            (SCETYPE)ProfileType,
                            SectionName,
                            &hSection
                            );

                if ( SCESTATUS_SUCCESS == rc ) {

                    DWORD ValueLen=0;
                    DWORD NewLen=0;

                    rc = SceJetGetValue(
                            hSection,
                            SCEJET_EXACT_MATCH_NO_CASE,
                            KeyName,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            0,
                            &ValueLen
                            );

                    // allocate output buffer
                    if ( SCESTATUS_SUCCESS == rc ) {
                        Value = (PWSTR)ScepAlloc(LPTR, ValueLen+2);

                        if ( !Value )
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        else {
                            *pValueInfo = (PSCEPR_VALUEINFO)ScepAlloc(0,sizeof(SCEPR_VALUEINFO));

                            if ( *pValueInfo == NULL ) {
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            }
                        }
                    }

                    // query the value
                    if ( SCESTATUS_SUCCESS == rc ) {

                        rc = SceJetGetValue(
                                hSection,
                                SCEJET_CURRENT,
                                KeyName,
                                NULL,
                                0,
                                NULL,
                                Value,
                                ValueLen,
                                &NewLen
                                );
                        if ( SCESTATUS_SUCCESS == rc ) {
                            (*pValueInfo)->ValueLen = ValueLen+2;
                            (*pValueInfo)->Value = (byte *)Value;
                        }
                    }

                    // free buffer
                    if ( SCESTATUS_SUCCESS != rc ) {

                        if ( Value ) ScepFree(Value);
                        if ( *pValueInfo ) {
                            ScepFree(*pValueInfo);
                            *pValueInfo = NULL;
                        }
                    }

                    SceJetCloseSection(&hSection, TRUE);
                }

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // free ppInfoBuffer if it's allocated
            //

            if ( Value ) ScepFree(Value);
            if ( *pValueInfo ) {
                ScepFree(*pValueInfo);
                *pValueInfo = NULL;
            }

            if ( hSection )
                SceJetCloseSection(&hSection, TRUE);

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);

}

DWORD
SceRpcConfigureConvertedFileSecurityImmediately(
    IN handle_t binding_h,
    IN wchar_t *pszDriveName
    )
/*
Routine Description:

    RPC interface called by SCE client (only when conversion of security is immediate)

Arguments:

    binding_h       -   binding handle
    pszDriveName   -   name of the volume for which setup-style security is to be applied

Return:

    win32 error code

*/

{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC
        //

        return SCESTATUS_ACCESS_DENIED;

    }

    DWORD rc = ERROR_SUCCESS;
    NTSTATUS    Status = NO_ERROR;

    if ( pszDriveName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken, TRUE));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    rc = ScepConfigureConvertedFileSecurityImmediate( pszDriveName );

    RpcRevertToSelf();

    return(rc);
}


DWORD
ScepServerConfigureSystem(
    IN  PWSTR   InfFileName,
    IN  PWSTR   DatabaseName,
    IN  PWSTR   LogFileName,
    IN  DWORD   ConfigOptions,
    IN  AREA_INFORMATION  Area
    )
/*
Routine Description:

    Configure the system using the Inf template. This routine is similar to the RPC interface
    SceRpcConfigureSystem except that the configuration is initiated by the server itself.

    Since this routine is called by the server only (system context) and not by sce client,
    there is no need to do impersonate etc.
    Log file initialization etc. is done outside of this routine

Arguments:

    InfFileName     -   name of inf file to import configuration information from
    DatabaseName    -   name of database to import into
    LogFileName     -   name of log file to log errors
    ConfigOptions   -   configuration options ()
    Area            -   security area to configure

Return Value:

    win32 error code
*/
{
    DWORD rc = ERROR_SUCCESS;

    if (InfFileName == NULL || DatabaseName == NULL || LogFileName == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // initialize jet engine in system context if not already initialized
    //
    rc = SceJetInitialize(NULL);

    if ( rc != SCESTATUS_SUCCESS ) {
        return(ScepSceStatusToDosError(rc));
    }

    //
    // no one else can use convert.sdb - lock access to it
    //

    rc = ScepLockEngine(DatabaseName);

    if ( SCESTATUS_ALREADY_RUNNING == rc ) {
        //
        // will wait for max one minute
        //
        DWORD dwWaitCount = 0;

        while ( TRUE ) {

            Sleep(5000);  // 5 seconds

            rc = ScepLockEngine(DatabaseName);

            dwWaitCount++;

            if ( SCESTATUS_SUCCESS == rc ||
                 dwWaitCount >= 12 ) {
                break;
            }
        }
    }


    if ( SCESTATUS_SUCCESS == rc ) {


        __try {
            //
            // catch exception if InfFileName, or pebClient/pdWarning are bogus
            //
            rc = ScepConfigureSystem(
                                    (LPCTSTR)InfFileName,
                                    DatabaseName,
                                    ConfigOptions,
                                    TRUE,
                                    (AREA_INFORMATION)Area,
                                    NULL
                                    );

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }

        ScepUnlockEngine(DatabaseName);

    }
    //
    // start a timer queue to check to see if there is active tasks/contexts
    // if not, terminate jet engine
    //
    ScepIfTerminateEngine();

    return(ScepSceStatusToDosError(rc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\srvrpcp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    srvrpcp.h

Abstract:

    This module defines private APIs called from the RPC interfaces on server
    site.

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

    jinhuang 26-Jan-1998   splitted for client-server

--*/

#ifndef _srvrpcp_
#define _srvrpcp_

#ifdef __cplusplus
extern "C" {
#endif

typedef SCESTATUS (WINAPI *PFSCEINFWRITEINFO)(LPCTSTR, AREA_INFORMATION, PSCE_PROFILE_INFO, PSCE_ERROR_LOG_INFO *);
typedef SCESTATUS (WINAPI *PFSCEGETINFO)(PVOID, SCETYPE, AREA_INFORMATION, PSCE_PROFILE_INFO *, PSCE_ERROR_LOG_INFO *);
typedef SCESTATUS (WINAPI *PFSCEOPENPROFILE)(PCWSTR, SCE_FORMAT_TYPE, PVOID *);
typedef SCESTATUS (WINAPI *PFSCECLOSEPROFILE)(PVOID *);

#define SCEPOL_SAVE_BUFFER      0x1
#define SCEPOL_SAVE_DB          0x2
#define SCEPOL_SYSTEM_SETTINGS  0x4

//
// svcsrv.cpp
//

SCESTATUS
SceSvcpUpdateInfo(
    IN PSCECONTEXT                  Context,
    IN PCWSTR                       ServiceName,
    IN PSCESVC_CONFIGURATION_INFO   Info
    );

SCESTATUS
SceSvcpQueryInfo(
    IN PSCECONTEXT                  Context,
    IN SCESVC_INFO_TYPE             SceSvcType,
    IN PCWSTR                       ServiceName,
    IN PWSTR                        Prefix OPTIONAL,
    IN BOOL                         bExact,
    OUT PVOID                       *ppvInfo,
    OUT PSCE_ENUMERATION_CONTEXT    psceEnumHandle
    );

SCESTATUS
SceSvcpSetInfo(
    IN PSCECONTEXT  Context,
    IN SCESVC_INFO_TYPE SceSvcType,
    IN PCWSTR           ServiceName,
    IN PWSTR            Prefix OPTIONAL,
    IN BOOL             bExact,
    IN LONG             GpoID,
    IN PVOID            pvInfo OPTIONAL
    );

//
// setupsrv.cpp
//

DWORD
ScepSetupUpdateObject(
    IN PSCECONTEXT Context,
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN UINT nFlag,
    IN PWSTR SDText
    );

DWORD
ScepSetupMoveFile(
    IN PSCECONTEXT Context,
    PWSTR OldName,
    PWSTR NewName OPTIONAL,
    PWSTR SDText OPTIONAL
    );

//
// pfget.cpp
//
SCESTATUS
ScepGetDatabaseInfo(
    IN  PSCECONTEXT     Context,
    IN  SCETYPE             ProfileType,
    IN  AREA_INFORMATION    Area,
    IN  DWORD               dwAccountFormat,
    OUT PSCE_PROFILE_INFO   *ppInfoBuffer,
    IN  OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetObjectChildren(
    IN PSCECONTEXT Context,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectPrefix,
    IN SCE_SUBOBJECT_TYPE Option,
    OUT PVOID *Buffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetObjectSecurity(
    IN PSCECONTEXT Context,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    OUT PSCE_OBJECT_SECURITY *ObjSecurity
    );

//
// ScepCopyObjects is called for each area
// within the RPC interface SceRpcCopyObjects
// for system service or security policy area
// attchments needs to be considered
//

SCESTATUS
ScepGetAnalysisSummary(
    IN PSCECONTEXT Context,
    IN AREA_INFORMATION Area,
    OUT PDWORD pCount
    );

//
// server.cpp
//

SCESTATUS
ScepOpenDatabase(
    IN PCWSTR DatabaseName,
    IN DWORD OpenOption,
    IN SCEJET_OPEN_TYPE OpenType,
    OUT PSCECONTEXT *pContext
    );

SCESTATUS
ScepCloseDatabase(
    IN PSCECONTEXT Context
    );

//
// SceJetGetDescription, SceJetGetTimeStamp
// SceJetStartTransaction, SceJetCommitTransaction, SceJetRollback,
// RtlGetNtProductType (for SceRpcGetServerProductType)
// are called within the RPC interfaces directly
//

//
// config.c
//

SCESTATUS
ScepConfigureSystem(
    IN PCWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName,
    IN DWORD ConfigOptions,
    IN BOOL bAdminLogon,
    IN AREA_INFORMATION Area,
    OUT PDWORD pdWarning OPTIONAL
    );

//
// analyze.c
//

SCESTATUS
ScepAnalyzeSystem(
    IN PCWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName,
    IN DWORD AnalyzeOptions,
    IN BOOL bAdminLogon,
    IN AREA_INFORMATION Area,
    IN PDWORD pdWarning OPTIONAL,
    IN PWSTR InfRollback OPTIONAL
    );

SCESTATUS
ScepAnalyzeSystemAccess(
    IN PSCE_PROFILE_INFO pSmpInfo,
    IN PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN DWORD dwSaveOption,
    OUT BOOL *pbChanged,
    IN OUT PSCE_ERROR_LOG_INFO *pErrLog
    );

//
// editsave.c
//

SCESTATUS
ScepUpdateDatabaseInfo(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PSCE_PROFILE_INFO pInfo
    );

SCESTATUS
ScepUpdateLocalTable(
    IN PSCECONTEXT       hProfile,
    IN AREA_INFORMATION  Area,
    IN PSCE_PROFILE_INFO pInfo,
    IN DWORD             dwMode
    );

SCESTATUS
ScepUpdateObjectInfo(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN BYTE ConfigStatus,
    IN BOOL  IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    );

//
// polsrv.cpp
//
DWORD
ScepNotifyGetChangedPolicies(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL,
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    OUT BOOL *pbChanged
    );

DWORD
ScepNotifySaveChangedPolicies(
    IN PSCECONTEXT hProfile,
    IN SECURITY_DB_TYPE DbType,
    IN AREA_INFORMATION Area,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pMergedInfo OPTIONAL
    );

#define SCEGPO_INSETUP_NT4          1
#define SCEGPO_INSETUP_NT5          2
#define SCEGPO_NOCHECK_EXISTENCE    3

DWORD
ScepNotifyGetDefaultGPOTemplateName(
    IN UNICODE_STRING DnsDomainName,
    IN PWSTR ComputerName OPTIONAL,
    IN BOOL bDomainPolicy,
    IN DWORD dwInSetup,
    OUT LPTSTR *pTemplateName
    );

DWORD
ScepNotifySaveNotifications(
    IN PWSTR TemplateName,
    IN SECURITY_DB_TYPE  DbType,
    IN SECURITY_DB_OBJECT_TYPE  ObjectType,
    IN SECURITY_DB_DELTA_TYPE  DeltaType,
    IN PSID ObjectSid OPTIONAL
    );

DWORD
ScepNotifyUpdateGPOVersion(
    IN PWSTR GpoTemplateName,
    IN BOOL bDomainPolicy
    );

//
// analyze.cpp
//
SCESTATUS
ScepGetSystemSecurity(
    IN AREA_INFORMATION Area,
    IN DWORD Options,
    OUT PSCE_PROFILE_INFO *ppInfo,
    OUT PSCE_ERROR_LOG_INFO *pErrLog
    );

//
// config.cpp
//
SCESTATUS
ScepSetSystemSecurity(
    IN AREA_INFORMATION Area,
    IN DWORD ConfigOptions,
    IN PSCE_PROFILE_INFO pInfo,
    OUT PSCE_ERROR_LOG_INFO *pErrLog
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\setupsrv.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    setupsrv.cpp

Abstract:

    Routines for secedit integration with system setup and component setup

Author:

    Jin Huang (jinhuang) 15-Aug-1997

Revision History:

    jinhuang 26-Jan-1998  splitted to client-server

--*/

#include "headers.h"
#include "serverp.h"
#include "srvrpcp.h"
#include "pfp.h"
#include <io.h>


SCESTATUS
ScepUpdateObjectInSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR ObjectName,
    IN SE_OBJECT_TYPE ObjectType,
    IN UINT nFlag,
    IN PWSTR SDText,
    OUT UINT *pStatus
    );

//
// implementations
//


DWORD
ScepSetupUpdateObject(
    IN PSCECONTEXT Context,
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN UINT nFlag,
    IN PWSTR SDText
    )
/*
Routine Description:

    This routine is the private API called from the RPC interface to
    update object information in the database.

Arguments:

    Context     - the database context handle

    ObjectFullName  - the object's name

    Objecttype      - the object type

    nFlag       - the flag on how to update this object

    SDText      - the security descriptor in SDDL text


Return Value:

*/
{

    if ( !ObjectFullName || NULL == SDText ) {
        return ERROR_INVALID_PARAMETER;
    }

    switch ( ObjectType ) {
    case SE_SERVICE:
    case SE_REGISTRY_KEY:
    case SE_FILE_OBJECT:
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    SCESTATUS rc;

    DWORD dwInSetup=0;

    ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                TEXT("System\\Setup"),
                TEXT("SystemSetupInProgress"),
                &dwInSetup
                );

    //
    // convert SDText to security descriptor
    //
    PSECURITY_DESCRIPTOR pSD=NULL;
    DWORD SDSize;
    SECURITY_INFORMATION SeInfo=0;
    HANDLE  Token=NULL;

    DWORD Win32rc=ERROR_SUCCESS;

    if ( !(nFlag & SCESETUP_UPDATE_DB_ONLY) ) {
        //
        // security will be set, so compute the security descriptor
        //
        Win32rc = ConvertTextSecurityDescriptor (
                        SDText,
                        &pSD,
                        &SDSize,
                        &SeInfo
                        );

        if ( NO_ERROR == Win32rc ) {

            ScepChangeAclRevision(pSD, ACL_REVISION);

            //
            // get current thread/process's token
            //
            if (!OpenThreadToken( GetCurrentThread(),
                                   TOKEN_QUERY,
                                   TRUE,
                                   &Token)) {

                if(ERROR_NO_TOKEN == GetLastError()){

                    if(!OpenProcessToken( GetCurrentProcess(),
                                          TOKEN_QUERY,
                                          &Token )){

                        Win32rc = GetLastError();

                    }

                } else {

                    Win32rc = GetLastError();

                }

            }

            if ( Token && (SeInfo & SACL_SECURITY_INFORMATION) ) {

                SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, TRUE, Token );
            }
        }
    }

    if ( NO_ERROR == Win32rc ) {

        //
        // only update DB if it's in setup
        //

        //
        // on 64-bit platform, only update database if setup does not indicate SCE_SETUP_32KEY flag
        //

#ifdef _WIN64
        if ( dwInSetup && !(nFlag & SCE_SETUP_32KEY) ) {
#else
        if ( dwInSetup ) {
#endif

            // save this into SCP and SMP, do not overwrite the status/container flag
            // if there is one exist, else use SCE_STATUS_CHECK and check for container
            //
            //
            // start a transaction since there are multiple operations
            //

            rc = SceJetStartTransaction( Context );

            if ( rc == SCESTATUS_SUCCESS ) {

                UINT Status=SCE_STATUS_CHECK;

                rc = ScepUpdateObjectInSection(
                            Context,
                            SCE_ENGINE_SMP,
                            ObjectFullName,
                            ObjectType,
                            nFlag,
                            SDText,
                            &Status
                            );

                if ( rc == SCESTATUS_SUCCESS &&
                     (Context->JetSapID != JET_tableidNil) ) {
                    //
                    // the SAP table ID points to the tattoo table
                    // should update the tattoo table too if it exist
                    //
                    rc = ScepUpdateObjectInSection(
                                Context,
                                SCE_ENGINE_SAP,
                                ObjectFullName,
                                ObjectType,
                                nFlag,
                                SDText,
                                NULL
                                );

                }
            }

        } else {
            rc = SCESTATUS_SUCCESS;
        }

        if ( rc == SCESTATUS_SUCCESS &&
             !(nFlag & SCESETUP_UPDATE_DB_ONLY) ) {

            //
            // set security to the object
            //

            //
            // if 64-bit platform, no synchronization is done and setup will have
            // to call the exported API with SCE_SETUP_32KEY if 32-bit hive is desired
            //

#ifdef _WIN64
            if ( ObjectType == SE_REGISTRY_KEY && (nFlag & SCE_SETUP_32KEY) ){
                ObjectType = SE_REGISTRY_WOW64_32KEY;
            }
#endif

            Win32rc = ScepSetSecurityWin32(
                ObjectFullName,
                SeInfo,
                pSD,
                ObjectType
                );

        } else
            Win32rc = ScepSceStatusToDosError(rc);

        if ( Win32rc == ERROR_SUCCESS ||
             Win32rc == ERROR_FILE_NOT_FOUND ||
             Win32rc == ERROR_PATH_NOT_FOUND ||
             Win32rc == ERROR_INVALID_OWNER ||
             Win32rc == ERROR_INVALID_PRIMARY_GROUP ||
             Win32rc == ERROR_INVALID_HANDLE ) {

            if ( Win32rc )
                gWarningCode = Win32rc;

            if ( dwInSetup ) {  // in setup, update DB
                Win32rc = ScepSceStatusToDosError(
                           SceJetCommitTransaction( Context, 0));
            } else {
                Win32rc = ERROR_SUCCESS;
            }

        } else if ( dwInSetup ) {  // in setup

            SceJetRollback( Context, 0 );
        }

        if ( Token && (SeInfo & SACL_SECURITY_INFORMATION) )
            SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, FALSE, Token );

    }

    CloseHandle(Token);

    if ( pSD ) {
        LocalFree(pSD);
        pSD = NULL;
    }

    return(Win32rc);

}


SCESTATUS
ScepUpdateObjectInSection(
    IN PSCECONTEXT Context,
    IN SCETYPE ProfileType,
    IN PWSTR ObjectName,
    IN SE_OBJECT_TYPE ObjectType,
    IN UINT nFlag,
    IN PWSTR SDText,
    OUT UINT *pStatus
    )
/*
Routine Description:

    Update SCP and SMP. if the table does not exist at all, ignore the update.
    Delete SAP entry for the object. If table or record not found, ignore the error.

Arguments:

Return Value:

*/
{
    if ( Context == NULL || ObjectName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;
    PSCESECTION hSection=NULL;
    PCWSTR SectionName;

    switch ( ObjectType ) {
    case SE_FILE_OBJECT:
        SectionName = szFileSecurity;
        break;
    case SE_REGISTRY_KEY:
        SectionName = szRegistryKeys;
        break;
    case SE_SERVICE:
        SectionName = szServiceGeneral;
        break;
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = ScepOpenSectionForName(
                Context,
                ProfileType,
                SectionName,
                &hSection
                );
    if ( rc == SCESTATUS_BAD_FORMAT ||
         rc == SCESTATUS_RECORD_NOT_FOUND ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        WCHAR         StatusFlag=L'\0';
        DWORD         ValueLen;
        BYTE          Status=SCE_STATUS_CHECK;
        BOOL          IsContainer=TRUE;
        BYTE          StartType;

        rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                ObjectName,
                NULL,
                0,
                NULL,
                (PWSTR)&StatusFlag,
                2,
                &ValueLen
                );

        if ( rc == SCESTATUS_SUCCESS ||
             rc == SCESTATUS_BUFFER_TOO_SMALL ) {

            rc = SCESTATUS_SUCCESS;

            Status = *((BYTE *)&StatusFlag);

            if ( pStatus ) {
                *pStatus = Status;
            }

            if ( ObjectType == SE_SERVICE ) {
                StartType = *((BYTE *)&StatusFlag+1);
            } else {
                IsContainer = *((CHAR *)&StatusFlag+1) != '0' ? TRUE : FALSE;
            }
        }

        if ( ObjectType == SE_SERVICE ) {

            DWORD SDLen, Len;
            PWSTR ValueToSet;

            StartType = (BYTE)nFlag;

            if ( SDText != NULL ) {
                SDLen = wcslen(SDText);
                Len = ( SDLen+1)*sizeof(WCHAR);
            } else
                Len = sizeof(WCHAR);

            ValueToSet = (PWSTR)ScepAlloc( (UINT)0, Len+sizeof(WCHAR) );

            if ( ValueToSet != NULL ) {

                //
                // The first byte is the flag, the second byte is IsContainer (1,0)
                //
                *((BYTE *)ValueToSet) = Status;

                *((BYTE *)ValueToSet+1) = StartType;

                if ( SDText != NULL ) {
                    wcscpy(ValueToSet+1, SDText );
                    ValueToSet[SDLen+1] = L'\0';  //terminate this string
                } else {
                    ValueToSet[1] = L'\0';
                }

                if ( SCESTATUS_SUCCESS == rc || ProfileType != SCE_ENGINE_SAP ) {
                    //
                    // only update tattoo table (pointed by SAP handle) if it finds a record there
                    // for other table (SMP), ignore the error code, just set
                    //
                    rc = SceJetSetLine( hSection,
                                        ObjectName,
                                        FALSE,
                                        ValueToSet,
                                        Len,
                                        0);
                }

                ScepFree( ValueToSet );

            } else {

                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

        } else if ( SCESTATUS_SUCCESS == rc || ProfileType != SCE_ENGINE_SAP ) {
            //
            // only update tattoo table (pointed by SAP handle) if it finds a record there
            // for other table (SMP), ignore the error code, just set
            //

            rc = ScepSaveObjectString(
                    hSection,
                    ObjectName,
                    IsContainer,
                    Status,
                    SDText,
                    (SDText == NULL ) ? 0 : wcslen(SDText)
                    );
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
            rc = SCESTATUS_SUCCESS;

        SceJetCloseSection(&hSection, TRUE);
    }

    return(rc);
}


DWORD
ScepSetupMoveFile(
    IN PSCECONTEXT Context,
    PWSTR OldName,
    PWSTR NewName OPTIONAL,
    PWSTR SDText OPTIONAL
    )
/*
Routine Description:

    Set security to OldName but save with NewName in SCE database if SDText
    is not NULL. If NewName is NULL, delete OldName from SCE database.

Arguments:

    Context     - the databaes context handle

    SectionName - the section name

    OldName     - the object's old name

    NewName     - the new name to rename to, if NULL, delete the old object

    SDText      - security string

Return Value:

    Win32 error code
*/
{

    if ( !Context || !OldName ) {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD rc32=ERROR_SUCCESS;

    if ( NewName && SDText  ) {
        //
        // set security on OldName with SDText
        //

        rc32 = ScepSetupUpdateObject(
                        Context,
                        OldName,
                        SE_FILE_OBJECT,
                        0,
                        SDText
                        );
    }

    if ( rc32 == ERROR_SUCCESS ) {

        //
        // save this into SCP and SMP, do not overwrite the status/container flag
        // if there is one exist, else use SCE_STATUS_CHECK and check for container
        //

        SCESTATUS rc = SceJetStartTransaction( Context );

        if ( rc == SCESTATUS_SUCCESS ) {

            PSCESECTION hSection=NULL;
            //
            // process SMP section first
            //
            rc = ScepOpenSectionForName(
                        Context,
                        SCE_ENGINE_SMP,
                        szFileSecurity,
                        &hSection
                        );

            if ( rc == SCESTATUS_SUCCESS ) {
                if ( NewName ) {
                    //
                    // rename this line
                    //
                    rc = SceJetRenameLine(
                            hSection,
                            OldName,
                            NewName,
                            FALSE);

                } else {
                    //
                    // delete this line first
                    //
                    rc = SceJetDelete(
                        hSection,
                        OldName,
                        FALSE,
                        SCEJET_DELETE_LINE_NO_CASE
                        );
                }
                SceJetCloseSection( &hSection, TRUE);
            }


            if ( (SCESTATUS_SUCCESS == rc ||
                  SCESTATUS_RECORD_NOT_FOUND == rc ||
                  SCESTATUS_BAD_FORMAT == rc) &&
                 (Context->JetSapID != JET_tableidNil) ) {
                //
                // process tattoo table
                //
                rc = ScepOpenSectionForName(
                            Context,
                            SCE_ENGINE_SAP,
                            szFileSecurity,
                            &hSection
                            );

                if ( rc == SCESTATUS_SUCCESS ) {
                    if ( NewName ) {
                        //
                        // rename this line
                        //
                        rc = SceJetRenameLine(
                                hSection,
                                OldName,
                                NewName,
                                FALSE);

                    } else {
                        //
                        // delete this line first
                        //
                        rc = SceJetDelete(
                            hSection,
                            OldName,
                            FALSE,
                            SCEJET_DELETE_LINE_NO_CASE
                            );
                    }

                    SceJetCloseSection( &hSection, TRUE);
                }

            }
            if ( SCESTATUS_RECORD_NOT_FOUND == rc ||
                 SCESTATUS_BAD_FORMAT == rc ) {
                rc = SCESTATUS_SUCCESS;
            }

            if ( SCESTATUS_SUCCESS == rc ) {
                //
                // commit the transaction
                //
                rc = SceJetCommitTransaction( Context, 0 );
            } else {
                //
                // rollback the transaction
                //
                SceJetRollback( Context, 0 );
            }
        }

        rc32 = ScepSceStatusToDosError(rc);
    }

    return(rc32);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\srvutil.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    srvutil.cpp

Abstract:

    Server Service attachment APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997

Revision History:

    jinhuang    23-Jan-1998     splitted to client-server
--*/
#include "serverp.h"
#include "srvutil.h"
#include "infp.h"
#include "pfp.h"

#include <io.h>
#pragma hdrstop

DWORD Thread     gMaxRegTicks=0;
DWORD Thread     gMaxFileTicks=0;
DWORD Thread     gMaxDsTicks=0;
WCHAR Thread     theAcctDomName[MAX_PATH+1];
WCHAR Thread     ComputerName[MAX_COMPUTERNAME_LENGTH+1];
CHAR Thread      sidAuthBuf[32];
CHAR Thread      sidBuiltinBuf[32];
DWORD Thread     t_pebSize=0;
LPVOID Thread    t_pebClient=NULL;

SCESTATUS
ScepQueryInfTicks(
    IN PWSTR TemplateName,
    IN AREA_INFORMATION Area,
    OUT PDWORD pTotalTicks
    );

SCESTATUS
ScepGetObjectCount(
    IN PSCECONTEXT Context,
    IN PCWSTR SectionName,
    IN BOOL bPolicyProp,
    OUT PDWORD pTotalTicks
    );


LPTSTR
ScepSearchClientEnv(
    IN LPTSTR varName,
    IN DWORD dwSize
    );

//
// implementations
//


SCESTATUS
ScepGetTotalTicks(
    IN PCWSTR TemplateName,
    IN PSCECONTEXT Context,
    IN AREA_INFORMATION Area,
    IN SCEFLAGTYPE nFlag,
    OUT PDWORD pTotalTicks
    )
/*
Routine Description:

    Retrieve the total count of objects from the inf template and/or the
    database for the area specified.

Arguments:

    TemplateName - the INF template Name

    Context      - the database context

    Area         - the security area

    nFlag - the flag to indicate operation which determines where the count is
            retrieved:

                SCE_FLAG_CONFIG
                SCE_FLAG_CONFIG_APPEND
                SCE_FLAG_ANALYZE
                SCE_FLAG_ANALYZE_APPEND

    pTotalTicks - the output count

Return Value:

    SCE Status
*/
{
    if ( pTotalTicks == NULL ||
        ( NULL == TemplateName && NULL == Context) ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;
    DWORD nTicks=0;

    *pTotalTicks = 0;
    gMaxRegTicks=0;
    gMaxFileTicks=0;
    gMaxDsTicks=0;

    if ( Area & (AREA_FILE_SECURITY |
                 AREA_REGISTRY_SECURITY) ) { // |
//                 AREA_DS_OBJECTS) ) {

        switch ( nFlag ) {
        case SCE_FLAG_CONFIG:
        case SCE_FLAG_CONFIG_APPEND:
        case SCE_FLAG_CONFIG_SCP:
        case SCE_FLAG_CONFIG_SCP_APPEND:

            if ( TemplateName != NULL ) {

                //
                // use the template if there is any
                //
                rc = ScepQueryInfTicks(
                            (LPTSTR)TemplateName,
                            Area & (AREA_FILE_SECURITY |
                                    AREA_REGISTRY_SECURITY), // |
//                                    AREA_DS_OBJECTS),
                            pTotalTicks
                            );
            }
            if ( Context != NULL &&
                 (nFlag == SCE_FLAG_CONFIG_APPEND ||
                  nFlag == SCE_FLAG_CONFIG_SCP_APPEND ||
                  TemplateName == NULL) ) {

                //
                // use the existing database
                //

                if ( Area & AREA_REGISTRY_SECURITY ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                            szRegistryKeys,
                                            (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                            &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxRegTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
                if ( rc == SCESTATUS_SUCCESS && (Area & AREA_FILE_SECURITY) ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                             szFileSecurity,
                                             (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                             &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxFileTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
#if 0
                if ( rc == SCESTATUS_SUCCESS && (Area & AREA_DS_OBJECTS) ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                        szDSSecurity,
                                        (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                        &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxDsTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
#endif

            }

            break;
        case SCE_FLAG_ANALYZE:
        case SCE_FLAG_ANALYZE_APPEND:

            if ( Context != NULL ) {
                //
                // use the existing database
                //
                if ( Area & AREA_REGISTRY_SECURITY ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                             szRegistryKeys,
                                             (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                             &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxRegTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
                if ( rc == SCESTATUS_SUCCESS &&
                     Area & AREA_FILE_SECURITY ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                             szFileSecurity,
                                             (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                             &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxFileTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
#if 0
                if ( rc == SCESTATUS_SUCCESS &&
                    Area & AREA_DS_OBJECTS ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                        szDSSecurity,
                                        (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                        &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxDsTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
#endif
            }

            if ( rc == SCESTATUS_SUCCESS && TemplateName != NULL &&
                 (nFlag == SCE_FLAG_ANALYZE_APPEND || Context == NULL) ) {

                //
                // get handle in template
                //

                DWORD nTempTicks=0;

                rc = ScepQueryInfTicks(
                            (LPTSTR)TemplateName,
                            Area & (AREA_FILE_SECURITY |
                                    AREA_REGISTRY_SECURITY), // |
//                                    AREA_DS_OBJECTS),
                            &nTempTicks
                            );
                if ( rc == SCESTATUS_SUCCESS ) {
                    *pTotalTicks += nTempTicks;
                }
            }

            break;
        default:
            return SCESTATUS_INVALID_PARAMETER;
        }
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( Area & AREA_SECURITY_POLICY )
            *pTotalTicks += TICKS_SECURITY_POLICY_DS + TICKS_SPECIFIC_POLICIES;

        if ( Area & AREA_GROUP_MEMBERSHIP )
            *pTotalTicks += TICKS_GROUPS;

        if ( Area & AREA_PRIVILEGES )
            *pTotalTicks += TICKS_PRIVILEGE;

        if ( Area & AREA_SYSTEM_SERVICE )
            *pTotalTicks += TICKS_GENERAL_SERVICES + TICKS_SPECIFIC_SERVICES;
/*
        if ( *pTotalTicks ) {
            *pTotalTicks += 10;  // for jet engine initialization
        }
*/
    }

    return(rc);

}


SCESTATUS
ScepQueryInfTicks(
    IN PWSTR TemplateName,
    IN AREA_INFORMATION Area,
    OUT PDWORD pTotalTicks
    )
/*
Routine Description:

    Query total number of objects in the inf template for the specified area.

Arguments:

Return:

*/
{
    LONG Count=0;
    HINF InfHandle;

    SCESTATUS rc = SceInfpOpenProfile(
                        TemplateName,
                        &InfHandle
                        );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( Area & AREA_REGISTRY_SECURITY ) {

            Count = SetupGetLineCount(InfHandle, szRegistryKeys);
            gMaxRegTicks += Count;

        }
        if ( Area & AREA_FILE_SECURITY ) {

            Count += SetupGetLineCount(InfHandle, szFileSecurity);
            gMaxFileTicks += Count;
        }
#if 0
        if ( Area & AREA_DS_OBJECTS ) {

            Count += SetupGetLineCount(InfHandle, szDSSecurity);
            gMaxDsTicks += Count;
        }
#endif
        SceInfpCloseProfile(InfHandle);
    }

    *pTotalTicks = Count;

    return(rc);
}



SCESTATUS
ScepGetObjectCount(
    IN PSCECONTEXT Context,
    IN PCWSTR SectionName,
    IN BOOL bPolicyProp,
    OUT PDWORD pTotalTicks
    )
{
    if ( Context == NULL || SectionName == NULL ||
         pTotalTicks == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    PSCESECTION hSection=NULL;
    SCESTATUS rc;
    DWORD count=0;

    rc = ScepOpenSectionForName(
                Context,
                bPolicyProp ? SCE_ENGINE_SCP : SCE_ENGINE_SMP,
                SectionName,
                &hSection
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = SceJetGetLineCount(
                    hSection,
                    NULL,
                    FALSE,
                    &count
                    );

        if ( rc == SCESTATUS_SUCCESS )
            *pTotalTicks += count;

        SceJetCloseSection( &hSection, TRUE);
    }

    if ( SCESTATUS_RECORD_NOT_FOUND == rc)
        rc = SCESTATUS_SUCCESS;

    return(rc);
}


BOOL
ScepIsEngineRecovering()
{
   TCHAR TempFileName[MAX_PATH];
   PWSTR SysRoot=NULL;
   DWORD SysLen;
   DWORD rc;
   BOOL bFindIt=FALSE;

   SysLen =  0;
   rc = ScepGetNTDirectory( &SysRoot, &SysLen, SCE_FLAG_WINDOWS_DIR );

   if ( rc == NO_ERROR && SysRoot != NULL ) {

       swprintf(TempFileName, L"%s\\Security\\tmp.edb", SysRoot);
       TempFileName[MAX_PATH-1] = L'\0';

       if ( 0xFFFFFFFF != GetFileAttributes(TempFileName) ) {

           bFindIt = TRUE;
       }

       ScepFree(SysRoot);

   }

   return bFindIt;

}



SCESTATUS
ScepSaveAndOffAuditing(
    OUT PPOLICY_AUDIT_EVENTS_INFO *ppAuditEvent,
    IN BOOL bTurnOffAuditing,
    IN LSA_HANDLE PolicyHandle OPTIONAL
    )
{
    LSA_HANDLE      lsaHandle=NULL;
    NTSTATUS        status;
    SCESTATUS        rc;
    POLICY_AUDIT_EVENT_OPTIONS  lSaveAudit;

    //
    // open Lsa policy for read/write
    //

    if ( PolicyHandle == NULL ) {

        ACCESS_MASK  access=0;

        if ( bTurnOffAuditing ) {
            access = POLICY_SET_AUDIT_REQUIREMENTS | POLICY_AUDIT_LOG_ADMIN;
        }

        status = ScepOpenLsaPolicy(
                        POLICY_VIEW_AUDIT_INFORMATION | access,
                        &lsaHandle,
                        TRUE
                        );

        if (status != ERROR_SUCCESS) {

            lsaHandle = NULL;
            rc = RtlNtStatusToDosError( status );
            ScepLogOutput3( 1, rc, SCEDLL_LSA_POLICY);

            return(ScepDosErrorToSceStatus(rc));
        }

    } else {

        lsaHandle = PolicyHandle;
    }
    //
    // Query audit event information
    //

    status = LsaQueryInformationPolicy( lsaHandle,
                                      PolicyAuditEventsInformation,
                                      (PVOID *)ppAuditEvent
                                    );
    rc = RtlNtStatusToDosError( status );

    if ( NT_SUCCESS( status ) && bTurnOffAuditing && (*ppAuditEvent)->AuditingMode ) {

        //
        // turn off object access auditing
        //
        if ( AuditCategoryObjectAccess < (*ppAuditEvent)->MaximumAuditEventCount ) {
            lSaveAudit = (*ppAuditEvent)->EventAuditingOptions[AuditCategoryObjectAccess];
            (*ppAuditEvent)->EventAuditingOptions[AuditCategoryObjectAccess] = POLICY_AUDIT_EVENT_NONE;

            status = LsaSetInformationPolicy( lsaHandle,
                                              PolicyAuditEventsInformation,
                                              (PVOID)(*ppAuditEvent)
                                            );

            //
            // restore the object access auditing mode
            //

            (*ppAuditEvent)->EventAuditingOptions[AuditCategoryObjectAccess] = lSaveAudit;

        }

        rc = RtlNtStatusToDosError( status );


        if ( rc == NO_ERROR )
            ScepLogOutput3( 2, 0, SCEDLL_EVENT_IS_OFF);
        else
            ScepLogOutput3( 1, rc, SCEDLL_SCP_ERROR_EVENT_AUDITING);

    } else if ( rc != NO_ERROR)
        ScepLogOutput3( 1, rc, SCEDLL_ERROR_QUERY_EVENT_AUDITING);

    //
    // free LSA handle if it's opened in this function
    //
    if ( lsaHandle && (PolicyHandle == NULL) )
        LsaClose( lsaHandle );

    return(ScepDosErrorToSceStatus(rc));
}


NTSTATUS
ScepGetAccountExplicitRight(
    IN LSA_HANDLE PolicyHandle,
    IN PSID       AccountSid,
    OUT PDWORD    PrivilegeLowRights,
    OUT PDWORD    PrivilegeHighRights
    )
/* ++
Routine Description:

    This routine queries the explicitly assigned privilege/rights to a account
    (referenced by AccountSid) and stores in a DWORD type variable PrivilegeRights,
    in which each bit represents a privilege/right.

Arguments:

    PolicyHandle    - Lsa Policy Domain handle

    AccountSid      - The SID for the account

    PrivilegeRights - Privilege/Rights of this account

Return value:

    NTSTATUS
-- */
{
    NTSTATUS            NtStatus;

    DWORD               CurrentPrivLowRights=0, CurrentPrivHighRights=0;
    LONG                index;
    PUNICODE_STRING     UserRightEnum=NULL;
    ULONG               i, cnt=0;
    LUID                LuidValue;

    //
    // Enumerate user privilege/rights
    //

    NtStatus = LsaEnumerateAccountRights(
                    PolicyHandle,
                    AccountSid,
                    &UserRightEnum,
                    &cnt
                    );
    if ( NtStatus == STATUS_NO_SUCH_PRIVILEGE ||
        NtStatus == STATUS_OBJECT_NAME_NOT_FOUND ) {

        NtStatus = ERROR_SUCCESS;
        goto Done;
    }

    if ( !NT_SUCCESS( NtStatus) ) {
        ScepLogOutput3(1,
                       RtlNtStatusToDosError(NtStatus),
                       SCEDLL_SAP_ERROR_ENUMERATE,
                       L"LsaEnumerateAccountRights");
        goto Done;
    }

    if (UserRightEnum != NULL)

        for ( i=0; i < cnt; i++) {
            if ( UserRightEnum[i].Length == 0 )
                continue;

            NtStatus = LsaLookupPrivilegeValue(
                            PolicyHandle,
                            &UserRightEnum[i],
                            &LuidValue
                            );

            if ( NtStatus == STATUS_NO_SUCH_PRIVILEGE ) {
                index = ScepLookupPrivByName( UserRightEnum[i].Buffer );
                NtStatus = ERROR_SUCCESS;
            } else if ( NT_SUCCESS(NtStatus) ) {
                index = ScepLookupPrivByValue( LuidValue.LowPart );
            } else
                index = -1;

            if ( index == -1 ) {

                //
                // not found
                //

                NtStatus = STATUS_NOT_FOUND;
                ScepLogOutput3(1,
                               RtlNtStatusToDosError(NtStatus),
                               SCEDLL_USERRIGHT_NOT_DEFINED);
                goto Done;

            } else {
                if ( index < 32 ) {
                    CurrentPrivLowRights |= (1 << index);
                } else {
                    CurrentPrivHighRights |= (1 << (index-32) );
                }
            }
        }

Done:

    *PrivilegeLowRights = CurrentPrivLowRights;
    *PrivilegeHighRights = CurrentPrivHighRights;

    if (UserRightEnum != NULL)
        LsaFreeMemory(UserRightEnum);

    return (NtStatus);
}


NTSTATUS
ScepGetMemberListSids(
    IN PSID         DomainSid,
    IN LSA_HANDLE   PolicyHandle,
    IN PSCE_NAME_LIST pMembers,
    OUT PUNICODE_STRING *MemberNames,
    OUT PSID**      Sids,
    OUT PULONG      MemberCount
    )
/*
Routine Description:

    Lookup each account in the name list pMembers and return the lookup information
    in the output buffer - MemberNames, Sids, MemberCount.

    if an account can't be resolved, the corresponding SID will be empty.

*/
{
    NTSTATUS                    NtStatus=STATUS_SUCCESS;
    PSCE_NAME_LIST               pUser;

    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains=NULL;
    PLSA_TRANSLATED_SID2        MemberSids=NULL;
    DWORD                       i;
    PSID                        DomainSidToUse=NULL;
    ULONG                       Cnt=0;

    //
    // build a UNICODE_STRING for the member list to look up
    //
    for (pUser=pMembers;
         pUser != NULL;
         pUser = pUser->Next) {

        if ( pUser->Name == NULL ) {
            continue;
        }
        Cnt++;
    }

    if ( Cnt > 0 ) {

        *MemberNames = (PUNICODE_STRING)RtlAllocateHeap(
                                        RtlProcessHeap(),
                                        0,
                                        Cnt * sizeof (UNICODE_STRING)
                                        );
        
        if ( *MemberNames == NULL )
            return(STATUS_NO_MEMORY);
                
        *Sids = (PSID *)ScepAlloc( LMEM_ZEROINIT, Cnt*sizeof(PSID));
        if ( *Sids == NULL ) {
            NtStatus = STATUS_NO_MEMORY;
            goto Done;
        }
        
        //
        // Lookup each UNICODE_STRING
        //
        
        for (pUser=pMembers, Cnt=0;
             pUser != NULL;
             pUser = pUser->Next) {

            if ( pUser->Name == NULL ) {
                continue;
            }

            RtlInitUnicodeString(&((*MemberNames)[Cnt]), pUser->Name);
            
            NtStatus = ScepLsaLookupNames2(
                                          PolicyHandle,
                                          LSA_LOOKUP_ISOLATED_AS_LOCAL,
                                          pUser->Name,
                                          &ReferencedDomains,
                                          &MemberSids
                                          );

            if ( !NT_SUCCESS(NtStatus) ) {
                ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                               SCEDLL_ERROR_LOOKUP);
                goto Done;
            }
            
            DWORD SidLength=0;
            
            //
            // translate the LSA_TRANSLATED_SID into PSID
            //
            
            if ( MemberSids &&
                 MemberSids[0].Use != SidTypeInvalid &&
                 MemberSids[0].Use != SidTypeUnknown &&
                 MemberSids[0].Sid != NULL ) {

                SidLength = RtlLengthSid(MemberSids[0].Sid);

                if ( ((*Sids)[Cnt] = (PSID) ScepAlloc( (UINT)0, SidLength)) == NULL ) {
                    NtStatus = STATUS_NO_MEMORY;
                } else {

                    //
                    // copy the SID
                    // if failed, memory will be freed at cleanup
                    //

                    NtStatus = RtlCopySid( SidLength, (*Sids)[Cnt], MemberSids[0].Sid );

                }

                if ( !NT_SUCCESS(NtStatus) ) {
                    goto Done;
                }
            }

            if ( ReferencedDomains != NULL ){
                LsaFreeMemory(ReferencedDomains);
                ReferencedDomains = NULL;
            }

            if ( MemberSids != NULL ){
                LsaFreeMemory(MemberSids);
                MemberSids = NULL;
            }
            
            Cnt++;
        }
        
    }
    *MemberCount = Cnt;
Done:

    if (!NT_SUCCESS(NtStatus) ) {
        if ( *Sids != NULL ) {
            for ( i=0; i<Cnt; i++ )
                if ( (*Sids)[i] != NULL )
                    ScepFree( (*Sids)[i] );
            ScepFree( *Sids );
            *Sids = NULL;
        }
        if ( *MemberNames != NULL )
            RtlFreeHeap(RtlProcessHeap(), 0, *MemberNames);
        *MemberNames = NULL;
    }
    if ( ReferencedDomains != NULL )
        LsaFreeMemory(ReferencedDomains);

    if ( MemberSids != NULL )
        LsaFreeMemory(MemberSids);

    return(NtStatus);
}


DWORD
ScepOpenFileObject(
    IN  LPWSTR       pObjectName,
    IN  ACCESS_MASK  AccessMask,
    OUT PHANDLE      Handle
    )
/*++
Routine Description:

    opens the specified file (or directory) object

Arguments:

    pObjectName   - the name of the file object

    AccessMask    - Desired Access

    Handle        - the just opened handle to the object

Return value:

    Win32 errro code
*/
{
    NTSTATUS NtStatus;
    DWORD Status = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES Attributes;
    IO_STATUS_BLOCK Isb;
    UNICODE_STRING FileName;
    PVOID FreeBuffer;

    //
    // cut and paste code from windows\base\advapi\security.c SetFileSecurityW
    //
    if (RtlDosPathNameToNtPathName_U(
                            pObjectName,
                            &FileName,
                            NULL,
                            NULL
                            ))
    {
        FreeBuffer = FileName.Buffer;

        InitializeObjectAttributes(
            &Attributes,
            &FileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );


        NtStatus = NtOpenFile( Handle,
                               AccessMask,
                               &Attributes,
                               &Isb,
                               FILE_SHARE_READ |
                               FILE_SHARE_WRITE |
                               FILE_SHARE_DELETE,
                               FILE_OPEN_REPARSE_POINT); // bug 635098: set permissions on junction point,
                                                         // not on target directory
        if (!NT_SUCCESS(NtStatus))
        {
            Status = RtlNtStatusToDosError(NtStatus);
        }

        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    } else
    {
        Status = ERROR_INVALID_NAME;
    }

    return(Status);
}


DWORD
ScepOpenRegistryObject(
    IN  SE_OBJECT_TYPE  ObjectType,
    IN  LPWSTR       pObjectName,
    IN  ACCESS_MASK  AccessMask,
    OUT PHKEY        Handle
    )
/*++
Routine Description:

    opens the specified registry key object

Arguments:

    pObjectName  - the name of the object

    AccessMask   - Desired access

    Handle      - the just opened handle to the object

Return value:

    Win32 error code

Note:
    The code is cut/pasted from windows\base\accctrl\src\registry.cxx and modified
--*/
{
    DWORD status=NO_ERROR;
    HKEY basekey;
    LPWSTR usename, basekeyname, keyname;

    if (pObjectName) {

        //
        // save a copy of the name since we must crack it.
        //
        if (NULL != (usename = (LPWSTR)ScepAlloc( LMEM_ZEROINIT,
                               (wcslen(pObjectName) + 1) * sizeof(WCHAR)))) {

            wcscpy(usename,pObjectName);

            basekeyname = usename;
            keyname = wcschr(usename, L'\\');
            if (keyname != NULL) {
                *keyname = L'\0';
                keyname++;
            }

            if (0 == _wcsicmp(basekeyname, L"MACHINE")) {
                basekey = HKEY_LOCAL_MACHINE;
            } else if (0 == _wcsicmp(basekeyname, L"USERS")) {
                basekey = HKEY_USERS;
            } else if ( 0 == _wcsicmp(basekeyname, L"CLASSES_ROOT")) {
                basekey = HKEY_CLASSES_ROOT;
            } else {
                status = ERROR_INVALID_PARAMETER;
            }

            if (NO_ERROR == status) {
                if ( keyname == NULL ) {
                    *Handle = basekey;
                } else {
                    //
                    // open the key
                    //

#ifdef _WIN64
                    if (ObjectType == SE_REGISTRY_WOW64_32KEY) {
                        AccessMask |= KEY_WOW64_32KEY;
                    }
#endif

                    status = RegOpenKeyEx(
                                  basekey,
                                  keyname,
                                  0 ,
                                  AccessMask,
                                  Handle
                                  );
                }
            }
            ScepFree(usename);
        } else {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        status = ERROR_INVALID_NAME;
    }

    return(status);
}



SCESTATUS
ScepGetNameInLevel(
    IN PCWSTR ObjectFullName,
    IN DWORD  Level,
    IN WCHAR  Delim,
    OUT PWSTR Buffer,
    OUT PBOOL LastOne
    )
/* ++
Routine Description:

    This routine parses a full path name and returns the component for the
    level. For example, a object name "c:\winnt\system32" will return c: for
    level 1, winnt for level 2, and system32 for level 3. This routine is
    used when add a object to the security tree.

Arguments:

    ObjectFullName - The full path name of the object

    Level - the level of component to return

    Delim - the deliminator to look for

    Buffer - The address of buffer for the component name

    LastOne - Flag to indicate if the component is the last one

Return value:

    SCESTATUS

-- */
{
    PWSTR  pTemp, pStart;
    DWORD i;

    if ( ObjectFullName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // loop through the object name to find the level
    // if there is no such level, return INVALID_PARAMETER
    //
    pStart = (PWSTR)ObjectFullName;
    for ( i=0; i<Level; i++) {

        pTemp = wcschr(pStart, Delim);

        if ( pTemp == pStart ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }

        if ( i == Level-1 ) {
            //
            // find the right level
            //
            if ( pTemp == NULL ) {
                wcscpy(Buffer, pStart);
                *LastOne = TRUE;
            } else {
                wcsncpy(Buffer, pStart, (size_t)(pTemp - pStart));
                if ( *(pTemp+1) == L'\0' )
                    *LastOne = TRUE;
                else
                    *LastOne = FALSE;
            }
        } else {
            if ( pTemp == NULL )
                return(SCESTATUS_INVALID_PARAMETER);
            else
                pStart = pTemp + 1;
        }
    }

    return(SCESTATUS_SUCCESS);

}

SCESTATUS
ScepTranslateFileDirName(
   IN  PWSTR oldFileName,
   OUT PWSTR *newFileName
   )
/* ++
Routine Description:

   This routine converts a generic file/directory name to a real used name
   for the current system. The following generic file/directory names are handled:
         %systemroot%   - Windows NT root directory (e.g., c:\winnt)
         %systemDirectory% - Windows NT system32 directory (e.g., c:\winnt\system32)

Arguments:

   oldFileName - the file name to convert, which includes "%" to represent
                 some directory names

   newFileName - the real file name, in which the "%" name is replaced with
                 the real directory name

Return values:

   Win32 error code

-- */
{
    PWSTR   pTemp=NULL, pStart, TmpBuf, szVar;
    DWORD   rc=NO_ERROR;
    DWORD   newFileSize, cSize;
    BOOL    bContinue;

    //
    // match for %systemroot%
    //

    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%SYSTEMROOT%",
                                       SCE_FLAG_WINDOWS_DIR,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    //
    // match for %systemdirectory%
    //

    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%SYSTEMDIRECTORY%",
                                       SCE_FLAG_SYSTEM_DIR,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    //
    // match for systemdrive
    //

    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%SYSTEMDRIVE%",
                                       SCE_FLAG_WINDOWS_DIR,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    //
    // match for boot drive
    //

    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%BOOTDRIVE%",
                                       SCE_FLAG_BOOT_DRIVE,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    rc = ERROR_SUCCESS;
    //
    // search for environment variable in the current process
    //
    pStart = wcschr(oldFileName, L'%');

    if ( pStart ) {
        pTemp = wcschr(pStart+1, L'%');
        if ( pTemp ) {

            bContinue = TRUE;
            //
            // find a environment variable to translate
            //
            TmpBuf = (PWSTR)ScepAlloc(0, ((UINT)(pTemp-pStart))*sizeof(WCHAR));
            if ( TmpBuf ) {

                wcsncpy(TmpBuf, pStart+1, (size_t)(pTemp-pStart-1));
                TmpBuf[pTemp-pStart-1] = L'\0';

                //
                // try search in the client environment block
                //

                szVar = ScepSearchClientEnv(TmpBuf, (DWORD)(pTemp-pStart-1));

                if ( szVar ) {

//                        ScepLogOutput2(3,0,L"\tFind client env %s=%s", TmpBuf, szVar);
                    //
                    // find it in the client's environment block, use it
                    // get info in szVar
                    //
                    bContinue = FALSE;

                    newFileSize = ((DWORD)(pStart-oldFileName))+wcslen(szVar)+wcslen(pTemp+1)+1;

                    *newFileName = (PWSTR)ScepAlloc(0, newFileSize*sizeof(TCHAR));

                    if (*newFileName ) {
                        if ( pStart != oldFileName ) {
                            wcsncpy(*newFileName, oldFileName, (size_t)(pStart-oldFileName));
                        }

                        swprintf((PWSTR)(*newFileName+(pStart-oldFileName)), L"%s%s", szVar, pTemp+1);

                    } else {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    //
                    // DO NOT free szVar because it's a ref pointer to the env block
                    //
                } else {

                    cSize = GetEnvironmentVariable( TmpBuf,
                                                NULL,
                                                0 );

                    if ( cSize > 0 ) {
                    //
                    // does not find it in the client environment block,
                    // find it in the current server process environment, use it
                    //
                        szVar = (PWSTR)ScepAlloc(0, (cSize+1)*sizeof(WCHAR));

                        if ( szVar ) {
                            cSize = GetEnvironmentVariable(TmpBuf,
                                                       szVar,
                                                       cSize);
                            if ( cSize > 0 ) {
                                //
                                // get info in szVar
                                //
                                bContinue = FALSE;

                                newFileSize = ((DWORD)(pStart-oldFileName))+cSize+wcslen(pTemp+1)+1;

                                *newFileName = (PWSTR)ScepAlloc(0, newFileSize*sizeof(TCHAR));

                                if (*newFileName ) {
                                    if ( pStart != oldFileName )
                                        wcsncpy(*newFileName, oldFileName, (size_t)(pStart-oldFileName));

                                    swprintf((PWSTR)(*newFileName+(pStart-oldFileName)), L"%s%s", szVar, pTemp+1);

                                } else
                                    rc = ERROR_NOT_ENOUGH_MEMORY;
                            }

                            ScepFree(szVar);

                        } else
                            rc = ERROR_NOT_ENOUGH_MEMORY;

                    }
                }

                ScepFree(TmpBuf);

            } else
                rc = ERROR_NOT_ENOUGH_MEMORY;

            if ( NO_ERROR != rc || !bContinue ) {
                //
                // if errored, or do not continue
                //
                return(rc);
            }

            //
            // not found in environment blob,
            // continue to search for DSDIT/DSLOG/SYSVOL in registry
            //
            if ( ProductType == NtProductLanManNt ) {

                //
                // search for DSDIT
                //

                rc = ScepExpandEnvironmentVariable(oldFileName,
                                                   L"%DSDIT%",
                                                   SCE_FLAG_DSDIT_DIR,
                                                   newFileName);

                if ( rc != ERROR_FILE_NOT_FOUND ) {
                    return rc;
                }

                //
                // search for DSLOG
                //

                rc = ScepExpandEnvironmentVariable(oldFileName,
                                                   L"%DSLOG%",
                                                   SCE_FLAG_DSLOG_DIR,
                                                   newFileName);

                if ( rc != ERROR_FILE_NOT_FOUND ) {
                    return rc;
                }

                //
                // search for SYSVOL
                //
                rc = ScepExpandEnvironmentVariable(oldFileName,
                                                   L"%SYSVOL%",
                                                   SCE_FLAG_SYSVOL_DIR,
                                                   newFileName);

                if ( rc != ERROR_FILE_NOT_FOUND ) {
                    return rc;
                }

            }

            //
            // search for PROFILES
            //
            rc = ScepExpandEnvironmentVariable(oldFileName,
                                               L"%PROFILES%",
                                               SCE_FLAG_PROFILES_DIR,
                                               newFileName);

            if ( rc != ERROR_FILE_NOT_FOUND ) {

                return rc;

            }

        }

    }
    //
    // Otherwise, just copy the old name to a new buffer and return ERROR_PATH_NOT_FOUND
    //
    *newFileName = (PWSTR)ScepAlloc(0, (wcslen(oldFileName)+1)*sizeof(TCHAR));

    if (*newFileName != NULL) {
        wcscpy(*newFileName, _wcsupr(oldFileName) );
        rc = ERROR_PATH_NOT_FOUND;
    } else
        rc = ERROR_NOT_ENOUGH_MEMORY;

    return(rc);

}

LPTSTR
ScepSearchClientEnv(
    IN LPTSTR varName,
    IN DWORD dwSize
    )
{
    if ( !varName || dwSize == 0 ||
         !t_pebClient || t_pebSize == 0 ) {
        return NULL;
    }

    LPTSTR pTemp = (LPTSTR)t_pebClient;

    while ( pTemp && *pTemp != L'\0' ) {


        if ( _wcsnicmp(varName, pTemp, dwSize) == 0 &&
             L'=' == *(pTemp+dwSize) ) {
            //
            // find the variable
            //
            return pTemp+dwSize+1;
            break;
        }
        DWORD Len = wcslen(pTemp);
        pTemp += Len+1;
    }

    return NULL;
}


SCESTATUS
ScepConvertLdapToJetIndexName(
    IN PWSTR TempName,
    OUT PWSTR *OutName
    )
{
    PWSTR pTemp1;
    PWSTR pTemp2;
    INT i,j;
    DWORD Len;

    //
    // Ldap name are in the format of CN=,DC=,...O=
    // Jet Index requires names in the O=,...DC=,CN= format
    //
    // semicolon is converted to , and spaces are stripped out
    //
    if ( TempName == NULL || OutName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    Len = wcslen(TempName);
    pTemp1 = TempName + Len - 1;

    //
    // skip the trailing spaces, commas, or semicolons
    //
    while ( pTemp1 >= TempName &&
            (*pTemp1 == L' ' || *pTemp1 == L';' || *pTemp1 == L',') ) {
        pTemp1--;
    }

    if ( pTemp1 < TempName ) {
        //
        // all spaces or ; in the name
        //
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // allocate output buffer
    //
    *OutName = (PWSTR)ScepAlloc(0, ((UINT)(pTemp1-TempName+2))*sizeof(WCHAR));
    if ( *OutName != NULL ) {

        pTemp2 = *OutName;

        while ( pTemp1 >= TempName ) {

            //
            // find the previous ; or ,
            //
            i = 0;
            while ( pTemp1-i >= TempName && *(pTemp1-i) != L',' &&
                    *(pTemp1-i) != L';' ) {
                i++;
            }
            //
            // either reach the head, or a ; or , is encountered
            //
            i--;   // i must be >= 0

            //
            // skip the leading spaces
            //
            j = 0;
            while ( *(pTemp1-i+j) == L' ' && j <= i ) {
                j++;
            }
            //
            // copy the component
            //
            if ( i >= j ) {

                if ( pTemp2 != *OutName ) {
                    *pTemp2++ = L',';
                }
                wcsncpy(pTemp2, pTemp1-i+j, i-j+1);
                pTemp2 += (i-j+1);

            } else {
                //
                // all spaces
                //
            }
            pTemp1 -= (i+1);
            //
            // skip the trailing spaces, commas, or semicolons
            //
            while ( pTemp1 >= TempName &&
                    (*pTemp1 == L' ' || *pTemp1 == L';' || *pTemp1 == L',') ) {
                pTemp1--;
            }
        }
        if ( pTemp2 == *OutName ) {
            //
            // nothing got copied to the output buffer, WRONG!!!
            //
            ScepFree(*OutName);
            *OutName = NULL;
            return(SCESTATUS_INVALID_PARAMETER);

        } else {
            //
            // teminate the string
            //
            *pTemp2 = L'\0';
            _wcslwr(*OutName);

            return(SCESTATUS_SUCCESS);
        }

    } else
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
}



SCESTATUS
ScepRestoreAuditing(
    IN PPOLICY_AUDIT_EVENTS_INFO auditEvent,
    IN LSA_HANDLE PolicyHandle OPTIONAL
    )
{
    LSA_HANDLE      lsaHandle=NULL;
    NTSTATUS        status;
    SCESTATUS        rc;

    if ( auditEvent == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( PolicyHandle == NULL ) {

        // open Lsa policy for read/write
        status = ScepOpenLsaPolicy(
                        POLICY_VIEW_AUDIT_INFORMATION |
                        POLICY_SET_AUDIT_REQUIREMENTS |
                        POLICY_AUDIT_LOG_ADMIN,
                        &lsaHandle,
                        TRUE
                        );

        if (status != ERROR_SUCCESS) {

            lsaHandle = NULL;
            rc = RtlNtStatusToDosError( status );
            ScepLogOutput3( 1, rc, SCEDLL_LSA_POLICY);

            return(ScepDosErrorToSceStatus(rc));
        }

    } else {
        lsaHandle = PolicyHandle;
    }

    // restore
    status = LsaSetInformationPolicy( lsaHandle,
                                      PolicyAuditEventsInformation,
                                      (PVOID)(auditEvent)
                                    );
    rc = RtlNtStatusToDosError( status );

    if ( rc == NO_ERROR )
        ScepLogOutput3( 2, 0, SCEDLL_EVENT_RESTORED);
    else
        ScepLogOutput3( 1, rc, SCEDLL_SCP_ERROR_EVENT_AUDITING);

    if ( lsaHandle && (lsaHandle != PolicyHandle) )
        LsaClose( lsaHandle );

    return(ScepDosErrorToSceStatus(rc));

}


DWORD
ScepGetDefaultDatabase(
    IN LPCTSTR JetDbName OPTIONAL,
    IN DWORD LogOptions,
    IN LPCTSTR LogFileName OPTIONAL,
    OUT PBOOL pAdminLogon OPTIONAL,
    OUT PWSTR *ppDefDatabase
    )
/*
Routine Description:

    Get the default SCE database for the current logged on user.

Arguments:

    JetDbName   - optional jet database name

    LogOptions  - options for the log, if there is any

    LogFileName - the log file

    pAdminLogon - output flag to indicate if administrative privileged user logged on

    ppDefDatabase - the default database name

Return Value:

    SCESTATUS
*/
{
    if ( !ppDefDatabase ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( LogOptions & SCE_DISABLE_LOG) {

        ScepEnableDisableLog(FALSE);
    } else {
        ScepEnableDisableLog(TRUE);
    }

    if ( LogOptions & SCE_DEBUG_LOG ) {

        ScepSetVerboseLog(3);

    } else if ( LogOptions & SCE_VERBOSE_LOG ) {
        //
        // by default it's not verbose
        //
        ScepSetVerboseLog(2);

    } else {
        ScepSetVerboseLog(-1);
    }

    if ( ScepLogInitialize( LogFileName ) == ERROR_INVALID_NAME ) {
        ScepLogOutput3(1,0, SCEDLL_LOGFILE_INVALID, LogFileName );
    }


    DWORD rc=ERROR_SUCCESS;
    BOOL bAdminLogon=FALSE;

    //
    // determine if admin logs on
    //

    if ( pAdminLogon || !JetDbName || wcslen(JetDbName) < 1) {

        rc = ScepIsAdminLoggedOn(&bAdminLogon, TRUE);
        if ( rc != NO_ERROR ) {
            ScepLogOutput3(1, rc, SCEDLL_UNKNOWN_LOGON_USER);
        }

        if ( bAdminLogon ) {
            ScepLogOutput3(3, 0, SCEDLL_ADMIN_LOGON);
        }
    }

    //
    // find the databae name
    //

    if ( JetDbName && wcslen(JetDbName) > 0 ) {

        *ppDefDatabase = (LPTSTR)JetDbName;

    } else {

        //
        // query if the profile name (or the default ) in registry
        //

        rc = ScepGetProfileSetting(
                L"DefaultProfile",
                bAdminLogon,
                ppDefDatabase
                );

        if ( rc != NO_ERROR || *ppDefDatabase == NULL ) {   // return is Win32 error code
            ScepLogOutput3(1,rc, SCEDLL_UNKNOWN_DBLOCATION);
        }
    }

    if ( pAdminLogon ) {
        *pAdminLogon = bAdminLogon;
    }

    return(rc);

}



BOOL
ScepIsDomainLocal(
    IN PUNICODE_STRING pDomainName OPTIONAL
    )
/* ++
Routine Description:

    This routine checks if the domain is on the local machine by comparing
    the domain name with the local machine's computer name.

Arguments:

    pDomainName - the domain's name to check

Return Value:

    TRUE if it is local

-- */
{
    NTSTATUS                     NtStatus;
    OBJECT_ATTRIBUTES            ObjectAttributes;
    LSA_HANDLE                   PolicyHandle;
    DWORD                        NameLen=MAX_COMPUTERNAME_LENGTH;


    if ( pDomainName == NULL ) {
        //
        // reset the buffer
        //
        ComputerName[0] = L'\0';
        theAcctDomName[0] = L'\0';
        sidBuiltinBuf[0] = '\0';
        sidAuthBuf[0] = '\0';

        return(TRUE);
    }

    if ( pDomainName->Length <= 0 ||
         pDomainName->Buffer == NULL )
        return(TRUE);

    if ( ComputerName[0] == L'\0' ) {
        memset(ComputerName, '\0', (MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR));
        GetComputerName(ComputerName, &NameLen);
    }

    NameLen = wcslen(ComputerName);

    if ( _wcsnicmp(ComputerName, pDomainName->Buffer, pDomainName->Length/2 ) == 0 &&
         (LONG)NameLen == pDomainName->Length/2 )
        return(TRUE);

    if ( theAcctDomName[0] == L'\0' ) {

        //
        // query the current account domain name (for DC case)
        //

        PPOLICY_ACCOUNT_DOMAIN_INFO  PolicyAccountDomainInfo=NULL;

        //
        // Open the policy database
        //

        InitializeObjectAttributes( &ObjectAttributes,
                                      NULL,             // Name
                                      0,                // Attributes
                                      NULL,             // Root
                                      NULL );           // Security Descriptor

        NtStatus = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &PolicyHandle );
        if ( NT_SUCCESS(NtStatus) ) {

            //
            // Query the account domain information
            //

            NtStatus = LsaQueryInformationPolicy( PolicyHandle,
                                                PolicyAccountDomainInformation,
                                                (PVOID *)&PolicyAccountDomainInfo );

            LsaClose( PolicyHandle );
        }

        if ( NT_SUCCESS(NtStatus) ) {

            if ( PolicyAccountDomainInfo->DomainName.Buffer ) {

                wcsncpy(theAcctDomName,
                        PolicyAccountDomainInfo->DomainName.Buffer,
                        PolicyAccountDomainInfo->DomainName.Length/2);

                theAcctDomName[PolicyAccountDomainInfo->DomainName.Length/2] = L'\0';


            }
            LsaFreeMemory(PolicyAccountDomainInfo);
        }
    }

    NameLen = wcslen(theAcctDomName);

    if ( _wcsnicmp(theAcctDomName, pDomainName->Buffer, pDomainName->Length/2) == 0 &&
         (LONG)NameLen == pDomainName->Length/2 )
        return(TRUE);
    else
        return(FALSE);

}


BOOL
ScepIsDomainLocalBySid(
    PSID pSidLookup
    )
{

    if ( pSidLookup == NULL ) {
        return FALSE;
    }

    NTSTATUS                     NtStatus;
    SID_IDENTIFIER_AUTHORITY     NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // search for "NT Authority" name
    //
    if ( sidAuthBuf[0] == '\0' ) {  // sid revision can't be 0

        //
        // build the NT authority sid
        //
        NtStatus = RtlInitializeSid(
                        (PSID)sidAuthBuf,
                        &NtAuthority,
                        0
                        );

        if ( !NT_SUCCESS(NtStatus) ) {

            sidAuthBuf[0] = '\0';
        }

    }

    if ( sidAuthBuf[0] != '\0' &&
         RtlEqualSid((PSID)sidAuthBuf, pSidLookup) ) {

        return(TRUE);
    }

    if ( sidBuiltinBuf[0] == '\0' ) {
        //
        // build the builtin domain sid
        //

        NtStatus = RtlInitializeSid(
                        (PSID)sidBuiltinBuf,
                        &NtAuthority,
                        1
                        );

        if ( NT_SUCCESS(NtStatus) ) {

            *(RtlSubAuthoritySid((PSID)sidBuiltinBuf, 0)) = SECURITY_BUILTIN_DOMAIN_RID;

        } else {

            sidBuiltinBuf[0] = '\0';
        }
    }

    if ( sidBuiltinBuf[0] != '\0' &&
         RtlEqualSid((PSID)sidBuiltinBuf, pSidLookup) ) {

        return(TRUE);

    } else {

        return(FALSE);
    }

}


NTSTATUS
ScepAddAdministratorToThisList(
    IN SAM_HANDLE DomainHandle OPTIONAL,
    IN OUT PSCE_NAME_LIST *ppList
    )
{
    NTSTATUS NtStatus;
    SAM_HANDLE          AccountDomain=NULL;
    SAM_HANDLE          UserHandle=NULL;
    SAM_HANDLE          ServerHandle=NULL;
    PSID                DomainSid=NULL;

    USER_NAME_INFORMATION *BufName=NULL;
    DOMAIN_NAME_INFORMATION *DomainName=NULL;
    PSCE_NAME_LIST        pName=NULL;

    if (!ppList ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if ( !DomainHandle ) {

        //
        // open the sam account domain
        //

        NtStatus = ScepOpenSamDomain(
                        SAM_SERVER_ALL_ACCESS,
                        MAXIMUM_ALLOWED,
                        &ServerHandle,
                        &AccountDomain,
                        &DomainSid,
                        NULL,
                        NULL
                        );

        if ( !NT_SUCCESS(NtStatus) ) {
            ScepLogOutput3(1,RtlNtStatusToDosError(NtStatus),
                           SCEDLL_ERROR_OPEN, L"SAM");
            return(NtStatus);
        }

    } else {
        AccountDomain = DomainHandle;
    }

    //
    // query account domain name
    //
    NtStatus = SamQueryInformationDomain(
                    AccountDomain,
                    DomainNameInformation,
                    (PVOID *)&DomainName
                    );

    if ( NT_SUCCESS( NtStatus ) && DomainName &&
         DomainName->DomainName.Length > 0 && DomainName->DomainName.Buffer ) {

        NtStatus = SamOpenUser(
                      AccountDomain,
                      MAXIMUM_ALLOWED,
                      DOMAIN_USER_RID_ADMIN,
                      &UserHandle
                      );

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SamQueryInformationUser(
                          UserHandle,
                          UserNameInformation,
                          (PVOID *)&BufName
                          );

            if ( NT_SUCCESS( NtStatus ) && BufName &&
                 BufName->UserName.Length > 0 && BufName->UserName.Buffer ) {

                //
                // add it to the members list, check duplicate
                //
                LONG NameLen;
                PWSTR                 pTemp;

                for ( pName = *ppList; pName; pName=pName->Next ) {

                    if ( !pName->Name ) {
                        continue;
                    }

                    pTemp = wcschr( pName->Name, L'\\');

                    if ( pTemp ) {
                        //
                        // has a domain prefix
                        //
                        pTemp++;
                    } else {
                        pTemp = pName->Name;
                    }
                    NameLen = wcslen(pTemp);

                    if ( NameLen == BufName->UserName.Length/2 &&
                         _wcsnicmp(pTemp,
                                   BufName->UserName.Buffer,
                                   BufName->UserName.Length/2) == 0 ) {
                        //
                        // now, match the domain prefix
                        //
                        if ( pTemp != pName->Name ) {

                            if ( (pTemp-pName->Name-1) == DomainName->DomainName.Length/2 &&
                                 _wcsnicmp(pName->Name,
                                           DomainName->DomainName.Buffer,
                                           DomainName->DomainName.Length/2) == 0 ) {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                }

                if ( !pName ) {

                    //
                    // allocate a new node, if no resource, ignore the addition
                    //
                    pName = (PSCE_NAME_LIST)ScepAlloc( (UINT)0, sizeof(SCE_NAME_LIST));

                    if ( pName ) {

                        pName->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, BufName->UserName.Length+DomainName->DomainName.Length+4);

                        if ( pName->Name == NULL ) {
                            ScepFree(pName);
                        } else {
                            //
                            // add the node to the front of the members list
                            //
                            NameLen = DomainName->DomainName.Length/2;

                            wcsncpy(pName->Name, DomainName->DomainName.Buffer,
                                    NameLen);
                            pName->Name[NameLen] = L'\\';

                            wcsncpy(pName->Name+NameLen+1, BufName->UserName.Buffer,
                                    BufName->UserName.Length/2);
                            pName->Name[NameLen+1+BufName->UserName.Length/2] = L'\0';

                            pName->Next = *ppList;
                            *ppList = pName;
                        }
                    }
                } else {
                    // else find it in the member list already, do nothing
                }

            }

            //
            // close the user handle
            //
            SamCloseHandle(UserHandle);
            UserHandle = NULL;
        }
    }

    if ( AccountDomain != DomainHandle ) {
       //
       // domain is opened
       //
       SamCloseHandle(AccountDomain);

       SamCloseHandle( ServerHandle );
       if ( DomainSid != NULL )
           SamFreeMemory(DomainSid);
    }

    if ( BufName ) {
        SamFreeMemory(BufName);
    }

    if ( DomainName ) {
        SamFreeMemory(DomainName);
    }

    return(NtStatus);
}



DWORD
ScepDatabaseAccessGranted(
    IN LPTSTR DatabaseName,
    IN DWORD DesiredAccess,
    IN BOOL bCreate
    )
{

    if ( DatabaseName == NULL || DesiredAccess == 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    HANDLE hToken = NULL, hNewToken = NULL;
    DWORD Win32rc = NO_ERROR;

    //
    // get current client token
    //
    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                          TRUE,
                          &hToken)) {

        if(ERROR_NO_TOKEN == GetLastError()){

            if(!OpenProcessToken( GetCurrentProcess(),
                                  TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                                  &hToken )){

                return ( GetLastError() );

            }

        } else {

            return( GetLastError() );

        }
        
    }

    //
    // Duplicate it so it can be used for impersonation
    //

    if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                          NULL, SecurityImpersonation, TokenImpersonation,
                          &hNewToken))
    {
        CloseHandle (hToken);
        return ( GetLastError() );
    }

    CloseHandle (hToken);


    PSECURITY_DESCRIPTOR pCurrentSD=NULL;
    PRIVILEGE_SET PrivSet;
    DWORD PrivSetLength = sizeof(PRIVILEGE_SET);
    DWORD dwGrantedAccess;
    BOOL bAccessStatus = TRUE;

    if ( !bCreate ) {

        Win32rc = ScepGetNamedSecurityInfo(
                        DatabaseName,
                        SE_FILE_OBJECT,
                        OWNER_SECURITY_INFORMATION |
                        GROUP_SECURITY_INFORMATION |
                        DACL_SECURITY_INFORMATION,
                        &pCurrentSD
                        );

        if ( Win32rc == ERROR_PATH_NOT_FOUND ||
             Win32rc == ERROR_FILE_NOT_FOUND ) {

            pCurrentSD = NULL;

            Win32rc = NO_ERROR;

        }
    }

    if ( Win32rc == NO_ERROR ) {

        if ( pCurrentSD == NULL ) {
            //
            // either this database is to be overwritten (re-created)
            // or it doesn't exist. In both cases, hand the call over to Jet
            // which will do the right access checking.
            //
        } else {

            if ( !AccessCheck (
                        pCurrentSD,
                        hNewToken,
                        DesiredAccess,
                        &FileGenericMapping,
                        &PrivSet,
                        &PrivSetLength,
                        &dwGrantedAccess,
                        &bAccessStatus
                        ) ) {

                Win32rc = GetLastError();

            } else {

                if ( bAccessStatus &&
                     (dwGrantedAccess == DesiredAccess ) ) {
                    Win32rc = NO_ERROR;
                } else {
                    Win32rc = ERROR_ACCESS_DENIED;
                }
            }
        }

    }

    if ( pCurrentSD ) {

        LocalFree(pCurrentSD);
    }

    CloseHandle (hNewToken);

    return( Win32rc );
}


DWORD
ScepAddSidToNameList(
    OUT PSCE_NAME_LIST *pNameList,
    IN PSID pSid,
    IN BOOL bReuseBuffer,
    OUT BOOL *pbBufferUsed
    )
/* ++
Routine Description:

    This routine adds a SID to the name list. The new added
    node is always placed as the head of the list for performance reason.

Arguments:

    pNameList -  The address of the name list to add to.

    pSid      - the Sid to add

Return value:

    Win32 error code
-- */
{

    PSCE_NAME_LIST pList=NULL;
    ULONG  Length;

    //
    // check arguments
    //
    if ( pNameList == NULL ||
         pbBufferUsed == NULL )
        return(ERROR_INVALID_PARAMETER);

    *pbBufferUsed = FALSE;

    if ( pSid == NULL )
        return(NO_ERROR);

    if ( !RtlValidSid(pSid) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // check if the SID is already in the name list
    //
    for ( pList=*pNameList; pList!=NULL; pList=pList->Next ) {
        if ( pList->Name == NULL ) {
            continue;
        }
        if ( ScepValidSid( (PSID)(pList->Name) ) &&
             RtlEqualSid( (PSID)(pList->Name), pSid ) ) {
            break;
        }
    }

    if ( pList ) {
        //
        // the SID is already in the list
        //
        return(NO_ERROR);
    }

    //
    // allocate a new node
    //
    pList = (PSCE_NAME_LIST)ScepAlloc( (UINT)0, sizeof(SCE_NAME_LIST));

    if ( pList == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);

    if ( bReuseBuffer ) {

        pList->Name = (PWSTR)pSid;
        *pbBufferUsed = TRUE;

    } else {

        Length = RtlLengthSid ( pSid );

        pList->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, Length);
        if ( pList->Name == NULL ) {
            ScepFree(pList);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // add the node to the front of the list and link its next to the old list
        //
        RtlCopySid( Length, (PSID)(pList->Name), pSid );
    }

    pList->Next = *pNameList;
    *pNameList = pList;

    return(NO_ERROR);
}


BOOL
ScepValidSid(
    PSID Sid
    )
{
    if ( RtlValidSid(Sid) ) {

        PISID Isid = (PISID) Sid;

        if ( Isid->Revision == SID_REVISION ) {
            return(TRUE);
        } else {
            return(FALSE);
        }
    }

    return(FALSE);
}

BOOL
ScepBinarySearch(
    IN  PWSTR   *aPszPtrs,
    IN  DWORD   dwSize_aPszPtrs,
    IN  PWSTR   pszNameToFind
    )
/* ++
Routine Description:

    This routine determines if a string is found in a sorted array of strings.
    The complexity of this search is logarithmic (log(n)) in the size of the
    input array.

Arguments:

    aPszPtrs        -   the array of string pointers to search in

    dwSize_aPszPtrs -   the size of the above array

    pszNameToFind   -   the string to search for

Return value:

    TRUE if string is found
    FALSE if string is not found

-- */
{
    if ( aPszPtrs == NULL || dwSize_aPszPtrs == 0 || pszNameToFind == NULL ) {
        return FALSE;
    }

    int   iLow = 0;
    int   iHigh = dwSize_aPszPtrs - 1;
    int   iMid;
    int   iCmp;

    while (iLow <= iHigh ) {

        iMid = (iLow + iHigh ) / 2;

        iCmp = _wcsicmp( aPszPtrs[iMid], pszNameToFind );

        if ( iCmp == 0 )
            return TRUE;
        else if ( iCmp < 0 )
            iLow = iMid + 1;
        else
            iHigh = iMid - 1;
    }

    return FALSE;
}


/* ++
Routine Description:

    This routine adds a relative SID to the SID list in the format "#-RSID", eg "#-512"
    for Domain Admins. Upon membership restore the groups stores as relative SIDs will be
    from the tattoo table, the full SID will be restored based on current domain.
    

Arguments:

    aPszPtrs        -   the array of string pointers to search in

    dwSize_aPszPtrs -   the size of the above array

    pszNameToFind   -   the string to search for

Return value:

    TRUE if string is found
    FALSE if string is not found

-- */
DWORD
ScepAddRelativeSidToNameList(
    IN OUT PSCE_NAME_LIST *pNameList,
    IN PSID pSid)
{
    DWORD rc;
    PWSTR pwszSid = NULL;
    WCHAR *pchRelativeSid;

    rc = ScepConvertSidToPrefixStringSid(pSid, &pwszSid);
    if(ERROR_SUCCESS == rc)
    {
        //
        // find the relative SID suffix
        //
        pchRelativeSid = wcsrchr(pwszSid, STRING_SID_SUBAUTH_SEPARATOR);
        if(!pchRelativeSid || L'\0'==*(pchRelativeSid+1))
        {
            rc = SCESTATUS_INVALID_DATA;
        }
        else
        {
            //
            // Add the relative SID to list in format "#-RSID"
            //
            rc = ScepAddTwoNamesToNameList(
                pNameList,
                FALSE,
                RELATIVE_SID_PREFIX_SZ,
                1,
                pchRelativeSid,
                wcslen(pchRelativeSid));
        }
    }

    if(pwszSid)
    {
        ScepFree(pwszSid);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\srvutil.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scep.h

Abstract:

    This module defines the data structures and function prototypes
    for the security managment utility

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

--*/

#ifndef _srvutil_
#define _srvutil_

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _SCE_FLAG_TYPE {

    SCE_FLAG_CONFIG=1,
    SCE_FLAG_CONFIG_APPEND,
    SCE_FLAG_ANALYZE,
    SCE_FLAG_ANALYZE_APPEND,
    SCE_FLAG_CONFIG_SCP,
    SCE_FLAG_CONFIG_SCP_APPEND

} SCEFLAGTYPE;

SCESTATUS
ScepGetTotalTicks(
    IN PCWSTR TemplateName,
    IN PSCECONTEXT Context,
    IN AREA_INFORMATION Area,
    IN SCEFLAGTYPE nFlag,
    OUT PDWORD pTotalTicks
    );

BOOL
ScepIsEngineRecovering();

SCESTATUS
ScepSaveAndOffAuditing(
    OUT PPOLICY_AUDIT_EVENTS_INFO *ppAuditEvent,
    IN BOOL bTurnOffAuditing,
    IN LSA_HANDLE PolicyHandle OPTIONAL
    );

NTSTATUS
ScepGetAccountExplicitRight(
    IN LSA_HANDLE PolicyHandle,
    IN PSID       AccountSid,
    OUT PDWORD    PrivilegeLowRights,
    OUT PDWORD    PrivilegeHighRights
    );

NTSTATUS
ScepGetMemberListSids(
    IN PSID         DomainSid,
    IN LSA_HANDLE   PolicyHandle,
    IN PSCE_NAME_LIST pMembers,
    OUT PUNICODE_STRING *MemberNames,
    OUT PSID**      Sids,
    OUT PULONG      MemberCount
    );

DWORD
ScepOpenFileObject(
    IN  LPWSTR       pObjectName,
    IN  ACCESS_MASK  AccessMask,
    OUT PHANDLE      Handle
    );

DWORD
ScepOpenRegistryObject(
    IN  SE_OBJECT_TYPE  ObjectType,
    IN  LPWSTR       pObjectName,
    IN  ACCESS_MASK  AccessMask,
    OUT PHKEY        Handle
    );

SCESTATUS
ScepGetNameInLevel(
    IN PCWSTR ObjectFullName,
    IN DWORD  Level,
    IN WCHAR  Delim,
    OUT PWSTR Buffer,
    OUT PBOOL LastOne
    );


SCESTATUS
ScepTranslateFileDirName(
   IN PWSTR oldFileName,
   OUT PWSTR *newFileName
   );

//
// errlog.c
//
SCESTATUS
ScepLogInitialize(
   IN PCWSTR logname
   );

SCESTATUS
ScepLogOutput2(
   IN INT     ErrLevel,
   IN DWORD   rc,
   IN PWSTR   fmt,
   ...
  );

SCESTATUS
ScepLogOutput(
    IN DWORD rc,
    IN LPTSTR buf
    );

SCESTATUS
ScepLogOutput3(
   IN INT     ErrLevel,
   IN DWORD   rc,
   IN UINT nId,
   ...
  );

SCESTATUS
ScepLogClose();

SCESTATUS
ScepLogWriteError(
    IN PSCE_ERROR_LOG_INFO  pErrlog,
    IN INT ErrLevel
    );

SCESTATUS
ScepConvertLdapToJetIndexName(
    IN PWSTR TempName,
    OUT PWSTR *OutName
    );

SCESTATUS
ScepRestoreAuditing(
    IN PPOLICY_AUDIT_EVENTS_INFO auditEvent,
    IN LSA_HANDLE PolicyHandle OPTIONAL
    );

DWORD
ScepGetDefaultDatabase(
    IN LPCTSTR JetDbName OPTIONAL,
    IN DWORD LogOptions,
    IN LPCTSTR LogFileName OPTIONAL,
    OUT PBOOL pAdminLogon OPTIONAL,
    OUT PWSTR *ppDefDatabase
    );

BOOL
ScepIsDomainLocal(
    IN PUNICODE_STRING pDomainName OPTIONAL
    );

BOOL
ScepIsDomainLocalBySid(
    IN PSID pSidLookup
    );

NTSTATUS
ScepAddAdministratorToThisList(
    IN SAM_HANDLE DomainHandle OPTIONAL,
    IN OUT PSCE_NAME_LIST *ppList
    );

DWORD
ScepDatabaseAccessGranted(
    IN LPTSTR DatabaseName,
    IN DWORD DesiredAccess,
    IN BOOL bCreate
    );

DWORD
ScepAddSidToNameList(
    OUT PSCE_NAME_LIST *pNameList,
    IN PSID pSid,
    IN BOOL bReuseBuffer,
    OUT BOOL *pbBufferUsed
    );

BOOL
ScepValidSid(
    PSID Sid
    );

BOOL
ScepBinarySearch(
    IN  PWSTR   *aPszPtrs,
    IN  DWORD   dwSize_aPszPtrs,
    IN  PWSTR   pszNameToFind
    );

DWORD
ScepAddRelativeSidToNameList(
    IN OUT PSCE_NAME_LIST *pNameList,
    IN PSID pSid);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\svcsrv.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    svcsrv.cpp

Abstract:

    Server Service attachment APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997

Revision History:

    jinhuang    23-Jan-1998     splitted to client-server
--*/
#include "serverp.h"
#include "pfp.h"
#include "srvrpcp.h"
#include "service.h"
#pragma hdrstop

//
// private prototypes
//
SCESTATUS
SceSvcpGetOneKey(
    IN PSCESECTION hSection,
    IN PWSTR Prefix,
    IN DWORD PrefixLen,
    IN SCESVC_INFO_TYPE Type,
    OUT PVOID *Info
    );

SCESTATUS
SceSvcpEnumNext(
    IN PSCESECTION hSection,
    IN DWORD RequestCount,
    IN SCESVC_INFO_TYPE Type,
    OUT PVOID *Info,
    OUT PDWORD CountReturned
    );

//
// prototypes called from RPC interfaces
//


SCESTATUS
SceSvcpUpdateInfo(
    IN PSCECONTEXT                  Context,
    IN PCWSTR                       ServiceName,
    IN PSCESVC_CONFIGURATION_INFO   Info
    )
/*
Routine Description:

    Load service's engine dll and pass the Info buffer to service engine's
    update API (SceSvcAttachmentUpdate). Currently security manager engine
    is not doing any processing for the service data.

    This routine triggers the update of configuration database and/or
    analysis information by the service engine. Info may contain the
    modifications only, or the whole configuratio data for the service,
    or partial configuration data, depending on the agreement between service
    extension and service engine.

    This routine does not really write info to security manager database directly,
    instead, it passes the info buffer to the service engine's update interface
    and service engine will determine what and when to write inot the database.

Arguments:

    hProfile - the security database context handle

    ServiceName - The service's name as used by service control manager

    Info - The information modified

*/
{

    if ( Context == NULL || ServiceName == NULL ||
        Info == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);

    }

    SCESTATUS rc;

    //
    // get service's dll name
    //

    DWORD KeyLen;
    PWSTR KeyStr=NULL;

    KeyLen = wcslen(SCE_ROOT_SERVICE_PATH) + 1 + wcslen(ServiceName);

    KeyStr = (PWSTR)ScepAlloc(0, (KeyLen+1)*sizeof(WCHAR));

    if ( KeyStr == NULL ) {

        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    }

    PWSTR Setting=NULL;
    DWORD RegType;

    swprintf(KeyStr, L"%s\\%s", SCE_ROOT_SERVICE_PATH, ServiceName);
    KeyStr[KeyLen] = L'\0';

    rc = ScepRegQueryValue(
            HKEY_LOCAL_MACHINE,
            KeyStr,
            L"ServiceAttachmentPath",
            (PVOID *)&Setting,
            &RegType,
            NULL
            );

    rc = ScepDosErrorToSceStatus(rc);

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( Setting != NULL ) {

            //
            // load the dll.
            //
            HINSTANCE hService;

            hService = LoadLibrary(Setting);

            if ( hService != NULL ) {
                //
                // call SceSvcAttachmentUpdate from the dll
                //
                PF_UpdateService pfTemp;

                pfTemp = (PF_UpdateService)
                                  GetProcAddress(hService,
                                                 "SceSvcAttachmentUpdate") ;
                if ( pfTemp != NULL ) {

                    SCEP_HANDLE sceHandle;
                    SCESVC_CALLBACK_INFO sceCbInfo;

                    sceHandle.hProfile = (PVOID)Context;
                    sceHandle.ServiceName = ServiceName;

                    sceCbInfo.sceHandle = &sceHandle;
                    sceCbInfo.pfQueryInfo = &SceCbQueryInfo;
                    sceCbInfo.pfSetInfo = &SceCbSetInfo;
                    sceCbInfo.pfFreeInfo = &SceSvcpFreeMemory;
                    sceCbInfo.pfLogInfo = &ScepLogOutput2;

                    //
                    // call the SceSvcAttachmentUpdate from the DLL
                    //
                    __try {

                        rc = (*pfTemp)((PSCESVC_CALLBACK_INFO)&sceCbInfo, Info );

                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                    }

                } else {
                    //
                    // this API is not supported
                    //
                    rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                }

                //
                // try to free the library handle. If it fails, just leave it
                // to to the process to terminate
                //
                FreeLibrary(hService);

            } else
                rc = SCESTATUS_SERVICE_NOT_SUPPORT;

            ScepFree(Setting);

        } else
            rc = SCESTATUS_SERVICE_NOT_SUPPORT;
    }

    ScepFree(KeyStr);

    return(rc);

}


SCESTATUS
SceSvcpQueryInfo(
    IN PSCECONTEXT                  Context,
    IN SCESVC_INFO_TYPE             SceSvcType,
    IN PCWSTR                       ServiceName,
    IN PWSTR                        Prefix OPTIONAL,
    IN BOOL                         bExact,
    OUT PVOID                       *ppvInfo,
    IN OUT PSCE_ENUMERATION_CONTEXT psceEnumHandle
    )
/*
Routine Description:

    Query information for the service in the configuration/analysis database
    which contains the modified configuration and last analysis information.

    One enumeration returns maximum SCESVC_ENUMERATION_MAX lines (key/value)
    matching the lpPrefix for the service. If lpPrefix is NULL, all information
    for the service is enumerated. If there is more information, psceEnumHandle
    must be used to get next set of keys/values, until *ppvInfo is NULL or Count is 0.

    When bExact is set and lpPrefix is not NULL, exact match on the lpPrefix is
    searched and only one line is returned.

    The output buffer must be freed by SceSvcFree

Arguments:

    Context     - the database context handle

    SceSvcType  - the information type to query

    ServiceName - the service name to query info for

    Prefix      - the optional key name prefix for the query

    bExact      - TRUE = exact match on key

    ppvInfo     - the output buffer

    psceEnumHandle  - the output enumeration handle for next enumeartion

*/
{
    if ( Context == NULL || ppvInfo == NULL ||
         psceEnumHandle == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);

    }

    PSCESECTION   hSection=NULL;
    DOUBLE        SectionID;
    SCESTATUS     rc;

    switch ( SceSvcType ) {
    case SceSvcConfigurationInfo:
        //
        // query data in configuration database
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SMP,
                    ServiceName,
                    &hSection
                    );
        break;

    case SceSvcAnalysisInfo:
        //
        // query data in analysis database
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    ServiceName,
                    &hSection
                    );
        break;

    case SceSvcInternalUse:
    case SceSvcMergedPolicyInfo:
        //
        // query data in SCP database
        //
        rc = SceJetGetSectionIDByName(
                    Context,
                    ServiceName,
                    &SectionID
                    );
        if ( rc == SCESTATUS_SUCCESS ) {

            rc = SceJetOpenSection(
                        Context,
                        SectionID,
                        SCEJET_TABLE_SCP,
                        &hSection
                        );
        }
        break;

    default:
        rc = SCESTATUS_INVALID_PARAMETER;
        break;
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        *ppvInfo = NULL;

        DWORD PrefixLen, CountReturned;

        if ( Prefix != NULL ) {
            PrefixLen = wcslen(Prefix);
        } else
            PrefixLen = 0;

        if ( bExact && Prefix != NULL ) {

            //
            // one single key match
            //

            rc = SceSvcpGetOneKey(
                        hSection,
                        Prefix,
                        PrefixLen,
                        SceSvcType,
                        ppvInfo
                        );

            *psceEnumHandle = 0;

        } else {
            //
            // count total number of lines matching Prefix
            //
            DWORD LineCount;

            rc = SceJetGetLineCount(
                        hSection,
                        Prefix,
                        TRUE,
                        &LineCount
                        );

            if ( rc == SCESTATUS_SUCCESS && LineCount <= 0 )
                rc = SCESTATUS_RECORD_NOT_FOUND;

            if ( rc == SCESTATUS_SUCCESS ) {

                if ( LineCount <= *psceEnumHandle ) {
                    //
                    // no more entries
                    //

                } else {
                    //
                    // go to the first line of Prefix
                    //
                    rc = SceJetSeek(
                            hSection,
                            Prefix,
                            PrefixLen*sizeof(WCHAR),
                            SCEJET_SEEK_GE
                            );

                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // skip the first *EnumHandle lines
                        //
                        JET_ERR JetErr;

                        JetErr = JetMove(hSection->JetSessionID,
                                     hSection->JetTableID,
                                     *psceEnumHandle,
                                     0
                                     );
                        rc = SceJetJetErrorToSceStatus(JetErr);

                        if ( rc == SCESTATUS_SUCCESS ) {
                            //
                            // find the right start point
                            //
                            DWORD CountToReturn;

                            if ( LineCount - *psceEnumHandle > SCESVC_ENUMERATION_MAX ) {
                                CountToReturn = SCESVC_ENUMERATION_MAX;
                            } else
                                CountToReturn = LineCount - *psceEnumHandle;
                            //
                            // get next block of data
                            //
                            rc = SceSvcpEnumNext(
                                    hSection,
                                    CountToReturn,
                                    SceSvcType,
                                    ppvInfo,
                                    &CountReturned
                                    );

                            if ( rc == SCESTATUS_SUCCESS ) {
                                //
                                // update the enumeration handle
                                //
                                *psceEnumHandle += CountReturned;

                            }
                        }

                    }

                }
            }
        }

        if ( rc != SCESTATUS_SUCCESS ) {

            *psceEnumHandle = 0;
        }

        //
        // close the section
        //
        SceJetCloseSection(&hSection, TRUE);
    }

    return(rc);
}



SCESTATUS
SceSvcpGetOneKey(
    IN PSCESECTION hSection,
    IN PWSTR Prefix,
    IN DWORD PrefixLen,
    IN SCESVC_INFO_TYPE Type,
    OUT PVOID *Info
    )
/*
Read key and value information into *Info for exact matched Prefix

*/
{
    if ( hSection == NULL || Prefix == NULL ||
         Info == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;
    DWORD ValueLen;
    PBYTE Value=NULL;

    rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH,
                Prefix,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueLen
                );

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // allocate buffer for Value
        //
        Value = (PBYTE)ScepAlloc(0, ValueLen+2);

        if ( Value != NULL ) {

            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        (PWSTR)Value,
                        ValueLen,
                        &ValueLen
                        );

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // allocate output buffer and assign
                //
                PSCESVC_ANALYSIS_INFO pAnalysisInfo=NULL;
                PSCESVC_CONFIGURATION_INFO pConfigInfo=NULL;

                if ( Type == SceSvcAnalysisInfo ) {

                    *Info = ScepAlloc(0, sizeof(SCESVC_ANALYSIS_INFO));
                    pAnalysisInfo = (PSCESVC_ANALYSIS_INFO)(*Info);

                } else {
                    *Info = ScepAlloc(0, sizeof(SCESVC_CONFIGURATION_INFO));
                    pConfigInfo = (PSCESVC_CONFIGURATION_INFO)(*Info);
                }

                if ( *Info != NULL ) {
                    //
                    // Lines buffer
                    //
                    if ( Type == SceSvcAnalysisInfo ) {

                        pAnalysisInfo->Lines = (PSCESVC_ANALYSIS_LINE)ScepAlloc(0,
                                                sizeof(SCESVC_ANALYSIS_LINE));

                        if ( pAnalysisInfo->Lines != NULL ) {
                            //
                            // Key buffer
                            //
                            pAnalysisInfo->Lines->Key = (PWSTR)ScepAlloc(0, (PrefixLen+1)*sizeof(WCHAR));

                            if ( pAnalysisInfo->Lines->Key != NULL ) {

                                wcscpy( pAnalysisInfo->Lines->Key, Prefix );
                                pAnalysisInfo->Lines->Value = Value;
                                pAnalysisInfo->Lines->ValueLen = ValueLen;

                                pAnalysisInfo->Count = 1;

                                Value = NULL;


                            } else {
                                //
                                // free *Info->Lines
                                //
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                ScepFree( pAnalysisInfo->Lines );
                                pAnalysisInfo->Lines = NULL;
                            }

                        } else
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                        if ( rc != SCESTATUS_SUCCESS ) {
                            //
                            // free buffer allocate
                            //
                            ScepFree(*Info);
                            *Info = NULL;

                        }

                    } else {
                        pConfigInfo->Lines = (PSCESVC_CONFIGURATION_LINE)ScepAlloc(0,
                                                sizeof(SCESVC_CONFIGURATION_LINE));

                        if ( pConfigInfo->Lines != NULL ) {
                            //
                            // Key buffer
                            //
                            pConfigInfo->Lines->Key = (PWSTR)ScepAlloc(0, (PrefixLen+1)*sizeof(WCHAR));

                            if ( pConfigInfo->Lines->Key != NULL ) {

                                wcscpy( pConfigInfo->Lines->Key, Prefix );
                                pConfigInfo->Lines->Value = (PWSTR)Value;
                                pConfigInfo->Lines->ValueLen = ValueLen;

                                pConfigInfo->Count = 1;

                                Value = NULL;

                            } else {
                                //
                                // free *Info->Lines
                                //
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                ScepFree( pConfigInfo->Lines );
                                pConfigInfo->Lines = NULL;
                            }

                        } else
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                        if ( rc != SCESTATUS_SUCCESS ) {
                            //
                            // free buffer allocate
                            //
                            ScepFree(*Info);
                            *Info = NULL;

                        }

                    }
                    //
                    // free *Info
                    //
                    if ( rc != SCESTATUS_SUCCESS ) {

                        ScepFree( *Info );
                        *Info = NULL;
                    }

                } else
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

            if ( Value != NULL ) {
                ScepFree(Value);
                Value = NULL;
            }

        }
    }
    return(rc);
}


SCESTATUS
SceSvcpEnumNext(
    IN PSCESECTION hSection,
    IN DWORD RequestCount,
    IN SCESVC_INFO_TYPE Type,
    OUT PVOID *Info,
    OUT PDWORD CountReturned
    )
{
    if ( hSection == NULL || Info == NULL || CountReturned == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( RequestCount <= 0 ) {
        *CountReturned = 0;

        return(SCESTATUS_SUCCESS);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    //
    // allocate output buffer
    //
    PSCESVC_ANALYSIS_INFO pAnalysisInfo=NULL;
    PSCESVC_CONFIGURATION_INFO pConfigInfo=NULL;

    if ( Type == SceSvcAnalysisInfo ) {

        *Info = ScepAlloc(0, sizeof(SCESVC_ANALYSIS_INFO));
        pAnalysisInfo = (PSCESVC_ANALYSIS_INFO)(*Info);

    } else {

        *Info = ScepAlloc(0, sizeof(SCESVC_CONFIGURATION_INFO));
        pConfigInfo = (PSCESVC_CONFIGURATION_INFO)(*Info);
    }

    if ( *Info != NULL ) {

        DWORD Count=0;

        if ( Type == SceSvcAnalysisInfo ) {

            pAnalysisInfo->Lines = (PSCESVC_ANALYSIS_LINE)ScepAlloc(0,
                                      RequestCount*sizeof(SCESVC_ANALYSIS_LINE));

            if ( pAnalysisInfo->Lines == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

        } else {

            pConfigInfo->Lines = (PSCESVC_CONFIGURATION_LINE)ScepAlloc(0,
                                      RequestCount*sizeof(SCESVC_CONFIGURATION_LINE));

            if ( pConfigInfo->Lines == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

        }

        if ( rc == SCESTATUS_SUCCESS ) {  // if Lines is NULL, rc will be NOT_ENOUGH_RESOURCE

            //
            // loop through each line
            //
            DWORD KeyLen, ValueLen;
            PWSTR Key=NULL, Value=NULL;

            do {

                rc = SceJetGetValue(
                            hSection,
                            SCEJET_CURRENT,
                            NULL,
                            NULL,
                            0,
                            &KeyLen,
                            NULL,
                            0,
                            &ValueLen
                            );

                if ( rc == SCESTATUS_SUCCESS ) {

                    //
                    // allocate memory for the Key and Value
                    //
                    Key = (PWSTR)ScepAlloc(LMEM_ZEROINIT, KeyLen+2);
                    Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

                    if ( Key == NULL || Value == NULL ) {

                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                        ScepFree(Key);
                        ScepFree(Value);

                    } else {
                        //
                        // Get the Key and Value
                        //
                        rc = SceJetGetValue(
                                    hSection,
                                    SCEJET_CURRENT,
                                    NULL,
                                    Key,
                                    KeyLen,
                                    &KeyLen,
                                    Value,
                                    ValueLen,
                                    &ValueLen
                                    );

                        if ( rc == SCESTATUS_SUCCESS ) {
                            //
                            // assign to the output buffer
                            //
                            if ( Type == SceSvcAnalysisInfo ) {
                                pAnalysisInfo->Lines[Count].Key = Key;
                                pAnalysisInfo->Lines[Count].Value = (PBYTE)Value;
                                pAnalysisInfo->Lines[Count].ValueLen = ValueLen;
                            } else {
                                pConfigInfo->Lines[Count].Key = Key;
                                pConfigInfo->Lines[Count].Value = Value;
                                pConfigInfo->Lines[Count].ValueLen = ValueLen;
                            }

                        } else {
                            ScepFree(Key);
                            ScepFree(Value);
                        }

                    }
                }

                //
                // move to next line
                //
                if ( rc == SCESTATUS_SUCCESS ) {

                    rc = SceJetMoveNext(hSection);

                    Count++;
                }

            } while (rc == SCESTATUS_SUCCESS && Count < RequestCount );

        }

        *CountReturned = Count;

        if (Type == SceSvcAnalysisInfo) {

            pAnalysisInfo->Count = Count;

        } else {

            pConfigInfo->Count = Count;
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
            rc = SCESTATUS_SUCCESS;

        } else if ( rc != SCESTATUS_SUCCESS ) {
            //
            // free memory allocated for output buffer
            //
            DWORD i;

            if (Type == SceSvcAnalysisInfo) {

                for ( i=0; i<Count; i++ ) {
                    ScepFree(pAnalysisInfo->Lines[i].Key);
                    ScepFree(pAnalysisInfo->Lines[i].Value);
                }

                ScepFree(pAnalysisInfo->Lines);

            } else {

                for ( i=0; i<Count; i++ ) {

                    ScepFree(pConfigInfo->Lines[i].Key);
                    ScepFree(pConfigInfo->Lines[i].Value);
                }

                ScepFree(pConfigInfo->Lines);
            }

            ScepFree(*Info);
            *Info = NULL;

            *CountReturned = 0;
        }

    } else
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

    return(rc);
}


SCESTATUS
SceSvcpSetInfo(
    IN PSCECONTEXT      Context,
    IN SCESVC_INFO_TYPE SceSvcType,
    IN PCWSTR           ServiceName,
    IN PWSTR            Prefix OPTIONAL,
    IN BOOL             bExact,
    IN LONG             GpoID,
    IN PVOID            pvInfo OPTIONAL
    )
/*
Routine Description:

    Save information of a service into security manager internal database. It's up
    to the service to collect/decide the information to write.

    Type indicates the type of internal database: CONFIGURATION or ANALYSIS.

    If the service section does not exist, create it.

*/
{
    if (!Context || !ServiceName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    PSCESECTION hSection=NULL;
    SCESTATUS rc;

    //
    // open/create the sections
    //

    rc = SceJetStartTransaction( Context );

    if ( rc == SCESTATUS_SUCCESS ) {

        switch ( SceSvcType ) {
        case SceSvcConfigurationInfo:

            rc = ScepStartANewSection(
                        Context,
                        &hSection,
                        SCEJET_TABLE_SMP,
                        ServiceName
                        );
            break;

        case SceSvcAnalysisInfo:

            rc = ScepStartANewSection(
                        Context,
                        &hSection,
                        SCEJET_TABLE_SAP,
                        ServiceName
                        );
            break;

        case SceSvcInternalUse:
        case SceSvcMergedPolicyInfo:

            rc = ScepStartANewSection(
                        Context,
                        &hSection,
                        SCEJET_TABLE_SCP,
                        ServiceName
                        );
            break;

        default:
            rc = SCESTATUS_INVALID_PARAMETER;
        }

        if ( rc == SCESTATUS_SUCCESS ) {

            if ( pvInfo == NULL ) {
                //
                // delete the whole section, partial for Prefix, or a single line
                //
                if (Prefix == NULL ) {
                    rc = SceJetDelete(
                             hSection,
                             NULL,
                             FALSE,
                             SCEJET_DELETE_SECTION
                             );
                } else if ( bExact ) {
                    //
                    // delete single line
                    //
                    rc = SceJetDelete(
                             hSection,
                             Prefix,
                             FALSE,
                             SCEJET_DELETE_LINE
                             );
                } else {
                    rc = SceJetDelete(
                             hSection,
                             Prefix,
                             FALSE,
                             SCEJET_DELETE_PARTIAL
                             );
                }
                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    rc = SCESTATUS_SUCCESS;
                }

            } else {
                //
                // if bExact is not set, delete the whole section first
                //
                if ( !bExact ) {
                    rc = SceJetDelete(
                             hSection,
                             NULL,
                             FALSE,
                             SCEJET_DELETE_SECTION
                             );
                    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                        rc = SCESTATUS_SUCCESS;
                    }
                }
                //
                // overwrite some keys in Info
                //
                DWORD Count;
                PWSTR Key;
                PBYTE Value;
                DWORD ValueLen;

                if ( SceSvcType == SceSvcAnalysisInfo )
                    Count = ((PSCESVC_ANALYSIS_INFO)pvInfo)->Count;
                else
                    Count = ((PSCESVC_CONFIGURATION_INFO)pvInfo)->Count;

                for ( DWORD i=0; i<Count; i++ ) {

                    if ( SceSvcType == SceSvcAnalysisInfo ) {

                        Key = ((PSCESVC_ANALYSIS_INFO)pvInfo)->Lines[i].Key;
                        Value = ((PSCESVC_ANALYSIS_INFO)pvInfo)->Lines[i].Value;
                        ValueLen = ((PSCESVC_ANALYSIS_INFO)pvInfo)->Lines[i].ValueLen;

                    } else {
                        Key = ((PSCESVC_CONFIGURATION_INFO)pvInfo)->Lines[i].Key;
                        Value = (PBYTE)(((PSCESVC_CONFIGURATION_INFO)pvInfo)->Lines[i].Value);
                        ValueLen = ((PSCESVC_CONFIGURATION_INFO)pvInfo)->Lines[i].ValueLen;
                    }

                    rc = SceJetSetLine(
                                hSection,
                                Key,
                                TRUE,
                                (PWSTR)Value,
                                ValueLen,
                                GpoID
                                );

                    if ( rc != SCESTATUS_SUCCESS ) {
                        break;
                    }

                }
            }
        }
        //
        // close the section
        //
        SceJetCloseSection(&hSection, TRUE);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // commit the change
            //
            rc = SceJetCommitTransaction(Context, 0);

        }
        if ( rc != SCESTATUS_SUCCESS ) {

            SceJetRollback(Context, 0);
        }
    }

    return(rc);
}

//
// attachment engine call back functions
//

SCESTATUS
SceCbQueryInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    OUT PVOID               *ppvInfo,
    OUT PSCE_ENUMERATION_CONTEXT psceEnumHandle
    )
{

    PVOID hProfile;
    SCESTATUS rc=ERROR_SUCCESS;

    __try {

        hProfile = ((SCEP_HANDLE *)sceHandle)->hProfile;

        if ( !hProfile ||
            ((SCEP_HANDLE *)sceHandle)->ServiceName == NULL ) {

            rc = SCESTATUS_INVALID_PARAMETER;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = SCESTATUS_INVALID_PARAMETER;
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        //
        // call the private function
        //

        rc = SceSvcpQueryInfo(
                    (PSCECONTEXT)hProfile,
                    sceType,
                    ((SCEP_HANDLE *)sceHandle)->ServiceName,
                    lpPrefix,
                    bExact,
                    ppvInfo,
                    psceEnumHandle
                    );
    }

    return(rc);

}

SCESTATUS
SceCbSetInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    IN PVOID                pvInfo
    )
{

    PVOID hProfile;
    SCESTATUS rc=ERROR_SUCCESS;

    __try {

        hProfile = ((SCEP_HANDLE *)sceHandle)->hProfile;

        if ( !hProfile ||
            ((SCEP_HANDLE *)sceHandle)->ServiceName == NULL ) {

            rc = SCESTATUS_INVALID_PARAMETER;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = SCESTATUS_INVALID_PARAMETER;
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        //
        // call the private function
        //

        rc = SceSvcpSetInfo(
                    (PSCECONTEXT)hProfile,
                    sceType,
                    ((SCEP_HANDLE *)sceHandle)->ServiceName,
                    lpPrefix,
                    bExact,
                    0,
                    pvInfo
                    );

    }

    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\sceanalysisreader.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    SceAnalysisReader.h

Abstract:

    definition of interface for class SceAnalysisReader
    
    SceAnalysisReader is a class that facilitates reading
    Analysis information from a SCE JET security database
    
    This analysis information can be exported with the help
    of an SceXMLLogWriter instance.
    
Author:

    Steven Chan (t-schan) July 2002

--*/


#ifndef SCEANALYSISREADERH
#define SCEANALYSISREADERH

#include "secedit.h"
#include "SceXMLLogWriter.h"
#include "SceProfInfoAdapter.h"
#include "SceLogException.h"

#define STRING_BUFFER_SIZE 512


class SceAnalysisReader{

public:

    SceAnalysisReader(HMODULE hModule, PCWSTR szFileName);
    ~SceAnalysisReader();
    void ExportAnalysis(SceXMLLogWriter* LogWriter, HANDLE hLogFile);


private:

    PWSTR              szFileName;
    SceXMLLogWriter*    LogWriter;

    BOOL    bIsW2k;
    SceProfInfoAdapter* ppSAPBuffer;
    SceProfInfoAdapter* ppSMPBuffer;
    
    SCETYPE             SceEngineSAP;
    SCETYPE             SceEngineSMP;

    PVOID               hProfile;
    WCHAR				szTmpStringBuffer[STRING_BUFFER_SIZE];
    HINSTANCE           myModuleHandle;
    
    void ExportAreaSystemAccess();
    void ExportAreaSystemAudit();
    void ExportAreaGroupMembership();
    void ExportAreaRegistryValues();
    void ExportAreaPrivileges();
    void ExportAreaFileSecurity();
    void ExportAreaRegistrySecurity();
    void ExportAreaKerberos();
    void ExportAreaServices();
    
    void trace(PCWSTR szBuffer, HANDLE hLogFile);   
    void trace(UINT uID, HANDLE hLogFile);

    void 
    GetRegKeyDisplayName(
        IN PCWSTR szName,
        OUT PWSTR szDisplayName,
        IN DWORD dwDisplayNameSize
        );
    
    void
    GetPrivilegeDisplayName(
        IN PCWSTR szName,
        OUT PWSTR szDisplayName,
        IN DWORD dwDisplayNameSize
        );
    
    void 
    LogObjectChildrenDifferences(AREA_INFORMATION Area,
                                 PWSTR ObjectName
                                 );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\server\tree.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tree.cpp

Abstract:

    SCE Engine security inheritance and propagation APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997 created

--*/
#include "serverp.h"
#include "srvutil.h"
#include <io.h>

BOOL    gbQueriedIfSystemContext = FALSE;
BOOL    gbIsSystemContext = FALSE;

#ifdef SCE_DBG
DWORD    gDbgNumPushed = 0;
DWORD    gDbgNumPopped = 0;
#endif

#if _WIN32_WINNT==0x0400
#include "dsrights.h"
#endif

#pragma hdrstop
#define SCETREE_QUERY_SD    1

#define SE_VALID_CONTROL_BITS ( SE_DACL_UNTRUSTED | \
                                SE_SERVER_SECURITY | \
                                SE_DACL_AUTO_INHERIT_REQ | \
                                SE_SACL_AUTO_INHERIT_REQ | \
                                SE_DACL_AUTO_INHERITED | \
                                SE_SACL_AUTO_INHERITED | \
                                SE_DACL_PROTECTED | \
                                SE_SACL_PROTECTED )


#define SCEP_IGNORE_SOME_ERRORS(ErrorCode)  ErrorCode == ERROR_FILE_NOT_FOUND ||\
                                            ErrorCode == ERROR_PATH_NOT_FOUND ||\
                                            ErrorCode == ERROR_ACCESS_DENIED ||\
                                            ErrorCode == ERROR_SHARING_VIOLATION ||\
                                            ErrorCode == ERROR_INVALID_OWNER ||\
                                            ErrorCode == ERROR_INVALID_PRIMARY_GROUP ||\
                                            ErrorCode == ERROR_INVALID_HANDLE ||\
                                            ErrorCode == ERROR_INVALID_SECURITY_DESCR ||\
                                            ErrorCode == ERROR_CANT_ACCESS_FILE


DWORD
AccRewriteSetNamedRights(
    IN     LPWSTR               pObjectName,
    IN     SE_OBJECT_TYPE       ObjectType,
    IN     SECURITY_INFORMATION SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN     BOOL                 bSkipInheritanceComputation
    );

SCESTATUS
ScepCreateObjectNode(
    IN PWSTR Buffer,
    IN WCHAR Delim,
    IN PSCE_OBJECT_TREE *ParentNode,
    OUT PSCE_OBJECT_CHILD_LIST *NewNode
    );

DWORD
ScepDoesObjectHasChildren(
    IN SE_OBJECT_TYPE ObjectType,
    IN PWSTR ObjectName,
    OUT PBOOL pbHasChildren
    );

DWORD
ScepAddAutoInheritRequest(
    IN OUT PSECURITY_DESCRIPTOR pSD,
    IN OUT SECURITY_INFORMATION *pSeInfo
    );

DWORD
ScepSetSecurityOverwriteExplicit(
    IN PCWSTR ObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    );

DWORD
ScepConfigureOneSubTreeFile(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOL BackSlashExist
    );

DWORD
ScepConfigureOneSubTreeKey(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    );

typedef struct _SCEP_STACK_NODE_ {
    PWSTR   Buffer;
    PSECURITY_DESCRIPTOR pObjectSecurity;
    struct _SCEP_STACK_NODE_    *Next;
} SCEP_STACK_NODE, *PSCEP_STACK_NODE;

DWORD
ScepStackNodePush(
    IN PSCEP_STACK_NODE    *ppStackHead,
    IN PWSTR   pszObjectName,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

VOID
ScepStackNodePop(
    IN OUT PSCEP_STACK_NODE    *ppStackHead,
    IN OUT PWSTR   *ppszObjectName,
    IN OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    );

VOID
ScepFreeStack(
    IN PSCEP_STACK_NODE    *ppStackHead
    );

VOID
ScepDumpStack(
    IN PSCEP_STACK_NODE    *ppStackHead
    );

SCESTATUS
ScepBuildObjectTree(
    IN OUT PSCE_OBJECT_TREE *ParentNode,
    IN OUT PSCE_OBJECT_CHILD_LIST *ChildHead,
    IN ULONG Level,
    IN WCHAR Delim,
    IN PCWSTR ObjectFullName,
    IN BOOL IsContainer,
    IN BYTE Status,
    IN PSECURITY_DESCRIPTOR pInfSecurityDescriptor,
    IN SECURITY_INFORMATION InfSeInfo
    )
/* ++
Routine Description:

    This routine adds the ObjectFullName to the tree. When this routine is
    first called from outside, the root of the tree is passed in as *SiblingHead,
    and the ParentNode is NULL. Then the routine parses the ObjectFullName for
    each level and adds the node if it does not exist. For example:

                           root

        level 1             c: ---------> d:--->...
                           /              /
        level 2        winnt->NTLDR->... "Program Files"->...
                       /
        level 3 system32->system->...

Arguments:

    ParentNode - The parent node pointer

    SiblingHead - The sibling head pointer for this level

    Level       - The level (1,2,3...)

    Delim - The deliminator to separate each level in the full name component
            Currently '\' is used for file and registry objects, and '/' is used
            for acitve directory objects.

    ObjectFullName - Full path name of the object (file, registry)

    Status - The configuration status
                    SCE_STATUS_CHECK (with AUTO_INHERIT)
                    SCE_STATUS_NO_AUTO_INHERIT
                    SCE_STATUS_IGNORE
                    SCE_STATUS_OVERWRITE

    pInfSecurityDescriptor - The security descriptor set in the INF file

    InfSeInfo - The security information set in the INF file

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_NOT_ENOUGH_RESOURCE


-- */
{
    SCESTATUS                rc;
    TCHAR                   *Buffer = NULL;
    PSCE_OBJECT_CHILD_LIST  NewNode=NULL;
    PSCE_OBJECT_CHILD_LIST  PrevSib=NULL;
    PSCE_OBJECT_TREE        ThisNode=NULL;
    INT                     Result;
    BOOL                    LastOne=FALSE;
    DWORD                   dwObjectFullNameLen = 0;

    //
    // address for ParentNode can be empty( the root )
    // but address for the first node of the level cannot be empty.
    //
    if ( ChildHead == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // find the object name for the level (from ObjectFullName)
    // e.g., if ObjectFullName is c:\winnt\system32 then
    // level 1 name is c:, level 2 name is winnt, level 3 name is system32
    //
    dwObjectFullNameLen = wcslen(ObjectFullName);
    Buffer = (TCHAR *)LocalAlloc(LMEM_ZEROINIT, 
                                 sizeof(TCHAR) * (dwObjectFullNameLen + 1));

    if (NULL == Buffer) {
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        goto Done;
    }

    memset(Buffer, '\0', dwObjectFullNameLen * sizeof(TCHAR));
    
    rc = ScepGetNameInLevel(ObjectFullName,
                           Level,
                           Delim,
                           Buffer,
                           &LastOne);

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    if ( *ChildHead == NULL ) {
        //
        // This is the first node in this level
        // Create the node and assign it to the ChildHead
        //
        rc = ScepCreateObjectNode(
                        Buffer,
                        Delim,
                        ParentNode,
                        &NewNode
                        );

        if ( rc != SCESTATUS_SUCCESS)
            goto Done;

        *ChildHead = NewNode;

        //
        // Establish the link if there is a parent
        //
        if ( ParentNode != NULL )
            if ( *ParentNode != NULL )
                (*ParentNode)->ChildList = NewNode;

        ThisNode = NewNode->Node;

    } else {
        //
        // There are existing nodes. Search all siblings
        // All siblings are stored in alphabetic order.
        //
        PSCE_OBJECT_CHILD_LIST pTemp;

        for ( pTemp = *ChildHead, PrevSib = NULL;
              pTemp != NULL;
              pTemp = pTemp->Next) {
            //
            // Compare the node's object name with the current object name
            //
            Result = _wcsicmp(pTemp->Node->Name, Buffer);
            //
            // if the node's object name is equal to (find it) or greater
            // than (insert the node) the current object name, then stop
            //
            if ( Result >= 0 ) {
                break;
            }
            PrevSib = pTemp;
        }

        if ( pTemp == NULL ) {
            //
            // Not exist. Append the new node
            //
            rc = ScepCreateObjectNode(
                            Buffer,
                            Delim,
                            ParentNode,
                            &NewNode
                            );

            if ( rc != SCESTATUS_SUCCESS)
                goto Done;

            if ( PrevSib != NULL )
                PrevSib->Next = NewNode;
            else {
                //
                // this is the first one in the level
                //
                (*ChildHead)->Next = NewNode;
            }
            ThisNode = NewNode->Node;

        } else {
            //
            // either find it (i=0) or need to insert between PrevSib and ThisNode
            //
            if ( Result > 0 ) {
                //
                // insert the node
                //
                rc = ScepCreateObjectNode(
                                Buffer,
                                Delim,
                                ParentNode,
                                &NewNode
                                );

                if ( rc != SCESTATUS_SUCCESS)
                    goto Done;

                NewNode->Next = pTemp;
                if ( PrevSib != NULL )
                    PrevSib->Next = NewNode;
                else {
                    //
                    // insert before SiblingHead
                    //
                    *ChildHead = NewNode;
                    if ( ParentNode != NULL )
                        if ( *ParentNode != NULL )
                            (*ParentNode)->ChildList = NewNode;
                }

                ThisNode = NewNode->Node;

            } else {
                ThisNode = pTemp->Node;
            }
        }
    }

    if ( LastOne ) {
        //
        // Assign Inf security information to this node
        //
        ThisNode->pSecurityDescriptor = pInfSecurityDescriptor;
        ThisNode->SeInfo = InfSeInfo;
        ThisNode->Status = Status;
        ThisNode->IsContainer = IsContainer;

    } else {
        //
        // process next level recursively
        //
        rc = ScepBuildObjectTree(&ThisNode,
                                &(ThisNode->ChildList),
                                Level+1,
                                Delim,
                                ObjectFullName,
                                IsContainer,
                                Status,
                                pInfSecurityDescriptor,
                                InfSeInfo);
    }

Done:

    if (Buffer) {
        LocalFree(Buffer);
    }
    
    return(rc);

}


SCESTATUS
ScepCreateObjectNode(
    IN PWSTR Buffer,
    IN WCHAR Delim,
    IN PSCE_OBJECT_TREE *ParentNode,
    OUT PSCE_OBJECT_CHILD_LIST *NewNode
    )
/* ++
Routine Description:

    This routine allocates memory for a new node in the tree. The ParentNode
    is used to determine the full object name and link the new node (if not NULL)

Arguments:

    Buffer - The component name of a object

    Delim - The deliminator to separate different levels in the full name.

    ParentNode - Pointer of the parent node of this new node

    NewNode - New created node

Return value:

    SCESTATUS

-- */
{
    DWORD Len;

    if (NewNode == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // allocate buffer for the node
    //
    *NewNode = (PSCE_OBJECT_CHILD_LIST)ScepAlloc(LPTR, sizeof(SCE_OBJECT_CHILD_LIST));
    if ( *NewNode == NULL )
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    PSCE_OBJECT_TREE Node = (PSCE_OBJECT_TREE)ScepAlloc((UINT)0, sizeof(SCE_OBJECT_TREE));

    if ( Node == NULL ) {
        ScepFree(*NewNode);
        *NewNode = NULL;
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    //
    // allocate buffer for the object name
    //
    Len = wcslen(Buffer);

    Node->Name = (PWSTR)ScepAlloc((UINT)0,
                                   (Len+1) * sizeof(TCHAR));
    if ( Node->Name == NULL ) {
        ScepFree(Node);
        ScepFree(*NewNode);
        *NewNode = NULL;
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    if ( ParentNode != NULL &&
         *ParentNode != NULL ) {
        Len += wcslen((*ParentNode)->ObjectFullName)+1;
        ++((*ParentNode)->dwSize_aChildNames);
    // Reserve a space for "\" for the root dir c:\ .
    } else if ( Buffer[1] == L':' ) {
        Len++;
    }

    Node->ObjectFullName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Len+1)*sizeof(TCHAR));

    if ( Node->ObjectFullName == NULL ) {
        ScepFree(Node->Name );
        ScepFree(Node);
        ScepFree( *NewNode );
        *NewNode = NULL;
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    //
    // initialize
    //
    wcscpy(Node->Name, Buffer);
    Node->ChildList = NULL;
    Node->pSecurityDescriptor = NULL;
    Node->pApplySecurityDescriptor = NULL;
    Node->SeInfo = 0;
    Node->IsContainer = TRUE;
    Node->aChildNames = NULL;
    Node->dwSize_aChildNames = 0;

    if ( ParentNode != NULL &&
         *ParentNode != NULL ) {
        //
        // link to parent, use parent's status for this one
        //
        Node->Parent = *ParentNode;
        swprintf(Node->ObjectFullName,
                 L"%s%c%s",
                 (*ParentNode)->ObjectFullName,
                 Delim,
                 Buffer);
        Node->Status = (*ParentNode)->Status;
    } else {
        //
        // this is the first node.
        //
        Node->Parent = NULL;
        wcscpy(Node->ObjectFullName, Buffer);
        Node->Status = SCE_STATUS_CHECK;
    }

    (*NewNode)->Node = Node;

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepCalculateSecurityToApply(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    )
/* ++
Routine Description:

    This routine walks through the security tree to determine security
    descriptor for each node. It calls RtlNewSecurityObject, passing a
    parent node's SD and current node's SD specified in the INF file.
    The output SD from that API is the security descriptor to set to the
    current object.

Arguments:

    ThisNode - The current object's node

    ObjectType - The object's type
                     SE_FILE_OBJECT
                     SE_REGISTRY_KEY

    Token - The thread/process token of the calling client

    GenericMapping - Generic access map table

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_OTHER_ERROR (see log for detail error)

-- */
{
    SCESTATUS               rc=SCESTATUS_SUCCESS;
    PSECURITY_DESCRIPTOR    ParentSD=NULL;
    SECURITY_INFORMATION    SeInfoGet;
    DWORD                   Win32rc;
    intptr_t                    hFile;
    struct _wfinddata_t     *pFileInfo=NULL;
    DWORD   dwChildIndex = 0;



    if ( ThisNode == NULL )
        return(SCESTATUS_SUCCESS);

#ifdef SCE_DBG
    wprintf(L"%s\n", ThisNode->ObjectFullName);
#endif
    //
    // if IGNORE is set, skip this node too
    //
    if ( ThisNode->Status != SCE_STATUS_CHECK &&
         ThisNode->Status != SCE_STATUS_NO_AUTO_INHERIT &&
         ThisNode->Status != SCE_STATUS_OVERWRITE )
        goto Done;

    if ( ThisNode->dwSize_aChildNames != 0) {
        ThisNode->aChildNames = (PWSTR *) LocalAlloc( LMEM_ZEROINIT,
                                                     (sizeof(PWSTR) * ThisNode->dwSize_aChildNames));

        if ( ThisNode->aChildNames == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }


    if ( ThisNode->Parent == NULL ) {

        //
        // this is the first node
        // should always use Rtl routine to compute security descriptor
        // so Creator Owner ace is translated properly.
        //

        if ( ThisNode->pSecurityDescriptor ) {
            Win32rc = ScepGetNewSecurity(
                                ThisNode->ObjectFullName,
                                NULL, // parent's SD
                                ThisNode->pSecurityDescriptor,
                                0,    // does not query current object SD
                                (BOOLEAN)(ThisNode->IsContainer),
                                ThisNode->SeInfo,
                                ObjectType,
                                Token,
                                GenericMapping,
                                &(ThisNode->pApplySecurityDescriptor)
                                );
            if ( Win32rc != NO_ERROR ) {
                ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_BUILD_SD,
                             ThisNode->ObjectFullName );
                rc = ScepDosErrorToSceStatus(Win32rc);
                goto Done;
            }

        } else {
            //
            // no explicit security specified for this node
            //
            ThisNode->pApplySecurityDescriptor = NULL;
        }

        goto ProcChild;
    }

    //
    // process children nodes
    //
    if ( ThisNode->pSecurityDescriptor != NULL ||
         ThisNode->Parent->pApplySecurityDescriptor != NULL ) {

        if ( ObjectType == SE_FILE_OBJECT && NULL == ThisNode->ChildList ) {
            //
            // detect if this is a file (non-container object)
            //
            pFileInfo = (struct _wfinddata_t *)ScepAlloc(0,sizeof(struct _wfinddata_t));
            if ( pFileInfo == NULL ) {

                //
                // out of memory, treat it as a container for now and
                // will error out later.
                //

                ThisNode->IsContainer = TRUE;

            } else {

                hFile = _wfindfirst(ThisNode->ObjectFullName, pFileInfo);
                ThisNode->IsContainer = FALSE;
                if ( hFile != -1 )
                {
                    _findclose(hFile);
                    if ( pFileInfo->attrib & _A_SUBDIR &&
                         ( 0 == ( pFileInfo->attrib & 
                                  FILE_ATTRIBUTE_REPARSE_POINT ))) // bug 635098: don't propagate permissions 
                                                                   // across junction points)
                    {
                        ThisNode->IsContainer = TRUE;
                    }
                }

                ScepFree(pFileInfo);
                pFileInfo = NULL;
            }

        } else {

            ThisNode->IsContainer = TRUE;
        }

        //
        // even if the security descriptor is protected,
        // still need to call ScepNewSecurity to get CREATOR OWNER ace
        // translated correctly.
        //

        //
        // if this is the first explicit node in this branch,
        // the pApplySecurityDescriptor of the parent must be NULL.
        //

        if ( ThisNode->Parent->pApplySecurityDescriptor == NULL ) {

            //
            // yes, this is the first explicit node.
            // get the current system's setting on the parent node
            // have to use Win32 api because it will compute all inherited
            // security information from all parents automatically
            //

            SeInfoGet = 0;
            if ( ThisNode->SeInfo & DACL_SECURITY_INFORMATION )
                SeInfoGet |= DACL_SECURITY_INFORMATION;

            if ( ThisNode->SeInfo & SACL_SECURITY_INFORMATION )
                SeInfoGet |= SACL_SECURITY_INFORMATION;

            Win32rc = GetNamedSecurityInfo(
                                ThisNode->Parent->ObjectFullName,
                                ObjectType,
                                SeInfoGet,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                &ParentSD
                                );
/*
            Win32rc = ScepGetNamedSecurityInfo(
                        ThisNode->Parent->ObjectFullName,
                        ObjectType,
                        SeInfoGet,
                        &ParentSD
                        );
*/
            if ( Win32rc != NO_ERROR &&
                Win32rc != ERROR_FILE_NOT_FOUND &&
                Win32rc != ERROR_PATH_NOT_FOUND &&
                Win32rc != ERROR_ACCESS_DENIED &&
                Win32rc != ERROR_CANT_ACCESS_FILE &&
                Win32rc != ERROR_SHARING_VIOLATION ) {

                ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_QUERY_SECURITY,
                             ThisNode->Parent->ObjectFullName );
                rc = ScepDosErrorToSceStatus(Win32rc);
                goto Done;
            }

        } else {
            ParentSD = ThisNode->Parent->pApplySecurityDescriptor;
            //
            // owner/group information are not inheritable
            //
            if ( ThisNode->Parent->SeInfo & DACL_SECURITY_INFORMATION )
                ThisNode->SeInfo |= DACL_SECURITY_INFORMATION;
            if ( ThisNode->Parent->SeInfo & SACL_SECURITY_INFORMATION )
                ThisNode->SeInfo |= SACL_SECURITY_INFORMATION;
        }

        //
        // compute the new security descriptor with inherited aces from the parentSD
        // if the status is SCE_STATUS_CHECK (auto inherit), need to query the current
        // object's security descriptor if no explicit SD is specified
        // (ThisNode->pSecurityDescriptor is NULL)
        //

        Win32rc = ScepGetNewSecurity(
                        ThisNode->ObjectFullName,
                        ParentSD,
                        ThisNode->pSecurityDescriptor,
                        (BYTE)(( ThisNode->Status == SCE_STATUS_CHECK ) ? SCETREE_QUERY_SD : 0),
                        (BOOLEAN)(ThisNode->IsContainer),
                        ThisNode->SeInfo,
                        ObjectType,
                        Token,
                        GenericMapping,
                        &(ThisNode->pApplySecurityDescriptor)
                        );

        if ( ParentSD &&
             ParentSD != ThisNode->Parent->pApplySecurityDescriptor ) {
            //
            // free the parent security descriptor if it's allocated here
            //
            LocalFree(ParentSD);
        }

        if ( ERROR_SUCCESS == Win32rc ||
             ERROR_FILE_NOT_FOUND == Win32rc ||
             ERROR_PATH_NOT_FOUND == Win32rc ||
             ERROR_ACCESS_DENIED == Win32rc ||
             ERROR_CANT_ACCESS_FILE == Win32rc ||
             ERROR_SHARING_VIOLATION == Win32rc ) {

            rc = SCESTATUS_SUCCESS;
        } else {
            ScepLogOutput3(1, Win32rc,
                         SCEDLL_ERROR_BUILD_SD,
                         ThisNode->ObjectFullName
                         );
            rc = ScepDosErrorToSceStatus(Win32rc);
            goto Done;
        }

    }

ProcChild:
    //
    // then process left child
    //

    for ( PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
          pTemp != NULL; pTemp = pTemp->Next ) {

        if ( pTemp->Node == NULL ) continue;

        ThisNode->aChildNames[dwChildIndex] = pTemp->Node->Name;

        ++dwChildIndex;

        rc = ScepCalculateSecurityToApply(
                        pTemp->Node,
                        ObjectType,
                        Token,
                        GenericMapping
                        );

        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    //
    // in case there are lesser child names than initially calcluated
    //

    if (dwChildIndex < ThisNode->dwSize_aChildNames) {

        ThisNode->dwSize_aChildNames = dwChildIndex;

    }

Done:

    return(rc);

}


DWORD
ScepGetNewSecurity(
    IN LPTSTR ObjectName,
    IN PSECURITY_DESCRIPTOR pParentSD OPTIONAL,
    IN PSECURITY_DESCRIPTOR pObjectSD OPTIONAL,
    IN BYTE nFlag,
    IN BOOLEAN bIsContainer,
    IN SECURITY_INFORMATION SeInfo,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *ppNewSD
    )
/*
Routine Description:

    This routine will compute a security descriptor based on parent's security
    descriptor and the explicit security descriptor for the object. If no owner
    information is specified in the object's security descriptor, this routine
    will query the current owner of the object on the system so CREATOR_OWNER
    ace can be translated into the proper ace based on the owner.

Arguments:

    ObjectName - the object's full name

    pParentSD - optional security descriptor of the parent

    pObjectSD - optional explicit security descriptor of this object

    SeInfo    - security information contained in the object's SD

    bIsContainer - if the object is a container

    pNewSD - the new computed security descriptor address

Return Value:

    NTSTATUS of this operation
*/
{

    BOOL        bOwner;
    BOOLEAN     tFlag;
    BOOLEAN     aclPresent;
    PSID        pOwner=NULL;
    PACL        pDacl=NULL;
    PACL        pSacl=NULL;
    SECURITY_DESCRIPTOR     SD;
    PSECURITY_DESCRIPTOR    pCurrentSD=NULL;
    DWORD       Win32rc;
    NTSTATUS    NtStatus;
    SECURITY_DESCRIPTOR_CONTROL Control;
    ULONG Revision;

    if ( !ppNewSD ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // In case there is no RPC call causing us to enter here, there
    // is no impersonation happening and the current thread is already
    // running under Local System context in which case there is no
    // need to RevertToSelf() etc. as below.
    // This behavior happens when, for example, the server side itself
    // initiates a configuration
    //

    if ( !gbQueriedIfSystemContext ) {

        //
        // if any error happens when checking if running under system context,
        // continue - since there will be impersonation errors later on in
        // this routine
        //

        NtStatus = ScepIsSystemContext(
                                              Token,
                                              &gbIsSystemContext);

        if (ERROR_SUCCESS == RtlNtStatusToDosError(NtStatus)) {

            gbQueriedIfSystemContext = TRUE;

        }

    }

    if ( nFlag == SCETREE_QUERY_SD &&
         !pObjectSD ) {
        //
        // current object's security descriptor is used, for SeInfo | OWNER
        // NOTE: the inherited ace from pCurrentSD are not copied (which is correct).
        //

        Win32rc = GetNamedSecurityInfo(
                        ObjectName,
                        ObjectType,
                        SeInfo | OWNER_SECURITY_INFORMATION,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &pCurrentSD
                        );
/*
        Win32rc = ScepGetNamedSecurityInfo(
                        ObjectName,
                        ObjectType,
                        SeInfo | OWNER_SECURITY_INFORMATION,
                        &pCurrentSD
                        );
*/
        //
        // RtlNewSecurityObjectEx must be called on the process context (system)
        // because it will try to get process information inside the api.
        //

        if (!gbIsSystemContext) {

            RpcRevertToSelf();

        }

        if ( ERROR_SUCCESS == Win32rc ||
             ERROR_FILE_NOT_FOUND == Win32rc ||
             ERROR_PATH_NOT_FOUND == Win32rc ) {

            //
            // use the current SD to compute
            //
            NtStatus = RtlNewSecurityObjectEx(
                        pParentSD,
                        pCurrentSD,
                        ppNewSD,
                        NULL, // GUID
                        bIsContainer,
                        SEF_DACL_AUTO_INHERIT |
                        SEF_SACL_AUTO_INHERIT |
                        SEF_AVOID_OWNER_CHECK |
                        SEF_AVOID_PRIVILEGE_CHECK,
                        Token,
                        GenericMapping
                        );
            Win32rc = RtlNtStatusToDosError(NtStatus);
        }

        if ( pCurrentSD ) {
            ScepFree(pCurrentSD);
        }

    } else {

        //
        // RtlNewSecurityObjectEx must be called on the process context (system)
        // because it will try to get process information inside the api.
        //

        if (!gbIsSystemContext) {

            RpcRevertToSelf();

        }

        if ( pObjectSD ) {
            //
            // check if there is a owner
            //

            NtStatus = RtlGetOwnerSecurityDescriptor(
                              pObjectSD,
                              &pOwner,
                              &tFlag);
            if ( NT_SUCCESS(NtStatus) && pOwner && !tFlag ) {
                bOwner = TRUE;
            } else {
                bOwner = FALSE;
            }

        } else {
            //
            // no owner
            //
            bOwner = FALSE;
        }

        if ( !bOwner ) {
            //
            // query owner information only
            //
            Win32rc = ScepGetNamedSecurityInfo(
                            ObjectName,
                            ObjectType,
                            OWNER_SECURITY_INFORMATION,
                            &pCurrentSD
                            );

            if ( ERROR_SUCCESS == Win32rc ) {

                NtStatus = RtlGetOwnerSecurityDescriptor(
                                  pCurrentSD,
                                  &pOwner,
                                  &tFlag);
                Win32rc = RtlNtStatusToDosError(NtStatus);
            }

            if ( ERROR_FILE_NOT_FOUND == Win32rc ||
                 ERROR_PATH_NOT_FOUND == Win32rc ) {
                Win32rc = ERROR_SUCCESS;
            }

            if ( ERROR_SUCCESS == Win32rc ) {

                //
                // build a security descriptor to use
                //

                if ( SeInfo & DACL_SECURITY_INFORMATION &&
                     pObjectSD ) {

                    //
                    // Get DACL address
                    //
                    Win32rc = RtlNtStatusToDosError(
                                  RtlGetDaclSecurityDescriptor(
                                                pObjectSD,
                                                &aclPresent,
                                                &pDacl,
                                                &tFlag));
                    if (Win32rc == NO_ERROR && !aclPresent ) {
                        pDacl = NULL;
                    }
                }


                if ( ERROR_SUCCESS == Win32rc &&
                     (SeInfo & SACL_SECURITY_INFORMATION) &&
                     pObjectSD ) {

                    //
                    // Get SACL address
                    //

                    Win32rc = RtlNtStatusToDosError(
                                  RtlGetSaclSecurityDescriptor(
                                                pObjectSD,
                                                &aclPresent,
                                                &pSacl,
                                                &tFlag));
                    if ( Win32rc == NO_ERROR && !aclPresent ) {
                        pSacl = NULL;
                    }
                }

                if ( ERROR_SUCCESS == Win32rc ) {

                    //
                    // build an absolute security descriptor
                    //
                    NtStatus = RtlCreateSecurityDescriptor( &SD,
                                            SECURITY_DESCRIPTOR_REVISION );
                    if ( NT_SUCCESS(NtStatus) ) {

                        //
                        // set control field
                        //

                        if ( pObjectSD ) {

                            NtStatus = RtlGetControlSecurityDescriptor (
                                            pObjectSD,
                                            &Control,
                                            &Revision
                                            );
                            if ( NT_SUCCESS(NtStatus) ) {

                                Control &= SE_VALID_CONTROL_BITS;
                                NtStatus = RtlSetControlSecurityDescriptor (
                                                &SD,
                                                Control,
                                                Control
                                                );
                            }
                        }

                        //
                        // set owner first
                        //

                        if ( pOwner ) {
                            NtStatus = RtlSetOwnerSecurityDescriptor (
                                            &SD,
                                            pOwner,
                                            FALSE
                                            );
                        }

                        if ( NT_SUCCESS(NtStatus) ) {
                            //
                            // set DACL and SACL pointer to this SD
                            //
                            if ( SeInfo & DACL_SECURITY_INFORMATION && pDacl ) {

                                NtStatus = RtlSetDaclSecurityDescriptor (
                                                &SD,
                                                TRUE,
                                                pDacl,
                                                FALSE
                                                );
                            }

                            if ( NT_SUCCESS(NtStatus) &&
                                 (SeInfo & SACL_SECURITY_INFORMATION) && pSacl ) {

                                NtStatus = RtlSetSaclSecurityDescriptor (
                                                &SD,
                                                TRUE,
                                                pSacl,
                                                FALSE
                                                );
                            }
                        }

                        //
                        // now compute the new security descriptor
                        //

                        if ( NT_SUCCESS(NtStatus) ) {

                            NtStatus = RtlNewSecurityObjectEx(
                                        pParentSD,
                                        &SD,
                                        ppNewSD,
                                        NULL, // GUID
                                        bIsContainer,
                                        SEF_DACL_AUTO_INHERIT |
                                        SEF_SACL_AUTO_INHERIT |
                                        SEF_AVOID_OWNER_CHECK |
                                        SEF_AVOID_PRIVILEGE_CHECK,
                                        Token,
                                        GenericMapping
                                        );

                        }
                    }

                    Win32rc = RtlNtStatusToDosError(NtStatus);
                }
            }

            if ( pCurrentSD ) {
                //
                // this owner needs to be freed
                //
                LocalFree(pCurrentSD);
            }

        } else {

            //
            // there is a SD and there is a owner in it, just use it
            //
            NtStatus = RtlNewSecurityObjectEx(
                        pParentSD,
                        pObjectSD,
                        ppNewSD,
                        NULL, // GUID
                        bIsContainer,
                        SEF_DACL_AUTO_INHERIT |
                        SEF_SACL_AUTO_INHERIT |
                        SEF_AVOID_OWNER_CHECK |
                        SEF_AVOID_PRIVILEGE_CHECK,
                        Token,
                        GenericMapping
                        );

            Win32rc = RtlNtStatusToDosError(NtStatus);
        }

    }

    RPC_STATUS RpcStatus = RPC_S_OK;

    if (!gbIsSystemContext) {

        RpcStatus = RpcImpersonateClient( NULL );

    }

    if ( RpcStatus != RPC_S_OK ) {

        Win32rc = I_RpcMapWin32Status(RpcStatus);
    }

    if ( NO_ERROR != Win32rc &&
         *ppNewSD ) {
        //
        // free the buffer if there is an error
        //
        RtlDeleteSecurityObject(ppNewSD);
        *ppNewSD = NULL;
    }

    return(Win32rc);
}


DWORD
ScepAddAutoInheritRequest(
    IN OUT PSECURITY_DESCRIPTOR pSD,
    IN OUT SECURITY_INFORMATION *pSeInfo
    )
{

    SECURITY_DESCRIPTOR_CONTROL Control;
    SECURITY_DESCRIPTOR_CONTROL ToSet;
    ULONG Revision;
    NTSTATUS NtStatus;

    DWORD Win32rc=NO_ERROR;

    if ( !pSeInfo )
        return(ERROR_INVALID_PARAMETER);

    if ( pSD != NULL &&
         (*pSeInfo & DACL_SECURITY_INFORMATION ||
         *pSeInfo & SACL_SECURITY_INFORMATION) ) {

        NtStatus = RtlGetControlSecurityDescriptor (
                        pSD,
                        &Control,
                        &Revision
                        );
        if ( !NT_SUCCESS(NtStatus) ) {

            Win32rc = RtlNtStatusToDosError(NtStatus);

        } else {

            if ( !(Control & SE_DACL_PRESENT) )
                *pSeInfo &= ~DACL_SECURITY_INFORMATION;

            if ( !(Control & SE_SACL_PRESENT) )
                *pSeInfo &= ~SACL_SECURITY_INFORMATION;

            if ( *pSeInfo & (DACL_SECURITY_INFORMATION |
                             SACL_SECURITY_INFORMATION) ) {

                ToSet = 0;
                if ( *pSeInfo & DACL_SECURITY_INFORMATION ) {

                    ToSet |= (SE_DACL_AUTO_INHERIT_REQ |
                                SE_DACL_AUTO_INHERITED);
                }

                if ( *pSeInfo & SACL_SECURITY_INFORMATION) {

                    ToSet |= (SE_SACL_AUTO_INHERIT_REQ |
                                SE_SACL_AUTO_INHERITED);
                }

                if ( ToSet ) {
                    ((SECURITY_DESCRIPTOR *)pSD)->Control &= ~ToSet;
                    ((SECURITY_DESCRIPTOR *)pSD)->Control |= ToSet;
/*
                    NtStatus = RtlSetControlSecurityDescriptor (
                                pSD,
                                ToSet,
                                ToSet
                                );
                    Win32rc = RtlNtStatusToDosError(NtStatus);
*/
                }
            }

        }

    }

    return(Win32rc);
}



DWORD
ScepDoesObjectHasChildren(
    IN SE_OBJECT_TYPE ObjectType,
    IN PWSTR ObjectName,
    OUT PBOOL pbHasChildren
    )
{
    PWSTR Name=NULL;
    DWORD rc=NO_ERROR;
    DWORD Len;
    intptr_t            hFile;
    struct _wfinddata_t    FileInfo;
    HKEY hKey;
    DWORD cSubKeys=0;


    if ( ObjectName == NULL || pbHasChildren == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *pbHasChildren = TRUE;  // default

    if ( ObjectType == SE_FILE_OBJECT ) {
        //
        // detect if this is a container for file system
        //
        Len = wcslen(ObjectName);
        Name = (PWSTR)ScepAlloc(0, (Len+5)*sizeof(WCHAR) );

        if ( Name != NULL ) {

            swprintf(Name, L"%s\\*.*", ObjectName);
            Name[Len+4] = L'\0';

            hFile = _wfindfirst(Name, &FileInfo);

            if ( hFile == -1 ||
                 0 != ( GetFileAttributes(ObjectName) & 
                        FILE_ATTRIBUTE_REPARSE_POINT )) // bug 635098: don't propagate permissions 
                                                        // across junction points
            {
                *pbHasChildren = FALSE;
            }

            if ( -1 != hFile)
            {
                _findclose(hFile);
            }

            ScepFree(Name);

        } else
            rc = ERROR_NOT_ENOUGH_MEMORY;

#ifdef _WIN64
    } else if ( ObjectType == SE_REGISTRY_KEY || ObjectType == SE_REGISTRY_WOW64_32KEY) {
#else
    } else if ( ObjectType == SE_REGISTRY_KEY) {
#endif

        rc = ScepOpenRegistryObject(
                    ObjectType,
                    (LPWSTR)ObjectName,
                    KEY_READ,
                    &hKey
                    );

        if ( rc == NO_ERROR ) {

            cSubKeys = 0;

            rc = RegQueryInfoKey (
                        hKey,
                        NULL,
                        NULL,
                        NULL,
                        &cSubKeys,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );

            if ( rc == NO_ERROR && cSubKeys == 0 ) {
                *pbHasChildren = FALSE;
            }

            RegCloseKey(hKey);
        }
    }

    return(rc);
}


SCESTATUS
ScepConfigureObjectTree(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    IN DWORD ConfigOptions
    )
/* ++
Routine Description:

    This routine set security information to each node in the tree and objects of
    the container if SCE_STATUS_OVERWRITE is set.

Arguments:

    ThisNode - one node in the tree

    ObjectType - type of the object (SE_FILE_OBJECT, SE_REGISTRY_KEY)

    Token - The current process/thread's token (for computing new security descriptors)

    GenericMapping - The access mask mappings from generic access rights to object
                    specific access rights.

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_OTHER_ERROR (see the log file for detail error)

-- */
{
    // two error codes to distinguish between config status of "ThisNode" and "ThisNode's children"
    DWORD rcThisNodeOnly = ERROR_SUCCESS;
    DWORD rcThisNodeChildren = ERROR_SUCCESS;

    if ( ThisNode == NULL )
        return(SCESTATUS_SUCCESS);

    //
    // if IGNORE is set, skip this node, but post progress on it
    //
    if ( ThisNode->pSecurityDescriptor != NULL ) {
        //
        // notify the progress bar if there is any
        //
        switch(ObjectType) {
        case SE_FILE_OBJECT:
            ScepPostProgress(1, AREA_FILE_SECURITY, ThisNode->ObjectFullName);
            break;
        case SE_REGISTRY_KEY:
#ifdef _WIN64
        case SE_REGISTRY_WOW64_32KEY:
#endif
            ScepPostProgress(1, AREA_REGISTRY_SECURITY, ThisNode->ObjectFullName);
            break;
        default:
            ScepPostProgress(1, 0, ThisNode->ObjectFullName);
            break;
        }
    }

    SCESTATUS       rc=SCESTATUS_SUCCESS;
    DWORD           Win32Rc=ERROR_SUCCESS;

    if ( ThisNode->Status != SCE_STATUS_CHECK &&
         ThisNode->Status != SCE_STATUS_NO_AUTO_INHERIT &&
         ThisNode->Status != SCE_STATUS_OVERWRITE )
        goto SkipNode;

    if ( ThisNode->pSecurityDescriptor != NULL ) {

        ScepLogOutput3(2, 0, SCEDLL_SCP_CONFIGURE, ThisNode->ObjectFullName);
    }

    //
    // Process this node first
    // Note: we do not set NULL security descriptor
    //

    if ( ThisNode->pApplySecurityDescriptor != NULL ) {

        if ( ThisNode->pSecurityDescriptor == NULL ) {
            ScepLogOutput3(3, 0, SCEDLL_SCP_CONFIGURE, ThisNode->ObjectFullName);
        }

        BOOL            BackSlashExist=FALSE;

        if ( ThisNode->Status == SCE_STATUS_NO_AUTO_INHERIT ) {
            //
            // no auto inherit to children. Apply to this object only
            // this flag is removed since 2/20/1998
            //
            Win32Rc = ScepSetSecurityObjectOnly(
                        ThisNode->ObjectFullName,
                        ThisNode->SeInfo,
                        ThisNode->pApplySecurityDescriptor,
                        ObjectType,
                        NULL
                        );

            rcThisNodeOnly = Win32Rc;

        } else if ( ThisNode->ChildList == NULL &&
                    ThisNode->Status != SCE_STATUS_OVERWRITE ) {
            //
            // there is no children
            // apply security to everyone underneeth, using the win32 api.
            //
            Win32Rc = ScepDoesObjectHasChildren(ObjectType,
                                              ThisNode->ObjectFullName,
                                              &BackSlashExist // temp use
                                              );
            if ( Win32Rc == NO_ERROR ) {

                if ( BackSlashExist ) {
                    //
                    // this is a container which has children
                    //

                    //
                    // new marta API without considering parent
                    //
                    Win32Rc = AccRewriteSetNamedRights(
                                                      ThisNode->ObjectFullName,
                                                      ObjectType,
                                                      ThisNode->SeInfo,
                                                      ThisNode->pApplySecurityDescriptor,
                                                      TRUE    // bSkipInheritanceComputation
                                                      );
/*
                    Win32Rc = ScepSetSecurityWin32(
                            ThisNode->ObjectFullName,
                            ThisNode->SeInfo,
                            ThisNode->pApplySecurityDescriptor,
                            ObjectType
                            );
*/
                } else {
                    //
                    // no children
                    //
                    Win32Rc = ScepSetSecurityObjectOnly(
                                ThisNode->ObjectFullName,
                                ThisNode->SeInfo,
                                ThisNode->pApplySecurityDescriptor,
                                ObjectType,
                                NULL
                                );
                }

            } else {
                ScepLogOutput3(1, Win32Rc, SCEDLL_SAP_ERROR_ENUMERATE,
                             ThisNode->ObjectFullName);
            }

            rcThisNodeOnly = Win32Rc;

        } else {

            //
            // there is child(ren) in the tree, or OVERWRITE flag is set
            //


            Win32Rc = ScepDoesObjectHasChildren(ObjectType,
                                              ThisNode->ObjectFullName,
                                              &BackSlashExist // temp use
                                              );

            rcThisNodeOnly = Win32Rc;

            if ( Win32Rc != ERROR_SUCCESS ) {
                //
                // for registry keys, the above function could fail if the key does
                // not exist. Log the error in this case
                //
                ScepLogOutput3(1, Win32Rc, SCEDLL_SAP_ERROR_ENUMERATE,
                             ThisNode->ObjectFullName);

            }
            if ( Win32Rc == ERROR_SUCCESS && !BackSlashExist ) {
                //
                // no child exist
                //
                if (ThisNode->Status == SCE_STATUS_OVERWRITE ) {

                    //
                    // if OVERWRITE flag set and no children, set now (top-down)
                    // if OVERWRITE flag and has children then share logic with 0 mode, set later (bottom-up)
                    // maybe we can have all OVERWRITE mode go bottom-up if goto SkipNode is removed here
                    //

                    Win32Rc = ScepSetSecurityObjectOnly(
                                ThisNode->ObjectFullName,
                                ThisNode->SeInfo,
                                ThisNode->pApplySecurityDescriptor,
                                ObjectType,
                                &BackSlashExist
                                );

                    rcThisNodeOnly = rcThisNodeOnly == NO_ERROR ? Win32Rc: rcThisNodeOnly;

                }

                goto SkipNode;
            }

            if ( Win32Rc == ERROR_SUCCESS && BackSlashExist ) {

                //
                // set security for other files/keys under this directory
                //
                //
                // child exist, set child node first
                // set security for other files/keys under this directory
                //

                switch ( ObjectType ) {
                case SE_FILE_OBJECT:

                    //
                    // detect if there is a \ at the end
                    //
                    BackSlashExist = ScepLastBackSlash(ThisNode->ObjectFullName);

                    Win32Rc = ScepConfigureOneSubTreeFile(ThisNode,
                                                      ObjectType,
                                                      Token,
                                                      GenericMapping,
                                                      BackSlashExist
                                                      );
                    break;

                case SE_REGISTRY_KEY:
#ifdef _WIN64
                case SE_REGISTRY_WOW64_32KEY:
#endif

                    //
                    // process this key and any sub keys
                    //

                    Win32Rc = ScepConfigureOneSubTreeKey(ThisNode,
                                                ObjectType,
                                                Token,
                                                GenericMapping
                                               );
                    break;
                }


                //
                // this rc is the status for configuration of children of ThisNode
                //
                rcThisNodeChildren = Win32Rc;

            }
        }

        //
        // ignore some error codes and continue to configure other objects
        //
        if ( SCEP_IGNORE_SOME_ERRORS(Win32Rc) ) {

            gWarningCode = Win32Rc;
            rc = SCESTATUS_SUCCESS;
            goto SkipNode;
        }

        if ( Win32Rc != ERROR_SUCCESS ) {
            //
            // if security for this object was specified in the config template/database, log to RSOP status
            //

            if (ThisNode->pSecurityDescriptor && (ConfigOptions & SCE_RSOP_CALLBACK) ) {

                ScepRsopLog(ObjectType == SE_FILE_OBJECT ?
                            SCE_RSOP_FILE_SECURITY_INFO :
                            SCE_RSOP_REGISTRY_SECURITY_INFO,
                            rcThisNodeOnly,
                            ThisNode->ObjectFullName,0,0);

                if (rcThisNodeOnly == ERROR_SUCCESS && rcThisNodeChildren != ERROR_SUCCESS) {

                    ScepRsopLog(ObjectType == SE_FILE_OBJECT ?
                                (SCE_RSOP_FILE_SECURITY_INFO | SCE_RSOP_FILE_SECURITY_INFO_CHILD) :
                                (SCE_RSOP_REGISTRY_SECURITY_INFO | SCE_RSOP_REGISTRY_SECURITY_INFO_CHILD),
                                rcThisNodeChildren,
                                ThisNode->ObjectFullName,0,0);
                }

            }

            return(ScepDosErrorToSceStatus(Win32Rc));
        }

    }


    //
    // then process children
    //

    for ( PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
          pTemp != NULL; pTemp = pTemp->Next ) {

        if ( pTemp->Node == NULL ) continue;

        rc = ScepConfigureObjectTree(
                                    pTemp->Node,
                                    ObjectType,
                                    Token,
                                    GenericMapping,
                                    ConfigOptions
                                    );
        Win32Rc = ScepSceStatusToDosError(rc);

        //
        // ignore some error codes and continue to configure other objects
        //
        if (  SCEP_IGNORE_SOME_ERRORS(Win32Rc) ) {

            gWarningCode = Win32Rc;
            Win32Rc = ERROR_SUCCESS;
            rc = SCESTATUS_SUCCESS;
        }

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

    }

    if ( ThisNode->pApplySecurityDescriptor != NULL &&
         ThisNode->Status != SCE_STATUS_NO_AUTO_INHERIT &&
         ( ThisNode->ChildList != NULL ||
           ThisNode->Status == SCE_STATUS_OVERWRITE ) ) {

        //
        // finally config the current node - (post order)
        //

        Win32Rc = ScepSetSecurityObjectOnly(
                ThisNode->ObjectFullName,
                ThisNode->SeInfo,
                ThisNode->pApplySecurityDescriptor,
                ObjectType,
                NULL
                );

        rc = ScepDosErrorToSceStatus(Win32Rc);

        rcThisNodeOnly = rcThisNodeOnly == NO_ERROR ? Win32Rc: rcThisNodeOnly;

        //
        // ignore the following error codes and continue to configure other objects
        //
        if ( SCEP_IGNORE_SOME_ERRORS(Win32Rc) ) {

            gWarningCode = Win32Rc;
            Win32Rc = ERROR_SUCCESS;
            rc = SCESTATUS_SUCCESS;
        }
    }



SkipNode:

    //
    // if security for this object was specified in the config template/database, log to RSOP status
    //

    if (ThisNode->pSecurityDescriptor && (ConfigOptions & SCE_RSOP_CALLBACK) ) {

        ScepRsopLog(ObjectType == SE_FILE_OBJECT ?
                    SCE_RSOP_FILE_SECURITY_INFO :
                    SCE_RSOP_REGISTRY_SECURITY_INFO,
                    rcThisNodeOnly,
                    ThisNode->ObjectFullName,0,0);

        if (rcThisNodeOnly == ERROR_SUCCESS && rcThisNodeChildren != ERROR_SUCCESS) {

            ScepRsopLog(ObjectType == SE_FILE_OBJECT ?
                        (SCE_RSOP_FILE_SECURITY_INFO | SCE_RSOP_FILE_SECURITY_INFO_CHILD) :
                        (SCE_RSOP_REGISTRY_SECURITY_INFO | SCE_RSOP_REGISTRY_SECURITY_INFO_CHILD),
                        rcThisNodeChildren,
                        ThisNode->ObjectFullName,0,0);
        }

    }

    return(rc);

}


DWORD
ScepConfigureOneSubTreeFile(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOL BackSlashExist
    )
{

    if ( NULL == ThisNode ) {
        return(ERROR_SUCCESS);
    }

    DWORD           BufSize;
    PWSTR           Buffer=NULL;

    //
    // find all files under this directory/file
    //

    BufSize = wcslen(ThisNode->ObjectFullName)+4;
    Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
    if ( Buffer == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    if ( BackSlashExist ) {
        swprintf(Buffer, L"%s*.*", ThisNode->ObjectFullName);
    } else {
        swprintf(Buffer, L"%s\\*.*", ThisNode->ObjectFullName);
    }

    intptr_t            hFile;
    struct _wfinddata_t    *pFileInfo=NULL;

    //
    // allocate the find buffer
    //
    pFileInfo = (struct _wfinddata_t *)ScepAlloc(0,sizeof(struct _wfinddata_t));
    if ( pFileInfo == NULL ) {
        ScepFree(Buffer);
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    hFile = _wfindfirst(Buffer, pFileInfo);

    ScepFree(Buffer);
    Buffer = NULL;

    DWORD  Win32Rc = ERROR_SUCCESS;
    BOOL    bFilePresentInTree;

    if ( hFile != -1 &&
         0 == ( GetFileAttributes(ThisNode->ObjectFullName)& 
             FILE_ATTRIBUTE_REPARSE_POINT )) // bug 635098: don't propagate permissions 
                                             // across junction points)
        {
        PSCE_OBJECT_CHILD_LIST pTemp;
        INT             i;
        DWORD           EnumRc;
        PSECURITY_DESCRIPTOR pChildrenSD=NULL;

        do {
            if ( pFileInfo->name[0] == L'.' && 
                 (pFileInfo->name[1] == L'\0' || (pFileInfo->name[1] == L'.' && pFileInfo->name[2] == L'\0')))
                continue;

            bFilePresentInTree = ScepBinarySearch(
                                                 ThisNode->aChildNames,
                                                 ThisNode->dwSize_aChildNames,
                                                 pFileInfo->name);

            if ( ! bFilePresentInTree ) {

                //
                // The name is not in the list, so set.
                // build the full name first
                //

                BufSize = wcslen(ThisNode->ObjectFullName)+wcslen(pFileInfo->name)+1;
                Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                if ( Buffer == NULL ) {
                    Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                if ( BackSlashExist ) {

                    swprintf(Buffer, L"%s%s", ThisNode->ObjectFullName, pFileInfo->name);
                } else {

                    swprintf(Buffer, L"%s\\%s", ThisNode->ObjectFullName, pFileInfo->name);
                }
                EnumRc = pFileInfo->attrib; // borrow this variable temperaorily

                ScepFree(pFileInfo);
                pFileInfo = NULL;


                //
                // compute the SDs for each individual object
                //
                Win32Rc = ScepGetNewSecurity(
                                    Buffer,
                                    ThisNode->pApplySecurityDescriptor, // parent's SD
                                    NULL,
                                    (BYTE)((ThisNode->Status != SCE_STATUS_OVERWRITE ) ? SCETREE_QUERY_SD : 0),
                                    (BOOLEAN)(EnumRc & _A_SUBDIR),
                                    ThisNode->SeInfo,
                                    ObjectType,
                                    Token,
                                    GenericMapping,
                                    &pChildrenSD
                                    );

                if (Win32Rc == ERROR_SHARING_VIOLATION ||
                    Win32Rc == ERROR_ACCESS_DENIED ||
                    Win32Rc == ERROR_CANT_ACCESS_FILE) {

                    ScepLogOutput3(1, Win32Rc, SCEDLL_ERROR_BUILD_SD, Buffer);
                }

                if ( Win32Rc == NO_ERROR ) {

                    if ( !(EnumRc & _A_SUBDIR) ) {

                        // this is a single file
                        //

                        Win32Rc = ScepSetSecurityObjectOnly(
                                    Buffer,
                                    (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                    (ThisNode->SeInfo & SACL_SECURITY_INFORMATION),
                                    pChildrenSD,
                                    ObjectType,
                                    NULL
                                    );

                    } else if ( ThisNode->Status == SCE_STATUS_OVERWRITE ) {

                        //
                        // enumerate all nodes under this one and "empty" explicit aces by
                        // calling NtSetSecurityInfo directly but please note
                        // Creator Owner Ace should be reserved
                        //

                        Win32Rc = ScepSetSecurityOverwriteExplicit(
                                    Buffer,
                                    (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                    (ThisNode->SeInfo & SACL_SECURITY_INFORMATION),
                                    pChildrenSD,
                                    ObjectType,
                                    Token,
                                    GenericMapping
                                    );
                    } else {
                        //
                        // new marta API without considering parent
                        //
                        Win32Rc = AccRewriteSetNamedRights(
                                                Buffer,
                                                ObjectType,
                                                ThisNode->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                                                pChildrenSD,
                                                TRUE    // bSkipInheritanceComputation
                                                );
                        /*
                        Win32Rc = ScepSetSecurityWin32(
                                    Buffer,
                                    (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                    (ThisNode->SeInfo & SACL_SECURITY_INFORMATION),
                                    pChildrenSD,
                                    ObjectType
                                    );
                       */

                        if ( Win32Rc != ERROR_SUCCESS ) {
                            //
                            // something is wrong to set inheritance info, log it
                            // but still continue to the next one
                            //
                            gWarningCode = Win32Rc;

                            Win32Rc = NO_ERROR;

                        }
                    }

                }

                ScepFree(Buffer);
                Buffer = NULL;

                //
                // free the SD pointers allocated for this object
                //
                if ( pChildrenSD != NULL )
                    RtlDeleteSecurityObject( &pChildrenSD );

                pChildrenSD = NULL;

                if (Win32Rc == ERROR_FILE_NOT_FOUND ||
                    Win32Rc == ERROR_PATH_NOT_FOUND ||
                    Win32Rc == ERROR_SHARING_VIOLATION ||
                    Win32Rc == ERROR_ACCESS_DENIED ||
                    Win32Rc == ERROR_CANT_ACCESS_FILE ) {

                    gWarningCode = Win32Rc;

                    Win32Rc = NO_ERROR;
                } else if ( Win32Rc != ERROR_SUCCESS )
                    break;

                pFileInfo = (struct _wfinddata_t *)ScepAlloc(0,sizeof(struct _wfinddata_t));
                if ( pFileInfo == NULL ) {
                    Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

            }
        } while ( _wfindnext(hFile, pFileInfo) == 0 );

        _findclose(hFile);

        //
        // free memory if allocated
        //
        if ( pChildrenSD != NULL &&
             pChildrenSD != ThisNode->pApplySecurityDescriptor ) {

            RtlDeleteSecurityObject( &pChildrenSD );
            pChildrenSD = NULL;
        }

    }

    if ( pFileInfo != NULL ) {
        ScepFree(pFileInfo);
        pFileInfo = NULL;
    }

    if ( Buffer != NULL ) {
        ScepFree(Buffer);
        Buffer = NULL;
    }

    return(Win32Rc);
}


DWORD
ScepConfigureOneSubTreeKey(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    )
{

    if ( NULL == ThisNode ) {
        return(ERROR_SUCCESS);
    }

    HKEY            hKey=NULL;
    DWORD           Win32Rc;

    DWORD           SubKeyLen;
    PWSTR           Buffer1=NULL;

    //
    // open the key
    //

    Win32Rc = ScepOpenRegistryObject(
                ObjectType,
                ThisNode->ObjectFullName,
                KEY_READ,
                &hKey
                );

    if ( Win32Rc == ERROR_SUCCESS ) {

        SubKeyLen = 0;
        Win32Rc = RegQueryInfoKey (
                    hKey,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &SubKeyLen,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
    } else {
        ScepLogOutput3(1, Win32Rc, SCEDLL_ERROR_OPEN, ThisNode->ObjectFullName );
    }

    if ( Win32Rc == ERROR_SUCCESS ) {

        //
        // enumerate all subkeys of the key
        //
        Buffer1 = (PWSTR)ScepAlloc(0, (SubKeyLen+2)*sizeof(WCHAR));
        if ( Buffer1 == NULL ) {
            Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( Win32Rc == ERROR_SUCCESS ) {

        DWORD           index;
        DWORD           EnumRc;
        DWORD           BufSize;

        PSCE_OBJECT_CHILD_LIST pTemp;
        INT             i;
        PWSTR           Buffer=NULL;
        PSECURITY_DESCRIPTOR pChildrenSD=NULL;
        BOOL    bKeyPresentInTree;

        index = 0;

        do {

            BufSize = SubKeyLen+1;
            memset(Buffer1, L'\0', (SubKeyLen+2)*sizeof(WCHAR));

            EnumRc = RegEnumKeyEx(hKey,
                            index,
                            Buffer1,
                            &BufSize,
                            NULL,
                            NULL,
                            NULL,
                            NULL);

            if ( EnumRc == ERROR_SUCCESS ) {

                index++;
                //
                // find if the subkey is already in the tree
                // if it is in the tree, it will be processed later
                //

                bKeyPresentInTree = ScepBinarySearch(
                                                    ThisNode->aChildNames,
                                                    ThisNode->dwSize_aChildNames,
                                                    Buffer1);

                if ( ! bKeyPresentInTree ) {
                    //
                    // The name is not in the list, so set
                    // build the fullname first
                    //
                    BufSize += wcslen(ThisNode->ObjectFullName)+1;
                    Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                    if ( Buffer == NULL ) {
                        Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                    swprintf(Buffer, L"%s\\%s", ThisNode->ObjectFullName, Buffer1);

                    ScepLogOutput3(3, 0, SCEDLL_SCP_CONFIGURE, Buffer);

                    //
                    // compute the SDs for each individual object
                    //
                    Win32Rc = ScepGetNewSecurity(
                                        Buffer,
                                        ThisNode->pApplySecurityDescriptor, // parent's SD
                                        NULL,
                                        (BYTE)((ThisNode->Status != SCE_STATUS_OVERWRITE ) ? SCETREE_QUERY_SD : 0),
                                        (BOOLEAN)TRUE,
                                        ThisNode->SeInfo,
                                        ObjectType,
                                        Token,
                                        GenericMapping,
                                        &pChildrenSD
                                        );

                    if (Win32Rc == ERROR_SHARING_VIOLATION ||
                        Win32Rc == ERROR_ACCESS_DENIED ||
                        Win32Rc == ERROR_CANT_ACCESS_FILE) {

                        ScepLogOutput3(1, Win32Rc, SCEDLL_ERROR_BUILD_SD, Buffer);
                    }

                    if ( Win32Rc == ERROR_SUCCESS ) {
                        if ( ThisNode->Status == SCE_STATUS_OVERWRITE ) {

                            //
                            // enumerate all nodes under this one and "empty" explicit aces by
                            // calling NtSetSecurityInfo directly
                            //

                            Win32Rc = ScepSetSecurityOverwriteExplicit(
                                        Buffer,
                                        (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                        (ThisNode->SeInfo & SACL_SECURITY_INFORMATION),
                                        pChildrenSD,
                                        ObjectType,
                                        Token,
                                        GenericMapping
                                        );
                        } else {

                            //
                            // new marta API without considering parent
                            //
                            Win32Rc = AccRewriteSetNamedRights(
                                                    Buffer,
                                                    ObjectType,
                                                    ThisNode->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                                                    pChildrenSD,
                                                    TRUE    // bSkipInheritanceComputation
                                                    );

                            /*
                            Win32Rc = ScepSetSecurityWin32(
                                        Buffer,
                                        (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                        (ThisNode->SeInfo & SACL_SECURITY_INFORMATION),
                                        pChildrenSD,  // ThisNode->pApplySecurityDescriptor, calculate autoinheritance
                                        ObjectType
                                        );
                            */

                            if ( Win32Rc != ERROR_SUCCESS ) {
                                //
                                // can't set inheritance to children, log it but continue
                                //
                                gWarningCode = Win32Rc;

                                Win32Rc = NO_ERROR;
                            }
                        }

                    }
                    if ( pChildrenSD != NULL ) {
                        RtlDeleteSecurityObject( &pChildrenSD );
                        pChildrenSD = NULL;
                    }

                    if ( Win32Rc == ERROR_FILE_NOT_FOUND ||
                         Win32Rc == ERROR_INVALID_HANDLE ||
                         Win32Rc == ERROR_PATH_NOT_FOUND ||
                         Win32Rc == ERROR_ACCESS_DENIED ||
                         Win32Rc == ERROR_CANT_ACCESS_FILE ||
                         Win32Rc == ERROR_SHARING_VIOLATION ) {

                        gWarningCode = Win32Rc;
                        Win32Rc = NO_ERROR;
                    }

                    if ( Win32Rc != ERROR_SUCCESS )
                        ScepLogOutput3(1, Win32Rc, SCEDLL_ERROR_SET_SECURITY, Buffer);

                    ScepFree(Buffer);
                    Buffer = NULL;

                    if ( Win32Rc != ERROR_SUCCESS )
                        break;
                }

            } else if ( EnumRc != ERROR_NO_MORE_ITEMS ) {
                break;
            }
        } while ( EnumRc != ERROR_NO_MORE_ITEMS );

        ScepFree(Buffer1);
        Buffer1 = NULL;

        if ( EnumRc != ERROR_SUCCESS && EnumRc != ERROR_NO_MORE_ITEMS ) {

            ScepLogOutput3(1, EnumRc, SCEDLL_SAP_ERROR_ENUMERATE,
                         ThisNode->ObjectFullName );
            if ( Win32Rc == ERROR_SUCCESS )
                Win32Rc = EnumRc;

        }

        //
        // free memory if allocated
        //
        if ( pChildrenSD != NULL &&
             pChildrenSD != ThisNode->pApplySecurityDescriptor ) {

            RtlDeleteSecurityObject( &pChildrenSD );
            pChildrenSD = NULL;
        }
        if ( Buffer != NULL ) {
            ScepFree(Buffer);
            Buffer = NULL;
        }

    }

    if ( hKey ) {
        RegCloseKey(hKey);
    }

    return(Win32Rc);

}


SCESTATUS
ScepFreeObject2Security(
    IN PSCE_OBJECT_CHILD_LIST  NodeList,
    IN BOOL bFreeComputedSDOnly
    )
/* ++
Routine Description:

    This routine frees memory allocated by the security object tree.

Arguments:

    ThisNode - one node in the tree

Return value:

    None

-- */
{
    NTSTATUS  NtStatus;
    SCESTATUS  rc;


    if ( NodeList == NULL )
        return(SCESTATUS_SUCCESS);

    PSCE_OBJECT_CHILD_LIST pTemp,pTemp1;
    PSCE_OBJECT_TREE ThisNode;

    //
    // free children first
    //
    pTemp = NodeList;

    while ( pTemp != NULL ) {
        if ( pTemp->Node ) {

            ThisNode = pTemp->Node;

            rc = ScepFreeObject2Security(ThisNode->ChildList, bFreeComputedSDOnly);
            //
            // both security descriptors need to be freed for SAP/SMP type
            //
            if ( ThisNode->pApplySecurityDescriptor != NULL &&
                 ThisNode->pApplySecurityDescriptor != ThisNode->pSecurityDescriptor ) {

                NtStatus = RtlDeleteSecurityObject(
                                &(ThisNode->pApplySecurityDescriptor)
                                );
                ThisNode->pApplySecurityDescriptor = NULL;
            }

            if (!bFreeComputedSDOnly) {

                if ( ThisNode->pSecurityDescriptor != NULL )
                    ScepFree(ThisNode->pSecurityDescriptor);

                if ( ThisNode->Name != NULL)
                    ScepFree(ThisNode->Name);

                if ( ThisNode->ObjectFullName != NULL )
                    ScepFree(ThisNode->ObjectFullName);

                if ( ThisNode->aChildNames != NULL ) {
                    LocalFree(ThisNode->aChildNames);
                }

                ScepFree(ThisNode);
            }

        }

        pTemp1 = pTemp;
        pTemp = pTemp->Next;

        if (!bFreeComputedSDOnly) {
            ScepFree(pTemp1);
        }
    }

    return(SCESTATUS_SUCCESS);
}


DWORD
ScepSetSecurityWin32(
    IN PCWSTR ObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType
    )
/* ++
Routine Description:

    This routine set security information to the object and inherited aces
    are set to the object's children by calling Win32 API SetNamedSecurityInfo


Arguments:

    ObjecName  - name of the object to set security to

    SeInfo     - Security information to set

    pSecurityDescriptor - the security descriptor

    ObjectType - type of the object
                      SE_FILE_OBJECT
                      SE_REGISTRY_KEY
                      SE_DS_OBJECT

Return value:

    Win32 error code

-- */
{

    if ( !ObjectName || !pSecurityDescriptor || SeInfo == 0 ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD       Win32rc = NO_ERROR;
    SECURITY_INFORMATION SeInfoSet;


    BOOLEAN     tFlag;
    BOOLEAN     aclPresent = FALSE;
    PSID        pOwner=NULL;
    PSID        pGroup=NULL;
    PACL        pDacl=NULL;
    PACL        pSacl=NULL;
    SECURITY_DESCRIPTOR_CONTROL Control=0;

    if ( pSecurityDescriptor != NULL ) {

        RtlGetControlSecurityDescriptor (
                pSecurityDescriptor,
                &Control,
                &Win32rc  // temp use
                );
        //
        // Get Owner address
        // always get the owner in case take ownership occurs
        //
        Win32rc = RtlNtStatusToDosError(
                      RtlGetOwnerSecurityDescriptor(
                                pSecurityDescriptor,
                                &pOwner,
                                &tFlag));
#if 0
        //
        // Get Group address
        //

        if ( SeInfo & GROUP_SECURITY_INFORMATION ) {
            Win32rc = RtlNtStatusToDosError(
                         RtlGetGroupSecurityDescriptor(
                                 pSecurityDescriptor,
                                 &pGroup,
                                 &tFlag));
        }
#endif
        //
        // Get DACL address
        //

        if ( SeInfo & DACL_SECURITY_INFORMATION ) {
            Win32rc = RtlNtStatusToDosError(
                          RtlGetDaclSecurityDescriptor(
                                        pSecurityDescriptor,
                                        &aclPresent,
                                        &pDacl,
                                        &tFlag));
            if (Win32rc == NO_ERROR && !aclPresent )
                pDacl = NULL;
        }


        //
        // Get SACL address
        //

        if ( SeInfo & SACL_SECURITY_INFORMATION ) {
            Win32rc = RtlNtStatusToDosError(
                          RtlGetSaclSecurityDescriptor(
                                        pSecurityDescriptor,
                                        &aclPresent,
                                        &pSacl,
                                        &tFlag));
            if ( Win32rc == NO_ERROR && !aclPresent )
                pSacl = NULL;
        }
    }

    //
    // if error occurs for this one, do not set. return
    //

    if ( Win32rc != NO_ERROR ) {

        ScepLogOutput3(1, Win32rc, SCEDLL_INVALID_SECURITY, (PWSTR)ObjectName );
        return(Win32rc);
    }
    //
    // set permission
    //
#ifdef SCE_DBG
    printf("Calling SetNamedSecurityInfo:\n");
    ScepPrintSecurityDescriptor( pSecurityDescriptor, TRUE );
#endif
    //
    // should set owner/group separately from dacl/sacl
    // if access is denied, take ownership will occur.
    //

    if ( Win32rc != NO_ERROR ) {
        //
        // ignore the error code from setting owner/group
        //
        Win32rc = NO_ERROR;
    }

    //
    // set DACL/SACL
    //
    SeInfoSet = 0;

    if ( (SeInfo & DACL_SECURITY_INFORMATION) && pDacl ) {

        SeInfoSet |= DACL_SECURITY_INFORMATION;

        if ( Control & SE_DACL_PROTECTED ) {
            SeInfoSet |= PROTECTED_DACL_SECURITY_INFORMATION;
        }
    }

    if ( (SeInfo & SACL_SECURITY_INFORMATION) && pSacl ) {

        SeInfoSet |= SACL_SECURITY_INFORMATION;

        if ( Control & SE_SACL_PROTECTED ) {
            SeInfoSet |= PROTECTED_SACL_SECURITY_INFORMATION;
        }
    }

    Win32rc = SetNamedSecurityInfo(
                        (LPWSTR)ObjectName,
                        ObjectType,
                        SeInfoSet,
                        NULL,
                        NULL,
                        pDacl,
                        pSacl
                        );

    if ( (Win32rc == ERROR_ACCESS_DENIED || Win32rc == ERROR_CANT_ACCESS_FILE) && NULL != AdminsSid ) {
        //
        // access denied, take ownership and then set
        // should backup the old owner first
        // NOTE: the old owner of this object is already stored in pOwner
        // (pSecurityDescritor) which is queried from ScepGetNewSecurity(...
        //

        ScepLogOutput3(3,0, SCEDLL_SCP_TAKE_OWNER, (LPWSTR)ObjectName);

        Win32rc = SetNamedSecurityInfo(
                            (LPWSTR)ObjectName,
                            ObjectType,
                            OWNER_SECURITY_INFORMATION,
                            AdminsSid,
                            NULL,
                            NULL,
                            NULL
                            );

        if ( Win32rc == NO_ERROR ) {
            //
            // ownership is changed, then set security again
            //
            Win32rc = SetNamedSecurityInfo(
                                (LPWSTR)ObjectName,
                                ObjectType,
                                SeInfoSet,
                                NULL,
                                NULL,
                                pDacl,
                                pSacl
                                );

            //
            // set the old owner back (later)
            //
        } else {

            ScepLogOutput3(2,Win32rc, SCEDLL_ERROR_TAKE_OWNER, (LPWSTR)ObjectName);
        }

    } else {
        //
        // no takeownership action is taken
        //
        if ( !(SeInfo & OWNER_SECURITY_INFORMATION) ) {
            pOwner = NULL;
        }
    }

    if ( Win32rc != NO_ERROR ) {
        ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_SET_SECURITY,
                     (PWSTR)ObjectName );
    } else {

        if ( pOwner != NULL || pGroup != NULL ) {
            if ( pOwner != NULL )
                SeInfoSet = OWNER_SECURITY_INFORMATION;
            else
                SeInfoSet = 0;
            if ( pGroup != NULL )
                SeInfoSet |= GROUP_SECURITY_INFORMATION;

            Win32rc = SetNamedSecurityInfo(
                            (LPWSTR)ObjectName,
                            ObjectType,
                            SeInfoSet,
                            pOwner,
                            pGroup,
                            NULL,
                            NULL
                            );
        }

    }


/*
#if 0

#ifdef SCE_DBG
    printf("Calling SetNamedSecurityInfoEx:\n");
    ScepPrintSecurityDescriptor( pSecurityDescriptor, TRUE );
#endif

    //
    // convert to the new structure
    //
    PACTRL_ACCESS       pAccess=NULL;
    PACTRL_AUDIT        pAudit=NULL;
    LPWSTR              pOwner=NULL;
    LPWSTR              pGroup=NULL;

    Win32rc = ConvertSecurityDescriptorToAccessNamed(
                        ObjectName,
                        ObjectType,
                        pSecurityDescriptor,
                        &pAccess,
                        &pAudit,
                        &pOwner,
                        &pGroup
                        );

    if ( Win32rc == ERROR_SUCCESS ) {

        //
        // set DACL/SACL
        //
        SeInfoSet = (SeInfo & DACL_SECURITY_INFORMATION) |
                    (SeInfo & SACL_SECURITY_INFORMATION);

        Win32rc = SetNamedSecurityInfoEx(
                                ObjectName,
                                ObjectType,
                                SeInfoSet,
                                NULL,
                                pAccess,
                                pAudit,
                                NULL,
                                NULL,
                                NULL
                                );

        if ( (Win32rc == ERROR_ACCESS_DENIED || Win32rc == ERROR_CANT_ACCESS_FILE) && NULL != AdminsSid ) {
            //
            // access denied, take ownership and then set
            // should backup the old owner first
            // NOTE: the old owner of this object is already stored in pOwner
            // (pSecurityDescritor) which is queried from ScepGetNewSecurity(...
            //

            ScepLogOutput3(3,0, SCEDLL_SCP_TAKE_OWNER, (LPWSTR)ObjectName);

            Win32rc = SetNamedSecurityInfo(
                                (LPWSTR)ObjectName,
                                ObjectType,
                                OWNER_SECURITY_INFORMATION,
                                AdminsSid,
                                NULL,
                                NULL,
                                NULL
                                );

            if ( Win32rc == NO_ERROR ) {
                //
                // ownership is changed, then set security again
                //
                Win32rc = SetNamedSecurityInfoEx(
                                        ObjectName,
                                        ObjectType,
                                        SeInfoSet,
                                        NULL,
                                        pAccess,
                                        pAudit,
                                        NULL,
                                        NULL,
                                        NULL
                                        );

                //
                // set the old owner back (later)
                //
            } else {

                ScepLogOutput3(2,Win32rc, SCEDLL_ERROR_TAKE_OWNER, (LPWSTR)ObjectName);
            }
        }

        if ( Win32rc != NO_ERROR ) {
            ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_SET_SECURITY,
                         (PWSTR)ObjectName );
        } else {

            if ( pOwner != NULL || pGroup != NULL ) {
                if ( pOwner != NULL )
                    SeInfoSet = OWNER_SECURITY_INFORMATION;
                else
                    SeInfoSet = 0;
                if ( pGroup != NULL )
                    SeInfoSet |= GROUP_SECURITY_INFORMATION;

                Win32rc = SetNamedSecurityInfoEx(
                                        ObjectName,
                                        ObjectType,
                                        SeInfoSet,
                                        NULL,
                                        NULL,
                                        NULL,
                                        pOwner,
                                        pGroup,
                                        NULL
                                        );
            }

        }
    }

    if ( pAccess ) {
        LocalFree(pAccess);
    }

    if ( pAudit ) {
        LocalFree(pAudit);
    }

    if ( pGroup ) {
        LocalFree(pGroup);
    }

    if ( pOwner ) {
        LocalFree(pOwner);
    }
#endif
*/

    if (Win32rc == ERROR_FILE_NOT_FOUND ||
        Win32rc == ERROR_PATH_NOT_FOUND ||
        Win32rc == ERROR_SHARING_VIOLATION ||
        Win32rc == ERROR_ACCESS_DENIED ||
        Win32rc == ERROR_CANT_ACCESS_FILE ||
        Win32rc == ERROR_INVALID_HANDLE ) {

        gWarningCode = Win32rc;

        Win32rc = NO_ERROR;
    }

    return(Win32rc);
}


DWORD
ScepSetSecurityOverwriteExplicit(
    IN PCWSTR pszRootObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    )
/*
Routine Description:

    This routine will set security to the current object and all children.
    By calling this function, the existing security descriptor for all children
    will be totally replaced by pSecurityDescriptor if it is a container, or by
    pObjectSecurity if it is a file object.

    The difference between this function and SetNamedSecurityInfo is that
    SetNamedSecurityInfo only overwrites the inherited aces for all children
    but not the explicit aces.

Arguments:

    ObjectName - The container object's name

    SeInfo     - Security Information to set

    pSecurityDescriptor - Security descriptor for container type objects

    ObjectType - The object type
                        SE_FILE_OBJECT
                        SE_REGISTRY_KEY

Return Value:

    Win32 error codes
*/
{

    PSCEP_STACK_NODE pStackHead = NULL;
    DWORD           rc;
    BOOL    bPushedOntoStack = FALSE;

    //
    // for file objects - to avoid excessive heap operations
    //
    struct _wfinddata_t FileInfo = {0};

    //
    // for registry objects - to avoid excessive heap operations
    //

    WCHAR           Buffer1[261];
    PWSTR   ObjectName = NULL;

    Buffer1[0] = L'\0';

    rc = ScepStackNodePush(&pStackHead,
                                (PWSTR)pszRootObjectName,
                                pSecurityDescriptor);

    if (rc == ERROR_SUCCESS ) {

        while (pStackHead) {

            ScepStackNodePop(&pStackHead,
                             &ObjectName,
                             &pSecurityDescriptor);

#ifdef SCE_DBG
            ScepDumpStack(&pStackHead);
#endif

            BOOL            bHasChild=FALSE;

            //
            // set security to the current object first
            //
#ifdef _WIN64
            rc = ScepSetSecurityObjectOnly(
                                          ObjectName,
                                          SeInfo,
                                          pSecurityDescriptor,
                                          ObjectType,
                                          (ObjectType == SE_REGISTRY_KEY || ObjectType == SE_REGISTRY_WOW64_32KEY) ? &bHasChild : NULL
                                          );
#else
            rc = ScepSetSecurityObjectOnly(
                                          ObjectName,
                                          SeInfo,
                                          pSecurityDescriptor,
                                          ObjectType,
                                          (ObjectType == SE_REGISTRY_KEY) ? &bHasChild : NULL
                                          );
#endif

            if ( rc == ERROR_ACCESS_DENIED ||
                 rc == ERROR_CANT_ACCESS_FILE ||
                 rc == ERROR_FILE_NOT_FOUND ||
                 rc == ERROR_PATH_NOT_FOUND ||
                 rc == ERROR_SHARING_VIOLATION ||
                 rc == ERROR_INVALID_HANDLE ) {

                gWarningCode = rc;


                if (ObjectName != pszRootObjectName) {

                    ScepFree(ObjectName);
                    ObjectName = NULL;

                    if (pSecurityDescriptor) {
                        RtlDeleteSecurityObject( &pSecurityDescriptor );
                        pSecurityDescriptor = NULL;
                    }
                }

                continue;
            }

            if ( rc != ERROR_SUCCESS )
                break;

            PWSTR           Buffer=NULL;
            DWORD           BufSize;
            PSECURITY_DESCRIPTOR pObjectSecurity=NULL;


            switch ( ObjectType ) {
            case SE_FILE_OBJECT:

                //
                // find all files under this directory/file
                //
                BufSize = wcslen(ObjectName)+4;
                Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                if ( Buffer == NULL ) {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                swprintf(Buffer, L"%s\\*.*", ObjectName);

                intptr_t            hFile;

                hFile = _wfindfirst(Buffer, &FileInfo);

                ScepFree(Buffer);
                Buffer = NULL;

                if ( hFile != -1 &&
                     ( 0 == ( GetFileAttributes(ObjectName) &   // bug 635098: don't propagate permissions
                              FILE_ATTRIBUTE_REPARSE_POINT )))  // across junction points 
                {

                    do {
                        if (FileInfo.name[0] == L'.' && 
                            (FileInfo.name[1] == L'\0' || 
                             (FileInfo.name[1] == L'.' && 
                              FileInfo.name[2] == L'\0')))
                            continue;

                        //
                        // build the full name for this object
                        //
                        BufSize = wcslen(ObjectName)+wcslen(FileInfo.name)+1;
                        Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                        if ( Buffer == NULL ) {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }
                        swprintf(Buffer, L"%s\\%s", ObjectName, FileInfo.name);

                        //
                        // compute the new security descriptor because
                        // different objects may have different owner and
                        // the creator owner ace must be translated correctly
                        //

                        pObjectSecurity = NULL;

                        rc = ScepGetNewSecurity(
                                               Buffer,
                                               pSecurityDescriptor, // parent's SD
                                               NULL,  // object SD
                                               0,    // does not query current object SD
                                               (BOOLEAN)(FileInfo.attrib & _A_SUBDIR ),
                                               SeInfo,
                                               ObjectType,
                                               Token,
                                               GenericMapping,
                                               &pObjectSecurity
                                               );

                        if ( ERROR_SUCCESS  == rc ) {

                            if ( FileInfo.attrib & _A_SUBDIR ) {


                                //
                                // enumerate all nodes under this one and "empty" explicit aces by
                                // calling NtSetSecurityInfo directly
                                //
                                /*rc = ScepSetSecurityOverwriteExplicit(
                                                                     Buffer,
                                                                     SeInfo,
                                                                     pObjectSecurity,
                                                                     ObjectType,
                                                                     Token,
                                                                     GenericMapping
                                                                     );*/

                                rc = ScepStackNodePush(&pStackHead,
                                                            Buffer,
                                                            pObjectSecurity);

                                if (rc == ERROR_SUCCESS)
                                    bPushedOntoStack = TRUE;

                            } else {
                                //
                                // this is a file. Set the file security descriptor to this object
                                // using NT api
                                //
                                rc = ScepSetSecurityObjectOnly(
                                                              Buffer,
                                                              SeInfo,
                                                              pObjectSecurity,
                                                              ObjectType,
                                                              NULL
                                                              );
                                if ( rc == ERROR_ACCESS_DENIED ||
                                     rc == ERROR_CANT_ACCESS_FILE ||
                                     rc == ERROR_FILE_NOT_FOUND ||
                                     rc == ERROR_PATH_NOT_FOUND ||
                                     rc == ERROR_SHARING_VIOLATION ||
                                     rc == ERROR_INVALID_HANDLE ) {

                                    gWarningCode = rc;
                                    rc = NO_ERROR;
                                }
                            }

                        } else if ( ERROR_ACCESS_DENIED == rc ) {

                            ScepLogOutput3(1, rc, SCEDLL_ERROR_QUERY_SECURITY, Buffer);

                            //
                            // if fail to query security due to access problem
                            // ignore this subtree and continue
                            //
                            rc = ERROR_SUCCESS;
                        }

                        if ( !bPushedOntoStack ) {

                            if (pObjectSecurity) {
                                RtlDeleteSecurityObject( &pObjectSecurity );
                                pObjectSecurity = NULL;
                            }

                            if (Buffer) {
                                ScepFree(Buffer);
                                Buffer = NULL;
                            }

                        }

                        bPushedOntoStack = FALSE;


                        if ( rc != ERROR_SUCCESS )
                            break;

                    } while ( _wfindnext(hFile, &FileInfo) == 0 );

                    _findclose(hFile);
                }

                break;

            case SE_REGISTRY_KEY:
#ifdef _WIN64
            case SE_REGISTRY_WOW64_32KEY:
#endif

                if ( bHasChild ) {

                    HKEY            hKey;

                    //
                    // open the key
                    //
                    rc = ScepOpenRegistryObject(
                                               ObjectType,
                                               (LPWSTR)ObjectName,
                                               KEY_READ,
                                               &hKey
                                               );

                    if ( rc == ERROR_SUCCESS ) {

                        DWORD           SubKeyLen;
                        DWORD           cSubKeys;

                        cSubKeys = 0;

                        rc = RegQueryInfoKey (
                                             hKey,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &cSubKeys,
                                             &SubKeyLen,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL
                                             );

                        if ( rc != NO_ERROR ) {

                            ScepLogOutput3(1, rc, SCEDLL_ERROR_QUERY_INFO, (PWSTR)ObjectName );

                            cSubKeys = 0;
                            SubKeyLen = 0;

                            rc = NO_ERROR;
                        }

                        if ( cSubKeys && SubKeyLen ) {

                            DWORD           index;
                            DWORD           EnumRc;

                            index = 0;
                            //
                            // enumerate all subkeys of the key
                            //

                            do {
                                BufSize = 260;

                                EnumRc = RegEnumKeyEx(hKey,
                                                      index,
                                                      Buffer1,
                                                      &BufSize,
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      NULL);

                                if ( EnumRc == ERROR_SUCCESS ) {
                                    index++;

                                    BufSize += wcslen(ObjectName)+1;
                                    Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                                    if ( Buffer == NULL ) {
                                        rc = ERROR_NOT_ENOUGH_MEMORY;
                                        break;
                                    }
                                    swprintf(Buffer, L"%s\\%s", ObjectName, Buffer1);

                                    //
                                    // compute the new security descriptor because
                                    // different objects may have different owner and
                                    // the creator owner ace must be translated correctly
                                    //

                                    pObjectSecurity = NULL;

                                    rc = ScepGetNewSecurity(
                                                           Buffer,
                                                           pSecurityDescriptor, // parent's SD
                                                           NULL,  // object SD
                                                           0,    // does not query current object SD
                                                           (BOOLEAN)TRUE,
                                                           SeInfo,
                                                           ObjectType,
                                                           Token,
                                                           GenericMapping,
                                                           &pObjectSecurity
                                                           );

                                    if ( ERROR_SUCCESS == rc ) {

                                        //
                                        // enumerate all nodes under this one and "empty" explicit aces by
                                        // calling NtSetSecurityInfo directly
                                        //
                                        /*rc = ScepSetSecurityOverwriteExplicit(
                                                                             Buffer,
                                                                             SeInfo,
                                                                             pObjectSecurity,
                                                                             ObjectType,
                                                                             Token,
                                                                             GenericMapping
                                                                             );*/

                                        rc = ScepStackNodePush(&pStackHead,
                                                                    Buffer,
                                                                    pObjectSecurity);

                                        if (rc == ERROR_SUCCESS)
                                            bPushedOntoStack = TRUE;

                                    } else if ( ERROR_ACCESS_DENIED == rc ) {

                                        ScepLogOutput3(1, rc, SCEDLL_ERROR_QUERY_SECURITY, Buffer);

                                        //
                                        // if fail to query security of this key
                                        // ignore this subtree and continue
                                        //

                                        rc = ERROR_SUCCESS;
                                    }

                                    if ( rc != ERROR_SUCCESS )
                                        ScepLogOutput3(1, rc, SCEDLL_ERROR_SET_SECURITY, Buffer);

                                    if ( !bPushedOntoStack ) {

                                        if ( pObjectSecurity ) {

                                            RtlDeleteSecurityObject( &pObjectSecurity );
                                            pObjectSecurity = NULL;
                                        }

                                        ScepFree(Buffer);
                                        Buffer = NULL;
                                    }

                                    bPushedOntoStack = FALSE;

                                    if ( rc != ERROR_SUCCESS )
                                        break;

                                } else if ( EnumRc != ERROR_NO_MORE_ITEMS ) {
                                    break;
                                }

                            } while ( EnumRc != ERROR_NO_MORE_ITEMS );

                            if ( EnumRc != ERROR_SUCCESS && EnumRc != ERROR_NO_MORE_ITEMS ) {
                                ScepLogOutput3(1, EnumRc, SCEDLL_SAP_ERROR_ENUMERATE, (PWSTR)ObjectName );
                                if ( rc == ERROR_SUCCESS )
                                    rc = EnumRc;

                            }
                        }

                        RegCloseKey(hKey);

                    } else
                        ScepLogOutput3(1, rc, SCEDLL_ERROR_OPEN, (PWSTR)ObjectName );
                }

                break;
            }

            if (ObjectName != pszRootObjectName) {

                ScepFree(ObjectName);
                ObjectName = NULL;

                if (pSecurityDescriptor) {
                    RtlDeleteSecurityObject( &pSecurityDescriptor );
                    pSecurityDescriptor = NULL;
                }
            }

        }

        if ( rc != ERROR_SUCCESS ) {
            ScepFreeStack(&pStackHead);
        }

    }

    return(rc);

}

VOID
ScepFreeStack(
    IN PSCEP_STACK_NODE    *ppStackHead
    )
{
    if (ppStackHead == NULL || *ppStackHead == NULL )
        return;

    PSCEP_STACK_NODE    pNode;

    while ( pNode = *ppStackHead ) {
        ScepFree( pNode->Buffer );
        RtlDeleteSecurityObject( &(pNode->pObjectSecurity) );
        *ppStackHead = pNode->Next;
        LocalFree(pNode);
    }
    return;
}

VOID
ScepDumpStack(
    IN PSCEP_STACK_NODE    *ppStackHead
    )
{
    if (ppStackHead == NULL || *ppStackHead == NULL )
        return;

    PSCEP_STACK_NODE    pNode = *ppStackHead;

    wprintf(L"\n >>>>>>>>> Stack contents");

    while ( pNode ) {
        if ( pNode->Buffer)
            wprintf(L"\n     %s", pNode->Buffer );
        pNode = pNode->Next;
    }
    return;
}


DWORD
ScepStackNodePush(
    IN PSCEP_STACK_NODE    *ppStackHead,
    IN PWSTR   pszObjectName,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{

    if (ppStackHead == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    PSCEP_STACK_NODE    pNode = (PSCEP_STACK_NODE) LocalAlloc(LMEM_ZEROINIT, sizeof(SCEP_STACK_NODE));

    if ( pNode == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    pNode->Buffer = pszObjectName;
    pNode->pObjectSecurity = pSecurityDescriptor;
    pNode->Next = *ppStackHead;
    *ppStackHead = pNode;

#ifdef SCE_DBG
    gDbgNumPushed ++;
#endif

    return ERROR_SUCCESS;

}

VOID
ScepStackNodePop(
    IN OUT PSCEP_STACK_NODE    *ppStackHead,
    IN OUT PWSTR   *ppszObjectName,
    IN OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    )
{
    if (ppStackHead == NULL ||
        *ppStackHead == NULL ||
        ppszObjectName == NULL ||
        ppSecurityDescriptor == NULL )
        return;

    PSCEP_STACK_NODE    pNode = *ppStackHead;

    *ppszObjectName =  pNode->Buffer;
    *ppSecurityDescriptor = pNode->pObjectSecurity;
    *ppStackHead = pNode->Next;

    LocalFree(pNode);

#ifdef SCE_DBG
    gDbgNumPopped ++;
#endif

    return;

}


DWORD
ScepSetSecurityObjectOnly(
    IN PCWSTR ObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType,
    OUT PBOOL pbHasChild
    )
/* ++
Routine Description:

    This routine set security information to the object only. Security
    for children of this object is not set.

Arguments:

    ObjecName  - name of the object to set security to

    SeInfo     - Security information to set

    pSecurityDescriptor - the security descriptor

    ObjectType - type of the object (FILE, REGISTRY, ...)

Return value:

    Win32 error code

-- */
{
    DWORD       rc=ERROR_SUCCESS;
    HANDLE      Handle=NULL;
    NTSTATUS    NtStatus;
    DWORD       cSubKeys;
    SECURITY_INFORMATION SeInfoToSet=0;
    SECURITY_DESCRIPTOR SD;

#ifdef SCE_DBG
    UCHAR psdbuffer[1024];
    PISECURITY_DESCRIPTOR psecuritydescriptor = (PISECURITY_DESCRIPTOR) psdbuffer;
    ULONG bytesneeded = 0;
    ULONG newbytesneeded;

    printf("Before calling NtSetSecurityObject:\n");
    ScepPrintSecurityDescriptor( pSecurityDescriptor, TRUE );
#endif

    //
    // make a absolute format security descriptor which only contains AdminsSid
    // as the owner.
    //

    switch ( ObjectType ) {
    case SE_FILE_OBJECT:
        //
        // open file object. If it can't be opend due to access denied,
        // take ownership then open again.
        //
        rc = ScepOpenFileObject(
                    (LPWSTR)ObjectName,
                    ScepGetDesiredAccess(MODIFY_ACCESS_RIGHTS, SeInfo),
                    &Handle
                    );

        if ( (rc == ERROR_ACCESS_DENIED || rc == ERROR_CANT_ACCESS_FILE) && NULL != AdminsSid ) {
            //
            // open with access to set owner
            //
            ScepLogOutput3(3,0, SCEDLL_SCP_TAKE_OWNER, (LPWSTR)ObjectName);

            rc = ScepOpenFileObject(
                        (LPWSTR)ObjectName,
                        ScepGetDesiredAccess(WRITE_ACCESS_RIGHTS, OWNER_SECURITY_INFORMATION),
                        &Handle
                        );
            if ( rc == ERROR_SUCCESS ) {
                //
                // make a absolute format of security descriptor
                // to set owner with
                // if error occurs, continue
                //

                NtStatus = RtlCreateSecurityDescriptor( &SD,
                                        SECURITY_DESCRIPTOR_REVISION );
                if ( NT_SUCCESS(NtStatus) ) {

                    NtStatus = RtlSetOwnerSecurityDescriptor (
                                        &SD,
                                        AdminsSid,
                                        FALSE
                                        );
                    if ( NT_SUCCESS(NtStatus) ) {
                        NtStatus = NtSetSecurityObject(
                                            Handle,
                                            OWNER_SECURITY_INFORMATION,
                                            &SD
                                            );
                    }
                }

                rc = RtlNtStatusToDosError(NtStatus);

                CloseHandle(Handle);

                if ( rc == ERROR_SUCCESS ) {

                    //
                    // old owner of the object is already stored in the security descriptor
                    // passed in, which is created from ScepGetNewSecurity...
                    //
                    SeInfoToSet = OWNER_SECURITY_INFORMATION;

                    //
                    // re-open the file
                    //
                    rc = ScepOpenFileObject(
                                (LPWSTR)ObjectName,
                                ScepGetDesiredAccess(MODIFY_ACCESS_RIGHTS, SeInfoToSet | SeInfo), //SeInfo),
                                &Handle
                                );
                }
            }

            if ( ERROR_SUCCESS != rc ) {
                ScepLogOutput3(2, rc, SCEDLL_ERROR_TAKE_OWNER, (PWSTR)ObjectName );
            }
        }

        if (rc == ERROR_SUCCESS ) {

            //
            // set security to this object
            //

            SeInfoToSet |= SeInfo;
            ScepAddAutoInheritRequest(pSecurityDescriptor, &SeInfoToSet);

            NtStatus = NtSetSecurityObject(
                                Handle,
                                SeInfoToSet,
                                pSecurityDescriptor
                                );
            rc = RtlNtStatusToDosError(NtStatus);

#ifdef SCE_DBG
            if ( rc == NO_ERROR ) {

                printf("After calling NtSetSecurityObject:\n");

                NtStatus = NtQuerySecurityObject( Handle,
                                                   SeInfo,
                                                   psecuritydescriptor,
                                                   1024,
                                                   &bytesneeded);

                if (STATUS_BUFFER_TOO_SMALL == NtStatus)
                {
                    if (NULL != (psecuritydescriptor = (PISECURITY_DESCRIPTOR)
                                         ScepAlloc(LMEM_ZEROINIT, bytesneeded) ))

                        NtStatus = NtQuerySecurityObject(Handle,
                                              SeInfo,
                                              psecuritydescriptor,
                                              bytesneeded,
                                              &newbytesneeded);
                }
                if (NT_SUCCESS(NtStatus)) {
                    ScepPrintSecurityDescriptor( (PSECURITY_DESCRIPTOR)psecuritydescriptor, TRUE );
                } else
                    printf("error occurs: %x\n", NtStatus);

                if (bytesneeded > 1024)
                    ScepFree(psecuritydescriptor);

            }
#endif
            CloseHandle(Handle);
        }

        if ( rc == ERROR_SUCCESS && pbHasChild != NULL ) {
            ScepDoesObjectHasChildren(ObjectType, (PWSTR)ObjectName, pbHasChild);
        }

        break;

    case SE_REGISTRY_KEY:
#ifdef _WIN64
    case SE_REGISTRY_WOW64_32KEY:
#endif
        //
        // open registry object. If it can't be opened due to access denied,
        // take ownership then open again.
        //
        rc = ScepOpenRegistryObject(
                    ObjectType,
                    (LPWSTR)ObjectName,
                    ScepGetDesiredAccess(WRITE_ACCESS_RIGHTS, SeInfo),
                    (PHKEY)&Handle
                    );

        if ( (rc == ERROR_ACCESS_DENIED || rc == ERROR_CANT_ACCESS_FILE) && NULL != AdminsSid ) {

            ScepLogOutput3(3,0, SCEDLL_SCP_TAKE_OWNER, (LPWSTR)ObjectName);

            //
            // open registry object with access to set owner
            //
            rc = ScepOpenRegistryObject(
                        ObjectType,
                        (LPWSTR)ObjectName,
                        ScepGetDesiredAccess(WRITE_ACCESS_RIGHTS, OWNER_SECURITY_INFORMATION),
                        (PHKEY)&Handle
                        );
            if ( rc == ERROR_SUCCESS ) {
                //
                // make a absolute format of security descriptor
                // to set owner with
                // if error occurs, continue
                //

                NtStatus = RtlCreateSecurityDescriptor( &SD,
                                        SECURITY_DESCRIPTOR_REVISION );
                if ( NT_SUCCESS(NtStatus) ) {

                    NtStatus = RtlSetOwnerSecurityDescriptor (
                                        &SD,
                                        AdminsSid,
                                        FALSE
                                        );
                }

                if ( NT_SUCCESS(NtStatus) ) {
                    rc = RegSetKeySecurity((HKEY)Handle,
                                            OWNER_SECURITY_INFORMATION,
                                            &SD);

                } else {
                    rc = RtlNtStatusToDosError(NtStatus);
                }

                RegCloseKey((HKEY)Handle);

                if ( rc == ERROR_SUCCESS ) {

                    //
                    // old owner is already stored in the pSecurityDescriptor passed in
                    // which is created in ScepGetNewSecurity...
                    //

                    SeInfoToSet = OWNER_SECURITY_INFORMATION;
                    //
                    // re-open the registry key
                    //
                    rc = ScepOpenRegistryObject(
                                ObjectType,
                                (LPWSTR)ObjectName,
                                ScepGetDesiredAccess(WRITE_ACCESS_RIGHTS, SeInfoToSet | SeInfo),
                                (PHKEY)&Handle
                                );
                }
            }

            if ( ERROR_SUCCESS != rc ) {

                ScepLogOutput3(2, rc, SCEDLL_ERROR_TAKE_OWNER, (PWSTR)ObjectName );
            }

        }

        if (rc == ERROR_SUCCESS ) {

            //
            // set security to the registry key
            //
            SeInfoToSet |= SeInfo;
            ScepAddAutoInheritRequest(pSecurityDescriptor, &SeInfoToSet);

            rc = RegSetKeySecurity((HKEY)Handle,
                                    SeInfoToSet,
                                    pSecurityDescriptor);

            RegCloseKey((HKEY)Handle);

            //
            // query key info for subkeys first
            //
            if ( ERROR_SUCCESS == rc && pbHasChild != NULL ) {

                rc = ScepOpenRegistryObject(
                            ObjectType,
                            (LPWSTR)ObjectName,
                            KEY_READ,
                            (PHKEY)&Handle
                            );

                if ( ERROR_SUCCESS == rc ) {

                    cSubKeys = 0;

                    rc = RegQueryInfoKey (
                                (HKEY)Handle,
                                NULL,
                                NULL,
                                NULL,
                                &cSubKeys,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );

                    RegCloseKey((HKEY)Handle);
                }

                if ( rc != NO_ERROR ) {

                    ScepLogOutput3(1, rc, SCEDLL_ERROR_QUERY_INFO, (PWSTR)ObjectName );

                    cSubKeys = 0;

                    rc = NO_ERROR;
                }

                if (cSubKeys == 0 )
                    *pbHasChild = FALSE;
                else
                    // ignore the error, just set has child.
                    //
                    *pbHasChild = TRUE;

            }

        } else
            ScepLogOutput3(1, rc, SCEDLL_ERROR_OPEN, (PWSTR)ObjectName);


        break;
    }

    if ( rc != NO_ERROR )
        ScepLogOutput3(1, rc, SCEDLL_ERROR_SET_SECURITY, (PWSTR)ObjectName);

    if ( rc == ERROR_INVALID_OWNER ||
         rc == ERROR_INVALID_PRIMARY_GROUP ||
         rc == ERROR_INVALID_SECURITY_DESCR )
        rc = NO_ERROR;

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\scelogexception.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    SceLogException.cpp

Abstract:

    implementation of class SceLogException

    SceLogException is the exception class used internally
    within the SecMan dll. SecLogExceptions can be thrown
    and additional debug information can be added to
    the SecLogException each time it is caught.
    
Author:

    Steven Chan (t-schan) July 2002

--*/


#ifdef UNICODE
#define _UNICODE
#endif	

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <iostream.h>
#include "SceLogException.h"



SceLogException::SceLogException(
    IN SXERROR ErrorType, 
    IN PCWSTR szDebugInfo OPTIONAL, 
    IN PCWSTR szMoreInfo OPTIONAL,
    IN DWORD dwErrorCode
    )
/*++

Routine Description:

    Constructor for SceLogException

Arguments:
    
    ErrorType:      Type of the error
    szDebugInfo:    Info to add to the exception for debugging
    szMoreInfo:     Any additional info to be added
    dwErrorCode:    Code of the error that caused this excetion. If 
                    there is no code, this should be 0.
    
Return Value:

    none

--*/
{
    this->ErrorType = ErrorType;
    this->dwErrorCode = dwErrorCode;
    if (szDebugInfo!=NULL) {
        this->szDebugInfo = new WCHAR[wcslen(szDebugInfo)+1];
        wcscpy(this->szDebugInfo, szDebugInfo);
    } else {
        szDebugInfo=NULL;
    }
    if (szMoreInfo!=NULL) {    
        this->szMoreInfo = new WCHAR[wcslen(szMoreInfo)+1];
        wcscpy(this->szMoreInfo, szMoreInfo);
    } else {
        szDebugInfo=NULL;
    }
}




SceLogException::~SceLogException()
/*++

Routine Description:

    destructor for SceLogException

Arguments:

    none    

Return Value:

    none

--*/
{
    if (NULL!=szDebugInfo) {
        delete szDebugInfo;
    }
    if (NULL!=szMoreInfo) {
        delete szMoreInfo;
    }
    if (NULL!=szArea) {
        delete szArea;
    }
    if (NULL!=szSettingName) {
        delete szSettingName;
    }
}                




void
SceLogException::ChangeType(
    IN SXERROR ErrorType
    )
/*++

Routine Description:

    changes the type of the error

Arguments:
    
    ErrorType:  Type to change to

Return Value:

    none

--*/
{
    this->ErrorType=ErrorType;
}




void
SceLogException::AddDebugInfo(
    IN PCWSTR szDebugInfo
    )
/*++

Routine Description:

    appends more debug info to whatever is already present
    a new line is added between the old info and the new string

Arguments:
    
    szDebugInfo:    string to append
    
Return Value:

    none

--*/
{
    if (szDebugInfo!=NULL) {    
        if (this->szDebugInfo==NULL) {
            this->szDebugInfo = new WCHAR[wcslen(szDebugInfo)+1];
            if (this->szDebugInfo!=NULL) {
                wcscpy(this->szDebugInfo, szDebugInfo);
            }
        } else {
            PWSTR szTmp = this->szDebugInfo;
            this->szDebugInfo = new WCHAR[wcslen(szDebugInfo) + wcslen(szTmp) + 3];
            if (this->szDebugInfo!=NULL) {
                wcscpy(this->szDebugInfo, szDebugInfo);
                wcscat(this->szDebugInfo, L"\n\r");
                wcscat(this->szDebugInfo, szTmp);
            }
            delete szTmp;
        }
    }
}




void
SceLogException::SetSettingName(
    IN PCWSTR szSettingName
    )
/*++

Routine Description:

    set the name of the setting where this error occured

Arguments:
    
    szSettingName:  setting name
    
Return Value:

    none

--*/
{
    delete this->szSettingName;
    if (szSettingName!=NULL) {    
        this->szSettingName = new WCHAR[wcslen(szSettingName)+1];
        if (this->szSettingName!=NULL) {
            wcscpy(this->szSettingName, szSettingName);
        }
    } else {
        szSettingName=NULL;
    }
}




void
SceLogException::SetArea(
    IN PCWSTR szArea
    )
/*++

Routine Description:

    sets the name of the analysis area in which this error occured

Arguments:
    
    szArea: name of analysis area

Return Value:

    none

--*/
{
    delete this->szArea;
    if (szArea!=NULL) {    
        this->szArea = new WCHAR[wcslen(szArea)+1];
        if (this->szArea!=NULL) {
            wcscpy(this->szArea, szArea);
        }
    } else {
        szSettingName=NULL;
    }
}




void
SceLogException::AddMoreInfo(
    IN PCWSTR szMoreInfo
    )
/*++

Routine Description:

    appends more supplementary info to whatever is already present
    a new line is added between the old info and the new string

Arguments:
    
    szMoreInfo:    string to append
    
Return Value:

    none

--*/
{
    if (szMoreInfo!=NULL) {    
        if (this->szMoreInfo==NULL) {
            this->szMoreInfo = new WCHAR[wcslen(szMoreInfo)+1];
            if (szMoreInfo!=NULL) {
                wcscpy(this->szMoreInfo, szMoreInfo);
            }
        } else {
            PWSTR szTmp = this->szMoreInfo;
            this->szMoreInfo = new WCHAR[wcslen(szMoreInfo) + wcslen(szTmp) + 3];
            if (this->szMoreInfo!=NULL) {
                wcscpy(this->szMoreInfo, szMoreInfo);
                wcscat(this->szMoreInfo, L"\n\r");
                wcscat(this->szMoreInfo, szTmp);
            }
            delete szTmp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\sceanalysisreader.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    SceAnalysisReader.cpp

Abstract:

    implementation of class SceAnalysisReader
    
    SceAnalysisReader is a class that facilitates reading
    Analysis information from a SCE JET security database
    
    This analysis information can be exported with the help
    of an SceXMLLogWriter instance.
    
Author:

    Steven Chan (t-schan) July 2002

--*/


// System header files

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <shlwapi.h>

// COM/XML header files

#include <atlbase.h>

// CRT header files

#include <iostream.h>

// SCE header files

#include "secedit.h"

// SecMan header files

#include "SceXmlLogWriter.h"      
#include "resource.h"   
#include "table.h"     
#include "SceLogException.h"
#include "SceAnalysisReader.h"
#include "w2kstructdefs.h"
#include "SceProfInfoAdapter.h"



SceAnalysisReader::SceAnalysisReader(
    HMODULE hModule,
    IN  PCWSTR szFileName
    )
/*++

Routine Description:

    Constructor for class SceAnalysisReader

Arguments:
    
    hModule:    handle to module
    szFileName: File Name for Security Analysis Database to open    

Return Value:

    none

--*/
{
    ppSAPBuffer = NULL;
    ppSMPBuffer = NULL;
    hProfile = NULL;
    LogWriter = NULL;
    myModuleHandle=hModule;
    
    try {    
        //myModuleHandle=GetModuleHandle(L"SecMan");
        if (szFileName!=NULL) {
            this->szFileName = new WCHAR[wcslen(szFileName)+1];
            wcscpy(this->szFileName, szFileName);
        }
    
        // determine windows version
        OSVERSIONINFO osvi;
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx (&osvi);
        if ((osvi.dwMajorVersion == 5) && (osvi.dwMinorVersion == 0)) {
            bIsW2k = TRUE;
            SceEngineSAP = (SCETYPE) W2K_SCE_ENGINE_SAP;
            SceEngineSMP = (SCETYPE) W2K_SCE_ENGINE_SMP;
        } else {
            bIsW2k = FALSE;
            SceEngineSAP = SCE_ENGINE_SAP;
            SceEngineSMP = SCE_ENGINE_SMP;
        }
        if (osvi.dwMajorVersion < 5) {
            throw new SceLogException(SceLogException::SXERROR_OS_NOT_SUPPORTED,
                                      L"bAcceptableOS==FALSE",
                                      NULL,
                                      0);
        }
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INIT,
                                  L"bInitSuccess==FALSE",
                                  NULL,
                                  0);
    }
}




SceAnalysisReader::~SceAnalysisReader()
/*++

Routine Description:

    destructor for SceAnalysisReader
    
Arguments:

    none    

Return Value:

    none

--*/
{
    if (hProfile!=NULL) {
        SceCloseProfile(&hProfile);
        hProfile=NULL;
    }
    if (ppSAPBuffer != NULL) {
        delete ppSAPBuffer;
        ppSAPBuffer = NULL;
    }
    if (ppSMPBuffer != NULL) {
        delete ppSMPBuffer;
        ppSMPBuffer = NULL;
    }
    if (szFileName != NULL) {
        delete szFileName;
        szFileName = NULL;
    }
}



void
SceAnalysisReader::ExportAnalysis(
    IN  SceXMLLogWriter *LogWriter,
    IN  HANDLE hLogFile OPTIONAL
    )
/*++

Routine Description:

    exports the analysis information from this->filename to an outout file
    via LogWriter

Arguments:

    LogWriter:          The LogWriter to use for logging output
    hLogFile:           Error log file handle

Return Value:

    none        
    
Throws:

    SceLogException    

--*/
{
    DWORD   dwTmp;
    BOOL    bTmp;
    PWSTR	szProfDesc=NULL;
    PWSTR   szAnalysisTime=NULL;

    SCESTATUS			    rc;	
    hProfile=NULL;
    PSCE_PROFILE_INFO ppSAPPInfo = NULL;
    PSCE_PROFILE_INFO ppSMPPInfo = NULL;

    try {  

        if (LogWriter!=NULL) {
            this->LogWriter=LogWriter;
        } else {
            throw new SceLogException(SceLogException::SXERROR_INIT,
                                      L"ExtractAnalysis(ILLEGAL ARG)",
                                      NULL,
                                      0);
        }

      
        //
        // Open specified SDB file 
        //

        trace(IDS_LOG_OPEN_DATABASE, hLogFile);
        trace(szFileName,hLogFile);
        trace(L"\n\r\n\r",hLogFile);

        rc = SceOpenProfile(szFileName, SCE_JET_FORMAT, &hProfile);
        switch (rc) {
        case SCESTATUS_SUCCESS:
            break;
        case SCESTATUS_PROFILE_NOT_FOUND:
            throw new SceLogException(SceLogException::SXERROR_OPEN_FILE_NOT_FOUND,
                                      L"SceOpenProfile(szFileName, SCE_JET_FORMAT, &hProfile)",
                                      NULL,
                                      rc);
            break;
        default:
            throw new SceLogException(SceLogException::SXERROR_OPEN,
                                      L"SceOpenProfile(szFileName, SCE_JET_FORMAT, &hProfile)",
                                      NULL,
                                      rc);
            break;
        }
        
        //
        // extract System Settings to ppSAPBuffer
        // and Baseline Settings to ppSMPBuffer
        //

        rc = SceGetSecurityProfileInfo(hProfile,
                                       SceEngineSAP, 
                                       AREA_ALL,
                                       &ppSAPPInfo,
                                       NULL);
        if (rc!=SCESTATUS_SUCCESS) {
            throw new SceLogException(SceLogException::SXERROR_READ_NO_ANALYSIS_TABLE,
                                      L"SceGetSecurityProfileInfo(...)",
                                      NULL,
                                      rc);
        }
        ppSAPBuffer = new SceProfInfoAdapter(ppSAPPInfo, bIsW2k);   // for w2k compat
        rc = SceGetSecurityProfileInfo(hProfile,
                                       SceEngineSMP,
                                       AREA_ALL,
                                       &ppSMPPInfo,
                                       NULL);
        if (rc!=SCESTATUS_SUCCESS) {
            throw new SceLogException(SceLogException::SXERROR_READ_NO_CONFIGURATION_TABLE,
                                      L"SceGetSecurityProfileInfo(...)",
                                      NULL,
                                      rc);
        }
        ppSMPBuffer = new SceProfInfoAdapter(ppSMPPInfo, bIsW2k);   // for w2k compat
        
        
        //
        // get Profile Description, timestamp and machine name and log these
        //

        trace(IDS_LOG_PROFILE_DESC, hLogFile);
        rc = SceGetScpProfileDescription(hProfile, &szProfDesc);
        if (rc!=SCESTATUS_SUCCESS) {
            throw new SceLogException(SceLogException::SXERROR_READ,
                                      L"SceGetScpProfileDescription(hProfile, &szProfDesc)",
                                      NULL,
                                      rc);
        }
        trace(szProfDesc,hLogFile);
        trace (L"\n\r\n\r",hLogFile);
        trace(IDS_LOG_ANALYSIS_TIME, hLogFile);
        rc = SceGetTimeStamp(hProfile, 
                             NULL,
                             &szAnalysisTime);
        if (rc!=SCESTATUS_SUCCESS) {
            throw new SceLogException(SceLogException::SXERROR_READ,
                                      L"SceGetTimeStamp(hProfile,NULL,&szAnalysisTime)",
                                      NULL,
                                      rc);
        }
        trace(szAnalysisTime, hLogFile);
        trace (L"\n\r\n\r",hLogFile);
        trace(IDS_LOG_MACHINE_NAME, hLogFile);
        dwTmp=STRING_BUFFER_SIZE;
        bTmp=GetComputerName(szTmpStringBuffer, &dwTmp);
        if (!bTmp) {
            throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                      L"GetComputerName(szTmpStringBuffer, &dwTmp",
                                      NULL,
                                      0);
        }
        trace(szTmpStringBuffer, hLogFile);
        LogWriter->SetDescription(szTmpStringBuffer,
                                  szProfDesc,
                                  szAnalysisTime);
        trace(L"\n\r\n\r", hLogFile);

        //
        // export various areas of settings
        //

        this->ExportAreaSystemAccess();       
        this->ExportAreaSystemAudit();
        this->ExportAreaKerberos();
        this->ExportAreaRegistryValues();        
        this->ExportAreaServices();
        this->ExportAreaGroupMembership();
        this->ExportAreaPrivileges();
        this->ExportAreaFileSecurity();
        this->ExportAreaRegistrySecurity();

        // All Analysis Finished!!!
        // If We've gotten this far, this was a successful run

    } // try
    catch(SceLogException *e) {
        
        //
        // Cleanup after normal/abnormal termination
        //

        // Close Profile

        if (hProfile!=NULL) {
            SceCloseProfile(&hProfile);
            hProfile=NULL;
        }

        // Free Memory

        if (szProfDesc!=NULL) {
            free(szProfDesc);
            szProfDesc=NULL;
        }
        if (szAnalysisTime!=NULL) {
            free(szAnalysisTime);
            szAnalysisTime=NULL;
        }
        if (ppSAPBuffer != NULL) {
            delete ppSAPBuffer;
            ppSAPBuffer=NULL;
        }
        if (ppSMPBuffer != NULL) {    
            delete ppSMPBuffer;
            ppSMPBuffer=NULL;
        }
        if (ppSAPPInfo != NULL ) {
            SceFreeProfileMemory(ppSAPPInfo);
            ppSAPPInfo=NULL;
        }
        if (ppSMPPInfo != NULL ) {
            SceFreeProfileMemory(ppSMPPInfo);
            ppSMPPInfo=NULL;
        }    

        e->AddDebugInfo(L"ExportAnalysis(LogWriter, hLogFile)");
        throw e;
    }
    catch(...){
        
        //
        // Cleanup after normal/abnormal termination
        //

        // Close Profile

        if (hProfile!=NULL) {
            SceCloseProfile(&hProfile);
            hProfile=NULL;
        }

        // Free Memory

        if (szProfDesc!=NULL) {
            free(szProfDesc);
            szProfDesc=NULL;
        }
        if (szAnalysisTime!=NULL) {
            free(szAnalysisTime);
            szAnalysisTime=NULL;
        }
        if (ppSAPBuffer != NULL) {
            delete ppSAPBuffer;
            ppSAPBuffer=NULL;
        }
        if (ppSMPBuffer != NULL) {    
            delete ppSMPBuffer;
            ppSMPBuffer=NULL;
        }
        if (ppSAPPInfo != NULL ) {
            SceFreeProfileMemory(ppSAPPInfo);
            ppSAPPInfo=NULL;
        }
        if (ppSMPPInfo != NULL ) {
            SceFreeProfileMemory(ppSMPPInfo);
            ppSMPPInfo=NULL;
        }    

        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"ExportAnalysis(LogWriter, hLogFile)",
                                  NULL,
                                  0);
    }
    
    //
    // Cleanup after normal/abnormal termination
    //

    // Close Profile
    
    if (hProfile!=NULL) {
        SceCloseProfile(&hProfile);
        hProfile=NULL;
    }
    
    // Free Memory

    if (szProfDesc!=NULL) {
        free(szProfDesc);
        szProfDesc=NULL;
    }
    if (szAnalysisTime!=NULL) {
        free(szAnalysisTime);
        szAnalysisTime=NULL;
    }
    if (ppSAPBuffer != NULL) {
        delete ppSAPBuffer;
        ppSAPBuffer=NULL;
    }
    if (ppSMPBuffer != NULL) {    
        delete ppSMPBuffer;
        ppSMPBuffer=NULL;
    }
    if (ppSAPPInfo != NULL ) {
        SceFreeProfileMemory(ppSAPPInfo);
        ppSAPPInfo=NULL;
    }
    if (ppSMPPInfo != NULL ) {
        SceFreeProfileMemory(ppSMPPInfo);
        ppSMPPInfo=NULL;
    }    
}
                    


void
SceAnalysisReader::ExportAreaSystemAccess(
    )
/*++

Routine Description:

    Internal method to export System Access settings.
    Should only be called from within ExportAnalysis() after
    the necessary global variables have been initialized

Arguments:
    
    none

Return Value:

    none

--*/
{   
    int iTmp;

    try {

        LogWriter->SetNewArea(TEXT("SystemAccess"));

        //
        // cycle through settings in table
        // system access table size is calculated just once
        //

        iTmp=sizeof(tableSystemAccess)/sizeof(tableEntry);
        for (int i=0; i<iTmp; i++) {
            // load description string
    
            LoadString(myModuleHandle,
                       tableSystemAccess[i].displayNameUID,
                       szTmpStringBuffer,
                       STRING_BUFFER_SIZE);		
    
            // add setting
            LogWriter->AddSetting(tableSystemAccess[i].name,
                                  szTmpStringBuffer,
                                  TYPECAST(DWORD, ppSMPBuffer, tableSystemAccess[i].offset),
                                  TYPECAST(DWORD, ppSAPBuffer, tableSystemAccess[i].offset),
                                  tableSystemAccess[i].displayType);
        }
    
        // two additional non-DWORD settings

        LoadString(myModuleHandle,
                   IDS_SETTING_NEW_ADMIN,
                   szTmpStringBuffer,
                   STRING_BUFFER_SIZE);		
        LogWriter->AddSetting(TEXT("NewAdministratorName"),
                              szTmpStringBuffer,
                              ppSMPBuffer->NewAdministratorName,
                              ppSAPBuffer->NewAdministratorName,
                              SceXMLLogWriter::TYPE_DEFAULT);
        LoadString(myModuleHandle,
                   IDS_SETTING_NEW_GUEST,
                   szTmpStringBuffer,
                   STRING_BUFFER_SIZE);		
        LogWriter->AddSetting(TEXT("NewGuestName"),
                              szTmpStringBuffer,
                              ppSMPBuffer->NewGuestName,
                              ppSAPBuffer->NewGuestName,
                              SceXMLLogWriter::TYPE_BOOLEAN);
    } catch (SceLogException *e) {
        e->SetArea(L"SystemAccess");
        e->AddDebugInfo(L"SceAnalysisReader::ExportAreaSystemAccess()");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceAnalysisReader::ExportAreaSystemAccess()",
                                  NULL,
                                  0);
    }    
}
    



void
SceAnalysisReader::ExportAreaSystemAudit(
    )
/*++

Routine Description:

    Internal method to export System Audit settings.
    Should only be called from within ExportAnalysis() after
    the necessary global variables have been initialized

Arguments:
    
    none

Return Value:

    none

--*/
{
    int iTmp;

    try {
        LogWriter->SetNewArea(TEXT("SystemAudit"));

        //
        // cycle through settings in table\
        // system audit table size is calculated just once
        //

        iTmp=sizeof(tableSystemAudit)/sizeof(tableEntry);        
        for (int i=0; i<iTmp; i++) {
            // load description string
    
            LoadString(myModuleHandle,
                       tableSystemAudit[i].displayNameUID,
                       szTmpStringBuffer,
                       STRING_BUFFER_SIZE);		
    
            // add setting            
            LogWriter->AddSetting(tableSystemAudit[i].name,
                                  szTmpStringBuffer,
                                  TYPECAST(DWORD, ppSMPBuffer, tableSystemAudit[i].offset),
                                  TYPECAST(DWORD, ppSAPBuffer, tableSystemAudit[i].offset),
                                  tableSystemAudit[i].displayType);
        }
    } catch (SceLogException *e) {
        e->SetArea(L"SystemAudit");
        e->AddDebugInfo(L"SceAnalysisReader::ExportAreaSystemAudit()");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceAnalysisReader::ExportAreaSystemAudit()",
                                  NULL,
                                  0);
    }
}



void
SceAnalysisReader::ExportAreaGroupMembership(
    )
/*++

Routine Description:

    Internal method to export Group Membership settings.
    Should only be called from within ExportAnalysis() after
    the necessary global variables have been initialized

Arguments:
    
    none

Return Value:

    none

--*/
{
    SceXMLLogWriter::SXMATCH_STATUS match;
    INT iTmp;

    try {    

        LogWriter->SetNewArea(TEXT("GroupMembership"));
    
        PSCE_GROUP_MEMBERSHIP pGroupSystem = ppSAPBuffer->pGroupMembership;
        PSCE_GROUP_MEMBERSHIP pGroupBase = ppSMPBuffer->pGroupMembership;
        PSCE_GROUP_MEMBERSHIP pGroupTBase, pGroupTSystem;
    
        //
        // For every group in the Baseline Profile, we attempt to find
        // its corresponding group in the Anaylsis Profile
        //
    
        pGroupTBase = pGroupBase;
        while (pGroupTBase!=NULL) {
            PWSTR szGroupName = pGroupTBase->GroupName;
            BOOL found = FALSE;
    
            //
            // search for group in system
            //
    
            pGroupTSystem = pGroupSystem;
            while ( (pGroupTSystem!=NULL) && !found ) {
                if (_wcsicmp(szGroupName, pGroupTSystem->GroupName)==0) {
    
                    //
                    // found the matching group
                    //
    
                    // determine match status for Group Members
    
                    match = LogWriter->MATCH_TRUE;
                    if (pGroupTSystem->Status & 0x01) {
                        match = LogWriter->MATCH_FALSE;
                    } else
                    if (pGroupTSystem->Status & 0x10) {
                        match = LogWriter->MATCH_NOT_ANALYZED;
                    }
                    if (pGroupTSystem->Status & 0x20) {
                        match = LogWriter->MATCH_ERROR;
                    } 

                    //
                    // check if value read from database makes sense
                    //

                    if ((szGroupName==NULL) ||
                        (wcscmp(szGroupName, L"")==0)) {
                        throw new SceLogException(SceLogException::SXERROR_READ_ANALYSIS_SUGGESTED,
                                                  L"szGroupName==NULL",
                                                  NULL,
                                                  0);
                    }
    
                    //
                    // log setting for Group Members with LogWriter
                    //

                    iTmp = wnsprintf(szTmpStringBuffer, 
                                     STRING_BUFFER_SIZE,
                                     L"%s %s",
                                     szGroupName,
                                     L"(Members)");

                    if (iTmp<0) {

                        //
                        // negative result from wnsprintf implies failed
                        //

                        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                                  L"wnsprintf(szTmpStringBuffer,...,szGroupName,...)",
                                                  NULL,
                                                  iTmp);
                    }
                    
                    LogWriter->AddSetting(szTmpStringBuffer, 
                                          szTmpStringBuffer,
                                          match, 
                                          pGroupTBase->pMembers, 
                                          pGroupTSystem->pMembers, 
                                          SceXMLLogWriter::TYPE_DEFAULT);
    
    
                    // determine match status for Group Member Of
    
                    match = LogWriter->MATCH_TRUE;
                    if (pGroupTSystem->Status & 0x02) {
                        match = LogWriter->MATCH_FALSE;
                    }
                    if (pGroupTSystem->Status & 0x10) {
                        match = LogWriter->MATCH_NOT_ANALYZED;
                    }
                    if (pGroupTSystem->Status & 0x20) {
                        match = LogWriter->MATCH_ERROR;
                    }
    
                    // log setting for Group Member Of
    
                    iTmp = wnsprintf(szTmpStringBuffer, 
                                     STRING_BUFFER_SIZE,
                                     L"%s %s",
                                     szGroupName,
                                     L"(Member Of)");

                    if (iTmp<0) {

                        //
                        // negative result from wnsprintf implies failed
                        //

                        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                                  L"wnsprintf(szTmpStringBuffer,...,szGroupName,...)",
                                                  NULL,
                                                  iTmp);
                    }

                    LogWriter->AddSetting(szTmpStringBuffer, 
                                          szTmpStringBuffer,
                                          match, 
                                          pGroupTBase->pMemberOf, 
                                          pGroupTSystem->pMemberOf, 
                                          SceXMLLogWriter::TYPE_DEFAULT);
    
                    found = TRUE;
                }
                pGroupTSystem = pGroupTSystem->Next;
            } // while{} for system groups
    
            // There should not be any groups that are in baseline but not in SAP
            // It seems as though once a group is added to the SMP, then it will exist
            // in the SAP even if no analysis is performed -- checked with Vishnu 7/10/02
    
            pGroupTBase = pGroupTBase->Next;
        } 
        // There should not be any groups in SAP but not in baseline
    } catch (SceLogException *e) {
        e->SetArea(L"GroupMembership");
        e->AddDebugInfo(L"SceAnalysisReader::ExportAreaGroupMembership()");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceAnalysisReader::ExportAreaGroupMembership()",
                                  NULL,
                                  0);
    }
}



void
SceAnalysisReader::ExportAreaRegistryValues(
    )
/*++

Routine Description:

    Internal method to export Registry Value settings.
    Should only be called from within ExportAnalysis() after
    the necessary global variables have been initialized

Arguments:
    
    none

Return Value:

    none

--*/
{
    
    SceXMLLogWriter::SXMATCH_STATUS match;

    try {    
    
        LogWriter->SetNewArea(TEXT("RegistryValues"));

        // For each registry value in the Baseline Profile, we attempt to
        // find its matching registry value in the Analysis Profile
    
        // this method of finding matching reg keys is rather inefficient,
        // time complexity is O(n^2) in the number of reg values
        // can probably do better if necessary
    
        for (DWORD i=0; i<ppSMPBuffer->RegValueCount; i++) {
            BOOL found = FALSE;
            SceXMLLogWriter::SXTYPE type;
            SceXMLLogWriter::SXMATCH_STATUS match;
            PWSTR keyName = ppSMPBuffer->aRegValues[i].FullValueName;
    
            // get reg key display name
    
            GetRegKeyDisplayName(ppSMPBuffer->aRegValues[i].FullValueName,
                                 szTmpStringBuffer,
                                 STRING_BUFFER_SIZE);
    
            //
            // determine reg value type
            //
    
            switch(ppSMPBuffer->aRegValues[i].ValueType){
            case REG_BINARY:
                type=SceXMLLogWriter::TYPE_REG_BINARY;
                break;
            case REG_DWORD:
                type=SceXMLLogWriter::TYPE_REG_DWORD;
                break;
            case REG_EXPAND_SZ:
                type=SceXMLLogWriter::TYPE_REG_EXPAND_SZ;
                break;
            case REG_MULTI_SZ:
                type=SceXMLLogWriter::TYPE_REG_MULTI_SZ;
                break;
            case REG_SZ:
                type=SceXMLLogWriter::TYPE_REG_SZ;
                break;
            }
    
            for (DWORD j=0; j<ppSAPBuffer->RegValueCount; j++) {
                if (_wcsicmp(keyName, ppSAPBuffer->aRegValues[j].FullValueName)==0) {
    
                    //
                    // found matching reg key
                    //
    
                    found=TRUE;
    
                    // determine match status
    
                    switch (ppSAPBuffer->aRegValues[j].Status) {
                    case SCE_STATUS_GOOD:
                        match=SceXMLLogWriter::MATCH_TRUE;
                        break;
                    case SCE_STATUS_MISMATCH:
                        match=SceXMLLogWriter::MATCH_FALSE;
                        break;
                    case SCE_STATUS_NOT_ANALYZED:
                        match=SceXMLLogWriter::MATCH_NOT_ANALYZED;
                        break;
                    default:
                        match=SceXMLLogWriter::MATCH_ERROR;
                        break;
                    }
    
                    // log setting
    
                    LogWriter->AddSetting(keyName, 
                                          szTmpStringBuffer,
                                          match, 
                                          ppSMPBuffer->aRegValues[i].Value,
                                          ppSAPBuffer->aRegValues[j].Value,
                                          type);
                }
            }
            if (!found) {
    
                // 
                // since reg val missing from Analysis Profile,
                // this actually implies a match
                //
    
                match = SceXMLLogWriter::MATCH_TRUE;
                LogWriter->AddSetting(keyName, 
                                      szTmpStringBuffer,
                                      match, 
                                      ppSMPBuffer->aRegValues[i].Value,
                                      ppSMPBuffer->aRegValues[i].Value,
                                      type);
            }
        }
    
        //
        // some other misc values that are also under the RegistryValues area
        //
    
        LogWriter->AddSetting(TEXT("EnableAdminAccount"),
                              TEXT("EnableAdminAccount"),
                              ppSMPBuffer->EnableAdminAccount,
                              ppSAPBuffer->EnableAdminAccount,
                              SceXMLLogWriter::TYPE_BOOLEAN);
        LogWriter->AddSetting(TEXT("EnableGuestAccount"),
                              TEXT("EnableGuestAccount"),
                              ppSMPBuffer->EnableGuestAccount,
                              ppSAPBuffer->EnableGuestAccount,
                              SceXMLLogWriter::TYPE_BOOLEAN);
    } catch (SceLogException *e) {
        e->SetArea(L"RegistryValues");
        e->AddDebugInfo(L"SceAnalysisReader::ExportAreaRegistryValues()");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceAnalysisReader::ExportAreaRegistryValues()",
                                  NULL,
                                  0);
    }
}



void
SceAnalysisReader::ExportAreaPrivileges(
    )
/*++

Routine Description:

    Internal method to export Privilege settings.
    Should only be called from within ExportAnalysis() after
    the necessary global variables have been initialized

Arguments:
    
    none

Return Value:

    none

--*/
{
    SceXMLLogWriter::SXMATCH_STATUS match;

    try {    
    
        LogWriter->SetNewArea(TEXT("PrivilegeRights"));
        PSCE_PRIVILEGE_ASSIGNMENT pTmpPrivBase = ppSMPBuffer->pPrivilegeAssignedTo;
        PSCE_PRIVILEGE_ASSIGNMENT pTmpPrivSys = ppSAPBuffer->pPrivilegeAssignedTo;
    
        //
        // for each privilege in the baseline profile, attempt to find its matching
        // privilege in the analysis profile
        //
    
        while (pTmpPrivBase!=NULL) {
            DWORD dwValue = pTmpPrivBase->Value;
            BOOL found = FALSE;
            BOOL bPrivLookupSuccess;
            SceXMLLogWriter::SXMATCH_STATUS match;
            PWSTR szPrivDescription=NULL;
    
            GetPrivilegeDisplayName(pTmpPrivBase->Name,
                                    szTmpStringBuffer,
                                    STRING_BUFFER_SIZE);
    
            //
            // search for matching privilege in analysis table
            //
    
            while (pTmpPrivSys!=NULL&&!found) {
                if (dwValue==pTmpPrivSys->Value) {
    
                    //
                    // Found matching privilege
                    //
    
                    // determine match status
    
                    switch (pTmpPrivSys->Status) {
                    case SCE_STATUS_GOOD:
                        match=SceXMLLogWriter::MATCH_TRUE;
                        break;
                    case SCE_STATUS_MISMATCH:
                        match=SceXMLLogWriter::MATCH_FALSE;
                        break;
                    case SCE_STATUS_NOT_CONFIGURED:
                        match=SceXMLLogWriter::MATCH_NOT_CONFIGURED;
                        break;
                    case SCE_STATUS_NOT_ANALYZED:
                        match=SceXMLLogWriter::MATCH_NOT_ANALYZED;
                        break;
                    case SCE_DELETE_VALUE:
                        match=SceXMLLogWriter::MATCH_OTHER;
                        break;
                    default:
                        match=SceXMLLogWriter::MATCH_OTHER;
                        break;
                    }
    
                    // log setting
                    LogWriter->AddSetting(pTmpPrivBase->Name,
                                          szTmpStringBuffer,
                                          match,
                                          pTmpPrivBase->AssignedTo,
                                          pTmpPrivSys->AssignedTo,
                                          SceXMLLogWriter::TYPE_DEFAULT);
                    found=TRUE;
                }
                pTmpPrivSys=pTmpPrivSys->Next;
            }
            if (!found) {
    
                // since settings is absent from analysis profile,
                // this implies a match
    
                match=SceXMLLogWriter::MATCH_TRUE;
                LogWriter->AddSetting(pTmpPrivBase->Name,
                                      szTmpStringBuffer,
                                      match,
                                      pTmpPrivBase->AssignedTo,
                                      NULL,
                                      SceXMLLogWriter::TYPE_DEFAULT);
    
            }
            pTmpPrivBase=pTmpPrivBase->Next;
            pTmpPrivSys=ppSAPBuffer->pPrivilegeAssignedTo;
        }
    } catch (SceLogException *e) {
        e->SetArea(L"PrivilegeRights");
        e->AddDebugInfo(L"SceAnalysisReader::ExportAreaPrivileges()");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceAnalysisReader::ExportAreaPrivileges()",
                                  NULL,
                                  0);
    }  
}



void
SceAnalysisReader::ExportAreaKerberos(
    )
/*++

Routine Description:

    Internal method to export Kerberos settings.
    Should only be called from within ExportAnalysis() after
    the necessary global variables have been initialized

Arguments:
    
    none

Return Value:

    none

--*/
{
    try {
    
        // Kerberos settings will be present only if this machine is a DC
    
        if (ppSAPBuffer->pKerberosInfo!=NULL) {
            LogWriter->SetNewArea(TEXT("Kerberos"));
            LoadString(myModuleHandle,
                       IDS_SETTING_KERBEROS_MAX_AGE,
                       szTmpStringBuffer,
                       STRING_BUFFER_SIZE);
            LogWriter->AddSetting(TEXT("MaxTicketAge"),
                                  szTmpStringBuffer,
                                  ppSAPBuffer->pKerberosInfo->MaxTicketAge,
                                  ppSMPBuffer->pKerberosInfo->MaxTicketAge,
                                  SceXMLLogWriter::TYPE_DEFAULT);
            LoadString(myModuleHandle,
                       IDS_SETTING_KERBEROS_RENEWAL,
                       szTmpStringBuffer,
                       STRING_BUFFER_SIZE);
            LogWriter->AddSetting(TEXT("MaxRenewAge"),
                                  szTmpStringBuffer,
                                  ppSAPBuffer->pKerberosInfo->MaxRenewAge,
                                  ppSMPBuffer->pKerberosInfo->MaxRenewAge,
                                  SceXMLLogWriter::TYPE_DEFAULT);
            LoadString(myModuleHandle,
                       IDS_SETTING_KERBEROS_MAX_SERVICE,
                       szTmpStringBuffer,
                       STRING_BUFFER_SIZE);
            LogWriter->AddSetting(TEXT("MaxServiceAge"),
                                  szTmpStringBuffer,
                                  ppSAPBuffer->pKerberosInfo->MaxServiceAge,
                                  ppSMPBuffer->pKerberosInfo->MaxServiceAge,
                                  SceXMLLogWriter::TYPE_DEFAULT);
            LoadString(myModuleHandle,
                       IDS_SETTING_KERBEROS_MAX_CLOCK,
                       szTmpStringBuffer,
                       STRING_BUFFER_SIZE);
            LogWriter->AddSetting(TEXT("MaxClockSkew"),
                                  szTmpStringBuffer,
                                  ppSAPBuffer->pKerberosInfo->MaxClockSkew,
                                  ppSMPBuffer->pKerberosInfo->MaxClockSkew,
                                  SceXMLLogWriter::TYPE_DEFAULT);
            LoadString(myModuleHandle,
                       IDS_SETTING_KERBEROS_VALIDATE_CLIENT,
                       szTmpStringBuffer,
                       STRING_BUFFER_SIZE);
            LogWriter->AddSetting(TEXT("TicketValidateClient"),
                                  szTmpStringBuffer,
                                  ppSAPBuffer->pKerberosInfo->TicketValidateClient,
                                  ppSMPBuffer->pKerberosInfo->TicketValidateClient,
                                  SceXMLLogWriter::TYPE_BOOLEAN);
        }
    
    } catch (SceLogException *e) {
        e->SetArea(L"Kerberos");
        e->AddDebugInfo(L"SceAnalysisReader::ExportAreaKerberos()");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceAnalysisReader::ExportAreaKerberos()",
                                  NULL,
                                  0);
    }

}



void
SceAnalysisReader::ExportAreaRegistrySecurity(
    )
/*++

Routine Description:

    Internal method to export Registry Security settings.
    Should only be called from within ExportAnalysis() after
    the necessary global variables have been initialized

Arguments:
    
    none

Return Value:

    none

--*/
{
    SceXMLLogWriter::SXMATCH_STATUS match;
    SCESTATUS rc;
    WCHAR* FullName;

    try {    

        {
            LogWriter->SetNewArea(TEXT("RegistrySecurity"));

            PSCE_OBJECT_LIST pTmpObjSys = ppSAPBuffer->pRegistryKeys.pOneLevel;
            while(pTmpObjSys!=NULL) {
    
                //
                // log settings for children of this object
                //
    
                if (pTmpObjSys->IsContainer) {
                    this->LogObjectChildrenDifferences(AREA_REGISTRY_SECURITY,pTmpObjSys->Name);                
                }

    
                //
                // check match status for parent object to determine whether 
                // we need to log setting for this object
                //
    
                if ((pTmpObjSys->Status&SCE_STATUS_PERMISSION_MISMATCH) ||
                    (pTmpObjSys->Status&SCE_STATUS_MISMATCH) ||
                    (pTmpObjSys->Status==SCE_STATUS_GOOD)) {
    
                    SceXMLLogWriter::SXMATCH_STATUS match;
    
                    if (pTmpObjSys->Status==SCE_STATUS_GOOD){
                        match=SceXMLLogWriter::MATCH_TRUE;
                    } else {
                        match=SceXMLLogWriter::MATCH_FALSE;;
                    }
    
                    // Get object security of baseline and system setting			
    
                    PSCE_OBJECT_SECURITY pObjSecBase = NULL;
                    PSCE_OBJECT_SECURITY pObjSecSys = NULL;
    
                    // no need trailing '\' behind object name
    
                    FullName= new WCHAR[wcslen(pTmpObjSys->Name)+2];
                    wcscpy(FullName, pTmpObjSys->Name);
    
                    rc = SceGetObjectSecurity(hProfile,
                                              SceEngineSMP,
                                              AREA_REGISTRY_SECURITY,
                                              FullName,
                                              &pObjSecBase);
                    if ((rc!=SCESTATUS_SUCCESS) &&
                        (rc!=SCESTATUS_RECORD_NOT_FOUND)) {
                        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                                  L"SceGetObjectSecurity()",
                                                  NULL,
                                                  rc);
                    }
    
                    // if match is true, object security will not exist in SAP
    
                    if (match!=SceXMLLogWriter::MATCH_TRUE) rc = SceGetObjectSecurity(hProfile,
                                                                            SceEngineSAP,
                                                                            AREA_REGISTRY_SECURITY,
                                                                            FullName,
                                                                            &pObjSecSys);
                    if ((rc!=SCESTATUS_SUCCESS) &&
                        (rc!=SCESTATUS_RECORD_NOT_FOUND)) {
                        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                                  L"SceGetObjectSecurity()",
                                                  NULL,
                                                  rc);
                    }
    
                    // Log Setting
    
                    if (match==SceXMLLogWriter::MATCH_TRUE) {
                        LogWriter->AddSetting(FullName, 
                                              FullName,
                                              match, 
                                              pObjSecBase, 
                                              pObjSecBase, 
                                              SceXMLLogWriter::TYPE_DEFAULT);
                    } else {
                        LogWriter->AddSetting(FullName, 
                                              FullName,
                                              match, 
                                              pObjSecBase, 
                                              pObjSecSys, 
                                              SceXMLLogWriter::TYPE_DEFAULT);
                    }
                }
    
                pTmpObjSys=pTmpObjSys->Next;
            }
        }   
    } catch (SceLogException *e) {

        if (NULL!=FullName) {
            delete (FullName);
            FullName=NULL;
        }

        e->SetArea(L"RegistrySecurity");
        e->AddDebugInfo(L"SceAnalysisReader::ExportAreaRegistrySecurity()");  
        throw e;
    } catch (...) {
        
        if (NULL!=FullName) {
            delete (FullName);
            FullName=NULL;
        }
        
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceAnalysisReader::ExportAreaRegistrySecurity()",
                                  NULL,
                                  0);
    }   

    //
    // cleanup
    //

    if (NULL!=FullName) {
        delete (FullName);
        FullName=NULL;
    }

}



void
SceAnalysisReader::ExportAreaFileSecurity(
    )
/*++

Routine Description:

    Internal method to export File Security settings.
    Should only be called from within ExportAnalysis() after
    the necessary global variables have been initialized

Arguments:
    
    none

Return Value:

    none

--*/
{
    SceXMLLogWriter::SXMATCH_STATUS match;
    SCESTATUS rc;
    WCHAR* FullName;

    try {

        LogWriter->SetNewArea(TEXT("FileSecurity"));
        PSCE_OBJECT_LIST pTmpObjSys = ppSAPBuffer->pFiles.pOneLevel;
        while(pTmpObjSys!=NULL) {
    
            //
            // log settings for children of this object
            //

            if (pTmpObjSys->IsContainer) {
                this->LogObjectChildrenDifferences(AREA_FILE_SECURITY,pTmpObjSys->Name);
            }
    
            //
            // check match status for parent object to determine whether 
            // we need to log setting for this object
            //
    
            if ((pTmpObjSys->Status&SCE_STATUS_PERMISSION_MISMATCH) ||
                (pTmpObjSys->Status&SCE_STATUS_MISMATCH) ||
                (pTmpObjSys->Status==SCE_STATUS_GOOD)) {
    
                SceXMLLogWriter::SXMATCH_STATUS match;
    
                if (pTmpObjSys->Status==SCE_STATUS_GOOD){
                    match=SceXMLLogWriter::MATCH_TRUE;
                } else {
                    match=SceXMLLogWriter::MATCH_FALSE;;
                }
    
                // Get object security of baseline and system setting			
    
                PSCE_OBJECT_SECURITY pObjSecBase = NULL;
                PSCE_OBJECT_SECURITY pObjSecSys = NULL;
    
                // need trailing '\' behind object name
    
                FullName= new WCHAR[wcslen(pTmpObjSys->Name)+2];
                wcscpy(FullName, pTmpObjSys->Name);
                wcscat(FullName, TEXT("\\"));
    
                rc = SceGetObjectSecurity(hProfile,
                                          SceEngineSMP,
                                          AREA_FILE_SECURITY,
                                          FullName,
                                          &pObjSecBase);
                if ((rc!=SCESTATUS_SUCCESS) &&
                    (rc!=SCESTATUS_RECORD_NOT_FOUND)) {
                    throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                              L"SceGetObjectSecurity()",
                                              NULL,
                                              rc);
                }
    
                // if match is true, object security will not exist in SAP
    
                if (match!=SceXMLLogWriter::MATCH_TRUE) rc = SceGetObjectSecurity(hProfile,
                                                                        SceEngineSAP,
                                                                        AREA_FILE_SECURITY,
                                                                        FullName,
                                                                        &pObjSecSys);   
                if ((rc!=SCESTATUS_SUCCESS) &&
                    (rc!=SCESTATUS_RECORD_NOT_FOUND)) {
                    throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                              L"SceGetObjectSecurity()",
                                              NULL,
                                              rc);
                }
    
                // Log Setting
                if (match==SceXMLLogWriter::MATCH_TRUE) {
                    LogWriter->AddSetting(FullName, 
                                          FullName,
                                          match, 
                                          pObjSecBase, 
                                          pObjSecBase, 
                                          SceXMLLogWriter::TYPE_DEFAULT);
                } else {
                    LogWriter->AddSetting(FullName, 
                                          FullName,
                                          match,
                                          pObjSecBase, 
                                          pObjSecSys, 
                                          SceXMLLogWriter::TYPE_DEFAULT);
                }
            }
    
            pTmpObjSys=pTmpObjSys->Next;
        }

    } catch (SceLogException *e) {
        
        if (NULL!=FullName) {
            delete (FullName);
            FullName=NULL;
        }
        
        e->SetArea(L"FileSecurity");
        e->AddDebugInfo(L"SceAnalysisReader::ExportAreaFileSecurity()");  
        throw e;
    } catch (...) {
        
        if (NULL!=FullName) {
            delete (FullName);
            FullName=NULL;
        }
        
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceAnalysisReader::ExportAreaFileSecurity()",
                                  NULL,
                                  0);
    }
    
    if (NULL!=FullName) {
        delete (FullName);
        FullName=NULL;
    }



}



void
SceAnalysisReader::ExportAreaServices(
    )
/*++

Routine Description:

    Internal method to export Service settings.
    Should only be called from within ExportAnalysis() after
    the necessary global variables have been initialized

Arguments:
    
    none

Return Value:

    none

--*/
{
    SceXMLLogWriter::SXMATCH_STATUS match;

    try {    
    
        LogWriter->SetNewArea(TEXT("ServiceSecurity"));
        PSCE_SERVICES pTmpServBase = ppSMPBuffer->pServices;
        PSCE_SERVICES pTmpServSys = ppSAPBuffer->pServices;
        while (pTmpServBase!=NULL) {
            PWSTR szName = pTmpServBase->ServiceName;
            BOOL found=FALSE;
            SceXMLLogWriter::SXMATCH_STATUS match;
    
            while (pTmpServSys!=NULL&&!found) {
                if (_wcsicmp(szName, pTmpServSys->ServiceName)==0) {
    
                    // determine match status
                    if (!(pTmpServSys->SeInfo & DACL_SECURITY_INFORMATION)) {
                        match=SceXMLLogWriter::MATCH_NOT_CONFIGURED;
                    } else if (pTmpServSys->Status==0) {
                        match=SceXMLLogWriter::MATCH_TRUE;
                    } else {
                        match=SceXMLLogWriter::MATCH_FALSE;
                    }
    
                    // log setting
                    LogWriter->AddSetting(pTmpServBase->ServiceName,
                                          pTmpServBase->DisplayName,
                                          match,
                                          pTmpServBase,  
                                          pTmpServSys,
                                          SceXMLLogWriter::TYPE_DEFAULT);										 										 
                    found=TRUE;
                }
                pTmpServSys=pTmpServSys->Next;
    
            }
            if (!found) {
                // settings match
                match = SceXMLLogWriter::MATCH_TRUE;
    
                // log setting
                LogWriter->AddSetting(pTmpServBase->ServiceName,
                                      pTmpServBase->DisplayName,
                                      match,
                                      pTmpServBase,
                                      pTmpServBase,
                                      SceXMLLogWriter::TYPE_DEFAULT);
            }
    
            pTmpServSys=ppSAPBuffer->pServices;
            pTmpServBase=pTmpServBase->Next;
        }
    } catch (SceLogException *e) {
        e->SetArea(L"ServiceSecurity");
        e->AddDebugInfo(L"SceAnalysisReader::ExportAreaServiceSecurity()");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceAnalysisReader::ExportAreaServiceSecurity()",
                                  NULL,
                                  0);
    }
}




void
SceAnalysisReader::GetRegKeyDisplayName(
    IN PCWSTR szName,
    OUT PWSTR szDisplayName,
    IN DWORD dwDisplayNameSize
    )
/*++

Routine Description:

    Maps known registry keys to their display name
    
    The implementation of this function is definitely far from optimal 
    which is potentially bad since it is called for every registry key found
    in the template.This code was copied from the wssecmgr snapin.
    
    On the other hand, practical results seem like the additional time taken
    is negligible, for now. Ideally should use a hash table.
    
Arguments:

    szName:             Reg key name to lookup
    dwDisplayNameSize:  Size of buffer of szDisplayName in WCHARs
    
Return Value:

    szDisplayName:      display name of the reg key

--*/
{
    DWORD dwSize;
    UINT uID;
     
    dwSize=dwDisplayNameSize;

    // find match for reg key name
    if( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\NTDS\\Parameters\\LDAPServerIntegrity") == 0 ) {
        uID = IDS_REGKEY_LDAPSERVERINTEGRITY;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\SignSecureChannel") == 0 ) {
        uID = IDS_REGKEY_SIGNSECURECHANNEL;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\SealSecureChannel") == 0 ) {
        uID = IDS_REGKEY_SEALSECURECHANNEL;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\RequireStrongKey") == 0 ){
        uID = IDS_REGKEY_REQUIRESTRONGKEY;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\RequireSignOrSeal") == 0 ) {
        uID = IDS_REGKEY_REQUIRESIGNORSEAL;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\RefusePasswordChange") == 0 ){
        uID = IDS_REGKEY_REFUSEPASSWORDCHANGE;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\MaximumPasswordAge") == 0 ){
        uID = IDS_REGKEY_MAXIMUMPASSWORDAGE;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\Netlogon\\Parameters\\DisablePasswordChange") == 0 ){
      uID = IDS_REGKEY_DISABLEPASSWORDCHANGE;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\LDAP\\LDAPClientIntegrity") == 0 ){
        uID = IDS_REGKEY_LDAPCLIENTINTEGRITY;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters\\RequireSecuritySignature") == 0 ){
        uID = IDS_REGKEY_REQUIRESECURITYSIGNATURE;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters\\EnableSecuritySignature") == 0 ){
        uID = IDS_REGKEY_ENABLESECURITYSIGNATURE;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters\\EnablePlainTextPassword") == 0 ){
        uID = IDS_REGKEY_ENABLEPLAINTEXTPASSWORD;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\RestrictNullSessAccess") == 0 ){
        uID = IDS_REGKEY_RESTRICTNULLSESSACCESS;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\RequireSecuritySignature") == 0 ){
        uID = IDS_REGKEY_SERREQUIRESECURITYSIGNATURE;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\NullSessionShares") == 0 ){
        uID = IDS_REGKEY_NULLSESSIONSHARES;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\NullSessionPipes") == 0 ){
        uID = IDS_REGKEY_NULLSESSIONPIPES;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\EnableSecuritySignature") == 0 ){
        uID = IDS_REGKEY_SERENABLESECURITYSIGNATURE;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\EnableForcedLogOff") == 0 ){
        uID = IDS_REGKEY_ENABLEFORCEDLOGOFF;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\AutoDisconnect") == 0 ){
        uID = IDS_REGKEY_AUTODISCONNECT;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\ProtectionMode") == 0 ){
        uID = IDS_REGKEY_PROTECTIONMODE;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\ClearPageFileAtShutdown") == 0 ){
        uID = IDS_REGKEY_CLEARPAGEFILEATSHUTDOWN;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\Kernel\\ObCaseInsensitive") == 0 ){
        uID = IDS_REGKEY_OBCASEINSENSITIVE;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\SecurePipeServers\\Winreg\\AllowedPaths\\Machine") == 0 ){
        uID = IDS_REGKEY_MACHINE;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Servers\\AddPrinterDrivers") == 0 ){
        uID = IDS_REGKEY_ADDPRINTERDRIVERS;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\SubmitControl") == 0 ){
        uID = IDS_REGKEY_SUBMITCONTROL;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\RestrictAnonymousSAM") == 0 ){
        uID = IDS_REGKEY_RESTRICTANONYMOUSSAM;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\RestrictAnonymous") == 0 ){
        uID = IDS_REGKEY_RESTRICTANONYMOUS;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\NoLMHash") == 0 ){
        uID = IDS_REGKEY_NOLMHASH;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\NoDefaultAdminOwner") == 0 ){
        uID = IDS_REGKEY_NODEFAULTADMINOWNER;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\MSV1_0\\NTLMMinServerSec") == 0 ){
        uID = IDS_REGKEY_NTLMMINSERVERSEC;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\MSV1_0\\NTLMMinClientSec") == 0 ){
        uID = IDS_REGKEY_NTLMMINCLIENTSEC;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\LmCompatibilityLevel") == 0 ){
        uID = IDS_REGKEY_LMCOMPATIBILITYLEVEL;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\LimitBlankPasswordUse") == 0 ){
        uID = IDS_REGKEY_LIMITBLANKPASSWORDUSE;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\FullPrivilegeAuditing") == 0 ){
        uID = IDS_REGKEY_FULLPRIVILEGEAUDITING;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\ForceGuest") == 0 ){
        uID = IDS_REGKEY_FORCEGUEST;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\FIPSAlgorithmPolicy") == 0 ){
        uID = IDS_REGKEY_FIPSALGORITHMPOLICY;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\EveryoneIncludesAnonymous") == 0 ){
        uID = IDS_REGKEY_EVERYONEINCLUDESANONYMOUS;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\DisableDomainCreds") == 0 ){
        uID = IDS_REGKEY_DISABLEDOMAINCREDS;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\CrashOnAuditFail") == 0 ){
        uID = IDS_REGKEY_CRASHONAUDITFAIL;
    } else if ( _wcsicmp(szName, L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\AuditBaseObjects") == 0 ){
        uID = IDS_REGKEY_AUDITBASEOBJECTS;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\UndockWithoutLogon") == 0 ){
        uID = IDS_REGKEY_UNDOCKWITHOUTLOGON;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\ShutdownWithoutLogon") == 0 ){
        uID = IDS_REGKEY_SHUTDOWNWITHOUTLOGON;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\ScForceOption") == 0 ){
        uID = IDS_REGKEY_SCFORCEOPTION;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\LegalNoticeText") == 0 ){
        uID = IDS_REGKEY_LEGALNOTICETEXT;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\LegalNoticeCaption") == 0 ){
        uID = IDS_REGKEY_LEGALNOTICECAPTION;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\DontDisplayLastUserName") == 0 ){
        uID = IDS_REGKEY_DONTDISPLAYLASTUSERNAME;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\DisableCAD") == 0 ){
        uID = IDS_REGKEY_DISABLECAD;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\ScRemoveOption") == 0 ){
        uID = IDS_REGKEY_SCREMOVEOPTION;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\PasswordExpiryWarning") == 0 ){
        uID = IDS_REGKEY_PASSWORDEXPIRYWARNING;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\ForceUnlockLogon") == 0 ){
        uID = IDS_REGKEY_FORCEUNLOCKLOGON;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\CachedLogonsCount") == 0 ){
        uID = IDS_REGKEY_CACHEDLOGONSCOUNT;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\AllocateFloppies") == 0 ){
        uID = IDS_REGKEY_ALLOCATEFLOPPIES;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\AllocateDASD") == 0 ){
        uID = IDS_REGKEY_ALLOCATEDASD;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\AllocateCDRoms") == 0 ){
        uID = IDS_REGKEY_ALLOCATECDROMS;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\RecoveryConsole\\SetCommand") == 0 ){
        uID = IDS_REGKEY_SETCOMMAND;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\RecoveryConsole\\SecurityLevel") == 0 ){
        uID = IDS_REGKEY_SECURITYLEVEL;
    } else if ( _wcsicmp(szName, L"MACHINE\\Software\\Microsoft\\Driver Signing\\Policy") == 0 ){
        uID = IDS_REGKEY_REGPOLICY;
    } else {
        uID = IDS_REGKEY_ERROR_DETERMINE_REGNAME;
    }

    // load string
    LoadString(myModuleHandle,
               uID,
               szDisplayName,
               dwDisplayNameSize);    

}




void
SceAnalysisReader::GetPrivilegeDisplayName(
    IN PCWSTR szName,
    OUT PWSTR szDisplayName,
    IN DWORD dwDisplayNameSize
    )
/*++

Routine Description:

    Attempts to do a Lookup on the local system for privilege name
    szName. If that fails, then attempts to match it to cerain known
    privilege names. If this too fails, then assigns it an error string
    
Arguments:

    szName:             Privilege name to lookup
    dwDisplayNameSize:  Size of buffer of szDisplayName in WCHARs
    
Return Value:

    szDisplayName:  Display Name of the privilege

--*/    
{
    DWORD dwLanguage, dwSize;
    BOOL bPrivLookupSuccess;
    UINT uID;
     
    dwSize=dwDisplayNameSize;

    bPrivLookupSuccess = LookupPrivilegeDisplayName(NULL,
                                                    szName,
                                                    szDisplayName,
                                                    &dwSize,
                                                    &dwLanguage);
    if(!bPrivLookupSuccess) {
        // determine uID
        if (_wcsicmp(szName, L"senetworklogonright")==0) {
            uID=IDS_PRIVNAME_SE_NETWORK_LOGON_RIGHT;
        } else if (_wcsicmp(szName, L"seinteractivelogonright")==0) {
            uID=IDS_PRIVNAME_SE_INTERACTIVE_LOGON_RIGHT;
        } else if (_wcsicmp(szName, L"sebatchlogonright")==0) {
            uID=IDS_PRIVNAME_SE_BATCH_LOGON_RIGHT;
        } else if (_wcsicmp(szName, L"seservicelogonright")==0) {
            uID=IDS_PRIVNAME_SE_SERVICE_LOGON_RIGHT;
        } else if (_wcsicmp(szName, L"sedenyinteractivelogonright")==0) {
            uID=IDS_PRIVNAME_DENY_LOGON_LOCALLY;
        } else if (_wcsicmp(szName, L"sedenynetworklogonright")==0) {
            uID=IDS_PRIVNAME_DENY_LOGON_NETWORK;
        } else if (_wcsicmp(szName, L"sedenyservicelogonright")==0) {
            uID=IDS_PRIVNAME_DENY_LOGON_BATCH;
        } else if (_wcsicmp(szName, L"sedenyremoteinteractivelogonright")==0) {
            uID=IDS_PRIVNAME_DENY_REMOTE_INTERACTIVE_LOGON;
        } else if (_wcsicmp(szName, L"seremoteinteractivelogonright")==0) {
            uID=IDS_PRIVNAME_REMOTE_INTERACTIVE_LOGON;
        } else {
            uID=IDS_ERROR_DETERMINE_PRIVNAME;
        }

        // load string
        LoadString(myModuleHandle,
                   uID,
                   szDisplayName,
                   dwDisplayNameSize);    
    }

}




void 
SceAnalysisReader::LogObjectChildrenDifferences(
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName
    ) 
/*++

Routine Description:

    This is a recursive function that finds the children of ObjectName
    and logs all objects that have a match/mismatch in the anaylsis
    table

Arguments:
    
    hProfile:   The handle of the SCE database for this object
    Area:       The area that the object resides in, as defined in secedit.h
    ObjectName: Name of object to check and log
    LogWriter:   The instance of LogWriter to use for logging differences

Return Value:

    none

--*/
{    
    SCESTATUS rc;
    
    // Find Object's Children
    PSCE_OBJECT_CHILDREN pChildren=NULL;
    rc = SceGetObjectChildren(hProfile,
                              SceEngineSAP,
                              Area,
                              ObjectName,
                              &pChildren,
                              NULL);
    if (rc!=SCESTATUS_SUCCESS) {
        throw new SceLogException(SceLogException::SXERROR_READ_ANALYSIS_SUGGESTED,
                                  L"SceGetObjectChildren()",
                                  NULL,
                                  rc);
    }
    
    //
    // cycle through the children of this object
    //

    PSCE_OBJECT_CHILDREN_NODE *pObjNode=&(pChildren->arrObject);
    for (DWORD i=0; i<pChildren->nCount; i++) {
        
        // construct full name of child node
        // allocating memory for size of parentname, size of childname, null termination char and '\'
        // hence the '+2'

        WCHAR* ChildFullName= new WCHAR[(wcslen(ObjectName)+wcslen(pObjNode[i]->Name)+2)];
        wcscpy(ChildFullName, ObjectName);
        wcscat(ChildFullName, TEXT("\\"));
        wcscat(ChildFullName, pObjNode[i]->Name);
        
        // only need to log or recurse deeper if children configured

        if (pObjNode[i]->Status&SCE_STATUS_CHILDREN_CONFIGURED) {
            this->LogObjectChildrenDifferences(Area,ChildFullName);							
        }
        
        // check match status to determine whether we need to log setting for this object

        if ((pObjNode[i]->Status&SCE_STATUS_PERMISSION_MISMATCH) ||
            (pObjNode[i]->Status&SCE_STATUS_MISMATCH) ||
            (pObjNode[i]->Status==SCE_STATUS_GOOD)) {
            
            SceXMLLogWriter::SXMATCH_STATUS match;
            
            if (pObjNode[i]->Status==SCE_STATUS_GOOD){
                match=SceXMLLogWriter::MATCH_TRUE;
            } else {
                match=SceXMLLogWriter::MATCH_FALSE;;
            }
            
            // Get object security of baseline and system setting			

            PSCE_OBJECT_SECURITY pObjSecBase = NULL;
            PSCE_OBJECT_SECURITY pObjSecSys = NULL;
            
            rc = SceGetObjectSecurity(hProfile,
                                      SceEngineSMP,
                                      Area,
                                      ChildFullName,
                                      &pObjSecBase);
            if ((rc!=SCESTATUS_SUCCESS) &&
                (rc!=SCESTATUS_RECORD_NOT_FOUND)) {
                throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                          L"SceGetObjectSecurity()",
                                          NULL,
                                          rc);
            }
            
            // if match is true, object security will not exist in SAP

            if (match!=SceXMLLogWriter::MATCH_TRUE) rc = SceGetObjectSecurity(hProfile,
                                                                    SceEngineSAP,
                                                                    Area,
                                                                    ChildFullName,
                                                                    &pObjSecSys);
            if ((rc!=SCESTATUS_SUCCESS)&&
                (rc!=SCESTATUS_RECORD_NOT_FOUND)) {
                throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                          L"SceGetObjectSecurity()",
                                          NULL,
                                          rc);
            }
            
            // Log Setting

            if (match==SceXMLLogWriter::MATCH_TRUE) {
                LogWriter->AddSetting(ChildFullName, 
                                      ChildFullName,
                                      match, 
                                      pObjSecBase, 
                                      pObjSecBase, 
                                      SceXMLLogWriter::TYPE_DEFAULT);
            } else {
                LogWriter->AddSetting(ChildFullName, 
                                      ChildFullName,
                                      match, 
                                      pObjSecBase, 
                                      pObjSecSys, 
                                      SceXMLLogWriter::TYPE_DEFAULT);
            }
        }
        //free(ChildFullName);
        delete ChildFullName;
        ChildFullName=NULL;
    }
    SceFreeMemory((PVOID)pChildren, SCE_STRUCT_OBJECT_CHILDREN);
}
    


void 
SceAnalysisReader::trace(
    IN  PCWSTR szBuffer, 
    IN  HANDLE hLogFile
    )
/*++

Routine Description:

    Internal method to trace info to an error log.

Arguments:
    
    szBuffer:   string to be added to log
    hLogFile:   handle of error log file

Return Value:

    none

--*/
{
    DWORD   dwNumWritten;

    if ((NULL!=hLogFile) && (NULL!=szBuffer)) {    
        WriteFile(hLogFile, 
                  szBuffer, 
                  wcslen(szBuffer)*sizeof(WCHAR), 
                  &dwNumWritten,
                  NULL);
    }
}




void 
SceAnalysisReader::trace(
    IN  UINT   uID, 
    IN  HANDLE hLogFile
    )
/*++

Routine Description:

    Internal method to trace info to an error log.

Arguments:
    
    uID:        id of string to be added to log
    hLogFile:   handle of error log file

Return Value:

    none

--*/
{
    DWORD   dwNumWritten;
    
    if (NULL!=hLogFile) {    
        LoadString(myModuleHandle,
                   uID,
                   szTmpStringBuffer,
                   STRING_BUFFER_SIZE);

        WriteFile(hLogFile, 
                  szTmpStringBuffer, 
                  wcslen(szTmpStringBuffer)*sizeof(WCHAR), 
                  &dwNumWritten,
                  NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\resource.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    contains strings definitions for SecMan

Author:

    Steven Chan (t-schan) July 2002

--*/

#define IDS_PROJNAME                    100
#define IDR_SECURITYDATABASE            101

#define IDS_ERROR_DETERMINE_PRIVNAME    351

#define IDS_SETTING_MIN_PAS_AGE         501
#define IDS_SETTING_MAX_PAS_AGE         502
#define IDS_SETTING_MIN_PAS_LEN         503
#define IDS_SETTING_PAS_COMPLEX         504
#define IDS_SETTING_PAS_UNIQUENESS      505
#define IDS_SETTING_LOCK_COUNT          506
#define IDS_SETTING_LOCK_RESET_COUNT    507
#define IDS_SETTING_LOCK_DURATION       508
#define IDS_SETTING_REQ_LOGON           509
#define IDS_SETTING_FORCE_LOGOFF        510
#define IDS_SETTING_SEC_SYS_PARTITION	511
#define IDS_SETTING_CLEAR_PASSWORD      512
#define IDS_SETTING_LSA_ANON_LOOKUP     513
#define IDS_SETTING_NEW_ADMIN           514
#define IDS_SETTING_NEW_GUEST           515


#define IDS_SETTING_SYS_LOG_MAX         551
#define IDS_SETTING_SEC_LOG_MAX         552
#define IDS_SETTING_APP_LOG_MAX         553
#define IDS_SETTING_SYS_LOG_RET         554
#define IDS_SETTING_SEC_LOG_RET         555
#define IDS_SETTING_APP_LOG_RET         556
#define IDS_SETTING_SYS_LOG_DAYS        557
#define IDS_SETTING_SEC_LOG_DAYS        558
#define IDS_SETTING_APP_LOG_DAYS        559
#define IDS_SETTING_SYS_LOG_GUEST       560
#define IDS_SETTING_SEC_LOG_GUEST       561
#define IDS_SETTING_APP_LOG_GUEST       562
#define IDS_SETTING_SYSTEM_EVENT        563
#define IDS_SETTING_LOGON_EVENT         564
#define IDS_SETTING_OBJECT_ACCESS       565
#define IDS_SETTING_PRIVILEGE_USE       566
#define IDS_SETTING_POLICY_CHANGE       567
#define IDS_SETTING_ACCOUNT_MANAGE      568
#define IDS_SETTING_PROCESS_TRACK       569
#define IDS_SETTING_DIRECTORY_ACCESS    570
#define IDS_SETTING_ACCOUNT_LOGON       571
#define IDS_SETTING_CRASH_LOG_FULL      572

#define IDS_PRIVNAME_SE_NETWORK_LOGON_RIGHT          601
#define IDS_PRIVNAME_SE_INTERACTIVE_LOGON_RIGHT      602
#define IDS_PRIVNAME_SE_BATCH_LOGON_RIGHT            603
#define IDS_PRIVNAME_SE_SERVICE_LOGON_RIGHT          604
#define IDS_PRIVNAME_DENY_LOGON_LOCALLY              605
#define IDS_PRIVNAME_DENY_LOGON_NETWORK              606
#define IDS_PRIVNAME_DENY_LOGON_SERVICE              607
#define IDS_PRIVNAME_DENY_LOGON_BATCH                608
#define IDS_PRIVNAME_DENY_REMOTE_INTERACTIVE_LOGON   609
#define IDS_PRIVNAME_REMOTE_INTERACTIVE_LOGON        610

#define IDS_SETTING_KERBEROS_MAX_AGE            651
#define IDS_SETTING_KERBEROS_RENEWAL            652
#define IDS_SETTING_KERBEROS_MAX_SERVICE        653
#define IDS_SETTING_KERBEROS_MAX_CLOCK          654
#define IDS_SETTING_KERBEROS_VALIDATE_CLIENT    655


#define IDS_REGKEY_LDAPSERVERINTEGRITY		    701
#define IDS_REGKEY_SIGNSECURECHANNEL		    702
#define IDS_REGKEY_SEALSECURECHANNEL		    703
#define IDS_REGKEY_REQUIRESTRONGKEY		        704
#define IDS_REGKEY_REQUIRESIGNORSEAL		    705
#define IDS_REGKEY_REFUSEPASSWORDCHANGE	        706
#define IDS_REGKEY_MAXIMUMPASSWORDAGE		    707
#define IDS_REGKEY_DISABLEPASSWORDCHANGE	    708
#define IDS_REGKEY_LDAPCLIENTINTEGRITY		    709
#define IDS_REGKEY_REQUIRESECURITYSIGNATURE	    710
#define IDS_REGKEY_ENABLESECURITYSIGNATURE	    711
#define IDS_REGKEY_ENABLEPLAINTEXTPASSWORD	    712
#define IDS_REGKEY_RESTRICTNULLSESSACCESS	    713
#define IDS_REGKEY_SERREQUIRESECURITYSIGNATURE  714
#define IDS_REGKEY_NULLSESSIONSHARES	     	715
#define IDS_REGKEY_NULLSESSIONPIPES		        716
#define IDS_REGKEY_SERENABLESECURITYSIGNATURE	717
#define IDS_REGKEY_ENABLEFORCEDLOGOFF		    718
#define IDS_REGKEY_AUTODISCONNECT		        719
#define IDS_REGKEY_PROTECTIONMODE		        720
#define IDS_REGKEY_CLEARPAGEFILEATSHUTDOWN	    721    
#define IDS_REGKEY_OBCASEINSENSITIVE		    722
#define IDS_REGKEY_MACHINE			            723
#define IDS_REGKEY_ADDPRINTERDRIVERS		    724
#define IDS_REGKEY_SUBMITCONTROL	   	        725
#define IDS_REGKEY_RESTRICTANONYMOUSSAM	        726
#define IDS_REGKEY_RESTRICTANONYMOUS		    727
#define IDS_REGKEY_NOLMHASH			            728
#define IDS_REGKEY_NODEFAULTADMINOWNER		    729
#define IDS_REGKEY_NTLMMINSERVERSEC		        730
#define IDS_REGKEY_NTLMMINCLIENTSEC		        731
#define IDS_REGKEY_LMCOMPATIBILITYLEVEL	        732
#define IDS_REGKEY_LIMITBLANKPASSWORDUSE	    734
#define IDS_REGKEY_FULLPRIVILEGEAUDITING	    735
#define IDS_REGKEY_FORCEGUEST			        736
#define IDS_REGKEY_FIPSALGORITHMPOLICY		    737
#define IDS_REGKEY_EVERYONEINCLUDESANONYMOUS	738
#define IDS_REGKEY_DISABLEDOMAINCREDS		    739
#define IDS_REGKEY_CRASHONAUDITFAIL		        740
#define IDS_REGKEY_AUDITBASEOBJECTS		        741
#define IDS_REGKEY_UNDOCKWITHOUTLOGON		    742
#define IDS_REGKEY_SHUTDOWNWITHOUTLOGON	        743
#define IDS_REGKEY_SCFORCEOPTION		        744
#define IDS_REGKEY_LEGALNOTICETEXT		        745
#define IDS_REGKEY_LEGALNOTICECAPTION		    746
#define IDS_REGKEY_DONTDISPLAYLASTUSERNAME	    747
#define IDS_REGKEY_DISABLECAD			        748
#define IDS_REGKEY_SCREMOVEOPTION		        749
#define IDS_REGKEY_PASSWORDEXPIRYWARNING	    750    
#define IDS_REGKEY_FORCEUNLOCKLOGON		        751
#define IDS_REGKEY_CACHEDLOGONSCOUNT		    752
#define IDS_REGKEY_ALLOCATEFLOPPIES	  	        753
#define IDS_REGKEY_ALLOCATEDASD		            754
#define IDS_REGKEY_ALLOCATECDROMS		        755
#define IDS_REGKEY_SETCOMMAND			        756
#define IDS_REGKEY_SECURITYLEVEL		        757
#define IDS_REGKEY_REGPOLICY			        758
#define IDS_REGKEY_ERROR_DETERMINE_REGNAME	    759

#define IDS_LOG_START_EXPORT                        800
#define IDS_LOG_OPEN_DATABASE                       801
#define IDS_LOG_MACHINE_NAME                        802
#define IDS_LOG_ANALYSIS_TIME                       803
#define IDS_LOG_PROFILE_DESC                        804
#define IDS_LOG_SUCCESS                             805
#define IDS_LOG_SAVING                              806
#define IDS_LOG_ERROR			                    807
#define IDS_LOG_ERROR_INTERNAL	                    808
#define IDS_LOG_ERROR_INIT			                809
#define IDS_LOG_ERROR_INIT_MSXML	                810
#define IDS_LOG_ERROR_SAVE			                811
#define IDS_LOG_ERROR_SAVE_INVALID_FILENAME	        812
#define IDS_LOG_ERROR_SAVE_ACCESS_DENIED	        813
#define IDS_LOG_ERROR_OPEN			                814
#define IDS_LOG_ERROR_OPEN_FILE_NOT_FOUND	        815    
#define IDS_LOG_ERROR_READ			                816
#define IDS_LOG_ERROR_READ_NO_ANALYSIS_TABLE	    817
#define IDS_LOG_ERROR_READ_NO_CONFIGURATION_TABLE	818
#define IDS_LOG_ERROR_READ_ANALYSIS_SUGGESTED	    819
#define IDS_LOG_ERROR_INSUFFICIENT_MEMORY	        820
#define IDS_LOG_ERROR_UNEXPECTED                    821
#define IDS_LOG_ERROR_DEBUGINFO		                822
#define IDS_LOG_ERROR_AREA			                823
#define IDS_LOG_ERROR_SETTING		                824
#define IDS_LOG_ERROR_OS_NOT_SUPPORTED              825
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\scelogexception.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    SceLogException.h

Abstract:

    definition of interface for class SceLogException

    SceLogException is the exception class used internally
    within the SecMan dll. SecLogExceptions can be thrown
    and additional debug information can be added to
    the SecLogException each time it is caught.
    
Author:

    Steven Chan (t-schan) July 2002

--*/

#ifndef SCELOGEXCEPTIONH
#define SCELOGEXCEPTIONH


class SceLogException{

public:
    
    typedef enum _SXERROR {
        SXERROR_INTERNAL,
        SXERROR_OS_NOT_SUPPORTED,
        SXERROR_INIT,        
        SXERROR_INIT_MSXML,
        SXERROR_SAVE,
        SXERROR_SAVE_INVALID_FILENAME,
        SXERROR_SAVE_ACCESS_DENIED,
        SXERROR_OPEN,
        SXERROR_OPEN_FILE_NOT_FOUND,
        SXERROR_READ,
        SXERROR_READ_NO_ANALYSIS_TABLE,
        SXERROR_READ_NO_CONFIGURATION_TABLE,
        SXERROR_READ_ANALYSIS_SUGGESTED,
        SXERROR_INSUFFICIENT_MEMORY
    } SXERROR;


    SXERROR ErrorType;
    PWSTR   szDebugInfo;
    PWSTR   szMoreInfo;
    PWSTR   szArea;
    PWSTR   szSettingName;
    DWORD   dwErrorCode;

    SceLogException(IN SXERROR ErrorType, 
                    IN PCWSTR szDebugInfo OPTIONAL, 
                    IN PCWSTR szSuggestion OPTIONAL,
                    IN DWORD dwErrorCode);
    ~SceLogException();

    void ChangeType(IN SXERROR ErrorType);
    void AddDebugInfo(IN PCWSTR szDebugInfo);
    void AddMoreInfo(IN PCWSTR szSuggestion);
    void SetSettingName(IN PCWSTR szSettingName);
    void SetArea(IN PCWSTR szArea);

private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\sceprofinfoadapter.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    SceProfInfoAdapter.cpp

Abstract:

    Implementation for class SceProfInfoAdapter

    This is an adapter for structure SCE_PROFILE_INFO. This class is
    necessary becaue SCE_PROFILE_INFO is defined differently in
    w2k and in xp and provides a common structure to work with regardless
    of whether the system is winxp or win2k
    
    This class is given a pointer to an SCE_PROFILE_INFO structure
    at construct time and its fields are populated accordingly depending
    on which OS the dll is running on.
                
Author:

    Steven Chan (t-schan) July 2002

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <iostream.h>

#include "SceProfInfoAdapter.h"
#include "SceLogException.h"



SceProfInfoAdapter::SceProfInfoAdapter(
    PSCE_PROFILE_INFO ppInfo, 
    BOOL bIsW2k
    )
/*++

Routine Description:

    constructor for a new SceProfInfoAdapter
    casts the ppInfo argument appropriately depending on whether
    OS is win2k or winxp and copies the data to its own fields so that
    user can access one single structure regardless of whether the OS
    is win2k or winxp

Arguments:
    
    ppInfo: SCE_PROFILE_INFO to be adapted
    bIsW2k: true if running on win2k else false

Return Value:

    none

--*/

{
    try {
    
        if (bIsW2k) {
            this->Type = ((PW2K_SCE_PROFILE_INFO) ppInfo)->Type;
            this->MinimumPasswordAge = ((PW2K_SCE_PROFILE_INFO) ppInfo)->MinimumPasswordAge;
            this->MaximumPasswordAge = ((PW2K_SCE_PROFILE_INFO) ppInfo)->MaximumPasswordAge;
            this->MinimumPasswordLength = ((PW2K_SCE_PROFILE_INFO) ppInfo)->MinimumPasswordLength;
            this->PasswordComplexity = ((PW2K_SCE_PROFILE_INFO) ppInfo)->PasswordComplexity;
            this->PasswordHistorySize = ((PW2K_SCE_PROFILE_INFO) ppInfo)->PasswordHistorySize;
            this->LockoutBadCount = ((PW2K_SCE_PROFILE_INFO) ppInfo)->LockoutBadCount;
            this->ResetLockoutCount = ((PW2K_SCE_PROFILE_INFO) ppInfo)->ResetLockoutCount;
            this->LockoutDuration = ((PW2K_SCE_PROFILE_INFO) ppInfo)->LockoutDuration;
            this->RequireLogonToChangePassword = ((PW2K_SCE_PROFILE_INFO) ppInfo)->RequireLogonToChangePassword;
            this->ForceLogoffWhenHourExpire = ((PW2K_SCE_PROFILE_INFO) ppInfo)->ForceLogoffWhenHourExpire;
            this->NewAdministratorName = ((PW2K_SCE_PROFILE_INFO) ppInfo)->NewAdministratorName;
            this->NewGuestName = ((PW2K_SCE_PROFILE_INFO) ppInfo)->NewGuestName;
            this->SecureSystemPartition = ((PW2K_SCE_PROFILE_INFO) ppInfo)->SecureSystemPartition;
            this->ClearTextPassword = ((PW2K_SCE_PROFILE_INFO) ppInfo)->ClearTextPassword;
            this->LSAAnonymousNameLookup = SCE_NO_VALUE;
            
            if (((SCETYPE) W2K_SCE_ENGINE_SAP)==ppInfo->Type) {
                this->pUserList = ((PW2K_SCE_PROFILE_INFO) ppInfo)->OtherInfo.sap.pUserList;
            } else if (((SCETYPE) W2K_SCE_ENGINE_SMP)==ppInfo->Type) {
                this->pUserList = ((PW2K_SCE_PROFILE_INFO) ppInfo)->OtherInfo.smp.pUserList;
            } else {
                this->pUserList = NULL;
            }
    
            if (((SCETYPE) W2K_SCE_ENGINE_SAP)==ppInfo->Type) {
                this->pPrivilegeAssignedTo = ((PW2K_SCE_PROFILE_INFO) ppInfo)->OtherInfo.sap.pPrivilegeAssignedTo;
            } else if (((SCETYPE) W2K_SCE_ENGINE_SMP)==ppInfo->Type) {
                this->pPrivilegeAssignedTo = ((PW2K_SCE_PROFILE_INFO) ppInfo)->OtherInfo.smp.pPrivilegeAssignedTo;
            } else {
                this->pPrivilegeAssignedTo = NULL;
            }
            this->pGroupMembership = ((PW2K_SCE_PROFILE_INFO) ppInfo)->pGroupMembership;
            this->pRegistryKeys = ((PW2K_SCE_PROFILE_INFO) ppInfo)->pRegistryKeys;
            this->pServices = ((PW2K_SCE_PROFILE_INFO) ppInfo)->pServices;
            this->pFiles = ((PW2K_SCE_PROFILE_INFO) ppInfo)->pFiles;
            this->pDsObjects = ((PW2K_SCE_PROFILE_INFO) ppInfo)->pDsObjects;
            this->pKerberosInfo = ((PW2K_SCE_PROFILE_INFO) ppInfo)->pKerberosInfo;
    
            this->MaximumLogSize[0] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->MaximumLogSize[0];
            this->MaximumLogSize[1] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->MaximumLogSize[1];
            this->MaximumLogSize[2] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->MaximumLogSize[2];
            this->AuditLogRetentionPeriod[0] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditLogRetentionPeriod[0];
            this->AuditLogRetentionPeriod[1] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditLogRetentionPeriod[1];
            this->AuditLogRetentionPeriod[2] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditLogRetentionPeriod[2];
            this->RetentionDays[0] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->RetentionDays[0];
            this->RetentionDays[1] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->RetentionDays[1];
            this->RetentionDays[2] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->RetentionDays[2];
            this->RestrictGuestAccess[0] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->RestrictGuestAccess[0];
            this->RestrictGuestAccess[1] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->RestrictGuestAccess[1];
            this->RestrictGuestAccess[2] = ((PW2K_SCE_PROFILE_INFO) ppInfo)->RestrictGuestAccess[2];
    
            this->AuditSystemEvents = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditSystemEvents;
            this->AuditLogonEvents = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditLogonEvents;
            this->AuditObjectAccess = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditObjectAccess;
            this->AuditPrivilegeUse = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditPrivilegeUse;
            this->AuditPolicyChange = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditPolicyChange;
            this->AuditAccountManage = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditAccountManage;
            this->AuditProcessTracking = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditProcessTracking;
            this->AuditDSAccess = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditDSAccess;
            this->AuditAccountLogon = ((PW2K_SCE_PROFILE_INFO) ppInfo)->AuditAccountLogon;
            this->CrashOnAuditFull = ((PW2K_SCE_PROFILE_INFO) ppInfo)->CrashOnAuditFull;
            
            this->RegValueCount = ((PW2K_SCE_PROFILE_INFO) ppInfo)->RegValueCount;
            this->aRegValues = ((PW2K_SCE_PROFILE_INFO) ppInfo)->aRegValues;
            this->EnableAdminAccount = SCE_NO_VALUE;
            this->EnableGuestAccount = SCE_NO_VALUE;
    
        } else {
            this->Type = ppInfo->Type;
            this->MinimumPasswordAge = ppInfo->MinimumPasswordAge;
            this->MaximumPasswordAge = ppInfo->MaximumPasswordAge;
            this->MinimumPasswordLength = ppInfo->MinimumPasswordLength;
            this->PasswordComplexity = ppInfo->PasswordComplexity;
            this->PasswordHistorySize = ppInfo->PasswordHistorySize;
            this->LockoutBadCount = ppInfo->LockoutBadCount;
            this->ResetLockoutCount = ppInfo->ResetLockoutCount;
            this->LockoutDuration = ppInfo->LockoutDuration;
            this->RequireLogonToChangePassword = ppInfo->RequireLogonToChangePassword;
            this->ForceLogoffWhenHourExpire = ppInfo->ForceLogoffWhenHourExpire;
            this->NewAdministratorName = ppInfo->NewAdministratorName;
            this->NewGuestName = ppInfo->NewGuestName;
            this->SecureSystemPartition = ppInfo->SecureSystemPartition;
            this->ClearTextPassword = ppInfo->ClearTextPassword;
            this->LSAAnonymousNameLookup = ppInfo->LSAAnonymousNameLookup;
    
            if (SCE_ENGINE_SAP == ppInfo->Type) {
                this->pUserList = ppInfo->OtherInfo.sap.pUserList;
            } else if (SCE_ENGINE_SMP == ppInfo->Type) {
                this->pUserList = ppInfo->OtherInfo.smp.pUserList;
            } else {
                this->pUserList = NULL;
            }
            
            if (SCE_ENGINE_SAP == ppInfo->Type) {
                this->pPrivilegeAssignedTo = ppInfo->OtherInfo.sap.pPrivilegeAssignedTo;
            } else if (SCE_ENGINE_SMP == ppInfo->Type) {
                this->pPrivilegeAssignedTo = ppInfo->OtherInfo.smp.pPrivilegeAssignedTo;
            } else {
                this->pPrivilegeAssignedTo = NULL;
            }
            this->pGroupMembership = ppInfo->pGroupMembership;
            this->pRegistryKeys = ppInfo->pRegistryKeys;
            this->pServices = ppInfo->pServices;
            this->pFiles = ppInfo->pFiles;
            this->pDsObjects = ppInfo->pDsObjects;
            this->pKerberosInfo = ppInfo->pKerberosInfo;
    
            this->MaximumLogSize[0] = ppInfo->MaximumLogSize[0];
            this->MaximumLogSize[1] = ppInfo->MaximumLogSize[1];
            this->MaximumLogSize[2] = ppInfo->MaximumLogSize[2];
            this->AuditLogRetentionPeriod[0] = ppInfo->AuditLogRetentionPeriod[0];
            this->AuditLogRetentionPeriod[1] = ppInfo->AuditLogRetentionPeriod[1];
            this->AuditLogRetentionPeriod[2] = ppInfo->AuditLogRetentionPeriod[2];
            this->RetentionDays[0] = ppInfo->RetentionDays[0];
            this->RetentionDays[1] = ppInfo->RetentionDays[1];
            this->RetentionDays[2] = ppInfo->RetentionDays[2];
            this->RestrictGuestAccess[0] = ppInfo->RestrictGuestAccess[0];
            this->RestrictGuestAccess[1] = ppInfo->RestrictGuestAccess[1];
            this->RestrictGuestAccess[2] = ppInfo->RestrictGuestAccess[2];
    
            this->AuditSystemEvents = ppInfo->AuditSystemEvents;
            this->AuditLogonEvents = ppInfo->AuditLogonEvents;
            this->AuditObjectAccess = ppInfo->AuditObjectAccess;
            this->AuditPrivilegeUse = ppInfo->AuditPrivilegeUse;
            this->AuditPolicyChange = ppInfo->AuditPolicyChange;
            this->AuditAccountManage = ppInfo->AuditAccountManage;
            this->AuditProcessTracking = ppInfo->AuditProcessTracking;
            this->AuditDSAccess = ppInfo->AuditDSAccess;
            this->AuditAccountLogon = ppInfo->AuditAccountLogon;
            this->CrashOnAuditFull = ppInfo->CrashOnAuditFull;
    
            this->RegValueCount = ppInfo->RegValueCount;
            this->aRegValues = ppInfo->aRegValues;
            this->EnableAdminAccount = ppInfo->EnableAdminAccount;
            this->EnableGuestAccount = ppInfo->EnableGuestAccount;
        }
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_READ,
                                  L"SceProfInfoAdapter::SceProfInfoAdapter(ppInfo, bIsW2k)",
                                  NULL,
                                  0);
    }
}




SceProfInfoAdapter::~SceProfInfoAdapter(
    ) 
/*++

Routine Description:

    SceProfInfoAdapter destructor
    
Arguments:
    
    none

Return Value:

    none

--*/

{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\scexmllogwriter.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    SceXMLLogWriter.h     (interface of class SceXMLLogWriter)
    SceXMLLogWriter.cpp   (implementation of class SceXMLLogWriter)
    
Abstract:

    SceXMLLogWriter is a class that simplifies the XML Logging of SCE analysis
    data.
    
    It also serves to abstract away the actual log format from SCE. 
    The user of this class need not be aware of the actual output 
    log format thus allowing the format to be changed easily.
    
    Usage of this class is as follows. The class is initialized
    by calling its constructor. It is expected that COM has already
    been initialized when this constructor is called. 
    
    Before logging any settings, SceXMLLogWriter::setNewArea must be called 
    to set the current logging area. After this, the caller can call
    any combination of SceXMLLogWriter::setNewArea and SceXMLLogWriter::addSetting.
    
    Finally, SceXMLLogWriter::saveAs is called to save the output log file.

Author:

    Steven Chan (t-schan) July 2002

--*/


#ifdef UNICODE
#define _UNICODE
#endif	

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <iostream.h>
#include <sddl.h>

//
// XML header files
//

#include <atlbase.h>
//#include <atlconv.h>
//#include <objbase.h>
#include <msxml.h>

#include "secedit.h"
#include "SceXMLLogWriter.h"
#include "SceLogException.h"
#include "resource.h"


//
// define constants used by SceXMLLogWriterger
//

CComVariant SceXMLLogWriter::_variantNodeElement(NODE_ELEMENT);
CComBSTR SceXMLLogWriter::_bstrMachineName("MachineName");
CComBSTR SceXMLLogWriter::_bstrAnalysisTimestamp("AnalysisTimestamp");
CComBSTR SceXMLLogWriter::_bstrProfileDescription("ProfileDescription");
CComBSTR SceXMLLogWriter::_bstrSCEAnalysisData("SCEAnalysisData");

CComBSTR SceXMLLogWriter::_bstrSetting("Setting");
CComBSTR SceXMLLogWriter::_bstrDescription("Description");
CComBSTR SceXMLLogWriter::_bstrAnalysisResult("AnalysisResult");
CComBSTR SceXMLLogWriter::_bstrBaselineValue("BaselineValue");
CComBSTR SceXMLLogWriter::_bstrSystemValue("SystemValue");
CComBSTR SceXMLLogWriter::_bstrType("Type");
CComBSTR SceXMLLogWriter::_bstrName("Name");
CComBSTR SceXMLLogWriter::_bstrMatch("Match");

CComBSTR SceXMLLogWriter::_bstrStartupType("StartupType");
CComBSTR SceXMLLogWriter::_bstrForever("Forever");
CComBSTR SceXMLLogWriter::_bstrNotDefined("Not Defined");
CComBSTR SceXMLLogWriter::_bstrNotAnalyzed("Not Analyzed");
CComBSTR SceXMLLogWriter::_bstrNotConfigured("Not Configured");
CComBSTR SceXMLLogWriter::_bstrOther("Other");
CComBSTR SceXMLLogWriter::_bstrTrue("TRUE");
CComBSTR SceXMLLogWriter::_bstrFalse("FALSE");
CComBSTR SceXMLLogWriter::_bstrError("Error");

CComBSTR SceXMLLogWriter::_bstrSpecial("Special");
CComBSTR SceXMLLogWriter::_bstrInteger("Integer");
CComBSTR SceXMLLogWriter::_bstrBoolean("Boolean");

CComBSTR SceXMLLogWriter::_bstrSecurityDescriptor("SecurityDescriptor");
CComBSTR SceXMLLogWriter::_bstrAccount("Account");
CComBSTR SceXMLLogWriter::_bstrAccounts("Accounts");

CComBSTR SceXMLLogWriter::_bstrEventAudit("EventAudit");
CComBSTR SceXMLLogWriter::_bstrSuccess("Success");
CComBSTR SceXMLLogWriter::_bstrFailure("Failure");


CComBSTR SceXMLLogWriter::_bstrServiceSetting("ServiceSetting");
CComBSTR SceXMLLogWriter::_bstrBoot("Boot");
CComBSTR SceXMLLogWriter::_bstrSystem("System");
CComBSTR SceXMLLogWriter::_bstrAutomatic("Automatic");
CComBSTR SceXMLLogWriter::_bstrManual("Manual");
CComBSTR SceXMLLogWriter::_bstrDisabled("Disabled");

CComBSTR SceXMLLogWriter::_bstrString("String");
CComBSTR SceXMLLogWriter::_bstrRegSZ("REG_SZ");
CComBSTR SceXMLLogWriter::_bstrRegExpandSZ("REG_EXPAND_SZ");
CComBSTR SceXMLLogWriter::_bstrRegBinary("REG_BINARY");
CComBSTR SceXMLLogWriter::_bstrRegDWORD("REG_DWORD");
CComBSTR SceXMLLogWriter::_bstrRegMultiSZ("REG_MULTI_SZ");
    


SceXMLLogWriter::SceXMLLogWriter() 
/*++    
Routine Description:

    Constructor for class SceXMLLogWriter.
    
    COM should be initialized before SceXMLLogWriter() is called as SceXMLLogWriter depends
    on MSXML in this current implementation.
    
    
Arguments:

    none
    
Throws:

    SceLogException*:   on error initializing class
    
Return Value:

    a new SceXMLLogWriter
    
--*/
{
    HRESULT hr;
    CComPtr<IXMLDOMNode> spTmpRootNode;
	
    try {

        //
        // check that strings were allocated successfully
        // else exception will be thrown
        //
        
        CheckCreatedCComBSTR(_bstrMachineName);
        CheckCreatedCComBSTR(_bstrProfileDescription); 
        CheckCreatedCComBSTR(_bstrAnalysisTimestamp);         
        CheckCreatedCComBSTR(_bstrSCEAnalysisData);
        CheckCreatedCComBSTR(_bstrSetting); 
        CheckCreatedCComBSTR(_bstrAnalysisResult); 
        CheckCreatedCComBSTR(_bstrBaselineValue); 
        CheckCreatedCComBSTR(_bstrSystemValue);
        CheckCreatedCComBSTR(_bstrType); 
        CheckCreatedCComBSTR(_bstrName); 
        CheckCreatedCComBSTR(_bstrMatch); 
        CheckCreatedCComBSTR(_bstrStartupType); 
        CheckCreatedCComBSTR(_bstrForever);
        CheckCreatedCComBSTR(_bstrNotDefined); 
        CheckCreatedCComBSTR(_bstrNotAnalyzed); 
        CheckCreatedCComBSTR(_bstrNotConfigured); 
        CheckCreatedCComBSTR(_bstrOther);
        CheckCreatedCComBSTR(_bstrTrue); 
        CheckCreatedCComBSTR(_bstrFalse); 
        CheckCreatedCComBSTR(_bstrError); 
        CheckCreatedCComBSTR(_bstrSpecial); 
        CheckCreatedCComBSTR(_bstrInteger); 
        CheckCreatedCComBSTR(_bstrBoolean); 
        CheckCreatedCComBSTR(_bstrSecurityDescriptor); 
        CheckCreatedCComBSTR(_bstrAccount); 
        CheckCreatedCComBSTR(_bstrAccounts); 
        CheckCreatedCComBSTR(_bstrEventAudit);         
        CheckCreatedCComBSTR(_bstrSuccess); 
        CheckCreatedCComBSTR(_bstrFailure); 
        CheckCreatedCComBSTR(_bstrServiceSetting); 
        CheckCreatedCComBSTR(_bstrBoot); 
        CheckCreatedCComBSTR(_bstrSystem); 
        CheckCreatedCComBSTR(_bstrAutomatic); 
        CheckCreatedCComBSTR(_bstrManual); 
        CheckCreatedCComBSTR(_bstrDisabled); 
        CheckCreatedCComBSTR(_bstrString); 
        CheckCreatedCComBSTR(_bstrRegSZ); 
        CheckCreatedCComBSTR(_bstrRegExpandSZ); 
        CheckCreatedCComBSTR(_bstrRegBinary); 
        CheckCreatedCComBSTR(_bstrRegDWORD); 
        CheckCreatedCComBSTR(_bstrRegMultiSZ); 
        CheckCreatedCComBSTR(_bstrDescription);
    
        //
        // create instance of MSXML
        //
        
        hr = spXMLDOM.CoCreateInstance(__uuidof(DOMDocument));
        if (FAILED(hr)) {
            throw new SceLogException(SceLogException::SXERROR_INIT_MSXML,
                                      L"CoCreateInstance(_uuidf(DOMDocument))",
                                      NULL,
                                      hr);
        }
        
        //
        // create and attach root node
        //
        
        hr = spXMLDOM->createNode(_variantNodeElement, 
                                  _bstrSCEAnalysisData, 
                                  NULL, 
                                  &spTmpRootNode);
        CheckCreateNodeResult(hr);
        hr = spXMLDOM->appendChild(spTmpRootNode, 
                                   &spRootNode);        
        CheckAppendChildResult(hr);
    
    } catch (SceLogException *e) {           
        e->AddDebugInfo(L"SceXMLLogWriter::SceXMLLogWriter()");
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INIT,
                                  L"SceXMLLogWriter::SceXMLLogWriter()",
                                  NULL,
                                  0);
    }
}



void SceXMLLogWriter::SaveAs(PCWSTR szFileName) 
/*++
Routine Description:

    Saves the current state of the log to szFileName

Arguments:

    szFileName:     filename to save as

Throws:
    
    SceLogException*:   on error while saving log

Return Value:

    none
    
--*/
{
    HRESULT hr;

    // check arguments
    if (szFileName==NULL) {
        throw new SceLogException(SceLogException::SXERROR_SAVE_INVALID_FILENAME,
                                  L"IXMLDOMDocument->save(ILLEGAL ARG)",
                                  NULL,
                                  0);
    }

    hr = spXMLDOM->save(CComVariant(szFileName));

    if (FAILED(hr)) {
        SceLogException::SXERROR    errorType;

        // determine error code

        switch(hr){
        case E_INVALIDARG:
            errorType = SceLogException::SXERROR_SAVE_INVALID_FILENAME;
            break;
        case E_ACCESSDENIED:
            errorType = SceLogException::SXERROR_SAVE_ACCESS_DENIED;
            break;
        case E_OUTOFMEMORY:
            errorType = SceLogException::SXERROR_INSUFFICIENT_MEMORY;
            break;
        default:
            errorType = SceLogException::SXERROR_SAVE;
            break;
        }
        
        // create exception

        throw new SceLogException(errorType,
                                  L"IXMLDOMDocument->save()",
                                  NULL,
                                  hr);
    }
}


void
SceXMLLogWriter::SetDescription(
    IN PCWSTR szMachineName,
    IN PCWSTR szProfileDescription,
    IN PCWSTR szAnalysisTimestamp
    )
/*++
Routine Description:

    Sets the description of the current logfile and places
    the description at the current position in the logfile

Arguments:

    szMachineName:          Machine name on which log is being exported
    szProfileDescription:   Description of profile being exported
    szAnalysisTimeStamp:    timestamp of last analysis

Return Value:

    none
       
Throws:

    SceLogException*   
  
--*/
{

    HRESULT hr;
    CComPtr<IXMLDOMNode> spDescription, spMachineName, spAnalysisTimestamp,
        spProfileDescription;
    
    try {

        // create CComBSTRs

        CComBSTR bstrAnalysisTimestamp(szAnalysisTimestamp);
        CheckCreatedCComBSTR(bstrAnalysisTimestamp);
        CComBSTR bstrMachineName(szMachineName);
        CheckCreatedCComBSTR(bstrMachineName);
        CComBSTR bstrProfileDescription(szProfileDescription);
        CheckCreatedCComBSTR(bstrProfileDescription);

        // build description node

        spAnalysisTimestamp=CreateNodeWithText(_bstrAnalysisTimestamp,
                                               bstrAnalysisTimestamp);
        spMachineName=CreateNodeWithText(_bstrMachineName,
                                         bstrMachineName);
        spProfileDescription=CreateNodeWithText(_bstrProfileDescription,
                                                bstrProfileDescription);
        hr=spXMLDOM->createNode(_variantNodeElement, 
                                _bstrDescription,
                                NULL,
                                &spDescription);
        CheckCreateNodeResult(hr);
        hr=spDescription->appendChild(spMachineName, NULL);
        CheckAppendChildResult(hr);
        hr=spDescription->appendChild(spProfileDescription, NULL);
        CheckAppendChildResult(hr);
        hr=spDescription->appendChild(spAnalysisTimestamp, NULL);
        CheckAppendChildResult(hr);

        // append description node to root

        hr=spRootNode->appendChild(spDescription, NULL);
        CheckAppendChildResult(hr);
    
    } catch (SceLogException *e) {        
        e->AddDebugInfo(L"SceXMLLogWriter::SetDescription(PCWSTR, PCWSTR, PCWSTR)");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::SetDescription(PCWSTR, PCWSTR, PCWSTR)",
                                  NULL,
                                  0);
    }
}



void 
SceXMLLogWriter::SetNewArea(
    IN PCWSTR szAreaName
    ) 
/*++
Routine Description:

    Sets the current logging area to szAreaName. This should be called
    before attempting to log any settings.

Arguments:
    
    szAreaName:     Name of area. Must have no space, cannot be null nor empty
    
Throws:

    SceLogException*:

Return Value:

    none
    
--*/
{
    HRESULT hr;
    CComPtr<IXMLDOMNode> spTmpNewArea;

    // check arguments

    if ((szAreaName==NULL)||
        (wcscmp(szAreaName, L"")==0)) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::SetNewArea(ILLEGAL ARG)",
                                  NULL,
                                  0);
    }

    try {    
        
        // create CComBSTRs

        CComBSTR bstrAreaName(szAreaName);
        CheckCreatedCComBSTR(bstrAreaName);

        // create node structure and append to root

        hr = spXMLDOM->createNode(_variantNodeElement, bstrAreaName, NULL, &spTmpNewArea);
        CheckCreateNodeResult(hr);
        hr = spRootNode->appendChild(spTmpNewArea, &spCurrentArea);
        CheckAppendChildResult(hr);
    } catch (SceLogException *e) {
        e->AddDebugInfo(L"SceXMLLogWriter::SetNewArea(PCWSTR)");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::SetNewArea(PCWSTR)",
                                  NULL,
                                  0);
    }
}



void 
SceXMLLogWriter::AddSetting(
    IN PCWSTR szSettingName, 
    IN PCWSTR szSettingDescription,
    IN SXMATCH_STATUS match,
    IN DWORD baselineVal, 
    IN DWORD systemVal,
    IN SXTYPE type
    ) 
/*++
Routine Description:

    Adds a new setting entry with the given values

Arguments:

    szSettingName:          Name of Setting
    szSettingDescription:   Description of Setting
    match:                  SXMATCH_STATUS of setting
    baselineVal:            baseline value
    systemVal;              system value
    type:                   representation type

Throws:

    SceLogException*:

Return Value:

    none

--*/
{

    // check arguments
    if ((szSettingName==NULL) ||
        (wcscmp(szSettingName, L"")==0)) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(ILLEGAL ARG)",
                                  NULL,
                                  0);
    }

	try {    
        
        // create CComBSTRs

        CComBSTR bstrSettingName(szSettingName);
        CheckCreatedCComBSTR(bstrSettingName);
        CComBSTR bstrDescription(szDescription);
        CheckCreatedCComBSTR(bstrDescription);

        AddSetting(bstrSettingName, 
                   bstrDescription,
                   match, 
                   CreateTypedNode(_bstrBaselineValue, baselineVal, type), 
                   CreateTypedNode(_bstrSystemValue, systemVal, type));
    } catch (SceLogException *e) {
        e->SetSettingName(szSettingName);
        e->AddDebugInfo(L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, SXMATCH_STATUS, DWORD, DWORD, SXTYPE)");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, SXMATCH_STATUS, DWORD, DWORD, SXTYPE)",
                                  NULL,
                                  0);
    }
}



void 
SceXMLLogWriter::AddSetting(
    IN PCWSTR szSettingName, 
    IN PCWSTR szSettingDescription,
    IN DWORD baselineVal, 
    IN DWORD systemVal,
    IN SXTYPE type
    ) 
/*++
Routine Description:

    Adds a new setting entry with the given values
    
    Since the match status is not defined, this is determind
    from the values of baselineVal and systemVal using the 
    conventions adhered to within the struct SCE_PROFILE_INFO
  
    Specifically, 
        if (baselineVal==SCE_NO_VALUE) then MATCH_NOT_DEFINED
  
        if (systemVal==SCE_NO_VALUE)&&(baselineVal!=SCE_NO_VALUE)
        then match is set to MATCH_TRUE
  
        if (systemVal==SCE_NOT_ANALYZED) then MATCH_NOT_ANALYZED
    
Arguments:

    szSettingName:          Name of Setting
    szSettingDescription:   Description of Setting
    baselineVal:            baseline value
    systemVal;              system value
    type:                   representation type

Throws:

    SceLogException*:

Return Value:

    none

--*/
{
	
    SXMATCH_STATUS match = MATCH_FALSE;
    CComPtr<IXMLDOMNode> spnBaseline, spnSystem;

    // check arguments
    if ((szSettingName==NULL) ||
        (wcscmp(szSettingName, L"")==0)) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(ILLEGAL ARG)",
                                  NULL,
                                  0);
    }

    //
    // determine match status from systemVal and baselineVal
    //

    switch (systemVal) {
    case SCE_NO_VALUE:
        match = MATCH_TRUE;
        systemVal = baselineVal;
        break;
    case SCE_NOT_ANALYZED_VALUE:
        match = MATCH_NOT_ANALYZED;
        break;
    case SCE_ERROR_VALUE:
        match = MATCH_ERROR;
        break;
    case SCE_FOREVER_VALUE:
    case SCE_KERBEROS_OFF_VALUE:
    case SCE_DELETE_VALUE:
    case SCE_SNAPSHOT_VALUE:
        match = MATCH_OTHER;
        break;
    default:
        match = MATCH_FALSE;
        break;
    }

    // if baseline value not defined, this status precedes any 
    // system value setting

    if (baselineVal == SCE_NO_VALUE) {    
        match = MATCH_NOT_DEFINED;        
    }

    //
    // add setting
    //

    try {

        // create CComBSTRs

        CComBSTR bstrSettingName(szSettingName);
        CheckCreatedCComBSTR(bstrSettingName);
        CComBSTR bstrSettingDescription(szSettingDescription);
        CheckCreatedCComBSTR(bstrSettingDescription);

        spnBaseline = CreateTypedNode(_bstrBaselineValue, baselineVal, type);
        spnSystem = CreateTypedNode(_bstrSystemValue, systemVal, type);
        AddSetting(bstrSettingName, 
                   bstrSettingDescription,
                   match, 
                   spnBaseline, 
                   spnSystem);
    } catch (SceLogException *e) {
        e->SetSettingName(szSettingName);
        e->AddDebugInfo(L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, DWORD, DWORD, SXTYPE");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, DWORD, DWORD, SXTYPE",
                                  NULL,
                                  0);
    }
}



void 
SceXMLLogWriter::AddSetting(
    IN PCWSTR szSettingName, 
    IN PCWSTR szSettingDescription,
    IN PCWSTR szBaseline, 
    IN PCWSTR szSystem,
    IN SXTYPE type
    ) 
/*++
Routine Description:

    Adds a new setting entry with the given values

    Since the match status is not defined, this is determind
    from the values of baselineVal and systemVal using the 
    conventions adhered to within the struct SCE_PROFILE_INFO
  
    Specifically, 
        
        if szBaseline==NULL then MATCH_NOT_DEFINED
        
        if szSystem==NULL and szBaseline!=NULL then MATCH_TRUE

Arguments:

    szSettingName:          Name of Setting
    szSettingDescription:   Description of Setting
    baselineVal:            baseline value
    systemVal;              system value
    type:                   representation type

Throws:

    SceLogException*

Return Value:

    none

--*/
{
	
    SXMATCH_STATUS match = MATCH_FALSE;
    PCWSTR szSys;

    // check arguments
    if ((szSettingName==NULL) ||
        (wcscmp(szSettingName, L"")==0)) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(ILLEGAL ARG)",
                                  NULL,
                                  0);
    }

    //
    // determine match status
    //

    szSys=szSystem;
    if (szSystem==NULL) {
        szSys=szBaseline;
        match = MATCH_TRUE;
    }

    if (szBaseline==NULL) {
	match = MATCH_NOT_DEFINED;
    }

    //
    // add setting
    //
    
    try {    

        // create CComBSTRs

        CComBSTR bstrSettingName(szSettingName);
        CheckCreatedCComBSTR(bstrSettingName);
        CComBSTR bstrSettingDescription(szSettingDescription);
        CheckCreatedCComBSTR(bstrSettingDescription);        

        CComBSTR bstrBaseline(szBaseline);
        if (szBaseline!=NULL) {
            CheckCreatedCComBSTR(bstrBaseline);
        }
        CComBSTR bstrSys(szSys);
        if (szSys!=NULL) {
            CheckCreatedCComBSTR(bstrSys);
        }

        AddSetting(bstrSettingName, 
                   bstrSettingDescription,
                   match,
                   CreateTypedNode(_bstrBaselineValue, 
                                   bstrBaseline, 
                                   type), 
                   CreateTypedNode(_bstrSystemValue, 
                                   bstrSys, 
                                   type));
    } catch (SceLogException *e) {
        e->SetSettingName(szSettingName);
        e->AddDebugInfo(L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, PCWSTR, PCWSTR, SXTYPE");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, PCWSTR, PCWSTR, SXTYPE",
                                  NULL,
                                  0);
    }
}



void 
SceXMLLogWriter::AddSetting(
    IN PCWSTR szSettingName, 
    IN PCWSTR szSettingDescription,
    IN SXMATCH_STATUS match,
    IN PCWSTR szBaseline, 
    IN PCWSTR szSystem,
    IN SXTYPE type
    ) 
/*++
Routine Description:

    Adds a new setting entry with the given values

Arguments:

    szSettingName:          Name of Setting
    szSettingDescription:   Description of Setting
    match:                  SXMATCH_STATUS of setting
    baselineVal:            baseline value
    systemVal;              system value
    type:                   representation type

Throws:

    SceLogException*

Return Value:

    none

--*/
{
    // check arguments
    if ((szSettingName==NULL) ||
        (wcscmp(szSettingName, L"")==0)) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(ILLEGAL ARG)",
                                  NULL,
                                  0);
    }

    try {    

        // create CComBSTRs

        CComBSTR bstrSettingName(szSettingName);
        CheckCreatedCComBSTR(bstrSettingName);
        CComBSTR bstrSettingDescription(szSettingDescription);
        CheckCreatedCComBSTR(bstrSettingDescription);

        CComBSTR bstrBaseline(szBaseline);
        if (szBaseline!=NULL) {
            CheckCreatedCComBSTR(bstrBaseline);
        }
        CComBSTR bstrSystem(szSystem);
        if (szSystem!=NULL) {
            CheckCreatedCComBSTR(bstrSystem);
        }

        AddSetting(bstrSettingName, 
                   bstrSettingDescription,
                   match,
                   CreateTypedNode(_bstrBaselineValue, 
                                   bstrBaseline, 
                                   type), 
                   CreateTypedNode(_bstrSystemValue, 
                                   bstrSystem, 
                                   type));
    } catch (SceLogException *e) {
        e->SetSettingName(szSettingName);
        e->AddDebugInfo(L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, SXMATCH_STATUS, PCWSTR, PCWSTR, SXTYPE");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, SXMATCH_STATUS, PCWSTR, PCWSTR, SXTYPE",
                                  NULL,
                                  0);
    }   
}



void 
SceXMLLogWriter::AddSetting(
    PCWSTR szSettingName,
    PCWSTR szSettingDescription,
    SXMATCH_STATUS match,
    PSCE_NAME_LIST pBaseline,
    PSCE_NAME_LIST pSystem,
    SXTYPE type
    ) 
/*++
Routine Description:

    Adds a new setting entry with the given values

Arguments:

    szSettingName:          Name of Setting
    szSettingDescription:   Description of Setting
    match:                  SXMATCH_STATUS of setting
    baselineVal:            baseline value
    systemVal;              system value
    type:                   representation type

Throws:

    SceLogException*

Return Value:

    none

--*/
{
    CComPtr<IXMLDOMNode> spnBaseline, spnSystem;

     // check arguments
    if ((szSettingName==NULL) ||
        (wcscmp(szSettingName, L"")==0)) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(ILLEGAL ARG)",
                                  NULL,
                                  0);
    }


    try {    

        // create CComBSTRs

        CComBSTR bstrSettingName(szSettingName);
        CheckCreatedCComBSTR(bstrSettingName);
        CComBSTR bstrSettingDescription(szSettingDescription);
        CheckCreatedCComBSTR(bstrSettingDescription);

        spnBaseline = CreateTypedNode(_bstrBaselineValue, pBaseline, type);
        spnSystem = CreateTypedNode(_bstrSystemValue, pSystem, type);
        AddSetting(bstrSettingName, 
                   bstrSettingDescription,
                   match, 
                   spnBaseline, 
                   spnSystem);
    } catch (SceLogException *e) {
        e->SetSettingName(szSettingName);
        e->AddDebugInfo(L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, SXMATCH_STATUS, PSCE_NAME_LIST, PSCE_NAME_LIST, SXTYPE");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, SXMATCH_STATUS, PSCE_NAME_LIST, PSCE_NAME_LIST, SXTYPE",
                                  NULL,
                                  0);
    }
}



void 
SceXMLLogWriter::AddSetting(
    IN PCWSTR szSettingName,
    IN PCWSTR szSettingDescription,
    IN SXMATCH_STATUS match,
    IN PSCE_SERVICES pBaseline,
    IN PSCE_SERVICES pSystem,
    IN SXTYPE type
    ) 
/*++
Routine Description:

    Adds a new setting entry with the given values.
    
    Even though a list of services is presented, only the first
    service is logged.The rationale behind this is that the client
    needs to find the matching pointer to a particular service
    within two service lists that may have a different ordering.

Arguments:

    szSettingName:          Name of Setting
    szSettingDescription:   Description of Setting
    match:                  SXMATCH_STATUS of setting
    baselineVal:            baseline value
    systemVal;              system value
    type:                   representation type

Throws:

    SceLogException*

Return Value:

    none

--*/
{
    CComPtr<IXMLDOMNode> spnBaseline, spnSystem;

    // check arguments
    if ((szSettingName==NULL) ||
        (wcscmp(szSettingName, L"")==0)) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(ILLEGAL ARG)",
                                  NULL,
                                  0);
    }


    try {    

        // create CComBSTRs

        CComBSTR bstrSettingName(szSettingName);
        CheckCreatedCComBSTR(bstrSettingName);
        CComBSTR bstrSettingDescription(szSettingDescription);
        CheckCreatedCComBSTR(bstrSettingDescription);

        spnBaseline = CreateTypedNode(_bstrBaselineValue, pBaseline, type);
        spnSystem = CreateTypedNode(_bstrSystemValue, pSystem, type);
        AddSetting(bstrSettingName, 
                   bstrSettingDescription,
                   match, 
                   spnBaseline, 
                   spnSystem);
    } catch (SceLogException *e) {
        e->SetSettingName(szSettingName);
        e->AddDebugInfo(L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, SXMATCH_STATUS, PSCE_SERVICES, PSCE_SERVICES, SXTYPE");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, SXMATCH_STATUS, PSCE_SERVICES, PSCE_SERVICES, SXTYPE",
                                  NULL,
                                  0);
    }
}



void 
SceXMLLogWriter::AddSetting(
    IN PCWSTR szSettingName,
    IN PCWSTR szSettingDescription,
    IN SXMATCH_STATUS match,
    IN PSCE_OBJECT_SECURITY pBaseline,
    IN PSCE_OBJECT_SECURITY pSystem,
    IN SXTYPE type
    ) 
/*++
Routine Description:

    Adds a new setting entry with the given values

Arguments:

    szSettingName:          Name of Setting
    szSettingDescription:   Description of Setting
    match:                  SXMATCH_STATUS of setting
    baselineVal:            baseline value
    systemVal;              system value
    type:                   representation type

Throws:

    SceLogException*

Return Value:

    none

--*/
{
    CComPtr<IXMLDOMNode> spnBaseline, spnSystem;
    
    // check arguments
    if ((szSettingName==NULL) ||
        (wcscmp(szSettingName, L"")==0)) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(ILLEGAL ARG)",
                                  NULL,
                                  0);
    }

    try {    

        // create CComBSTRs

        CComBSTR bstrSettingName(szSettingName);
        CheckCreatedCComBSTR(bstrSettingName);
        CComBSTR bstrSettingDescription(szSettingDescription);
        CheckCreatedCComBSTR(bstrSettingDescription);

        spnBaseline = CreateTypedNode(_bstrBaselineValue, pBaseline, type);
        spnSystem = CreateTypedNode(_bstrSystemValue, pSystem, type);
        AddSetting(bstrSettingName, 
                   bstrSettingDescription,
                   match, 
                   spnBaseline, 
                   spnSystem);
    } catch (SceLogException *e) {
        e->SetSettingName(szSettingName);
        e->AddDebugInfo(L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, SXMATCH_STATUS, PSCE_OBJECT_SECURITY, PSCE_OBJECT_SECURITY, SXTYPE");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(PCWSTR, PCWSTR, SXMATCH_STATUS, PSCE_OBJECT_SECURITY, PSCE_OBJECT_SECURITY, SXTYPE",
                                  NULL,
                                  0);
    }
}



//
// Private Functions!
//



CComPtr<IXMLDOMNode>
SceXMLLogWriter::CreateNodeWithText(
    IN BSTR bstrNodeName, 
    IN BSTR bstrText
    ) 
/*++
Routine Description:

    This private method creates a node with name bstrNodeName and text
    as specified by bstrText.
    
    This method is private so as to abstract the logging implementation
    (currently XML) from the client.
    
Arguments:

    bstrNodeName: Name of node to create. Must have NO spaces.
    bstrText:     Text that this node should contain
    
Return Value:

    CComPtr<IXMLDOMNode>       
     
Throws:

    SceLogException*   
    
--*/
{
    CComPtr<IXMLDOMText> sptnTextNode;
    CComPtr<IXMLDOMNode> spnNodeWithText;
    HRESULT hr;

    //
    // create the text node, create the actual node,
    // then add text node to actual node
    //
    
    try {    
        hr = spXMLDOM->createTextNode(bstrText, &sptnTextNode);
        CheckCreateNodeResult(hr);
        hr = spXMLDOM->createNode(_variantNodeElement, bstrNodeName, NULL, &spnNodeWithText);
        CheckCreateNodeResult(hr);
        hr = spnNodeWithText->appendChild(sptnTextNode, NULL);
        CheckAppendChildResult(hr);
    } catch (SceLogException *e) {
        e->AddDebugInfo(L"SceXMLLogWriter::CreateNodeWithText(BSTR, BSTR)");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::CreateNodeWithText(BSTR, BSTR)",
                                  NULL,
                                  0);
    }

    return spnNodeWithText;
}



CComPtr<IXMLDOMNode> 
SceXMLLogWriter::CreateTypedNode(
    IN BSTR bstrNodeName, 
    IN PSCE_SERVICES value, 
    IN SXTYPE type
    )
/*++
Routine Description:

    This private method creates a specially formated node that stores
    service information with the representation as specified by 'type'
    
    This method is private so as to abstract the logging implementation
    (currently XML) from the client.
    
Arguments:

    bstrNodeName: Name of node to create. Must have NO spaces.
    value:      Data that this node is to contain
    type:       Species how this data should be represented
    
Return Value:

    CComPtr<IXMLDOMNode
      
Throws:

    SceLogException*   
   
--*/
{
	
    CComPtr<IXMLDOMNode> result, spnodSD, spnodStartupType;
    PWSTR szSD = NULL;
    BOOL bConvertResult = FALSE;
    HRESULT hr;

    try {
        
        if (value==NULL) {
            result = CreateNodeWithText(bstrNodeName, _bstrNotDefined);
        } else {        
    
            bConvertResult = ConvertSecurityDescriptorToStringSecurityDescriptor(
                value->General.pSecurityDescriptor,
                SDDL_REVISION_1,
                value->SeInfo,
                &szSD,
                NULL);
            if (bConvertResult==FALSE) {
                throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                          L"ConvertSecurityDescriptorToStringSecurityDescriptor()",
                                          NULL,
                                          0);
            }
    
            CComBSTR bstrSD(szSD);
            CheckCreatedCComBSTR(bstrSD);
    
            spnodSD=CreateNodeWithText(_bstrSecurityDescriptor, bstrSD);
            
            
            //
            // determine service startup type
            //
            
            switch (value->Startup) {
            case SCE_STARTUP_BOOT:
                spnodStartupType=CreateNodeWithText(_bstrStartupType, _bstrBoot);
                break;
            case SCE_STARTUP_SYSTEM:
                spnodStartupType=CreateNodeWithText(_bstrStartupType, _bstrSystem);
                break;
            case SCE_STARTUP_AUTOMATIC:
                spnodStartupType=CreateNodeWithText(_bstrStartupType, _bstrAutomatic);
                break;
            case SCE_STARTUP_MANUAL:
                spnodStartupType=CreateNodeWithText(_bstrStartupType, _bstrManual);
                break;
            case SCE_STARTUP_DISABLED:
                spnodStartupType=CreateNodeWithText(_bstrStartupType, _bstrDisabled);
                break;
            }
            
            
            //
            // append startup type descriptor node
            //
            
            hr = spXMLDOM->createNode(_variantNodeElement, bstrNodeName, NULL, &result);
            CheckCreateNodeResult(hr);
            result->appendChild(spnodStartupType, NULL);
            result->appendChild(spnodSD, NULL);
            
            //
            // Cast as element to add attribute
            //
            
            CComQIPtr<IXMLDOMElement> speResult;
            speResult = result;
            if (speResult.p == NULL) {
                throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                          L"CComQIPtr<IXMLDOMElement> x = IXMLDOMNode y",
                                          NULL,
                                          0);
            }
            
            hr = speResult->setAttribute(_bstrType, CComVariant(_bstrServiceSetting));
            if (FAILED(hr)) {
                throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                          L"IXMLDOMElement->setAttribute()",
                                          NULL,
                                          hr);
            }
        }

    } catch (SceLogException *e) {

        if (NULL!=szSD) {
            LocalFree(szSD);
            szSD=NULL;
        }

        e->AddDebugInfo(L"SceXMLLogWriter::CreateTypedNode(BSTR, PSCE_SERVICES, SXTYPE)");  
        throw e;
    } catch (...) {

        if (NULL!=szSD) {
            LocalFree(szSD);
            szSD=NULL;
        }

        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::CreateTypedNode(BSTR, PSCE_SERVICES, SXTYPE)",
                                  NULL,
                                  0);
    }
    
    //
    // cleanup
    //

    if (NULL!=szSD) {
        LocalFree(szSD);
        szSD=NULL;
    }

    return result;
}



CComPtr<IXMLDOMNode> 
SceXMLLogWriter::CreateTypedNode(
    IN BSTR bstrNodeName, 
    IN PSCE_OBJECT_SECURITY value, 
    IN SXTYPE type)
/*++
Routine Description:

    This private method creates a specially formated node that stores
    object security information with the representation as specified by 'type'
    
    This method is private so as to abstract the logging implementation
    (currently XML) from the client.
    
Arguments:

    bstrNodeName: Name of node to create. Must have NO spaces.
    value:      Data that this node is to contain
    type:       Species how this data should be represented
    
Return Value:

    CComPtr<IXMLDOMNode>
      
Throws:

    SceLogException*   
   
--*/
{
	
    CComPtr<IXMLDOMNode> result;
    PWSTR szSD = NULL;
    BOOL bConvertResult = FALSE;
    HRESULT hr;

    try {

        if (value==NULL) {
            result = CreateNodeWithText(bstrNodeName, _bstrNotDefined);
        } else {        
        
            //
            // convert security descriptor to string
            //
            
            bConvertResult = ConvertSecurityDescriptorToStringSecurityDescriptor(
                value->pSecurityDescriptor,
                SDDL_REVISION_1,
                value->SeInfo,
                &szSD,
                NULL);
            if (bConvertResult==FALSE) {
                throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                          L"ConvertSecurityDescriptorToStringSecurityDescriptor()",
                                          NULL,
                                          0);
            }
            
            CComBSTR bstrSD(szSD);
            CheckCreatedCComBSTR(bstrSD);
    
            result=CreateNodeWithText(bstrNodeName, bstrSD);
            
            //
            // Cast as element to add attribute
            //
            
            CComQIPtr<IXMLDOMElement> speResult;
            speResult = result;
            if (speResult.p == NULL) {
                throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                          L"CComQIPtr<IXMLDOMElement> x = IXMLDOMNode y",
                                          NULL,
                                          0);        
            }
            
            hr = speResult->setAttribute(_bstrType, CComVariant(_bstrSecurityDescriptor));
            if (FAILED(hr)) {
                throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                          L"IXMLDOMElement->setAttribute()",
                                          NULL,
                                          hr);
            }
        }
    } catch (SceLogException *e) {
        
        if (NULL!=szSD) {
            LocalFree(szSD);
            szSD=NULL;
        }

        e->AddDebugInfo(L"SceXMLLogWriter::CreateTypedNode(BSTR, PSCE_OBJECT_SECURITY, SXTYPE)");  
        throw e;
    } catch (...) {

        if (NULL!=szSD) {
            LocalFree(szSD);
            szSD=NULL;
        }

        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::CreateTypedNode(BSTR, PSCE_OBJECT_SECURITY, SXTYPE)",
                                  NULL,
                                  0);
    }

    //
    // cleanup
    //

    if (NULL!=szSD) {
        LocalFree(szSD);
        szSD=NULL;
    }

    return result;
}




CComPtr<IXMLDOMNode> 
SceXMLLogWriter::CreateTypedNode(
    IN BSTR bstrNodeName, 
    IN PSCE_NAME_LIST value,
    IN SXTYPE type
    )
/*++
Routine Description:

    This private method creates a specially formated node that stores
    SCE_NAME_LISTs with the representation as specified by 'type'
    
    This method is private so as to abstract the logging implementation
    (currently XML) from the client.
    
Arguments:

    bstrNodeName: Name of node to create. Must have NO spaces.
    value:      Data that this node is to contain
    type:       Species how this data should be represented
    
Return Value:

    CComPtr<IXMLDOMNode>
      
Throws:

    SceLogException*   
   
--*/
{
	
    CComPtr<IXMLDOMNode> result, temp;
    PSCE_NAME_LIST tMem1;
    HRESULT hr;
     
    try {

        hr = spXMLDOM->createNode(_variantNodeElement, bstrNodeName, NULL, &result);
        CheckCreateNodeResult(hr);
        
        tMem1 = value;
        while (tMem1!=NULL) {
            temp = CreateNodeWithText(_bstrAccount, tMem1->Name);
            hr = result->appendChild(temp, NULL);
            CheckAppendChildResult(hr);
            tMem1=tMem1->Next;
        }
    	
        //
        // Cast as element to add attribute
        //
    
        CComQIPtr<IXMLDOMElement> speResult;
        speResult = result;
        if (speResult.p == NULL) {
            throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                      L"CComQIPtr<IXMLDOMElement> x = IXMLDOMNode y",
                                      NULL,
                                      0);
        }
    
        hr = speResult->setAttribute(_bstrType, CComVariant(_bstrAccounts));
        if (FAILED(hr)) {
            throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                      L"IXMLDOMElement->setAttribute()",
                                      NULL,
                                      hr);
        }

    } catch (SceLogException *e) {
        e->AddDebugInfo(L"SceXMLLogWriter::CreateTypedNode(BSTR, PSCE_NAME_LIST, SXTYPE)");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::CreateTypedNode(BSTR, PSCE_NAME_LIST, SXTYPE)",
                                  NULL,
                                  0);
    }

    return result;
}



CComPtr<IXMLDOMNode> 
SceXMLLogWriter::CreateTypedNode(
    IN BSTR bstrNodeName, 
    IN DWORD value, 
    IN SXTYPE type
    )
/*++
Routine Description:

    This private method creates a specially formated node that stores
    DWORDs with the representation as specified by 'type'
    
    This method is private so as to abstract the logging implementation
    (currently XML) from the client.
    
Arguments:

    bstrNodeName: Name of node to create. Must have NO spaces.
    value:      Data that this node is to contain
    type:       Species how this data should be represented
    
Return Value:

    CComPtr<IXMLDOMNode>
      
Throws:

    SceLogException*   
   
--*/
{
	
    CComPtr<IXMLDOMNode> result;
    WCHAR 	buffer[20];
    HRESULT hr;
    BSTR	bstrType = NULL;

    try {
    
    	// first check for any special value types: {forever, not defined, not analyzed}
    
        switch (value) {
        case SCE_FOREVER_VALUE:
            result = CreateNodeWithText(bstrNodeName, _bstrForever);
            bstrType = _bstrSpecial;
            break;
        case SCE_NO_VALUE:
            result = CreateNodeWithText(bstrNodeName, _bstrNotDefined);
            bstrType = _bstrSpecial;
            break;
        case SCE_NOT_ANALYZED_VALUE:
            result = CreateNodeWithText(bstrNodeName, _bstrNotAnalyzed);
            bstrType = _bstrSpecial;
            break;
        default:
            
            // otherwise format by specified type
    
            switch (type) {
            case TYPE_DEFAULT:
                _itot(value, buffer, 10);
                result = CreateNodeWithText(bstrNodeName, buffer);
                bstrType = _bstrInteger;
                break;
            case TYPE_BOOLEAN:
                bstrType = _bstrBoolean;
                if (value==0) {
                    result = CreateNodeWithText(bstrNodeName, _bstrFalse);
                } else {
                    result = CreateNodeWithText(bstrNodeName, _bstrTrue);
                }
                break;
            case TYPE_AUDIT:
                CComPtr<IXMLDOMNode> spnSuccess, spnFailure;
                if (value & 0x01) {
                    spnSuccess = CreateNodeWithText(_bstrSuccess, _bstrTrue);
                } else {
                    spnSuccess = CreateNodeWithText(_bstrSuccess, _bstrFalse);
                }
                if (value & 0x02) {
                    spnFailure = CreateNodeWithText(_bstrFailure, _bstrTrue);
                } else {
                    spnFailure = CreateNodeWithText(_bstrFailure, _bstrFalse);
                }
                hr=spXMLDOM->createNode(_variantNodeElement, bstrNodeName, NULL, &result);
                CheckCreateNodeResult(hr);
                hr = result->appendChild(spnSuccess, NULL);
                CheckAppendChildResult(hr);
                hr = result->appendChild(spnFailure, NULL);
                CheckAppendChildResult(hr);
                
                bstrType = _bstrEventAudit;
                break;
            }
        }
    
        // Cast as element to add attribute
    
        CComQIPtr<IXMLDOMElement> speResult;
        speResult = result;
        if (speResult.p == NULL) {
            throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                      L"CComQIPtr<IXMLDOMElement> x = IXMLDOMNode y",
                                      NULL,
                                      0);
        }
        hr = speResult->setAttribute(_bstrType, CComVariant(bstrType));
        if (FAILED(hr)) {
            throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                      L"IXMLDOMElement->setAttribute()",
                                      NULL,
                                      hr);
        }

    } catch (SceLogException *e) {
        e->AddDebugInfo(L"SceXMLLogWriter::CreateTypedNode(BSTR, DWORD, SXTYPE)");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::CreateTypedNode(BSTR, DWORD, SXTYPE)",
                                  NULL,
                                  0);
    }

    return result;
}



CComPtr<IXMLDOMNode> 
SceXMLLogWriter::CreateTypedNode(
    IN BSTR bstrNodeName, 
    IN BSTR bstrValue, 
    IN SXTYPE type
    ) 
/*++
Routine Description:

    This private method creates a specially formated node that stores
    strings with the representation as specified by 'type'
    
    This method is private so as to abstract the logging implementation
    (currently XML) from the client.
    
Arguments:

    bstrNodeName: Name of node to create. Must have NO spaces.
    bstrValue:      Data that this node is to contain
    type:       Species how this data should be represented
    
Return Value:

    CComPtr<IXMLDOMNode>
      
Throws:

    SceLogException*   
   
--*/
{
	
    CComPtr<IXMLDOMNode> result;
    BSTR bstrType=NULL;
    HRESULT hr;

    //
    // determine registry value type
    //

    switch(type) {
    case TYPE_DEFAULT:
        bstrType=_bstrString;
        break;
    case TYPE_REG_SZ:
        bstrType=_bstrRegSZ;
        break;
    case TYPE_REG_EXPAND_SZ:
        bstrType=_bstrRegExpandSZ;
        break;
    case TYPE_REG_BINARY:
        bstrType=_bstrRegBinary;
        break;
    case TYPE_REG_DWORD:
        bstrType=_bstrRegDWORD;
        break;
    case TYPE_REG_MULTI_SZ:
        bstrType=_bstrRegMultiSZ;
        break;
    default:
        bstrType=_bstrString;
    }

    try {    

        if (bstrValue==NULL) {
            result=CreateNodeWithText(bstrNodeName, _bstrNotDefined);
        } else {
            result=CreateNodeWithText(bstrNodeName, bstrValue);
        }
    
        // Cast as element to add attribute
    
        CComQIPtr<IXMLDOMElement> speResult;
        speResult = result;
        if (speResult.p == NULL) {
            throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                      L"CComQIPtr<IXMLDOMElement> x = IXMLDOMNode y",
                                      NULL,
                                      0);
        }
        hr=speResult->setAttribute(_bstrType, CComVariant(bstrType));
        if (FAILED(hr)) {
            throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                      L"IXMLDOMElement->setAttribute()",
                                      NULL,
                                      hr);
        }

    } catch (SceLogException *e) {
        e->AddDebugInfo(L"SceXMLLogWriter::createTypedNode(PCWSTR, BSTR, SXTYPE)");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::createTypedNode(PCWSTR, BSTR, SXTYPE)",
                                  NULL,
                                  0);
    }   

    return result;

}


void 
SceXMLLogWriter::AddSetting(
    IN BSTR bstrSettingName, 
    IN BSTR bstrSettingDescription,
    IN SXMATCH_STATUS match,
    IN IXMLDOMNode* spnBaseline, 
    IN IXMLDOMNode* spnSystem
    ) 
/*++
Routine Description:

    This private method inserts a setting into the current area with match
    status match,baseline node spnBaseline and system setting node spnSystem
    
    This method is private so as to abstract the logging implementation
    (currently XML) from the client.
    
Arguments:

    bstrSettingName:        Name of setting to add
    bstrSettingDescription: Description of setting
    match:                  match status
    spnBaseLine:            Baseline Node to attach
    spnSystem:              System Setting Node to attach
    
Return Value:

    none
     
Throws:

    SceLogException*   
   
--*/
{
    HRESULT hr;
    CComPtr<IXMLDOMNode> spSetting, spAnalysisResult;
    CComPtr<IXMLDOMNode> spSettingName, spMatchStatus, spSettingDescription;

    try {    

        //
        // construct Setting
        //
    
        hr = spXMLDOM->createNode(_variantNodeElement, _bstrSetting, NULL, &spSetting);
        CheckCreateNodeResult(hr);
        spSettingName = CreateNodeWithText(_bstrName, bstrSettingName);
        spSettingDescription = CreateNodeWithText(_bstrDescription, bstrSettingDescription);
        hr = spSetting->appendChild(spSettingName, NULL);
        CheckCreateNodeResult(hr);
        hr = spSetting->appendChild(spSettingDescription, NULL);
        CheckCreateNodeResult(hr);
    
        //
        // construct Anyalysis Result
        //
    
        hr = spXMLDOM->createNode(_variantNodeElement, _bstrAnalysisResult, NULL, &spAnalysisResult);
        CheckCreateNodeResult(hr);
    	
        switch(match) {
        case MATCH_TRUE:
            spMatchStatus = CreateNodeWithText(_bstrMatch, _bstrTrue);		
            break;
        case MATCH_FALSE:
            spMatchStatus = CreateNodeWithText(_bstrMatch, _bstrFalse);		
            break;
        case MATCH_OTHER:
            spMatchStatus = CreateNodeWithText(_bstrMatch, _bstrOther);
            break;
        case MATCH_NOT_DEFINED:
            spMatchStatus = CreateNodeWithText(_bstrMatch, _bstrNotDefined);		
            break;
        case MATCH_NOT_ANALYZED:
            spMatchStatus = CreateNodeWithText(_bstrMatch, _bstrNotAnalyzed);		
            break;
        case MATCH_NOT_CONFIGURED:
            spMatchStatus = CreateNodeWithText(_bstrMatch, _bstrNotConfigured);
            break;
        default:
            spMatchStatus = CreateNodeWithText(_bstrMatch, _bstrError);
            break;
        }
    
        hr = spAnalysisResult->appendChild(spMatchStatus, NULL);
        CheckAppendChildResult(hr);
        hr = spAnalysisResult->appendChild(spnBaseline, NULL);
        CheckAppendChildResult(hr);
        hr = spAnalysisResult->appendChild(spnSystem, NULL);
        CheckAppendChildResult(hr);
    
    
        //
    	// append Analysis Result
        //
    
        hr = spSetting->appendChild(spAnalysisResult, NULL);
        CheckAppendChildResult(hr);
    
        //
        // attach Setting to XML doc
        //
    
        hr = spCurrentArea->appendChild(spSetting, NULL);
        CheckAppendChildResult(hr);
        
    } catch (SceLogException *e) {
        e->AddDebugInfo(L"SceXMLLogWriter::AddSetting(BSTR, BSTR, SXMATCH_STATUS. IXMLDOMNode*, IXMLDOMNode*");  
        throw e;
    } catch (...) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"SceXMLLogWriter::AddSetting(BSTR, BSTR, SXMATCH_STATUS. IXMLDOMNode*, IXMLDOMNode*",
                                  NULL,
                                  0);
    }   

}



void
SceXMLLogWriter::CheckCreateNodeResult (
    IN HRESULT hr
    )
/*++
Routine Description:

    Checks the HRESULT returned by IXMLDOMDocument->createNode
    and throws the appropriate SceLogException if not S_OK
    
Arguments:

    hr: HRESULT to check
    
Return Value:

    none
     
Throws:

    SceLogException*   
    
--*/
{
    if (FAILED(hr)) {
        if (hr==E_INVALIDARG) {
            throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                      L"Invalid argument to IXMLDOMDocument->createNode",
                                      NULL,
                                      hr);
        } else {
            throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                      L"IXMLDOMDOcument->createNode",
                                      NULL,
                                      hr);
        }
    }
}



void
SceXMLLogWriter::CheckAppendChildResult (
    IN HRESULT hr
    )
/*++
Routine Description:

    Checks the HRESULT returned by IXMLDOMDocument->createNode
    and throws the appropriate SceLogException if not S_OK
    
Arguments:

    hr: HRESULT to check
    
Return Value:

    none
         
Throws:

    SceLogException*   

--*/
{
    if (FAILED(hr)) {
        if (hr==E_INVALIDARG) {
            throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                      L"Invalid argument to IXMLDOMDocument->appendChild",
                                      NULL,
                                      hr);
        } else {
            throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                      L"IXMLDOMDOcument->appendChild",
                                      NULL,
                                      hr);
        }
    }
}




void
SceXMLLogWriter::CheckCreatedCComBSTR(
    IN CComBSTR bstrIn
    )
/*++
Routine Description:

    Throws a SceLogException if bstrIn was not successfully
    allocated or is NULL
    
Arguments:

    bstrIn: CComBSTR to check
    
Retrun Value:

    none
     
Throws:

    SceLogException*   
    
--*/        
{
    if (bstrIn.m_str==NULL) {
        throw new SceLogException(SceLogException::SXERROR_INTERNAL,
                                  L"CComBSTR()",
                                  NULL,
                                  0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\sceprofinfoadapter.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    SceProfInfoAdapter.h

Abstract:

    definition of interface for class SceProfInfoAdapter

    This is an adapter for structure SCE_PROFILE_INFO. This class is
    necessary becaue SCE_PROFILE_INFO is defined differently in
    w2k and in xp and provides a common structure to work with regardless
    of whether the system is winxp or win2k
    
    This class is given a pointer to an SCE_PROFILE_INFO structure
    at construct time and its fields are populated accordingly depending
    on which OS the dll is running on.
                
Author:

    Steven Chan (t-schan) July 2002

--*/

#ifndef SCEPROFINFOADAPTERH
#define SCEPROFINFOADAPTERH

#include "secedit.h"
#include "w2kstructdefs.h"

struct SceProfInfoAdapter {

public:

    SceProfInfoAdapter(PSCE_PROFILE_INFO ppInfo, BOOL bIsW2k);
    ~SceProfInfoAdapter();

// Type is used to free the structure by SceFreeMemory
    SCETYPE      Type;
//
// Area: System access
//
    DWORD       MinimumPasswordAge;
    DWORD       MaximumPasswordAge;
    DWORD       MinimumPasswordLength;
    DWORD       PasswordComplexity;
    DWORD       PasswordHistorySize;
    DWORD       LockoutBadCount;
    DWORD       ResetLockoutCount;
    DWORD       LockoutDuration;
    DWORD       RequireLogonToChangePassword;
    DWORD       ForceLogoffWhenHourExpire;
    PWSTR       NewAdministratorName;
    PWSTR       NewGuestName;
    DWORD       SecureSystemPartition;
    DWORD       ClearTextPassword;
    DWORD       LSAAnonymousNameLookup;
    
// Area: user settings (sap)
    PSCE_NAME_LIST        pUserList;
// Area: privileges
    PSCE_PRIVILEGE_ASSIGNMENT    pPrivilegeAssignedTo;

// Area: group membership
    PSCE_GROUP_MEMBERSHIP        pGroupMembership;

// Area: Registry
    SCE_OBJECTS            pRegistryKeys;

// Area: System Services
    PSCE_SERVICES                pServices;

// System storage
    SCE_OBJECTS            pFiles;
//
// ds object
//
    SCE_OBJECTS            pDsObjects;
//
// kerberos policy settings
//
    PSCE_KERBEROS_TICKET_INFO pKerberosInfo;
//
// System audit 0-system 1-security 2-application
//
    DWORD                 MaximumLogSize[3];
    DWORD                 AuditLogRetentionPeriod[3];
    DWORD                 RetentionDays[3];
    DWORD                 RestrictGuestAccess[3];
    DWORD                 AuditSystemEvents;
    DWORD                 AuditLogonEvents;
    DWORD                 AuditObjectAccess;
    DWORD                 AuditPrivilegeUse;
    DWORD                 AuditPolicyChange;
    DWORD                 AuditAccountManage;
    DWORD                 AuditProcessTracking;
    DWORD                 AuditDSAccess;
    DWORD                 AuditAccountLogon;
    DWORD                 CrashOnAuditFull;

//
// registry values
//
    DWORD                       RegValueCount;
    PSCE_REGISTRY_VALUE_INFO    aRegValues;
    DWORD                 EnableAdminAccount;
    DWORD                 EnableGuestAccount;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\securitydatabase.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    SecurityDatabase.cpp

Abstract:

    Implementation of CSecurityDatabase interface
    
    SecurityDatabase is a COM interface that allows users to perform
    basic operations on SCE security databases such as analysis,
    import and export.
    
    This is a bare implementation just to expose export functionality
    of SCE analysis databases. Still needs work.
    
Author:

    Steven Chan (t-schan) July 2002

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <shlwapi.h>
#include <winnlsp.h>
#include <iostream.h>

#include "stdafx.h"
#include "SecMan.h"
#include "SecurityDatabase.h"
#include "SceXMLLogWriter.h"
#include "SceAnalysisReader.h"
#include "SceLogException.h"
#include "secedit.h"    //REMOVE ONCE DEMO IS DONE!

CSecurityDatabase::CSecurityDatabase()
{
    bstrFileName=L"";
    myModuleHandle=GetModuleHandle(L"SecMan.dll");
}

STDMETHODIMP CSecurityDatabase::get_FileName(BSTR *pVal)
{
    return bstrFileName.CopyTo(pVal);
}

STDMETHODIMP CSecurityDatabase::put_FileName(BSTR newVal)
{
    bstrFileName = newVal;
    return S_OK;
}

STDMETHODIMP CSecurityDatabase::get_MachineName(BSTR *pVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CSecurityDatabase::put_MachineName(BSTR newVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CSecurityDatabase::ImportTemplateFile(BSTR FileName)
{
    // IMPLEMENTED ONLY FOR DEMO!!!
    // Still needs work to convert SCESTATUS result code to HRESULT
    SceConfigureSystem(NULL,
                            FileName,
                            bstrFileName,
                            NULL,
                            SCE_OVERWRITE_DB | SCE_NO_CONFIG,
                            AREA_ALL,            
                            NULL,
                            NULL,
                            NULL
                           );
	return S_OK;
}

STDMETHODIMP CSecurityDatabase::ImportTemplateString(BSTR TemplateString)
{
	return E_NOTIMPL;
}

STDMETHODIMP CSecurityDatabase::Analyze()
{
    // IMPLEMENTED ONLY FOR DEMO!!!
    // Still needs work to convert SCESTATUS result code to HRESULT
    SceAnalyzeSystem(NULL,
                     NULL,
                     bstrFileName,
                     NULL,
                     SCE_UPDATE_DB,
                     AREA_ALL,
                     NULL,
                     NULL,
                     NULL);


	return S_OK;
}

STDMETHODIMP CSecurityDatabase::ExportAnalysisToXML(BSTR FileName, BSTR ErrorLogFileName)
/*++

Routine Description:

    exports the analysis information from this SecurityDatabase to FileName

Arguments:

    FileName:           XML file to export to
    ErrorLogFileName:   Error log

Return Value:

    none        

--*/
{
    HANDLE hLogFile=NULL;
    HRESULT result=S_OK;
    SceXMLLogWriter *LogWriter=NULL;
    SceAnalysisReader *AnalysisReader=NULL;
    
    //
    // initialize logfile if necessary
    // if log file fails to be created, we just go about not logging
    // (a parameter of NULL for log file handle to SceAnalysisReader::ExportAnalysis
    // indicates no logging
    //

    if (ErrorLogFileName!=NULL) {
        hLogFile = CreateFile(ErrorLogFileName, 
                              GENERIC_WRITE, 
                              FILE_SHARE_WRITE,
                              NULL, 
                              CREATE_ALWAYS, 
                              FILE_ATTRIBUTE_NORMAL, 
                              NULL);

    }

    try {  
        trace(IDS_LOG_START_EXPORT, hLogFile);
        LogWriter = new SceXMLLogWriter();
        AnalysisReader = new SceAnalysisReader(myModuleHandle, bstrFileName);    
        AnalysisReader->ExportAnalysis(LogWriter, hLogFile);
        trace(IDS_LOG_SAVING, hLogFile);
        trace(FileName, hLogFile);
        trace(L"\n\r\n\r", hLogFile);
        LogWriter->SaveAs(FileName);
        trace(IDS_LOG_SUCCESS, hLogFile);

    } catch(SceLogException *e) {
        switch (e->ErrorType) {
        case SceLogException::SXERROR_INTERNAL:
            trace(IDS_LOG_ERROR_INTERNAL, hLogFile);
            result=E_UNEXPECTED;           
        break;
        case SceLogException::SXERROR_OS_NOT_SUPPORTED:            
            trace(IDS_LOG_ERROR_OS_NOT_SUPPORTED, hLogFile);
            result=ERROR_OLD_WIN_VERSION;
            break;
        case SceLogException::SXERROR_INIT:
            trace(IDS_LOG_ERROR_INTERNAL, hLogFile);
            result=ERROR_MOD_NOT_FOUND;
            break;
        case SceLogException::SXERROR_INIT_MSXML:
            trace(IDS_LOG_ERROR_INIT_MSXML, hLogFile);
            result=ERROR_MOD_NOT_FOUND;
            break;
        case SceLogException::SXERROR_SAVE:
            trace(IDS_LOG_ERROR_SAVE, hLogFile);
            result=ERROR_WRITE_FAULT;
            break;
        case SceLogException::SXERROR_SAVE_INVALID_FILENAME:
            trace(IDS_LOG_ERROR_SAVE_INVALID_FILENAME, hLogFile);
            result=ERROR_INVALID_NAME;
            break;
        case SceLogException::SXERROR_SAVE_ACCESS_DENIED:
            trace(IDS_LOG_ERROR_SAVE_ACCESS_DENIED, hLogFile);
            result=E_ACCESSDENIED;
            break;
        case SceLogException::SXERROR_OPEN:
            trace(IDS_LOG_ERROR_OPEN, hLogFile);
            result=ERROR_OPEN_FAILED;
            break;
        case SceLogException::SXERROR_OPEN_FILE_NOT_FOUND:
            trace(IDS_LOG_ERROR_OPEN_FILE_NOT_FOUND, hLogFile);
            result=ERROR_FILE_NOT_FOUND;
            break;
        case SceLogException::SXERROR_READ:
            trace(IDS_LOG_ERROR_READ, hLogFile);
            result=ERROR_READ_FAULT;
            break;
        case SceLogException::SXERROR_READ_NO_ANALYSIS_TABLE:
            trace(IDS_LOG_ERROR_READ_NO_ANALYSIS_TABLE, hLogFile);
            result=ERROR_READ_FAULT;
            break;
        case SceLogException::SXERROR_READ_NO_CONFIGURATION_TABLE:
            trace(IDS_LOG_ERROR_READ_NO_CONFIGURATION_TABLE, hLogFile);
            result=ERROR_READ_FAULT;
            break;
        case SceLogException::SXERROR_READ_ANALYSIS_SUGGESTED:
            trace(IDS_LOG_ERROR_READ_ANALYSIS_SUGGESTED, hLogFile);
            result=ERROR_READ_FAULT;
            break;
        case SceLogException::SXERROR_INSUFFICIENT_MEMORY:
            trace(IDS_LOG_ERROR_INSUFFICIENT_MEMORY, hLogFile);
            result=E_OUTOFMEMORY;
            break;
        default:
            trace(IDS_LOG_ERROR_UNEXPECTED, hLogFile);
            result=E_UNEXPECTED;
            break;
        }
        trace (IDS_LOG_ERROR_DEBUGINFO, hLogFile);
        trace (e->szDebugInfo, hLogFile);
        trace (L"\n\r",hLogFile);
        trace (IDS_LOG_ERROR_AREA, hLogFile);
        trace (e->szArea, hLogFile);
        trace (L"\n\r",hLogFile);
        trace (IDS_LOG_ERROR_SETTING, hLogFile);
        trace (e->szSettingName, hLogFile);
        delete e;
    }
    catch(...){
        trace(IDS_LOG_ERROR_UNEXPECTED, hLogFile);        
        result = E_UNEXPECTED;
    }
  
    if (NULL!=LogWriter) {
        delete LogWriter;
        LogWriter=NULL;
    }
    if (NULL!=AnalysisReader) {
      delete AnalysisReader;
      AnalysisReader=NULL;
    }
    if (NULL!=hLogFile) {
        CloseHandle(hLogFile);
    }

	return result;
}

void 
CSecurityDatabase::trace(
    PCWSTR szBuffer, 
    HANDLE hLogFile
    )
/*++

Routine Description:

    Internal method to trace info to an error log.

Arguments:
    
    szBuffer:   string to be added to log
    hLogFile:   handle of error log file

Return Value:

    none

--*/
{
    DWORD   dwNumWritten;

    if ((NULL!=hLogFile) && (NULL!=szBuffer)) {    
        WriteFile(hLogFile, 
                  szBuffer, 
                  wcslen(szBuffer)*sizeof(WCHAR), 
                  &dwNumWritten,
                  NULL);
    }
}

void 
CSecurityDatabase::trace(
    UINT   uID, 
    HANDLE hLogFile
    )
/*++

Routine Description:

    Internal method to trace info to an error log.

Arguments:
    
    uID:        ID of string to be added to log
    hLogFile:   handle of error log file

Return Value:

    none

--*/
{
    DWORD   dwNumWritten;
    WCHAR   szTmpStringBuffer[512];
    
    if (NULL!=hLogFile) {    
        LoadString(myModuleHandle,
                   uID,
                   szTmpStringBuffer,
                   sizeof(szTmpStringBuffer)/sizeof(WCHAR));

        WriteFile(hLogFile, 
                  szTmpStringBuffer, 
                  wcslen(szTmpStringBuffer)*sizeof(WCHAR), 
                  &dwNumWritten,
                  NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\secman.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    SecMan.cpp

Abstract:

    Implementation of DLL Exports.
    
Author:

    Steven Chan (t-schan) July 2002

--*/


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SecManps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SecMan.h"

#include "SecMan_i.c"
#include "SecurityDatabase.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SecurityDatabase, CSecurityDatabase)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SECMANLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\scexmllogwriter.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    SceXMLLogWriter.h     (interface of class SceXMLLogWriter)
    SceXMLLogWriter.cpp   (implementation of class SceXMLLogWriter)
    
Abstract:

    SceXMLLogWriter is a class that simplifies the XML Logging of SCE analysis
    data.
    
    It also serves to abstract away the actual log format from SCE. 
    The user of this class need not be aware of the actual output 
    log format thus allowing the format to be changed easily.
    
    Usage of this class is as follows. The class is initialized
    by calling its constructor. It is expected that COM has already
    been initialized when this constructor is called. 
    
    Before logging any settings, SceXMLLogWriter::setNewArea must be called 
    to set the current logging area. After this, the caller can call
    any combination of SceXMLLogWriter::setNewArea and SceXMLLogWriter::addSetting.
    
    Finally, SceXMLLogWriter::saveAs is called to save the output log file.

Author:

    Steven Chan (t-schan) July 2002

--*/

#ifndef SCEXMLLOGWRITERH
#define SCEXMLLOGWRITERH

#include "secedit.h"


#define ERROR_BUFFER_SIZE 80

class SceXMLLogWriter {


public:
    
    // SXTYPE represents the type of data being logged to SceXMLLogWriter::addSetting and 
    // determines how the data will be represented in the log file.
    //
    // TYPE_DEFAULT defines the default representation for the datatype presented
    // to SceXMLLogWriter::addSetting depending on whether it is a DWORD or a PCWSTR
    //
    // TYPE_AUDIT defines audit data (0=none 1=onsuccess, 2=onfail, 3=both)
    //
    // TYPE_BOOLEAN defines (0=FALSE 1=TRUE)

    typedef enum _SXTYPE {
        TYPE_DEFAULT = 0,
        TYPE_AUDIT,		        // valid for DWORD else ignored
        TYPE_BOOLEAN,	        // valid for DWORD else ignored

        TYPE_REG_SZ,			// REG types valid for strings
        TYPE_REG_EXPAND_SZ,
        TYPE_REG_BINARY,
        TYPE_REG_DWORD,
        TYPE_REG_MULTI_SZ
    } SXTYPE;
	

    // SXMATCH_STATUS defines the match status of the values being presented
    // to SceXMLLogWriter::addSetting.

    typedef enum _SXMATCH_STATUS {
        MATCH_TRUE,
        MATCH_FALSE,
        MATCH_NOT_DEFINED,      // not defined in Baseline
        MATCH_NOT_CONFIGURED,   // not configured in System
        MATCH_NOT_ANALYZED,
        MATCH_OTHER,
        MATCH_ERROR
    } SXMATCH_STATUS;
	    

    SceXMLLogWriter();
    void SaveAs(PCWSTR szFileName);
    void SceXMLLogWriter::SetDescription(IN PCWSTR szMachineName,
                                IN PCWSTR szProfileDescription,
                                IN PCWSTR szAnalysisTimestamp);
    void SetNewArea(PCWSTR szAreaName);
    void AddSetting(PCWSTR szSettingName, 
                    PCWSTR szDescription,
                    SXMATCH_STATUS match,
                    DWORD baselineVal, 
                    DWORD systemVal,
                    SXTYPE type);
    void AddSetting(PCWSTR szSettingName,
                    PCWSTR szDescription,
                    DWORD baselineVal,
                    DWORD systemVal,
                    SXTYPE type);
    void AddSetting(PCWSTR szSettingName,
                    PCWSTR szDescription,
                    PCWSTR szBaseline,
                    PCWSTR szSystem,
                    SXTYPE type);
    void AddSetting(PCWSTR szSettingName,
                    PCWSTR szDescription,
                    SXMATCH_STATUS match,
                    PCWSTR szBaseline,
                    PCWSTR szSystem,
                    SXTYPE type);
    void AddSetting(PCWSTR szSettingName,
                    PCWSTR szDescription,
                    SXMATCH_STATUS match,
                    PSCE_NAME_LIST pBaseline,
                    PSCE_NAME_LIST pSystem,
                    SXTYPE type);
    void AddSetting(PCWSTR szSettingName,
                    PCWSTR szDescription,
                    SXMATCH_STATUS match,
                    PSCE_SERVICES pBaseline,
                    PSCE_SERVICES pSystem,
                    SXTYPE type);
    void AddSetting(PCWSTR szSettingName,
                    PCWSTR szDescription,
                    SXMATCH_STATUS match,
                    PSCE_OBJECT_SECURITY pBaseline,
                    PSCE_OBJECT_SECURITY pSystem,
                    SXTYPE type);


private:

    //
    // constants used by SceXMLLogWriter
    //
    
    static CComVariant _variantNodeElement;
    static CComBSTR _bstrMachineName;
    static CComBSTR _bstrProfileDescription; 
    static CComBSTR _bstrAnalysisTimestamp;         
    static CComBSTR _bstrSCEAnalysisData;
    static CComBSTR _bstrSetting; 
    static CComBSTR _bstrAnalysisResult; 
    static CComBSTR _bstrBaselineValue; 
    static CComBSTR _bstrSystemValue;
    static CComBSTR _bstrType; 
    static CComBSTR _bstrName; 
    static CComBSTR _bstrMatch; 
    static CComBSTR _bstrStartupType; 
    static CComBSTR _bstrForever;
    static CComBSTR _bstrNotDefined; 
    static CComBSTR _bstrNotAnalyzed; 
    static CComBSTR _bstrNotConfigured; 
    static CComBSTR _bstrOther;
    static CComBSTR _bstrTrue; 
    static CComBSTR _bstrFalse; 
    static CComBSTR _bstrError; 
    static CComBSTR _bstrSpecial; 
    static CComBSTR _bstrInteger; 
    static CComBSTR _bstrBoolean; 
    static CComBSTR _bstrSecurityDescriptor; 
    static CComBSTR _bstrAccount; 
    static CComBSTR _bstrAccounts; 
    static CComBSTR _bstrEventAudit;         
    static CComBSTR _bstrSuccess; 
    static CComBSTR _bstrFailure; 
    static CComBSTR _bstrServiceSetting; 
    static CComBSTR _bstrBoot; 
    static CComBSTR _bstrSystem; 
    static CComBSTR _bstrAutomatic; 
    static CComBSTR _bstrManual; 
    static CComBSTR _bstrDisabled; 
    static CComBSTR _bstrString; 
    static CComBSTR _bstrRegSZ; 
    static CComBSTR _bstrRegExpandSZ; 
    static CComBSTR _bstrRegBinary; 
    static CComBSTR _bstrRegDWORD; 
    static CComBSTR _bstrRegMultiSZ; 
    static CComBSTR _bstrDescription;

    //
    // variables that hold current logging state
    //

    CComPtr<IXMLDOMDocument> spXMLDOM; 	    // the xml document
    CComPtr<IXMLDOMNode> spRootNode;	    // root node
    CComPtr<IXMLDOMNode> spCurrentArea;	    // note of current analysis area


    //
    // private methods
    //

    CComPtr<IXMLDOMNode> CreateNodeWithText(BSTR szNodeName, BSTR szText);
    CComPtr<IXMLDOMNode> CreateTypedNode(BSTR szNodeName, DWORD value, SXTYPE type);
    CComPtr<IXMLDOMNode> CreateTypedNode(BSTR szNodeName, BSTR value, SXTYPE type);
    CComPtr<IXMLDOMNode> CreateTypedNode(BSTR szNodeName, PSCE_NAME_LIST value, SXTYPE type);
    CComPtr<IXMLDOMNode> CreateTypedNode(BSTR szNodeName, PSCE_SERVICES value, SXTYPE type);
    CComPtr<IXMLDOMNode> CreateTypedNode(BSTR szNodeName, PSCE_OBJECT_SECURITY value, SXTYPE type);
    
    void AddSetting(BSTR bstrSettingName, 
                    BSTR bstrDescription,
                    SXMATCH_STATUS match,
                    IXMLDOMNode* spnBaseline, 
                    IXMLDOMNode* spnSystem);

    // for error checking

    static void CheckAppendChildResult(IN HRESULT hr);
    static void CheckCreateNodeResult(IN HRESULT hr);   
    static void CheckCreatedCComBSTR(IN CComBSTR bstrIn);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\stdafx.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    source file that includes just the standard includes
    stdafx.pch will be the pre-compiled header
    stdafx.obj will contain the pre-compiled type information

Author:

    Steven Chan (t-schan) - July 2002

--*/


#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\stdafx.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    Include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently

Author:

    Steven Chan (t-schan) - July 2002

--*/


#if !defined(AFX_STDAFX_H__E3A3D579_55AA_4CB6_B065_1DCE85F29EEA__INCLUDED_)
#define AFX_STDAFX_H__E3A3D579_55AA_4CB6_B065_1DCE85F29EEA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E3A3D579_55AA_4CB6_B065_1DCE85F29EEA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\exe\resource.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    resource.h
    
Abstract:

    contains strings definitions for SCE/JET->XML tool

Author:

    Steven Chan (t-schan) July 2002

--*/

#ifndef  SCEXMLRESOURCEH
#define SCEXMLRESOURCEH

#define IDS_PROGRAM_INFO                100
#define IDS_PROGRAM_USAGE_0             101
#define IDS_PROGRAM_USAGE_1				102
#define IDS_PROGRAM_SUCCESS             103

#define IDS_SECMAN_INIT		    104
#define IDS_ERROR_CLASSNOTREG	105
#define IDS_ERROR_NOAGGREGATION	106
#define IDS_ERROR_NOINTERFACE	107
#define IDS_ERROR_OLDWINVERSION	108
#define IDS_ERROR_MODNOTFOUND	109
#define IDS_ERROR_WRITEFAULT	110
#define IDS_ERROR_INVALIDFILENAME	111			
#define IDS_ERROR_ACCESSDENIED	112
#define IDS_ERROR_OPENFAILED	113
#define IDS_ERROR_FILENOTFOUND	114
#define IDS_ERROR_READFAULT	    115
#define IDS_ERROR_OUTOFMEMORY	116
#define IDS_ERROR_UNEXPECTED	117

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\table.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    table.h
        
Abstract:

    contains tables that specify settings within SCE_PROFILE_INFO that
    will be logged within the SystemAccess and SystemAudit sections.
    
    the intent of these tables is to reduce code length and to make it easy
    to add and remove more settings for the two areas within the 
    PSCE_PROFILE_INFO structure without having to modify the code much.
    
    Each table should only contain DWORD values. 
   
Author:

    Steven Chan (t-schan) July 2002

--*/

#ifndef SCEXMLTABLEH
#define SCEXMLTABLEH

#include "SceXMLLogWriter.h"
#include "secedit.h"
#include "SceProfInfoAdapter.h"

typedef struct _tableEntry {
    PCWSTR			name;
    UINT			displayNameUID;
    SceXMLLogWriter::SXTYPE 	displayType;
    size_t			offset;
} tableEntry;

#define TYPECAST(type, bufptr, offset) (*((type *)((byte *)bufptr + offset)))

// table of DWORD values for area System Access

static tableEntry tableSystemAccess[] = {
    {(PCWSTR)TEXT("MinimumPasswordAge"), IDS_SETTING_MIN_PAS_AGE, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, MinimumPasswordAge)},
    {(PCWSTR)TEXT("MaximumPasswordAge"), IDS_SETTING_MAX_PAS_AGE, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, MaximumPasswordAge)},
    {(PCWSTR)TEXT("MinimumPasswordLength"), IDS_SETTING_MIN_PAS_LEN, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, MinimumPasswordLength)},
    {(PCWSTR)TEXT("PasswordComplexity"), IDS_SETTING_PAS_COMPLEX, SceXMLLogWriter::TYPE_BOOLEAN, offsetof(SceProfInfoAdapter, PasswordComplexity)},
    {(PCWSTR)TEXT("PasswordHistorySize"), IDS_SETTING_PAS_UNIQUENESS, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, PasswordHistorySize)},
    {(PCWSTR)TEXT("LockoutBadCount"), IDS_SETTING_LOCK_COUNT, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, LockoutBadCount)},
    {(PCWSTR)TEXT("ResetLockoutCount"), IDS_SETTING_LOCK_RESET_COUNT, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, ResetLockoutCount)},
    {(PCWSTR)TEXT("LockoutDuration"), IDS_SETTING_LOCK_DURATION, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, LockoutDuration)},
    {(PCWSTR)TEXT("RequireLogonToChangePassword"), IDS_SETTING_REQ_LOGON, SceXMLLogWriter::TYPE_BOOLEAN, offsetof(SceProfInfoAdapter, RequireLogonToChangePassword)},
    {(PCWSTR)TEXT("ForceLogoffWhenHourExpire"), IDS_SETTING_FORCE_LOGOFF, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, ForceLogoffWhenHourExpire)},
    {(PCWSTR)TEXT("SecureSystemPartition"), IDS_SETTING_SEC_SYS_PARTITION, SceXMLLogWriter::TYPE_BOOLEAN, offsetof(SceProfInfoAdapter, SecureSystemPartition)},
    {(PCWSTR)TEXT("ClearTextPassword"), IDS_SETTING_CLEAR_PASSWORD, SceXMLLogWriter::TYPE_BOOLEAN, offsetof(SceProfInfoAdapter, ClearTextPassword)},
    {(PCWSTR)TEXT("LSAAnonymousNameLookup"), IDS_SETTING_LSA_ANON_LOOKUP, SceXMLLogWriter::TYPE_BOOLEAN, offsetof(SceProfInfoAdapter, LSAAnonymousNameLookup)}
};


// table of DWORD values for area System Audit

static tableEntry tableSystemAudit[] = {
    {(PCWSTR)TEXT("MaximumSystemLogSize"), IDS_SETTING_SYS_LOG_MAX, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, MaximumLogSize[0])},
    {(PCWSTR)TEXT("MaximumSecurityLogSize"), IDS_SETTING_SEC_LOG_MAX, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, MaximumLogSize[1])},
    {(PCWSTR)TEXT("MaximumApplicationLogSize"), IDS_SETTING_APP_LOG_MAX, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, MaximumLogSize[2])},
    {(PCWSTR)TEXT("AuditSystemLogRetentionPeriod"), IDS_SETTING_SYS_LOG_RET, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, AuditLogRetentionPeriod[0])},
    {(PCWSTR)TEXT("AuditSecurityLogRetentionPeriod"), IDS_SETTING_SEC_LOG_RET, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, AuditLogRetentionPeriod[1])},
    {(PCWSTR)TEXT("AuditApplicationLogRetentionPeriod"), IDS_SETTING_APP_LOG_RET, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, AuditLogRetentionPeriod[2])},
    {(PCWSTR)TEXT("SystemRetentionDays"), IDS_SETTING_SYS_LOG_DAYS, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, RetentionDays[0])},
    {(PCWSTR)TEXT("SecurityRetentionDays"), IDS_SETTING_SEC_LOG_DAYS, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, RetentionDays[1])},
    {(PCWSTR)TEXT("ApplicationRetentionDays"), IDS_SETTING_APP_LOG_DAYS, SceXMLLogWriter::TYPE_DEFAULT, offsetof(SceProfInfoAdapter, RetentionDays[2])},
    {(PCWSTR)TEXT("SystemRestrictGuestAccess"), IDS_SETTING_SYS_LOG_GUEST, SceXMLLogWriter::TYPE_BOOLEAN, offsetof(SceProfInfoAdapter, RestrictGuestAccess[0])},
    {(PCWSTR)TEXT("SecurityRestrictGuestAccess"), IDS_SETTING_SEC_LOG_GUEST, SceXMLLogWriter::TYPE_BOOLEAN, offsetof(SceProfInfoAdapter, RestrictGuestAccess[1])},
    {(PCWSTR)TEXT("ApplicationRestrictGuestAccess"), IDS_SETTING_APP_LOG_GUEST, SceXMLLogWriter::TYPE_BOOLEAN, offsetof(SceProfInfoAdapter, RestrictGuestAccess[2])},
    {(PCWSTR)TEXT("AuditSystemEvents"), IDS_SETTING_SYSTEM_EVENT, SceXMLLogWriter::TYPE_AUDIT, offsetof(SceProfInfoAdapter, AuditSystemEvents)},
    {(PCWSTR)TEXT("AuditLogonEvents"), IDS_SETTING_LOGON_EVENT, SceXMLLogWriter::TYPE_AUDIT, offsetof(SceProfInfoAdapter, AuditLogonEvents)},
    {(PCWSTR)TEXT("AuditObjectAccess"), IDS_SETTING_OBJECT_ACCESS, SceXMLLogWriter::TYPE_AUDIT, offsetof(SceProfInfoAdapter, AuditObjectAccess)},
    {(PCWSTR)TEXT("AuditPrivilegeUse"), IDS_SETTING_PRIVILEGE_USE, SceXMLLogWriter::TYPE_AUDIT, offsetof(SceProfInfoAdapter, AuditPrivilegeUse)},
    {(PCWSTR)TEXT("AuditPolicyChange"), IDS_SETTING_POLICY_CHANGE, SceXMLLogWriter::TYPE_AUDIT, offsetof(SceProfInfoAdapter, AuditPolicyChange)},
    {(PCWSTR)TEXT("AuditAccountManage"), IDS_SETTING_ACCOUNT_MANAGE, SceXMLLogWriter::TYPE_AUDIT, offsetof(SceProfInfoAdapter, AuditAccountManage)},
    {(PCWSTR)TEXT("AuditProcessTracking"), IDS_SETTING_PROCESS_TRACK, SceXMLLogWriter::TYPE_AUDIT, offsetof(SceProfInfoAdapter, AuditProcessTracking)},
    {(PCWSTR)TEXT("AuditDSAccess"), IDS_SETTING_DIRECTORY_ACCESS, SceXMLLogWriter::TYPE_AUDIT, offsetof(SceProfInfoAdapter, AuditDSAccess)},
    {(PCWSTR)TEXT("AuditAccountLogon"), IDS_SETTING_ACCOUNT_LOGON, SceXMLLogWriter::TYPE_AUDIT, offsetof(SceProfInfoAdapter, AuditAccountLogon)},
    {(PCWSTR)TEXT("CrashOnAuditFull"), IDS_SETTING_CRASH_LOG_FULL, SceXMLLogWriter::TYPE_BOOLEAN, offsetof(SceProfInfoAdapter, CrashOnAuditFull)}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\w2kstructdefs.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    w2kstructdefs.h

Abstract:

    structure definitions for a few w2k secedit.h structures
    that are different from their xp definitions; specifically
    SCE_PROFILE_INFO and SCETYPE
    
    necessary for compatibility with w2k
    
Author:

    Steven Chan (t-schan) July 2002

--*/

#ifndef W2KSTRUCTDEFSH
#define W2KSTRUCTDEFSH

//
// Windows 2000 Profile structure
//
typedef struct _W2K_SCE_PROFILE_INFO {

// Type is used to free the structure by SceFreeMemory
    SCETYPE      Type;
//
// Area: System access
//
    DWORD       MinimumPasswordAge;
    DWORD       MaximumPasswordAge;
    DWORD       MinimumPasswordLength;
    DWORD       PasswordComplexity;
    DWORD       PasswordHistorySize;
    DWORD       LockoutBadCount;
    DWORD       ResetLockoutCount;
    DWORD       LockoutDuration;
    DWORD       RequireLogonToChangePassword;
    DWORD       ForceLogoffWhenHourExpire;
    PWSTR       NewAdministratorName;
    PWSTR       NewGuestName;
    DWORD       SecureSystemPartition;
    DWORD       ClearTextPassword;
    union {
        struct {
            // Area : user settings (scp)
            PSCE_NAME_LIST   pAccountProfiles;
            // Area: privileges
            // Name field is the user/group name, Status field is the privilege(s)
            //     assigned to the user/group
            union {
//                PSCE_NAME_STATUS_LIST        pPrivilegeAssignedTo;
                PSCE_PRIVILEGE_VALUE_LIST   pPrivilegeAssignedTo;
                PSCE_PRIVILEGE_ASSIGNMENT    pInfPrivilegeAssignedTo;
            } u;
        } scp;
        struct {
            // Area: user settings (sap)
            PSCE_NAME_LIST        pUserList;
            // Area: privileges
            PSCE_PRIVILEGE_ASSIGNMENT    pPrivilegeAssignedTo;
        } sap;
        struct {
            // Area: user settings (smp)
            PSCE_NAME_LIST        pUserList;
            // Area: privileges
            // See sap structure for pPrivilegeAssignedTo
            PSCE_PRIVILEGE_ASSIGNMENT    pPrivilegeAssignedTo;
        } smp;
    } OtherInfo;

// Area: group membership
    PSCE_GROUP_MEMBERSHIP        pGroupMembership;

// Area: Registry
    SCE_OBJECTS            pRegistryKeys;

// Area: System Services
    PSCE_SERVICES                pServices;

// System storage
    SCE_OBJECTS            pFiles;
//
// ds object
//
    SCE_OBJECTS            pDsObjects;
//
// kerberos policy settings
//
    PSCE_KERBEROS_TICKET_INFO pKerberosInfo;
//
// System audit 0-system 1-security 2-application
//
    DWORD                 MaximumLogSize[3];
    DWORD                 AuditLogRetentionPeriod[3];
    DWORD                 RetentionDays[3];
    DWORD                 RestrictGuestAccess[3];
    DWORD                 AuditSystemEvents;
    DWORD                 AuditLogonEvents;
    DWORD                 AuditObjectAccess;
    DWORD                 AuditPrivilegeUse;
    DWORD                 AuditPolicyChange;
    DWORD                 AuditAccountManage;
    DWORD                 AuditProcessTracking;
    DWORD                 AuditDSAccess;
    DWORD                 AuditAccountLogon;
    DWORD                 CrashOnAuditFull;

//
// registry values
//
    DWORD                       RegValueCount;
    PSCE_REGISTRY_VALUE_INFO    aRegValues;

}W2K_SCE_PROFILE_INFO, *PW2K_SCE_PROFILE_INFO;

typedef enum _W2K_SCE_TYPE {

    W2K_SCE_ENGINE_SCP=300,     // effective table
    W2K_SCE_ENGINE_SAP,         // analysis table
    W2K_SCE_ENGINE_SCP_INTERNAL,
    W2K_SCE_ENGINE_SMP_INTERNAL,
    W2K_SCE_ENGINE_SMP,         // local table
    W2K_SCE_STRUCT_INF,
    W2K_SCE_STRUCT_PROFILE,
    W2K_SCE_STRUCT_USER,
    W2K_SCE_STRUCT_NAME_LIST,
    W2K_SCE_STRUCT_NAME_STATUS_LIST,
    W2K_SCE_STRUCT_PRIVILEGE,
    W2K_SCE_STRUCT_GROUP,
    W2K_SCE_STRUCT_OBJECT_LIST,
    W2K_SCE_STRUCT_OBJECT_CHILDREN,
    W2K_SCE_STRUCT_OBJECT_SECURITY,
    W2K_SCE_STRUCT_OBJECT_ARRAY,
    W2K_SCE_STRUCT_ERROR_LOG_INFO,
    W2K_SCE_STRUCT_SERVICES,
    W2K_SCE_STRUCT_PRIVILEGE_VALUE_LIST

} W2KSCETYPE;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\securitydatabase.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    SecurityDatabase.cpp

Abstract:

    Definition of CSecurityDatabase interface
    
    SecurityDatabase is a COM interface that allows users to perform
    basic operations on SCE security databases such as analysis,
    import and export.
    
Author:

    Steven Chan (t-schan) July 2002

--*/


#ifndef __SECURITYDATABASE_H_
#define __SECURITYDATABASE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSecurityDatabase
class ATL_NO_VTABLE CSecurityDatabase : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSecurityDatabase, &CLSID_SecurityDatabase>,
	public IDispatchImpl<ISecurityDatabase, &IID_ISecurityDatabase, &LIBID_SECMANLib>
{
public:
	CSecurityDatabase();

DECLARE_REGISTRY_RESOURCEID(IDR_SECURITYDATABASE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSecurityDatabase)
	COM_INTERFACE_ENTRY(ISecurityDatabase)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISecurityDatabase
public:
	STDMETHOD(ExportAnalysisToXML)(BSTR FileName, BSTR ErrorLogFileName);
	STDMETHOD(Analyze)();
	STDMETHOD(ImportTemplateString)(BSTR TemplateString);
	STDMETHOD(ImportTemplateFile)(BSTR FileName);
	STDMETHOD(get_MachineName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_MachineName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FileName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FileName)(/*[in]*/ BSTR newVal);

private:
    HMODULE myModuleHandle;
    CComBSTR bstrFileName;
    void trace(PCWSTR szBuffer, HANDLE hLogFile);
    void trace(UINT uID, HANDLE hLogFile);

};

#endif //__SECURITYDATABASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\scerpc\xml-jet\secman\exe\secexport.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    xml-jet.cpp

Abstract:

    Command line tool for exporting SCE anaylsis data from an
    SCE JET Database to XML
    
Author:

    Steven Chan (t-schan) July 2002

--*/


//
// System header files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <shlwapi.h>
#include <winnlsp.h>
#include <sddl.h>

//
// COM/XML header files
//

#include <atlbase.h>
#include <objbase.h>

//
// CRT header files
//

#include <process.h>
#include <wchar.h>
#include <stddef.h>
#include <stdlib.h>
#include <iostream.h>
#include <stdio.h>
#include <time.h>
#include <limits.h>
#include <io.h>
#include <locale.h>

#include "resource.h"
#include "SecMan.h"


#define STRING_BUFFER_SIZE 512
WCHAR   szTmpStringBuffer[STRING_BUFFER_SIZE];
HMODULE myModuleHandle;
void printIDS(IN UINT uID);



void 
__cdecl wmain(
    int argc, 
    WCHAR * argv[]
    )
/*++

Routine Description:

    Main routine of the SCE/JET to XML executable

    Opens the specified .sdb file, reads the logged System Values and
    Baseline Values from the .sdb file, then uses the SecLogger class to 
    format log these results. Currently SecLogger logs to XML.

Usage:

    <exename> infilename outfilename    
    
    infilename:     The filename of the .sdb database to be opened
    outfilename:    The filename of the generated (XML) log file

Return Value:

    none        

--*/
{
        	
    WCHAR               szInFile[_MAX_PATH];
    WCHAR               szOutFile[_MAX_PATH];
    WCHAR               szErrLogFile[_MAX_PATH];

    myModuleHandle=GetModuleHandle(NULL);

    //
    // call SetThreadUILanguage() indirectly for win2k compatability
    //

    typedef void (CALLBACK* LPFNSETTHREADUILANGUAGE)();
    typedef void (CALLBACK* LPFNSETTHREADUILANGUAGE2)(DWORD);
    
    HMODULE hKern32;               // Handle to Kernel32 dll
    LPFNSETTHREADUILANGUAGE lpfnSetThreadUILanguage;    // Function pointer
    
    hKern32 = LoadLibrary(L"kernel32.dll");
    if (hKern32 != NULL)
    {
       lpfnSetThreadUILanguage = (LPFNSETTHREADUILANGUAGE) GetProcAddress(hKern32,
                                                                          "SetThreadUILanguage");
       if (!lpfnSetThreadUILanguage)
       {
          FreeLibrary(hKern32);
       }
       else
       {
          // call the function
          lpfnSetThreadUILanguage();
       }
    }

    //
    // Check that Command Line args are valid
    // 
    
    printIDS(IDS_PROGRAM_INFO);
    if ((argc!=3)&&(argc!=4)) {	// progname src dest

        //
        // arg count wrong; output usage
        //
        
        printIDS(IDS_PROGRAM_USAGE_0);
        wprintf(argv[0]);	                // print progname
        printIDS(IDS_PROGRAM_USAGE_1);
        return;	// quit
    }


    // convert filenames to full pathnames

    _wfullpath(szInFile, argv[1], _MAX_PATH);
    _wfullpath(szOutFile, argv[2], _MAX_PATH);
        

    // load security database interface

    CoInitialize(NULL);

    CComPtr<ISecurityDatabase> SecDB;

    HRESULT hr = SecDB.CoCreateInstance(__uuidof(SecurityDatabase));

    switch(hr) {
    case S_OK:
        printIDS(IDS_SECMAN_INIT);
        break;
    case REGDB_E_CLASSNOTREG:
        printIDS(IDS_ERROR_CLASSNOTREG);
        break;
    case CLASS_E_NOAGGREGATION:
        printIDS(IDS_ERROR_NOAGGREGATION);
        break;
    case E_NOINTERFACE:
        printIDS(IDS_ERROR_NOINTERFACE);
        break;
    default:
        printIDS(IDS_ERROR_UNEXPECTED);
        break;
    }

    // set database filename

    if (SUCCEEDED(hr)) {
        hr=SecDB->put_FileName(CComBSTR(szInFile));

        switch(hr) {
        case S_OK:
            break;
        case E_INVALIDARG:
            printIDS(IDS_ERROR_INVALIDFILENAME);
            break;
        case E_OUTOFMEMORY:
            printIDS(IDS_ERROR_OUTOFMEMORY);
            break;
        }
    }

    // export analysis

    if (SUCCEEDED(hr)) {
        if (argc==4) {
            _wfullpath(szErrLogFile, argv[3], _MAX_PATH);  
            hr=SecDB->ExportAnalysisToXML(CComBSTR(szOutFile), CComBSTR(szErrLogFile));
        } else {
            hr=SecDB->ExportAnalysisToXML(CComBSTR(szOutFile), NULL);        
        }    
        switch(hr) {
        case S_OK:
            printIDS(IDS_PROGRAM_SUCCESS);
            wprintf(szOutFile);
            wprintf(L"\n\r");
            break;
        case ERROR_OLD_WIN_VERSION:
            printIDS(IDS_ERROR_OLDWINVERSION);
            break;
        case ERROR_MOD_NOT_FOUND:
            printIDS(IDS_ERROR_MODNOTFOUND);
            break;
        case ERROR_WRITE_FAULT:
            printIDS(IDS_ERROR_WRITEFAULT);
            break;
        case ERROR_INVALID_NAME:
            printIDS(IDS_ERROR_INVALIDFILENAME);
            break;
        case E_ACCESSDENIED:
            printIDS(IDS_ERROR_ACCESSDENIED);
            break;
        case ERROR_OPEN_FAILED:
            printIDS(IDS_ERROR_OPENFAILED);
            break;
        case ERROR_FILE_NOT_FOUND:
            printIDS(IDS_ERROR_FILENOTFOUND);
            break;
        case ERROR_READ_FAULT:
            printIDS(IDS_ERROR_READFAULT);
            break;
        case E_OUTOFMEMORY:
            printIDS(IDS_ERROR_OUTOFMEMORY);
            break;
        case E_UNEXPECTED:
        default:
            printIDS(IDS_ERROR_UNEXPECTED);
            break;
        }
    }

    wprintf(L"\n\r");

    CoUninitialize();
    
    // SetThreadUILanguage(0);

    if (lpfnSetThreadUILanguage)
    {
        ((LPFNSETTHREADUILANGUAGE2)lpfnSetThreadUILanguage)(0);
    }

}



void 
printIDS(
    IN UINT uID
    )
/*++

Routine Description:

    Helper function for automating printing of strings from stringtable

Usage:

    uID:    resource ID of string to be printed    

Return Value:

    none        

--*/
{
    LoadString(myModuleHandle,
               uID,
               szTmpStringBuffer,
               STRING_BUFFER_SIZE);		
    wprintf(szTmpStringBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\common\ntacls.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    NTacls

Abstract:

    This module implements the CSecurityAttribute class.  It's job is to
    encapsulate the NT security descriptors as needed by Calais.

Author:

    Doug Barlow (dbarlow) 1/24/1997

Environment:

    Windows NT, Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <CalaisLb.h>


const CSecurityDescriptor::SecurityId
    CSecurityDescriptor::SID_Null =        { SECURITY_NULL_SID_AUTHORITY,    1, SECURITY_NULL_RID,           0 },
    CSecurityDescriptor::SID_World =       { SECURITY_WORLD_SID_AUTHORITY,   1, SECURITY_WORLD_RID,          0 },
    CSecurityDescriptor::SID_Owner =       { SECURITY_CREATOR_SID_AUTHORITY, 1, SECURITY_CREATOR_OWNER_RID,  0 },
    CSecurityDescriptor::SID_Group =       { SECURITY_CREATOR_SID_AUTHORITY, 1, SECURITY_CREATOR_GROUP_RID,  0 },
    CSecurityDescriptor::SID_Admins =      { SECURITY_NT_AUTHORITY,          2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS },
    CSecurityDescriptor::SID_SrvOps =      { SECURITY_NT_AUTHORITY,          2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_SYSTEM_OPS },
    CSecurityDescriptor::SID_DialUp =      { SECURITY_NT_AUTHORITY,          1, SECURITY_DIALUP_RID,         0 },
    CSecurityDescriptor::SID_Network =     { SECURITY_NT_AUTHORITY,          1, SECURITY_NETWORK_RID,        0 },
    CSecurityDescriptor::SID_Batch =       { SECURITY_NT_AUTHORITY,          1, SECURITY_BATCH_RID,          0 },
    CSecurityDescriptor::SID_Interactive = { SECURITY_NT_AUTHORITY,          1, SECURITY_INTERACTIVE_RID,    0 },
    CSecurityDescriptor::SID_Service =     { SECURITY_NT_AUTHORITY,          1, SECURITY_SERVICE_RID,        0 },
    CSecurityDescriptor::SID_System =      { SECURITY_NT_AUTHORITY,          1, SECURITY_LOCAL_SYSTEM_RID,   0 },
    CSecurityDescriptor::SID_LocalService ={ SECURITY_NT_AUTHORITY,          1, SECURITY_LOCAL_SERVICE_RID,  0 },
    CSecurityDescriptor::SID_SysDomain =   { SECURITY_NT_AUTHORITY,          1, SECURITY_BUILTIN_DOMAIN_RID, 0 },
    CSecurityDescriptor::SID_RemoteInteractive = 
                                           { SECURITY_NT_AUTHORITY,          1, SECURITY_REMOTE_LOGON_RID,   0 };  

CSecurityDescriptor::CSecurityDescriptor()
{
    m_pSD = NULL;
    m_pOwner = NULL;
    m_pGroup = NULL;
    m_pDACL = NULL;
    m_pSACL= NULL;
    m_fInheritance = FALSE;
}

CSecurityDescriptor::~CSecurityDescriptor()
{
    if (m_pSD)
        delete m_pSD;
    if (m_pOwner)
        delete[] (LPBYTE)m_pOwner;
    if (m_pGroup)
        delete[] (LPBYTE)m_pGroup;
    if (m_pDACL)
        delete[] (LPBYTE)m_pDACL;
    if (m_pSACL)
        delete[] (LPBYTE)m_pSACL;
}

HRESULT CSecurityDescriptor::Initialize()
{
    if (m_pSD)
    {
        delete m_pSD;
        m_pSD = NULL;
    }
    if (m_pOwner)
    {
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
    }
    if (m_pGroup)
    {
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
    }
    if (m_pDACL)
    {
        delete[] (LPBYTE)(m_pDACL);
        m_pDACL = NULL;
    }
    if (m_pSACL)
    {
        delete[] (LPBYTE)(m_pSACL);
        m_pSACL = NULL;
    }

    m_pSD = new SECURITY_DESCRIPTOR;
    if (!m_pSD)
        return E_OUTOFMEMORY;
    if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        delete m_pSD;
        m_pSD = NULL;
        _ASSERTE(FALSE);
        return hr;
    }
    // Set the DACL to allow EVERYONE
    /*
    No, this is not a safe thing to do.  The SD in this state grants
    Everyone full control.  Instead, leave the Security Descriptor 
    without a Dacl - all access is denied by default.  Callers
    should add the Ace's they require.
    
    SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);
    */

    return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
    PSID pUserSid;
    PSID pGroupSid;
    HRESULT hr;

    Initialize();
    hr = GetProcessSids(&pUserSid, &pGroupSid);
    if (!FAILED(hr))
        hr = SetOwner(pUserSid, bDefaulted);
    if (!FAILED(hr))
        hr = SetGroup(pGroupSid, bDefaulted);

    if (pUserSid)
        delete[] (LPBYTE)(pUserSid);
    if (pGroupSid)
        delete[] (LPBYTE)(pGroupSid);

    if (FAILED(hr))
        return hr;
    return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
    PSID pUserSid;
    PSID pGroupSid;
    HRESULT hr;

    Initialize();
    hr = GetThreadSids(&pUserSid, &pGroupSid);
    if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
        hr = GetProcessSids(&pUserSid, &pGroupSid);
    if (!FAILED(hr))
        hr = SetOwner(pUserSid, bDefaulted);
    if (!FAILED(hr))
        hr = SetGroup(pGroupSid, bDefaulted);

    if (pUserSid)
        delete[] (LPBYTE)(pUserSid);
    if (pGroupSid)
        delete[] (LPBYTE)(pGroupSid);

    if (FAILED(hr))
        return hr;
    return S_OK;
}

HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
    _ASSERTE(m_pSD);

    // Mark the SD as having no owner
    if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }

    if (m_pOwner)
    {
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
    }

    // If they asked for no owner don't do the copy
    if (pOwnerSid == NULL)
        return S_OK;

    // Make a copy of the Sid for the return value
    DWORD dwSize = GetLengthSid(pOwnerSid);

    m_pOwner = (PSID) new BYTE[dwSize];
    if (!m_pOwner)
    {
        // Insufficient memory to allocate Sid
        _ASSERTE(FALSE);
        return E_OUTOFMEMORY;
    }
    if (!CopySid(dwSize, m_pOwner, pOwnerSid))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
        return hr;
    }

    _ASSERTE(IsValidSid(m_pOwner));

    if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
    _ASSERTE(m_pSD);

    // Mark the SD as having no Group
    if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }

    if (m_pGroup)
    {
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
    }

    // If they asked for no Group don't do the copy
    if (pGroupSid == NULL)
        return S_OK;

    // Make a copy of the Sid for the return value
    DWORD dwSize = GetLengthSid(pGroupSid);

    m_pGroup = (PSID) new BYTE[dwSize];
    if (!m_pGroup)
    {
        // Insufficient memory to allocate Sid
        _ASSERTE(FALSE);
        return E_OUTOFMEMORY;
    }
    if (!CopySid(dwSize, m_pGroup, pGroupSid))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
        return hr;
    }

    _ASSERTE(IsValidSid(m_pGroup));

    if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::Allow(const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, psidPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::AllowOwner(DWORD dwAccessMask)
{
    HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Deny(const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, psidPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
    HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
    BOOL bRes;
    HRESULT hr;
    HANDLE hToken = NULL;
    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;
    bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
    if (!bRes)
    {
        // Couldn't open process token
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }
    hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
    CloseHandle(hToken);
    return hr;
}

HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
    BOOL bRes;
    HRESULT hr;
    HANDLE hToken = NULL;
    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;
    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
    if (!bRes)
    {
        // Couldn't open thread token
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }
    hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
    CloseHandle(hToken);
    return hr;
}


HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
    DWORD dwSize;
    HRESULT hr;
    PTOKEN_USER ptkUser = NULL;
    PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;

    if (ppUserSid)
    {
        // Get length required for TokenUser by specifying buffer length of 0
        GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
        {
            // Expected ERROR_INSUFFICIENT_BUFFER
            _ASSERTE(FALSE);
            hr = HRESULT_FROM_WIN32(hr);
            goto failed;
        }

        ptkUser = (TOKEN_USER*) new BYTE[dwSize];
        if (!ptkUser)
        {
            // Insufficient memory to allocate TOKEN_USER
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        // Get Sid of process token.
        if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
        {
            // Couldn't get user info
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        // Make a copy of the Sid for the return value
        dwSize = GetLengthSid(ptkUser->User.Sid);

        PSID pSid = (PSID) new BYTE[dwSize];
        if (!pSid)
        {
            // Insufficient memory to allocate Sid
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        _ASSERTE(IsValidSid(pSid));
        *ppUserSid = pSid;
        delete[] (LPBYTE)(ptkUser);
        ptkUser = NULL;
    }
    if (ppGroupSid)
    {
        // Get length required for TokenPrimaryGroup by specifying buffer length of 0
        GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
        {
            // Expected ERROR_INSUFFICIENT_BUFFER
            _ASSERTE(FALSE);
            hr = HRESULT_FROM_WIN32(hr);
            goto failed;
        }

        ptkGroup = (TOKEN_PRIMARY_GROUP*) new BYTE[dwSize];
        if (!ptkGroup)
        {
            // Insufficient memory to allocate TOKEN_USER
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        // Get Sid of process token.
        if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
        {
            // Couldn't get user info
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        // Make a copy of the Sid for the return value
        dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

        PSID pSid = (PSID) new BYTE[dwSize];
        if (!pSid)
        {
            // Insufficient memory to allocate Sid
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        _ASSERTE(IsValidSid(pSid));

        *ppGroupSid = pSid;
        delete[] (LPBYTE)(ptkGroup);
        ptkGroup = NULL;
    }

    return S_OK;

failed:
    if (ptkUser)
        delete[] (LPBYTE)(ptkUser);
    if (ptkGroup)
        delete[] (LPBYTE)(ptkGroup);
    return hr;
}


HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
    HANDLE tkHandle = NULL;
    HRESULT hr = S_OK;

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
    {
        TOKEN_USER *tkUser = NULL;
        DWORD tkSize = 0;
        DWORD sidLength = 0;

        // Call to get size information for alloc
        if (FALSE == GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(tkHandle);
            return hr;
        }

        tkUser = (TOKEN_USER *) new BYTE[tkSize];
        if (NULL == tkUser)
        {
            CloseHandle(tkHandle);
            return E_OUTOFMEMORY;
        }

        // Now make the real call
        if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
        {
            sidLength = GetLengthSid(tkUser->User.Sid);
            *ppSid = (PSID) new BYTE[sidLength];
            if (NULL != *ppSid)
            {
                memcpy(*ppSid, tkUser->User.Sid, sidLength);
                CloseHandle(tkHandle);

                delete[] (LPBYTE)(tkUser);
                return S_OK;
            }
            else
            {
                CloseHandle(tkHandle);
                delete[] (LPBYTE)(tkUser);
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            CloseHandle(tkHandle);
            delete[] (LPBYTE)(tkUser);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
    HRESULT hr;
    LPTSTR pszRefDomain = NULL;
    DWORD dwDomainSize = 0;
    DWORD dwSidSize = 0;
    SID_NAME_USE snu;

    // Call to get size info for alloc
    LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

    hr = GetLastError();
    if (hr != ERROR_INSUFFICIENT_BUFFER)
        return HRESULT_FROM_WIN32(hr);

    pszRefDomain = new TCHAR[dwDomainSize];
    if (pszRefDomain == NULL)
        return E_OUTOFMEMORY;

    *ppSid = (PSID) new BYTE[dwSidSize];
    if (*ppSid != NULL)
    {
        if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
        {
            delete[] (LPBYTE)(*ppSid);
            *ppSid = NULL;
            delete[] pszRefDomain;
            return HRESULT_FROM_WIN32(GetLastError());
        }
        delete[] pszRefDomain;
        return S_OK;
    }
    delete[] pszRefDomain;
    return E_OUTOFMEMORY;
}


HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
    PACL    pDACL = NULL;
    PACL    pSACL = NULL;
    BOOL    bDACLPresent, bSACLPresent;
    BOOL    bDefaulted;
    PACL    m_pDACL = NULL;
    ACCESS_ALLOWED_ACE* pACE;
    HRESULT hr;
    PSID    pUserSid;
    PSID    pGroupSid;

    hr = Initialize();
    if(FAILED(hr))
        return hr;

    // get the existing DACL.
    if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
        goto failed;

    if (bDACLPresent)
    {
        if (pDACL)
        {
            // allocate new DACL.
            if (!(m_pDACL = (PACL) new BYTE[pDACL->AclSize]))
                goto failed;

            // initialize the DACL
            if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
                goto failed;

            // copy the ACES
            for (int i = 0; i < pDACL->AceCount; i++)
            {
                if (!GetAce(pDACL, i, (void **)&pACE))
                    goto failed;

                if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
                    goto failed;
            }

            if (!IsValidAcl(m_pDACL))
                goto failed;
        }

        // set the DACL
        if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
            goto failed;
    }

    // get the existing SACL.
    if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
        goto failed;

    if (bSACLPresent)
    {
        if (pSACL)
        {
            // allocate new SACL.
            if (!(m_pSACL = (PACL) new BYTE[pSACL->AclSize]))
                goto failed;

            // initialize the SACL
            if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
                goto failed;

            // copy the ACES
            for (int i = 0; i < pSACL->AceCount; i++)
            {
                if (!GetAce(pSACL, i, (void **)&pACE))
                    goto failed;

                if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
                    goto failed;
            }

            if (!IsValidAcl(m_pSACL))
                goto failed;
        }

        // set the SACL
        if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
            goto failed;
    }

    if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
        goto failed;

    if (FAILED(SetOwner(pUserSid, bDefaulted)))
        goto failed;

    if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
        goto failed;

    if (FAILED(SetGroup(pGroupSid, bDefaulted)))
        goto failed;

    if (!IsValidSecurityDescriptor(m_pSD))
        goto failed;

    return hr;

failed:
    if (m_pDACL)
        delete[] (LPBYTE)(m_pDACL);
    if (m_pSD)
        delete[] (LPBYTE)(m_pSD);
    return E_UNEXPECTED;
}

HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
    HRESULT hr;
    DWORD dwSize = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;

    GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

    hr = GetLastError();
    if (hr != ERROR_INSUFFICIENT_BUFFER)
        return HRESULT_FROM_WIN32(hr);

    pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwSize];
    if (NULL==pSD)
        return E_OUTOFMEMORY;

    if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        delete[] (LPBYTE)(pSD);
        return hr;
    }

    hr = Attach(pSD);
    delete[] (LPBYTE)(pSD);
    return hr;
}


HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    LPVOID pAce;
    ACE_HEADER *aceHeader;

    if (pSrc == NULL)
        return S_OK;

    if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        return HRESULT_FROM_WIN32(GetLastError());

    // Copy all of the ACEs to the new ACL
    for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce(pSrc, i, &pAce))
            return HRESULT_FROM_WIN32(GetLastError());

        aceHeader = (ACE_HEADER *) pAce;

        if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
            return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID;
    PACL oldACL, newACL;

    oldACL = *ppAcl;

    returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
    if (FAILED(returnValue))
        return returnValue;

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];
    if (NULL==newACL)
    {
        delete[] (LPBYTE)principalSID;
        return E_OUTOFMEMORY;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return returnValue;
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID;
    PACL oldACL, newACL;
    DWORD dwLen, dwIx;

    oldACL = *ppAcl;

    ASSERT(255 >= psidPrincipal->dwRidCount);
    dwLen = GetSidLengthRequired((UCHAR)psidPrincipal->dwRidCount);
    principalSID = (PSID)(new BYTE[dwLen]);
    if (NULL==principalSID)
        return E_OUTOFMEMORY;
    if (!InitializeSid(
                principalSID,
                (PSID_IDENTIFIER_AUTHORITY)&psidPrincipal->sid,
                (UCHAR)psidPrincipal->dwRidCount))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }
    for (dwIx = 0; dwIx < psidPrincipal->dwRidCount; dwIx += 1)
        *GetSidSubAuthority(principalSID, dwIx) = psidPrincipal->rgRids[dwIx];
    if (!IsValidSid(principalSID))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];
    if (NULL==newACL)
    {
        delete[] (LPBYTE)principalSID;
        return E_OUTOFMEMORY;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)(principalSID);
        return returnValue;
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID = NULL;
    PACL oldACL, newACL;
    DWORD dwLen, dwIx;

    oldACL = *ppAcl;

    ASSERT(255 >= psidPrincipal->dwRidCount);
    dwLen = GetSidLengthRequired((UCHAR)psidPrincipal->dwRidCount);
    principalSID = (PSID)(new BYTE[dwLen]);
    if (NULL==principalSID)
        return E_OUTOFMEMORY;
    if (!InitializeSid(
                principalSID,
                (PSID_IDENTIFIER_AUTHORITY)&psidPrincipal->sid,
                (UCHAR)psidPrincipal->dwRidCount))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }
    for (dwIx = 0; dwIx < psidPrincipal->dwRidCount; dwIx += 1)
        *GetSidSubAuthority(principalSID, dwIx) = psidPrincipal->rgRids[dwIx];
    if (!IsValidSid(principalSID))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];
    if (NULL==newACL) {
        delete[] (LPBYTE)principalSID;
        return E_OUTOFMEMORY;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)principalSID;
        return returnValue;
    }

    if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)principalSID;
    return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID;
    PACL oldACL, newACL;

    oldACL = *ppAcl;

    returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
    if (FAILED(returnValue))
        return returnValue;

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];
    if (NULL==newACL)
    {
        delete[] (LPBYTE)principalSID;
        return E_OUTOFMEMORY;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return returnValue;
    }

    if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PACL oldACL, newACL;

    oldACL = *ppAcl;

    if (!IsValidSid(m_pOwner))
    {
        _ASSERTE(FALSE);
        return E_INVALIDARG;
    }

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(m_pOwner) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];
    if (NULL==newACL)
    {
        return E_OUTOFMEMORY;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)(newACL);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)(newACL);
        return returnValue;
    }

    if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, m_pOwner))
    {
        delete[] (LPBYTE)(newACL);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    return S_OK;
}

HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    ULONG i;
    LPVOID ace;
    ACCESS_ALLOWED_ACE *accessAllowedAce;
    ACCESS_DENIED_ACE *accessDeniedAce;
    SYSTEM_AUDIT_ACE *systemAuditAce;
    PSID principalSID;
    DWORD returnValue;
    ACE_HEADER *aceHeader;

    returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
    if (FAILED(returnValue))
        return returnValue;

    GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce(pAcl, i, &ace))
        {
            delete[] (LPBYTE)(principalSID);
            return HRESULT_FROM_WIN32(GetLastError());
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce(pAcl, i);
                delete[] (LPBYTE)(principalSID);
                return S_OK;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce(pAcl, i);
                delete[] (LPBYTE)(principalSID);
                return S_OK;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce(pAcl, i);
                delete[] (LPBYTE)(principalSID);
                return S_OK;
            }
        }
    }
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}


HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
    HRESULT hr;
    TOKEN_PRIVILEGES tpPrevious;
    TOKEN_PRIVILEGES tp;
    DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LUID luid;
    HANDLE hMyToken = NULL;

    // if no token specified open process token
    if (hToken == 0)
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hMyToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            return hr;
        }
        hToken = hMyToken;
    }

    if (!LookupPrivilegeValue(NULL, privilege, &luid ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        if (NULL != hMyToken)
            CloseHandle(hMyToken);
        return hr;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = 0;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        if (NULL != hMyToken)
            CloseHandle(hMyToken);
        return hr;
    }

    tpPrevious.PrivilegeCount = 1;
    tpPrevious.Privileges[0].Luid = luid;

    if (bEnable)
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    else
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

    if (!AdjustTokenPrivileges(hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        if (NULL != hMyToken)
            CloseHandle(hMyToken);
        return hr;
    }
    if (NULL != hMyToken)
        CloseHandle(hMyToken);
    return S_OK;
}

CSecurityDescriptor::operator LPSECURITY_ATTRIBUTES()
{
    m_saAttrs.nLength = sizeof (m_saAttrs);
    m_saAttrs.lpSecurityDescriptor = m_pSD;
    m_saAttrs.bInheritHandle = m_fInheritance;
    return (&m_saAttrs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\common\changedb.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    changedb

Abstract:

    This file provides the implementation of the Calais Database management
    utilities which modify the Calais database.

Author:

    Doug Barlow (dbarlow) 1/29/1997

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <winscard.h>
#include <CalaisLb.h>

// Keep this in sync with QueryDB.cpp
typedef struct {
    DWORD dwScope;
    HKEY hKey;
} RegMap;

#if SCARD_SCOPE_SYSTEM < SCARD_SCOPE_USER
#error Invalid ordering to SCARD_SCOPE definitions
#endif

static TCHAR l_szInvalidChars[] = TEXT("\\?");
static const RegMap l_rgRegMap[]
    = {
        { SCARD_SCOPE_USER,     HKEY_CURRENT_USER },
     // { SCARD_SCOPE_TERMINAL, Not implemented yet },  // ?Hydra?
        { SCARD_SCOPE_SYSTEM,   HKEY_LOCAL_MACHINE }
      };
static const DWORD l_dwRegMapMax = sizeof(l_rgRegMap) / sizeof(RegMap);

static const LPCTSTR l_szrgProvMap[]
    = {
        NULL,   // Zero value
        SCARD_REG_PPV,
        SCARD_REG_CSP
      };
static const DWORD l_dwProvMapMax = sizeof(l_szrgProvMap) / sizeof(LPCTSTR);

static void
GuidFromString(
    IN LPCTSTR szGuid,
    OUT LPGUID pguidResult);


//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Management Services
//
//      The following services provide for managing the Calais Database.  These
//      services actually update the database, and require a smartcard context.
//

/*++

IntroduceReaderGroup:

    This service provides means for introducing a new smartcard reader group to
    Calais.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported..

    szGroupName supplies the friendly name to be assigned to the new reader
        group.

Return Value:

    None

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
IntroduceReaderGroup(
    IN DWORD dwScope,
    IN LPCTSTR szGroupName)
{

    //
    //  In this implementation, groups need not be pre-declared.
    //

    if (0 == *szGroupName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    if (NULL != _tcspbrk(szGroupName, l_szInvalidChars))
        throw (DWORD)SCARD_E_INVALID_VALUE;
    return;
}


/*++

ForgetReaderGroup:

    This service provides means for removing a previously defined smartcard
    reader group from the Calais Subsystem.  This service automatically clears
    all readers from the group before forgetting it.  It does not affect the
    existence of the readers in the database.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szGroupName supplies the friendly name of the reader group to be
        forgotten.  The Calais-defined default reader groups may not be
        forgotten.

Return Value:

    None

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
ForgetReaderGroup(
    IN DWORD dwScope,
    IN LPCTSTR szGroupName)
{
    DWORD dwCount, dwLen;
    LPCTSTR mszGroups;
    CBuffer bfTmp;
    CBuffer bfGroup;
    DWORD dwIndex;
    CRegistry regReaders;
    LPCTSTR szReader;

    if (0 == *szGroupName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)SCARD_E_INVALID_VALUE;

    regReaders.Open(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_READERS,
            KEY_ALL_ACCESS);
    regReaders.Status();
    MStrAdd(bfGroup, szGroupName);
    for (dwIndex = 0;; dwIndex += 1)
    {
        try
        {
            try
            {
                szReader = regReaders.Subkey(dwIndex);
            }
            catch (...)
            {
                szReader = NULL;
            }
            if (NULL == szReader)
                break;
            CRegistry regReader(regReaders, szReader, KEY_ALL_ACCESS);
            mszGroups = regReader.GetMultiStringValue(SCARD_REG_GROUPS);
            dwCount = MStringCount(mszGroups);
            dwLen = MStringRemove(mszGroups, bfGroup, bfTmp);
            if (dwCount != dwLen)
                regReader.SetMultiStringValue(SCARD_REG_GROUPS, bfTmp);
        }
        catch (...) {}
    }
}


/*++

IntroduceReader:

    This service provides means for introducing an existing smartcard reader
    device to Calais.  Once introduced, Calais will assume responsibility for
    managing access to that reader.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szReaderName supplies the friendly name to be assigned to the reader.

    SzDeviceName supplies the system name of the smartcard reader device.
        (Example: "Smartcard0".)

Return Value:

    None

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
IntroduceReader(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szDeviceName)
{
    CRegistry regReaders;
    DWORD dwIndex;


    //
    // Verify the reader name, so that it doesn't include any
    // disallowed characters.
    //

    if (0 == *szReaderName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    if (NULL != _tcspbrk(szReaderName, l_szInvalidChars))
        throw (DWORD)SCARD_E_INVALID_VALUE;


    //
    // Translate the caller's scope.
    //

    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)SCARD_E_INVALID_VALUE;


    regReaders.Open(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_READERS,
            KEY_CREATE_SUB_KEY,
            REG_OPTION_NON_VOLATILE,
            NULL);  // Inherit
    CRegistry regReader(
            regReaders,
            szReaderName,
            KEY_SET_VALUE,
            REG_OPTION_NON_VOLATILE,
            NULL);   // Create it & inherit

    if (REG_OPENED_EXISTING_KEY == regReader.GetDisposition())
        throw (DWORD)SCARD_E_DUPLICATE_READER;
    regReader.SetValue(SCARD_REG_DEVICE, szDeviceName);
    // regReader.SetValue(SCARD_REG_OEMCFG, ?what?);
    regReader.SetMultiStringValue(SCARD_REG_GROUPS, SCARD_DEFAULT_READERS);
}


/*++

ForgetReader:

    This service provides means for removing previously defined smartcard
    readers from control by the Calais Subsystem.  It is automatically removed
    from any groups it may have been added to.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szReaderName supplies the friendly name of the reader to be forgotten.

Return Value:

    None

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
ForgetReader(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName)
{
    CRegistry regReaders;
    DWORD dwIndex;

    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)SCARD_E_INVALID_VALUE;

    // Need to prevent passing a NULL string to DeleteKey, since
    // that will cause the whole reader DB to be deleted.
    if (NULL == szReaderName || _T('\0') == szReaderName[0])
        throw (DWORD)SCARD_E_INVALID_VALUE;

    regReaders.Open(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_READERS,
            KEY_ALL_ACCESS);
    regReaders.DeleteKey(szReaderName);
}


/*++

AddReaderToGroup:

    This service provides means for adding existing an reader into an existing
    reader group.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szReaderName supplies the friendly name of the reader to be added.

    szGroupName supplies the friendly name of the group to which the reader
        should be added.

Return Value:

    None

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
AddReaderToGroup(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szGroupName)
{
    DWORD dwCount, dwLen;
    LPCTSTR mszGroups;
    CBuffer bfTmp;
    CBuffer bfGroup;
    CRegistry regReaders;
    DWORD dwIndex;

    if (0 == *szGroupName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)SCARD_E_INVALID_VALUE;

    regReaders.Open(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_READERS,
            KEY_ALL_ACCESS);
    CRegistry regReader(
            regReaders,
            szReaderName,
            KEY_ALL_ACCESS);

    MStrAdd(bfGroup, szGroupName);
    mszGroups = regReader.GetMultiStringValue(SCARD_REG_GROUPS);
    dwCount = MStringCount(mszGroups);
    dwLen = MStringMerge(mszGroups, bfGroup, bfTmp);
    if (dwCount != dwLen)
        regReader.SetMultiStringValue(SCARD_REG_GROUPS, bfTmp);
}


/*++

RemoveReaderFromGroup:

    This service provides means for removing an existing reader from an existing
    reader group.  It does not affect the existence of either the reader or the
    group in the Calais database.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szReaderName supplies the friendly name of the reader to be removed.

    szGroupName supplies the friendly name of the group to which the reader
        should be removed.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
RemoveReaderFromGroup(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szGroupName)
{
    DWORD dwCount, dwLen;
    LPCTSTR mszGroups;
    CBuffer bfTmp;
    CBuffer bfGroup;
    CRegistry regReaders;
    DWORD dwIndex;

    if (0 == *szGroupName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)SCARD_E_INVALID_VALUE;

    regReaders.Open(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_READERS,
            KEY_ALL_ACCESS);
    CRegistry regReader(
            regReaders,
            szReaderName,
            KEY_ALL_ACCESS);

    MStrAdd(bfGroup, szGroupName);
    mszGroups = regReader.GetMultiStringValue(SCARD_REG_GROUPS);
    dwCount = MStringCount(mszGroups);
    dwLen = MStringRemove(mszGroups, bfGroup, bfTmp);
    if (dwCount != dwLen)
        regReader.SetMultiStringValue(SCARD_REG_GROUPS, bfTmp);
}


/*++

IntroduceCard:

    This service provides means for introducing new smartcards to the Calais
    Subsystem for the active user.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szCardName supplies the friendly name by which this card should be known.

    PguidPrimaryProvider supplies a pointer to a GUID used to identify the
        Primary Service Provider for the card.

    rgguidInterfaces supplies an array of GUIDs identifying the smartcard
        interfaces supported by this card.

    dwInterfaceCount supplies the number of GUIDs in the pguidInterfaces array.

    pbAtr supplies a string against which card ATRs will be compared to
        determine a possible match for this card.  The length of this string is
        determined by normal ATR parsing.

    pbAtrMask supplies an optional bitmask to use when comparing the ATRs of
        smartcards to the ATR supplied in pbAtr.  If this value is non-NULL, it
        must point to a string of bytes the same length as the ATR string
        supplied in pbAtr.  Then when a given ATR A is compared to the ATR
        supplied in pbAtr B, it matches if and only if A & M = B, where M is the
        supplied mask, and & represents bitwise logical AND.

    cbAtrLen supplies the length of the ATR and Mask.  This value may be zero
        if the lentgh is obvious from the ATR.  However, it may be required if
        there is a Mask value that obscures the actual ATR.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/

void
IntroduceCard(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen)
{
    DWORD dwIndex, dwReg, dwAtrLen;



    //
    // Verify the card name, so that it doesn't include any
    // disallowed characters.
    //

    if (0 == *szCardName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    if (NULL != _tcspbrk(szCardName, l_szInvalidChars))
        throw (DWORD)SCARD_E_INVALID_VALUE;


    //
    // Translate the caller's scope.
    //

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;
    dwReg = dwIndex;
    if (NULL == pbAtrMask)
    {
        if (!ParseAtr(pbAtr, &dwAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
        if ((0 != cbAtrLen) && (dwAtrLen != cbAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
    }
    else
    {
        if ((2 > cbAtrLen) || (33 < cbAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
        for (dwIndex = 0; dwIndex < cbAtrLen; dwIndex += 1)
        {
            if (pbAtr[dwIndex] != (pbAtr[dwIndex] & pbAtrMask[dwIndex]))
                throw (DWORD)SCARD_E_INVALID_PARAMETER;
        }
        dwAtrLen = cbAtrLen;
    }

    CRegistry regCards(
            l_rgRegMap[dwReg].hKey,
            SCARD_REG_CARDS,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);      // Inherit
    CRegistry regCard(
            regCards,
            szCardName,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);   // Create it & inherit

    if (REG_OPENED_EXISTING_KEY == regCard.GetDisposition())
        throw (DWORD)ERROR_ALREADY_EXISTS;
    regCard.SetValue(
            SCARD_REG_ATR,
            pbAtr,
            dwAtrLen);
    if (NULL != pbAtrMask)
        regCard.SetValue(
            SCARD_REG_ATRMASK,
            pbAtrMask,
            dwAtrLen);
    if (NULL != pguidPrimaryProvider)
        regCard.SetValue(
            SCARD_REG_PPV,
            (LPBYTE)pguidPrimaryProvider,
            sizeof(GUID));
    if ((NULL != rgguidInterfaces) && (0 < dwInterfaceCount))
        regCard.SetValue(
            SCARD_REG_GUIDS,
            (LPBYTE)rgguidInterfaces,
            sizeof(GUID) * dwInterfaceCount);
}


/*++

SetCardTypeProviderName:

    This routine sets the value of a given Provider Name, by Id number, for the
    identified card type.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL and SCARD_SCOPE_USER are not supported.

    szCardName supplies the name of the card type with which this provider
        name is to be associated.

    dwProviderId supplies the identifier for the provider to be associated with
        this card type.  Possible values are:

        SCARD_PROVIDER_SSP - The SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
            over 0x80000000 are available for use by the smart card vendors, and
            are card-specific.

    szProvider supplies the string identifying the provider.

Return Value:

    None.

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/

void
SetCardTypeProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN DWORD dwProviderId,
    IN LPCTSTR szProvider)
{
    DWORD dwIndex;
    LPCTSTR szProvValue;
    TCHAR szNumeric[36];


    //
    // Validate the request.
    //

    if (0 == *szCardName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    if (0 == *szProvider)
        throw (DWORD)SCARD_E_INVALID_VALUE;


    //
    // Find the Card definition.
    //

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;

    CRegistry regCardTypes(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_CARDS,
            KEY_ALL_ACCESS);
    CRegistry regCard(
            regCardTypes,
            szCardName,
            KEY_ALL_ACCESS);
    regCard.Status();


    //
    // Derive the Provider Value Name.
    //

    if (dwProviderId < l_dwProvMapMax)
    {
        szProvValue = l_szrgProvMap[dwProviderId];
        if (NULL == szProvValue)
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
    }
    else if (0x80000000 <= dwProviderId)
    {
        _ultot(dwProviderId, szNumeric, 16);
        szProvValue = szNumeric;
    }
    else
        throw (DWORD)SCARD_E_INVALID_PARAMETER;


    //
    // Write the provider value.
    //

    switch (dwProviderId)
    {
    case 1: // SCARD_PROVIDER_SSP
    {
        GUID guidProvider;

        GuidFromString(szProvider, &guidProvider);
        regCard.SetValue(szProvValue, (LPCBYTE)&guidProvider, sizeof(GUID));
        break;
    }
    default:
        regCard.SetValue(szProvValue, szProvider);
    }
}


/*++

ForgetCard:

    This service provides means for removing previously defined smartcards from
    the Calais Subsystem.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szCardName supplies the friendly name of the card to be forgotten.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/

void
ForgetCard(
    IN DWORD dwScope,
    IN LPCTSTR szCardName)
{
    DWORD dwIndex;

    if (0 == *szCardName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;

    CRegistry regCards(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_CARDS,
            KEY_ALL_ACCESS);

    regCards.DeleteKey(szCardName);
}


#ifdef ENABLE_SCARD_TEMPLATES
/*++

IntroduceCardTypeTemplate:

    This service provides means for introducing a new smartcard template to the
    Calais Subsystem.  A card tye template is a known card type that hasn't
    been formally introduced.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_USER and SCARD_SCOPE_TERMINAL is not supported.

    szVendorName supplies the manufacturer name by which this card should be
        recognized.

    PguidPrimaryProvider supplies a pointer to a GUID used to identify the
        Primary Service Provider for the card.

    rgguidInterfaces supplies an array of GUIDs identifying the smartcard
        interfaces supported by this card.

    dwInterfaceCount supplies the number of GUIDs in the pguidInterfaces array.

    pbAtr supplies a string against which card ATRs will be compared to
        determine a possible match for this card.  The length of this string is
        determined by normal ATR parsing.

    pbAtrMask supplies an optional bitmask to use when comparing the ATRs of
        smartcards to the ATR supplied in pbAtr.  If this value is non-NULL, it
        must point to a string of bytes the same length as the ATR string
        supplied in pbAtr.  Then when a given ATR A is compared to the ATR
        supplied in pbAtr B, it matches if and only if A & M = B, where M is the
        supplied mask, and & represents bitwise logical AND.

    cbAtrLen supplies the length of the ATR and Mask.  This value may be zero
        if the lentgh is obvious from the ATR.  However, it may be required if
        there is a Mask value that obscures the actual ATR.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
IntroduceCardTypeTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen)
{
    DWORD dwIndex, dwReg, dwAtrLen;



    //
    // Verify the template name, so that it doesn't include any
    // disallowed characters.
    //

    if (NULL != _tcspbrk(szVendorName, l_szInvalidChars))
        throw (DWORD)SCARD_E_INVALID_VALUE;


    //
    // Translate the caller's scope.
    //

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;
    dwReg = dwIndex;
    if (NULL == pbAtrMask)
    {
        if (!ParseAtr(pbAtr, &dwAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
        if ((0 != cbAtrLen) && (dwAtrLen != cbAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
    }
    else
    {
        if ((2 > cbAtrLen) || (33 < cbAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
        for (dwIndex = 0; dwIndex < cbAtrLen; dwIndex += 1)
        {
            if (pbAtr[dwIndex] != (pbAtr[dwIndex] & pbAtrMask[dwIndex]))
                throw (DWORD)SCARD_E_INVALID_PARAMETER;
        }
        dwAtrLen = cbAtrLen;
    }

    CRegistry regCards(
            l_rgRegMap[dwReg].hKey,
            SCARD_REG_TEMPLATES,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);
    CRegistry regCard(
            regCards,
            szVendorName,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);   // Create it.

    if (REG_OPENED_EXISTING_KEY == regCard.GetDisposition())
        throw (DWORD)ERROR_ALREADY_EXISTS;
    regCard.SetValue(
            SCARD_REG_ATR,
            pbAtr,
            dwAtrLen);
    if (NULL != pbAtrMask)
        regCard.SetValue(
            SCARD_REG_ATRMASK,
            pbAtrMask,
            dwAtrLen);
    if (NULL != pguidPrimaryProvider)
        regCard.SetValue(
            SCARD_REG_PPV,
            (LPBYTE)pguidPrimaryProvider,
            sizeof(GUID));
    if ((NULL != rgguidInterfaces) && (0 < dwInterfaceCount))
        regCard.SetValue(
            SCARD_REG_GUIDS,
            (LPBYTE)rgguidInterfaces,
            sizeof(GUID) * dwInterfaceCount);
}


/*++

SetCardTypeTemplateProviderName:

    This routine sets the value of a given Provider Name, by Id number, for the
    identified card type template.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL and SCARD_SCOPE_USER are not supported.

    szTemplateName supplies the name of the card type template with which this
        provider name is to be associated.

    dwProviderId supplies the identifier for the provider to be associated with
        this card type template.  Possible values are:

        SCARD_PROVIDER_SSP - The SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
            over 0x80000000 are available for use by the smart card vendors, and
            are card-specific.

    szProvider supplies the string identifying the provider.

Return Value:

    None.

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/

void
SetCardTypeTemplateProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szTemplateName,
    IN DWORD dwProviderId,
    IN LPCTSTR szProvider)
{
    DWORD dwIndex;
    LPCTSTR szProvValue;
    TCHAR szNumeric[36];

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;


    //
    // Make sure the template exists.
    //

    CRegistry regTemplates(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_TEMPLATES,
            KEY_ALL_ACCESS);
    CRegistry regTempl(
            regTemplates,
            szTemplateName,
            KEY_ALL_ACCESS);
    regTempl.Status();


    //
    // Derive the Provider Value Name.
    //

    if (dwProviderId < l_dwProvMapMax)
    {
        szProvValue = l_szrgProvMap[dwProviderId];
        if (NULL == szProvValue)
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
    }
    else if (0x80000000 <= dwProviderId)
    {
        _ultot(dwProviderId, szNumeric, 16);
        szProvValue = szNumeric;
    }
    else
        throw (DWORD)SCARD_E_INVALID_PARAMETER;


    //
    // Write the provider value.
    //

    switch (dwProviderId)
    {
    case 1: // SCARD_PROVIDER_SSP
    {
        GUID guidProvider;

        GuidFromString(szProvider, &guidProvider);
        regTempl.SetValue(szProvValue, (LPCBYTE)&guidProvider, sizeof(GUID));
        break;
    }
    default:
        regTempl.SetValue(szProvValue, szProvider);
    }
}


/*++

ForgetCardTypeTemplate:

    This service provides means for removing previously defined smart card type
    templates from the Calais Subsystem.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_USER and SCARD_SCOPE_TERMINAL are not supported.

    szVendorName supplies the manufacturer's name of the card to be forgotten.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
ForgetCardTypeTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName)
{
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;

    CRegistry regTemplates(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_TEMPLATES,
            KEY_ALL_ACCESS);

    regTemplates.DeleteKey(szVendorName);
}


/*++

IntroduceCardTypeFromTemplate:

    This service provides means for introducing new smartcards to the Calais
    Subsystem for the active user, based on a stored card template.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szVendorName supplies the vendor name by which this card type is known,
        identifying the template to use.

    szFriendlyName supplies the friendly name by which this card should be
        known.  If this value is NULL, the vendor name is used as the friendly
        name,

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
IntroduceCardTypeFromTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName,
    IN LPCTSTR szFriendlyName /* = NULL */ )
{
    DWORD dwIndex;
    HKEY hCardTypeKey;
    CRegistry regTemplates, regTmpl;


    //
    // Verify the reader name, so that it doesn't include any
    // disallowed characters.
    //

    if (NULL == szFriendlyName)
        szFriendlyName = szVendorName;
    else
    {
        if (NULL != _tcspbrk(szFriendlyName, l_szInvalidChars))
            throw (DWORD)SCARD_E_INVALID_VALUE;
    }


    //
    // Identify the card type scope.
    //

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;
    hCardTypeKey = l_rgRegMap[dwIndex].hKey;


    //
    // Find the Template definition closest to the caller.
    //

    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope >= dwScope)
        {
            regTemplates.Open(
                l_rgRegMap[dwIndex].hKey,
                SCARD_REG_TEMPLATES,
                KEY_READ);
            try
            {
                regTmpl.Open(regTemplates, szVendorName, KEY_READ);
                regTmpl.Status();
                break;
            }
            catch (...)
            {
                regTmpl.Close();
            }
            regTemplates.Close();
        }
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)ERROR_FILE_NOT_FOUND;


    //
    // Create the CardType Entry.
    //

    CRegistry regCards(
            hCardTypeKey,
            SCARD_REG_CARDS,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);
    CRegistry regCard(
            regCards,
            szFriendlyName,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);   // Create it.
    if (REG_OPENED_EXISTING_KEY == regCard.GetDisposition())
        throw (DWORD)ERROR_ALREADY_EXISTS;


    //
    // Copy the entries.
    //

    regCard.Copy(regTmpl);
}
#endif  // ENABLE_SCARD_TEMPLATES


//
////////////////////////////////////////////////////////////////////////////////
//
// Support Routines
//

/*++

GuidFromString:

    This routine converts a string representation of a GUID into an actual GUID.
    It tries not to be picky about the systax, as long as it can get a GUID out
    of the string.  It's here so that it's not necessary to link all of OleBase
    into WinSCard.  Otherwise, we'd just use CLSIDFromString.

Arguments:

    szGuid supplies the GUID as a string.  For this routine, a GUID consists of
        hex digits, and some collection of braces and dashes.

    pguidResult receives the converted GUID.  If an error occurs during
        conversion, the contents of this parameter are indeterminant.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/20/1998

--*/

static void
GuidFromString(
    IN LPCTSTR szGuid,
    OUT LPGUID pguidResult)
{
    // The following placement assumes Little Endianness.
    static const WORD wPlace[sizeof(GUID)]
        = { 3, 2, 1, 0, 5, 4, 7, 6, 8, 9, 10, 11, 12, 13, 14, 15 };
    DWORD dwI, dwJ;
    LPCTSTR pch = szGuid;
    LPBYTE pbGuid = (LPBYTE)pguidResult;
    BYTE bVal;

    for (dwI = 0; dwI < sizeof(GUID); dwI += 1)
    {
        bVal = 0;
        for (dwJ = 0; dwJ < 2;)
        {
            switch (*pch)
            {
            case TEXT('0'):
            case TEXT('1'):
            case TEXT('2'):
            case TEXT('3'):
            case TEXT('4'):
            case TEXT('5'):
            case TEXT('6'):
            case TEXT('7'):
            case TEXT('8'):
            case TEXT('9'):
                bVal = (bVal << 4) + (*pch - TEXT('0'));
                dwJ += 1;
                break;
            case TEXT('A'):
            case TEXT('B'):
            case TEXT('C'):
            case TEXT('D'):
            case TEXT('E'):
            case TEXT('F'):
                bVal = (bVal << 4) + (10 + *pch - TEXT('A'));
                dwJ += 1;
                break;
            case TEXT('a'):
            case TEXT('b'):
            case TEXT('c'):
            case TEXT('d'):
            case TEXT('e'):
            case TEXT('f'):
                bVal = (bVal << 4) + (10 + *pch - TEXT('a'));
                dwJ += 1;
                break;
            case TEXT('['):
            case TEXT(']'):
            case TEXT('{'):
            case TEXT('}'):
            case TEXT('-'):
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            pch += 1;
        }
        pbGuid[wPlace[dwI]] = bVal;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\common\querydb.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    QueryDB

Abstract:

    This module provides simple access to the Calais Registry Database.

Author:

    Doug Barlow (dbarlow) 11/25/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <winscard.h>
#include <CalaisLb.h>

// Keep this in sync with ChangeDB.cpp
typedef struct {
    DWORD dwScope;
    HKEY hKey;
} RegMap;

#if SCARD_SCOPE_SYSTEM < SCARD_SCOPE_USER
#error Invalid ordering to SCARD_SCOPE definitions
#endif

static const RegMap l_rgRegMap[]
    = {
        { SCARD_SCOPE_USER,     HKEY_CURRENT_USER },
     // { SCARD_SCOPE_TERMINAL, Not implemented yet },  // ?Hydra?
        { SCARD_SCOPE_SYSTEM,   HKEY_LOCAL_MACHINE }
      };
static const DWORD l_dwRegMapMax = sizeof(l_rgRegMap) / sizeof(RegMap);

static const LPCTSTR l_szrgProvMap[]
    = {
        NULL,   // Zero value
        SCARD_REG_PPV,
        SCARD_REG_CSP
      };
static const DWORD l_dwProvMapMax = sizeof(l_szrgProvMap) / sizeof(LPCTSTR);

static BOOL
ListKnownKeys(
    IN  DWORD dwScope,
    OUT CBuffer &bfKeys,
    IN  LPCTSTR szUserList,
    IN  LPCTSTR szSystemList = NULL);
static void
FindKey(
    IN  DWORD dwScope,
    IN LPCTSTR szKey,
    OUT CRegistry &regKey,
    IN  LPCTSTR szUserList,
    IN  LPCTSTR szSystemList = NULL);


//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Query Services
//
//      These services all are oriented towards reading the Calais database.
//

/*++

ListReaderGroups:

    This service provides the list of named card reader groups that have
    previously been defined to the system.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, this value is ignored, and assumed to be SCARD_SCOPE_SYSTEM.

    bfGroups receives a multi-string listing the reader groups defined within
        the supplied scope.

Return Value:

    None.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/

void
ListReaderGroups(
    IN DWORD dwScope,
    OUT CBuffer &bfGroups)
{
    CBuffer bfReaders;
    CRegistry regReader;
    LPCTSTR szReader, mszGroups;
    CBuffer bfTmp;
    DWORD cchGroups;

    ListKnownKeys(dwScope, bfReaders, SCARD_REG_READERS);
    for (szReader = FirstString(bfReaders);
         NULL != szReader;
         szReader = NextString(szReader))
    {
        try
        {
            FindKey(dwScope, szReader, regReader, SCARD_REG_READERS);
            mszGroups = regReader.GetMultiStringValue(SCARD_REG_GROUPS);
            cchGroups = regReader.GetValueLength() / sizeof(TCHAR);
            while (0 == mszGroups[cchGroups - 1])
                cchGroups -= 1;
            bfTmp.Append(
                (LPBYTE)mszGroups,
                cchGroups * sizeof(TCHAR));
            bfTmp.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR));
        }
        catch (...) {}
    }


    //
    // Sort the list, and remove duplicates.
    //

    bfTmp.Append((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
    MStringSort(bfTmp, bfGroups);
}


/*++

ListReaders:

    This service provides the list of readers within a set of named reader
    groups, eliminating duplicates.  The caller supplies a multistring listing
    the name of a set of pre-defined group of readers, and receives the list of
    smartcard readers within the named groups.  Unrecognized group names are
    ignored.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    mszGroups supplies the names of the reader groups defined to the system, as
        a multi-string.  If this parameter is null, all readers are returned.

    bfReaders receives a multi-string listing the card readers within the
        supplied reader groups.

Return Value:

    None.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/

void
ListReaders(
    IN DWORD dwScope,
    IN LPCTSTR mszGroups,
    OUT CBuffer &bfReaders)
{
    CRegistry regReader;
    LPCTSTR szReader, mszRdrGroups;
    CBuffer bfRdrs, bfCmn;
    DWORD dwCmnCount;

    dwCmnCount = MStringCommon(mszGroups, SCARD_ALL_READERS, bfCmn);
    if (0 == dwCmnCount)
    {
        if ((NULL == mszGroups) || (0 == *mszGroups))
            mszGroups = SCARD_DEFAULT_READERS;
        bfReaders.Reset();
        ListKnownKeys(dwScope, bfRdrs, SCARD_REG_READERS);
        for (szReader = FirstString(bfRdrs);
        NULL != szReader;
        szReader = NextString(szReader))
        {
            try
            {
                FindKey(dwScope, szReader, regReader, SCARD_REG_READERS);
                mszRdrGroups = regReader.GetMultiStringValue(SCARD_REG_GROUPS);
                dwCmnCount = MStringCommon(mszGroups, mszRdrGroups, bfCmn);
                if (0 < dwCmnCount)
                    bfReaders.Append(
                    (LPCBYTE)szReader,
                    (lstrlen(szReader) + 1) * sizeof(TCHAR));
            }
            catch (...) {}
        }
        bfReaders.Append((LPBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
        bfReaders.Resize(MStrLen((LPCTSTR)bfReaders.Access()), TRUE);
    }
    else
        ListKnownKeys(dwScope, bfReaders, SCARD_REG_READERS);
}


/*++

ListReaderNames:

    This routine returns the list of names corresponding to a given reader
    device.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, this value is ignored, and assumed to be SCARD_SCOPE_SYSTEM.

    szDevice supplies the reader device name.

    bfNames receives a multistring of the names given to that device, if any.

Return Value:

    None

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 2/13/1997

--*/

void
ListReaderNames(
    IN DWORD dwScope,
    IN LPCTSTR szDevice,
    OUT CBuffer &bfNames)
{
    CRegistry regReader;
    LPCTSTR szReader, szDev;
    CBuffer bfRdrs;

    bfNames.Reset();
    ListKnownKeys(dwScope, bfRdrs, SCARD_REG_READERS);
    for (szReader = FirstString(bfRdrs);
    NULL != szReader;
    szReader = NextString(szReader))
    {
        try
        {
            FindKey(dwScope, szReader, regReader, SCARD_REG_READERS);
            szDev = regReader.GetStringValue(SCARD_REG_DEVICE);
            if (0 == lstrcmpi(szDev, szDevice))
                MStrAdd(bfNames, szReader);
        }
        catch (...) {}
    }
}



/*++

ListCards:

    This service provides a list of named cards previously introduced to the
    system by this user which match an optionally supplied ATR string and/or
    supply a set of given interfaces.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    pbAtr supplies the address of an ATR string to compare to known cards, or
        NULL if all card names are to be returned.

    rgguidInterfaces supplies an array of GUIDs, or the value NULL.  When an
        array is supplied, a card name will be returned only if this set of
        GUIDs is a (possibly improper) subset of the set of GUIDs supported by
        the card.

    cguidInterfaceCount supplies the number of entries in the rgguidInterfaces
        array.  If rgguidInterfaces is NULL, then this value is ignored.

  bfCards receives a multi-string listing the smartcards introduced to the
        system by this user which match the supplied ATR string.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/

void
ListCards(
    DWORD dwScope,
    IN LPCBYTE pbAtr,
    IN LPCGUID rgquidInterfaces,
    IN DWORD cguidInterfaceCount,
    OUT CBuffer &bfCards)
{
    CRegistry regCard;
    LPCTSTR szCard;
    CBuffer bfCardAtr;
    CBuffer bfCardList;

    bfCards.Reset();
    ListKnownKeys(dwScope, bfCardList, SCARD_REG_CARDS, SCARD_REG_TEMPLATES);
    for (szCard = FirstString(bfCardList);
         NULL != szCard;
         szCard = NextString(szCard))
    {
        try
        {
            FindKey(
                dwScope,
                szCard,
                regCard,
                SCARD_REG_CARDS,
                SCARD_REG_TEMPLATES);


            //
            // Does this card match the supplied ATR?
            //

            if ((NULL != pbAtr) && (0 != *pbAtr))
            {
                LPCBYTE pbCardAtr, pbCardMask;
                DWORD cbCardAtr, cbCardMask;

                pbCardAtr = regCard.GetBinaryValue(
                                        SCARD_REG_ATR,
                                        &cbCardAtr);
                bfCardAtr.Set(pbCardAtr, cbCardAtr);
                try
                {
                    pbCardMask = regCard.GetBinaryValue(
                                            SCARD_REG_ATRMASK,
                                            &cbCardMask);
                    if (cbCardAtr != cbCardMask)
                        continue;       // Invalid ATR/Mask combination.
                }
                catch (...)
                {
                    pbCardMask = NULL;  // No mask.
                }

                if (!AtrCompare(pbAtr, bfCardAtr, pbCardMask, cbCardAtr))
                    continue;           // ATRs invalid or don't match.
            }


            //
            // Does this card support the given interfaces?
            //

            if ((NULL != rgquidInterfaces) && (0 < cguidInterfaceCount))
            {
                DWORD cguidCrd;
                DWORD ix, jx;
                BOOL fAllInterfacesFound = TRUE;
                LPCGUID rgCrdInfs = (LPCGUID)regCard.GetBinaryValue(
                                            SCARD_REG_GUIDS,
                                            &cguidCrd);
                if ((0 != (cguidCrd % sizeof(GUID)))
                    || (0 == cguidCrd))
                    continue;           // Invalid GUID list.
                cguidCrd /= sizeof(GUID);
                for (ix = 0; ix < cguidInterfaceCount; ix += 1)
                {
                    for (jx = 0; jx < cguidCrd; jx += 1)
                    {
                        if (0 == MemCompare(
                                    (LPCBYTE)&rgCrdInfs[jx],
                                    (LPCBYTE)&rgquidInterfaces[ix],
                                    sizeof(GUID)))
                            break;
                    }
                    if (jx == cguidCrd)
                    {
                        fAllInterfacesFound = FALSE; // Unsupported interface
                        break;
                    }
                }
                if (!fAllInterfacesFound)
                    continue;
            }


            //
            // This card passes all the tests -- Include it.
            //

            MStrAdd(bfCards, szCard);
        }
        catch (...) {}
    }
    if (0 == bfCards.Length())
        bfCards.Set((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
}


/*++

GetCardTypeProviderName:

    This routine returns the value of a given Provider Name, by Id number, for
    the identified card type.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    szCardName supplies the name of the card type with which this provider name
        is associated.

    dwProviderId supplies the identifier for the provider associated with this
        card type.  Possible values are:

        SCARD_PROVIDER_SSP - The SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
            over 0x80000000 are available for use by the smart card vendors, and
            are card-specific.

    bfProvider receives the string identifying the provider.

Return Value:

    None

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/

void
GetCardTypeProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN DWORD dwProviderId,
    OUT CBuffer &bfProvider)
{
    LPCTSTR szProvValue;
    TCHAR szNumeric[36];
    CRegistry regCard;


    //
    // Find the Card definition closest to the caller.
    //

    FindKey(
        dwScope,
        szCardName,
        regCard,
        SCARD_REG_CARDS,
        SCARD_REG_TEMPLATES);


    //
    // Derive the Provider Value Name.
    //

    if (dwProviderId < l_dwProvMapMax)
    {
        szProvValue = l_szrgProvMap[dwProviderId];
        if (NULL == szProvValue)
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
    }
    else if (0x80000000 <= dwProviderId)
    {
        _ultot(dwProviderId, szNumeric, 16);
        szProvValue = szNumeric;
    }
    else
        throw (DWORD)SCARD_E_INVALID_PARAMETER;


    //
    // Read the provider value.
    //

    switch (dwProviderId)
    {
    case 1: // SCARD_PROVIDER_SSP
    {
        CBuffer bfGuid(sizeof(GUID));

        bfProvider.Presize(40 * sizeof(TCHAR));
        regCard.GetValue(szProvValue, bfGuid);
        StringFromGuid(
            (LPCGUID)bfGuid.Access(),
            (LPTSTR)bfProvider.Access());
        bfProvider.Resize(
            (lstrlen((LPCTSTR)bfProvider.Access()) + 1) * sizeof(TCHAR),
            TRUE);
        break;
    }
    default:
        regCard.GetValue(szProvValue, bfProvider);
    }
}


/*++

GetReaderInfo:

    This routine returns all stored information regarding a given reader.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    szReader supplies the name of the reader of which info is to be extracted.

    pbfGroups receives the list of groups as a multistring.

    pbfDevice receives the device name.

Return Value:

    TRUE - Reader found
    FALSE - Reader not found

Author:

    Doug Barlow (dbarlow) 12/2/1996

--*/

BOOL
GetReaderInfo(
    IN DWORD dwScope,
    IN LPCTSTR szReader,
    OUT CBuffer *pbfGroups,
    OUT CBuffer *pbfDevice)
{
    CRegistry regReader;


    //
    // Find the reader definition closest to the caller.
    //

    try
    {
        FindKey(dwScope, szReader, regReader, SCARD_REG_READERS);
    }
    catch (...)
    {
        return FALSE;
    }


    //
    // Look up all it's values.
    //

    if (NULL != pbfDevice)
    {
        // Device name
        try
        {
            regReader.GetValue(SCARD_REG_DEVICE, *pbfDevice);
        }
        catch (...)
        {
            pbfDevice->Reset();
        }
    }

    if (NULL != pbfGroups)
    {
        // Group list
        try
        {
            regReader.GetValue(SCARD_REG_GROUPS, *pbfGroups);
        }
        catch (...)
        {
            pbfGroups->Reset();
        }
    }

    return TRU