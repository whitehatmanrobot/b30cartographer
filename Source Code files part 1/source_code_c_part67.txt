   SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::~SnmpTrapManager: Kill the thread\n" 

    ) ;
)
        m_trapThread->SignalThreadShutdown();
    }

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::~SnmpTrapManager: Exiting\n" 

    ) ;
)
}


BOOL SnmpTrapManager::RegisterReceiver(SnmpTrapReceiver *trapRx)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::RegisterReceiver: Entering...\n" 

    ) ;
)

    if (NULL == trapRx)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::RegisterReceiver: Exiting with FALSE, invalid argument\n" 

    ) ;
)
        return FALSE;
    }

    if (!m_bListening)
    {
        SnmpTrapTaskObject trap_task = SnmpTrapTaskObject(this, &m_trapSession);
        m_trapThread->ScheduleTask(trap_task);
        trap_task.Exec();
        trap_task.Wait();
        m_trapThread->ReapTask(trap_task);

        if (NULL == m_trapSession)
        {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::RegisterReceiver: Exiting with FALSE, invalid trap session\n" 

    ) ;
)
            return FALSE;
        }

        m_bListening = TRUE;
    }

    BOOL bRet =  m_receivers.Add(trapRx);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::RegisterReceiver: Exiting with %s\n" ,
        bRet ? L"TRUE" : L"FALSE, failed to add to store of receivers"

    ) ;
)

    return bRet;
}


BOOL SnmpTrapManager::UnRegisterReceiver (SnmpTrapReceiver *trapRx)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::UnRegisterReceiver: Entering...\n" 

    ) ;
)
    if (!m_bListening || (NULL == trapRx))
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::UnRegisterReceiver: Exiting with FALSE, invalid trap session\n" 

    ) ;
)
        return FALSE;
    }


    BOOL bRet = m_receivers.Delete(trapRx);

    if (bRet && m_receivers.IsEmpty())
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::UnRegisterReceiver: Destroy trap session, no more receivers\n"

    ) ;
)
        m_trapSession->DestroySession();
        m_trapSession = NULL;
        m_bListening = FALSE;
    }

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::UnRegisterReceiver: Exiting with %s\n" ,
        bRet ? L"TRUE" : L"FALSE, failed to remove from store of receivers"

    ) ;
)

    return bRet;
}

SnmpTrapReceiver::SnmpTrapReceiver() : m_cRef ( 1 ) , m_bregistered ( false ) 
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiver::SnmpTrapReceiver: Creating a new SnmpTrapReceiver\n"

    ) ;
)

    m_bregistered = SnmpTrapManager ::s_TrapMngrPtr->RegisterReceiver(this);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiver::SnmpTrapReceiver: %s this trap receiver\n" ,
        m_bregistered ? L"Succeessfully registered" : L"Failed to register"
    ) ;
)

}

SnmpTrapReceiver::~SnmpTrapReceiver()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiver::~SnmpTrapReceiver: deleted this trap receiver\n"
    ) ;
)
}

BOOL SnmpTrapReceiver::DestroyReceiver()
{
    if (0 != InterlockedDecrement(&m_cRef))
    {
        return FALSE;
    }

    if (m_bregistered)
    {
        SnmpTrapManager ::s_TrapMngrPtr->UnRegisterReceiver(this);
        m_bregistered = FALSE;
    }
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiver::DestroyReceiver: Destroyed and unregistered this trap receiver\n"
    ) ;
)

    delete this;
    return TRUE;
}



SnmpTrapReceiverStore::SnmpTrapReceiverStore() : m_HandledRxStack ( NULL ), m_UnHandledRxStack ( NULL )
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::SnmpTrapReceiverStore: Created store\n"
    ) ;
)

	try {

        m_HandledRxStack = (void *)(new CList<SnmpTrapReceiver*, SnmpTrapReceiver*>);
        m_UnHandledRxStack = (void *)(new CList<SnmpTrapReceiver*, SnmpTrapReceiver*>);
        InitializeCriticalSection(&m_Lock);

	} catch( ... ) { //if there is any exception, wind back and don't leak.

		if (m_HandledRxStack)
		{
			delete ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack);
			m_HandledRxStack = NULL;
		}

		if (m_UnHandledRxStack)
		{
			delete ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack);
			m_UnHandledRxStack = NULL;
		}

		throw ;
	}
}


BOOL SnmpTrapReceiverStore::Add(SnmpTrapReceiver* receiver)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Add: Entering...\n"
    ) ;
)
	Lock();

	ScopeGuard t_1 = MakeObjGuard ( *this , Unlock ) ;

    BOOL bRet = FALSE;

    if (((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->IsEmpty())
    {
        bRet =  (NULL != ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->AddTail(receiver));
    }
    else
    {
        bRet = (NULL != ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->AddTail(receiver));
    }

    DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Add: Exiting with %s...\n",
        bRet ? L"TRUE" : L"FALSE"
    ) ;
)

    return bRet;
}


BOOL SnmpTrapReceiverStore::Delete(SnmpTrapReceiver* receiver)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Delete: Entering...\n"
    ) ;
)

    Lock();

    //first check the m_HandledRxStack
    POSITION pos = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->GetHeadPosition();
    
    while(NULL != pos)
    {
        POSITION delpos = pos;
        SnmpTrapReceiver* rx = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->GetNext(pos);

        if (rx == receiver)
        {
            ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->RemoveAt(delpos);
            Unlock();
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Delete: Exiting with TRUE\n"
    ) ;
)

            return TRUE;
        }
    }

    //now check the m_UnHandledRxStack
    pos = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->GetHeadPosition();
    
    while(NULL != pos)
    {
        POSITION delpos = pos;
        SnmpTrapReceiver* rx = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->GetNext(pos);

        if (rx == receiver)
        {
            ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->RemoveAt(delpos);
            Unlock();
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Delete: Exiting with TRUE\n"
    ) ;
)
            return TRUE;
        }
    }

    Unlock();
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Delete: Exiting with FALSE\n"
    ) ;
)
    return FALSE;
}


void SnmpTrapReceiverStore::Lock()
{
    EnterCriticalSection(&m_Lock);
}


void SnmpTrapReceiverStore::Unlock()
{
    LeaveCriticalSection(&m_Lock);
}

BOOL SnmpTrapReceiverStore::IsEmpty()
{
    Lock();
    BOOL ret =  ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->IsEmpty() && ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->IsEmpty();
    Unlock();
    return ret;
}


SnmpTrapReceiver* SnmpTrapReceiverStore::GetNext()
{
    SnmpTrapReceiver* ret = NULL;   
    Lock();

    if (!((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->IsEmpty())
    {
        ret = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->RemoveHead();
        ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->AddTail(ret);
    }
    else
    {
        CList<SnmpTrapReceiver*, SnmpTrapReceiver*> *tmp = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack);
        m_UnHandledRxStack = m_HandledRxStack;
        m_HandledRxStack = (void*)tmp;
    }

    Unlock();
    return ret;
}


SnmpTrapReceiverStore::~SnmpTrapReceiverStore()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::~SnmpTrapReceiverStore: Deleting store\n"
    ) ;
)
    DeleteCriticalSection(&m_Lock);

    if (m_HandledRxStack)
    {
        ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->RemoveAll();
		delete ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack);
		m_HandledRxStack = NULL;
    }

    if (m_UnHandledRxStack)
    {
        ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->RemoveAll();
		delete ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack);
		m_UnHandledRxStack = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\trapsess.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "common.h"
#include "address.h"
#include "timer.h"
#include "sec.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "vblist.h"
#include "ophelp.h"
#include "window.h"
#include "trap.h"
#include "trapsess.h"

SnmpWinSnmpTrapSession::SnmpWinSnmpTrapSession(SnmpTrapManager* managerPtr)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::SnmpWinSnmpTrapSession: Creating a new trap session\n" 

    ) ;
)

    m_bValid = FALSE;
    m_bDestroy = FALSE;
    m_cRef = 1;

    if ( (NULL == Window::operator()()) || (NULL == managerPtr) ||  !RegisterForAllTraps())
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::SnmpWinSnmpTrapSession: Invalid trap session created\n" 

    ) ;
)
        return;
    }
    
    m_managerPtr = managerPtr;
    m_bValid = TRUE;
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::SnmpWinSnmpTrapSession: Valid trap session created\n" 

    ) ;
)
}


SnmpWinSnmpTrapSession::~SnmpWinSnmpTrapSession()
{
    //Deregister for all traps...
    if (m_bValid)
    {
        SnmpRegister(m_session_handle,
                    0, //manager
                    0, //agent
                    0, //context
                    0, //trap_oid
                    SNMPAPI_OFF);
        SnmpClose(m_session_handle);
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::~SnmpWinSnmpTrapSession: Unregistered for traps and closed winsnmp session\n" 

    ) ;
)
    }
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::~SnmpWinSnmpTrapSession: Trap session destroyed\n" 

    ) ;
)
}


BOOL SnmpWinSnmpTrapSession::RegisterForAllTraps()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::RegisterForAllTraps: Registering for all traps...\n" 

    ) ;
)

    smiUINT32 nMajorVersion = 1;
    smiUINT32 nMinorVersion = 1;
    smiUINT32 nLevel = 2;
    smiUINT32 nTranslateMode = SNMPAPI_UNTRANSLATED_V1;
    smiUINT32 nRetransmitMode = SNMPAPI_OFF;
    
    SNMPAPI_STATUS apiStatus = SnmpStartup(&nMajorVersion,
                                                &nMinorVersion,
                                                &nLevel,
                                                &nTranslateMode,
                                                &nRetransmitMode);
    if (SNMPAPI_FAILURE == apiStatus)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::RegisterForAllTraps: Failed to start up winsnmp\n" 

    ) ;
)
        return FALSE;
    }

    m_session_handle = SnmpOpen(GetWindowHandle(), TRAP_EVENT);

    if (SNMPAPI_FAILURE == m_session_handle)
    {
        DWORD t_LastError = SnmpGetLastError ( 0 ) ;
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::RegisterForAllTraps: Failed to open a winsnmp session, error code (%d)\n" ,
        t_LastError

    ) ;
)

        return FALSE;
    }
    
    apiStatus = SnmpRegister(m_session_handle,
                                0, //manager
                                0, //agent
                                0, //context
                                0, //trap_oid
                                SNMPAPI_ON);

    if (SNMPAPI_FAILURE == apiStatus)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::RegisterForAllTraps: Failed to register for all traps\n"

    ) ;
)
        SnmpClose(m_session_handle);
        return FALSE;
    }

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::RegisterForAllTraps: Registered for all traps!\n"

    ) ;
)

    return TRUE;
}

BOOL SnmpWinSnmpTrapSession::PostMessage(UINT user_msg_id, WPARAM wParam, LPARAM lParam)
{
    //call the global PostMessage...
    return ::WaitPostMessage(GetWindowHandle(), user_msg_id, wParam, lParam);
}

BOOL SnmpWinSnmpTrapSession::DestroySession()
{
    if (0 != InterlockedDecrement(&m_cRef))
    {
        return FALSE;
    }

    delete this;
    return TRUE;
}

LONG_PTR SnmpWinSnmpTrapSession::HandleEvent(HWND hWnd, UINT message,
                                     WPARAM wParam,LPARAM lParam)
{
    InterlockedIncrement(&m_cRef);
    LONG_PTR ret = 0;

	ScopeGuard t_1 = MakeObjGuard ( *this , SnmpWinSnmpTrapSession::DestroySession ) ;

    if (TRAP_EVENT == message)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Received Trap\n" 

    ) ;
)

        /*
        never the case 'cos if the list is empty, this session
        would not have been created by the TrapMnager!
        if (m_managerPtr->m_receivers->IsEmpty())
        {
            return 0;
        }
        */

        HSNMP_ENTITY hsrc;
        HSNMP_CONTEXT hctxt;
        HSNMP_VBL hvbl;
        HSNMP_PDU hpdu;

        SNMPAPI_STATUS status = SnmpRecvMsg (m_session_handle,
                                                &hsrc, NULL, &hctxt, &hpdu);
        
        if (SNMPAPI_FAILURE != status)
        {
            SnmpSecurity *ctxt = OperationHelper::GetSecurityContext(hctxt);
            SnmpFreeContext(hctxt);

            if (NULL == ctxt) 
            {
                //conversion failed clean up and return
                SnmpFreePdu(hpdu);
                SnmpFreeEntity(hsrc);
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to security context decode failure\n" 

    ) ;
)
            }
            else
            {
                SnmpTransportAddress *src = OperationHelper::GetTransportAddress(hsrc);
                SnmpFreeEntity(hsrc);

                if (NULL == src)
                {
                    //conversion failed clean up and return
                    delete ctxt;
                    SnmpFreePdu(hpdu);
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to source address decode failure\n" 

    ) ;
)
                }
                else
                {
                    smiINT t_PduType ;
                    status = SnmpGetPduData(hpdu, &t_PduType, NULL, NULL, NULL, &hvbl);

                    //got the vblist, don't need the pdu
                    SnmpFreePdu(hpdu);

                    
                    if (SNMPAPI_FAILURE == status)
                    {
                        //failed to get varbinds clean up and return
                        delete ctxt;
                        delete src;
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to PDU decode failure\n" 

    ) ;
)
                    }
                    else
                    {
                        if ( !(( SNMP_PDU_TRAP == t_PduType  ) || 
                               ( SNMP_PDU_V1TRAP == t_PduType) || 
                               ( SNMP_PDU_INFORM == t_PduType)))
                        {
                            delete ctxt;
                            delete src;
                            SnmpFreeVbl(hvbl);
                            DestroySession();
                            return ret;
                        }

                        UINT vbcount = SnmpCountVbl(hvbl);

                        if (SNMPAPI_FAILURE == vbcount)
                        {
                            delete ctxt;
                            delete src;
                            SnmpFreeVbl(hvbl);
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to VarBind count decode failure\n" 

    ) ;
)
                        }
                        else
                        {
                            SnmpVarBindList vbl;

                            for (UINT i = 1; i <= vbcount; i++)
                            {
                                smiOID vbname;
                                smiVALUE vbvalue;
                                status = SnmpGetVb(hvbl, i, &vbname, &vbvalue);

                                if (SNMPAPI_FAILURE == status)
                                {
                                    delete ctxt;
                                    delete src;
                                    SnmpFreeVbl(hvbl);
                                    hvbl = NULL;
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to complete VarBind decode failure\n" 

    ) ;
)
                                    break;
                                }
                                else
                                {
                                    SnmpVarBind* vb = OperationHelper::GetVarBind(vbname, vbvalue);
                                    if ( ! vb )
                                    {
                                        delete ctxt;
                                        delete src;
                                        SnmpFreeVbl(hvbl);
                                        hvbl = NULL;
                                        SnmpFreeDescriptor(SNMP_SYNTAX_OID, (smiOCTETS *)&vbname);
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to (%d)th VarBind decode failure\n",
        i

    ) ;
)
                                        break;
                                    }

                                    SnmpFreeDescriptor(SNMP_SYNTAX_OID, (smiOCTETS *)&vbname);

                                    switch (vbvalue.syntax)
                                    {
                                        case SNMP_SYNTAX_OCTETS :
                                        case SNMP_SYNTAX_BITS :
                                        case SNMP_SYNTAX_OPAQUE :
                                        case SNMP_SYNTAX_IPADDR :
                                        case SNMP_SYNTAX_NSAPADDR :
                                        {
                                            SnmpFreeDescriptor(SNMP_SYNTAX_OCTETS, &vbvalue.value.string);
                                        }
                                        break ;

                                        case SNMP_SYNTAX_OID :
                                        {
                                            SnmpFreeDescriptor(SNMP_SYNTAX_OID,
                                                                (smiOCTETS *)(&vbvalue.value.oid));
                                        }
                                        break ;

                                        default:
                                        {
                                        }
                                    }

                                    vbl.AddNoReallocate (*vb);
                                }
                            }

                            if (hvbl != NULL)
                            {
                                SnmpFreeVbl(hvbl);
                                SnmpTrapReceiver * rx = m_managerPtr->m_receivers.GetNext();

                                while (NULL != rx)
                                {
                                    InterlockedIncrement(&(rx->m_cRef));
                                    rx->Receive(*src, *ctxt, vbl);
                                    rx->DestroyReceiver();
                                    rx = m_managerPtr->m_receivers.GetNext();
                                }

                                delete ctxt;
                                delete src;
                            }
                            else
                            {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to receive failure\n" 

    ) ;
)
                            }
                        }
                    }
                }
            }
        }
        else
        {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to decode error\n" 

    ) ;
)
        }
    }
    else
    {
        ret = Window::HandleEvent(hWnd, message, wParam, lParam);
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\tsess.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: tsess.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "error.h"
#include "encdec.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"

#include "tsent.h"

#include "transp.h"
#include "tsess.h"
#include "sync.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"

TransportWindow::TransportWindow (

    SnmpImpTransport &owner_transport

) : owner ( owner_transport ) , m_Session ( NULL )
{
    smiUINT32 t_MajorVersion = 1 ;
    smiUINT32 t_MinorVersion = 1 ;
    smiUINT32 t_Level = 2 ;
    smiUINT32 t_TranslateMode = SNMPAPI_UNTRANSLATED_V1 ;
    smiUINT32 t_RetransmitMode = SNMPAPI_OFF ;

    CriticalSectionLock t_CriticalSectionLock ( SnmpEncodeDecode :: s_CriticalSection ) ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;
    
    SNMPAPI_STATUS t_StartupStatus = SnmpStartup (

        &t_MajorVersion,
        &t_MinorVersion,
        &t_Level,
        &t_TranslateMode,
        &t_RetransmitMode
    );

    t_CriticalSectionLock.UnLock () ;

    if ( t_StartupStatus == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

    m_Session = SnmpOpen (

        GetWindowHandle (), 
        Window :: g_MessageArrivalEvent 
    ) ;

    if ( m_Session == SNMPAPI_FAILURE )
    {
        m_Session = NULL;
        DWORD t_LastError = SnmpGetLastError (0) ;
        throw GeneralException ( 

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

}

TransportWindow::~TransportWindow ()
{
    HSNMP_SESSION t_Session = ( HSNMP_SESSION ) m_Session ;
    if ( t_Session )
        SnmpClose ( t_Session ) ;
}

// over-rides the HandleEvent method provided by the
// WinSnmpSession. Receives the Pdu and passes it to
// the owner (SnmpTransport)

LONG_PTR TransportWindow::HandleEvent (

    HWND hWnd ,
    UINT message ,
    WPARAM wParam ,
    LPARAM lParam
)
{
    LONG rc = 0;

    try 
    {
        // check if the message needs to be handled
        if ( message == Window :: g_MessageArrivalEvent )
        {
            // inform the owner of a successful message receipt
            SnmpPdu t_SnmpPdu ;

            if ( ReceivePdu ( t_SnmpPdu ) )
            {
                owner.TransportReceiveFrame ( t_SnmpPdu , t_SnmpPdu.GetErrorReport () ) ; 

                delete & t_SnmpPdu.GetVarbindList () ; 
            }
            else
            {
            }
        }
        else if ( message == Window :: g_SentFrameEvent )
        {
            // inform the owner of a sent frame event
            // the error report will be ignored in this case
            owner.HandleSentFrame( (TransportFrameId)wParam );
        }
        else
        {
            return Window::HandleEvent(hWnd, message, wParam, lParam);
        }
    }
	catch ( Heap_Exception e_He )
	{
	}
    catch ( GeneralException exception )
    {
    }

    return rc;
}

// sends the specified pdu. it decodes the SnmpPdu to extract
// parameters needed for SnmpSendMsg. the return value denotes
// success and failure in transmission
// we return on encoutering an error from the winsnmp library call

BOOL TransportWindow :: SendPdu (

    IN SnmpPdu &a_SnmpPdu
)
{
    WinSnmpVariables t_WinSnmpVariables ;

    BOOL t_Status ;
    try 
    {
        t_Status = owner.session.GetSnmpEncodeDecode ().EncodeFrame ( a_SnmpPdu , &t_WinSnmpVariables ) ;
        if ( ! t_Status )
        {
            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError ((HSNMP_SESSION) m_Session) 
            );
        }
    }
	catch ( Heap_Exception e_He )
	{
		throw ;
	}
    catch ( GeneralException exception )
    {
        throw ;
    }

    HSNMP_CONTEXT t_Context = t_WinSnmpVariables.m_Context ;
    HSNMP_PDU t_Pdu = t_WinSnmpVariables.m_Pdu ;
    HSNMP_VBL t_Vbl = t_WinSnmpVariables.m_Vbl ;

    char *t_DstAddress = owner.GetTransportAddress ().GetAddress () ;

    CriticalSectionLock t_CriticalSectionLock ( SnmpEncodeDecode :: s_CriticalSection ) ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    owner.session.GetSnmpEncodeDecode ().SetTranslateMode () ;

    HSNMP_ENTITY t_SrcEntity = SnmpStrToEntity (

        ( HSNMP_SESSION ) m_Session ,
        LOOPBACK_ADDRESS 
    ) ;

    if ( t_SrcEntity == SNMPAPI_FAILURE )
    {
        SnmpFreeContext ( t_Context ) ;
        SnmpFreePdu ( t_Pdu ) ;
        SnmpFreeVbl ( t_Vbl ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );
    }

    HSNMP_ENTITY t_DstEntity = SnmpStrToEntity (

        ( HSNMP_SESSION ) m_Session ,
        t_DstAddress
    ) ;

    t_CriticalSectionLock.UnLock () ;

    if ( t_DstEntity == SNMPAPI_FAILURE )
    {
        SnmpFreeContext ( t_Context ) ;
        SnmpFreeEntity ( t_SrcEntity ) ;
        SnmpFreePdu ( t_Pdu ) ;
        SnmpFreeVbl ( t_Vbl ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );
    }

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Transport::SendPdu: sending %d\r\n\r\n" , t_WinSnmpVariables.m_RequestId 

    ) ;

    smiOCTETS t_Octets ;

    SnmpSetRetransmitMode ( SNMPAPI_OFF ) ;

    if ( SnmpEncodeMsg (

        m_Session,
        t_SrcEntity, 
        t_DstEntity,
        t_Context, 
        t_Pdu ,
        & t_Octets 

    ) != SNMPAPI_FAILURE )
    {
        ULONG t_Len = t_Octets.len ;
        UCHAR *t_Ptr = t_Octets.ptr ;

        ULONG t_RowLength = t_Len / 16 ;
        ULONG t_Remainder = t_Len % 16 ;
        
        ULONG t_Index = 0 ;
        for ( ULONG t_RowIndex = 0 ; t_RowIndex < t_RowLength ; t_RowIndex ++ )
        {
            ULONG t_StoredIndex = t_Index ;

            for ( ULONG t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%2.2lx  " , t_Ptr [ t_Index ++ ] ) ;
            }

            SnmpDebugLog :: s_SnmpDebugLog->Write ( L"        " ) ;

            for ( t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
            {
                if ( ( t_Ptr [ t_StoredIndex ] >= 0x20 ) && ( t_Ptr [ t_StoredIndex ] <= 0x7f ) ) 
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%c" , t_Ptr [ t_StoredIndex ] ) ;
                }
                else
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write (  L"." ) ;
                }

                t_StoredIndex ++ ;
            }

            SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\r\n" ) ;
        }       

        ULONG t_StoredIndex = t_Index ;
        for ( ULONG t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
        {
            if ( t_ColumnIndex < t_Remainder )
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%2.2lx  " , t_Ptr [ t_Index ++ ] ) ;
            }
            else
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write (  L"    " ) ;
            }
        }

        SnmpDebugLog :: s_SnmpDebugLog->Write ( L"        " ) ;

        for ( t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
        {
            if ( t_ColumnIndex < t_Remainder )
            {
                if ( t_Ptr [ t_StoredIndex ] >= 0x20 && t_Ptr [ t_StoredIndex ] <= 0x7f ) 
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%c" , t_Ptr [ t_StoredIndex ] ) ;
                }
                else
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write (  L"." ) ;
                }

                t_StoredIndex ++ ;
            }
        }

        SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\r\n\r\n" ) ;

        SnmpFreeDescriptor ( 

            SNMP_SYNTAX_OCTETS ,
            & t_Octets
        ) ;
    }
)

    SnmpSetRetransmitMode ( SNMPAPI_OFF ) ;

    // send message
    t_Status = SnmpSendMsg (

        m_Session,
        t_SrcEntity, 
        t_DstEntity,
        t_Context, 
        t_Pdu
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Transport::SendPdu: failed sending %d\r\n\r\n" , t_WinSnmpVariables.m_RequestId 

    ) ;
)
        SnmpFreeContext ( t_Context ) ;
        SnmpFreeEntity ( t_SrcEntity ) ;
        SnmpFreeEntity ( t_DstEntity ) ;
        SnmpFreePdu ( t_Pdu ) ;
        SnmpFreeVbl ( t_Vbl ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        ) ;
    }

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeVbl ( t_Vbl ) ;

    if ( t_Status == SNMPAPI_FAILURE )
        return FALSE;
    else
        return TRUE;
}

BOOL TransportWindow :: ReceivePdu (

    OUT SnmpPdu &a_SnmpPdu 
)
{
    HSNMP_ENTITY t_SrcEntity = NULL;
    HSNMP_ENTITY t_DstEntity = NULL;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    SNMPAPI_STATUS t_Status = SnmpRecvMsg (

        m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu
    );

    if ( t_SrcEntity ) 
    {
        SnmpFreeEntity ( t_SrcEntity ) ;
    }

    if ( t_DstEntity )
    {
        SnmpFreeEntity ( t_DstEntity ) ;
    }

    if ( t_Status == SNMPAPI_FAILURE )
    {
        if ( SnmpGetLastError ((HSNMP_SESSION) m_Session) == SNMPAPI_NOOP )
        {
            return FALSE ;
        }
        else
        {
            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError ((HSNMP_SESSION) m_Session)
            );  
        }
    }

    CriticalSectionLock t_CriticalSectionLock ( SnmpEncodeDecode :: s_CriticalSection ) ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    owner.session.GetSnmpEncodeDecode ().SetTranslateMode () ;

    t_SrcEntity = SnmpStrToEntity ( (HSNMP_SESSION) m_Session, LOOPBACK_ADDRESS ) ;
    t_DstEntity = SnmpStrToEntity ( (HSNMP_SESSION) m_Session, LOOPBACK_ADDRESS ) ;

    t_CriticalSectionLock.UnLock () ;

    WinSnmpVariables t_WinSnmpVariables ;

    t_WinSnmpVariables.m_SrcEntity = t_SrcEntity ;
    t_WinSnmpVariables.m_DstEntity = t_DstEntity ;
    t_WinSnmpVariables.m_Context = t_Context ;
    t_WinSnmpVariables.m_Pdu = t_Pdu  ;

    t_Status = owner.session.GetSnmpEncodeDecode ().DecodeFrame ( &t_WinSnmpVariables , a_SnmpPdu ) ;
    if ( ! t_Status ||
        SnmpEncodeDecode :: PduType :: RESPONSE != a_SnmpPdu.GetPduType() )
    {
        SnmpFreePdu ( t_Pdu ) ;
        SnmpFreeEntity ( t_SrcEntity ) ;
        SnmpFreeEntity ( t_DstEntity ) ;
        SnmpFreeContext ( t_Context ) ;

        throw GeneralException (

            Snmp_Error, 
            SnmpEncodeDecode :: PduType :: GETBULK == a_SnmpPdu.GetPduType() ? Snmp_General_Abort : Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );
    }

    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreeContext ( t_Context ) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\wsess.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: wsess.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "wsess.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\value.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: value.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include <typeinfo.h>
#include "common.h"
#include "address.h"
#include "value.h"

#define MAX_FIELDS 100
#define FIELD_SEPARATOR '.'

BOOL SnmpNull :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = TRUE;
    }

    return bResult;
}


// Copy constructor
SnmpInteger::SnmpInteger ( IN const SnmpInteger &value )
{
    val = value.GetValue();
}

BOOL SnmpInteger :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpInteger &)value);
    }

    return bResult;
}

LONG SnmpInteger::GetValue () const
{ 
    return val; 
}

void SnmpInteger::SetValue ( IN const LONG value ) 
{ 
    val = value; 
}

SnmpValue *SnmpInteger::Copy () const 
{ 
    return new SnmpInteger(val);
}

// Copy constructor
SnmpGauge::SnmpGauge ( IN const SnmpGauge &value )
{
    val = value.GetValue();
}

BOOL SnmpGauge :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpGauge &)value);
    }

    return bResult;
}

ULONG SnmpGauge::GetValue () const
{ 
    return val; 
}

void SnmpGauge::SetValue ( IN const ULONG value ) 
{ 
    val = value; 
}

SnmpValue *SnmpGauge::Copy () const 
{ 
    return new SnmpGauge(val);
}

// Copy constructor
SnmpCounter::SnmpCounter ( IN const SnmpCounter &value )
{
    val = value.GetValue();
}

BOOL SnmpCounter :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpCounter &)value);
    }

    return bResult;
}

ULONG SnmpCounter::GetValue () const
{ 
    return val; 
}

void SnmpCounter::SetValue ( IN const ULONG value ) 
{ 
    val = value; 
}

SnmpValue *SnmpCounter::Copy () const 
{ 
    return new SnmpCounter(val);
}

// Copy constructor
SnmpTimeTicks::SnmpTimeTicks ( IN const SnmpTimeTicks &value )
{
    val = value.GetValue();
}

BOOL SnmpTimeTicks :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpTimeTicks &)value);
    }

    return bResult;
}

ULONG SnmpTimeTicks::GetValue () const
{ 
    return val; 
}

void SnmpTimeTicks::SetValue ( IN const ULONG value ) 
{ 
    val = value; 
}

SnmpValue *SnmpTimeTicks::Copy () const 
{ 
    return new SnmpTimeTicks(val);
}

void SnmpOctetString::OverWrite(IN const UCHAR *value)
{
    if ( value && length )
    {
        memcpy(val, value, sizeof(UCHAR)*length);
    }
}

void SnmpOctetString::Initialize(IN const UCHAR *value, IN const ULONG valueLength)
{
    is_valid = FALSE;

    if ( (value == NULL) && (valueLength != 0) )
        return;

    length = valueLength;
    val = Replicate(value, valueLength);
    is_valid = TRUE;
}


void SnmpOctetString::UnReplicate(UCHAR *value)
{
    if ( is_valid == TRUE )
        delete[] val;
}

SnmpOctetString::SnmpOctetString ( IN const UCHAR *value , IN const ULONG valueLength ) : is_valid ( FALSE )
{       
    Initialize(value, valueLength);
}

SnmpOctetString::SnmpOctetString ( IN const SnmpOctetString &value ) : is_valid ( FALSE )
{
    Initialize(value.GetValue(), value.GetValueLength());
}

SnmpOctetString::~SnmpOctetString ()
{
    UnReplicate(val);
}


ULONG SnmpOctetString::GetValueLength () const 
{ 
    return length; 
}

UCHAR *SnmpOctetString::GetValue () const 
{ 
    return val; 
}

SnmpValue *SnmpOctetString::Copy () const 
{
    return new SnmpOctetString(val, length);
}
    
UCHAR *SnmpOctetString::Replicate(IN const UCHAR *value, IN const ULONG valueLength)
{
    if ( value )
    {
        UCHAR *temp = new UCHAR[valueLength];

        memcpy(temp, value, sizeof(UCHAR)*valueLength);

        return temp;
    }
    else
    {
        return NULL ;
    }
}

void SnmpOctetString::SetValue ( IN const UCHAR *value , IN const ULONG valueLength )
{
    if (length != valueLength)
    {
        UnReplicate(val);
        Initialize(value, valueLength);
    }
    else
        OverWrite(value);
}

BOOL SnmpOctetString :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpOctetString &)value);
    }

    return bResult;
}

BOOL SnmpOctetString::Equivalent(IN const SnmpOctetString &snmp_octet_string) const
{
    if ( is_valid && snmp_octet_string() )
    {
        if ( length != snmp_octet_string.GetValueLength() )
            return FALSE;

        UCHAR *octet_values = snmp_octet_string.GetValue();

        for( UINT i=0; i < length; i++)
        {
            if ( val[i] != octet_values[i] )
                return FALSE;
        }

        return TRUE;
    }
    else
        return FALSE;
}

void SnmpObjectIdentifier::OverWrite(IN const ULONG *value)
{
    if ( value )
    {
        memcpy(val, value, sizeof(ULONG)*length);
    }
}

void SnmpObjectIdentifier::Initialize(IN const ULONG *value, IN const ULONG valueLength)
{   
    if ( ( (value == NULL) && (valueLength != 0) ) || ( valueLength == 0 ) )
    {
        length = 0 ;
        val = NULL ;
        return;
    }

    length = valueLength;

    if ( length <= DEFAULT_OBJECTIDENTIFIER_LENGTH )
    {
        val = m_value ;
        memcpy(val , value, sizeof(ULONG)*length);
        is_valid = TRUE;

    }
    else
    {
        val = new ULONG[length];
        memcpy(val , value, sizeof(ULONG)*length);
        is_valid = TRUE;
    }
}

void SnmpObjectIdentifier::UnReplicate(ULONG *value)
{
    if ( ( is_valid == TRUE ) & ( length > DEFAULT_OBJECTIDENTIFIER_LENGTH ) )
    {
        delete[] val;
    }
}

SnmpObjectIdentifier::SnmpObjectIdentifier ( IN const ULONG *value , IN const ULONG valueLength ) : val ( NULL ) , length ( 0 ) , is_valid ( TRUE ) 
{   
    Initialize(value, valueLength);
}

SnmpObjectIdentifier::SnmpObjectIdentifier ( IN const SnmpObjectIdentifier &value ) : val ( NULL ) , length ( 0 ) , is_valid ( TRUE ) 
{
    Initialize(value.GetValue(), value.GetValueLength());
}

SnmpObjectIdentifier::~SnmpObjectIdentifier ()
{
    UnReplicate(val);
}

ULONG SnmpObjectIdentifier::GetValueLength () const 
{ 
    return length; 
}

ULONG *SnmpObjectIdentifier::GetValue () const 
{ 
    return val; 
}

SnmpValue *SnmpObjectIdentifier::Copy () const 
{
    return new SnmpObjectIdentifier(val, length);
}

        
ULONG *SnmpObjectIdentifier::Replicate(IN const ULONG *value, IN const ULONG valueLength) const
{
    if ( value )
    {
        ULONG *temp = new ULONG[valueLength];
        memcpy(temp, value, sizeof(ULONG)*valueLength);
        return temp;
    }
    else
    {
        return NULL ;
    }
}

        
ULONG *SnmpObjectIdentifier::Replicate(IN const ULONG *first_value, 
                                       IN const ULONG first_length,
                                       IN const ULONG *second_value,
                                       IN const ULONG second_length) const
{
    if ( first_value && second_value )
    {
        ULONG new_length = first_length + second_length;
        ULONG *temp = new ULONG[new_length];
            
        int first_value_size = sizeof(ULONG)*first_length;

        memcpy(temp, first_value, first_value_size);
        memcpy(temp + first_length, second_value, 
                    sizeof(ULONG)*second_length);
        return temp;
    }
    else if ( first_value )
    {
        ULONG *temp = new ULONG [ first_length];
        memcpy(temp, first_value, sizeof(ULONG)*first_length);
        return temp;
    }
    else if ( second_value )
    {
        ULONG *temp = new ULONG [ second_length];
        memcpy(temp, second_value, sizeof(ULONG)*second_length);
        return temp;

    }
    else
    {
        return NULL ;
    }
}


SnmpObjectIdentifier::Comparison SnmpObjectIdentifier::Compare(IN const SnmpObjectIdentifier &first, 
                                                               IN const SnmpObjectIdentifier &second) const
{
    ULONG *first_string = first.GetValue();
    ULONG *second_string = second.GetValue();
    int first_length = first.GetValueLength();
    int second_length = second.GetValueLength();
    int min_length = MIN(first_length,second_length);

    for(int i=0; i < min_length; i++)
    {
        if ( first_string[i] < second_string[i] )
            return LESS_THAN;
        else if ( first_string[i] > second_string[i] )
            return GREATER_THAN;
        else
            continue;
    }

    if ( first_length < second_length )
        return LESS_THAN;
    else if ( first_length > second_length )
            return GREATER_THAN;
    else
        return EQUAL_TO;
}

void SnmpObjectIdentifier::SetValue ( IN const ULONG *value , IN const ULONG valueLength )
{
    if (valueLength)
    {
        if ( length != valueLength)
        {
            UnReplicate(val);
            Initialize(value, valueLength);
        }
        else
        {
            OverWrite(value);
        }
    }
    else
    {
        UnReplicate(val);
        val = NULL ;
        length = 0 ;
    }
}

// A null terminated dot-separated string representing the 
// object identifer value is passed and the private fields
// and length are set from it
SnmpObjectIdentifier::SnmpObjectIdentifier(IN const char *value)
{
    is_valid = FALSE;

    UINT str_len = strlen(value);
    if ( str_len <= 0 )
        return;

    ULONG temp_field[MAX_FIELDS];

    // create an input stream from the string
    istrstream input_stream((char *)value);

    // consecutive fields must be separated by a
    // FIELD_SEPARATOR
    char separator;

    input_stream >> temp_field[0];

    if ( input_stream.bad() || input_stream.fail() )
        return;

    // while the stream still has something,
    // read (FIELD_SEPARATOR, ULONG) pairs from the input stream
    // and set the temp_fields
    // check if the read was bad or failed after the event
    for( int i = 1 ; (i < MAX_FIELDS) && (!input_stream.eof()); i++)
    {
        input_stream >> separator;

        if ( input_stream.bad() || input_stream.fail() )
            return;

        if ( separator != FIELD_SEPARATOR )
            return;

        input_stream >> temp_field[i];
 
        if ( input_stream.bad() || input_stream.fail() )
            return;
    }

    is_valid = TRUE;

    // set the length
    length = i;
    val = NULL ;

    // create memory for the fields and copy temp_fields into it
    Initialize(temp_field, length);
}


BOOL SnmpObjectIdentifier::Equivalent(IN const SnmpObjectIdentifier &value,
                                       IN ULONG max_length) const
{
    if ( (!is_valid) || (!value()) )
        return FALSE;

    if ( (length < max_length) || (value.GetValueLength() < max_length) )
        return FALSE;

    ULONG *value_string = value.GetValue();

    for( UINT i=0; i < max_length; i++ )
        if ( val[i] != value_string[i] )
            return FALSE;

    return TRUE;
}

BOOL SnmpObjectIdentifier::Equivalent(IN const SnmpObjectIdentifier &value) const
{
    if ( (!is_valid) || (!value()) )
        return FALSE;

    ULONG *value_string = value.GetValue();

    for( UINT i=length; i ; i-- )
    {
        if ( val[i-1] != value_string[i-1] )
            return FALSE;
    }

    return TRUE;
}

BOOL SnmpObjectIdentifier :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpObjectIdentifier &)value);
    }

    return bResult;
}

SnmpObjectIdentifier SnmpObjectIdentifier::operator+ ( IN const SnmpObjectIdentifier &value ) const
{   
    ULONG *temp_plus_array = Replicate(val, length, value.GetValue(), value.GetValueLength());

    SnmpObjectIdentifier local_identifier(temp_plus_array, length+value.GetValueLength());
    delete[] temp_plus_array;

    return SnmpObjectIdentifier(local_identifier);
}

// Determines the fields (starting from left), common to the
// two object identifiers and returns a new object identifier
// with only these fields. If nothing is shared, NULL is returned
SnmpObjectIdentifier *SnmpObjectIdentifier::Cut( SnmpObjectIdentifier &value ) const
{
    // determine the smaller of the two lengths
    int min_length = MIN(length, value.GetValueLength());
    ULONG *other_field = value.GetValue();

    // compare the fields
    for(int index=0; index < min_length; index++)
        if ( val[index] != other_field[index] )
            break;

    // if nothing in common - return NULL
    if ( index == 0 )
        return NULL;

    // they must have the fields in the range [0..(index-1)] common
    // therefore, a common length of "index"
    return new SnmpObjectIdentifier(other_field, index);
}


ULONG &SnmpObjectIdentifier::operator [] ( IN const ULONG index ) const
{
    if ( index < length )
        return val[index];

    // should never reach here if the user checks the
    // index value before
    return val[0];
}

//returns an allocated char* representation of the OID.
//The return value  must be freed by the caller i.e. delete []
char *SnmpObjectIdentifier::GetAllocatedString() const
{
    char * retVal = NULL ;

    if (length)
    {
        retVal = new char [ length * 18 ] ;
        ostrstream s ( retVal , length * 18 ) ;
        s << val[0];
        UINT i = 1;
        char dot = '.';

        while (i < length)
        {
            s << dot << val[i++] ;
        }
        
        s << ends ;
    }

    return retVal;
}
        

SnmpIpAddress::SnmpIpAddress ( IN const char *value )
{
    // create a stream to read the fields from
    istrstream address_stream((char *)value);

    // store the values [0..255] separated by FIELD_SEPARATORs
    // in the value string
    UCHAR field[SNMP_IP_ADDR_LEN];

    // contains the maximum value for a UCHAR. used
    // for comparison with the field values read
    const UCHAR max_uchar = -1;

    // consecutive fields must be separated by a
    // FIELD_SEPARATOR
    char separator;

    // a field is first read into this for comparison
    // with max_uchar
    ULONG temp_field;

    is_valid = FALSE;

    // read the first three (UCHAR,FIELD_SEPARATOR) pairs
    // check if the stream is good before each read
    for(int i=0; i < (SNMP_IP_ADDR_LEN-1); i++)
    {
        if ( !address_stream.good() )
            return;

        address_stream >> temp_field;
        if ( temp_field > max_uchar )
            return;

        field[i] = (UCHAR)temp_field;

        if ( !address_stream.good() )
            return;

        address_stream >> separator;
        if ( separator != FIELD_SEPARATOR )
            return;
    }

    if ( !address_stream.good() )
        return;

    address_stream >> temp_field;
    if (temp_field > max_uchar)
        return;

    field[SNMP_IP_ADDR_LEN-1] = (UCHAR)temp_field;

    // make sure that there are is nothing more left in the
    // stream
    if ( !address_stream.eof() )
        return;

    ULONG byteA = field [ 0 ] ;
    ULONG byteB = field [ 1 ] ;
    ULONG byteC = field [ 2 ] ;
    ULONG byteD = field [ 3 ] ;

    val = ( byteA << 24 ) + ( byteB << 16 ) + ( byteC << 8 ) + byteD ;

    is_valid = TRUE;
}


// Copy constructor
SnmpIpAddress::SnmpIpAddress ( IN const SnmpIpAddress &value )
{
    if ( value() )
    {
        val = value.GetValue();
        is_valid = TRUE;
    }
    else
        is_valid = FALSE;
}

BOOL SnmpIpAddress :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpIpAddress &)value);
    }

    return bResult;
}


ULONG SnmpIpAddress::GetValue () const
{ 
    return val; 
}

void SnmpIpAddress::SetValue ( IN const ULONG value ) 
{ 
    val = value;
    is_valid = TRUE;
}

SnmpValue *SnmpIpAddress::Copy () const 
{ 
    return new SnmpIpAddress(val);
}

// Copy constructor
SnmpUInteger32::SnmpUInteger32 ( IN const SnmpUInteger32 &value )
{
    val = value.GetValue();
}

ULONG SnmpUInteger32::GetValue () const
{ 
    return val; 
}

void SnmpUInteger32::SetValue ( IN const ULONG value ) 
{ 
    val = value; 
}

SnmpValue *SnmpUInteger32::Copy () const 
{ 
    return new SnmpUInteger32(val);
}

BOOL SnmpUInteger32 :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpUInteger32 &)value);
    }

    return bResult;
}

// Copy constructor
SnmpCounter64::SnmpCounter64( IN const SnmpCounter64 &value )
{
    lval = value.GetLowValue();
    hval = value.GetHighValue();
}

ULONG SnmpCounter64::GetLowValue () const
{ 
    return lval; 
}

ULONG SnmpCounter64::GetHighValue () const
{ 
    return hval; 
}

void SnmpCounter64::SetValue ( IN const ULONG lvalue , IN const ULONG hvalue ) 
{ 
    lval = lvalue; 
    hval = hvalue ;
}

SnmpValue *SnmpCounter64::Copy () const 
{ 
    return new SnmpCounter64(lval,hval);
}

BOOL SnmpCounter64 :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpCounter64 &)value);
    }

    return bResult;
}

BOOL SnmpNoSuchInstance :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = TRUE;
    }

    return bResult;
}

BOOL SnmpNoSuchObject :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = TRUE;
    }

    return bResult;
}

BOOL SnmpEndOfMibView :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = TRUE;
    }

    return bResult;
}

BOOL SnmpOpaque :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpOpaque &)value);
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\vblist.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: vblist.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "vblist.h"

#define INDEX_VALUE(index) ((index==ILLEGAL_INDEX)?-1:index)
    

SnmpVarBindListNode::SnmpVarBindListNode(const SnmpVarBind *varbind) : varbind ( NULL )
{
    SnmpVarBindListNode::varbind = 
            (varbind==NULL)?NULL: new SnmpVarBind(*varbind);

    // previous and next both point to itself
    previous = next = this;
}

SnmpVarBindListNode::SnmpVarBindListNode(const SnmpVarBind &varbind) : varbind ( NULL )
{
    SnmpVarBindListNode::varbind = new SnmpVarBind(varbind);

    // previous and next both point to itself
    previous = next = this;
}

SnmpVarBindListNode::SnmpVarBindListNode(SnmpVarBind &varbind) : varbind ( NULL )
{
    SnmpVarBindListNode::varbind = & varbind;

    // previous and next both point to itself
    previous = next = this;
}

SnmpVarBindList::ListPosition::~ListPosition()
{
    vblist->DestroyPosition(this);
}

void SnmpVarBindList::EmptyLookupTable(void)
{
    // get the first position
    POSITION current = lookup_table.GetStartPosition();

    // while the position isn't null
    while ( current != NULL )
    {
        PositionHandle  position_handle;
        PositionInfo *position_info;

        // get the next pair
        lookup_table.GetNextAssoc(current, position_handle, position_info);

        // delete the ptr
        delete position_info;
    }
}

SnmpVarBindList::SnmpVarBindList()
        : head(NULL), current_node(&head), next_position_handle(0)
{
    length = 0;
    current_index = ILLEGAL_INDEX;
}

SnmpVarBindList::SnmpVarBindList(IN SnmpVarBindList &varBindList)
                                : head(NULL), current_node(&head), next_position_handle(0)
{
    Initialize(varBindList);
}

SnmpVarBindList::~SnmpVarBindList()
{
   FreeList();
}

SnmpVarBindList &SnmpVarBindList::operator=(IN SnmpVarBindList &vblist)
{
    FreeList();
    Initialize(vblist);

    return *this;
}

void SnmpVarBindList::Initialize(IN SnmpVarBindList &varBindList)
{
    // obtain handle to current position
    ListPosition *list_position = varBindList.GetPosition();

    // get the varBind to identify the parameter list's current
    // position. If it currently points to the head, do the
    // same for local list
    const SnmpVarBind *current_var_bind = varBindList.Get();
    if ( current_var_bind == NULL )
        current_node = &head;

    // reset the list
    varBindList.Reset();
    
    // iterate through the list
    while( varBindList.Next() )
    {
        const SnmpVarBind *current = varBindList.Get();

        // add each varbind to the end of the list 
        Insert(&head,
               new SnmpVarBindListNode(current));

        // when we get to the current var bind in the parameter
        // list, set current_node to point to the node that has
        // just been inserted
        if ( current_var_bind == current )
            current_node = head.GetPrevious();
    }

    // set back the original iterator postion for the parameter list
    varBindList.GotoPosition(list_position);

    // set the current_index, length
    current_index = varBindList.GetCurrentIndex();
    length = varBindList.GetLength();

    // destroy the list_position
    delete list_position;
}

void SnmpVarBindList::GotoPosition(ListPosition *list_position)
{
    // confirm that the list position belongs to this list,
    // obtain the corresponding vblistnode and set current_node
    // to point to it
    if ( list_position->GetList() == this )
    {
        PositionHandle handle = list_position->GetPosition();           

        // check if such a position exists
        PositionInfo *position_info;
        BOOL found = lookup_table.Lookup(handle, position_info);

        if ( found )
        {
            current_node = position_info->current_node;
            current_index = position_info->current_index;

			DestroyPosition(list_position);
        }
    }
}

void SnmpVarBindList::FreeList()
{
    // reset the iterator to the start of the list
    Reset();
    Next();

    // while we do not reach the end of the list
    // at each node, obtain the next node and delete the node
    while (current_node != &head)
    {
        SnmpVarBindListNode *new_current_node = current_node->GetNext();

        delete current_node;

        current_node = new_current_node;
    }

    EmptyLookupTable();
}

void SnmpVarBindList::GoForward(SnmpVarBindListNode *from_node,
                                UINT distance)
{
    current_node = from_node;

    for(; distance > 0; distance--)
        current_node = current_node->GetNext();
}

void SnmpVarBindList::GoBackward(SnmpVarBindListNode *from_node,
                                 UINT distance)
{
    current_node = from_node;

    for(; distance > 0; distance--)
        current_node = current_node->GetPrevious();
}


BOOL SnmpVarBindList::GotoIndex(UINT index)
{
    // check if such an index exists currently
    if ( index >= length )
        return FALSE;

    // calculate the forward and reverse distances from the
    // head and the current_node to find the shortest way
    // to the specified index
    int d1, d2, d3, abs_d2;

    d1 = index+1; // forward distance from head
    d2 = index - INDEX_VALUE(current_index); // distance from current_node
    d3 = length - index; // reverse distance from head

    abs_d2 = abs(d2);   // d2 may be negative

    if ( d1 < abs_d2 )
    {
        if ( d1 < d3 )
            GoForward(&head, d1);
        else
            GoBackward(&head, d3);
    }
    else
    {
        if ( d2 > 0 )
            GoForward(current_node, abs_d2);
        else if ( d2 < 0 )
            GoBackward(current_node, abs_d2);
    }

    current_index = index;

    return TRUE;
}


void SnmpVarBindList::Insert(SnmpVarBindListNode *current, SnmpVarBindListNode *new_node)
{
    current->GetPrevious()->SetNext(new_node);
    new_node->SetPrevious(current->GetPrevious());
    new_node->SetNext(current);
    current->SetPrevious(new_node);
}

void SnmpVarBindList::Release(SnmpVarBindListNode *current)
{
  current->GetPrevious()->SetNext(current->GetNext());
  current->GetNext()->SetPrevious(current->GetPrevious());

  delete current;
}

// Prepares a copy of the list between the indices
// [current_index .. current_index+segment_length-1] and
// returns the varbindlist. If any of the indices do not
// exist, NULL is returned
SnmpVarBindList *SnmpVarBindList::CopySegment(IN const UINT segment_length)
{
    if ( current_index == ILLEGAL_INDEX )
        return NULL;

    // check if the required number of varbinds exist in
    // the remainder of the list
    if ( (current_index + segment_length) > length )
        return NULL;

    // create an empty list
    SnmpVarBindList *var_bind_list = new SnmpVarBindList;

    // Add each var bind in the range to the new list
    for(UINT i=0; i < segment_length; i++)
    {
        var_bind_list->Add(*(current_node->GetVarBind()));

        current_node = current_node->GetNext();
    }

    // now current_node points to the node at 
    // current_index+segment_length (one beyond the last
    // node in the range)
    // set current_index (check if back at head)
    if ( current_node != &head )
        current_index += segment_length;
    else
        current_index = ILLEGAL_INDEX;

    // return the new list
    return var_bind_list;
}

// Prepares a copy of the list between the indices
// [ 1.. index ] and
// returns the varbindlist. If any of the indices do not
// exist, NULL is returned
SnmpVarBindList *SnmpVarBindList::Car ( IN const UINT index )
{
    // check if the required number of varbinds exist in
    // the remainder of the list
    if ( index > length )
        return NULL;

    // create an empty list
    SnmpVarBindList *var_bind_list = new SnmpVarBindList;

    Reset () ;

    // Add each var bind in the range to the new list
    for(UINT i=0; i < index; i++)
    {
        Next () ;
        var_bind_list->Add(*(current_node->GetVarBind()));
    }

    current_index = ILLEGAL_INDEX;

    // return the new list
    return var_bind_list;
}

// Prepares a copy of the list between the indices
// [ 1.. index ] and
// returns the varbindlist. If any of the indices do not
// exist, NULL is returned
SnmpVarBindList *SnmpVarBindList::Cdr (IN const UINT index )
{
    // check if the required number of varbinds exist in
    // the remainder of the list
    if ( index > length )
        return NULL;

    // create an empty list
    SnmpVarBindList *var_bind_list = new SnmpVarBindList;

    Reset () ;
    for(UINT i=0; i < index; i++)
    {
        Next () ;
    }

    // Add each var bind in the range to the new list
    for(i=index; i < length; i++)
    {
        Next () ;
        var_bind_list->Add(*(current_node->GetVarBind()));
    }

    current_index = ILLEGAL_INDEX;

    // return the new list
    return var_bind_list;
}

void SnmpVarBindList::Remove()
{
    if ( current_node != &head )
    {
        // not beyond the list

        SnmpVarBindListNode *new_current_node =
            current_node->GetNext();

        Release(current_node);

        current_node = new_current_node;

        length--;
        if ( current_node == &head )
            current_index = ILLEGAL_INDEX;
    }
}


SnmpVarBindList::ListPosition *SnmpVarBindList::GetPosition()
{
    lookup_table.SetAt(next_position_handle, 
                       new PositionInfo(current_node, current_index));
	PositionHandle position = next_position_handle++ ;
    return new ListPosition(position,this);
}


BOOL SnmpVarBindList::Next()
{
    // get next node
    SnmpVarBindListNode *next_node = current_node->GetNext();

    // if next node is head, return false
    if ( next_node == &head )
        return FALSE;
    else
    {
        // set current node to next node, 
        current_node = next_node;
        
        // update index, return TRUE
        if ( current_index == ILLEGAL_INDEX )
            current_index = 0;
        else
            current_index++;
        return TRUE;
    }
}

void SnmpVarBindList::DestroyPosition(ListPosition *list_position)
{
	PositionHandle handle = list_position->GetPosition();

    PositionInfo *position_info;
    BOOL found = lookup_table.Lookup(handle, position_info);
    if ( found )
    {
	    lookup_table.RemoveKey(list_position->GetPosition());

        delete position_info;
    }
}

/*
void SnmpVarBindList::Print(ostrstream &s)
{
    SnmpVarBindListNode *current = head.GetNext();

    while ( current != &head )
    {
        // mark the current node
        if ( current == current_node )
            s << '*';
        current->GetVarBind()->GetInstance().Print(s);

        // separate varbinds
        s << '&';

        current = current->GetNext();
    }

    s << '|';   // shows that print has finished
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\vbl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: vbl.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include <typeinfo.h>
#include "common.h"
#include "encap.h"
#include "vbl.h"
#include <winsock.h>

#define IP_ADDR_LEN 4
#define BYTE_SIZE 8
#define BYTE_ON_FLAG 255

VBList::VBList(

    IN SnmpEncodeDecode &a_SnmpEncodeDecode , 
    IN SnmpVarBindList &var_bind_list ,
    IN ULONG index
) : var_bind_list ( NULL )
{
    m_Index = index ;

    VBList::var_bind_list = &var_bind_list;

    // Extract session from EncodeDecode object

    WinSNMPSession t_Session = NULL ;

    SnmpV1EncodeDecode *t_SnmpV1EncodeDecode = dynamic_cast<SnmpV1EncodeDecode *>(&a_SnmpEncodeDecode);
    if ( t_SnmpV1EncodeDecode )
    {
        t_Session = ( HSNMP_SESSION ) t_SnmpV1EncodeDecode->GetWinSnmpSession () ;
    }
    else
    {
        SnmpV2CEncodeDecode *t_SnmpV2CEncodeDecode = dynamic_cast<SnmpV2CEncodeDecode *>(&a_SnmpEncodeDecode);
        if ( t_SnmpV2CEncodeDecode )
        {
            t_Session = ( HSNMP_SESSION ) t_SnmpV2CEncodeDecode->GetWinSnmpSession () ;
        }
        else
        {
            throw ;
        }
    }
}

// the VarBindList and the WinSnmpVbl are indexed differently.
//     [0..(length-1)]     [1..length]
// the parameter index refers to the WinSnmpVbl index
SnmpVarBind *VBList::Get(IN UINT vbl_index)
{
    UINT length = var_bind_list->GetLength();

    if ( vbl_index > length )
        return NULL;

    SnmpVarBind *var_bind = new SnmpVarBind(*((*var_bind_list)[vbl_index-1]));

    return var_bind;
}


// the VarBindList and the WinSnmpVbl are indexed differently.
//     [0..(length-1)]     [1..length]
// the parameter index refers to the WinSnmpVbl index
SnmpVarBind *VBList::Remove(IN UINT vbl_index)
{
    UINT length = var_bind_list->GetLength();

    if ( vbl_index > length )
        return NULL;

    SnmpVarBind *var_bind = new SnmpVarBind(*((*var_bind_list)[vbl_index-1]));

    var_bind_list->Remove();

    return var_bind;
}

// the VarBindList and the WinSnmpVbl are indexed differently.
//     [0..(length-1)]     [1..length]
// the parameter index refers to the WinSnmpVbl index
void VBList::Delete(IN UINT vbl_index)
{
    UINT length = var_bind_list->GetLength();

    if ( vbl_index > length )
        return ;

    var_bind_list->Remove();

}

VBList::~VBList(void) 
{ 
    delete var_bind_list;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\window.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: window.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "timer.h"
#include "window.h"


extern HINSTANCE g_hInst ;

WindowMapping Window::mapping;

CriticalSection Window::window_CriticalSection;

UINT Window :: g_TimerMessage = SNMP_WM_TIMER ;
UINT Window :: g_SendErrorEvent = SEND_ERROR_EVENT ;
UINT Window :: g_OperationCompletedEvent = OPERATION_COMPLETED_EVENT ;
UINT Window :: g_MessageArrivalEvent = MESSAGE_ARRIVAL_EVENT ;
UINT Window :: g_SentFrameEvent = SENT_FRAME_EVENT ;
UINT Window :: g_NullEventId = NULL_EVENT_ID ;
UINT Window :: g_DeleteSessionEvent = DELETE_SESSION_EVENT ;

BOOL WaitPostMessage ( 

	HWND window , 
	UINT user_msg_id, 
	WPARAM wParam, 
	LPARAM lParam
)
{
	BOOL status = FALSE ;
	while ( ! status )
	{
		status = :: PostMessage ( window , user_msg_id, wParam, lParam ) ;
		if ( status )
		{
			return status ;
		}

		DWORD lastError = GetLastError () ;
		if ( lastError != E_OUTOFMEMORY )
		{
			TerminateProcess ( GetCurrentProcess () , lastError ) ;	
		}
	}

	return FALSE ;
}

Window::Window ( 

    char *templateCode, 
    BOOL display 
) : window_handle ( NULL )
{
    // is invalid
    is_valid = FALSE;

    // initialize the window

    Initialize (

        templateCode, 
        HandleGlobalEvent, 
        display
    ) ;

    // if handle is null, return

    if ( window_handle == NULL )
        return;

    is_valid = TRUE;
}

LONG_PTR CALLBACK WindowsMainProc (

    HWND hWnd, 
    UINT message ,
    WPARAM wParam ,
    LPARAM lParam
)
{
    return DefWindowProc(hWnd, message, wParam, lParam);
}

BOOL Window::CreateCriticalSection ()
{
    return TRUE ;
}

void Window::DestroyCriticalSection()
{
}


void Window::Initialize (

    char *templateCode, 
    WNDPROC EventHandler,
    BOOL display
)
{
    WNDCLASS  wc ;
 
    wc.style            = CS_HREDRAW | CS_VREDRAW ;
    wc.lpfnWndProc      = EventHandler ;
    wc.cbClsExtra       = 0 ;
    wc.cbWndExtra       = 0 ;
    wc.hInstance        = g_hInst ;
    wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
    wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
    wc.lpszMenuName     = NULL ;
    wc.lpszClassName    = L"templateCode" ;
 
    ATOM winClass = RegisterClass ( &wc ) ;

    if ( ! winClass ) 
    {
        DWORD t_GetLastError = GetLastError () ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Window::Initialise: Error = %lx\n" , t_GetLastError 
    ) ;
)

    }

    window_handle = CreateWindow (

        L"templateCode" ,              // see RegisterClass() call
        L"templateCode" ,                      // text for window title bar
        WS_OVERLAPPEDWINDOW ,               // window style
        CW_USEDEFAULT ,                     // default horizontal position
        CW_USEDEFAULT ,                     // default vertical position
        CW_USEDEFAULT ,                     // default width
        CW_USEDEFAULT ,                     // default height
        NULL ,                              // overlapped windows have no parent
        NULL ,                              // use the window class menu
        g_hInst,                            // instance (0 is used)
        NULL                                // pointer not needed
    ) ;

    if ( window_handle == NULL )
        return;

    // obtain lock
    CriticalSectionLock lock(window_CriticalSection);   

    // if cannot obtain lock, destroy the window
    // since the window cannot be registered, future messages to
    // it cannot be passed to it for processing
    if ( !lock.GetLock(INFINITE) )
    {
        DestroyWindow(window_handle);
        window_handle = NULL;
        return;
    }

    // register the window with the mapping 
    // (HWND,event_handler)

	try
	{
	    mapping[window_handle] = this;
	}
	catch ( Heap_Exception e_He )
	{
        DestroyWindow(window_handle);
        window_handle = NULL;
		return ;
	}

    // release lock
    lock.UnLock();

    if ( display == TRUE )
    {
        ShowWindow ( window_handle , SW_SHOW ) ;
    }
}

BOOL Window::InitializeStaticComponents()
{
    return CreateCriticalSection();
}

void Window::DestroyStaticComponents()
{
    DestroyCriticalSection();
}

// it determines the corresponding EventHandler and calls it
// with the appropriate parameters
LONG_PTR CALLBACK Window::HandleGlobalEvent (

    HWND hWnd ,
    UINT message ,
    WPARAM wParam ,
    LPARAM lParam
)
{
    LONG_PTR rc = 0 ;

    // send timer events to the Timer

    if ( message == WM_TIMER )
    {
#if 1
        UINT timerId = ( UINT ) wParam ;
        SnmpTimerObject *timerObject ;

        CriticalSectionLock session_lock(Timer::timer_CriticalSection);

        if ( !session_lock.GetLock(INFINITE) )
            throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;


        if ( SnmpTimerObject :: timerMap.Lookup ( timerId , timerObject ) )
        {
            SnmpTimerObject :: TimerNotification ( timerObject->GetHWnd () , timerId ) ;
        }
        else
        {
        }
#else

        UINT timerId = ( UINT ) wParam ;
        SnmpTimerObject *timerObject ;

        CriticalSectionLock session_lock(Timer::timer_CriticalSection);

        if ( !session_lock.GetLock(INFINITE) )
            throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

        if ( SnmpTimerObject :: timerMap.Lookup ( timerId , timerObject ) )
        {
            Timer::HandleGlobalEvent(timerObject->GetHWnd (), Timer :: g_SnmpWmTimer, timerId, lParam);
        }
        else
        {
        }

#endif
        return rc ;
    }

    if ( message == Timer :: g_SnmpWmTimer )
    {
        Timer::HandleGlobalEvent(
            hWnd, 
            message, 
            wParam, 
            (DWORD)lParam
            );
        return rc;
    }

    Window *window;

    // obtain lock
    CriticalSectionLock lock(window_CriticalSection);   

    // if cannot obtain lock, print a debug error message
    // and return
    if ( !lock.GetLock(INFINITE) )
    {

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Window::HandleGlobalEvent: ignoring window message (unable to obtain lock)\n"
    ) ;
)
        return rc;
    }

    BOOL found = mapping.Lookup(hWnd, window);

    // release lock
    lock.UnLock();

    // if no such window, return
    if ( !found )
        return DefWindowProc(hWnd, message, wParam, lParam);

    // let the window handle the event
    return window->HandleEvent(hWnd, message, wParam, lParam);
}

// calls the default handler
// a deriving class may override this, but
// must call this method explicitly for default
// case handling

LONG_PTR Window::HandleEvent (

    HWND hWnd ,
    UINT message ,
    WPARAM wParam ,
    LPARAM lParam
)
{
    return DefWindowProc ( hWnd , message , wParam , lParam );
}


bool WaitLock ( CriticalSectionLock &a_Lock , BOOL a_WaitCritical = TRUE )
{
	SetStructuredExceptionHandler t_StructuredException ;

	BOOL t_Do ;

	do 
	{
		try
		{
			a_Lock.GetLock(INFINITE) ;

			return true ;
		}
		catch ( Structured_Exception & t_StructuredException )
		{
#ifdef DBG
			OutputDebugString ( L"CriticalSection exception" ) ;
#endif

			t_Do = a_WaitCritical ;

			if ( t_Do )
			{
				Sleep ( 1000 ) ;
			}

			if ( t_StructuredException.GetSENumber () == STATUS_NO_MEMORY )
			{
			}
			else
			{
				return false ;
			}
		}
		catch ( ... )
		{
			return false ;
		}
	}
	while ( t_Do ) ;

	return true ;
}

Window::~Window(void)
{
    if ( window_handle != NULL )
    {

        // obtain lock
        CriticalSectionLock lock(window_CriticalSection);   

        if ( WaitLock ( lock ) )
        {
            mapping.RemoveKey(window_handle);
        }
		else
		{
			throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;
		}

        // release lock
        lock.UnLock();

        DestroyWindow(window_handle);
        UnregisterClass ( L"templateCode" , 0 ) ;

    }
}

BOOL Window::PostMessage(

    UINT user_msg_id,
    WPARAM wParam, 
    LPARAM lParam
)
{
    return WaitPostMessage(GetWindowHandle(), user_msg_id, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\dummy.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: dummy.hpp

Written By:	B.Rajeev

Purpose: 

Provides a derivative of the WinSnmpSession class for the SnmpImpSession
class for manipulating WinSnmp information and processing Windows
messages
-----------------------------------------------------------------*/

#ifndef __DUMMY_SESSION__
#define __DUMMY_SESSION__

#include "forward.h"
#include "wsess.h"
#include "reg.h"

class SessionWindow : public Window
{
	SnmpImpSession &owner;

	// over-rides the HandlerEvent method provided by the
	// WinSnmpSession. Alerts the owner of a sent frame event
	
	LONG_PTR HandleEvent (

		HWND hWnd ,
		UINT message ,
		WPARAM wParam ,
		LPARAM lParam
	);

public:

	SessionWindow (

		IN SnmpImpSession &owner
	
	) : owner(owner) {}

	~SessionWindow () {}

};


#endif // __DUMMY_SESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\common.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: common.hpp
Purpose	: Provides common constant, typedef, macro and
		  exception declarations. 
Written By:	B.Rajeev
-----------------------------------------------------------------*/


#ifndef __COMMON__
#define __COMMON__

#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <provexpt.h>
#include <limits.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>
#include <winsnmp.h>
#include <objbase.h>

#define DllImport	__declspec( dllimport )
#define DllExport	__declspec( dllexport )

#ifdef SNMPCLINIT
#define DllImportExport DllExport
#else
#define DllImportExport DllImport
#endif

// maximum length of decimal dot notation addresses
#define MAX_ADDRESS_LEN			100

// end of string character
#define EOS '\0'

#define MIN(a,b) ((a<=b)?a:b)

// returns TRUE if i is in [min,max), else FALSE
#define BETWEEN(i, min, max) ( ((i>=min)&&(i<max))?TRUE:FALSE )

// a default community name
#define COMMUNITY_NAME "public"

// a default destination address is the loopback address
// this way we don't have to determine the local ip address
#define LOOPBACK_ADDRESS "127.0.0.1"

// for exception specification
#include "excep.h"

// provides typedefs that encapsulate the winSNMP types
#include "encap.h"

#include "sync.h"

extern BOOL WaitPostMessage ( HWND window , UINT user_msg_id, WPARAM wParam, LPARAM lParam);

#endif // __COMMON__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\address.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*-----------------------------------------------------------------
Filename: address.hpp

Written By:	B.Rajeev

Purpose: 

Provides an abstract class SnmpTransportAddress for manipulating
SNMP transport address information. The class SnmpTransportIpAddress
provides an implementation of the abstract class for IP addresses
-----------------------------------------------------------------*/

#ifndef __ADDRESS__
#define __ADDRESS__

// an IP address is specified using these many UCHAR fields
#define SNMP_IP_ADDR_LEN 4
#define SNMP_IPX_ADDR_LEN 10
#define SNMP_IPX_NETWORK_LEN 4
#define SNMP_IPX_STATION_LEN 6

// behaviour of ip address resolution

#define SNMP_ADDRESS_RESOLVE_VALUE 1
#define SNMP_ADDRESS_RESOLVE_NAME 2

// The SNMP transport information is defined by this abstract class
// since this class may not be instantiated, the copy constructor
// and the "=" operators have been made private and give null definitions
class DllImportExport SnmpTransportAddress
{  
private: 

	// should not be called - returns itself
	SnmpTransportAddress & operator= ( IN const SnmpTransportAddress &address ) 
	{
		return *this;
	}

	// private copy constructor
	SnmpTransportAddress(IN const SnmpTransportAddress &address) {}

protected:

	// protected constructor
	SnmpTransportAddress () {}

public:

	virtual ~SnmpTransportAddress () {}
    	    
	virtual BOOL IsValid () const = 0;

	virtual SnmpTransportAddress *Copy () const  = 0;

	// enables indexing a particular UCHAR field of the address
	virtual UCHAR operator [] ( IN const USHORT  index ) const  = 0;

	// copies the UCHAR fields describing the address onto the OUT UCHAR *
	// parameter. atmost the specified USHORT fields are copied and the
	// number of copied fields is returned
	virtual USHORT GetAddress ( OUT UCHAR * , IN const  USHORT ) const  = 0;

	// returns the number of UCHAR fields currently describing the address
	virtual USHORT GetAddressLength () const  = 0;

	// returns a character string representation of the address
	virtual char *GetAddress () = 0;

	virtual operator void *() const = 0;

	virtual void *operator()(void) const  = 0;
} ;

// provides an implementation of the SnmpTransportAddress for IP addresses
class DllImportExport SnmpTransportIpAddress : public SnmpTransportAddress
{
private:                           

	BOOL is_valid;
	UCHAR field[SNMP_IP_ADDR_LEN];

	// the dotted notation character string representation of the address
	// is constructed on demand and stored in the field 'dotted_notation'
	// the field 'allocated' is flagged 'dotted_notation' points to
	// allocated memory
	BOOL allocated;
	char *dotted_notation;

	BOOL GetIpAddress ( IN const char *address ) ;

public:

	SnmpTransportIpAddress ( IN  const UCHAR *address, IN const USHORT address_length );	

	SnmpTransportIpAddress ( IN const char *address, IN const ULONG addressResolution = SNMP_ADDRESS_RESOLVE_VALUE );

	// the input parameter 'address' contains a single value (32bits) to
	// be stored internally in SNMP_IP_ADDR_LEN UCHAR fields
	SnmpTransportIpAddress ( IN const ULONG address );

	SnmpTransportIpAddress ( IN const SnmpTransportIpAddress &address )	
	{
		allocated = FALSE;
		*this = address;
	}

	SnmpTransportIpAddress ()
	{
		is_valid = FALSE;
		allocated = FALSE;
	}

	~SnmpTransportIpAddress();

	USHORT GetAddress ( OUT UCHAR *address , IN const USHORT length ) const ;

	USHORT GetAddressLength () const	
	{ 
		return ((is_valid)?SNMP_IP_ADDR_LEN:0);
	}

    // memory for the decimal notation string is allocated only when
    // the char *GetAddress method is called (and the address is valid)
    // this memory must be freed if required
	char *GetAddress ();

	BOOL IsValid () const 	
	{
		return is_valid;
	}

	SnmpTransportAddress *Copy () const ;

	BOOL operator== ( IN const SnmpTransportIpAddress & address ) const ;

	BOOL operator!= ( IN const SnmpTransportIpAddress & address ) const 	
	{
		return !(*this==address);
	}

	SnmpTransportIpAddress & operator= ( IN const UCHAR *ipAddr ) ;
	SnmpTransportIpAddress & operator= ( IN const SnmpTransportIpAddress &address ); 
	UCHAR operator [] ( IN const USHORT index ) const ;

	void * operator()(void) const
	{
		return ( (is_valid==TRUE)?(void *)this:NULL );
	}

	operator void *() const
	{
		return SnmpTransportIpAddress::operator()();
	}

	static BOOL ValidateAddress ( IN const char *address , IN const ULONG addressResolution = SNMP_ADDRESS_RESOLVE_VALUE ) ;

};

// provides an implementation of the SnmpTransportAddress for IP addresses
class DllImportExport SnmpTransportIpxAddress : public SnmpTransportAddress
{
private:                           

	BOOL is_valid;
	UCHAR field[SNMP_IPX_ADDR_LEN];

	// the dotted notation character string representation of the address
	// is constructed on demand and stored in the field 'dotted_notation'
	// the field 'allocated' is flagged 'dotted_notation' points to
	// allocated memory
	BOOL allocated;
	char *dotted_notation;

	BOOL GetIpxAddress ( IN const char *address ) ;

public:

	SnmpTransportIpxAddress ( IN  const UCHAR *address, IN const USHORT address_length );	

	SnmpTransportIpxAddress ( IN const char *address );

	SnmpTransportIpxAddress ( IN const SnmpTransportIpxAddress &address )	
	{
		allocated = FALSE;
		*this = address;
	}

	SnmpTransportIpxAddress ()
	{
		is_valid = FALSE;
		allocated = FALSE;
	}

	~SnmpTransportIpxAddress();

	USHORT GetAddress ( OUT UCHAR *address , IN const USHORT length ) const ;

	USHORT GetAddressLength () const	
	{ 
		return ((is_valid)?SNMP_IPX_ADDR_LEN:0);
	}

    // memory for the decimal notation string is allocated only when
    // the char *GetAddress method is called (and the address is valid)
    // this memory must be freed if required
	char *GetAddress ();

	BOOL IsValid () const 	
	{
		return is_valid;
	}

	SnmpTransportAddress *Copy () const ;

	BOOL operator== ( IN const SnmpTransportIpxAddress & address ) const ;

	BOOL operator!= ( IN const SnmpTransportIpxAddress & address ) const 	
	{
		return !(*this==address);
	}

	SnmpTransportIpxAddress & operator= ( IN const UCHAR *ipxAddr ) ;
	SnmpTransportIpxAddress & operator= ( IN const SnmpTransportIpxAddress &address ); 
	UCHAR operator [] ( IN const USHORT index ) const ;

	void * operator()(void) const
	{
		return ( (is_valid==TRUE)?(void *)this:NULL );
	}

	operator void *() const
	{
		return SnmpTransportIpxAddress::operator()();
	}

	static BOOL ValidateAddress ( IN const char *address ) ;
};



#endif // __ADDRESS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\encap.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: encap.hpp

Written By:	B.Rajeev

Purpose: Includes the winsnmp.h file and provides typedef 
		 declarations for some WinSnmp types.
-----------------------------------------------------------------*/

#ifndef __ENCAPSULATE__
#define __ENCAPSULATE__

#include <winsnmp.h>

typedef smiINT	WinSnmpInteger;
typedef smiINT32 WinSnmpInteger32;
typedef HSNMP_PDU WinSnmpPdu;
typedef HSNMP_VBL WinSnmpVbl;
typedef smiOCTETS WinSnmpOctetArray;



#endif // __ENCAPSULATE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\encdec.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-------------------------------------------------------
filename: encdec.hpp
author: B.Rajeev
purpose: Provides declarations for the class PseudoSession.
-------------------------------------------------------*/

#ifndef __ENCODE_DECODE__
#define __ENCODE_DECODE__

#include "forward.h"
#include "error.h"

#define IP_ADDR_LEN 4
#define ILLEGAL_REQUEST_ID 0
typedef long RequestId;

class DllImportExport SnmpEncodeDecode
{
friend VBList;
friend SnmpImpTransport;
friend SnmpImpSession;
friend SnmpCommunityBasedSecurity;
friend SnmpClassLibrary;
friend TransportWindow;

protected:

	BOOL m_IsValid;

	void *m_Session;
	void *m_Window ;

	static CriticalSection s_CriticalSection;

	void *GetWinSnmpSession () { return m_Session ; }

	virtual void SetTranslateMode () = 0 ;

	static BOOL DestroyStaticComponents () ;
	static BOOL InitializeStaticComponents () ;

public:

	enum PduType {GET, GETNEXT, SET, GETBULK, RESPONSE, TRAP, V1TRAP, INFORM, UNKNOWN };

	SnmpEncodeDecode ();

	virtual BOOL EncodeFrame (

		OUT SnmpPdu &a_SnmpPdu ,
		IN RequestId a_RequestId,
		IN PduType a_PduType,
		IN SnmpErrorReport &a_SnmpErrorReport ,
		IN SnmpVarBindList &a_SnmpVarBindList,
		IN SnmpCommunityBasedSecurity *&a_SnmpCommunityBasedSecuity ,
		IN SnmpTransportAddress *&a_SrcTransportAddress ,
		IN SnmpTransportAddress *&a_DstTransportAddress
	) ;

	virtual BOOL EncodeFrame (

		IN SnmpPdu &a_SnmpPdu ,
		OUT void *a_ImplementationEncoding 

	) ;

	virtual BOOL SetVarBindList (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpVarBindList &a_SnmpVarBindList

	) ;

	virtual BOOL SetCommunityName ( 

		IN SnmpPdu &a_SnmpPdu ,
		IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 
	
	) ;

	virtual BOOL SetErrorReport (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpErrorReport &a_SnmpErrorReport

	) ;

	virtual BOOL SetPduType (

		IN SnmpPdu &a_SnmpPdu ,
		OUT PduType a_PduType

	) ;

	virtual BOOL SetSourceAddress ( 

		IN OUT SnmpPdu &a_SnmpPdu ,
		IN SnmpTransportAddress &a_TransportAddress 

	) ;

	virtual BOOL SetDestinationAddress ( 

		IN OUT SnmpPdu &a_SnmpPdu ,
		IN SnmpTransportAddress &a_TransportAddress 

	) ;

	virtual BOOL SetRequestId (

		IN OUT SnmpPdu &a_SnmpPdu ,
		IN RequestId request_id

	) ;

	virtual BOOL DecodeFrame (

		IN SnmpPdu &a_SnmpPdu ,
		OUT RequestId a_RequestId,
		OUT PduType a_PduType ,
		OUT SnmpErrorReport &a_SnmpErrorReport ,
		OUT SnmpVarBindList *&a_SnmpVarBindList ,
		OUT SnmpCommunityBasedSecurity *&a_SnmpCommunityBasedSecurity ,
		OUT SnmpTransportAddress *&a_SrcTransportAddress ,
		OUT SnmpTransportAddress *&a_DstTransportAddress 

	) ;

	virtual BOOL DecodeFrame (

		IN void *a_ImplementationEncoding ,
		OUT SnmpPdu &a_SnmpPdu
	) ;

	virtual BOOL GetPduType (

		IN SnmpPdu &a_SnmpPdu ,
		OUT PduType &a_PduType 

	) ;

	virtual BOOL GetRequestId (

		IN SnmpPdu &a_SnmpPdu ,
		RequestId &a_RequestId

	) ;

	virtual BOOL GetErrorReport (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpErrorReport &a_SnmpErrorReport 

	) ;

	virtual BOOL GetCommunityName ( 

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 
	
	) ;

	virtual BOOL GetVarbindList (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpVarBindList &a_SnmpVarBindList

	) ;

	virtual BOOL GetSourceAddress ( 

		IN SnmpPdu &a_SnmpPdu ,
		SnmpTransportAddress *&a_TransportAddress

	) ;

	virtual BOOL GetDestinationAddress (

		IN SnmpPdu &a_SnmpPdu ,
		SnmpTransportAddress *&a_TransportAddress

	) ;

	virtual void *operator()() const
	{
		return ( m_IsValid ? (void *) this: NULL );
	}

	virtual ~SnmpEncodeDecode ();
};

class DllImportExport SnmpV1EncodeDecode : public SnmpEncodeDecode
{
friend VBList;
friend SnmpImpTransport;
friend SnmpImpSession;
friend SnmpCommunityBasedSecurity;

private:

	void InitializeVariables();

protected:

	void SetTranslateMode () ;
	
public:

	SnmpV1EncodeDecode () ;
	~SnmpV1EncodeDecode ();
};

class DllImportExport SnmpV2CEncodeDecode : public SnmpEncodeDecode
{
private:

	// initializes the pdu
	void InitializeVariables();

protected:

	void SetTranslateMode () ;

public:

	SnmpV2CEncodeDecode () ;
	~SnmpV2CEncodeDecode ();
};

#endif // __ENCODE_DECODE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\error.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: error.hpp
Purpose	: To provide enumerated types for SNMP error 
		  and status. It also provides the declaration
		  of the SnmpErrorReport which encapsulates the
		  error and status values.
Written By:	B.Rajeev
-----------------------------------------------------------------*/

#ifndef __ERROR__
#define __ERROR__

// specifies legal Error values
enum SnmpError 
{
	Snmp_Success	= 0 ,
	Snmp_Error		= 1 ,
	Snmp_Transport	= 2
} ;

// specifies legal Status values
enum SnmpStatus
{
	Snmp_No_Error				= 0 ,
	Snmp_Too_Big				= 1 ,
	Snmp_No_Such_Name			= 2 ,
	Snmp_Bad_Value				= 3 ,
	Snmp_Read_Only				= 4 ,
	Snmp_Gen_Error				= 5 ,

	Snmp_No_Access				= 6 ,
	Snmp_Wrong_Type				= 7 ,
	Snmp_Wrong_Length			= 8 ,
	Snmp_Wrong_Encoding			= 9 ,
	Snmp_Wrong_Value			= 10 ,
	Snmp_No_Creation			= 11 ,
	Snmp_Inconsistent_Value		= 12 ,
	Snmp_Resource_Unavailable	= 13 ,
	Snmp_Commit_Failed			= 14 ,
	Snmp_Undo_Failed			= 15 ,
	Snmp_Authorization_Error	= 16 ,
	Snmp_Not_Writable			= 17 ,
	Snmp_Inconsistent_Name		= 18 ,

	Snmp_No_Response			= 19 ,
	Snmp_Local_Error			= 20 ,
	Snmp_General_Abort			= 21 
} ;


// Encapsulates the Error and Status values for an
// SNMP operation
// Provides Get and Set operations to set these values
// and check a 'void *' operator to check for error

class DllImportExport SnmpErrorReport
{
private:

	SnmpError error;
	SnmpStatus status;
	unsigned long int index ;

public:

	SnmpErrorReport () : error ( Snmp_Success ) , status ( Snmp_No_Error ) , index ( 0 ) {}

	SnmpErrorReport(IN const SnmpError error, IN const SnmpStatus status, IN const unsigned long int index = 0 )
		: error(error), status(status), index(index) 
	{}

	SnmpErrorReport(IN const SnmpErrorReport &error)
	{
		SnmpErrorReport::error = error.GetError();
		SnmpErrorReport::status = error.GetStatus();
		SnmpErrorReport::index = error.GetIndex () ;
	}

	virtual ~SnmpErrorReport() {}

	SnmpStatus GetStatus() const { return status; }
	SnmpError GetError() const { return error; }
	unsigned long int GetIndex () const { return index ; }

	void SetStatus(IN const SnmpStatus status)
	{
		SnmpErrorReport::status = status;
	}

	void SetError(IN const SnmpError error)
	{
		SnmpErrorReport::error = error;
	}

	void SetIndex ( IN const unsigned long int index ) 
	{
		SnmpErrorReport::index = index ;
	}

	void *operator()(void) const
	{
		return ((error == Snmp_Success)?(void *)this:NULL);
	}

	operator void *() const
	{
		return SnmpErrorReport::operator()();
	}
};



#endif // __ERROR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\excep.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: encap.hpp

Written By:	B.Rajeev

Purpose: The GeneralException is thrown on encountering situations
such as an errored call to the WinSNMP library and mutex/timer calls.
It encapsulates the SnmpErrorReport since that is the vehicle for exchange
of error information for SNMPCL objects 
-----------------------------------------------------------------*/

#ifndef __EXCEPTION__
#define __EXCEPTION__

#include "error.h"


// This exception is used to convey the error and status
// for exception error situations to the calling methods
class DllImportExport GeneralException: public SnmpErrorReport
{
private:

	int line ;
	char *file ;
	DWORD errorCode ;
	
public:
	GeneralException(IN const SnmpError error, IN const SnmpStatus status, char *fileArg = NULL , int lineArg = 0 , DWORD errorCodeArg = 0 )
		: SnmpErrorReport(error, status) , line ( lineArg ) , errorCode ( errorCodeArg ) 
	{
		file = fileArg ? _strdup ( fileArg ) : NULL ;
	}

	GeneralException(IN const SnmpErrorReport &error_report,char *fileArg = NULL , int lineArg = 0 , DWORD errorCodeArg = 0 )
		: SnmpErrorReport(error_report) , line ( lineArg ) , errorCode ( errorCodeArg ) 
	{
		file = fileArg ? _strdup ( fileArg ) : NULL ;
	}

	GeneralException(IN const GeneralException &exception )
		: SnmpErrorReport(exception)
	{
		line = exception.line ;
		errorCode = exception.errorCode ;
		file = exception.file ? _strdup ( exception.file ) : NULL ;
	}

	~GeneralException() { free ( file ) ; }

	int  GetLine () { return line ; }
	char *GetFile () { return file ; }

};


#endif // __EXCEPTION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\flow.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: address.hpp

Written By:	B.Rajeev

Purpose: Provides a flow control mechanism for the SnmpImpSession. 
-----------------------------------------------------------------*/

#ifndef __FLOW_CONTROL__
#define __FLOW_CONTROL__


#include "forward.h"
#include "common.h"

/*--------------------------------------------------
Overview:
--------

  MessageStore: Provides queue like access to a store of messages.
  In addition to the Enqueue, Dequeue primites, it also	enables
  deletion of specified messages from the queue.
				

  FlowControlMechanism: It encapsulates the flow control
  mechanism for the session. Once the window is full, incoming 
  messages are buffered. A reply triggers off further message 
  transmission until the window is full. If we give up on a 
  message after retrying a specified number of times, the flow
  control mechanism must be informed of it. It signals FlowControl
  On/Off (through callback methods), when the window limits are reached
--------------------------------------------------*/

// a CList is used to implement the message store
typedef CList<Message *, Message *> CListStore;

class MessageStore : private CListStore
{
#ifdef WANT_MFC
	DECLARE_DYNAMIC(MessageStore);
#endif
	
public:

    // Add to the end of the queue.
    void Enqueue( Message &new_message );

    // Remove and return the first element in the Store
    Message* Dequeue(void);

	// checks if the queue is empty
	BOOL IsEmpty(void)
	{
		return CListStore::IsEmpty();
	}

	// remove the message possessing the session_frame_id and return it
	Message *DeleteMessage(SessionFrameId session_frame_id);

	~MessageStore(void);
}; 

class FlowControlMechanism
{
	
	// the session providing the context for flow control
	SnmpImpSession *session;

	UINT outstanding_messages;

	// this value is specified by the session on creation
	UINT window_size;
	
	// provides queue like access to a store of messages
	MessageStore message_store;

	// obtains lock on the session CriticalSection before
	// calling TransmitMessage
	void TransmitMessageUnderProtection(Message *message);

	// creates a waiting message, registers it with the message
	// registry and lets it transmit
	void TransmitMessage(Message *message);

	// transmits messages in message store as long as
	// the window is open
	void ClearMessageStore(void);

public:

	// initializes the private variable
	FlowControlMechanism(SnmpImpSession &session, UINT window_size);


	// sends message if within the flow control window
	// else Stores it up
	void SendMessage(Message &message);

	// It removes the message frame from its message_Store
	void DeleteMessage(SessionFrameId session_frame_id);

	// this is called by a waiting_message indicating arrival
	// or by the message registry
	void NotifyReceipt(WaitingMessage &waiting_message, 
					   IN const SnmpPdu *snmp_pdu,
					   SnmpErrorReport &error_report);

	// this is called when the session does not need
	// to be informed, but the flow control window
	// must advance (such as frame cancellation)
	// also destroys the waiting_message
	void AdvanceWindow(WaitingMessage &waiting_message);
};


#endif // __FLOW_CONTROL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\forward.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: forward.hpp

Written By:	B.Rajeev

Purpose: Provides forward declarations for the types and classes of the
SNMP class library
-----------------------------------------------------------------*/

#ifndef __FORWARD__
#define __FORWARD__

// globally visible typedefs
typedef ULONG TransportFrameId;
typedef ULONG SessionFrameId;

typedef HANDLE Mutex;
typedef HANDLE Semaphore;

// forward declarations for the various classes

class MsgIdStore;
class Window;

class TransportSentStateStore;
class SnmpTransportAddress;
class SnmpTransportIpxAddress;
class SnmpTransportIpAddress;
class TransportSession;
class SnmpTransport;
class SnmpImpTransport;
class SnmpUdpIpTransport;
class SnmpUdpIpImp;
class SnmpIpxTransport;
class SnmpIpxImp;

class SnmpSession;
class SnmpImpSession;
class SnmpV1OverIp;
class SnmpV2COverIp;
class SnmpV1OverIpx;
class SnmpV2COverIpx;
class SnmpOperation;
class SnmpGetRequest;
class SnmpSetRequest;
class SnmpGetNextRequest;
class SnmpEncodeDecode ;
class SnmpV1EncodeDecode ;
class SnmpV2CEncodeDecode ;

class SnmpPdu;

class SecuritySession;
class SnmpSecurity;
class SnmpCommunityBasedSecurity;

class SnmpValue;
class SnmpNull;
class SnmpIpAddress;
class SnmpTimeTicks;
class SnmpGauge;
class SnmpOpaque;
class SnmpInteger;
class SnmpObjectIdentifier;
class SnmpOctetString;
class SnmpCounter;

class SnmpVarBind;
class SnmpVarBindList;

class OperationWindow ;
class SessionWindow;
class TransportWindow;
class OperationRegistry;
class SessionSentStateStore;
class IdMapping;
class SnmpPduBuffer;
class SessionWindow;
class Timer;
class MessageRegistry;
class FrameRegistry;
class EventHandler;
class FlowControlMechanism;
class Message;
class WaitingMessage;
class SnmpClassLibrary;
class FrameState;
class FrameStateRegistry;
class PseudoSession;
class OperationHelper;
class VBList;

class SnmpTrapManager;
class SnmpWinSnmpTrapSession;

// class ;

#endif // __FORWARD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\frame.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: frame.hpp
Author: B.Rajeev
Purpose: Provides declarations for the FrameRegistry class.
--------------------------------------------------*/


#ifndef __FRAME_REGISTRY__
#define __FRAME_REGISTRY__

#define ILLEGAL_SESSION_FRAME_ID 0

#include "forward.h"
#include "common.h"
#include "message.h"

typedef CMap<SessionFrameId, SessionFrameId, WaitingMessage *, WaitingMessage *> FrameMapping;

/*--------------------------------------------------
Overview:
---------

  FrameRegistry: Provides access to WaitingMessages in a store 
  through their SessionFrameId. 
  
	This enables cancellation of SendFrame request. The frame id
  is supplied by the calling SnmpOperation to the session.
  When the operation tries to cancel a SendFrame request,
  SnmpImpSession calls the CancelFrameNotification. This method
  informs the flow control mechanism of the event (which may 
  Deregister the waiting message erasing the 
  <SessionFrameId, WaitingMessage>association).
--------------------------------------------------*/

class FrameRegistry
{
	// it stores the waiting messages in the context of this session
	SnmpImpSession *session;  

	// used to generate session frame ids
	SessionFrameId next_session_frame_id;

	// stores pairs of the form <SessionFrameId, WaitingMessage *>
	FrameMapping mapping;

public:

	FrameRegistry(IN SnmpImpSession &session)
	{
		FrameRegistry::session = &session;
		next_session_frame_id = ILLEGAL_SESSION_FRAME_ID+1;
	}

	SessionFrameId GenerateSessionFrameId(void);

	void RegisterFrame(IN const SessionFrameId session_frame_id, IN WaitingMessage &waiting_message);

	void DeregisterFrame(IN const SessionFrameId session_frame_id);
	
	// returns NULL if no such waiting message
	WaitingMessage *GetWaitingMessage(IN const SessionFrameId session_frame_id);

	void CancelFrameNotification(IN const SessionFrameId session_frame_id);

	~FrameRegistry(void);
};


#endif // __FRAME_REGISTRY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\fs_reg.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------------
Filename: fs_reg.hpp
Author: B.Rajeev
Purpose: Provides declarations for the FrameState and the
		 FrameStateRegistry classes. 
--------------------------------------------------------*/


#ifndef __FRAME_STATE_REGISTRY
#define __FRAME_STATE_REGISTRY

#include "forward.h"
#include "common.h"
#include "vbl.h"

// The FrameState stores the state information pertaining to a Session Frame
// They may be reused, if the frame is retransmitted with modifications.
class FrameState
{
	// the session frame id may be used to cancel the frame or associate
	// a reply with the varbinds sent in the frame
	SessionFrameId session_frame_id;

	// This is a (winsnmp vbl, SnmpVarBindList) pair representing
	// the list of var binds sent in the session frame
	VBList *vblist;

public:

	FrameState(IN SessionFrameId session_frame_id, IN VBList &vblist);

	SessionFrameId GetSessionFrameId(void) { return session_frame_id; }

	// since, frames may be retransmitted (after updating the var bind list)
	// they may be reused, with a different session frame id
	void SetSessionFrameId(IN SessionFrameId session_frame_id)
	{
		FrameState::session_frame_id = session_frame_id;
	}

	VBList *GetVBList(void) { return vblist; }
	
	~FrameState(void);
};


typedef CMap< SessionFrameId, SessionFrameId &, FrameState *, FrameState *& > FrameStateMapping;


// The FrameStateRegistry stores the FrameStates for all outstanding
// session frames. It stores <session_frame_id, FrameState> pairs allowing insertion,
// removal and a destructive traversal.
// It is used to detect completion of an operation (when it becomes empty),
// to cancel all outstanding frames and access to individual frame states

class FrameStateRegistry
{
	// determines the security context for a SendRequest and applies
	// to all the frames (including rexns) carrying varbinds from the
	// specified SnmpVarBindList
	SnmpSecurity *security;

	// stores the FrameStates
	FrameStateMapping mapping;

	// points to the currrent position, enabling a traversal
	POSITION current_pointer;

public:

	FrameStateRegistry()
	{
		security = NULL;
		current_pointer = mapping.GetStartPosition();
	}

	~FrameStateRegistry();

	void Insert(IN SessionFrameId session_frame_id, IN FrameState &frame_state)
	{
		mapping[session_frame_id] = &frame_state;
	}

	FrameState *Remove(IN SessionFrameId session_frame_id);

	// doesn't remove the <session_frame_id, FrameState> association
	FrameState *Get(IN SessionFrameId session_frame_id);

	void ResetIterator(void)
	{
		current_pointer = mapping.GetStartPosition();
	}

	FrameState *GetNext(OUT SessionFrameId *session_frame_id = NULL);

	void RemoveAll(void)
	{
		mapping.RemoveAll();
	}

	BOOL Empty(void)
	{
		return mapping.IsEmpty();
	}

	BOOL End(void)
	{
		return ( (current_pointer==NULL)?TRUE:FALSE );
	}

	// we reuse the frame state registry over several operations
	// this method enables change in the security context
	void RegisterSecurity(IN SnmpSecurity *security);

	SnmpSecurity *GetSecurity() const;

	// destroys an existing security context 
	void DestroySecurity();
};


#endif // __FRAME_STATE_REGISTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\idmap.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: idmap.hpp
Author: B.Rajeev
Purpose: Provides declarations for the IdMapping class.
--------------------------------------------------*/

#ifndef __ID_MAPPING__
#define __ID_MAPPING__

#include "forward.h"
#include "common.h"

#define ILLEGAL_TRANSPORT_FRAME_ID 0

typedef CMap<TransportFrameId, TransportFrameId &, SessionFrameId, SessionFrameId &> ForwardStore;
typedef CMap<SessionFrameId, SessionFrameId &, TransportFrameId, TransportFrameId &> BackwardStore;

// When a session frame is passed to the transport for transmission, the
// transport assigns a TransportFrameId to the frame.
// The IdMapping class provides a mapping between the SessionFrameIds and 
// TransportFrameIds
// NOTE: At any time, several transport frame ids may be associated with a
// session frame id, but the session frame id is only associated with the
// last registered transport frame id. DissociateSessionFrameId is called,
// the session frame id association is lost, however, other transport frame 
// ids remain associated with the session frame id
// If this is not desired in the future, a list of associated transport frame
// ids must be maintained for each session frame id 

class IdMapping
{
	// We need access by both the SessionFrameId and the TransportFrameId.
	// To avoid a CMap traversal, two CMaps are used to store the 
	// FrameIds, indexed by the TransportFrameId and the 
	// SessionFrameId respectively.
	ForwardStore forward_store;
	BackwardStore backward_store;

public:

	void Associate(IN TransportFrameId transport_frame_id,
				   IN SessionFrameId session_frame_id);

	SessionFrameId DisassociateTransportFrameId(IN TransportFrameId transport_frame_id);

	TransportFrameId DisassociateSessionFrameId(IN SessionFrameId session_frame_id);

	BOOL CheckIfAssociated(IN SessionFrameId session_frame_id);

	~IdMapping(void);
};

#endif // __ID_MAPPING__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\message.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: message.hpp
Author: B.Rajeev
Purpose: Provides declarations for the Message and
		 WaitingMessage classes.
--------------------------------------------------*/


#ifndef __MESSAGE__
#define __MESSAGE__

#include "forward.h"
#include "common.h"
#include "error.h"
#include "reg.h"
#include "timer.h"


/*--------------------------------------------------
Overview: 

  Message: Stores the parameters passed to the session with 
  a call to the SendFrame method. A message may either be
  transmitted immediately or enqueued in the FlowControlMechanism 
  queue for future transmission. After transmission, the message
  becomes a part of a WaitingMessage.

  WaitingMessage: Encapsulates the state maintained for each outstanding 
  reply. This includes its timer_event_id, retransmission 
  information (Message ptr) etc.

  Note - A Message/WaitingMessage may be cancelled at any time
--------------------------------------------------*/

class Message
{
	SessionFrameId session_frame_id;
	SnmpPdu *snmp_pdu;
	SnmpOperation &operation;

public:

	Message(IN const SessionFrameId session_frame_id, 
			IN SnmpPdu &snmp_pdu,
			IN SnmpOperation &snmp_operation);

	SessionFrameId GetSessionFrameId(void) const;

	SnmpOperation &GetOperation(void) const;

	void SetSnmpPdu(IN SnmpPdu &snmp_pdu);

	SnmpPdu &GetSnmpPdu(void) const;

	~Message(void);
};


// instances store the list of request ids used for a waiting message
typedef CList<RequestId, RequestId> RequestIdList;

// encapsulates state for a message that is transmitted and
// subsequently waits for a reply. It uses the timer to rexmt
// the message and if the reply isn't forthcoming, informs the
// flow control mechanism that no reply has been received. When
// a reply is received it informs the fc mech. of the event
// Each transmission of the waiting message uses a different request id

class WaitingMessage
{
	// it operates in the session's context
	SnmpImpSession *session;
	Message *message;
	SnmpPdu *reply_snmp_pdu;
	TransportFrameId last_transport_frame_id;
	TimerEventId m_TimerEventId ;

	// stores the list of request ids used for the waiting message
	// (inclusive of the original transmission)
	RequestIdList request_id_list;

	UINT max_rexns;
	UINT rexns_left;
	UINT strobes;

	BOOL sent_message_processed;
	BOOL active;

	// deregisters the waiting message from the message registry
	// for each request id stored in the RequestIdList
	void DeregisterRequestIds();

public:

	// initializes the private variables. in future, 
	// max_rexns and timeout_period might be obtained this way 
	// rather than from the session
	WaitingMessage(IN SnmpImpSession &session, IN Message &message);

	// returns the private message
	Message *GetMessage(void)
	{
		return message;
	}

	TimerEventId GetTimerEventId () ;

	void SetTimerEventId ( TimerEventId a_TimerEventId ) ;

	// sends the message. involves request_id generation,
	// registering with the message_registry, decoding the
	// message, updating the pdu and registering a timer event
	void Transmit();

	// used by the timer to notify the waiting message of
	// a timer event. if need, the message is retransmitted.
	// when all rexns are exhausted, ReceiveReply is called
	void TimerNotification(void);

	// A call to this function signifies that state corresponding to the
	// waiting_message need not be kept any further
	// it notifies the flow control mechanism of the termination
	// which destroys the waiting_message
	void ReceiveReply(IN const SnmpPdu *snmp_pdu, 
					  IN SnmpErrorReport &snmp_error_report = SnmpErrorReport(Snmp_Success, Snmp_No_Error));

	// The WinSnmp implementation, posts an event when a message is received,
	// however, when a call is made to the library to receive a message,
	// it hands them out in no specific order. Therefore, responses may
	// be received before their corresponding SENT_FRAME event is processed.
	// The following methods are concerned with buffering and
	// retrieving such snmp pdus.

	// buffers the snmp pdu received as a reply
	void BufferReply(IN const SnmpPdu &reply_snmp_pdu);

	// returns TRUE if a reply has been buffered
	BOOL ReplyBuffered();

	// returns a ptr to the buffered reply pdu, if buffered
	// otherwise a null ptr is returned
	// IMPORTANT: it sets the reply_snmp_pdu to NULL, so that it may 
	// not be deleted when the waiting message is destroyed
	SnmpPdu *GetBufferedReply();

	// informs the waiting message that a sent message has been
	// processed 
	void SetSentMessageProcessed();

	// if a sent message has been processed, it returns TRUE, else FALSE
	BOOL GetSentMessageProcessed();

	// an exit fn - prepares an error report and calls
	// ReceiveReply to signal a non-receipt
	void WrapUp( IN SnmpErrorReport &error_report =
					SnmpErrorReport(Snmp_Error, Snmp_Local_Error) );

	void SelfDestruct(void);

	// if required, it cancels registration with the message_registry and
	// the timer event with the timer, deletes message ptr
	~WaitingMessage(void);
};


#endif // __MESSAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\op.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: op.hpp   (operation.hpp)
Author: B.Rajeev
Purpose: Provides declarations for the SnmpOperation base
		 class and the classes derived from it -
		 SnmpGetOperation, SnmpGetNextOperation, SnmpSetOperation.
--------------------------------------------------*/

#ifndef __OPERATION__
#define __OPERATION__

#include "forward.h"
#include "error.h"
#include "encdec.h"

#define SEND_ERROR_EVENT (WM_USER+4)
#define OPERATION_COMPLETED_EVENT (WM_USER+5)

/*--------------------------------------------------
Overview: The SnmpOperation class defines protocol operations 
within the SNMP class library, the user of the class library is 
not expected to interact directly with SNMP frames exposed within 
the SnmpSession interface i.e. the user of the class library need 
not call into any SnmpSession method or derive from the 
SnmpSession class other than to receive flow control information, 
unless of course this is a requirement. The SnmpOperation defines 
the type of protocol request to send, the variable binding 
information requested and the frame encoding operation used to 
generate the required SNMP protocol data units.
--------------------------------------------------*/
  
// This is the base class for the Get, GetNext and Set operations.
// A few notables are -
// 1. It makes the callbacks to an operation user (ReceiveResponse etc.), 
// asynchronous with respect to the user's call to SendRequest.
// 2. The base class implementation registers and deregisters itself with
// the session in the constructor and the destructor respectively
// 3. a class deriving from the SnmpOperation method that provides
// alternate definitions for the "non-pure" virtual methods must
// also call the virtual method 
class DllImportExport SnmpOperation
{
	friend class OperationWindow;

	// only purpose of the OperationHelper is to separate certain winsnmp 
	// typedefs in the parameter list of a few methods from the 
	// SnmpOperation header file
	friend class OperationHelper;

private:

	// each public method checks for this flag before exiting. if the
	// flag is set, the operation must delete itself. only method that
	// sets it on is the protected DestroyOperation
	BOOL delete_operation;

	// its mandatory for every public method to call this method
	// before returning to the caller
	// it checks if the call sequence included a call to DestroyOperation
	// and if so, deletes "this" before returning
	void CheckOperationDeletion();

	// "=" operator has been
	// made private so that a copy may not be made
	SnmpOperation & operator= ( IN const SnmpOperation &snmp_operation )
	{
		return *this;
	}
	
	// sends a Frame with the VBList specifying the list of varbinds
	// in winsnmp vbl and SnmpVarBindList
	void SendFrame(VBList &list_segment);

	// sends the specified var bind list in snmp pdus each carrying
	// atmost max_size var binds
	void SendVarBindList(

		SnmpVarBindList &var_bind_list,
		UINT max_size = UINT_MAX,
		ULONG var_index = 0 
	);

	// makes the ReceiveErroredResponse callback for each varbind in
	// the errored_list
	void ReceiveErroredResponse(

		ULONG var_index ,
		SnmpVarBindList &errored_list,
		const SnmpErrorReport &error_report
	);

	// processes internal events such as error during sending
	// a frame or completion of an operation
	LONG ProcessInternalEvent(

		HWND hWnd, 
		UINT user_msg_id,
		WPARAM wParam, 
		LPARAM lParam
	);

	// both the public SendRequest methods call this for sending the varbindlist
	void SendRequest(

		IN SnmpVarBindList &varBindList,
		IN SnmpSecurity *security
	);

protected:

	SnmpSession &session;

	// used for hiding winsnmp manipulations and window messaging
	OperationWindow m_OperationWindow;

	// References to the following instances are used instead of 
	// embedded instances themselves. This is done to avoid including
	// the header files providing their declaration

	// unrecoverable errors during initialization or processing	(not yet)
	// set this field to FALSE
	BOOL is_valid;

	// only one operation may be in progress at a time
	BOOL in_progress;

	// only one thread is permitted to execute SnmpOperation methods
	CriticalSection exclusive_CriticalSection;

	// keeps all the FrameStates (for all outstanding Frames)
	FrameStateRegistry frame_state_registry;

	// hides winsnmp typedefs from this file
	OperationHelper helper;

	// atmost these many varbinds may be transmitted in any snmp pdu
	UINT varbinds_per_pdu;

	SnmpOperation(SnmpSession &snmp_session);

	// each time a pdu is prepared, it obtains the pdu type from the
	// derived class
	virtual SnmpEncodeDecode :: PduType GetPduType(void) = 0;

	virtual void ReceiveResponse();

	virtual void ReceiveVarBindResponse(

		IN const ULONG &varBindIndex ,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) {}

	virtual void ReceiveErroredVarBindResponse(

		IN const ULONG &varBindIndex ,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) {}

	virtual void FrameTooBig() {}

	virtual void FrameOverRun() {}

	// this method may be called to delete the Operation
	// note: the operation is deleted when a public method
	// returns. For this reason, if a public method calls another 
	// public method, it must not access any per-class variables
	// after that.
	void DestroyOperation();

public:

	virtual ~SnmpOperation() ;

	// packages the var binds in the var bind list into a series of
	// snmp pdus, each with at most varbinds_per_pdu var binds and
	// hands them to the session for transmission
	virtual void SendRequest(IN SnmpVarBindList &varBindList);

	// sends the frames with an additionally specified security context
	// (uses the session SendFrame with a security parameter
	virtual void SendRequest(
	
		IN SnmpVarBindList &varBindList,
		IN SnmpSecurity &security
	);

	// cancels all the session frames for which frame states exist in the
	// frame state registry (all outstanding frames)
	void CancelRequest();

	// called by the session or the SnmpOperation SendFrame method
	// to signal a valid reply, or an errored response (error in sending
	// timeout)
	void ReceiveFrame(

		IN const SessionFrameId session_frame_id,
		IN const SnmpPdu &snmpPdu,
		IN const SnmpErrorReport &errorReport
	);

	// called by the session to signal a frame transmission (successful
	// or otherwise) or a timeout situation. since a frame may be
	// retransmitted, in the absence of a response, more than one
	// SendFrame callback may be issued for the same session_frame_id.
	// however, atmost one errored SentFrame call may be made for each
	// frame/session_frame_id
	virtual void SentFrame (

		IN const SessionFrameId session_frame_id,
		IN const SnmpErrorReport &error_report
	);

	// used to check if the operation is valid
	void *operator()(void) const
	{
		return ( (is_valid)?(void *)this:NULL );
	}

	operator void *() const
	{
		return SnmpOperation::operator()();
	}

	static UINT g_SendErrorEvent ;
	static UINT g_OperationCompleteEvent ;
};


class DllImportExport SnmpGetOperation: public SnmpOperation
{
protected:

	SnmpEncodeDecode :: PduType GetPduType(void);

public:

	SnmpGetOperation(SnmpSession &snmp_session) : SnmpOperation(snmp_session)
	{}
};


class DllImportExport SnmpGetNextOperation: public SnmpOperation
{

protected:

	SnmpEncodeDecode :: PduType GetPduType(void);

public:

	SnmpGetNextOperation(IN SnmpSession &snmp_session) : SnmpOperation(snmp_session)
	{}
};



class DllImportExport SnmpSetOperation: public SnmpOperation
{
protected:

	SnmpEncodeDecode :: PduType GetPduType(void);

public:

	SnmpSetOperation(SnmpSession &snmp_session) : SnmpOperation(snmp_session)
	{}
};


#endif // __OPERATION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\opreg.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: opreg.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the OperationRegistry class
--------------------------------------------------*/

#ifndef __OPERATION_REGISTRY__
#define __OPERATION_REGISTRY__


#include "common.h"
#include "forward.h"

// stores the registered SnmpOperation instances and keeps a count of them
class OperationRegistry
{
	
	typedef CMap<SnmpOperation *, SnmpOperation *, void *, void *> Store;

	Store store;

	UINT num_registered;

public:

	OperationRegistry();

	void Register(IN SnmpOperation &operation);

	void Deregister(IN SnmpOperation &operation);

	UINT GetNumRegistered()
	{
		return num_registered;
	}

	~OperationRegistry();
};


#endif // __OPERATION_REGISTRY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\ophelp.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: ophelp.hpp
Author: B.Rajeev
Purpose: Provides declarations for the OperationHelper class
--------------------------------------------------*/

#ifndef __OPERATION_HELPER__
#define __OPERATION_HELPER__

#include "forward.h"

// The only purpose of this class is to hide the winsnmp
// typedefs in its method parameters from the file providing 
// operation class declaration

class OperationHelper
{
	SnmpOperation &operation;

public:

	OperationHelper(IN SnmpOperation &operation)
		: operation(operation)
	{}

	// calls the session to transmit the frame
	void TransmitFrame (

		OUT SessionFrameId &session_frame_id, 
		VBList &vbl
	);

	void ReceiveResponse (

		ULONG var_index,
		SnmpVarBindList &sent_var_bind_list,
		SnmpVarBindList &received_var_bind_list,
		SnmpErrorReport &error_report
	);

	// processes the response (successful or otherwise) for the specified
	// frame. the frame may be retransmitted in case of a reply bearing
	// an errored index
	void ProcessResponse (

		FrameState *frame_state,
		SnmpVarBindList &a_SnmpVarBindList ,
		SnmpErrorReport &error_report
	);

	//static functions which turn WINSNMP objects into SNMPCL objects.
	//these helper functions are static so that they may be used elsewhere.
	static SnmpVarBind *GetVarBind(

		IN smiOID &instance, 
		IN smiVALUE &value
	);

	static SnmpTransportAddress *GetTransportAddress(

		IN HSNMP_ENTITY &haddr
	);

	static SnmpSecurity *GetSecurityContext(

		IN HSNMP_CONTEXT &hctxt
	);
};


#endif // __OPERATION_HELPER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\pch.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\pdu.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: pdu.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the SnmpPdu class
--------------------------------------------------*/

#ifndef __SNMP_PDU__
#define __SNMP_PDU__

// encapsulates an Snmp Pdu. it is represented as an unsigned 
// character string (non-null terminated) and its length

class DllImportExport SnmpPdu
{
	// a pdu is invalid until the string and its length are specified
	// in the constructor or through SetPdu
	BOOL is_valid;
	UCHAR *ptr;
	ULONG length;

	RequestId m_RequestId ;
	SnmpEncodeDecode :: PduType m_PduType ;
	SnmpErrorReport m_ErrorReport ;
	SnmpVarBindList *m_SnmpVarBindList ;
	SnmpTransportAddress *m_SourceAddress ;
	SnmpTransportAddress *m_DestinationAddress ;
	SnmpCommunityBasedSecurity *m_SnmpCommunityName ;
	
	void Initialize(IN const UCHAR *frame, 
					IN const ULONG &frameLength);

	void FreeFrame(void);

	void FreePdu () ;

public:

	SnmpPdu();
	SnmpPdu(IN SnmpPdu &snmpPdu);
	SnmpPdu(IN const UCHAR *frame, IN const ULONG &frameLength);

	virtual ~SnmpPdu(void) ;

	ULONG GetFrameLength() const;

	UCHAR *GetFrame() const;

	void SetPdu(IN const UCHAR *frame, IN const ULONG frameLength);
	void SetPdu(IN SnmpPdu &a_SnmpPdu ) ;

	virtual BOOL SetVarBindList (

		OUT SnmpVarBindList &a_SnmpVarBindList

	) ;

	virtual BOOL SetCommunityName ( 

		IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 
	
	) ;

	virtual BOOL SetErrorReport (

		OUT SnmpErrorReport &a_SnmpErrorReport

	) ;

	virtual BOOL SetPduType (

		OUT SnmpEncodeDecode :: PduType a_PduType

	) ;

	virtual BOOL SetSourceAddress ( 

		IN SnmpTransportAddress &a_TransportAddress 

	) ;

	virtual BOOL SetDestinationAddress ( 

		IN SnmpTransportAddress &a_TransportAddress 

	) ;

	virtual BOOL SetRequestId (

		IN RequestId request_id

	) ;

	virtual SnmpEncodeDecode :: PduType & GetPduType () ;

	virtual RequestId & GetRequestId () ;

	virtual SnmpErrorReport &GetErrorReport () ;

	virtual SnmpCommunityBasedSecurity &GetCommunityName () ;

	virtual SnmpVarBindList &GetVarbindList () ;

	virtual SnmpTransportAddress &GetSourceAddress () ;

	virtual SnmpTransportAddress &GetDestinationAddress () ;

	void *operator()(void) const
	{
		return ( (is_valid)? (void *)this: NULL );
	}

	operator void *() const
	{
		return SnmpPdu::operator()();
	}
};


#endif // __SNMP_PDU__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\reg.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: reg.hpp
Author: B.Rajeev
Purpose: Provides declarations for the MessageRegistry class
--------------------------------------------------*/



#ifndef __REG__
#define __REG__

#include "common.h"
#include "encdec.h"
#include "message.h"

/*--------------------------------------------------
Overview:
--------

  MessageRegistry: It maintains a mapping 
  <request_id, waiting_message *>. Before transmission, a waiting 
  message registers itself with the registry. 
  When the session notifies the registry of a message
  arrival event, the registry notifies the waiting message of the event
--------------------------------------------------*/

typedef CMap< RequestId, RequestId, WaitingMessage *, WaitingMessage * > RequestMap;

class MessageRegistry
{
	// the v1 session: for obtaining session information,
	// event handler
	SnmpImpSession *session;

	// map for (event_id, waiting_message) association and
	// unique request_id generation
	static RequestId next_request_id;
	RequestMap mapping;

public:

	MessageRegistry(IN SnmpImpSession &session)
	{
		MessageRegistry::session = &session;
	}

	// generates and returns a new request id. It also 
	// associates the waiting message with the request id
	RequestId GenerateRequestId(IN WaitingMessage &waiting_message);

	// used by the session to notify the message registry
	// of a message receipt (when it is received from the Transport)
	// it must notify the concerned waiting message of the event
	void MessageArrivalNotification(IN SnmpPdu &snmp_pdu);

	// delete (request_id, waiting_message) pair
	void RemoveMessage(IN RequestId request_id);

	~MessageRegistry(void);
};

#endif // __REG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\pseudo.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-------------------------------------------------------
filename: pseudo.hpp
author: B.Rajeev
purpose: Provides declarations for the class OperationSession.
-------------------------------------------------------*/


#ifndef __PSEUDO_SESSION__
#define __PSEUDO_SESSION__ 

#include "forward.h"
#include "wsess.h"

// Its windows messaging services
// are used by the operation for internal events

class OperationWindow : public Window
{
private:

	// hands the window message events to the owner for processing
	SnmpOperation &owner;

	// over-rides the callback from WinSnmpSession for window message events
	LONG_PTR HandleEvent (

		HWND hWnd, 
		UINT user_msg_id, 
		WPARAM wParam, 
		LPARAM lParam
	);

public:

	OperationWindow (

		IN SnmpOperation &owner
	);

	~OperationWindow ();
};

#endif // __PSEUDO_SESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\snmpcl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __SINGLE_HEADER__
#define __SINGLE_HEADER__

#define DllImport	__declspec( dllimport )
#define DllExport	__declspec( dllexport )

#ifdef SNMPCLINIT
#define DllImportExport DllExport
#else
#define DllImportExport DllImport
#endif

#include <limits.h>
#include "sync.h"
#include "startup.h"
#include "address.h"
#include "error.h"
#include "encdec.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "trap.h"

#include "tsent.h"

#include "transp.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "pseudo.h"
#include "fs_reg.h"
#include "ophelp.h"
#include "op.h"
#include "value.h"

#endif // __SINGLE_HEADER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\sec.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: sec.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the SnmpSecurity class
--------------------------------------------------*/

#ifndef __SECURITY__
#define __SECURITY__

#include "forward.h"
#include "error.h"

#define SnmpV1Security SnmpCommunityBasedSecurity

// provides the security context under which snmp pdus are transmitted
class DllImportExport SnmpSecurity
{
private:

	// the "=" operator and the copy constructor have been made
	// private to prevent copies of the SnmpSecurity instance from
	// being made
	SnmpSecurity &operator=(IN const SnmpSecurity &security)
	{
		return *this;
	}

	SnmpSecurity(IN const SnmpSecurity &snmp_security) {}

protected:

	SnmpSecurity() {}

public:

	virtual ~SnmpSecurity(){}

	virtual SnmpErrorReport Secure (

		IN SnmpEncodeDecode &snmpEncodeDecode,
		IN OUT SnmpPdu &snmpPdu

	) = 0;

	virtual SnmpSecurity *Copy() const = 0;

	virtual void * operator()(void) const = 0;

	virtual operator void *() const = 0;
};


class DllImportExport SnmpCommunityBasedSecurity: public SnmpSecurity
{
protected:

	char *community_name;

	BOOL is_valid;

	void Initialize();

public:

	SnmpCommunityBasedSecurity ( IN const SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity ) ;
	SnmpCommunityBasedSecurity ( IN const char *a_CommunityName = "public" ) ;
	SnmpCommunityBasedSecurity ( IN const SnmpOctetString &a_OctetString ) ;

	~SnmpCommunityBasedSecurity () ;

	SnmpErrorReport Secure (
	
		IN SnmpEncodeDecode &snmpEncodeDecode,
		IN OUT SnmpPdu &snmpPdu

	) ;

	SnmpSecurity *Copy() const;

	SnmpCommunityBasedSecurity &operator=(IN const SnmpCommunityBasedSecurity &to_copy) ;

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	operator void *() const
	{
		return SnmpCommunityBasedSecurity::operator()();
	}

	void SetCommunityName ( IN const SnmpOctetString &a_OctetString ) ;
	void SetCommunityName ( IN const char *a_CommunityName ) ;

	void GetCommunityName ( SnmpOctetString &a_SnmpOctetString ) const ;
	const char *GetCommunityName() const;
};

#endif // __SECURITY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\snmpauto.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if _MSC_VER >= 1100
template<> DllImportExport UINT AFXAPI HashKey <SnmpObjectIdentifierType&> (SnmpObjectIdentifierType &key) ;
#else
DllImportExport UINT HashKey (SnmpObjectIdentifierType &key) ;
#endif

#if _MSC_VER >= 1100
template<> DllImportExport BOOL AFXAPI CompareElements <SnmpObjectIdentifierType , SnmpObjectIdentifierType >( 

	 const SnmpObjectIdentifierType* pElement1, 
	 const SnmpObjectIdentifierType* pElement2 
) ;
#else
DllImportExport BOOL CompareElements ( 

	 SnmpObjectIdentifierType* pElement1, 
	 SnmpObjectIdentifierType* pElement2 
) ;
#endif

class VarBindObject 
{
private:

	SnmpObjectIdentifier reply ;
	SnmpValue *value ;

protected:
public:

	VarBindObject ( const SnmpObjectIdentifier &replyArg , const SnmpValue &valueArg ) ;
	virtual ~VarBindObject () ;

	SnmpObjectIdentifier &GetObjectIdentifier () ;
	SnmpValue &GetValue () ;
} ;

class VarBindQueue 
{
private:

	CList <VarBindObject *, VarBindObject *&> queue ;

protected:
public:

	VarBindQueue () ;
	virtual ~VarBindQueue () ;

	void Add ( VarBindObject *varBindObject ) ;
	VarBindObject *Get () ;
	VarBindObject *Delete () ;
} ;

class VarBindObjectRequest 
{
private:

	BOOL repeatRequest ;
	VarBindQueue varBindResponseQueue ;
	SnmpObjectIdentifierType varBind ;
	SnmpObjectIdentifierType requested ;

protected:
public:

	VarBindObjectRequest ( const SnmpObjectIdentifierType &varBindArg ) ;
	VarBindObjectRequest ( 

		const SnmpObjectIdentifierType &varBindArg ,
		const SnmpObjectIdentifierType &requestedVarBindArg 
	) ;

	VarBindObjectRequest () ;
	virtual ~VarBindObjectRequest () ;

	const SnmpObjectIdentifierType &GetRequested () const ;
	const SnmpObjectIdentifierType &GetVarBind () const ;
	
	void AddQueuedObject ( VarBindObject *object ) ;
	VarBindObject *GetQueuedObject () ;
	VarBindObject *DeleteQueueudObject () ;

	void SetRequested ( const SnmpObjectIdentifierType &requestedArg ) ;
	void SetVarBind ( const SnmpObjectIdentifierType &varBindArg ) ;

	BOOL GetRepeatRequest () { return repeatRequest ; }
	void SetRepeatRequest ( BOOL repeatRequestArg = TRUE ) { repeatRequest = repeatRequestArg ; }
} ;


class GetNextOperation ;
class DllImportExport SnmpAutoRetrieveOperation 
{
friend GetNextOperation ;
private:

	BOOL status ;
	GetNextOperation *operation ;

protected:

	SnmpAutoRetrieveOperation (SnmpSession &snmp_session);

	virtual void ReceiveResponse() {} ;

	virtual void ReceiveRowResponse () {} ;

	virtual void ReceiveRowVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error) {}

	virtual void ReceiveVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error) {}

	virtual void ReceiveErroredVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error) {}

	virtual LONG EvaluateNextRequest (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN SnmpVarBind &sendVarBind

	) { return 0 ; }

	virtual void FrameTooBig() {}

	virtual void FrameOverRun() {}

	void DestroyOperation () ;

public:


	virtual ~SnmpAutoRetrieveOperation() ;

	virtual void SendRequest (

		IN SnmpVarBindList &scopeVarBindList , 
		IN SnmpVarBindList &varBindList 
	);

	virtual void SendRequest (

		IN SnmpVarBindList &varBindList 
	);

	void CancelRequest();

	void ReceiveFrame(IN const SessionFrameId session_frame_id,
					  IN const SnmpPdu &snmpPdu,
					  IN const SnmpErrorReport &errorReport) {} ;

	virtual void SentFrame(IN const SessionFrameId session_frame_id,
						   IN const SnmpErrorReport &error_report) {} ;

	void *operator()(void) const ;

} ;



class DllImportExport GetNextOperation : public SnmpGetNextOperation
{
private:

	ULONG m_RequestContainerLength ;
	VarBindObjectRequest **m_RequestContainer ;
	ULONG *m_RequestIndexContainer ;

	BOOL cancelledRequest ;
	SnmpObjectIdentifier minimumInstance ;
	SnmpAutoRetrieveOperation *operation ;

	void Cleanup () ;
	BOOL ProcessRow () ;
	void Send () ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(	

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	void FrameTooBig() ;

	void FrameOverRun() ;

	void SentFrame(

		IN const SessionFrameId session_frame_id,
		IN const SnmpErrorReport &error_report
	);

public:

	GetNextOperation (IN SnmpSession &session, SnmpAutoRetrieveOperation &autoRetrieveOperation ) ;
	~GetNextOperation () ;

	void SendRequest ( 

		SnmpVarBindList &varBindList , 
		SnmpVarBindList &startVarBindList 
	) ;

	void SendRequest ( SnmpVarBindList &varBindList ) ;
	void CancelRequest () ;

	void DestroyOperation () ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\snmpcont.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __SNMPCONT_H
#define __SNMPCONT_H

#include <provexpt.h>
#include <ScopeGuard.h>

template<class TYPE, class ARG_TYPE>
class SnmpList 
{
private:

	CCriticalSection * criticalSection ;
	CList <TYPE, ARG_TYPE> clist ;

protected:
public:

	SnmpList ( BOOL threadSafeArg = FALSE ) ;
	virtual ~SnmpList () ;

	int GetCount() const;
	BOOL IsEmpty() const;

	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

	TYPE RemoveHead();
	TYPE RemoveTail();

	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	void AddHead(SnmpList<TYPE,ARG_TYPE>* pNewList);
	void AddTail(SnmpList<TYPE,ARG_TYPE>* pNewList);

	void RemoveAll();

	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); 
	TYPE GetNext(POSITION& rPosition) const; 
	TYPE& GetPrev(POSITION& rPosition); 
	TYPE GetPrev(POSITION& rPosition) const; 

	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
	POSITION FindIndex(int nIndex) const;
} ;

template<class TYPE, class ARG_TYPE>
SnmpList <TYPE,ARG_TYPE>:: SnmpList ( BOOL threadSafeArg ) : criticalSection ( NULL )
{
	if ( threadSafeArg )	
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
SnmpList <TYPE,ARG_TYPE> :: ~SnmpList () 
{
	if ( criticalSection ) 
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
int SnmpList <TYPE,ARG_TYPE> :: GetCount() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		int count = clist.GetCount () ;
		return count ;
	}
	else
	{
		return clist.GetCount () ;
	}
}

template<class TYPE, class ARG_TYPE>
BOOL SnmpList <TYPE,ARG_TYPE> :: IsEmpty() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		BOOL isEmpty = clist.IsEmpty () ;
		return isEmpty ;
	}
	else
	{
		return clist.IsEmpty () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE &SnmpList <TYPE,ARG_TYPE> :: GetHead () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE &head = clist.GetHead () ;
		return head;
	}
	else
	{
		return clist.GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: GetHead () const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE head = clist.GetHead () ;
		return head ;
	}
	else
	{
		return clist.GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE &SnmpList <TYPE,ARG_TYPE> :: GetTail()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE &tail = clist.GetTail () ;
		return tail ;
	}
	else
	{
		return clist.GetTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: GetTail() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE tail = clist.GetTail () ;
		return tail ;
	}
	else
	{
		return clist.GetTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: RemoveHead()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE head = clist.RemoveHead () ;
		return head ;
	}
	else
	{
		return clist.RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: RemoveTail()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE tail = clist.RemoveTail () ;
		return tail ;
	}
	else
	{
		return clist.RemoveTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: AddHead(ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		POSITION position = clist.AddHead ( newElement ) ;
		return position ;
	}
	else
	{
		return clist.AddHead ( newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: AddTail(ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		POSITION position = clist.AddTail ( newElement ) ;
		return position ;
	}
	else
	{
		return clist.AddTail ( newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpList <TYPE,ARG_TYPE> :: AddHead(SnmpList<TYPE,ARG_TYPE> *pNewList)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		clist.AddHead ( pNewList->clist ) ;
	}
	else
	{
		clist.AddHead ( pNewList->clist ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpList <TYPE,ARG_TYPE> :: AddTail(SnmpList<TYPE,ARG_TYPE> *pNewList)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		clist.AddTail ( pNewList->clist ) ;
	}
	else
	{
		clist.AddTail ( pNewList->clist ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpList <TYPE,ARG_TYPE> :: RemoveAll ()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		clist.RemoveAll () ;
	}
	else
	{
		clist.RemoveAll () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: GetHeadPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		POSITION position = clist.GetHeadPosition () ;
		return position ;
	}
	else
	{
		return clist.GetHeadPosition () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: GetTailPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		POSITION position = clist.GetTailPosition () ;
		return position ;
	}
	else
	{
		return clist.GetTailPosition () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& SnmpList <TYPE,ARG_TYPE> :: GetNext(POSITION& rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE &type = clist.GetNext ( rPosition ) ;
		return type ;
	}
	else
	{
		return clist.GetNext ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: GetNext(POSITION& rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE type = clist.GetNext ( rPosition ) ;
		return type ;
	}
	else
	{
		return clist.GetNext ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& SnmpList <TYPE,ARG_TYPE> :: GetPrev(POSITION& rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE &type = clist.GetPrev ( rPosition ) ;
		return type ;
	}
	else
	{
		return clist.GetPrev ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: GetPrev(POSITION& rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE type = clist.GetPrev ( rPosition ) ;
		return type ;
	}
	else
	{
		return clist.GetPrev ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& SnmpList <TYPE,ARG_TYPE> :: GetAt(POSITION rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE &type = clist.GetAt ( rPosition ) ;
		return type ;
	}
	else
	{
		return clist.GetAt ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: GetAt(POSITION rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE type = clist.GetAt ( rPosition ) ;
		return type ;
	}
	else
	{
		return clist.GetAt ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpList <TYPE,ARG_TYPE> :: SetAt(POSITION pos, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		clist.SetAt ( pos , newElement ) ;
	}
	else
	{
		clist.SetAt ( pos , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpList <TYPE,ARG_TYPE> :: RemoveAt(POSITION position)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		clist.RemoveAt ( position ) ;
	}
	else
	{
		clist.RemoveAt ( position ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: InsertBefore(POSITION position, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		POSITION position = clist.InsertBefore ( position , newElement ) ;
		return position ;
	}
	else
	{
		return clist.InsertBefore ( position , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: InsertAfter(POSITION position, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		POSITION position = clist.InsertAfter ( position , newElement ) ;
		return position ;
	}
	else
	{
		return clist.InsertAfter ( position , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: Find(ARG_TYPE searchValue, POSITION startAfter ) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		POSITION position = clist.Find ( searchValue , startAfter ) ;
		return position ;
	}
	else
	{
		return clist.Find ( searchValue , startAfter ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: FindIndex(int nIndex) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		POSITION position = clist.Find ( nIndex ) ;
		return position ;
	}
	else
	{
		return clist.Find ( nIndex ) ;
	}
}

template<class TYPE, class ARG_TYPE>
class SnmpStack : public SnmpList<TYPE,ARG_TYPE>
{
private:

	CCriticalSection * criticalSection ;

protected:
public:

	SnmpStack ( BOOL threadSafeArg = FALSE ) ;
	virtual ~SnmpStack () ;

	void Add ( ARG_TYPE type ) ;
	TYPE Get () ;
	TYPE Delete () ;
} ;

template<class TYPE, class ARG_TYPE>
SnmpStack <TYPE, ARG_TYPE> :: SnmpStack ( BOOL threadSafeArg ) :
	SnmpList<TYPE,ARG_TYPE> ( FALSE ) ,
	criticalSection ( NULL )
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
SnmpStack <TYPE, ARG_TYPE> :: ~SnmpStack () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
void SnmpStack <TYPE, ARG_TYPE> :: Add ( ARG_TYPE type ) 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		AddHead ( type ) ;
	}
	else
	{
		AddHead ( type ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpStack <TYPE, ARG_TYPE> :: Get () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE type = GetHead () ;
		return type ;
	}
	else
	{
		return GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpStack <TYPE,ARG_TYPE> :: Delete () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE type = RemoveHead () ;
		return type ;
	}
	else
	{
		return RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
class SnmpQueue : public SnmpList<TYPE,ARG_TYPE>
{
private:

	CCriticalSection * criticalSection ;

protected:
public:

	SnmpQueue ( BOOL threadSafeArg = FALSE ) ;
	virtual ~SnmpQueue () ;

	void Add ( ARG_TYPE type ) ;
	TYPE Get () ;
	TYPE Delete () ;
	void Rotate () ;

} ;

template<class TYPE, class ARG_TYPE>
SnmpQueue <TYPE, ARG_TYPE> :: SnmpQueue ( BOOL threadSafeArg ) : 
	SnmpList<TYPE,ARG_TYPE> ( FALSE ) ,
	criticalSection ( NULL )
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
SnmpQueue <TYPE, ARG_TYPE> :: ~SnmpQueue () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
void SnmpQueue <TYPE, ARG_TYPE> :: Add ( ARG_TYPE type ) 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		AddTail ( type ) ;
	}
	else
	{
		AddTail ( type ) ;
	}
}


template<class TYPE, class ARG_TYPE>
TYPE SnmpQueue <TYPE, ARG_TYPE> :: Get () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE type = GetHead () ;
		return type ;
	}
	else
	{
		return GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpQueue <TYPE, ARG_TYPE> :: Delete () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE type = RemoveHead () ;
		return type ;
	}
	else
	{
		return RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpQueue <TYPE, ARG_TYPE> :: Rotate ()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		TYPE type = Delete () ;
		Add ( type ) ;
	}
	else
	{
		TYPE type = Delete () ;
		Add ( type ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class SnmpMap 
{
private:

	CCriticalSection * criticalSection ;
	CMap <KEY, ARG_KEY, VALUE, ARG_VALUE> cmap ;

protected:
public:

	SnmpMap ( BOOL threadSafe = FALSE ) ;
	virtual ~SnmpMap () ;

	int GetCount () const  ;
	BOOL IsEmpty () const ;
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const ;
	VALUE& operator[](ARG_KEY key) ;
	void SetAt(ARG_KEY key, ARG_VALUE newValue) ;
	BOOL RemoveKey(ARG_KEY key) ;
	void RemoveAll () ;
	POSITION GetStartPosition() const ;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const ;
	BOOL GetCurrentAssoc(POSITION rPosition, KEY& rKey, VALUE& rValue) const;
} ;


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SnmpMap ( BOOL threadSafeArg ) : criticalSection ( NULL )
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = FALSE ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ~SnmpMap () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
int SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetCount() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		int count = cmap.GetCount () ;
		return count ;
	}
	else
	{
		return cmap.GetCount () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: IsEmpty() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		BOOL isEmpty = cmap.IsEmpty () ;
		return isEmpty ;
	}
	else
	{
		return cmap.IsEmpty () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: Lookup(ARG_KEY key, VALUE& rValue) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		BOOL lookup = cmap.Lookup ( key , rValue ) ;
		return lookup ;
	}
	else
	{
		return cmap.Lookup ( key , rValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: operator[](ARG_KEY key)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		VALUE &value = cmap.operator [] ( key ) ;
		return value ;
	}
	else
	{
		return cmap.operator [] ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SetAt(ARG_KEY key, ARG_VALUE newValue)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		cmap.SetAt ( key , newValue ) ;
	}
	else
	{
		cmap.SetAt ( key , newValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveKey(ARG_KEY key)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		BOOL removeKey = cmap.RemoveKey ( key ) ;
		return removeKey ;
	}
	else
	{
		return cmap.RemoveKey ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveAll()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		cmap.RemoveAll () ;
	}
	else
	{
		cmap.RemoveAll () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
POSITION SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetStartPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		POSITION position = cmap.GetStartPosition () ;
		return position ;
	}
	else
	{
		return cmap.GetStartPosition () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
	}
	else
	{
		cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetCurrentAssoc(POSITION rPosition, KEY& rKey, VALUE& rValue) const
{
	BOOL t_Status ;

	if ( criticalSection )
	{
		criticalSection->Lock () ;
		ScopeGuard t_1 = MakeObjGuard ( *criticalSection , CCriticalSection :: Unlock ) ;
		t_Status = cmap.GetCurrentAssoc ( rPosition , rKey , rValue ) ;
	}
	else
	{
		t_Status = cmap.GetCurrentAssoc ( rPosition , rKey , rValue ) ;
	}

	return t_Status ;
}

#endif // __SNMPCONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\startup.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __STARTUP__
#define __STARTUP__

class DllImportExport SnmpClassLibrary 
{
private:
protected:

	static LONG s_ReferenceCount ;

	SnmpClassLibrary () {} ;

public:

	virtual ~SnmpClassLibrary () {} 

	static BOOL Startup () ;
	static void Closedown () ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\session.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: session.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the SnmpSession class
--------------------------------------------------*/
#ifndef __SESSION__
#define __SESSION__

#include "forward.h"
#include "address.h"
#include "sec.h"

#include "tsent.h"

#include "transp.h"
#include "encdec.h"

typedef UINT_PTR TimerEventId;

#define DEF_RETRY_COUNT			1
#define DEF_RETRY_TIMEOUT		500
#define DEF_VARBINDS_PER_PDU	10
#define DEF_WINDOW_SIZE			4


#pragma warning (disable:4355)

/*------------------------------------------------------------
Overview: The SnmpSession class provides the framework for the 
communications session between client and protocol stack. The 
SnmpSession exposes SNMP frame ( use the term frame and protocol 
data unit interchangeably throughout this document ) transmission 
and reception independently of the transport stack implementation. 
The SnmpSession provides the interface between communication 
subsystem and protocol operation generation.

The SnmpImpSession class provides an implementation of the 
SnmpSession abstract class.
------------------------------------------------------------*/

class DllImportExport SnmpSession
{
private:

	// the "=" operator and the copy constructor have been
	// made private to prevent any copies from being made
	SnmpSession & operator=( const SnmpSession & ) 
	{
		return *this;
	}

	SnmpSession(IN const SnmpSession &snmp_session) {}

protected:

	ULONG retry_count;
	ULONG retry_timeout;
	ULONG varbinds_per_pdu;
	ULONG flow_control_window;

/*
 * User overridable callback functions
 */

	virtual void SessionFlowControlOn() {}
	virtual void SessionFlowControlOff() {}

/*
 * End User overridable callback functions
 */

	SnmpSession(

		IN SnmpTransport &transportProtocol,
		IN SnmpSecurity &security,
		IN SnmpEncodeDecode &a_SnmpEncodeDecode  ,
		IN const ULONG retryCount = DEF_RETRY_COUNT,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE

		);

public:

	virtual ~SnmpSession () {}

/*
 * System overridable operation functions
 */

	virtual SnmpTransport &GetTransportProtocol () const = 0 ;

	virtual SnmpSecurity &GetSnmpSecurity () const = 0 ;

	virtual SnmpEncodeDecode &GetSnmpEncodeDecode () const = 0 ;

	// all operations must register themselves before
	// using the Session services and must deregister
	// for the session to be destroyed

	virtual void RegisterOperation(IN SnmpOperation &operation) = 0;

	virtual void DeregisterOperation(IN SnmpOperation &operation) = 0;

	// the session is destroyed if the number of registered sessions
	// is 0. otherwise the session is flagged to be destroyed when
	// the number of registered operations drops to 0.
	virtual BOOL DestroySession() = 0;

	virtual SnmpErrorReport SessionCancelFrame ( IN const SessionFrameId session_frame_id ) = 0 ;

	virtual void SessionSendFrame (  

		IN SnmpOperation &operation ,
		OUT SessionFrameId &session_frame_id ,
		IN SnmpPdu &SnmpPdu,
		IN SnmpSecurity &security

	)  = 0 ;

	virtual void SessionSendFrame (  

		IN SnmpOperation &operation ,
		OUT SessionFrameId &session_frame_id ,
		IN SnmpPdu &SnmpPdu

	)  = 0 ;

	virtual void SessionReceiveFrame (

		IN SnmpPdu &snmpPdu,
		IN SnmpErrorReport &errorReport

	)  = 0 ;

	virtual void SessionSentFrame (

             IN TransportFrameId  transport_frame_id,  
             IN SnmpErrorReport &errorReport
	
	) = 0;

	virtual void * operator()(void) const = 0;

  
/*
 * End system overridable operation functions
 */

	ULONG GetRetryCount () const
	{
		return retry_count;
	}

	ULONG GetRetryTimeout () const
	{
		return retry_timeout;
	}

	ULONG GetVarbindsPerPdu () const
	{
		return varbinds_per_pdu;
	}

	ULONG GetFlowControlWindow() const
	{
		return flow_control_window;
	}

	
} ;


class DllImportExport SnmpImpSession : public SnmpSession
{
private:

	SessionFrameId received_session_frame_id;
	SnmpOperation *operation_to_notify;

	friend class WaitingMessage;
	friend class FlowControlMechanism;
	friend class Timer;
	friend class MessageRegistry;
	friend class FrameRegistry;
	friend class SessionWindow;

	BOOL is_valid;

	// References to the following instances are used instead of 
	// embedded instances themselves. This is done to avoid including
	// the header files providing their declaration
	
	SessionWindow m_SessionWindow;

	CriticalSection session_CriticalSection;

	FlowControlMechanism flow_control;
	Timer	timer;
	TimerEventId timer_event_id;
	UINT strobe_count ;
	MessageRegistry message_registry;
	FrameRegistry frame_registry;

	SnmpTransport &transport;
	SnmpSecurity &security;	
	SnmpEncodeDecode &m_EncodeDecode ;

	SessionSentStateStore store;
	IdMapping id_mapping;

	// the operation registry keeps track of the registered
	// operations
	OperationRegistry operation_registry;

	// if this flag is TRUE, the session must delete this when
	// the number of registered operations falls to 0
	BOOL destroy_self;

	void PostSentFrameEvent (

		SessionFrameId session_frame_id ,
		SnmpOperation &operation, 
		SnmpErrorReport errorReport
	) ;
 
	void NotifyOperation(IN const SessionFrameId session_frame_id,
						 IN const SnmpPdu &snmp_pdu,
						 IN const SnmpErrorReport &error_report);

	SnmpOperation *GetOperation(IN const SessionFrameId session_frame_id);

	// the Handle* methods handle internal windows events
	// these are called by the DummySession
	void HandleSentFrame (IN SessionFrameId  session_frame_id , SnmpOperation *operation);

	void HandleDeletionEvent();


protected:

	SnmpImpSession ( 

		IN SnmpTransport &transportProtocol  ,
		IN SnmpSecurity &security  ,
		IN SnmpEncodeDecode &a_SnmpEncodeDecode  ,
		IN const ULONG retryCount = DEF_RETRY_COUNT ,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT ,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU  ,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE 
	) ;

public:

	~SnmpImpSession () ;

	SnmpTransport &GetTransportProtocol () const { return transport ; }

	SnmpSecurity &GetSnmpSecurity () const { return security ; }

	SnmpEncodeDecode &GetSnmpEncodeDecode () const { return m_EncodeDecode ; }

	void RegisterOperation(IN SnmpOperation &operation);

	void DeregisterOperation(IN SnmpOperation &operation);

	// the session is destroyed if the number of registered sessions
	// is 0. otherwise the session is flagged to be destroyed when
	// the number of registered operations drops to 0.
	BOOL DestroySession();

	SnmpErrorReport SessionCancelFrame ( IN const SessionFrameId session_frame_id ) ;

	void SessionSendFrame ( IN SnmpOperation &operation,
							OUT SessionFrameId &session_frame_id ,
							IN SnmpPdu &snmpPdu) ;

	void SessionSendFrame(IN SnmpOperation &operation,
						  OUT SessionFrameId &session_frame_id,
						  IN SnmpPdu &snmpPdu,
						  IN SnmpSecurity &snmp_security);

	void SessionReceiveFrame(IN SnmpPdu &snmpPdu,
							 IN SnmpErrorReport &errorReport);

	void SessionSentFrame(

             IN TransportFrameId  transport_frame_id,  
             IN SnmpErrorReport &errorReport);

	void * operator()(void) const
	{
		return (is_valid?(void *)this:NULL);
	}

	operator void *() const
	{
		return SnmpImpSession::operator()();
	}

	static ULONG RetryCount(IN const ULONG retry_count) ;
	
	static ULONG RetryTimeout(IN const ULONG retry_timeout) ;

	static ULONG VarbindsPerPdu(IN const ULONG varbinds_per_pdu) ;

	static ULONG WindowSize(IN const ULONG window_size) ;

} ;


class DllImportExport SnmpV1OverIp : public SnmpUdpIpImp , public SnmpCommunityBasedSecurity , public SnmpImpSession , public SnmpV1EncodeDecode
{
private:
protected:
public:

	SnmpV1OverIp ( 

		IN const char *ipAddress ,
		IN const ULONG addressResolution = SNMP_ADDRESS_RESOLVE_VALUE ,
		IN const char *communityName = "public" ,
		IN const ULONG retryCount = DEF_RETRY_COUNT ,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT ,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU  ,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE 
	)
	: 	  SnmpUdpIpImp(*this, ipAddress,addressResolution),
		  SnmpCommunityBasedSecurity(communityName),
		  SnmpImpSession(*this, *this,*this, retryCount,
				   retryTimeout, varbindsPerPdu, flowControlWindow)
	{}

	void * operator()(void) const;

	~SnmpV1OverIp () {}
} ;

class DllImportExport SnmpV2COverIp : public SnmpUdpIpImp , public SnmpCommunityBasedSecurity , public SnmpImpSession , public SnmpV2CEncodeDecode
{
private:
protected:
public:

	SnmpV2COverIp ( 

		IN const char *ipAddress ,
		IN const ULONG addressResolution = SNMP_ADDRESS_RESOLVE_VALUE ,
		IN const char *communityName = "public" ,
		IN const ULONG retryCount = DEF_RETRY_COUNT ,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT ,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU  ,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE 
	)
	: 	  SnmpUdpIpImp(*this, ipAddress,addressResolution),
		  SnmpCommunityBasedSecurity(communityName),
		  SnmpImpSession(*this, *this,*this, retryCount,
				   retryTimeout, varbindsPerPdu, flowControlWindow)
	{}

	void * operator()(void) const;

	~SnmpV2COverIp () {}
} ;

class DllImportExport SnmpV1OverIpx : public SnmpIpxImp , public SnmpCommunityBasedSecurity , public SnmpImpSession , public SnmpV1EncodeDecode
{
private:
protected:
public:

	SnmpV1OverIpx ( 

		IN const char *ipxAddress ,
		IN const char *communityName = "public" ,
		IN const ULONG retryCount = DEF_RETRY_COUNT ,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT ,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU  ,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE 
	)
	: 	  SnmpIpxImp(*this, ipxAddress),
		  SnmpCommunityBasedSecurity(communityName),
		  SnmpImpSession(*this, *this,*this, retryCount,
				   retryTimeout, varbindsPerPdu, flowControlWindow)
	{}

	void * operator()(void) const;

	~SnmpV1OverIpx () {}
} ;

class DllImportExport SnmpV2COverIpx : public SnmpIpxImp , public SnmpCommunityBasedSecurity , public SnmpImpSession , public SnmpV2CEncodeDecode
{
private:
protected:
public:

	SnmpV2COverIpx ( 

		IN const char *ipxAddress ,
		IN const char *communityName = "public" ,
		IN const ULONG retryCount = DEF_RETRY_COUNT ,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT ,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU  ,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE 
	)
	: 	  SnmpIpxImp(*this, ipxAddress),
		  SnmpCommunityBasedSecurity(communityName),
		  SnmpImpSession(*this, *this,*this, retryCount,
				   retryTimeout, varbindsPerPdu, flowControlWindow)
	{}

	void * operator()(void) const;

	~SnmpV2COverIpx () {}
} ;

#pragma warning (default:4355)

#endif // __SESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\snmptype.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include <provexpt.h>

DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString ) ;
DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString ) ;
DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix ) ;
DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) ;

class DllImportExport CBString
{
private:

    BSTR    m_pString;

public:

    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) 
		{
            SysFreeString(m_pString);
        }
        
		m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#if _MSC_VER >= 1100
template <> DllImportExport UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key ) ;
#else
DllImportExport UINT HashKey ( wchar_t *key ) ;
#endif

#if _MSC_VER >= 1100
typedef wchar_t * HmmHack_wchar_t ;
template<> DllImportExport BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const HmmHack_wchar_t *pElement1, const HmmHack_wchar_t *pElement2 ) ;
#else
DllImportExport BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 ) ;
#endif

union SnmpLexiconValue
{
	LONG signedInteger ;
	ULONG unsignedInteger ;
	wchar_t *token ;
} ;

class SnmpAnalyser;
class DllImportExport SnmpLexicon
{
friend SnmpAnalyser ;
public:

enum LexiconToken {

	TOKEN_ID ,
	SIGNED_INTEGER_ID ,
	UNSIGNED_INTEGER_ID ,
	COLON_ID ,
	COMMA_ID ,
	OPEN_PAREN_ID ,
	CLOSE_PAREN_ID ,
	DOT_ID ,
	DOTDOT_ID ,
	PLUS_ID ,
	MINUS_ID ,
	EOF_ID,
	WHITESPACE_ID,
	INVALID_ID,
	USERDEFINED_ID
} ;

private:

	wchar_t *tokenStream ;
	ULONG position ;
	LexiconToken token ;
	SnmpLexiconValue value ;

protected:
public:

	SnmpLexicon () ;
	~SnmpLexicon () ;

	void SetToken ( SnmpLexicon :: LexiconToken a_Token ) ;
	SnmpLexicon :: LexiconToken GetToken () ;
	SnmpLexiconValue *GetValue () ;
} ;

#define ANALYSER_ACCEPT_STATE 10000
#define ANALYSER_REJECT_STATE 10001

/* 
	User defined states should be greater than 20000
 */

class DllImportExport SnmpAnalyser
{
private:

	wchar_t *stream ;
	ULONG position ;
	BOOL status ;

	SnmpLexicon *GetToken (  BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

protected:

	virtual void Initialise () {} ;

	virtual SnmpLexicon *CreateLexicon () { return new SnmpLexicon ; }

	virtual BOOL Analyse ( 

		SnmpLexicon *lexicon , 
		ULONG &state , 
		const wchar_t token , 
		const wchar_t *tokenStream , 
		ULONG &position , 
		BOOL unSignedIntegersOnly , 
		BOOL leadingIntegerZeros , 
		BOOL eatSpace 
	) 
	{ return FALSE ; }

public:

	SnmpAnalyser ( const wchar_t *tokenStream = NULL ) ;
	virtual ~SnmpAnalyser () ;

	void Set ( const wchar_t *tokenStream ) ;

	SnmpLexicon *Get ( BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

	void PutBack ( const SnmpLexicon *token ) ;

	virtual operator void * () ;

	static BOOL IsEof ( wchar_t token ) ;
	static BOOL IsLeadingDecimal ( wchar_t token ) ;
	static BOOL IsDecimal ( wchar_t token ) ;
	static BOOL IsOctal ( wchar_t token ) ;
	static BOOL IsHex ( wchar_t token ) ;	
	static BOOL IsAlpha ( wchar_t token ) ;
	static BOOL IsAlphaNumeric ( wchar_t token ) ;
	static BOOL IsWhitespace ( wchar_t token ) ;

	static ULONG OctWCharToDecInteger ( wchar_t token ) ;
	static ULONG HexWCharToDecInteger ( wchar_t token ) ;
	static ULONG DecWCharToDecInteger ( wchar_t token ) ;
	static wchar_t DecIntegerToHexWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToDecWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToOctWChar ( UCHAR integer ) ;

	static ULONG OctCharToDecInteger ( char token ) ;
	static ULONG HexCharToDecInteger ( char token ) ;
	static ULONG DecCharToDecInteger ( char token ) ;
	static char DecIntegerToHexChar ( UCHAR integer ) ;
	static char DecIntegerToDecChar ( UCHAR integer ) ;
	static char DecIntegerToOctChar ( UCHAR integer ) ;

} ;

class DllImportExport SnmpNegativeRangeType
{
private:
protected:

	LONG lowerBound ;
	LONG upperBound ;

public:

	SnmpNegativeRangeType ( const SnmpNegativeRangeType &rangeType ) : lowerBound ( rangeType.lowerBound ) , upperBound ( rangeType.upperBound ) {}
	SnmpNegativeRangeType ( LONG lowerBoundArg , LONG upperBoundArg ) : lowerBound ( lowerBoundArg ) , upperBound ( upperBoundArg ) {}
	SnmpNegativeRangeType () : lowerBound ( 0 ) , upperBound ( 0 ) { } ;
	virtual ~SnmpNegativeRangeType () {}


	LONG GetLowerBound () { return lowerBound ; }
	LONG GetUpperBound () { return upperBound ; }
	void SetUpperBound ( const LONG &upperBoundArg ) { upperBound = upperBoundArg ; }
	void SetLowerBound ( const LONG &lowerBoundArg ) { lowerBound = lowerBoundArg ; }

	virtual SnmpNegativeRangeType *Copy () { return new SnmpNegativeRangeType ( *this ) ; }
} ;

class SnmpNegativeRangedType
{
private:
protected:

	BOOL status ;

	SnmpList <SnmpNegativeRangeType,SnmpNegativeRangeType> rangedValues ;

	BOOL Parse ( const wchar_t *rangedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	SnmpAnalyser analyser ;
	SnmpLexicon *pushBack ;

	void PushBack () ;
	SnmpLexicon *Get () ;
	SnmpLexicon *Match ( SnmpLexicon :: LexiconToken tokenType ) ;

	BOOL RecursiveDef () ;
	BOOL RangeDef () ;

public:

	SnmpNegativeRangedType ( const SnmpNegativeRangedType &rangedValues ) ;
	SnmpNegativeRangedType ( const wchar_t *rangedValues = NULL ) ;
	virtual ~SnmpNegativeRangedType () ;

	BOOL IsValid () { return status ; }

	void SetStatus ( const BOOL &statusArg ) { status = statusArg ; }

	BOOL Check ( const LONG &value ) ;

	virtual operator void* () { return status ? this : NULL ; } 

} ;

class DllImportExport SnmpPositiveRangeType
{
private:
protected:

	ULONG lowerBound ;
	ULONG upperBound ;

public:

	SnmpPositiveRangeType ( const SnmpPositiveRangeType &rangeType ) : lowerBound ( rangeType.lowerBound ) , upperBound ( rangeType.upperBound ) {}
	SnmpPositiveRangeType ( ULONG lowerBoundArg , LONG upperBoundArg ) : lowerBound ( lowerBoundArg ) , upperBound ( upperBoundArg ) {}
	SnmpPositiveRangeType () : lowerBound ( 0 ) , upperBound ( 0 ) { } ;
	virtual ~SnmpPositiveRangeType () {}


	ULONG GetLowerBound () { return lowerBound ; }
	ULONG GetUpperBound () { return upperBound ; }
	void SetUpperBound ( const ULONG &upperBoundArg ) { upperBound = upperBoundArg ; }
	void SetLowerBound ( const ULONG &lowerBoundArg ) { lowerBound = lowerBoundArg ; }

	virtual SnmpPositiveRangeType *Copy () { return new SnmpPositiveRangeType ( *this ) ; }
} ;

class DllImportExport SnmpPositiveRangedType
{
private:
protected:

	BOOL status ;

	SnmpList <SnmpPositiveRangeType,SnmpPositiveRangeType> rangedValues ;

	BOOL Parse ( const wchar_t *rangedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	SnmpAnalyser analyser ;
	SnmpLexicon *pushBack ;

	void PushBack () ;
	SnmpLexicon *Get () ;
	SnmpLexicon *Match ( SnmpLexicon :: LexiconToken tokenType ) ;

	BOOL RecursiveDef () ;
	BOOL RangeDef () ;

public:

	SnmpPositiveRangedType ( const SnmpPositiveRangedType &rangedValues ) ;
	SnmpPositiveRangedType ( const wchar_t *rangedValues = NULL ) ;
	virtual ~SnmpPositiveRangedType () ;

	void SetStatus ( const BOOL &statusArg ) { status = statusArg ; }

	BOOL IsValid () { return status ; }

	BOOL Check ( const ULONG &value ) ;

	virtual operator void* () { return status ? this : NULL ; }
} ;

class DllImportExport SnmpFixedType
{
private:
protected:

	ULONG fixedLength ;

public:

	SnmpFixedType ( const SnmpFixedType &fixedLengthArg ) { fixedLength = fixedLengthArg.fixedLength ; }
	SnmpFixedType ( const ULONG fixedLengthArg ) { fixedLength = fixedLengthArg ; }
	virtual ~SnmpFixedType () {} ;
} ;

class DllImportExport SnmpInstanceType 
{
private:
protected:

	BOOL m_IsNull ;
	BOOL status ;

	SnmpInstanceType ( const SnmpInstanceType &copy ) { status = copy.status ; m_IsNull = copy.m_IsNull ; }
	SnmpInstanceType ( BOOL statusArg = TRUE , BOOL nullArg = FALSE ) { status = statusArg ; m_IsNull = nullArg ; } ;
	virtual BOOL Equivalent (IN const SnmpInstanceType &value) const = 0;

public:

	virtual ~SnmpInstanceType () {} ;

	virtual SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const = 0  ;
	virtual SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) = 0 ;

	virtual const SnmpValue *GetValueEncoding () const = 0 ;
	virtual wchar_t *GetStringValue () const = 0 ;

	virtual SnmpInstanceType *Copy () const = 0 ;

	virtual operator void *() ;

	void SetStatus ( BOOL statusArg ) { status = statusArg ; }
	void SetNull ( BOOL nullArg ) { m_IsNull = nullArg ; }

	virtual BOOL IsValid () const ;
	virtual BOOL IsNull () const ;
	virtual BOOL IsSNMPV1Type () const { return TRUE ; }
	virtual BOOL IsSNMPV2CType () const { return TRUE ; }

	BOOL operator==(IN const SnmpInstanceType &value) const
	{
		return Equivalent(value) ;
	}

	BOOL operator!=(IN const SnmpInstanceType &value) const
	{
		return !((*this) == value) ;
	}

} ;

class DllImportExport SnmpNullType : public SnmpInstanceType
{
private:

	SnmpNull null ;

protected:

	BOOL Equivalent (IN const SnmpInstanceType &value) const;

public:

	SnmpNullType ( const SnmpNullType &nullArg ) ;
	SnmpNullType ( const SnmpNull &nullArg ) ;
	SnmpNullType () ;
	~SnmpNullType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;

	BOOL IsSNMPV2CType () const { return FALSE ; }
} ;

class DllImportExport SnmpIntegerType : public SnmpInstanceType , protected SnmpNegativeRangedType
{
private:
protected:

	SnmpInteger integer ;
	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *integerArg ) ;

public:

	SnmpIntegerType ( const SnmpIntegerType &integerArg ) ;
	SnmpIntegerType ( const SnmpInteger &integerArg , const wchar_t *rangeValues ) ;
	SnmpIntegerType ( const wchar_t *integerArg , const wchar_t *rangeValues ) ;
	SnmpIntegerType ( const LONG integerArg , const wchar_t *rangeValues ) ;
	SnmpIntegerType ( const wchar_t *rangeValues = NULL ) ;
	~SnmpIntegerType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const ;
	wchar_t *GetStringValue () const ;
	LONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpGaugeType : public SnmpInstanceType , protected SnmpPositiveRangedType
{
private:
protected:

	SnmpGauge gauge ;

	BOOL Parse ( const wchar_t *gaugeArg )  ;
	BOOL Equivalent (IN const SnmpInstanceType &value) const ;

public:

	SnmpGaugeType ( const SnmpGaugeType &gaugeArg ) ;
	SnmpGaugeType ( const SnmpGauge &gaugeArg , const wchar_t *rangeValues ) ;
	SnmpGaugeType ( const wchar_t *gaugeArg , const wchar_t *rangeValues ) ;
	SnmpGaugeType ( const ULONG gaugeArg , const wchar_t *rangeValues ) ;
	SnmpGaugeType ( const wchar_t *rangeValues = NULL ) ;
	~SnmpGaugeType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpUInteger32Type : public SnmpInstanceType , protected SnmpPositiveRangedType
{
private:
protected:

	SnmpUInteger32 ui_integer32 ;

	BOOL Parse ( const wchar_t *ui_integerArg )  ;
	BOOL Equivalent (IN const SnmpInstanceType &value) const ;

public:

	SnmpUInteger32Type ( const SnmpUInteger32Type &ui_integerArg ) ;
	SnmpUInteger32Type ( const SnmpUInteger32 &ui_integerArg , const wchar_t *rangeValues ) ;
	SnmpUInteger32Type ( const wchar_t *ui_integerArg , const wchar_t *rangeValues ) ;
	SnmpUInteger32Type ( const ULONG ui_integerArg , const wchar_t *rangeValues ) ;
	SnmpUInteger32Type ( const wchar_t *rangeValues = NULL ) ;
	~SnmpUInteger32Type () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;


class DllImportExport  SnmpTimeTicksType : public SnmpInstanceType
{
private:
protected:

	SnmpTimeTicks timeTicks ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *timeTicksArg )  ;

public:

	SnmpTimeTicksType ( const SnmpTimeTicks &timeTicksArg ) ;
	SnmpTimeTicksType ( const SnmpTimeTicksType &timeTicksArg ) ;
	SnmpTimeTicksType ( const wchar_t *timeTicksArg ) ;
	SnmpTimeTicksType ( const ULONG timeTicksArg ) ;
	SnmpTimeTicksType () ;
	~SnmpTimeTicksType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpCounterType : public SnmpInstanceType 
{
private:
protected:

	SnmpCounter counter ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *counterArg )  ;

public:

	SnmpCounterType ( const SnmpCounter &counterArg ) ;
	SnmpCounterType ( const SnmpCounterType &counterArg ) ;
	SnmpCounterType ( const wchar_t *counterArg ) ;
	SnmpCounterType ( const ULONG counterArg ) ;
	SnmpCounterType () ;
	~SnmpCounterType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;
	
	SnmpInstanceType *Copy () const ;

} ;

class DllImportExport  SnmpCounter64Type : public SnmpInstanceType 
{
private:
protected:

	SnmpCounter64 counter64;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *counterArg )  ;

public:

	SnmpCounter64Type ( const SnmpCounter64Type &counterArg ) ;
	SnmpCounter64Type ( const SnmpCounter64 &counterArg ) ;
	SnmpCounter64Type ( const wchar_t *counterArg ) ;
	SnmpCounter64Type ( const ULONG counterHighArg , const ULONG counterLowArg ) ;
	SnmpCounter64Type () ;
	~SnmpCounter64Type () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	void GetValue ( ULONG &counterHighArg , ULONG &counterLowArg ) const ;

	BOOL IsSNMPV1Type () const { return FALSE ; } 
	
	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpIpAddressType : public SnmpInstanceType
{
private:
protected:

	SnmpIpAddress ipAddress ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *ipAddressArg )  ;

public:

	SnmpIpAddressType ( const SnmpIpAddress &ipAddressArg ) ;
	SnmpIpAddressType ( const SnmpIpAddressType &ipAddressArg ) ;
	SnmpIpAddressType ( const wchar_t *ipAddressArg ) ;
	SnmpIpAddressType ( const ULONG ipAddressArg ) ;
	SnmpIpAddressType () ;
	~SnmpIpAddressType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpNetworkAddressType : public SnmpInstanceType
{
private:
protected:

	SnmpIpAddress ipAddress ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *gaugeArg )  ;

public:

	SnmpNetworkAddressType ( const SnmpIpAddress &ipAddressArg ) ;
	SnmpNetworkAddressType ( const SnmpNetworkAddressType &ipAddressArg ) ;
	SnmpNetworkAddressType ( const wchar_t *networkAddressArg ) ;
	SnmpNetworkAddressType ( const ULONG ipAddressArg ) ;
	SnmpNetworkAddressType () ;
	~SnmpNetworkAddressType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const  ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpObjectIdentifierType : public SnmpInstanceType
{
private:
protected:

	SnmpObjectIdentifier objectIdentifier ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *objectIdentifierArg )  ;

public:

	SnmpObjectIdentifierType ( const SnmpObjectIdentifier &objectIdentifierArg ) ;
	SnmpObjectIdentifierType ( const SnmpObjectIdentifierType &objectIdentifierArg ) ;
	SnmpObjectIdentifierType ( const wchar_t *objectIdentifierArg ) ;
	SnmpObjectIdentifierType ( IN const ULONG *value , IN const ULONG valueLength ) ;
	SnmpObjectIdentifierType () ;
	~SnmpObjectIdentifierType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	ULONG *GetValue () const ;

	SnmpInstanceType *Copy () const ;

	SnmpObjectIdentifierType &operator=(const SnmpObjectIdentifierType &to_copy ) ;
} ;

class DllImportExport  SnmpOpaqueType : public SnmpInstanceType , protected SnmpPositiveRangedType
{
private:
protected:

	SnmpOpaque opaque ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *opaqueArg )  ;

public:

	SnmpOpaqueType ( const SnmpOpaque &opaqueArg , const wchar_t *rangedValues ) ;
	SnmpOpaqueType ( const SnmpOpaqueType &opaqueArg ) ;
	SnmpOpaqueType ( const wchar_t *opaqueArg , const wchar_t *rangedValues ) ;
	SnmpOpaqueType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	SnmpOpaqueType ( const wchar_t *rangedValues = NULL ) ;
	~SnmpOpaqueType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	UCHAR *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpFixedLengthOpaqueType : public SnmpOpaqueType , protected SnmpFixedType
{
private:
protected:
public:

	SnmpFixedLengthOpaqueType ( const ULONG &fixedLength , const SnmpOpaque &opaqueArg ) ;
	SnmpFixedLengthOpaqueType ( const SnmpFixedLengthOpaqueType &opaqueArg ) ;
	SnmpFixedLengthOpaqueType ( const ULONG &fixedLength , const wchar_t *opaqueArg ) ;
	SnmpFixedLengthOpaqueType ( const ULONG &fixedLengthArg , const UCHAR *value , const ULONG valueLength ) ;
	SnmpFixedLengthOpaqueType ( const ULONG &fixedLength ) ;
	~SnmpFixedLengthOpaqueType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpOctetStringType : public SnmpInstanceType , protected SnmpPositiveRangedType
{
private:
protected:

	SnmpOctetString octetString ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *octetStringArg )  ;

public:

	SnmpOctetStringType ( const SnmpOctetString &octetStringArg , const wchar_t *rangedValues ) ;
	SnmpOctetStringType ( const SnmpOctetStringType &octetStringArg ) ;
	SnmpOctetStringType ( const wchar_t *octetStringArg , const wchar_t *rangedValues ) ;
	SnmpOctetStringType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	SnmpOctetStringType ( const wchar_t *rangedValues = NULL ) ;
	~SnmpOctetStringType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	UCHAR *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpFixedLengthOctetStringType : public SnmpOctetStringType , protected SnmpFixedType
{
private:
protected:
public:

	SnmpFixedLengthOctetStringType ( const ULONG &fixedLength , const SnmpOctetString &octetStringArg ) ;
	SnmpFixedLengthOctetStringType ( const SnmpFixedLengthOctetStringType &octetStringArg ) ;
	SnmpFixedLengthOctetStringType ( const ULONG &fixedLength , const wchar_t *octetStringArg ) ;
	SnmpFixedLengthOctetStringType ( const ULONG &fixedLength , const UCHAR *value ) ;
	SnmpFixedLengthOctetStringType ( const ULONG &fixedLength ) ;
	~SnmpFixedLengthOctetStringType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpMacAddressType : public SnmpFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *macAddressArg )  ;

public:

	SnmpMacAddressType ( const SnmpOctetString &macAddressArg ) ;
	SnmpMacAddressType ( const SnmpMacAddressType &macAddressArg ) ;
	SnmpMacAddressType ( const wchar_t *macAddressArg ) ;
	SnmpMacAddressType ( const UCHAR *macAddressArg ) ;
	SnmpMacAddressType () ;
	~SnmpMacAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpPhysAddressType : public SnmpOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *physAddressArg )  ;

public:

	SnmpPhysAddressType ( const SnmpOctetString &physAddressArg , const wchar_t *rangedValues  ) ;
	SnmpPhysAddressType ( const SnmpPhysAddressType &physAddressArg ) ;
	SnmpPhysAddressType ( const wchar_t *physAddressArg , const wchar_t *rangedValues ) ;
	SnmpPhysAddressType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	SnmpPhysAddressType ( const wchar_t *rangedValues = NULL ) ;
	~SnmpPhysAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpFixedLengthPhysAddressType : public SnmpFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *physAddressArg )  ;

public:

	SnmpFixedLengthPhysAddressType ( const ULONG &fixedLength , const SnmpOctetString &physAddressArg ) ;
	SnmpFixedLengthPhysAddressType ( const SnmpFixedLengthPhysAddressType &physAddressArg ) ;
	SnmpFixedLengthPhysAddressType ( const ULONG &fixedLength , const wchar_t *physAddressArg ) ;
	SnmpFixedLengthPhysAddressType ( const ULONG &fixedLength , const UCHAR *value , const ULONG valueLength ) ;
	SnmpFixedLengthPhysAddressType ( const ULONG &fixedLength ) ;
	~SnmpFixedLengthPhysAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpDisplayStringType : public SnmpOctetStringType
{
private:
protected:
public:

	SnmpDisplayStringType ( const SnmpOctetString &displayStringArg , const wchar_t *rangedValues ) ;
	SnmpDisplayStringType ( const SnmpDisplayStringType &displayStringArg ) ;
	SnmpDisplayStringType ( const wchar_t *displayStringArg , const wchar_t *rangedValues ) ;
	SnmpDisplayStringType ( const wchar_t *rangedValues = NULL ) ;
	~SnmpDisplayStringType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpFixedLengthDisplayStringType : public SnmpFixedLengthOctetStringType 
{
private:
protected:
public:

	SnmpFixedLengthDisplayStringType ( const ULONG &fixedLength , const SnmpOctetString &displayStringArg ) ;
	SnmpFixedLengthDisplayStringType ( const SnmpFixedLengthDisplayStringType &displayStringArg ) ;
	SnmpFixedLengthDisplayStringType ( const ULONG &fixedLength , const wchar_t *displayStringArg ) ;
	SnmpFixedLengthDisplayStringType ( const ULONG &fixedLength ) ;
	~SnmpFixedLengthDisplayStringType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpEnumeratedType : public SnmpIntegerType
{
private:

	SnmpMap <LONG, const LONG,wchar_t *,wchar_t *> integerMap ;
	SnmpMap <wchar_t *,wchar_t *,LONG,LONG> stringMap ;

	BOOL Parse ( const wchar_t *enumeratedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	SnmpAnalyser analyser ;
	SnmpLexicon *pushBack ;

	void PushBack () ;
	SnmpLexicon *Get () ;
	SnmpLexicon *Match ( SnmpLexicon :: LexiconToken tokenType ) ;

	BOOL EnumerationDef () ;
	BOOL RecursiveDef () ;

protected:
public:

	SnmpEnumeratedType ( const wchar_t *enumeratedValues , const LONG &enumeratedValue ) ;
	SnmpEnumeratedType ( const wchar_t *enumeratedValues , const wchar_t *enumeratedValue ) ;
	SnmpEnumeratedType ( const wchar_t *enumeratedValues , const SnmpInteger &enumeratedValue ) ;
	SnmpEnumeratedType ( const SnmpEnumeratedType &enumerateValues ) ;
	SnmpEnumeratedType ( const wchar_t *enumeratedValues ) ;
	~SnmpEnumeratedType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpRowStatusType : public SnmpEnumeratedType
{
private:
protected:
public:

	enum SnmpRowStatusEnum
	{
		active = 1 ,
		notInService = 2 ,
		notReady = 3 ,
		createAndGo = 4 ,
		createAndWait = 5,
		destroy = 6
	} ;

	SnmpRowStatusType ( const LONG &rowStatusValue ) ;
	SnmpRowStatusType ( const wchar_t *rowStatusValue ) ;
	SnmpRowStatusType ( const SnmpInteger &rowStatusValue ) ;
	SnmpRowStatusType ( const SnmpRowStatusType &rowStatusValue ) ;
	SnmpRowStatusType ( const SnmpRowStatusEnum &rowStatusValue ) ;
	SnmpRowStatusType () ;
	~SnmpRowStatusType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;
	SnmpRowStatusEnum GetRowStatus () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpBitStringType : public SnmpOctetStringType
{
private:

	SnmpMap <ULONG, const ULONG,wchar_t *,wchar_t *> integerMap ;
	SnmpMap <wchar_t *,wchar_t *,ULONG,ULONG> stringMap ;

	BOOL Parse ( const wchar_t *bitStringValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	SnmpAnalyser analyser ;
	SnmpLexicon *pushBack ;

	void PushBack () ;
	SnmpLexicon *Get () ;
	SnmpLexicon *Match ( SnmpLexicon :: LexiconToken tokenType ) ;

	BOOL BitStringDef () ;
	BOOL RecursiveDef () ;

protected:
public:

	SnmpBitStringType ( const wchar_t *bitStringValues , const SnmpOctetString &bitStringValue ) ;
	SnmpBitStringType ( const wchar_t *bitStringValues , const wchar_t **bitStringValue , const ULONG &bitStringValueLength ) ;
	SnmpBitStringType ( const SnmpBitStringType &bitStringValues ) ;
	SnmpBitStringType ( const wchar_t *bitStringValues ) ;
	~SnmpBitStringType () ;

	wchar_t *GetStringValue () const ;
	ULONG SnmpBitStringType :: GetValue ( wchar_t **&stringValue ) const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport SnmpDateTimeType : public SnmpOctetStringType
{
private:

	void Encode (

		const ULONG &year ,
		const ULONG &month ,
		const ULONG &day ,
		const ULONG &hour ,
		const ULONG &minutes ,
		const ULONG &seconds ,
		const ULONG &deciSeconds ,
		const ULONG &UTC_present ,
		const ULONG &UTC_direction ,
		const ULONG &UTC_hours ,
		const ULONG &UTC_minutes
	) ;

	BOOL Parse ( const wchar_t *dateTimeValue ) ;
	BOOL DateTimeDef () ;
//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	SnmpAnalyser analyser ;
	SnmpLexicon *pushBack ;

	void PushBack () ;
	SnmpLexicon *Get () ;
	SnmpLexicon *Match ( SnmpLexicon :: LexiconToken tokenType ) ;

protected:
public:

	SnmpDateTimeType ( const wchar_t *dateTimeValue ) ;
	SnmpDateTimeType ( const SnmpDateTimeType &dateTimeValue ) ;
	SnmpDateTimeType ( const SnmpOctetString &dateTimeValue ) ;
	SnmpDateTimeType () ;
	~SnmpDateTimeType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport SnmpOSIAddressType : public SnmpOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *osiAddressArg )  ;

public:

	SnmpOSIAddressType ( const SnmpOctetString &osiAddressArg ) ;
	SnmpOSIAddressType ( const SnmpOSIAddressType &osiAddressArg ) ;
	SnmpOSIAddressType ( const wchar_t *osiAddressArg ) ;
	SnmpOSIAddressType ( const UCHAR *value , const ULONG valueLength ) ;
	SnmpOSIAddressType () ;
	~SnmpOSIAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpUDPAddressType : public SnmpFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *udpAddressArg )  ;

public:

	SnmpUDPAddressType ( const SnmpOctetString &udpAddressArg ) ;
	SnmpUDPAddressType ( const SnmpUDPAddressType &udpAddressArg ) ;
	SnmpUDPAddressType ( const wchar_t *udpAddressArg ) ;
	SnmpUDPAddressType ( const UCHAR *udpAddressArg ) ;
	SnmpUDPAddressType () ;
	~SnmpUDPAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpIPXAddressType : public SnmpFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *ipxAddressArg )  ;

public:

	SnmpIPXAddressType ( const SnmpOctetString &ipxAddressArg ) ;
	SnmpIPXAddressType ( const SnmpIPXAddressType &ipxAddressArg ) ;
	SnmpIPXAddressType ( const wchar_t *ipxAddressArg ) ;
	SnmpIPXAddressType ( const UCHAR *ipxAddressArg ) ;
	SnmpIPXAddressType () ;
	~SnmpIPXAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\ssent.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: session.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the ErrorInfo and
		 the SessionSentStateStore classes
--------------------------------------------------*/

#ifndef __SESSION_SENT_STATE_STORE
#define __SESSION_SENT_STATE_STORE

#include "common.h"
#include "forward.h"

// encapsulates the state information required to inform the SnmpOperation
// of any errors in an attempt to transmit (ex. unable to encode the
// security context)

class ErrorInfo
{
	SnmpOperation *operation;
	SnmpErrorReport error_report;

public:

	ErrorInfo(SnmpOperation &operation, IN const SnmpErrorReport &error_report)
		: operation(&operation), error_report(error_report)
	{}

	SnmpOperation *GetOperation(void)
	{
		return operation;
	}

	SnmpErrorReport GetErrorReport(void)
	{
		return error_report;
	}
};


// stores the ErrorInfo data structure for frames that errored in
// an attempt to transmit

class SessionSentStateStore
{
	typedef CMap<SessionFrameId, SessionFrameId, ErrorInfo *, ErrorInfo *> Store;

	Store store;

public:

	// makes a copy of the error report for storage
	void Register(IN SessionFrameId id, 
				  IN SnmpOperation &operation,
				  IN const SnmpErrorReport &error_report);

	SnmpErrorReport Remove(IN SessionFrameId id, OUT SnmpOperation *&operation);

	void Remove(IN SessionFrameId id);

	~SessionSentStateStore(void);
};



#endif // __SESSION_SENT_STATE_STORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\sync.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: sync.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the MutexLock and 
		 the SemaphoreLock classes (derived from a 
		 generic Lock template class)
--------------------------------------------------*/
#ifndef __SYNC__
#define __SYNC__

// for exception specification
#include "excep.h"

typedef HANDLE Mutex;
typedef HANDLE Semaphore;

#define IMMEDIATE 0

// a generic template class used to build synchronization primitives
// like a Mutex and a Semaphore

template <class SyncObjType>
class Lock
{	
protected:

	// the sync_obj may be a mutex/semaphore etc.
	SyncObjType	sync_obj;

	// number of locks on the sync obj
	LONG num_locks;

	// an option that specifies if the held locks must be released
	// when the lock is destroyed
	BOOL release_on_destroy;

	virtual DWORD OpenOperation(DWORD wait_time) = 0 ;

	virtual BOOL ReleaseOperation(LONG num_release = 1, 
								  LONG *previous_count = NULL) = 0;

public:

	Lock(SyncObjType sync_obj, BOOL release_on_destroy = TRUE) : sync_obj ( sync_obj )
	{ 
		num_locks = 0;
		Lock::release_on_destroy = release_on_destroy;
	}

	BOOL GetLock(DWORD wait_time);

	UINT UnLock(LONG num_release = 1);
};

template <class SyncObjType>
BOOL Lock<SyncObjType>::GetLock(DWORD wait_time)
{
	DWORD wait_result = OpenOperation (wait_time);
	
	if ( wait_result == WAIT_FAILED )
		return FALSE;
	else if ( wait_result == WAIT_TIMEOUT )
		return FALSE;
	else
	{
		num_locks++;
		return TRUE;
	}
}

template <class SyncObjType>
UINT Lock<SyncObjType>::UnLock(LONG num_release)
{	
	LONG previous_count;
	BOOL release_result = 
		ReleaseOperation(num_release, &previous_count);

	if ( release_result == TRUE )
		num_locks -= num_release;
	else
		throw GeneralException(Snmp_Error, Snmp_Local_Error);

	return previous_count;
}

class CriticalSectionLock;
class CriticalSection 
{
friend CriticalSectionLock;
private:

	CRITICAL_SECTION m_CriticalSection ;

public:

	CriticalSection () 
	{
		InitializeCriticalSection ( &m_CriticalSection ) ;
	}
	
	~CriticalSection()
	{ 
		DeleteCriticalSection ( &m_CriticalSection ) ;
	}
};

class CriticalSectionLock : public Lock<CriticalSection&>
{
private:

	BOOL ReleaseOperation(LONG num_release = 1, 
						  LONG *previous_count = NULL)
	{
		// both parameters are ignored
		LeaveCriticalSection(&sync_obj.m_CriticalSection);
		return TRUE;
	}

	DWORD OpenOperation(DWORD wait_time) 
	{
		EnterCriticalSection(&sync_obj.m_CriticalSection);
		return TRUE;
	}

public:

	CriticalSectionLock(CriticalSection &criticalSection, BOOL release_on_destroy = TRUE)
		: Lock<CriticalSection &>(criticalSection, release_on_destroy)
	{}

	~CriticalSectionLock(void)
	{ 
		if ( (release_on_destroy == TRUE) && (num_locks != 0) )
			UnLock(num_locks);
	}
};

#endif // __SYNC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\timer.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: timer.hpp
Author: B.Rajeev
Purpose: Provides declarations for the Timer class.
--------------------------------------------------*/


#ifndef __TIMER__
#define __TIMER__

#define ILLEGAL_TIMER_EVENT_ID	0
#define RETRY_TIMEOUT_FACTOR 10
typedef UINT_PTR TimerEventId;

#include <snmpevt.h>
#include <snmpthrd.h>

#include "forward.h"
#include "common.h"
#include "message.h"

typedef CMap< TimerEventId, TimerEventId, Timer *, Timer * > TimerMapping;
typedef CList< WaitingMessage * , WaitingMessage * > WaitingMessageContainer;

class SnmpClThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	SnmpClThreadObject () ;

	void Initialise () ; 
	void Uninitialise () ;

} ;

class SnmpClTrapThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	SnmpClTrapThreadObject () ;

	void Initialise () ; 
	void Uninitialise () ;

} ;

/*--------------------------------------------------
Overview
--------

  Timer: Provides methods for setting and cancelling timer
events. When the timer is informed of a timer event, it determines
the corresponding waiting message and notifies it.

  note - the timer has static data structures which enable it
  to identify the timer instance corresponding to a timer event id.
  therefore, each timer event must not only be registered as a
  <timer_event_id, waiting_message *> pair within a timer instance, but
  also as a <timer_event_id, timer *> pair in the static CMap. The CriticalSection
  is needed to serialize access to the CMap
--------------------------------------------------*/

class Timer
{
	// counter to generate timer_event_id
	static TimerEventId next_timer_event_id;

	// v1 session: for obtaining the event handler
	SnmpImpSession *session;

	// map for (event_id, waiting_message) association and
	// unique event_id generation
	static TimerMapping timer_mapping;
	WaitingMessageContainer waiting_message_mapping;

	static BOOL CreateCriticalSection();

	static void DestroyCriticalSection();

public:

	Timer(SnmpImpSession &session);

	// generates and returns a new event id
	// associates the pair (event_id, waiting_message)
	// creates the timer event
	void SetMessageTimerEvent (WaitingMessage &waiting_message);

	TimerEventId SetTimerEvent(UINT timeout_value);

	// Removes the association (event_id, waiting_message)
	void CancelMessageTimer(WaitingMessage &waiting_message,TimerEventId event_id);

	// Kills the registered timer event
	void CancelTimer(TimerEventId event_id);

	// used to create the static CriticalSection
	static BOOL InitializeStaticComponents();

	// used to destroy the static CriticalSection
	static void DestroyStaticComponents();

	// it determines the corresponding Timer and calls 
	// its TimerEventNotification with the appropriate parameters
	static void CALLBACK HandleGlobalEvent(HWND hWnd ,UINT message,
										   UINT_PTR idEvent, DWORD dwTime);

	// informs the timer instance of the event. the instance
	// must pass the event to the corresponding waiting message
	void TimerEventNotification(TimerEventId event_id);

	virtual ~Timer(void);

	static SnmpClThreadObject *g_timerThread ;

	static UINT g_SnmpWmTimer ;

	// the CriticalSection serializes accesses to the static timer_mapping
	static CriticalSection timer_CriticalSection;

};

class SnmpTimerObject
{
private:

	HWND hWnd ;
	UINT_PTR timerId ;
	TIMERPROC lpTimerFunc ;

protected:
public:

	SnmpTimerObject ( 

		HWND hWnd , 
		UINT_PTR timerId , 
		UINT elapsedTime ,
		TIMERPROC lpTimerFunc 
	) ;

	~SnmpTimerObject () ;

	UINT_PTR GetTimerId () { return timerId ; }
	HWND GetHWnd () { return hWnd ; }
	TIMERPROC GetTimerFunc () { return lpTimerFunc ; }

	static Window *window ;
	static CMap <UINT_PTR,UINT_PTR,SnmpTimerObject *,SnmpTimerObject *> timerMap ;
	static void TimerNotification ( HWND hWnd , UINT timerId ) ;

} ;

class SnmpTimerEventObject : public SnmpTaskObject
{
private:
protected:

	SnmpTimerEventObject () {} 

public:

	virtual ~SnmpTimerEventObject () {} ;
} ;

class SnmpSetTimerObject : public SnmpTimerEventObject
{
private:

	UINT_PTR timerId ;
	HWND hWnd ;
	UINT elapsedTime ;
	TIMERPROC lpTimerFunc ;

protected:
public:

	SnmpSetTimerObject (

		HWND hWnd,				// handle of window for timer messages
		UINT_PTR nIDEvent,			// timer identifier
		UINT uElapse,			// time-out value
		TIMERPROC lpTimerFunc	// address of timer procedure
   ) ;

	~SnmpSetTimerObject () ;

	UINT_PTR GetTimerId () { return timerId ; }

	void Process () ;
} ;

class SnmpKillTimerObject : public SnmpTimerEventObject
{
private:

	BOOL status ;
	HWND hWnd ;
	UINT_PTR timerId ;

protected:
public:

	SnmpKillTimerObject (

		HWND hWnd ,				// handle of window that installed timer
		UINT_PTR uIDEvent			// timer identifier
	) ;

	~SnmpKillTimerObject () {} ;

	void Process () ;

	BOOL GetStatus () { return status ; }
} ;

UINT_PTR SnmpSetTimer (

	HWND hWnd,				// handle of window for timer messages
	UINT_PTR nIDEvent,			// timer identifier
	UINT uElapse,			// time-out value,
	TIMERPROC lpTimerFunc 	// address of timer procedure
) ;

BOOL SnmpKillTimer (

    HWND hWnd,		// handle of window that installed timer
    UINT_PTR uIDEvent 	// timer identifier
) ;

#endif // __TIMER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\trap.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __TRAP_MANAGEMENT__
#define __TRAP_MANAGEMENT__

//#include <snmpevt.h>
//#include <snmpthrd.h>

class SnmpClTrapThreadObject;

class DllImportExport SnmpTrapReceiver
{
friend SnmpWinSnmpTrapSession;	//needs access to m_cRef.
private:
	
	BOOL			m_bregistered;
	LONG			m_cRef;

protected:
	
					SnmpTrapReceiver ();

public:

	virtual void	Receive(SnmpTransportAddress &sender_addr,
								SnmpSecurity &security_context,
								SnmpVarBindList &vbList) = 0;

	BOOL			IsRegistered() { return m_bregistered; }

	BOOL			DestroyReceiver();

					~SnmpTrapReceiver ();

};


class SnmpTrapReceiverStore
{
private:

	CRITICAL_SECTION	m_Lock;
	void*				m_HandledRxStack;
	void*				m_UnHandledRxStack;

	void			Lock();
	void			Unlock();

public:

			SnmpTrapReceiverStore();

	BOOL				Add(SnmpTrapReceiver* receiver);
	BOOL				Delete(SnmpTrapReceiver* receiver);
	BOOL				IsEmpty();
	SnmpTrapReceiver*	GetNext();


			~SnmpTrapReceiverStore();
};


class SnmpTrapManager
{
friend SnmpWinSnmpTrapSession;	//needs access to m_receivers.

private:

	BOOL					m_bListening;
	SnmpWinSnmpTrapSession*	m_trapSession;
	SnmpTrapReceiverStore	m_receivers;
	SnmpClTrapThreadObject*		m_trapThread;


public:
		SnmpTrapManager ();

	BOOL	RegisterReceiver (SnmpTrapReceiver *trapRx);
	BOOL	UnRegisterReceiver (SnmpTrapReceiver *trapRx);
	BOOL	IsListening() const { return m_bListening; }

		~SnmpTrapManager ();

	static SnmpTrapManager *s_TrapMngrPtr;
};



#endif //__TRAP_MANAGEMENT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\trapsess.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __TRAP_SESSION__
#define __TRAP_SESSION__


#define TRAP_EVENT		(WM_USER+1)

class SnmpWinSnmpTrapSession : private Window
{

private:

	SnmpTrapManager*	m_managerPtr;
	BOOL				m_bValid;
	HSNMP_SESSION		m_session_handle;
	BOOL				m_bDestroy;
	LONG				m_cRef;
	
	BOOL	RegisterForAllTraps ();


public:

		SnmpWinSnmpTrapSession (SnmpTrapManager* managerPtr);
	
	BOOL	PostMessage (UINT user_msg_id, WPARAM wParam, LPARAM lParam);
	LONG_PTR	HandleEvent (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	HWND	GetWindowHandle() { return Window::GetWindowHandle(); }
	void*	operator()() const { return ( m_bValid ? (void*)this : NULL ); }
	BOOL	DestroySession();

		~SnmpWinSnmpTrapSession ();
};

class SnmpTrapTaskObject : public SnmpTaskObject
{
private:

	SnmpTrapManager*		m_mptr;
	SnmpWinSnmpTrapSession** m_pptrapsess;

public:

	SnmpTrapTaskObject (SnmpTrapManager* managerPtr, SnmpWinSnmpTrapSession** pptrapsess);
	~SnmpTrapTaskObject () {}

	void Process ();
};


#endif //__TRAP_SESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\transp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: transp.hpp  (transport.hpp)
Author: B.Rajeev
Purpose: Provides declarations for the SnmpTransport class
		and its derivatives
--------------------------------------------------*/

#ifndef __TRANSPORT__
#define __TRANSPORT__

#include "forward.h"
#include "address.h"

#pragma warning (disable:4355)

class DllImportExport SnmpTransport
{
private:

	SnmpTransportAddress *transport_address;

	// the "=" operator and the copy constructor have been
	// made private to prevent any copies from being made
	SnmpTransport &operator=(IN const SnmpTransport &transport)
	{
		return *this;
	}

	SnmpTransport(IN const SnmpTransport &snmp_transport) {}

protected:

	SnmpTransport(IN SnmpSession &session,
		IN const SnmpTransportAddress &transportAddress); 

	virtual void TransportFlowControlOn() = 0;

	virtual void TransportFlowControlOff() = 0;

public:

	virtual ~SnmpTransport();
	

	virtual void TransportSendFrame(
		
		OUT TransportFrameId &transport_frame_id, 
		IN SnmpPdu &snmpPdu
		
	) = 0 ;

	virtual void TransportReceiveFrame (

		IN SnmpPdu &snmpPdu,
		IN SnmpErrorReport &errorReport 

	) = 0 ;

	virtual void TransportSentFrame (

		IN TransportFrameId transport_frame_id,  
        IN SnmpErrorReport &errorReport 

	)  = 0;

	virtual SnmpTransportAddress &GetTransportAddress() ;

	virtual void * operator()(void) const = 0;

};

// forward declaration
class TransportSession;

class DllImportExport SnmpImpTransport: public SnmpTransport
{
	friend TransportWindow;

private:

	BOOL transport_created;
	SnmpSession &session;
	TransportWindow *transport;

	// References to the following instances are used instead of 
	// embedded instances themselves. This is done to avoid including
	// the header files providing their declaration
	
	TransportSentStateStore store;
	static TransportFrameId next_transport_frame_id;

protected:

	BOOL is_valid;

	virtual void HandleSentFrame(IN const TransportFrameId transport_frame_id);
	
	void TransportFlowControlOn() {}

	void TransportFlowControlOff() {}

public:

	SnmpImpTransport(IN SnmpSession &session,
					   IN const SnmpTransportAddress &address);

	~SnmpImpTransport();

	void TransportSendFrame (  

        OUT TransportFrameId &transport_frame_id,
		IN SnmpPdu &snmpPdu
	) ;

	void TransportReceiveFrame (

		IN SnmpPdu &snmpPdu ,
		IN SnmpErrorReport &errorReport 
	) ;

	void TransportSentFrame (

        IN TransportFrameId transport_frame_id,  
        IN SnmpErrorReport &errorReport 

    );

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

};

class DllImportExport SnmpUdpIpTransport: public SnmpImpTransport
{
private:
protected:
public:

	SnmpUdpIpTransport(IN SnmpSession &session,
					   IN const SnmpTransportIpAddress &ipAddress);
};

class DllImportExport SnmpUdpIpImp : public SnmpTransportIpAddress , 
					 public SnmpUdpIpTransport 
{
public:

	SnmpUdpIpImp(IN SnmpSession &session,
				 IN const char *address,
				 IN const ULONG addressResolution = SNMP_ADDRESS_RESOLVE_VALUE )
				 : SnmpTransportIpAddress(address,addressResolution),
				   SnmpUdpIpTransport(session, *this)
	{}

	SnmpUdpIpImp(IN SnmpSession &session,
				 IN const UCHAR *address)
				 : SnmpTransportIpAddress(address, SNMP_IP_ADDR_LEN),
				   SnmpUdpIpTransport(session, *this)
	{}
	
	SnmpUdpIpImp(IN SnmpSession &session,
				 IN const SnmpTransportIpAddress &address)
				 : SnmpTransportIpAddress(address),				   
				   SnmpUdpIpTransport(session, *this)
	{}

	void * operator()(void) const;
	
	~SnmpUdpIpImp() {}
} ;

class DllImportExport SnmpIpxTransport: public SnmpImpTransport
{
private:
protected:
public:

	SnmpIpxTransport(IN SnmpSession &session,
					   IN const SnmpTransportIpxAddress &ipxAddress);
};

class DllImportExport SnmpIpxImp : public SnmpTransportIpxAddress , 
					 public SnmpIpxTransport 
{
public:

	SnmpIpxImp(IN SnmpSession &session,
				 IN const char *address
				 )
				 : SnmpTransportIpxAddress(address),
				   SnmpIpxTransport(session, *this)
	{}

	SnmpIpxImp(IN SnmpSession &session,
				 IN const UCHAR *address)
				 : SnmpTransportIpxAddress(address, SNMP_IPX_ADDR_LEN),
				   SnmpIpxTransport(session, *this)
	{}
	
	SnmpIpxImp(IN SnmpSession &session,
				 IN const SnmpTransportIpxAddress &address)
				 : SnmpTransportIpxAddress(address),				   
				   SnmpIpxTransport(session, *this)
	{}

	void * operator()(void) const;
	
	~SnmpIpxImp() {}
} ;

#pragma warning (default:4355)

#endif // __TRANSPORT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\tsess.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: tsess.hpp
Author: B.Rajeev
Purpose: Provides declarations for the TransportSession class
--------------------------------------------------*/

#ifndef __TRANSPORT_SESSION__
#define __TRANSPORT_SESSION__

#include "wsess.h"

class WinSnmpVariables
{
public:

	HSNMP_ENTITY m_SrcEntity ;
	HSNMP_ENTITY m_DstEntity ;
	HSNMP_CONTEXT m_Context ;
	HSNMP_PDU m_Pdu;
	HSNMP_VBL m_Vbl;
	ULONG m_RequestId ;
} ;

/*---------------------------------------------------------------
Overview: The TransportSession class provides an abstraction for a 
WinSNMP session and a window message queue (both are available through
the WinSnmpSession class). The SnmpUdpIpTransport class uses it 
for services such as sending a PDU, posting window messages for 
internal events and receiving a reply and notifying the 
SnmpUdpIpTransport instance ("owner") of the receipt as well 
as internal events.
-------------------------------------------------------------*/

class TransportWindow : public Window
{
	SnmpImpTransport &owner;
	HSNMP_SESSION m_Session ;

	// over-rides the HandleEvent method provided by the
	// WinSnmpSession. Receives the Pdu and passes it to
	// the owner (SnmpTransport)

	LONG_PTR HandleEvent (

		HWND hWnd ,
		UINT message ,
		WPARAM wParam ,
		LPARAM lParam
	);

	BOOL ReceivePdu ( SnmpPdu &a_Pdu ) ;

public:

	TransportWindow (

		SnmpImpTransport &owner
	);

	~TransportWindow () ;

	BOOL SendPdu ( SnmpPdu &a_Pdu ) ;

};

#endif // __TRANSPORT_SESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\tsent.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: tsent.hpp
Author: B.Rajeev
Purpose: Provides declarations for the TransportSentStateStore class
--------------------------------------------------*/

#ifndef __TRANSPORT_SENT_STATE_STORE
#define __TRANSPORT_SENT_STATE_STORE

#include "common.h"
#include "forward.h"

/*---------------------------------------------------------------
Overview: The SnmpUdpIpTransport must call the SnmpSession instance
back with the status of each transmission attempt. Therefore, 
the transport instance registers an error report 
(Snmp_Success, Snmp_No_Error) for the transport_frame_id and posts 
a SENT_FRAME_EVENT before transmission. This is done in order to 
ensure that the sent frame window message is queued before a reply 
(and consequently a window message) is received. in case of an 
error in transmission, the error report is modified to reflect the 
nature of the error. When the SENT_FRAME_EVENT is processed, the 
SnmpSession instance is called back with the error report for the 
transport_frame_id. 

The TransportSentStateStore stores the above mentioned error reports.
-------------------------------------------------------------*/
  
class TransportSentStateStore
{
	typedef CMap<TransportFrameId, TransportFrameId, SnmpErrorReport *, SnmpErrorReport *> Store;

	Store store;

public:

		void Register(IN TransportFrameId id, 
					  IN const SnmpErrorReport &error_report);

		void Modify(IN TransportFrameId id,
					IN const SnmpErrorReport &error_report);

		SnmpErrorReport Remove(IN TransportFrameId id);

		~TransportSentStateStore(void);
};


#endif // __TRANSPORT_SENT_STATE_STORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\vbl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*-------------------------------------------------
filename: vbl.hpp
author: B.Rajeev
purpose: To provide declarations for the VBList class.
		 It encapsulates an association between a
		 VarBindList and a winSNMP VBL.
------------------------------------------------*/


#ifndef __VBL__
#define __VBL__

#include "forward.h"
#include "encap.h"
#include "common.h"
#include "encdec.h"
#include "vblist.h"

#define WinSNMPSession HSNMP_SESSION

// Given a var_bind_list creates a WinSnmpVbl. It supports deletion 
// of variable bindings by their index. This deletes the 
// binding from both var_bind_list and the WinSnmpVbl. 
// It also allows direct access to the var_bind_list and the WinSnmpVbl
// for convenience

class VBList
{
	ULONG m_Index ;
	SnmpVarBindList *var_bind_list;

public:

	VBList (

		IN SnmpEncodeDecode &a_SnmpEncodeDecode , 
		IN SnmpVarBindList &var_bind_list,
		IN ULONG index 
	);

	~VBList(void);

	// the two Get functions provide direct access to the
	// VarBindList and the WinSnmpVbl
	SnmpVarBindList &GetVarBindList(void) { return *var_bind_list; }

	ULONG GetIndex () { return m_Index ; }

	// deletes the specified variable binding from both the
	// var_bind_list and the WinSnmpVbl. returns a copy of the
	// deleted VarBind
	SnmpVarBind *Remove(IN UINT vbl_index);

	// gets the specified variable binding from both the
	// var_bind_list and the WinSnmpVbl. returns a copy of the
	// deleted VarBind
	SnmpVarBind *Get (IN UINT vbl_index);

	// deletes the specified variable binding from both the
	// var_bind_list and the WinSnmpVbl. 
	void Delete (IN UINT vbl_index);

};

#endif // __VBL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\value.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*-----------------------------------------------------------------
Filename: value.hpp
Purpose	: To specify the classes of various Snmp values and instance
		  identifiers. These classes represent the different types of 
		  values for variables that may populate a MIB. 
Written By:	B.Rajeev
-----------------------------------------------------------------*/


#ifndef __VALUE__
#define __VALUE__

/*-----------------------------------------------------------------
General Overview:
	A variable instance refers to a MIB object, e.g. 
	1.3.6.1.2.1.1.1.0 or 1.3.6.1.2.1.2.1.2.1. The instance is 
	encoded as an SNMP object identifier and is represented by the 
	class SnmpObjectIdentifier. 

  The classes derived from SnmpValue represent the encoding of the 
  information stored within the MIB object. The value is encoded 
  as an implementation of the abstract class SnmpValue. The SNMP 
  class library implements the following derivations of SnmpValue 
  which refer to SNMP BER encoded types.

		SnmpNull
		SnmpInteger
		SnmpCounter32
		SnmpCounter64
		SnmpGauge
		SnmpTimeTicks
		SnmpIPAddress
		SnmpNetworkAddress
		SnmpBitString
		SnmpOctetString
		SnmpOpaque
		SnmpObjectIdentifier

  All the implemented classes provide (in addition to others) -
  1. Constructors to initialize using relevant values or another
	instance of the same class.

  2. GetValue, SetValue methods for obtaining and setting
	relevant values.

  3. "=" operator to over-ride the default assignment operator and
	 an Equivalent method to check for equivalence between two instances
	 of the same (derived) class

  4. Copy methods for obtaining a copy of a specified instance of
	the class.


  note of caution:
  ----------------
		Some of the GetValue functions return pointers
  to dynamically allocated data. Users of the class must make copies
  of the returned values and must not rely on the integrity of this
  pointer or values obtained through it in future (because of 
  SetValue methods, or destruction of corresponding SnmpValue class) 
-----------------------------------------------------------------*/

#include <provexpt.h>


// Abstract class at the root of all Snmp Values


class DllImportExport SnmpValue 
{
	// the "=" operator and the copy constructor have been
	// made private to prevent copies of the SnmpValue instance
	// from being made
	SnmpValue &operator=(IN const SnmpValue &) 
	{
		return *this;
	}

	SnmpValue(IN const SnmpValue &snmp_value) {}

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const = 0;
	SnmpValue() {}

public:

	virtual SnmpValue *Copy () const = 0 ;

	BOOL operator==(IN const SnmpValue &value) const
	{
		return Equivalent(value) ;
	}

	BOOL operator!=(IN const SnmpValue &value) const
	{
		return !((*this) == value) ;
	}

	virtual ~SnmpValue() {}
} ;


// Enables null values for required variables. Its a concrete class
// with dummy constructor and destructors to enable specification of
// null values
class DllImportExport SnmpNull : public SnmpValue
{
protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	// dummy constructor and destructor
	SnmpNull() {}

	~SnmpNull() {}

	SnmpValue &operator=(IN const SnmpNull &to_copy) 
	{
		return *this;
	}

	SnmpValue *Copy() const { return new SnmpNull; }
};


// Allows integer values to be specified
class DllImportExport SnmpInteger : public SnmpValue 
{
private:

	LONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpInteger ( IN const LONG value ) : val(value) {}
	SnmpInteger ( IN const SnmpInteger &value );

	~SnmpInteger () {}

	LONG GetValue () const;

	void SetValue ( IN const LONG value );

	SnmpValue &operator=(IN const SnmpInteger &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpInteger &snmp_integer)	const
	{
		if ( val == snmp_integer.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

	SnmpValue *Copy () const;
} ;

// Encapsulates gauge value
class DllImportExport SnmpGauge : public SnmpValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpGauge ( IN const LONG value ) : val(value) {}
	SnmpGauge ( IN const SnmpGauge &value );
	~SnmpGauge () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpGauge &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpGauge &snmp_gauge)	const
	{
		if ( val == snmp_gauge.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates Counter values
class DllImportExport SnmpCounter : public SnmpValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpCounter ( IN const ULONG value ) : val(value) {}
	SnmpCounter ( IN const SnmpCounter &value );

	~SnmpCounter () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpCounter &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpCounter &snmp_counter)	const
	{
		if ( val == snmp_counter.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates Time Ticks (since an earlier event)
class DllImportExport SnmpTimeTicks : public SnmpValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpTimeTicks ( IN const ULONG value ) : val(value) {}
	SnmpTimeTicks ( IN const SnmpTimeTicks &value );

	~SnmpTimeTicks () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpTimeTicks &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpTimeTicks &snmp_time_ticks) const
	{
		if ( val == snmp_time_ticks.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates octet strings that do not have any terminator.
// The octet string is specified by the pair (val,length) where
// 'val' is a pointer to heap data and 'length' provides the number
// of octets in the data string.
class DllImportExport SnmpOctetString : public SnmpValue
{
private:

	// in case a new 'value' string has the same length as the stored
	// string, the stored string may be overwritten. this avoids
	// having to allocate and deallocate heap memory for the purpose.
	void OverWrite(IN const UCHAR *value);

protected:

	BOOL is_valid;
	UCHAR *val;
	ULONG length;

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;
	virtual void Initialize(IN const UCHAR *value, IN const ULONG valueLength);

	
	// The Replicate and UnReplicate methods allocate and deallocate
	// heap data. Replicate also copies the contents of the parameter
	// 'value' onto the allocated memory. This function may be 
	// implemented different and, thus, the methods have been declared
	// virtual.
	virtual UCHAR *Replicate(IN const UCHAR *value, IN const ULONG valueLength);

	virtual void UnReplicate(UCHAR *value);

public:

	SnmpOctetString ( IN const UCHAR *value , IN const ULONG valueLength );

	SnmpOctetString ( IN const SnmpOctetString &value );

	~SnmpOctetString ();

	void SetValue ( IN const UCHAR *value , IN const ULONG valueLength );

	ULONG GetValueLength () const;
	UCHAR *GetValue () const;

	SnmpValue *Copy () const;


	SnmpValue &operator=(IN const SnmpOctetString &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	BOOL Equivalent(IN const SnmpOctetString &snmp_octet_string) const;
} ;

// OpaqueValue class encapsulates octet strings
class DllImportExport SnmpOpaque : public SnmpValue
{
private:
	SnmpOctetString *octet_string;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpOpaque ( IN const UCHAR *value , IN const ULONG valueLength ) : octet_string ( NULL )
	{
		octet_string = new SnmpOctetString(value, valueLength);
	}

	SnmpOpaque ( IN const SnmpOpaque &value ) : octet_string ( NULL )
	{
		octet_string = new SnmpOctetString(value.GetValue(), value.GetValueLength());
	}
	
	~SnmpOpaque()
	{
		delete octet_string;
	}

	void SetValue ( IN const UCHAR *value , IN const ULONG valueLength )
	{
		octet_string->SetValue(value, valueLength);
	}

	ULONG GetValueLength () const
	{
		return octet_string->GetValueLength();
	}

	UCHAR *GetValue () const
	{
		return octet_string->GetValue();
	}


	SnmpValue &operator=(IN const SnmpOpaque &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	SnmpValue *Copy () const
	{
		return new SnmpOpaque(octet_string->GetValue(),
							  octet_string->GetValueLength());
	}

	void * operator()(void) const
	{
		return (*octet_string)();
	}


	BOOL Equivalent(IN const SnmpOpaque &snmp_opaque) const
	{
		return octet_string->Equivalent(*(snmp_opaque.octet_string));
	}
};

#define DEFAULT_OBJECTIDENTIFIER_LENGTH 32

// Encapsulates the object identifier. An object identifier 
// identifies a MIB object instance
class DllImportExport SnmpObjectIdentifier : public SnmpValue
{
	
	// describes the legal values for a comparison
	enum Comparison {LESS_THAN, EQUAL_TO, GREATER_THAN};

private:

	BOOL is_valid;
	ULONG m_value[DEFAULT_OBJECTIDENTIFIER_LENGTH];
	ULONG *val;
	ULONG length;

	// in case a new 'value' string has the same length as the stored
	// string, the stored string may be overwritten. this avoids
	// having to allocate and deallocate heap memory for the purpose.
	void OverWrite(IN const ULONG *value);

protected:
	
	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;
	virtual void Initialize(IN const ULONG *value, IN const ULONG valueLength);

	
	// The Replicate and UnReplicate methods allocate and deallocate
	// heap data. Replicate also copies the contents of the parameter
	// 'value' onto the allocated memory. This function may be 
	// implemented different and, thus, the methods have been declared
	// virtual.
	virtual ULONG *Replicate(IN const ULONG *value, IN const ULONG valueLength) const;

	// Allocates enough memory to copy the first value followed by
	// the second value to be copied, thus, appending the two values
	virtual ULONG *Replicate(IN const ULONG *first_value, IN const ULONG first_length,
							 IN const ULONG *second_value, IN const ULONG second_length) const;

	virtual void UnReplicate(ULONG *value);

	// This single function
	Comparison Compare(IN const SnmpObjectIdentifier &first, 
					   IN const SnmpObjectIdentifier &second) const;

	BOOL Equivalent(IN const SnmpObjectIdentifier &value) const;

public:

	SnmpObjectIdentifier ( IN const ULONG *value , IN const ULONG valueLength );

	SnmpObjectIdentifier ( IN const char *value );

	SnmpObjectIdentifier ( IN const SnmpObjectIdentifier &value );

	~SnmpObjectIdentifier ();

	void SetValue ( IN const ULONG *value , IN const ULONG valueLength );

	ULONG GetValueLength () const;
	ULONG *GetValue () const;

	SnmpValue *Copy () const;

	BOOL Equivalent(IN const SnmpObjectIdentifier &value,
					 IN ULONG max_length) const;
	
	BOOL operator<(IN const SnmpObjectIdentifier &value)	const
	{
		return (Compare(*this,value) == LESS_THAN)?TRUE:FALSE;

	}

	BOOL operator>(IN const SnmpObjectIdentifier &value)	const
	{
		return (Compare(*this,value) == GREATER_THAN)?TRUE:FALSE;
	}

	BOOL operator<=(IN const SnmpObjectIdentifier &value) const
	{
		return !(*this > value);
	}

	BOOL operator>=(IN const SnmpObjectIdentifier &value) const
	{
		return !(*this < value);
	}

	BOOL operator==(IN const SnmpObjectIdentifier &value) const
	{
		if ( this->GetValueLength() == value.GetValueLength() )
			return Equivalent(value) ;
		else
			return FALSE;
	}

	BOOL operator!=(IN const SnmpObjectIdentifier &value) const
	{
		return !(*this == value);
	}
	
	SnmpObjectIdentifier operator+ ( IN const SnmpObjectIdentifier &value ) const;

	BOOL Prefix( IN ULONG index, SnmpObjectIdentifier &prefix ) const
	{
		if ( index >= length )
			return FALSE;
		
		prefix.UnReplicate (val) ;
		prefix.Initialize (val, index+1) ;
		return TRUE ;
	}

	BOOL Suffix ( IN ULONG index , SnmpObjectIdentifier &suffix ) const
	{
		if ( index >= length )
			return FALSE;

		suffix.UnReplicate (val) ;
		suffix.Initialize ( val+index, length-index ) ;
		return TRUE ;
	}

	SnmpObjectIdentifier *Cut (SnmpObjectIdentifier &value) const;


	ULONG &operator [] ( IN const ULONG index ) const;


	SnmpValue &operator=(IN const SnmpObjectIdentifier &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	char *GetAllocatedString() const;
} ;


// encapsulates an ip address. represents the 32 bit value in a ULONG
class DllImportExport SnmpIpAddress : public SnmpValue 
{
private:

	// if the dotted decimal representation passed to the constructor
	// is ill-formed, the instance may be invalid
	BOOL is_valid;
	ULONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpIpAddress ( IN const ULONG value )
		:val(value), is_valid(TRUE)
	{}

	// a dotted decimal representation is parsed to obtain the 32 bit value
	SnmpIpAddress ( IN const char *value ) ;

	SnmpIpAddress ( IN const SnmpIpAddress &value );

	~SnmpIpAddress () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpIpAddress &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	BOOL Equivalent(IN const SnmpIpAddress &snmp_ip_address) const
	{
		if ( is_valid && snmp_ip_address() )
			return ( val == snmp_ip_address.GetValue() );
		else
			return FALSE;
	}

} ;

// Encapsulates UInteger32 value
class DllImportExport SnmpUInteger32 : public SnmpValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpUInteger32 ( IN const LONG value ) : val(value) {}
	SnmpUInteger32 ( IN const SnmpUInteger32 &value );
	~SnmpUInteger32 () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpUInteger32 &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpUInteger32 &snmp_integer)	const
	{
		if ( val == snmp_integer.GetValue() )
			return TRUE;
		else
			return FALSE;
	}
} ;


// Encapsulates Counter64 values
class DllImportExport SnmpCounter64 : public SnmpValue 
{
private:

	ULONG lval;
	ULONG hval;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpCounter64 ( IN const ULONG lvalue , IN const ULONG hvalue ) : lval(lvalue),hval(hvalue) {}
	SnmpCounter64 ( IN const SnmpCounter64 &value );

	~SnmpCounter64 () {}

	ULONG GetLowValue () const;
	ULONG GetHighValue () const;

	void SetValue ( IN const ULONG lvalue , IN const ULONG hvalue );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpCounter64 &to_copy) 
	{
		SetValue(to_copy.GetLowValue(),to_copy.GetHighValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpCounter64 &snmp_counter )	const
	{
		if ( ( lval == snmp_counter.GetLowValue() ) && ( hval == snmp_counter.GetHighValue() ) )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates EndOfMibView values
class DllImportExport SnmpEndOfMibView : public SnmpValue 
{
private:
protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpEndOfMibView () {} ;
	~SnmpEndOfMibView () {} ;

	SnmpValue *Copy () const { return new SnmpEndOfMibView ; }

	SnmpValue &operator=(IN const SnmpEndOfMibView &to_copy) 
	{
		return *this;
	}

} ;

// Encapsulates NoSuchObject values
class DllImportExport SnmpNoSuchObject: public SnmpValue 
{
private:
protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpNoSuchObject () {} ;
	~SnmpNoSuchObject () {} ;

	SnmpValue *Copy () const { return new SnmpNoSuchObject ; }

	SnmpValue &operator=(IN const SnmpNoSuchObject &to_copy) 
	{
		return *this;
	}

} ;

// Encapsulates NoSuchInstance values
class DllImportExport SnmpNoSuchInstance: public SnmpValue 
{
private:
protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpNoSuchInstance () {} ;
	~SnmpNoSuchInstance () {} ;

	SnmpValue *Copy () const { return new SnmpNoSuchInstance ; }

	SnmpValue &operator=(IN const SnmpNoSuchInstance &to_copy) 
	{
		return *this;
	}
} ;


#endif // __VALUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\winforw.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __WIN_SNMP_FORWARD__
#define __WIN_SNMP_FORWARD__


typedef WinSnmpInteger;
typedef WinSnmpInteger32;
typedef WinSnmpPdu;
typedef WinSnmpVbl;
typedef WinSnmpOctetArray;


#endif __WIN_SNMP_FORWARD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\wsess.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: wsess.hpp
Written By:	B.Rajeev
Purpose	: To provide declarations of the WinSnmpSession class 
----------------------------------------------------------*/

#ifndef __WINSNMPSESSION__
#define __WINSNMPSESSION__

#include "common.h"
#include "window.h"

#endif // __WINSNMPSESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\vblist.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: vblist.hpp
Written By:	B.Rajeev
Purpose	: To provide declarations of classes for
		  manipulating variable bindings 
		  (object identifier, SNMP value).
----------------------------------------------------------*/

#ifndef __VBLIST__
#define __VBLIST__

#define ILLEGAL_INDEX -1

#include <provexpt.h>

#include "value.h"

// encapsulates a variable binding, that is, a pair
// consisting of an SnmpObjectIdentifier and a corresponding
// SnmpValue

class DllImportExport SnmpVarBind
{
private:

	SnmpObjectIdentifier *identifier;
	SnmpValue *val;

protected:

	virtual void Replicate(IN const SnmpObjectIdentifier &instance,
			 			   IN const SnmpValue &value)
	{
		identifier = (SnmpObjectIdentifier *)instance.Copy();
		val = value.Copy();
	}

public:

	SnmpVarBind(IN const SnmpObjectIdentifier &instance,
			IN const SnmpValue &value) :
			identifier ( NULL ),
			val ( NULL )
	{
		Replicate(instance, value);
	}

	SnmpVarBind(IN const SnmpVarBind &varbind) :
			identifier ( NULL ),
			val ( NULL )
	{
		Replicate(varbind.GetInstance(), varbind.GetValue());
	}

	virtual ~SnmpVarBind()
	{
		delete identifier;
		delete val;
	}

	SnmpObjectIdentifier &GetInstance() const
	{
		return *identifier;
	}

	SnmpValue &GetValue() const
	{
		return *val;
	}

	SnmpVarBind &operator=(IN const SnmpVarBind &var_bind)
	{
		(*identifier) = var_bind.GetInstance();

		delete val;
		val = NULL ;
		val = var_bind.GetValue().Copy();

		return *this;
	}
};

// represents a node in the SnmpVarBindList and stores a varbind

class DllImportExport  SnmpVarBindListNode
{
private:

	SnmpVarBind *varbind;

protected:

	SnmpVarBindListNode *previous;
	SnmpVarBindListNode *next;

public:

	SnmpVarBindListNode(const SnmpVarBind *varbind);

	SnmpVarBindListNode(const SnmpVarBind &varbind);

	SnmpVarBindListNode(SnmpVarBind &varbind);

	~SnmpVarBindListNode()
	{
		// free the varbind if it isn't NULL
		if ( varbind != NULL )
			delete varbind;
	}

	void SetPrevious(SnmpVarBindListNode *new_previous)
	{
		previous = new_previous;
	}

	void SetNext(SnmpVarBindListNode *new_next)
	{
		next = new_next;
	}

	SnmpVarBindListNode *GetPrevious()
	{
		return previous;
	}

	SnmpVarBindListNode *GetNext()
	{
		return next;
	}	

	SnmpVarBind *GetVarBind()
	{
		return varbind;
	}

};


// a circular list of SnmpVarBindListNodes, each storing an 
// SnmpVarBind. it has a dummy head

class DllImportExport SnmpVarBindList
{
	typedef ULONG PositionHandle;

	struct PositionInfo
	{
	public:

		SnmpVarBindListNode *current_node;
		int current_index;

		PositionInfo(SnmpVarBindListNode *current_node,
						int current_index)
		{
			PositionInfo::current_node = current_node;
			PositionInfo::current_index = current_index;
		}
	};	
	
	class ListPosition
	{	
		PositionHandle position_handle;
		SnmpVarBindList *vblist;

	public:

		ListPosition(PositionHandle position_handle,
					SnmpVarBindList *vblist)
		{
			ListPosition::position_handle = position_handle;
			ListPosition::vblist = vblist;
		}

		PositionHandle GetPosition() { return position_handle;}

		SnmpVarBindList *GetList() { return vblist;}

		~ListPosition();

	};

	friend class ListPosition;

	class LookupTable : public CMap<PositionHandle, PositionHandle, PositionInfo * , PositionInfo * >
	{
	};

protected:

	UINT length;
	SnmpVarBindListNode head;
	SnmpVarBindListNode *current_node;
	int current_index;

	PositionHandle next_position_handle;
	LookupTable lookup_table;

	void EmptyLookupTable(void);

	// to set the current_node to the specified distance
	// from the specified node
	void GoForward(SnmpVarBindListNode *current, UINT distance);

	void GoBackward(SnmpVarBindListNode *current, UINT distance);

	// if able to point the current_node at the specified
	// index, returns TRUE, else FALSE
	BOOL GotoIndex(UINT index);

	// inserts the new_node just before the specified node
    void Insert(SnmpVarBindListNode *current, SnmpVarBindListNode *new_node);

    // if 'current' does not point to the head of the list, it
    // deletes the node pointed at by current. Otherwise error
    void Release(SnmpVarBindListNode *current);

	ListPosition *GetPosition();

	void GotoPosition(ListPosition *list_position);

	void DestroyPosition(ListPosition *list_position);

	void Initialize(IN SnmpVarBindList &varBindList);

	void FreeList();

             
public:

	SnmpVarBindList();

	SnmpVarBindList(IN SnmpVarBindList &varBindList);

	~SnmpVarBindList();

	SnmpVarBindList *CopySegment(IN const UINT segment_size);

	UINT GetLength(void) const { return length; }

	BOOL Empty(void) const { return ( (length==0)?TRUE:FALSE ); }

	int GetCurrentIndex(void) const { return current_index; }

	void Add(IN const SnmpVarBind &varBind)
	{
		Insert(&head,
			   new SnmpVarBindListNode(varBind));
		length++;
	}

	void AddNoReallocate (IN SnmpVarBind &varBind)
	{
		Insert(&head,
			   new SnmpVarBindListNode(varBind));
		length++;
	}

	void Remove();

	SnmpVarBind *operator[](IN const UINT index)
	{
		if ( GotoIndex(index) )
			return current_node->GetVarBind();
		else
			return NULL;
	}

	const SnmpVarBind *Get() const
	{
		return current_node->GetVarBind();
	}

	void Reset()
	{
		current_node = &head;

		current_index = ILLEGAL_INDEX;
	}

	BOOL Next();

	SnmpVarBindList &operator=(IN SnmpVarBindList &vblist) ;

	SnmpVarBindList *Car ( const UINT index ) ;

	SnmpVarBindList *Cdr ( const UINT index ) ;
};

#endif // __VBLIST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\window.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------------
filename: window.hpp"
author: B.Rajeev
purpose: Provides declarations for the Window class.
--------------------------------------------------------*/

#ifndef __WINDOW__
#define __WINDOW__

#include "forward.h"
#include "common.h"
#include "sync.h"

// these are events shared by all winsnmp session derivatives
#define NULL_EVENT_ID			(WM_USER+1)
#define MESSAGE_ARRIVAL_EVENT	(WM_USER+2)
#define SENT_FRAME_EVENT		(WM_USER+3)
#define SEND_ERROR_EVENT		(WM_USER+4)
#define OPERATION_COMPLETED_EVENT (WM_USER+5)
#define DELETE_SESSION_EVENT	(WM_USER+6)
#define SNMP_WM_TIMER			(WM_USER+7)

#define DUMMY_TITLE "Dummy Window"

typedef CMap< HWND, HWND &, Window *, Window *& > WindowMapping;

// It creates a window and, when asked to, displays it if successful.
// Lets users check for success and obtain a handle to the window 

class Window
{
	BOOL is_valid;
	HWND window_handle;

    // serializes access to the WindowMapping
    static CriticalSection window_CriticalSection;

    // map to associate an HWND with an EventHandler.
	// this is shared by all EventHandlers
	static WindowMapping mapping;

	void Initialize (

		char *templateCode,
		WNDPROC EventHandler,
		BOOL display
	);

	static BOOL CreateCriticalSection () ;

	static void DestroyCriticalSection () ;

public:

	Window ( 

		char *templateCode = DUMMY_TITLE, 
		BOOL display = FALSE 
	) ;

	virtual ~Window(void);

	HWND GetWindowHandle(void) { return window_handle; }

	// it determines the corresponding EventHandler and calls it
	// with the appropriate parameters
	static LONG_PTR CALLBACK HandleGlobalEvent (

		HWND hWnd ,
		UINT message ,
		WPARAM wParam ,
		LPARAM lParam
	);

    static BOOL InitializeStaticComponents () ; 

	static void DestroyStaticComponents () ;

	// calls the default handler
	// a deriving class may override this, but
	// must call this method explicitly for default
	// case handling
	virtual LONG_PTR HandleEvent (

		HWND hWnd ,
		UINT message ,
		WPARAM wParam ,
		LPARAM lParam
	);

	BOOL PostMessage (

		UINT user_msg_id,
		WPARAM wParam, 
		LPARAM lParam
	);

	// lets users check if the window was successfully created
	virtual void * operator()(void) const
	{
		return ( (is_valid)?(void *)this:NULL );
	}

	static UINT g_SendErrorEvent ;
	static UINT g_OperationCompletedEvent ;
	static UINT g_TimerMessage ;
	static UINT g_DeleteSessionEvent ;
	static UINT g_MessageArrivalEvent ;
	static UINT g_SentFrameEvent ;
	static UINT g_NullEventId ;
};

#endif // __WINDOW__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\array_o.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <snmpcoll.h>

CObArray::CObArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CObArray::~CObArray()
{
    delete[] (BYTE*)m_pData;
}

void CObArray::SetSize(int nNewSize, int nGrowBy)
{
    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        delete[] (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
        m_pData = (CObject**) new BYTE[nNewSize * sizeof(CObject*)];

        memset(m_pData, 0, nNewSize * sizeof(CObject*));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(CObject*));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        CObject** pNewData = (CObject**) new BYTE[nNewMax * sizeof(CObject*)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(CObject*));

        // construct remaining elements
        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(CObject*));


        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

int CObArray::Append(const CObArray& src)
{
    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);

    memcpy(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(CObject*));

    return nOldSize;
}

void CObArray::Copy(const CObArray& src)
{
    SetSize(src.m_nSize);

    memcpy(m_pData, src.m_pData, src.m_nSize * sizeof(CObject*));
}

void CObArray::FreeExtra()
{
    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
        CObject** pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (CObject**) new BYTE[m_nSize * sizeof(CObject*)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(CObject*));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CObArray::SetAtGrow(int nIndex, CObject* newElement)
{
    if (nIndex >= m_nSize)
        SetSize(nIndex+1);
    m_pData[nIndex] = newElement;
}

void CObArray::InsertAt(int nIndex, CObject* newElement, int nCount)
{
    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(CObject*));

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(CObject*));

    }

    // insert new value in the gap
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CObArray::RemoveAt(int nIndex, int nCount)
{
    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(CObject*));
    m_nSize -= nCount;
}

void CObArray::InsertAt(int nStartIndex, CObArray* pNewArray)
{
    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

int CObArray::GetSize() const
    { return m_nSize; }
int CObArray::GetUpperBound() const
    { return m_nSize-1; }
void CObArray::RemoveAll()
    { SetSize(0); }
CObject* CObArray::GetAt(int nIndex) const
    { return m_pData[nIndex]; }
void CObArray::SetAt(int nIndex, CObject* newElement)
    { m_pData[nIndex] = newElement; }
CObject*& CObArray::ElementAt(int nIndex)
    { return m_pData[nIndex]; }
const CObject** CObArray::GetData() const
    { return (const CObject**)m_pData; }
CObject** CObArray::GetData()
    { return (CObject**)m_pData; }
int CObArray::Add(CObject* newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
CObject* CObArray::operator[](int nIndex) const
    { return GetAt(nIndex); }
CObject*& CObArray::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\mtcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include "snmpmt.h"

/////////////////////////////////////////////////////////////////////////////
// Basic synchronization object

CSyncObject::CSyncObject(LPCTSTR pstrName)
{
    m_hObject = NULL;
}

CSyncObject::~CSyncObject()
{
    if (m_hObject != NULL)
    {
        ::CloseHandle(m_hObject);
        m_hObject = NULL;
    }
}

BOOL CSyncObject::Lock(DWORD dwTimeout)
{
    if (::WaitForSingleObject(m_hObject, dwTimeout) == WAIT_OBJECT_0)
        return TRUE;
    else
        return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\plex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include "plex.h"


CPlex* CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
    CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
            // may throw exception
    p->nMax = nMax;
    p->nCur = 0;
    p->pNext = pHead;
    pHead = p;  // change head (adds in reverse order for simplicity)
    return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
    CPlex* p = this;
    while (p != NULL)
    {
        BYTE* bytes = (BYTE*) p;
        CPlex* pNext = p->pNext;
        delete bytes;
        p = pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\list_o.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized List
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <snmpcoll.h>

/////////////////////////////////////////////////////////////////////////////

CObList::CObList(int nBlockSize)
{
    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

void CObList::RemoveAll()
{
    // destroy elements

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

CObList::~CObList()
{
    RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
/*
 * Implementation note: CNode's are stored in CPlex blocks and
 *  chained together. Free blocks are maintained in a singly linked list
 *  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
 *  Used blocks are maintained in a doubly linked list using both 'pNext'
 *  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
 *   as the head/tail.
 *
 * We never free a CPlex block unless the List is destroyed or RemoveAll()
 *  is used - so the total number of CPlex blocks may grow large depending
 *  on the maximum past size of the list.
 */

CObList::CNode*
CObList::NewNode(CObList::CNode* pPrev, CObList::CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }

    CObList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;

    pNode->data = 0; // start with zero

    return pNode;
}

void CObList::FreeNode(CObList::CNode* pNode)
{
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////

POSITION CObList::AddHead(CObject* newElement)
{
    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (POSITION) pNewNode;
}

POSITION CObList::AddTail(CObject* newElement)
{
    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (POSITION) pNewNode;
}

void CObList::AddHead(CObList* pNewList)
{
    // add a list of same elements to head (maintain order)
    POSITION pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

void CObList::AddTail(CObList* pNewList)
{
    // add a list of same elements
    POSITION pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

CObject* CObList::RemoveHead()
{
    CNode* pOldNode = m_pNodeHead;
    CObject* returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

CObject* CObList::RemoveTail()
{
    CNode* pOldNode = m_pNodeTail;
    CObject* returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

POSITION CObList::InsertBefore(POSITION position, CObject* newElement)
{
    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (POSITION) pNewNode;
}

POSITION CObList::InsertAfter(POSITION position, CObject* newElement)
{
    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (POSITION) pNewNode;
}

void CObList::RemoveAt(POSITION position)
{
    CNode* pOldNode = (CNode*) position;

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}


/////////////////////////////////////////////////////////////////////////////
// slow operations

POSITION CObList::FindIndex(int nIndex) const
{
    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        pNode = pNode->pNext;
    }
    return (POSITION) pNode;
}

POSITION CObList::Find(CObject* searchValue, POSITION startAfter) const
{
    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (pNode->data == searchValue)
            return (POSITION) pNode;
    return NULL;
}


int CObList::GetCount() const
    { return m_nCount; }
BOOL CObList::IsEmpty() const
    { return m_nCount == 0; }
CObject*& CObList::GetHead()
    { return m_pNodeHead->data; }
CObject* CObList::GetHead() const
    { return m_pNodeHead->data; }
CObject*& CObList::GetTail()
    { return m_pNodeTail->data; }
CObject* CObList::GetTail() const
    { return m_pNodeTail->data; }
POSITION CObList::GetHeadPosition() const
    { return (POSITION) m_pNodeHead; }
POSITION CObList::GetTailPosition() const
    { return (POSITION) m_pNodeTail; }
CObject*& CObList::GetNext(POSITION& rPosition) // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
CObject* CObList::GetNext(POSITION& rPosition) const // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
CObject*& CObList::GetPrev(POSITION& rPosition) // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
CObject* CObList::GetPrev(POSITION& rPosition) const // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
CObject*& CObList::GetAt(POSITION position)
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
CObject* CObList::GetAt(POSITION position) const
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
void CObList::SetAt(POSITION pos, CObject* newElement)
    { CNode* pNode = (CNode*) pos;
        pNode->data = newElement; }


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\mtex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include <snmpmt.h>

/////////////////////////////////////////////////////////////////////////////
// CSemaphore

CSemaphore::CSemaphore(LONG lInitialCount, LONG lMaxCount,
    LPCTSTR pstrName, LPSECURITY_ATTRIBUTES lpsaAttributes)
    :  CSyncObject(pstrName)
{
    m_hObject = ::CreateSemaphore(lpsaAttributes, lInitialCount, lMaxCount,
        pstrName);
}

CSemaphore::~CSemaphore()
{
}

BOOL CSemaphore::Unlock(LONG lCount, LPLONG lpPrevCount /* =NULL */)
{
    return ::ReleaseSemaphore(m_hObject, lCount, lpPrevCount);
}

/////////////////////////////////////////////////////////////////////////////
// CMutex

CMutex::CMutex(BOOL bInitiallyOwn, LPCTSTR pstrName,
    LPSECURITY_ATTRIBUTES lpsaAttribute /* = NULL */)
    : CSyncObject(pstrName)
{
    m_hObject = ::CreateMutex(lpsaAttribute, bInitiallyOwn, pstrName);
}

CMutex::~CMutex()
{
}

BOOL CMutex::Unlock()
{
    return ::ReleaseMutex(m_hObject);
}

/////////////////////////////////////////////////////////////////////////////
// CEvent

CEvent::CEvent(BOOL bInitiallyOwn, BOOL bManualReset, LPCTSTR pstrName,
    LPSECURITY_ATTRIBUTES lpsaAttribute)
    : CSyncObject(pstrName)
{
    m_hObject = ::CreateEvent(lpsaAttribute, bManualReset,
        bInitiallyOwn, pstrName);
}

CEvent::~CEvent()
{
}

BOOL CEvent::Unlock()
{
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSingleLock

CSingleLock::CSingleLock(CSyncObject* pObject, BOOL bInitialLock)
{
    m_pObject = pObject;
    m_hObject = pObject->m_hObject;
    m_bAcquired = FALSE;

    if (bInitialLock)
        Lock();
}

BOOL CSingleLock::Lock(DWORD dwTimeOut /* = INFINITE */)
{
    m_bAcquired = m_pObject->Lock(dwTimeOut);
    return m_bAcquired;
}

BOOL CSingleLock::Unlock()
{
    if (m_bAcquired)
        m_bAcquired = !m_pObject->Unlock();

    // successfully unlocking means it isn't acquired
    return !m_bAcquired;
}

BOOL CSingleLock::Unlock(LONG lCount, LPLONG lpPrevCount /* = NULL */)
{
    if (m_bAcquired)
        m_bAcquired = !m_pObject->Unlock(lCount, lpPrevCount);

    // successfully unlocking means it isn't acquired
    return !m_bAcquired;
}

/////////////////////////////////////////////////////////////////////////////
// CMultiLock

#define _countof(array) (sizeof(array)/sizeof(array[0]))

CMultiLock::CMultiLock(CSyncObject* pObjects[], DWORD dwCount,
    BOOL bInitialLock): m_pHandleArray ( NULL )
{
    m_ppObjectArray = pObjects;
    m_dwCount = dwCount;

    // as an optimization, skip alloacating array if
    // we can use a small, predeallocated bunch of handles

    if (m_dwCount > _countof(m_hPreallocated))
    {
        m_pHandleArray = new HANDLE[m_dwCount];
        m_bLockedArray = new BOOL[m_dwCount];
    }
    else
    {
        m_pHandleArray = m_hPreallocated;
        m_bLockedArray = m_bPreallocated;
    }

    // get list of handles from array of objects passed
    for (DWORD i = 0; i <m_dwCount; i++)
    {
        m_pHandleArray[i] = pObjects[i]->m_hObject;
        m_bLockedArray[i] = FALSE;
    }

    if (bInitialLock)
        Lock();
}

CMultiLock::~CMultiLock()
{
    Unlock();
    if (m_pHandleArray != m_hPreallocated)
    {
        delete[] m_bLockedArray;
        delete[] m_pHandleArray;
    }
}

DWORD CMultiLock::Lock(DWORD dwTimeOut /* = INFINITE */,
        BOOL bWaitForAll /* = TRUE */, DWORD dwWakeMask /* = 0 */)
{
    DWORD dwResult;
    if (dwWakeMask == 0)
        dwResult = ::WaitForMultipleObjects(m_dwCount,
            m_pHandleArray, bWaitForAll, dwTimeOut);
    else
        dwResult = ::MsgWaitForMultipleObjects(m_dwCount,
            m_pHandleArray, bWaitForAll, dwTimeOut, dwWakeMask);

    if (dwResult < (WAIT_OBJECT_0 + m_dwCount))
    {
        if (bWaitForAll)
        {
            for (DWORD i = 0; i < m_dwCount; i++)
                m_bLockedArray[i] = TRUE;
        }
        else
        {
            m_bLockedArray[dwResult - WAIT_OBJECT_0] = TRUE;
        }
    }
    return dwResult;
}

BOOL CMultiLock::Unlock()
{
    for (DWORD i=0; i < m_dwCount; i++)
    {
        if (m_bLockedArray[i])
            m_bLockedArray[i] = !m_ppObjectArray[i]->Unlock();
    }
    return TRUE;
}

BOOL CMultiLock::Unlock(LONG lCount, LPLONG lpPrevCount /* =NULL */)
{
    BOOL bGotOne = FALSE;
    for (DWORD i=0; i < m_dwCount; i++)
    {
        if (m_bLockedArray[i])
        {
            CSemaphore* pSemaphore = ( CSemaphore *) m_ppObjectArray[i];
            if (pSemaphore != NULL)
            {
                bGotOne = TRUE;
                m_bLockedArray[i] = !m_ppObjectArray[i]->Unlock(lCount, lpPrevCount);
            }
        }
    }

    return bGotOne;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\wstore.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: wstore.hpp
Written By:	B.Rajeev
Purpose	: To provide declarations of the MsgIdStore class 
----------------------------------------------------------*/

#ifndef __MSG_ID_STORE__
#define __MSG_ID_STORE__

#include "forward.h"
#include "msgid.h"
													
#endif // __MSG_ID_STORE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=snmpmfc
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES); \
	$(SNMP_MFC_INC); \
	$(FRAMEWORK_EXPT_INC)

SOURCES= \
	..\PLEX.cpp \
	..\MTCORE.cpp \
	..\MTEX.cpp \
	..\Array_o.cpp \
	..\List_o.cpp \
	..\strex.cpp \
	..\strcore.cpp

USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\ansi\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\strcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <snmpstd.h>
#include <snmptempl.h>
#include <snmpstr.h>


/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static CStringData* afxDataNil = (CStringData*)&rgInitData;
static LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));
// special function to make afxEmptyString work even during initialization
const CString& AFXAPI AfxGetEmptyString()
    { return *(CString*)&afxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
    Init();
}

CString::CString(const CString& stringSrc)
{
    if (stringSrc.GetData()->nRefs >= 0)
    {
        m_pchData = stringSrc.m_pchData;
        InterlockedIncrement(&GetData()->nRefs);
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
    if (nLen == 0)
        Init();
    else
    {
        CStringData* pData =
            (CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
        pData->nRefs = 1;
        pData->data()[nLen] = '\0';
        pData->nDataLength = nLen;
        pData->nAllocLength = nLen;
        m_pchData = pData->data();
    }
}

void CString::Release()
{
    if (GetData() != afxDataNil)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
        Init();
    }
}

void PASCAL CString::Release(CStringData* pData)
{
    if (pData != afxDataNil)
    {
        if (InterlockedDecrement(&pData->nRefs) <= 0)
            delete[] (BYTE*)pData;
    }
}

void CString::Empty()
{
    if (GetData()->nDataLength == 0)
        return;
    if (GetData()->nRefs >= 0)
        Release();
    else
        *this = &afxChNil;
}

void CString::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CStringData* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
    }
}

void CString::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }
}

CString::~CString()
//  free any attached data
{
    if (GetData() != afxDataNil)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCTSTR lpsz)
{
    Init();
    int nLen = SafeStrlen(lpsz);
    if (nLen != 0)
    {
        AllocBuffer(nLen);
        memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CString::CString(LPCSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
}
#else //_UNICODE
CString::CString(LPCWSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen*2);
        _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
    }
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
    AllocBeforeWrite(nSrcLen);
    memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
    GetData()->nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            m_pchData = stringSrc.m_pchData;
            InterlockedIncrement(&GetData()->nRefs);
        }
    }
    return *this;
}

const CString& CString::operator=(LPCTSTR lpsz)
{
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CString& CString::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    AllocBeforeWrite(nSrcLen);
    _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    ReleaseBuffer();
    return *this;
}
#else //!_UNICODE
const CString& CString::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    AllocBeforeWrite(nSrcLen*2);
    _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
    ReleaseBuffer();
    return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
    int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
    }
}

CString AFXAPI operator+(const CString& string1, const CString& string2)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);
    return s;
}

CString AFXAPI operator+(const CString& string, LPCTSTR lpsz)
{
    CString s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CString::SafeStrlen(lpsz), lpsz);
    return s;
}

CString AFXAPI operator+(LPCTSTR lpsz, const CString& string)
{
    CString s;
    s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
        return;

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CStringData* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        CString::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
        GetData()->nDataLength += nSrcLen;
        m_pchData[GetData()->nDataLength] = '\0';
    }
}

const CString& CString::operator+=(LPCTSTR lpsz)
{
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CString& CString::operator+=(TCHAR ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CString& CString::operator+=(const CString& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CString::GetBuffer(int nMinBufLength)
{
    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
        // we have to grow the buffer
        CStringData* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
            nMinBufLength = nOldLen;
        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
        GetData()->nDataLength = nOldLen;
        CString::Release(pOldData);
    }

    // return a pointer to the character storage for this string
    return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
        nNewLength = lstrlen(m_pchData); // zero terminated

    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
}

LPTSTR CString::GetBufferSetLength(int nNewLength)
{
    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
    return m_pchData;
}

void CString::FreeExtra()
{
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CStringData* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
        CString::Release(pOldData);
    }
}

LPTSTR CString::LockBuffer()
{
    LPTSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;
    return lpsz;
}

void CString::UnlockBuffer()
{
    if (GetData() != afxDataNil)
        GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CString::Find(TCHAR ch) const
{
    // find first single character
    LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
    LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CString::MakeUpper()
{
    CopyBeforeWrite();
    _tcsupr(m_pchData);
}

void CString::MakeLower()
{
    CopyBeforeWrite();
    _tcslwr(m_pchData);
}

void CString::MakeReverse()
{
    CopyBeforeWrite();
    _tcsrev(m_pchData);
}

void CString::SetAt(int nIndex, TCHAR ch)
{
    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CString::AnsiToOem()
{
    CopyBeforeWrite();
    ::AnsiToOem(m_pchData, m_pchData);
}
void CString::OemToAnsi()
{
    CopyBeforeWrite();
    ::OemToCharBuff(m_pchData, m_pchData,SafeStrlen(m_pchData));    
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CString conversion helpers (these use the current system locale)

int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
    if (count == 0 && mbstr != NULL)
        return 0;

    int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
        mbstr, count, NULL, NULL);

    if (result > 0)
        mbstr[result-1] = 0;
    return result;
}

int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
    if (count == 0 && wcstr != NULL)
        return 0;

    int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
        wcstr, count);

    if (result > 0)
        wcstr[result-1] = 0;
    return result;
}

LPWSTR AFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    if (lpa == NULL)
        return NULL;

    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

LPSTR AFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    if (lpw == NULL)
        return NULL;

    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}

///////////////////////////////////////////////////////////////////////////////
// OLE BSTR support

BSTR CString::AllocSysString() const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
    BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    BSTR bstr = ::SysAllocStringLen(NULL, nLen);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        bstr, nLen);
#endif

    return bstr;
}

BSTR CString::SetSysString(BSTR* pbstr) const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
    if (!::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    if (!::SysReAllocStringLen(pbstr, NULL, nLen))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        *pbstr, nLen);
#endif

    return *pbstr;
}

// CString
CStringData* CString::GetData() const
    { return ((CStringData*)m_pchData)-1; }
void CString::Init()
    { m_pchData = afxEmptyString.m_pchData; }
CString::CString(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
const CString& CString::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
const CString& CString::operator+=(char ch)
    { *this += (TCHAR)ch; return *this; }
const CString& CString::operator=(char ch)
    { *this = (TCHAR)ch; return *this; }
CString AFXAPI operator+(const CString& string, char ch)
    { return string + (TCHAR)ch; }
CString AFXAPI operator+(char ch, const CString& string)
    { return (TCHAR)ch + string; }
#endif

int CString::GetLength() const
    { return GetData()->nDataLength; }
int CString::GetAllocLength() const
    { return GetData()->nAllocLength; }
BOOL CString::IsEmpty() const
    { return GetData()->nDataLength == 0; }
CString::operator LPCTSTR() const
    { return m_pchData; }
int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
    { return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
int CString::Compare(LPCTSTR lpsz) const
    { return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
int CString::CompareNoCase(LPCTSTR lpsz) const
    { return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
int CString::Collate(LPCTSTR lpsz) const
    { return _tcscoll(m_pchData, lpsz); }   // locale sensitive

TCHAR CString::GetAt(int nIndex) const
{
    return m_pchData[nIndex];
}
TCHAR CString::operator[](int nIndex) const
{
    // same as GetAt
    return m_pchData[nIndex];
}
bool AFXAPI operator==(const CString& s1, const CString& s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) == 0; }
bool AFXAPI operator!=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) != 0; }
bool AFXAPI operator<(const CString& s1, const CString& s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) > 0; }
bool AFXAPI operator>(const CString& s1, const CString& s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) < 0; }
bool AFXAPI operator<=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) >= 0; }
bool AFXAPI operator>=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) <= 0; }


///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\plex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PLEX_H__
#define __PLEX_H__

struct CPlex    // warning variable length structure
{
	CPlex* pNext;
	UINT nMax;
	UINT nCur;
	/* BYTE data[maxNum*elementSize]; */

	void* data() { return this+1; }

	static CPlex* Create(CPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};


#endif //__PLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\snmpstd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __SNMPSTD_H_
#define __SNMPSTD_H_

#include <windows.h>
#include <stdio.h>
#include <provexpt.h>

struct __POSITION { };
typedef __POSITION* POSITION;
#define BEFORE_START_POSITION ((POSITION)-1L)

struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _AFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

class CObject 
{
public:

	CObject () {} ;
	virtual ~CObject () {} ;
} ;

#define AFXAPI __stdcall 
#define AFX_CDECL __cdecl

#pragma warning(disable: 4275)  // deriving exported class from non-exported
#pragma warning(disable: 4251)  // using non-exported as public in exported
#pragma warning(disable: 4114)

#include "snmpstr.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\strex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <snmpstd.h>
#include <snmptempl.h>
#include <snmpstr.h>

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(TCHAR ch, int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
#ifdef _UNICODE
        for (int i = 0; i < nLength; i++)
            m_pchData[i] = ch;
#else
        memset(m_pchData, ch, nLength);
#endif
    }
}

CString::CString(LPCTSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CString& CString::operator=(TCHAR ch)
{
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CString AFXAPI operator+(const CString& string1, TCHAR ch)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CString AFXAPI operator+(TCHAR ch, const CString& string)
{
    CString s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
        nFirst = 0;
    if (nCount < 0)
        nCount = 0;

    if (nFirst + nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength - nFirst;
    if (nFirst > GetData()->nDataLength)
        nCount = 0;

    CString dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CString CString::Right(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CString dest;
    AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
    return dest;
}

CString CString::Left(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CString dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
    return Left(_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
    return Left(_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(TCHAR ch) const
{
    // find last single character
    LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(LPCTSTR lpszSub) const
{
    // find first matching substring
    LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CString formatting

#ifdef _MAC
    #define TCHAR_ARG   int
    #define WCHAR_ARG   unsigned
    #define CHAR_ARG    int
#else
    #define TCHAR_ARG   TCHAR
    #define WCHAR_ARG   WCHAR
    #define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
    #define DOUBLE_ARG  _AFX_DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
    {
        // handle '%' character, but watch out for '%%'
        if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
        {
            nMaxLen += _tclen(lpsz);
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
        {
            // check for valid flags
            if (*lpsz == '#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == '*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                *lpsz == ' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0)
        {
            // width indicated by
            nWidth = _ttoi(lpsz);
            for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                ;
        }

        int nPrecision = 0;
        if (*lpsz == '.')
        {
            // skip past '.' separator (width.precision)
            lpsz = _tcsinc(lpsz);

            // get precision and skip it
            if (*lpsz == '*')
            {
                nPrecision = va_arg(argList, int);
                lpsz = _tcsinc(lpsz);
            }
            else
            {
                nPrecision = _ttoi(lpsz);
                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                    ;
            }
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz)
        {
        // modifiers that affect size
        case 'h':
            nModifier = FORCE_ANSI;
            lpsz = _tcsinc(lpsz);
            break;
        case 'l':
            nModifier = FORCE_UNICODE;
            lpsz = _tcsinc(lpsz);
            break;

        // modifiers that do not affect size
        case 'F':
        case 'N':
        case 'L':
            lpsz = _tcsinc(lpsz);
            break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier)
        {
        // single characters
        case 'c':
        case 'C':
            nItemLen = 2;
            va_arg(argList, TCHAR_ARG);
            break;
        case 'c'|FORCE_ANSI:
        case 'C'|FORCE_ANSI:
            nItemLen = 2;
            va_arg(argList, CHAR_ARG);
            break;
        case 'c'|FORCE_UNICODE:
        case 'C'|FORCE_UNICODE:
            nItemLen = 2;
            va_arg(argList, WCHAR_ARG);
            break;

        // strings
        case 's':
        {
            LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = lstrlen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case 'S':
        {
#ifndef _UNICODE
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
#else
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
#endif
            break;
        }

        case 's'|FORCE_ANSI:
        case 'S'|FORCE_ANSI:
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

#ifndef _MAC
        case 's'|FORCE_UNICODE:
        case 'S'|FORCE_UNICODE:
        {
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }
#endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0)
        {
            nItemLen = max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = min(nItemLen, nPrecision);
        }
        else
        {
            switch (*lpsz)
            {
            // integers
            case 'd':
            case 'i':
            case 'u':
            case 'x':
            case 'X':
            case 'o':
                va_arg(argList, int);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'e':
            case 'f':
            case 'g':
            case 'G':
                va_arg(argList, DOUBLE_ARG);
                nItemLen = 128;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'p':
                va_arg(argList, void*);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            // no output
            case 'n':
                va_arg(argList, int*);
                break;

            default:
                break ;
            }
        }

        // adjust nMaxLen for output nItemLen
        nMaxLen += nItemLen;
    }

    GetBuffer(nMaxLen);
    _vstprintf(m_pchData, lpszFormat, argListSave);
    ReleaseBuffer();

    va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CString::Format(LPCTSTR lpszFormat, ...)
{
    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}

#ifndef _MAC
// formatting (using FormatMessage style formatting)
void AFX_CDECL CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPTSTR lpszTemp;

    if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    }

    // assign lpszTemp into the resulting string and free the temporary
    *this = lpszTemp;
    LocalFree(lpszTemp);
    va_end(argList);
}

#endif //!_MAC

void CString::TrimRight()
{
    CopyBeforeWrite();

    // find beginning of trailing spaces by starting at beginning (DBCS aware)
    LPTSTR lpsz = m_pchData;
    LPTSTR lpszLast = NULL;
    while (*lpsz != '\0')
    {
        if (_istspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = _tcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CString::TrimLeft()
{
    CopyBeforeWrite();

    // find first non-space character
    LPCTSTR lpsz = m_pchData;
    while (_istspace(*lpsz))
        lpsz = _tcsinc(lpsz);

    // fix up data and length
    int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
    GetData()->nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// CString support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CString> (CString* pElements, int nCount)
#else
void AFXAPI ConstructElements(CString* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        memcpy(pElements, &afxEmptyString, sizeof(*pElements));
}

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CString> (CString* pElements, int nCount)
#else
void AFXAPI DestructElements(CString* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        pElements->~CString();
}

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CString> (CString* pDest, const CString* pSrc, int nCount)
#else
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount)
#endif
{
    for (; nCount--; ++pDest, ++pSrc)
        *pDest = *pSrc;
}

/*
#ifndef OLE2ANSI
#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key)
#else
UINT AFXAPI HashKey(LPCWSTR key)
#endif
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}
#endif

#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCSTR> (LPCSTR key)
#else
UINT AFXAPI HashKey(LPCSTR key)
#endif
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}
*/
UINT AFXAPI HashKeyLPCWSTR(LPCWSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}
UINT AFXAPI HashKeyLPCSTR(LPCSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\snmpcoll.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __SNMPCOLL_H__
#define __SNMPCOLL_H__

#include "snmpstd.h"

class CObArray : public CObject
{
public:

// Construction
	CObArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	CObject* GetAt(int nIndex) const;
	void SetAt(int nIndex, CObject* newElement);
	CObject*& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const CObject** GetData() const;
	CObject** GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, CObject* newElement);
	int Add(CObject* newElement);
	int Append(const CObArray& src);
	void Copy(const CObArray& src);

	// overloaded operator helpers
	CObject* operator[](int nIndex) const;
	CObject*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, CObject* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CObArray* pNewArray);

// Implementation
protected:
	CObject** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CObArray();

protected:
	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};

/////////////////////////////////////////////////////////////////////////////

class CObList : public CObject
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CObject* data;
	};
public:

// Construction
	CObList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CObject*& GetHead();
	CObject* GetHead() const;
	CObject*& GetTail();
	CObject* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	CObject* RemoveHead();
	CObject* RemoveTail();

	// add before head or after tail
	POSITION AddHead(CObject* newElement);
	POSITION AddTail(CObject* newElement);

	// add another list of elements before head or after tail
	void AddHead(CObList* pNewList);
	void AddTail(CObList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CObject*& GetNext(POSITION& rPosition); // return *Position++
	CObject* GetNext(POSITION& rPosition) const; // return *Position++
	CObject*& GetPrev(POSITION& rPosition); // return *Position--
	CObject* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CObject*& GetAt(POSITION position);
	CObject* GetAt(POSITION position) const;
	void SetAt(POSITION pos, CObject* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, CObject* newElement);
	POSITION InsertAfter(POSITION position, CObject* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(CObject* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CObList();

	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};

#endif //!__SNMPCOLL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\snmpmt.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __SNMPMT_H__
#define __SNMPMT_H__

#ifdef UNICODE
#define LPCTSTR wchar_t *
#else
#define LPCTSTR char *
#endif

class CSyncObject;
class CSemaphore;
class CMutex;
class CEvent;
class CCriticalSection;
class CSingleLock;
class CMultiLock;

/////////////////////////////////////////////////////////////////////////////
// Basic synchronization object

class CSyncObject
{
public:

	CSyncObject(LPCTSTR pstrName);

// Attributes
public:
	operator HANDLE() const;
	HANDLE  m_hObject;

// Operations
	virtual BOOL Lock(DWORD dwTimeout = INFINITE);
	virtual BOOL Unlock() = 0;
	virtual BOOL Unlock(LONG /* lCount */, LPLONG /* lpPrevCount=NULL */)
		{ return TRUE; }

// Implementation
public:
	virtual ~CSyncObject();
	friend class CSingleLock;
	friend class CMultiLock;
};

/////////////////////////////////////////////////////////////////////////////
// CSemaphore

class CSemaphore : public CSyncObject
{
// Constructor
public:
	CSemaphore(LONG lInitialCount = 1, LONG lMaxCount = 1,
		LPCTSTR pstrName=NULL, LPSECURITY_ATTRIBUTES lpsaAttributes = NULL);

// Implementation
public:
	virtual ~CSemaphore();
	virtual BOOL Unlock();
	virtual BOOL Unlock(LONG lCount, LPLONG lprevCount = NULL);
};

/////////////////////////////////////////////////////////////////////////////
// CMutex

class CMutex : public CSyncObject
{
// Constructor
public:
	CMutex(BOOL bInitiallyOwn = FALSE, LPCTSTR lpszName = NULL,
		LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Implementation
public:
	virtual ~CMutex();
	BOOL Unlock();
};

/////////////////////////////////////////////////////////////////////////////
// CEvent

class CEvent : public CSyncObject
{
// Constructor
public:
	CEvent(BOOL bInitiallyOwn = FALSE, BOOL bManualReset = FALSE,
		LPCTSTR lpszNAme = NULL, LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Operations
public:
	BOOL SetEvent();
	BOOL PulseEvent();
	BOOL ResetEvent();
	BOOL Unlock();

// Implementation
public:
	virtual ~CEvent();
};

/////////////////////////////////////////////////////////////////////////////
// CCriticalSection

class CCriticalSection : public CSyncObject
{
// Constructor
public:
	CCriticalSection();

// Attributes
public:
	operator CRITICAL_SECTION*();
	CRITICAL_SECTION m_sect;

// Operations
public:
	BOOL Unlock();
	BOOL Lock();
	BOOL Lock(DWORD dwTimeout);

// Implementation
public:
	virtual ~CCriticalSection();
};

/////////////////////////////////////////////////////////////////////////////
// CSingleLock

class CSingleLock
{
// Constructors
public:
	CSingleLock(CSyncObject* pObject, BOOL bInitialLock = FALSE);

// Operations
public:
	BOOL Lock(DWORD dwTimeOut = INFINITE);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked();

// Implementation
public:
	~CSingleLock();

protected:
	CSyncObject* m_pObject;
	HANDLE  m_hObject;
	BOOL    m_bAcquired;
};

/////////////////////////////////////////////////////////////////////////////
// CMultiLock

class CMultiLock
{
// Constructor
public:
	CMultiLock(CSyncObject* ppObjects[], DWORD dwCount, BOOL bInitialLock = FALSE);

// Operations
public:
	DWORD Lock(DWORD dwTimeOut = INFINITE, BOOL bWaitForAll = TRUE,
		DWORD dwWakeMask = 0);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked(DWORD dwItem);

// Implementation
public:
	~CMultiLock();

protected:
	HANDLE  m_hPreallocated[8];
	BOOL    m_bPreallocated[8];

	CSyncObject* const * m_ppObjectArray;
	HANDLE* m_pHandleArray;
	BOOL*   m_bLockedArray;
	DWORD   m_dwCount;
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline CSyncObject::operator HANDLE() const
	{ return m_hObject;}

inline BOOL CSemaphore::Unlock()
	{ return Unlock(1, NULL); }

inline BOOL CEvent::SetEvent()
	{ return ::SetEvent(m_hObject); }
inline BOOL CEvent::PulseEvent()
	{ return ::PulseEvent(m_hObject); }
inline BOOL CEvent::ResetEvent()
	{ return ::ResetEvent(m_hObject); }

inline CSingleLock::~CSingleLock()
	{ Unlock(); }
inline BOOL CSingleLock::IsLocked()
	{ return m_bAcquired; }

inline BOOL CMultiLock::IsLocked(DWORD dwObject)
	{ return m_bLockedArray[dwObject]; }

inline CCriticalSection::CCriticalSection() : CSyncObject(NULL)
	{ ::InitializeCriticalSection(&m_sect); }
inline CCriticalSection::operator CRITICAL_SECTION*()
	{ return (CRITICAL_SECTION*) &m_sect; }
inline CCriticalSection::~CCriticalSection()
	{ ::DeleteCriticalSection(&m_sect); }
inline BOOL CCriticalSection::Lock()
	{ ::EnterCriticalSection(&m_sect); return TRUE; }
inline BOOL CCriticalSection::Lock(DWORD /* dwTimeout */)
	{ return Lock(); }
inline BOOL CCriticalSection::Unlock()
	{ ::LeaveCriticalSection(&m_sect); return TRUE; }


#endif  // __AFXMT_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\snmpstr.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _SNMPSTR_H_
#define _SNMPSTR_H_

#include "snmpstd.h"
#include <tchar.h>

struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString AFXAPI operator+(const CString& string1,
			const CString& string2);
	friend CString AFXAPI operator+(const CString& string, TCHAR ch);
	friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString AFXAPI operator+(const CString& string, char ch);
	friend CString AFXAPI operator+(char ch, const CString& string);
#endif
	friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
	friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void AFX_CDECL Format(LPCTSTR lpszFormat, ...);

#ifndef _MAC
	// formatting for localization (uses FormatMessage API)
	void AFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
#endif

#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool AFXAPI operator==(const CString& s1, const CString& s2);
bool AFXAPI operator==(const CString& s1, LPCTSTR s2);
bool AFXAPI operator==(LPCTSTR s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2);

// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern TCHAR afxChNil;
const CString& AFXAPI AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\snmptempl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXTEMPL_H__
#define __AFXTEMPL_H__

#ifndef __AFXPLEX_H__
#include "plex.h"
#endif

//#include <new.h>
#include "snmpstd.h"
#include "snmpstr.h"

template<class TYPE>
inline void AFXAPI ConstructElements(TYPE* pElements, int nCount)
{
	// first do bit-wise zero initialization
	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	// then call the constructor(s)
	for (; nCount--; pElements++)
		::new((void*)pElements) TYPE;
}

template<class TYPE>
inline void AFXAPI DestructElements(TYPE* pElements, int nCount)
{
	// call the destructor(s)
	for (; nCount--; pElements++)
		pElements->~TYPE();
}

template<class TYPE>
inline void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
	// default is element-copy using assignment
	while (nCount--)
		*pDest++ = *pSrc++;
}

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT AFXAPI HashKey(ARG_KEY key)
{
	// default identity hash - works for most primitive values
	return (UINT)(((UINT_PTR) key) >> 4);
}

///////////////////////////////////////////////////////////////////////////////
// CString support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CString> (CString* pElements, int nCount);
#else
void AFXAPI ConstructElements(CString* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CString> (CString* pElements, int nCount);
#else
void AFXAPI DestructElements(CString* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CString> (CString* pDest, const CString* pSrc, int nCount);
#else
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount);
#endif

/*
#ifndef OLE2ANSI
#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key);
#else
UINT AFXAPI HashKey(LPCWSTR key);
#endif
#endif

#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCSTR> (LPCSTR key);
#else
UINT AFXAPI HashKey(LPCSTR key);
#endif
*/
UINT AFXAPI HashKeyLPCWSTR(LPCWSTR key);
UINT AFXAPI HashKeyLPCSTR(LPCSTR key);


/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray 
{
public:
// Construction
	CArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	TYPE GetAt(int nIndex) const;
	void SetAt(int nIndex, ARG_TYPE newElement);
	TYPE& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const TYPE* GetData() const;
	TYPE* GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, ARG_TYPE newElement);
	int Add(ARG_TYPE newElement);
	int Append(const CArray& src);
	void Copy(const CArray& src);

	// overloaded operator helpers
	TYPE operator[](int nIndex) const;
	TYPE& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
	TYPE* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CArray();
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
	{ return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
	{ SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
	{ return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
	{ m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
	{ return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
	{ return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
	{ return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
	if (m_pData != NULL)
	{
		DestructElements<TYPE>(m_pData, m_nSize);
		delete[] (BYTE*)m_pData;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		if (m_pData != NULL)
		{
			DestructElements<TYPE>(m_pData, m_nSize);
			delete[] (BYTE*)m_pData;
			m_pData = NULL;
		}
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
		ConstructElements<TYPE>(m_pData, nNewSize);
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);
		}
		else if (m_nSize > nNewSize)
		{
			// destroy the old elements
			DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = m_nSize / 8;
			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

		// construct remaining elements

		ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);
	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
	return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
	SetSize(src.m_nSize);
	CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
		TYPE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
			// copy new data from old
			memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
	if (nIndex >= m_nSize)
		SetSize(nIndex+1, -1);
	m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount, -1);  // grow it to new size
		// destroy intial data before copying over it
		DestructElements<TYPE>(&m_pData[nOldSize], nCount);
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(TYPE));

		// re-init slots we copied from
		ConstructElements<TYPE>(&m_pData[nIndex], nCount);
	}

	// insert new value in the gap

	while (nCount--)
		m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	DestructElements<TYPE>(&m_pData[nIndex], nCount);
	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(TYPE));
	m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList 
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	CList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CList* pNewList);
	void AddTail(CList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); // return *Position++
	TYPE GetNext(POSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(POSITION& rPosition); // return *Position--
	TYPE GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	POSITION FindIndex(int nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CList();
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
	{ return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
	{ return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
	{ return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
	{ return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		DestructElements<TYPE>(&pNode->data, 1);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
	RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}

	CList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;

	ConstructElements<TYPE>(&pNode->data, 1);
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
	DestructElements<TYPE>(&pNode->data, 1);
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;

	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
	CNode* pOldNode = (CNode*) position;

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements<TYPE>(&pNode->data, &searchValue))
			return (POSITION)pNode;
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap 
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		KEY key;
		VALUE value;
	};
public:
// Construction
	CMap(int nBlockSize = 10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;
	BOOL GetCurrentAssoc(POSITION rPosition, KEY& rKey, VALUE& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
	~CMap();
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				DestructElements<VALUE>(&pAssoc->value, 1);
				DestructElements<KEY>(&pAssoc->key, 1);
			}
		}
	}

	// free hash table
	delete[] m_pHashTable;
	m_pHashTable = NULL;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
	RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
		// chain them into free list
		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}

	CMap::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;

	ConstructElements<KEY>(&pAssoc->key, 1);
	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
	DestructElements<VALUE>(&pAssoc->value, 1);
	DestructElements<KEY>(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	UINT nHash;
	CAssoc* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	UINT nHash;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	CAssoc* pAssocRet = (CAssoc*)rNextPosition;

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
	}

	// find next association

	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCurrentAssoc(POSITION rPosition,
	KEY& rKey, VALUE& rValue) const
{
	CAssoc* pAssocRet = (CAssoc*)rPosition;

	if (pAssocRet != (CAssoc*) BEFORE_START_POSITION)
	{
		// fill in return data
		rKey = pAssocRet->key;
		rValue = pAssocRet->value;

		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(int nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(int nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
	void SetAt(int nIndex, TYPE ptr)
		{ BASE_CLASS::SetAt(nIndex, ptr); }

	// Potentially growing the array
	void SetAtGrow(int nIndex, TYPE newElement)
	   { BASE_CLASS::SetAtGrow(nIndex, newElement); }
	int Add(TYPE newElement)
	   { return BASE_CLASS::Add(newElement); }
	int Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
	   { return BASE_CLASS::Append(src); }
	void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
		{ BASE_CLASS::Copy(src); }

	// Operations that move elements around
	void InsertAt(int nIndex, TYPE newElement, int nCount = 1)
		{ BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
	void InsertAt(int nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
	   { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

	// overloaded operator helpers
	TYPE operator[](int nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](int nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
// Construction
	CTypedPtrList(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// peek at head or tail
	TYPE& GetHead()
		{ return (TYPE&)BASE_CLASS::GetHead(); }
	TYPE GetHead() const
		{ return (TYPE)BASE_CLASS::GetHead(); }
	TYPE& GetTail()
		{ return (TYPE&)BASE_CLASS::GetTail(); }
	TYPE GetTail() const
		{ return (TYPE)BASE_CLASS::GetTail(); }

	// get head or tail (and remove it) - don't call on empty list!
	TYPE RemoveHead()
		{ return (TYPE)BASE_CLASS::RemoveHead(); }
	TYPE RemoveTail()
		{ return (TYPE)BASE_CLASS::RemoveTail(); }

	// add before head or after tail
	POSITION AddHead(TYPE newElement)
		{ return BASE_CLASS::AddHead(newElement); }
	POSITION AddTail(TYPE newElement)
		{ return BASE_CLASS::AddTail(newElement); }

	// add another list of elements before head or after tail
	void AddHead(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddHead(pNewList); }
	void AddTail(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddTail(pNewList); }

	// iteration
	TYPE& GetNext(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetNext(rPosition); }
	TYPE GetNext(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetNext(rPosition); }
	TYPE& GetPrev(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
	TYPE GetPrev(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetPrev(rPosition); }

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position)
		{ return (TYPE&)BASE_CLASS::GetAt(position); }
	TYPE GetAt(POSITION position) const
		{ return (TYPE)BASE_CLASS::GetAt(position); }
	void SetAt(POSITION pos, TYPE newElement)
		{ BASE_CLASS::SetAt(pos, newElement); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:

// Construction
	CTypedPtrMap(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// Lookup
	BOOL Lookup(typename BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

	// Lookup and add if not there
	VALUE& operator[](typename BASE_CLASS::BASE_ARG_KEY key)
		{ return (VALUE&)BASE_CLASS::operator[](key); }

	// add a new key (key, value) pair
	void SetAt(KEY key, VALUE newValue)
		{ BASE_CLASS::SetAt(key, newValue); }

	// removing existing (key, ?) pair
	BOOL RemoveKey(KEY key)
		{ return BASE_CLASS::RemoveKey(key); }

	// iteration
	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
			(BASE_CLASS::BASE_VALUE&)rValue); }
};

/////////////////////////////////////////////////////////////////////////////

#endif //__AFXTEMPL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\snmplog.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmpstd.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <string.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <snmpcont.h>
#include <snmplog.h>
#include <snmpevt.h>
#include <snmpthrd.h>


ProvDebugLog* SnmpDebugLog::s_SnmpDebugLog = ProvDebugLog::GetProvDebugLog(LOG_SNMPPROV); ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\maindll.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <process.h>
#include <objbase.h>
#include <snmpcont.h>
#include "snmpevt.h"
#include "snmpthrd.h"
#include "snmplog.h"

extern CRITICAL_SECTION g_SnmpDebugLogMapCriticalSection ;


//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

    HINSTANCE hInstance, 
    ULONG ulReason , 
    LPVOID pvReserved
)
{
    BOOL status = TRUE ;
    SetStructuredExceptionHandler seh;

    try
    {
        if ( DLL_PROCESS_DETACH == ulReason )
        {

            status = TRUE ;
        }
        else if ( DLL_PROCESS_ATTACH == ulReason )
        {
            status = TRUE ;
            DisableThreadLibraryCalls(hInstance);			// 158024 
        }
        else if ( DLL_THREAD_DETACH == ulReason )
        {
            status = TRUE ;
        }
        else if ( DLL_THREAD_ATTACH == ulReason )
        {
            status = TRUE ;
        }
    }
    catch(Structured_Exception e_SE)
    {
        status = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        status = FALSE;
    }
    catch(...)
    {
        status = FALSE;
    }

    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\snmpevt.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <snmpcont.h>
#include "snmpevt.h"
#include "snmpthrd.h"

SnmpEventObject :: SnmpEventObject ( const wchar_t *globalEventName ) : m_event ( NULL )
{
    m_event = CreateEvent (

        NULL ,
        FALSE ,
        FALSE ,
        globalEventName 
    ) ;

    if ( m_event == NULL )
    {
        if ( GetLastError () == ERROR_ALREADY_EXISTS )
        {
            m_event = OpenEvent (

                EVENT_ALL_ACCESS ,
                FALSE , 
                globalEventName
            ) ;
        }
    }

    if( NULL == m_event ) throw Heap_Exception(Heap_Exception::E_ALLOCATION_ERROR);
}

SnmpEventObject :: ~SnmpEventObject () 
{
    if ( m_event != NULL )
    {
        CloseHandle ( m_event ) ;
    }
}

HANDLE SnmpEventObject :: GetHandle () 
{
    return m_event ;
}

void SnmpEventObject :: Set () 
{
    SetEvent ( m_event ) ;
}

void SnmpEventObject :: Clear () 
{
    ResetEvent ( m_event ) ;
}

void SnmpEventObject :: Process () 
{
}

BOOL SnmpEventObject :: Wait ()
{
    return WaitForSingleObject ( GetHandle () , INFINITE ) == WAIT_OBJECT_0 ;
}

void SnmpEventObject :: Complete ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\include\snmplog.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __SNMPLOG_H
#define __SNMPLOG_H
#include <provlog.h>

#ifdef SNMPDEBUG_INIT
class __declspec ( dllexport ) SnmpDebugLog : public ProvDebugLog
#else
class __declspec ( dllimport ) SnmpDebugLog : public ProvDebugLog
#endif
{
public:
	static ProvDebugLog * s_SnmpDebugLog;
} ;

#endif __SNMPLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\include\snmpevt.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __SNMPTHREAD_SNMPEVT_H__
#define __SNMPTHREAD_SNMPEVT_H__

#ifdef SNMPTHRD_INIT
class __declspec ( dllexport ) SnmpEventObject
#else
class __declspec ( dllimport ) SnmpEventObject
#endif
{
private:

	HANDLE m_event ;

protected:
public:

	SnmpEventObject ( const wchar_t *globalEventName = NULL ) ;
	virtual ~SnmpEventObject () ;

	HANDLE GetHandle () ;
	void Set () ;
	void Clear () ;

	virtual void Process () ;
	virtual BOOL Wait () ;
	virtual void Complete () ;
} ;

#endif //__SNMPTHREAD_SNMPEVT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\snmpthrd.cpp ===
//***************************************************************************
//
//  File:   
//
//  Module: MS SNMP Provider
//
//  Purpose: 
//
// Copyright (c) 1997-2003 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <snmpcont.h>
#include "snmpevt.h"
#include "snmpthrd.h"
#include "snmplog.h"


CCriticalSection SnmpThreadObject :: s_Lock ;

LONG SnmpThreadObject :: s_ReferenceCount = 0 ;

SnmpMap <DWORD,DWORD,SnmpThreadObject *,SnmpThreadObject *> SnmpThreadObject :: s_ThreadContainer ;

typedef ProvOnDelete < CRITICAL_SECTION *, VOID ( * ) ( LPCRITICAL_SECTION ), LeaveCriticalSection >			LeaveCriticalSectionScope;
typedef ProvOnDelete < CRITICAL_SECTION *, VOID ( * ) ( LPCRITICAL_SECTION ), DeleteCriticalSection >			DeleteCriticalSectionScope;
typedef WaitException < CRITICAL_SECTION *, VOID ( * ) ( LPCRITICAL_SECTION ), EnterCriticalSection, 1000 >		EnterCriticalSectionWait;

class SnmpShutdownTaskObject : public SnmpTaskObject
{
private:

    SnmpThreadObject* m_ThreadToShutdown ;

protected:
public:

    SnmpShutdownTaskObject (SnmpThreadObject* threadToShutdown) ;

    void Process () ;

} ;

SnmpShutdownTaskObject :: SnmpShutdownTaskObject (SnmpThreadObject* threadToShutdown) 
: m_ThreadToShutdown ( threadToShutdown )
{
}

void SnmpShutdownTaskObject ::Process()
{
    if (m_ThreadToShutdown)
    {
        m_ThreadToShutdown->SignalThreadShutdown();
    }

    Complete();
}


BOOL SnmpThreadObject :: Startup ()
{
    InterlockedIncrement ( & s_ReferenceCount ) ;

    return TRUE ;
}

void SnmpThreadObject :: Closedown()
{
#if DBG == 1

	if ( s_ReferenceCount == 0 )
	{
		DebugBreak ();
	}

#endif

    if ( InterlockedDecrement ( & s_ReferenceCount ) <= 0 )
        ProcessDetach () ;
}

void SnmpThreadObject :: ProcessAttach () 
{ 
}

void SnmpThreadObject :: ProcessDetach ( BOOL a_ProcessDetaching )
{
	// delete all known thread objects 
	EnterCriticalSectionWait ecs ( s_Lock ) ;

    POSITION t_Position = s_ThreadContainer.GetStartPosition () ;
    while ( t_Position )
    {
        DWORD t_EventId ;
        SnmpThreadObject *t_ThreadObject ;
        s_ThreadContainer.GetNextAssoc ( t_Position , t_EventId , t_ThreadObject ) ;

        s_Lock.Unlock () ;

        t_ThreadObject->SignalThreadShutdown () ;

		EnterCriticalSectionWait ecs ( s_Lock ) ;

        t_Position = s_ThreadContainer.GetStartPosition () ;
    }

    s_ThreadContainer.RemoveAll () ;
    s_Lock.Unlock () ;
}

void __cdecl SnmpThreadObject :: ThreadExecutionProcedure ( void *a_ThreadParameter )
{
    SetStructuredExceptionHandler seh;

	try
	{
		SnmpThreadObject *t_ThreadObject = ( SnmpThreadObject * ) a_ThreadParameter ;
		BOOL bInitialised = FALSE;

		try
		{
			t_ThreadObject->RegisterThread () ;
			t_ThreadObject->Initialise () ;
			bInitialised = TRUE;

DebugMacro8(

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n [%S] Thread beginning dispatch" , t_ThreadObject->m_ThreadName ) ;
)

			if ( t_ThreadObject->Wait () )
			{
			}
			else 
			{
			}

DebugMacro8(

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n [%S] Thread completed dispatch" , t_ThreadObject->m_ThreadName ) ;
)

			t_ThreadObject->Uninitialise () ;
			bInitialised = FALSE;

DebugMacro8(

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Thread terminating" ) ;
)
		}
		catch(Structured_Exception e_SE)
		{
			t_ThreadObject->RemoveThread () ;

			if ( bInitialised )
			{
DebugMacro(

		SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\n *** [%S] Thread terminating -> structured exception *** " , t_ThreadObject->m_ThreadName ) ;
)

				t_ThreadObject->Uninitialise () ;
			}

			return;
		}
		catch(Heap_Exception e_HE)
		{
			t_ThreadObject->RemoveThread () ;

			if ( bInitialised )
			{
DebugMacro(

		SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\n *** [%S] Thread terminating -> heap exception *** " , t_ThreadObject->m_ThreadName ) ;
)

				t_ThreadObject->Uninitialise () ;
			}

			return;
		}
		catch(...)
		{
			t_ThreadObject->RemoveThread () ;

			if ( bInitialised )
			{
DebugMacro(

		SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\n *** [%S] Thread terminating -> exception *** " , t_ThreadObject->m_ThreadName ) ;
)

				t_ThreadObject->Uninitialise () ;
			}

			return;
		}
	}
	catch ( ... )
	{
DebugMacro(

		SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\n *** Thread terminating -> second chance exception *** " ) ;
)
	}
}

void SnmpThreadObject :: TerminateThread () 
{
    :: TerminateThread (m_ThreadHandle,0) ;
}

SnmpThreadObject :: SnmpThreadObject (
    
    const char *a_ThreadName,
    DWORD a_timeout
    
) : m_EventContainer ( NULL ) , 
    m_EventContainerLength ( 0 ) , 
    m_ThreadId ( 0 ) , 
    m_ThreadHandle ( 0 ) ,
    m_ThreadName ( NULL ) ,
    m_timeout ( a_timeout ),
    m_pShutdownTask ( NULL )
{
    if ( a_ThreadName )
    {
        m_ThreadName = _strdup ( a_ThreadName ) ;
        if( NULL == m_ThreadName) throw Heap_Exception(Heap_Exception::E_ALLOCATION_ERROR);
    }

    ConstructEventContainer () ;

}

void  SnmpThreadObject :: BeginThread()
{
    UINT_PTR t_PseudoHandle = _beginthread ( 

        SnmpThreadObject :: ThreadExecutionProcedure , 
        0 , 
        ( void * ) this
     ) ;

	s_Lock.Lock () ;
	LeaveCriticalSectionScope lcs ( s_Lock );

	if ( ( HANDLE ) t_PseudoHandle != INVALID_HANDLE_VALUE )
	{
		BOOL t_Status = DuplicateHandle ( 

			GetCurrentProcess () ,
			( HANDLE ) t_PseudoHandle ,
			GetCurrentProcess () ,
			GetThreadHandleReference () ,
			0 ,
			TRUE ,
			DUPLICATE_SAME_ACCESS
		) ;

		if ( ! t_Status )
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}
	}
}

BOOL SnmpThreadObject :: WaitForStartup ()
{
	BOOL bResult = FALSE;

    SnmpTaskObject t_TaskObject ;
    ScheduleTask ( t_TaskObject ) ;
    t_TaskObject.Exec () ;
    if ( ( bResult = t_TaskObject.Wait () ) == TRUE )
	{
		bResult = ReapTask ( t_TaskObject ) ;
	}

	return bResult;
}

SnmpThreadObject :: ~SnmpThreadObject ()
{
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Enter Thread destructor" ) ;
)
    if ( ( m_ThreadId != GetCurrentThreadId () ) && ( m_ThreadId != 0 ))
    {
        SignalThreadShutdown () ;
    }

    free ( m_ThreadName ) ;

    POSITION t_Position = m_TaskContainer.GetHeadPosition () ;
    while ( t_Position )
    {
        SnmpAbstractTaskObject *t_TaskObject = m_TaskContainer.GetNext ( t_Position ) ;

        t_TaskObject->DetachTaskFromThread ( *this ) ;
    }

    m_TaskContainer.RemoveAll () ;

    free ( m_EventContainer ) ;

	// we should have task already deleted by SignalThreadShutdown
	EnterCriticalSectionWait ecs ( s_Lock );
    s_ThreadContainer.RemoveKey ( m_ThreadId ) ;
    s_Lock.Unlock () ;

    if (m_pShutdownTask != NULL)
    {
        delete m_pShutdownTask;
    }

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Exit Thread destructor" ) ;
)

}

void SnmpThreadObject :: PostSignalThreadShutdown ()
{
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Posting thread shutdown" ) ;
)

    if (m_pShutdownTask != NULL)
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Thread shutdown previously posted" ) ;
)
    }
    else
    {
        m_pShutdownTask = new SnmpShutdownTaskObject(this);
        ScheduleTask(*m_pShutdownTask);
        m_pShutdownTask->Exec();
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Thread shutdown posted" ) ;
)
    }
}


void SnmpThreadObject :: SignalThreadShutdown ()
{
	EnterCriticalSectionWait ecs ( s_Lock ) ;
	LeaveCriticalSectionScope lcs ( s_Lock) ;
    BOOL t_bRemoved = s_ThreadContainer.RemoveKey ( m_ThreadId ) ;
	lcs.Exec ();

    if (t_bRemoved)
    {
		// this should be safe now
		if ( m_ThreadId == GetCurrentThreadId () )
		{
			m_ThreadTerminateEvent.Set () ;
		}
		else
		{
			HANDLE t_Handle = m_ThreadHandle ;
			m_ThreadTerminateEvent.Set () ;

			DWORD t_Event = WaitForSingleObject (

				t_Handle ,
				INFINITE 
			) ;

			if ( t_Event != WAIT_OBJECT_0 )
			{
				DWORD dwError = ERROR_SUCCESS;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_NOT_ENOUGH_MEMORY )
				{
					#if DBG == 1
					// for testing purpose I will let process break
					::DebugBreak();
					#endif
				}

				while ( ERROR_SUCCESS != dwError )
				{
					// resources will eventually come back
					::Sleep ( 1000 );

					if ( WAIT_OBJECT_0 == WaitForSingleObject	(
																	t_Handle ,
																	INFINITE 
																) )
					{
						// terminate loop
						dwError = ERROR_SUCCESS;
					}
				}
			}

			CloseHandle ( t_Handle ) ;
		}
	}
}

void SnmpThreadObject :: ConstructEventContainer ()
{
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Constructing Container" , m_ThreadName ) ;
)

	EnterCriticalSectionWait ecs ( s_Lock ) ;
	LeaveCriticalSectionScope lcs ( s_Lock ) ;

	BOOL bAllocated = FALSE;
	do
	{
		ULONG origEventContainerLength = m_EventContainerLength ;

		if ( ( m_TaskContainer.GetCount () + 2 ) <  MAXIMUM_WAIT_OBJECTS )
		{
			m_EventContainerLength = m_TaskContainer.GetCount () + 2;
		}
		else
		{
			m_EventContainerLength = MAXIMUM_WAIT_OBJECTS - 1;
		}

		PVOID pNewMem = realloc ( m_EventContainer , sizeof ( HANDLE ) * m_EventContainerLength );
		if ( pNewMem == NULL )
		{
			//
			// revert the size back
			//
			m_EventContainerLength = origEventContainerLength ;

			s_Lock.Unlock () ;
			// system will eventually come back !
			Sleep (60000);
			EnterCriticalSectionWait ecs ( s_Lock ) ;
		}
		else
		{
			m_EventContainer = ( HANDLE * ) pNewMem;
			bAllocated = TRUE;
		}
	}
	while ( ! bAllocated );

    m_EventContainer [ 0 ] = GetHandle () ;
    m_EventContainer [ 1 ] = m_ThreadTerminateEvent.GetHandle () ;

    ULONG t_EventIndex = 2 ;
    POSITION t_Position = m_TaskContainer.GetHeadPosition () ;
    while ( t_Position && (t_EventIndex < m_EventContainerLength))
    {
        SnmpAbstractTaskObject *t_TaskObject = m_TaskContainer.GetNext ( t_Position ) ;
        m_EventContainer [ t_EventIndex ] = t_TaskObject->GetHandle () ;
        t_EventIndex ++ ;
    }
}

void SnmpThreadObject :: RotateTask ( SnmpAbstractTaskObject *a_TaskObject )
{
	EnterCriticalSectionWait ecs ( s_Lock ) ;
	LeaveCriticalSectionScope lcs ( s_Lock );

    POSITION t_Position = m_TaskContainer.GetHeadPosition () ;
    while ( t_Position )
    {
        POSITION t_LastPosition = t_Position ;
        SnmpAbstractTaskObject *t_TaskObject = m_TaskContainer.GetNext ( t_Position ) ;
        if ( a_TaskObject->GetHandle () == t_TaskObject->GetHandle () ) 
        {
            m_TaskContainer.RemoveAt ( t_LastPosition ) ;
            m_TaskContainer.Add ( t_TaskObject ) ;
            break ;
        }
    }
}

SnmpThreadObject *SnmpThreadObject :: GetThreadObject () 
{
	EnterCriticalSectionWait ecs ( s_Lock ) ;
	LeaveCriticalSectionScope lcs ( s_Lock );

    DWORD t_CurrentThreadId = GetCurrentThreadId () ;

    SnmpThreadObject *t_ThreadObject ;
    if ( s_ThreadContainer.Lookup ( GetCurrentThreadId () , t_ThreadObject ) )
    {
    }
    else
    {
        t_ThreadObject = NULL ;
    }

    return t_ThreadObject ;
}

SnmpAbstractTaskObject *SnmpThreadObject :: GetTaskObject ( HANDLE &a_Handle )
{
	EnterCriticalSectionWait ecs ( s_Lock ) ;
	LeaveCriticalSectionScope lcs ( s_Lock );

    POSITION t_Position = m_TaskContainer.GetHeadPosition () ;
    while ( t_Position )
    {
        SnmpAbstractTaskObject *t_TaskObject = m_TaskContainer.GetNext ( t_Position ) ;
        if ( t_TaskObject->GetHandle () == a_Handle ) 
        {
            return t_TaskObject ;
        }
    }

    return NULL ;
}

BOOL SnmpThreadObject :: RegisterThread () 
{
	EnterCriticalSectionWait ecs ( s_Lock ) ;
	LeaveCriticalSectionScope lcs ( s_Lock );

    m_ThreadId = GetCurrentThreadId () ;
    s_ThreadContainer [ m_ThreadId ] = this ;

    BOOL t_Status = TRUE;

DebugMacro8(

    wchar_t buffer [ 1025 ] ;
    wsprintf ( buffer , L"\nThread [%S] = %lx, with thread id = %lx" , m_ThreadName , this , m_ThreadId ) ;
    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__, buffer ) ;
)
    return t_Status ;
}

BOOL SnmpThreadObject :: RemoveThread () 
{
	EnterCriticalSectionWait ecs ( s_Lock ) ;
	LeaveCriticalSectionScope lcs ( s_Lock );

	BOOL t_Status = s_ThreadContainer.RemoveKey ( m_ThreadId ) ;

	if ( t_Status )
	{
DebugMacro8(

	wchar_t buffer [ 1025 ] ;
	wsprintf ( buffer , L"\nThread [%S] = %lx, with thread id = %lx was removed from container" , m_ThreadName , (UINT_PTR)this , m_ThreadId ) ;
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__, buffer ) ;
)
	}
	else
	{
DebugMacro8(

	wchar_t buffer [ 1025 ] ;
	wsprintf ( buffer , L"\nThread [%S] = %lx, with thread id = %lx failed to remove from container" , m_ThreadName , (UINT_PTR)this , m_ThreadId ) ;
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__, buffer ) ;
)
	}

    return t_Status ;
}

void SnmpThreadObject :: Process () 
{
	EnterCriticalSectionWait ecs ( s_Lock ) ;
	LeaveCriticalSectionScope lcs ( s_Lock );

    POSITION t_Position = m_ScheduleReapEventContainer.GetStartPosition () ;
    while ( t_Position )
    {
        HANDLE t_EventId ;
        SnmpEventObject *t_Event ;
        m_ScheduleReapEventContainer.GetNextAssoc ( t_Position , t_EventId , t_Event) ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Thread Process [%lx]" , m_ThreadName , t_EventId);
)

        t_Event->Set () ;
    }
}

BOOL SnmpThreadObject :: WaitDispatch ( ULONG t_HandleIndex , BOOL &a_Terminated )
{
    BOOL t_Status = TRUE ;

    HANDLE t_Handle = m_EventContainer [ t_HandleIndex ] ;
    if ( t_Handle == GetHandle () )
    {
// Task has been scheduled so we must update arrays

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Thread Wait: Refreshing handles" , m_ThreadName );
)

        Process () ;
        ConstructEventContainer () ;
    }
    else if ( t_Handle == m_ThreadTerminateEvent.GetHandle () )
    {
// thread has been told to close down

        a_Terminated = TRUE ;
        m_ThreadTerminateEvent.Process () ;

DebugMacro8(

        SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Someone t_Terminated" , m_ThreadName )  ;
)
    }
    else
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Thread Wait: Processing Task" , m_ThreadName );
)

        SnmpAbstractTaskObject *t_TaskObject = GetTaskObject ( t_Handle ) ;
        if ( t_TaskObject )
        {
            RotateTask ( t_TaskObject ) ;
            ConstructEventContainer () ;
            t_TaskObject->Process () ;
        }
        else
        {
DebugMacro8(

            SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Couldn't Find Task Object" , m_ThreadName ) ;
)
            t_Status = FALSE ;
        }
    }

    return t_Status ;
}

BOOL SnmpThreadObject :: Wait ()
{
    BOOL t_Status = TRUE ;
    BOOL t_Terminated = FALSE ;

    while ( t_Status && ! t_Terminated )
    {
        DWORD t_Event = MsgWaitForMultipleObjects (

            m_EventContainerLength ,
            m_EventContainer ,
            FALSE ,
            m_timeout ,
            QS_ALLINPUT
        ) ;

        ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

        if ( t_Event == 0xFFFFFFFF )
        {
            DWORD t_Error = GetLastError () ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Handle problem" , m_ThreadName ) ;
)

            t_Status = FALSE ;
        }
        else if ( t_Event == WAIT_TIMEOUT)
        {
            TimedOut();
        }
        else if ( t_HandleIndex <= m_EventContainerLength )
        {
// Go into dispatch loop

            if ( t_HandleIndex == m_EventContainerLength )
            {
                BOOL t_DispatchStatus ;
                MSG t_Msg ;

                while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
                {
					int t_Result = 0;
					t_Result = GetMessage ( & t_Msg , NULL , 0 , 0 );

					if ( t_Result != 0 && t_Result != -1 )
                    {
                        TranslateMessage ( & t_Msg ) ;
                        DispatchMessage ( & t_Msg ) ;
                    }

                    BOOL t_Timeout = FALSE ;

                    while ( ! t_Timeout && t_Status && ! t_Terminated )
                    {
                        t_Event = WaitForMultipleObjects (

                            m_EventContainerLength ,
                            m_EventContainer ,
                            FALSE ,
                            0
                        ) ;

                        t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

                        if ( t_Event == 0xFFFFFFFF )
                        {
                            DWORD t_Error = GetLastError () ;
    
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Handle problem" , m_ThreadName ) ;
)
                            t_Status = FALSE ;
                        }
                        else if ( t_Event == WAIT_TIMEOUT)
                        {
                            t_Timeout = TRUE ;
                        }
                        else if ( t_HandleIndex < m_EventContainerLength )
                        {
                            t_Status = WaitDispatch ( t_HandleIndex , t_Terminated ) ;
                        }
                        else
                        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Unknown handle index" , m_ThreadName ) ;
)
                            t_Status = FALSE ;
                        }
                    }
                }
            }
            else if ( t_HandleIndex < m_EventContainerLength )
            {
                t_Status = WaitDispatch ( t_HandleIndex , t_Terminated ) ;
            }
            else
            {

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Unknown handle index" , m_ThreadName ) ;
)
                t_Status = FALSE ;
            }
        }
    }

    return t_Status ;
}

ULONG SnmpThreadObject :: GetEventHandlesSize ()
{
    return m_EventContainerLength ;
}

HANDLE *SnmpThreadObject :: GetEventHandles ()
{
    return m_EventContainer ;
}

BOOL SnmpThreadObject :: ScheduleTask ( SnmpAbstractTaskObject &a_TaskObject ) 
{
    BOOL t_Result = TRUE ;

	EnterCriticalSectionWait ecs ( s_Lock ) ;

/*
 * Add Synchronous object to worker thread container
 */
    a_TaskObject.m_ScheduledHandle = a_TaskObject.GetHandle ();
    m_TaskContainer.Add ( &a_TaskObject ) ; 

    s_Lock.Unlock () ;

    a_TaskObject.AttachTaskToThread ( *this ) ;

    if ( GetCurrentThreadId () != m_ThreadId ) 
    {
#if 0
        SnmpEventObject t_ScheduledEventObject ;

		EnterCriticalSectionWait ecs1 ( s_Lock ) ;

		m_ScheduleReapEventContainer [ t_ScheduledEventObject.GetHandle () ] = &t_ScheduledEventObject ;

        s_Lock.Unlock () ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ScheduleTask: Setting update" , m_ThreadName );
)
        Set () ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ScheduleTask: Beginning Wait" , m_ThreadName );
)

        if ( t_ScheduledEventObject.Wait () )
        {
        }
        else
        {
            t_Result = FALSE ;
        }

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ScheduleTask: Ended Wait" , m_ThreadName );
)

		EnterCriticalSectionWait ecs2 ( s_Lock ) ;

        m_ScheduleReapEventContainer.RemoveKey ( t_ScheduledEventObject.GetHandle () ) ;

        s_Lock.Unlock () ;
#else
        Set () ;
#endif
    }
    else
    {
        ConstructEventContainer () ;
    }

    return t_Result ;
}

BOOL SnmpThreadObject :: ReapTask ( SnmpAbstractTaskObject &a_TaskObject ) 
{
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Entering ReapTask [%lx]" , m_ThreadName , a_TaskObject.m_ScheduledHandle );
)

    BOOL t_Result = TRUE ;

	EnterCriticalSectionWait ecs ( s_Lock ) ;

/*
 *  Remove worker object from worker thread container
 */

    POSITION t_Position = m_TaskContainer.GetHeadPosition () ;
    while ( t_Position )
    {
        POSITION t_LastPosition = t_Position ;
        SnmpAbstractTaskObject *t_TaskObject = m_TaskContainer.GetNext ( t_Position ) ;
        if ( a_TaskObject.m_ScheduledHandle == t_TaskObject->m_ScheduledHandle )    
        {
            m_TaskContainer.RemoveAt ( t_LastPosition ) ;
            break ;
        }
    }

    s_Lock.Unlock () ;

/*
 * Inform worker thread,thread container has been updated.
 */

    if ( GetCurrentThreadId () != m_ThreadId ) 
    {
        SnmpEventObject t_ReapedEventObject ;

		EnterCriticalSectionWait ecs1 ( s_Lock ) ;

        m_ScheduleReapEventContainer [ t_ReapedEventObject.GetHandle () ] = &t_ReapedEventObject ;

        s_Lock.Unlock () ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ReapTask: Setting update" , m_ThreadName );
)
        Set () ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ReapTask: Beginning Wait on [%lx]" , m_ThreadName , t_ReapedEventObject.GetHandle () );
)

        if ( t_ReapedEventObject.Wait () )
        {
        }
        else
        {
            t_Result = FALSE ;
        }

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ReapTask: Ended Wait" , m_ThreadName );
)

		EnterCriticalSectionWait ecs2 ( s_Lock ) ;

        m_ScheduleReapEventContainer.RemoveKey ( t_ReapedEventObject.GetHandle () ) ;

        s_Lock.Unlock () ;

    }
    else
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ReapTask: ConstructEventContainer" , m_ThreadName );
)
        ConstructEventContainer () ;
    }

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Returning from ReapTask [%lx]" , m_ThreadName , a_TaskObject.m_ScheduledHandle );
)

    a_TaskObject.DetachTaskFromThread ( *this ) ;

    return t_Result ;
}

SnmpAbstractTaskObject :: SnmpAbstractTaskObject ( 

    const wchar_t *a_GlobalTaskNameComplete,
    const wchar_t *a_GlobalTaskNameAcknowledgement,
    DWORD a_timeout

) : m_CompletionEvent ( a_GlobalTaskNameComplete ) , 
    m_AcknowledgementEvent ( a_GlobalTaskNameAcknowledgement ) , 
    m_timeout ( a_timeout ), 
    m_ScheduledHandle (NULL)
{
} 

SnmpAbstractTaskObject :: ~SnmpAbstractTaskObject () 
{
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: ~SnmpAbstractTaskObject () [%lx]" , m_ScheduledHandle ) ;
)
	EnterCriticalSectionWait ecs ( m_Lock ) ;
	LeaveCriticalSectionScope lcs ( m_Lock );

    if (NULL != m_ScheduledHandle)
    {
        POSITION t_Position = m_ThreadContainer.GetStartPosition () ;
        while ( t_Position )
        {
            DWORD t_ThreadId ;
            SnmpThreadObject *t_ThreadObject ;
            m_ThreadContainer.GetNextAssoc ( t_Position , t_ThreadId , t_ThreadObject ) ;

            t_ThreadObject->ReapTask ( *this ) ;
        }
    }

    m_ThreadContainer.RemoveAll () ;    
}

void SnmpAbstractTaskObject :: DetachTaskFromThread ( SnmpThreadObject &a_ThreadObject )
{
	EnterCriticalSectionWait ecs ( m_Lock ) ;
	LeaveCriticalSectionScope lcs ( m_Lock );

    m_ThreadContainer.RemoveKey ( a_ThreadObject.GetThreadId () ) ;
}

void SnmpAbstractTaskObject :: AttachTaskToThread ( SnmpThreadObject &a_ThreadObject )
{
	EnterCriticalSectionWait ecs ( m_Lock ) ;
	LeaveCriticalSectionScope lcs ( m_Lock );

    m_ThreadContainer [ a_ThreadObject.GetThreadId () ] = &a_ThreadObject ;
}

BOOL SnmpAbstractTaskObject :: Wait ( BOOL a_Dispatch )
{
    BOOL t_Status = TRUE ;
    BOOL t_Processed = FALSE ;

    while ( t_Status && ! t_Processed )
    {
        SnmpThreadObject *t_ThreadObject = SnmpThreadObject :: GetThreadObject () ;
        ULONG t_TaskEventArrayLength = 0 ;
        HANDLE *t_TaskEventArray = NULL ;

        if ( t_ThreadObject && a_Dispatch )
        {
            ULONG t_TaskArrayLength = t_ThreadObject->GetEventHandlesSize () ;
            t_TaskEventArrayLength = t_TaskArrayLength + 1 ;
            t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;

            if ( t_TaskEventArray )
            {
	            t_TaskEventArray [ 0 ] = m_CompletionEvent.GetHandle () ;

                memcpy ( 
 
                    & ( t_TaskEventArray [ 1 ] ) ,
                    t_ThreadObject->GetEventHandles () ,
                    t_TaskArrayLength * sizeof ( HANDLE ) 
                ) ;     
            }
			else
			{
				return FALSE;
			}
        }
        else
        {
            t_TaskEventArrayLength = 1 ;
            t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;
            t_TaskEventArray [ 0 ] = m_CompletionEvent.GetHandle () ;
        }

        DWORD t_Event ;

        if ( a_Dispatch ) 
        {
            t_Event = MsgWaitForMultipleObjects (

                t_TaskEventArrayLength ,
                t_TaskEventArray ,
                FALSE ,
                m_timeout ,
                QS_ALLINPUT
            ) ;
        }
        else
        {
            t_Event = WaitForMultipleObjects (

                t_TaskEventArrayLength ,
                t_TaskEventArray ,
                FALSE ,
                m_timeout 
            ) ;
        }

        ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

        if ( t_Event == 0xFFFFFFFF )
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle" ) ;
)

            DWORD t_Error = GetLastError () ;
            t_Status = FALSE ;
        }
        else if ( t_Event == WAIT_TIMEOUT)
        {
            TimedOut();
        }
        else if ( t_HandleIndex == t_TaskEventArrayLength )
        {
            BOOL t_DispatchStatus ;
            MSG t_Msg ;

            while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
            {
				int t_Result = 0;
				t_Result = GetMessage ( & t_Msg , NULL , 0 , 0 );

				if ( t_Result != 0 && t_Result != -1 )
                {
                    TranslateMessage ( & t_Msg ) ;
                    DispatchMessage ( & t_Msg ) ;
                }

                BOOL t_Timeout = FALSE ;

                while ( ! t_Timeout && t_Status && ! t_Processed )
                {
                    t_Event = WaitForMultipleObjects (

                        t_TaskEventArrayLength ,
                        t_TaskEventArray ,
                        FALSE ,
                        0
                    ) ;

                    t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

                    if ( t_Event == 0xFFFFFFFF )
                    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle" ) ;
)

                        DWORD t_Error = GetLastError () ;
                        t_Status = FALSE ;
                    }
                    else if ( t_Event == WAIT_TIMEOUT)
                    {
                        t_Timeout = TRUE ;
                    }
                    else if ( t_HandleIndex < t_TaskEventArrayLength )
                    {
                        HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
                        t_Status = WaitDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
                    }
                    else
                    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle index" ) ;
)
                        t_Status = FALSE ;
                    }
                }
            }
        }
        else if ( t_HandleIndex < t_TaskEventArrayLength )
        {
            HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
            t_Status = WaitDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
        }
        else
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle index" ) ;
)

            t_Status = FALSE ;
        }

        delete [] t_TaskEventArray ;
    }

    return t_Status ;
}

BOOL SnmpAbstractTaskObject :: WaitDispatch ( SnmpThreadObject *a_ThreadObject, HANDLE a_Handle , BOOL &a_Processed )
{
    BOOL t_Status = TRUE ;

    if ( a_Handle == m_CompletionEvent.GetHandle () )
    {

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nWait: Completed" );
)


        m_CompletionEvent.Process () ;
        a_Processed = TRUE ;
    }
    else if ( a_ThreadObject && ( a_Handle == a_ThreadObject->GetHandle () ) )
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nTask Wait: Refreshing handles" );
)
        a_ThreadObject->Process () ;
        a_ThreadObject->ConstructEventContainer () ;
    }
    else
    {
        SnmpAbstractTaskObject *t_TaskObject = a_ThreadObject->GetTaskObject ( a_Handle ) ;
        if ( t_TaskObject )
        {
            a_ThreadObject->RotateTask ( t_TaskObject ) ;
            a_ThreadObject->ConstructEventContainer () ;
            t_TaskObject->Process () ;
        }
        else
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Task" ) ;
)
            t_Status = FALSE ;
        }
    }

    return t_Status ;
}

BOOL SnmpAbstractTaskObject :: WaitAcknowledgement ( BOOL a_Dispatch )
{
    BOOL t_Status = TRUE ;
    BOOL t_Processed = FALSE ;

    while ( t_Status && ! t_Processed )
    {
        SnmpThreadObject *t_ThreadObject = SnmpThreadObject :: GetThreadObject () ;
        ULONG t_TaskEventArrayLength = 0 ;
        HANDLE *t_TaskEventArray = NULL ;

        if ( t_ThreadObject && a_Dispatch )
        {
            ULONG t_TaskArrayLength = t_ThreadObject->GetEventHandlesSize () ;
            t_TaskEventArrayLength = t_TaskArrayLength + 1 ;
            t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;

            if ( t_TaskArrayLength )
            {
                memcpy ( 
 
                    & ( t_TaskEventArray [ 1 ] ) , 
                    t_ThreadObject->GetEventHandles () ,
                    t_TaskArrayLength * sizeof ( HANDLE ) 
                ) ;     
            }

            t_TaskEventArray [ 0 ] = m_AcknowledgementEvent.GetHandle () ;          
        }
        else
        {
            t_TaskEventArrayLength = 1 ;
            t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;
            t_TaskEventArray [ 0 ] = m_AcknowledgementEvent.GetHandle () ;
        }

        DWORD t_Event ;

        if ( a_Dispatch ) 
        {
            t_Event = MsgWaitForMultipleObjects (

                t_TaskEventArrayLength ,
                t_TaskEventArray ,
                FALSE ,
                m_timeout ,
                QS_ALLINPUT
            ) ;
        }
        else
        {
            t_Event = WaitForMultipleObjects (

                t_TaskEventArrayLength ,
                t_TaskEventArray ,
                FALSE ,
                m_timeout 
            ) ;
        }

        ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

        if ( t_Event == 0xFFFFFFFF )
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle" ) ;
)

            DWORD t_Error = GetLastError () ;
            t_Status = FALSE ;
        }
        else if ( t_Event == WAIT_TIMEOUT)
        {
            TimedOut();
        }
        if ( t_HandleIndex == t_TaskEventArrayLength )
        {
            BOOL t_DispatchStatus ;
            MSG t_Msg ;

            while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
            {
				int t_Result = 0;
				t_Result = GetMessage ( & t_Msg , NULL , 0 , 0 );

				if ( t_Result != 0 && t_Result != -1 )
                {
                    TranslateMessage ( & t_Msg ) ;
                    DispatchMessage ( & t_Msg ) ;
                }

                BOOL t_Timeout = FALSE ;

                while ( ! t_Timeout && t_Status && ! t_Processed )
                {
                    t_Event = WaitForMultipleObjects (

                        t_TaskEventArrayLength ,
                        t_TaskEventArray ,
                        FALSE ,
                        0
                    ) ;

                    ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

                    if ( t_Event == 0xFFFFFFFF )
                    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle" ) ;
)

                        DWORD t_Error = GetLastError () ;
                        t_Status = FALSE ;
                    }
                    else if ( t_Event == WAIT_TIMEOUT)
                    {
                        t_Timeout = TRUE ;
                    }
                    else if ( t_HandleIndex < t_TaskEventArrayLength )
                    {
                        HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
                        t_Status = WaitAcknowledgementDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
                    }
                    else
                    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle index" ) ;
)
                        t_Status = FALSE ;
                    }
                }
            }
        }
        else if ( t_HandleIndex < t_TaskEventArrayLength )
        {
            HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
            t_Status = WaitAcknowledgementDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
        }
        else
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle index" ) ;
)

            t_Status = FALSE ;
        }

        delete [] t_TaskEventArray ;
    }

    return t_Status ;
}

BOOL SnmpAbstractTaskObject :: WaitAcknowledgementDispatch ( SnmpThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed )
{
    BOOL t_Status = TRUE ;

    if ( a_Handle == m_AcknowledgementEvent.GetHandle () )
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nWait: Completed" );
)

        m_AcknowledgementEvent.Process () ;
        a_Processed = TRUE ;
    }
    else if ( a_ThreadObject && ( a_Handle == a_ThreadObject->GetHandle () ) )
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nTask Wait: Refreshing handles" );
)
        a_ThreadObject->Process () ;
        a_ThreadObject->ConstructEventContainer () ;
    }
    else
    {
        SnmpAbstractTaskObject *t_TaskObject = a_ThreadObject->GetTaskObject ( a_Handle ) ;
        if ( t_TaskObject )
        {
            a_ThreadObject->RotateTask ( t_TaskObject ) ;
            a_ThreadObject->ConstructEventContainer () ;
            t_TaskObject->Process () ;
        }
        else
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Task" ) ;
)
            t_Status = FALSE ;
        }
    }

    return t_Status ;
}

SnmpTaskObject::SnmpTaskObject ( 
    const wchar_t *a_GlobalTaskNameStart, 
    const wchar_t *a_GlobalTaskNameComplete ,
    const wchar_t *a_GlobalTaskNameAcknowledge,
    DWORD a_timeout

): SnmpAbstractTaskObject(a_GlobalTaskNameComplete, a_GlobalTaskNameAcknowledge,a_timeout), m_Event(a_GlobalTaskNameStart)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\include\snmpthrd.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __SNMPTHREAD_SNMPTHRD_H__
#define __SNMPTHREAD_SNMPTHRD_H__

class SnmpAbstractTaskObject ;

#ifdef SNMPTHRD_INIT
class __declspec ( dllexport ) SnmpThreadObject : private SnmpEventObject
#else
class __declspec ( dllimport ) SnmpThreadObject : private SnmpEventObject
#endif
{
friend SnmpAbstractTaskObject ;
friend BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
) ;

public:

	static LONG s_ReferenceCount ;

private:

// Mutual exclusion mechanism

	static CCriticalSection s_Lock ;

	SnmpMap <HANDLE,HANDLE,SnmpEventObject *,SnmpEventObject *> m_ScheduleReapEventContainer ;

// Thread Name

	char *m_ThreadName ;

// Terminate thread event

	SnmpEventObject m_ThreadTerminateEvent ;

// TaskObject created if a PostSignalThreadShutdown is called
	SnmpAbstractTaskObject* m_pShutdownTask ;
	
// thread information

	ULONG m_ThreadId ;
	HANDLE m_ThreadHandle ;
	DWORD m_timeout;

// list of task objects associated with thread object

	SnmpQueue <SnmpAbstractTaskObject *,SnmpAbstractTaskObject *> m_TaskContainer ;

	void RotateTask ( SnmpAbstractTaskObject *a_TaskObject ) ;

// Evict thread from process

	void TerminateThread () ;

// Attach thread to global list of threads

	BOOL RegisterThread () ;

// Remove thread from global list of threads

	BOOL RemoveThread () ;

private:

// global list of thread objects keyed on thread identifier

	static SnmpMap <DWORD,DWORD,SnmpThreadObject *,SnmpThreadObject *> s_ThreadContainer ;

	HANDLE *m_EventContainer ;
	ULONG m_EventContainerLength ;

	HANDLE *GetEventHandles () ;
	ULONG GetEventHandlesSize () ;

	void ConstructEventContainer () ;

	void Process () ;
	BOOL Wait () ;

	SnmpAbstractTaskObject *GetTaskObject ( HANDLE &eventHandle ) ;

	BOOL WaitDispatch ( ULONG t_HandleIndex , BOOL &a_Terminated ) ;

private:

// Thread entry point

	static void __cdecl ThreadExecutionProcedure ( void *threadParameter ) ;

// Attach Process

	static void ProcessAttach () ;

// Detach Process

	static void ProcessDetach ( BOOL a_ProcessDetaching = FALSE ) ;

	HANDLE *GetThreadHandleReference () { return &m_ThreadHandle ; }

protected:
public:

	SnmpThreadObject ( const char *a_ThreadName = NULL, DWORD a_timeout = INFINITE ) ;
	virtual ~SnmpThreadObject () ;

	void BeginThread () ;

	BOOL WaitForStartup () ;

	void SignalThreadShutdown () ;
	void PostSignalThreadShutdown () ;

// Get thread information

	ULONG GetThreadId () { return m_ThreadId ; }
	HANDLE GetThreadHandle () { return m_ThreadHandle ; }

	BOOL ScheduleTask ( SnmpAbstractTaskObject &a_TaskObject ) ;
	BOOL ReapTask ( SnmpAbstractTaskObject &a_TaskObject ) ;

	virtual void Initialise () {} ;
	virtual void Uninitialise () {} ;
	virtual void TimedOut() {} ;

// Get Thread object associated with current thread

	static SnmpThreadObject *GetThreadObject () ;

	static BOOL Startup () ;
	static void Closedown() ;

} ;

#ifdef SNMPTHRD_INIT
class __declspec ( dllexport ) SnmpAbstractTaskObject 
#else
class __declspec ( dllimport ) SnmpAbstractTaskObject 
#endif
{
friend SnmpThreadObject ;
private:

// list of thread objects keyed on thread identifier

	SnmpMap <DWORD,DWORD,SnmpThreadObject *,SnmpThreadObject *> m_ThreadContainer ;
	CCriticalSection m_Lock ;

	SnmpEventObject m_CompletionEvent ;
	SnmpEventObject m_AcknowledgementEvent ;
	HANDLE m_ScheduledHandle;
	DWORD m_timeout;

	BOOL WaitDispatch ( SnmpThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed ) ;
	BOOL WaitAcknowledgementDispatch ( SnmpThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed ) ;

	void AttachTaskToThread ( SnmpThreadObject &a_ThreadObject ) ;
	void DetachTaskFromThread ( SnmpThreadObject &a_ThreadObject ) ;

protected:

	SnmpAbstractTaskObject ( 

		const wchar_t *a_GlobalTaskNameComplete = NULL, 
		const wchar_t *a_GlobalTaskNameAcknowledgement = NULL, 
		DWORD a_timeout = INFINITE

	) ;

	virtual HANDLE GetHandle() = 0;

public:

	virtual ~SnmpAbstractTaskObject () ;

	virtual void Process () { Complete () ; }
	virtual void Exec () {} ;
	virtual void Complete () { m_CompletionEvent.Set () ; }
	virtual BOOL Wait ( BOOL a_Dispatch = FALSE ) ;
	virtual void Acknowledge () { m_AcknowledgementEvent.Set () ; } 
	virtual BOOL WaitAcknowledgement ( BOOL a_Dispatch = FALSE ) ;
	virtual void TimedOut() {} ;
} ;

#ifdef SNMPTHRD_INIT
class __declspec ( dllexport ) SnmpTaskObject : public SnmpAbstractTaskObject 
#else
class __declspec ( dllimport ) SnmpTaskObject : public SnmpAbstractTaskObject 
#endif
{
private:
	SnmpEventObject m_Event;
protected:
public:

	SnmpTaskObject ( 

		const wchar_t *a_GlobalTaskNameStart = NULL , 
		const wchar_t *a_GlobalTaskNameComplete = NULL,
		const wchar_t *a_GlobalTaskNameAcknowledgement = NULL, 
		DWORD a_timeout = INFINITE

	) ;

	~SnmpTaskObject () {} ;
	void Exec () { m_Event.Set(); }
	HANDLE GetHandle () { return m_Event.GetHandle() ; }
} ;

template <typename FT, FT F, BOOL Condition_> class VoidOnDeleteIf 
{
	private:
	BOOL	Condition_;
	BOOL	bExec;

	public:
	VoidOnDeleteIf ( ): bExec ( FALSE )
	{
	};

	void Exec ( )
	{
		if ( Condition_ )
		{
			F ( );
			bExec = TRUE;
		}
	}

	~VoidOnDeleteIf ( )
	{
		if ( !bExec )
		{
			Exec ();
		}
	};
};

template <typename FT, FT F, BOOL const &Condition_> class VoidOnDeleteIfNot 
{
	private:
	BOOL	bExec;

	public:
	VoidOnDeleteIfNot ( ): bExec ( FALSE )
	{
	};

	void Exec ( )
	{
		if ( !Condition_ )
		{
			F ( );
			bExec = TRUE;
		}
	}

	~VoidOnDeleteIfNot ( )
	{
		if ( !bExec )
		{
			Exec ();
		}
	};
};

template <typename T, typename FT, FT F> class ProvOnDelete
{
	private:
	T		Val_;
	BOOL	bExec;

	public:
	ProvOnDelete ( T Val ): Val_ ( Val ), bExec ( FALSE )
	{
	};

	void Exec ( )
	{
		F(Val_);
		bExec = TRUE;
	}

	~ProvOnDelete ( )
	{
		if ( !bExec )
		{
			Exec ();
		}
	};
};

template<class T> class CProvFreeMe
{
	protected:
    T* m_p;

	public:
    CProvFreeMe(T* p) : m_p(p){}
    ~CProvFreeMe() {free ( m_p );}
};

template<class T> class CProvDeleteMe
{
	protected:
    T* m_p;

	public:
    CProvDeleteMe(T* p) : m_p(p){}
    ~CProvDeleteMe() {delete m_p;}
};

template<class T> class CProvDeleteMeArray
{
	protected:
    T* m_p;

	public:
    CProvDeleteMeArray(T* p) : m_p(p){}
    ~CProvDeleteMeArray() {delete [] m_p;}
};

#ifndef	__WAITEX__
#define	__WAITEX__

template < typename T, typename FT, FT F, int iTime >
class WaitException
{
	public:
	WaitException ( T Val_ )
	{
		BOOL bResult = FALSE;
		while ( ! bResult )
		{
			try
			{
				F ( Val_ );
				bResult = TRUE;
			}
			catch ( ... )
			{
			}

			if ( ! bResult )
			{
				::Sleep ( iTime );
			}
		}
	}
};

#endif	__WAITEX__

#endif //__SNMPTHREAD_SNMPTHRD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\generator.cpp ===
//
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <autoptr.h>

#include <snmptempl.h>

#include <wbemidl.h>
#include <smir.h>

#include <bool.hpp>
#include <newString.hpp>
	
#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objectType.hpp>
#include <objectTypeV1.hpp>
#include <objectTypeV2.hpp>
#include <objectIdentity.hpp>
#include <trapType.hpp>
#include <notificationType.hpp>
#include <group.hpp>
#include <notificationGroup.hpp>
#include <module.hpp>


#include <stackValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMessage.hpp>
#include <errorContainer.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <abstractParseTree.hpp>
#include <oidTree.hpp>
#include <parseTree.hpp>

#include "main.hpp"
#include "generator.hpp"

// These functions are local to this file
static void CleanUpSmir(ISmirAdministrator *pAdminInt,
			ISmirModHandle *pModHandleInt);
static STDMETHODIMP GenerateModule (ISmirAdministrator *pAdminInt, 
				ISmirSerialiseHandle *pSerializeInt,
				const SIMCModule *module);
static STDMETHODIMP GenerateModuleNotifications (ISmirAdministrator *pAdminInt, 
				ISmirSerialiseHandle *pSerializeInt,
				const SIMCModule *module);
static char *GetImportModulesString(const SIMCModule *module);

static STDMETHODIMP GenerateObjectGroup(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			ISmirModHandle *pModHandleInt,  
			SIMCObjectGroup * group);
static STDMETHODIMP GenerateScalarGroup(ISmirAdministrator *pAdminInt,
				ISmirSerialiseHandle *pSerializeInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCObjectGroup * group,
				SIMCScalarMembers *scalars);
static STDMETHODIMP GenerateScalar(SIMCScalar *scalar,
				IWbemClassObject *scalarClass,
				BOOL mapInaccessibleToo,
				BOOL mapObsoleteToo);
static STDMETHODIMP GenerateTable(ISmirAdministrator *pAdminInt,
				ISmirSerialiseHandle *pSerializeInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCObjectGroup * group,
				SIMCTable *table);

static STDMETHODIMP CreatePropertyAndMapSyntaxClause(IWbemClassObject *scalarClass,
					SIMCSymbol **syntax,
					wchar_t *objectName);
static STDMETHODIMP MapSyntaxAttributes(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCTypeReference *btRef,
		SIMCDefinedTypeReference *dtRef,
		SIMCModule::TypeClass typeClass,
		SIMCModule::PrimitiveType primitiveType,
		BOOL isTextualConvention);
static STDMETHODIMP MapSizeTypeSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCSizeType *sizeType,
		const char *const displayHintAttribute);
static STDMETHODIMP MapRangeTypeSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCRangeType *rangeType,
		const char *const displayHintAttribute);
static STDMETHODIMP MapEnumeratedSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCEnumOrBitsType *enumType,
		const char *const displayHintAttribute);
static STDMETHODIMP MapBitsSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCEnumOrBitsType *enumType,
		const char *const displayHintAttribute);
static void SetPropertyType(VARTYPE &varType , const BSTR &type, 
							  const BSTR &textualConvention,
							  const char * enumerationPropertyValue);
static STDMETHODIMP MapOidValue(IWbemQualifierSet *attributeSet,
				const SIMCCleanOidValue &oidValue);
static STDMETHODIMP MapStatusClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapAccessClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapDescriptionClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapReferenceClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapUnitsClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapIndexClause(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeType *objectType,
				IWbemClassObject *tableClass);
static BOOL ContainsImpliedClause(const SIMCObjectTypeV2 *objectType);
static STDMETHODIMP MapIndexClauseV1(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV1 *objectType,
				IWbemClassObject *tableClass);
static STDMETHODIMP MapIndexClauseV2(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV2 *objectType,
				IWbemClassObject *tableClass);
static STDMETHODIMP MapAugmentsClauseV2(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV2 *objectType,
				SIMCTable *augmentedTable,
				IWbemClassObject *tableClass);
static HRESULT MapIndexTypeReference(SIMCTable *table, 
					IWbemClassObject *tableClass,
					SIMCSymbol **syntaxSymbol,
					long ordinal);
static HRESULT MapIndexValueReference(SIMCTable *table, 
					IWbemClassObject *tableClass, 
					SIMCSymbol **symbol,
					long ordinal);

static STDMETHODIMP MapDefValClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapIntegerDefVal(IWbemQualifierSet *attributeSet, 
									 SIMCIntegerValue *value);
static STDMETHODIMP MapOctetStringDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCOctetStringValue *value);
static STDMETHODIMP MapBooleanDefVal(IWbemQualifierSet *attributeSet, 
									 SIMCBooleanValue *value);
static STDMETHODIMP MapNullDefVal(IWbemQualifierSet *attributeSet, 
									 SIMCNullValue *value);
static STDMETHODIMP MapOidDefVal(IWbemQualifierSet *attributeSet, 
									 SIMCOidValue *value);
static STDMETHODIMP MapBitsDefVal(IWbemQualifierSet *attributeSet, 
									 SIMCBitsValue *value);
static STDMETHODIMP SetDefValAttribute( IWbemQualifierSet *attributeSet,
									   const char * const str);
static STDMETHODIMP GenerateNotificationType(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement);
static STDMETHODIMP GenerateNotificationAttributes(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *notificationClass);
static STDMETHODIMP GenerateExNotificationAttributes(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *exNotificationClass);
static STDMETHODIMP GenerateNotificationProperties(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *notificationClass);
static STDMETHODIMP GenerateExNotificationProperties(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *exNotificationClass);
static STDMETHODIMP GenerateNotificationObject(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			SIMCSymbol **object,
			int varBindIndex,
			IWbemClassObject *notificationClass);
static STDMETHODIMP GenerateExNotificationObject(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			SIMCSymbol **object,
			int varBindIndex,
			IWbemClassObject *exNotificationClass);

//Sets the "key" attribute of a property
static STDMETHODIMP MakeKey(IWbemQualifierSet *);

//Sets the "virtual_key" and "key" attribute of a property
static STDMETHODIMP MakeVirtualKey(IWbemQualifierSet *);

//Sets the "key_order" attribute of a property
static STDMETHODIMP SetKeyOrder(IWbemQualifierSet *, long ordinal);

// Sets the "provider" attribute of a class
static STDMETHODIMP SetProvider(IWbemQualifierSet *attributeSet, OLECHAR FAR *value);

//Sets the "dynamic" attribute of a class
static STDMETHODIMP MakeDynamic(IWbemQualifierSet *attributeSet);

// Sets the "object_identifier" attribute of a notification class
static STDMETHODIMP SetObjectIdentifierAttribute (IWbemQualifierSet *attributeSet, SIMCSymbol **object);

// Sets the "object_identifier" attribute of a notification class
static STDMETHODIMP SetCIMTYPEAttribute (IWbemQualifierSet *attributeSet, LPCWSTR pszRefClassName);

// Sets the "VarBindIndex" attribute of a notification class
static STDMETHODIMP SetVarBindIndexAttribute (IWbemQualifierSet *attributeSet, int varBindIndex);

// Returns TRUE if the symbol resolves ultimately to the NULL type
static BOOL IsNullTypeReference(SIMCSymbol ** symbol);

// This is required due to the HMOM limitation
static char *ConvertHyphensToUnderscores(const char *const input);

// This is a global, set by the /z switch	  
BOOL simc_debug;
// The globals for this file
static const SIMCOidTree *oidTree;
static SIMCParseTree *parseTree;
static const SIMCUI *UI;
static BOOL generateMof;
static BOOL notificationsOnly;		// Set by the /o switch
static BOOL extendedNotifications;	// Set by the /ext switch
static BOOL notifications;			// Set by the /t switch

// A routine to convert BSTRs to ANSI
char * ConvertBstrToAnsi(const BSTR& unicodeString)
{
	int textLength = wcstombs ( NULL , unicodeString , 0 ) ;
	char *textBuffer = new char [ textLength + 1 ] ;
	textLength = wcstombs ( textBuffer , unicodeString , textLength + 1 ) ;

	return textBuffer ;
}

// And to convert an ansi string to BSTR   
BSTR ConvertAnsiToBstr(const char * const input)
{
	if( input == NULL)
		return NULL;
	unsigned long len = strlen(input);
	BSTR retVal;
	wchar_t *temp = new wchar_t[len+1];
	if(mbstowcs(temp, input, len+1) != len)
	{
		delete []temp;
		return NULL;
	}
	else
	{
		retVal = SysAllocString(temp);
		delete []temp;
		return retVal;
	}
}

// This is required due to the HMOM limitation
static char *ConvertHyphensToUnderscores(const char * const input)
{
	if(!input)
		return NULL;
	char * retVal = NewString(input);
	if(retVal)
	{
		int i = 0;
		while(retVal[i])
		{
			if( retVal[i] == '-')
				retVal[i] = '_';
			i++;
		}
	}
	return retVal;
}

// Checks whether the object has an ACCESS clause which
// is "not-accessible" or "accessible-for-notify"
BOOL IsInaccessibleObject(SIMCObjectTypeType *objectType)
{

	switch(SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			switch( ((SIMCObjectTypeV1 *)objectType)->GetAccess())
			{
				case SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE:
					return TRUE;
				default:
					return FALSE;
			}
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			switch( ((SIMCObjectTypeV2 *)objectType)->GetAccess())
			{
				case SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE:
				case SIMCObjectTypeV2::ACCESS_FOR_NOTIFY:
					return TRUE;
				default:
					return FALSE;
			}
			break;
	}
	return FALSE;
}

// Checks whether the object has a STATUS clause which
// is "obsolete"
BOOL IsObsoleteObject(SIMCObjectTypeType *objectType)
{

	switch(SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			switch( ((SIMCObjectTypeV1 *)objectType)->GetStatus())
			{
				case SIMCObjectTypeV1::STATUS_OBSOLETE:
					return TRUE;
				default:
					return FALSE;
			}
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			switch( ((SIMCObjectTypeV2 *)objectType)->GetStatus())
			{
				case SIMCObjectTypeV2::STATUS_OBSOLETE:
					return TRUE;
				default:
					return FALSE;
			}
			break;
	}
	return FALSE;
}

// The only non-static function in this file
STDMETHODIMP GenerateClassDefinitions (ISMIRWbemConfiguration *a_Configuration , const SIMCUI& theUI, SIMCParseTree& theParseTree, BOOL _generateMof)
{
	// Initialize the Global variables first
	oidTree = theParseTree.GetOidTree();
	parseTree = &theParseTree;
	UI = &theUI;
	generateMof = _generateMof;
	notificationsOnly = UI->DoNotificationsOnly();
	extendedNotifications = UI->DoExtendedNotifications();
	notifications = UI->DoNotifications();

	SIMCModule * mainModule = theParseTree.GetModuleOfFile(theUI.GetInputFileName());

	// Create the administrator, to load the module
	ISmirAdministrator *pAdminInt = NULL ;
	HRESULT result = a_Configuration->QueryInterface (IID_ISMIR_Administrative,(PPVOID)&pAdminInt);

	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "CoCreate() on Administrator failed" << endl;
		return result;
	}

	// If generating MOF, get the serialize handle
	ISmirSerialiseHandle *pSerializeInt;
	if(generateMof)
	{
		result = pAdminInt->GetSerialiseHandle(&pSerializeInt, theUI.ClassDefinitionsOnly());
		if(FAILED(result))
		{
			if(simc_debug)
				cerr << "CoCreate() on Serialize failed" << endl;
			pAdminInt->Release();
			return result;
		}
	}


	// Generate the classes in  the module
	if( !notificationsOnly)
		result = GenerateModule (pAdminInt, pSerializeInt, mainModule);

	// Generate notification classes
	if( SUCCEEDED(result) )
	{
		if( notifications || extendedNotifications)
			result = GenerateModuleNotifications(pAdminInt, pSerializeInt, mainModule);
	}

	// Generate MOF if necessary
	if(generateMof && !FAILED(result))
	{
		// Output the text
		BSTR text;
		if(FAILED(pSerializeInt->GetText(&text)))
		{
			if(simc_debug)
				cerr << "GetText() Failed" << endl;
			pAdminInt->Release();
			pSerializeInt->Release();
			return result;
		}
		else
		{
			char * textStr = ConvertBstrToAnsi(text);
			if(textStr)
			{
				// Microsoft copyright 
				cout << MICROSOFT_COPYRIGHT << endl << "//" << endl;

				// MOF Header
				cout << "//\tMOF Generated for module \"" <<
					mainModule->GetModuleName() << 
					"\" by smi2smir version " << versionString << endl << "//" << endl;

				if(theUI.GenerateContextInfo())
				{
					cout << "//\tCommand-line: " << theUI.GetCommandLine()	<< endl;
					cout << "//\tDate and Time (dd/mm/yy:hh:mm:ss) : " <<
						theUI.GetDateAndTime() << endl;
					cout <<	"//\tHost : " << theUI.GetHostName() <<
						", User : " << theUI.GetUserName() << endl;
					cout << "//\tProcess Directory : " << 
						theUI.GetProcessDirectory() << endl << endl << endl;
				}

				// MOF Body
				cout << textStr << endl;
			}
		}

		pSerializeInt->Release();
	}

	pAdminInt->Release();
	return result;
}


static STDMETHODIMP GenerateModule (ISmirAdministrator *pAdminInt, 
									ISmirSerialiseHandle *pSerializeInt,
									const SIMCModule *module  )
{
	// Create a module, to get the module handle.
	ISmirModHandle	*pModHandleInt=NULL;
	HRESULT result = CoCreateInstance (CLSID_SMIR_ModHandle , NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
			IID_ISMIR_ModHandle,(PPVOID)&pModHandleInt);

	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "CoCreate() on Module failed" << endl;
		return result;
	}
	
	// Set the module characteristics ...
	BSTR	organization		= ConvertAnsiToBstr(module->GetOrganization());
	BSTR	contactInfo			= ConvertAnsiToBstr(module->GetContactInfo());
	BSTR	lastUpdated			= ConvertAnsiToBstr(module->GetLastUpdated());
	BSTR	description			= ConvertAnsiToBstr(module->GetDescription());
	BSTR	moduleIdentityName	= ConvertAnsiToBstr(module->GetModuleIdentityName());
	char 	*moduleNameMangled	= ConvertHyphensToUnderscores(module->GetModuleName());
	BSTR	moduleName			= ConvertAnsiToBstr(moduleNameMangled);
	delete moduleNameMangled;

	// Revision clause takes a little more effort, since all the revision clauses have to
	// be concatenated.
	CString revisionValue = "";
	const SIMCRevisionList * theRevisionList = module->GetRevisionList();
	if(theRevisionList && !theRevisionList->IsEmpty())
	{
		SIMCRevisionElement *nextElement;
		POSITION p = theRevisionList->GetHeadPosition();
		while(p)
		{
			nextElement = theRevisionList->GetNext(p);
			revisionValue += nextElement->GetRevision();
			revisionValue += "\r\n";
			revisionValue += nextElement->GetDescription();
 			revisionValue += "\r\n";
		}
	}
	BSTR	revisionClause	= ConvertAnsiToBstr(revisionValue);

	//	... moduleIdentityOidValue ...
	SIMCCleanOidValue moduleIdentityOidValue;
	if( !module->GetModuleIdentityValue(moduleIdentityOidValue))
	{
		SysFreeString(organization);
		SysFreeString(contactInfo);
		SysFreeString(lastUpdated);
		SysFreeString(description);
		SysFreeString(moduleIdentityName);
		SysFreeString(moduleName);
	
		if(simc_debug)
			cerr << "GetModuleIdentityValue() failed" << endl;
		pModHandleInt->Release();
		return WBEM_E_FAILED;
	}

	char * oidValueString = CleanOidValueToString(moduleIdentityOidValue);
	BSTR moduleIdentityValue = ConvertAnsiToBstr(oidValueString);
	//delete []oidValueString;

	// ... imports 
	char * importModulesString = GetImportModulesString(module);
	BSTR importModulesValue;
	if(importModulesString)
		importModulesValue = ConvertAnsiToBstr(importModulesString);
	else
		importModulesValue = ConvertAnsiToBstr("");


	pModHandleInt->SetName(moduleName);
	pModHandleInt->SetModuleOID(moduleIdentityValue);
	pModHandleInt->SetModuleIdentity(moduleIdentityName);
	pModHandleInt->SetOrganisation(organization);
	pModHandleInt->SetContactInfo(contactInfo);
	if(!UI->SuppressText()) pModHandleInt->SetDescription(description);
	pModHandleInt->SetLastUpdate(lastUpdated);
	pModHandleInt->SetRevision(revisionClause);
	pModHandleInt->SetSnmpVersion(module->GetSnmpVersion());
	pModHandleInt->SetModuleImports(importModulesValue);

	// if(importModulesString) delete importModulesString;

	SysFreeString(organization);
	SysFreeString(contactInfo);
	SysFreeString(lastUpdated);
	SysFreeString(description);
	SysFreeString(moduleIdentityName);
	SysFreeString(moduleName);
	SysFreeString(moduleIdentityValue);
	SysFreeString(importModulesValue);
	SysFreeString(revisionClause);

	if(generateMof)
	{
		if(FAILED(result = pAdminInt->AddModuleToSerialise(pModHandleInt, pSerializeInt)))
		{
			if(simc_debug) cerr << "GenerateModule(): AddModuleToSerialize() failed" << endl;
			pModHandleInt->Release();
			return result;
		}
	}
	else
	{
		switch(result = pAdminInt->AddModule(pModHandleInt) )
		{
			case WBEM_E_FAILED:
				if(simc_debug) cerr << "GenerateModule(): AddModule() failed: WBEM_E_FAILED" << endl;
				pModHandleInt->Release();
				return result;

			case E_INVALIDARG:
				if(simc_debug) cerr << "GenerateModule(): AddModule() failed: E_INVALIDARG" << endl;
				pModHandleInt->Release();
				return result;

			case E_UNEXPECTED:
				if(simc_debug) cerr << "GenerateModule(): AddModule() failed: E_UNEXPECTED" << endl;
				pModHandleInt->Release();
				return result;
		}
	}

	SIMCGroupList * groupList = module->GetObjectGroupList();
	if(!groupList)
	{
		pModHandleInt->Release();
		return S_OK;
	}

	POSITION p = groupList->GetHeadPosition();
	while(p)
	{
		if( FAILED(GenerateObjectGroup(pAdminInt, pSerializeInt, pModHandleInt, groupList->GetNext(p))))
		{
			CleanUpSmir(pAdminInt, pModHandleInt);
			pModHandleInt->Release();
			return WBEM_E_FAILED;
		}
	}

	pModHandleInt->Release();
	return S_OK;
}

static char *GetImportModulesString(const SIMCModule *module)
{
	strstream outStream;
	const SIMCModuleNameList * importModulesList = module->GetImportModuleNameList();
	if(!importModulesList)
		return NULL;

	POSITION p = importModulesList->GetHeadPosition();
	CString nextModuleName;
	long index = importModulesList->GetCount();
	while(p)
	{
		nextModuleName = importModulesList->GetNext(p);
		index --;
		outStream << nextModuleName;
		if(index)
			outStream << ",";
	}

	outStream << ends;
	return outStream.str();
}


static STDMETHODIMP GenerateObjectGroup(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			ISmirModHandle *pModHandleInt,  
			SIMCObjectGroup * group)
{

	SIMCScalarMembers *scalars = group->GetScalarMembers();
	HRESULT result;

	ISmirGroupHandle	*pGroupHandleInt=NULL;
	result = CoCreateInstance (CLSID_SMIR_GroupHandle , NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
				IID_ISMIR_GroupHandle,(PPVOID)&pGroupHandleInt);
	
    if (FAILED(result))
    {
		if(simc_debug) cerr << " GenererateObjectGroup(): Failed to CoCreate ISMIR Group" << endl;
		return result;
	}


	//fill in the group details
	BSTR groupName; 
	BSTR groupOid; 
	BSTR status; 
	BSTR description; 
	BSTR reference;

	char *groupNameMangled = ConvertHyphensToUnderscores(group->GetObjectGroupName());
	// Name
	groupName = ConvertAnsiToBstr(groupNameMangled);
	delete groupNameMangled;
	if(FAILED(pGroupHandleInt->SetName(groupName)) )
	{
		if(simc_debug) cerr << "GenerateObjectGroup(): Failed to SetName()" << endl;
		SysFreeString(groupName);
		pGroupHandleInt->Release();
		return WBEM_E_FAILED;
	}
	SysFreeString(groupName);
	
	// OID Value
	char * oidValueString = CleanOidValueToString(*group->GetGroupValue());
	groupOid = ConvertAnsiToBstr(oidValueString);
	// delete oidValueString;
	if(FAILED(pGroupHandleInt->SetGroupOID(groupOid)) )
	{
		if(simc_debug) cerr << "GenerateObjectGroup(): Failed to SetGroupOid()" << endl;
		SysFreeString(groupOid);
		pGroupHandleInt->Release();
		return WBEM_E_FAILED;
	}
	SysFreeString(groupOid);


	// Status
	status = ConvertAnsiToBstr(group->GetStatusString());
	if(FAILED(pGroupHandleInt->SetStatus(status)) )
	{
		if(simc_debug) cerr << "GenerateObjectGroup(): Failed to SetGroupOid()" << endl;
		SysFreeString(status);
		pGroupHandleInt->Release();
		return WBEM_E_FAILED;
	}
	SysFreeString(status);


	// Description
	description = ConvertAnsiToBstr(group->GetDescription());
	if(FAILED(pGroupHandleInt->SetDescription(description) ) )
	{
		if(simc_debug) cerr << "GenerateObjectGroup(): Failed to SetDescription()" << endl;
		SysFreeString(description);
		pGroupHandleInt->Release();
		return WBEM_E_FAILED;
	}
	SysFreeString(description);


	// Reference 
	reference = ConvertAnsiToBstr(group->GetReference());
	
	if(FAILED(pGroupHandleInt->SetReference(reference)) )
	{
		if(simc_debug) cerr << "GenerateObjectGroup(): Failed to SetReference()" << endl;
		SysFreeString(reference);
		pGroupHandleInt->Release();
		return WBEM_E_FAILED;
	}

	SysFreeString(reference);

	// NOW ADD THE GROUP
	if(generateMof )
	{
		result = pAdminInt->AddGroupToSerialise(pModHandleInt, pGroupHandleInt, pSerializeInt);
		switch(result)
		{
			case E_INVALIDARG:
				if(simc_debug) cerr << "GenerateObjectGroup(): AddGroup() failed" << endl;
				pGroupHandleInt->Release();
				return result;
			case E_UNEXPECTED:
				if(simc_debug) cerr << "GenerateObjectGroup(): AddGroup() failed" << endl;
				pGroupHandleInt->Release();
				return result;
			case S_OK:
				break;
		}
	}
	else 
	{
		result = pAdminInt->AddGroup(pModHandleInt, pGroupHandleInt);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateObjectGroup(): AddGroup() failed" << endl;
			pGroupHandleInt->Release();
			return result;
		}
	}

	// CREATE THE CLASSES IN THE GROUP

	// THE SCALAR CLASSES
	if(scalars && !scalars->IsEmpty())
	{	
		result = GenerateScalarGroup(pAdminInt, pSerializeInt, pGroupHandleInt, group, scalars);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateObjectGroup(): GenerateScalars failed" << endl;
			pGroupHandleInt->Release();
			return result;
		}
		
	}

	// THE TABLE CLASSES
	SIMCTableMembers *tables = group->GetTableMembers();
	SIMCTable *nextTable;
	if(tables)
	{
		POSITION p = tables->GetHeadPosition();
		while(p)
		{
			nextTable = tables->GetNext(p);
			if( FAILED(GenerateTable(pAdminInt,  pSerializeInt, pGroupHandleInt, 
						group, nextTable) ))
			{
				pGroupHandleInt->Release();
				return WBEM_E_FAILED;
			}
		}
	}
	pGroupHandleInt->Release();
	return S_OK;
}

static STDMETHODIMP GenerateScalarGroup(ISmirAdministrator *pAdminInt,
				ISmirSerialiseHandle *pSerializeInt,
				ISmirGroupHandle *pGroupHandleInt,
				SIMCObjectGroup * group,
				SIMCScalarMembers *scalars)
{
	// Form the name of the scalar group
	SIMCSymbol *namedNode = group->GetNamedNode();
	// Use the module of one of the scalars as the module name, and not
	// the named node's module since this can be somthing else
	SIMCModule *module = scalars->GetHead()->GetSymbol()->GetModule();

	const char * const moduleName = module->GetModuleName();
	const char * const namedNodeName = namedNode->GetSymbolName();

	// Create a scalar class

	// Set the scalar group name	
	char *scalarGroupName = new char[strlen(GROUP_NAME_PREPEND_STRING) +
					strlen(moduleName) + 1 + strlen(namedNodeName) +1 ];
	strcpy(scalarGroupName, GROUP_NAME_PREPEND_STRING);
	strcat(scalarGroupName, moduleName);
	strcat(scalarGroupName, "_");
	strcat(scalarGroupName, namedNodeName);

	BSTR groupName = ConvertAnsiToBstr(ConvertHyphensToUnderscores(scalarGroupName));
	delete scalarGroupName;

	ISmirClassHandle *scalarClassHandle = NULL ;
	HRESULT result = pAdminInt->CreateWBEMClass(groupName, &scalarClassHandle);

	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Get Scalar class failed" << endl;
		return result;
	}

	IWbemClassObject *scalarClass = NULL ;

	result = scalarClassHandle->GetWBEMClass ( & scalarClass ) ;
  	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): GetWBEMClass failed" << endl;
		scalarClassHandle->Release();
		return result;
	}

	// ---------------- Set Attributes of the class ------------------
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetQualifierSet (&attributeSet);
  	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): GetAttribSet failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		return result;
	}

	VARIANT variant;
	// "description"
	VariantInit(&variant);

	if(!UI->SuppressText())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr("");
		result = attributeSet->Put ( DESCRIPTION_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION ) ;
		VariantClear ( & variant ) ;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateScalarGroup(): Put description failed" << endl;
			scalarClassHandle->Release();
			scalarClass->Release();
			attributeSet->Release();
			return result;
		}
	}
	// "module_name"
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(moduleName);
	result = attributeSet->Put ( MODULE_NAME_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION ) ;
	VariantClear ( & variant ) ;
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Put module_name failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		attributeSet->Release();
		return result;
	}

	// "singleton"
	VariantInit(&variant);
	variant.vt = VT_BOOL ;
	variant.boolVal = VARIANT_TRUE;
	result = attributeSet->Put ( SINGLETON_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION ) ;
	VariantClear ( & variant ) ;
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Put singleton failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		attributeSet->Release();
		return result;
	}

	// "group_objectid"
	char *groupOidStr = (char *)CleanOidValueToString(*group->GetGroupValue());
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(groupOidStr);
	result = attributeSet->Put ( GROUP_OBJECTID_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear ( & variant ) ;
	// delete []groupOidStr;
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Put group_objectid failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		attributeSet->Release();
		return result;
	}

	// "dynamic"
	if(FAILED(MakeDynamic(attributeSet)))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Make Dynamic failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		attributeSet->Release();
		return WBEM_E_FAILED;
	}

	// "provider"
	if(FAILED(SetProvider(attributeSet, SNMP_INSTANCE_PROVIDER)))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Make Provider failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		attributeSet->Release();
		return WBEM_E_FAILED;
	}


	// Set the properties of the class
	SIMCScalar *nextScalar;
	POSITION p = scalars->GetHeadPosition();
	while(p)
	{
		nextScalar = scalars->GetNext(p);
		if( GenerateScalar(nextScalar, scalarClass, FALSE, FALSE) 
							== WBEM_E_FAILED)
		{
			scalarClassHandle->Release();
			scalarClass->Release();
			attributeSet->Release();
			return WBEM_E_FAILED;
		}
	}

	scalarClass->Release();
	attributeSet->Release();
 
   	// Add the class to the Group

	if(generateMof)
	{
		if(FAILED(pAdminInt->AddClassToSerialise(pGroupHandleInt, scalarClassHandle, pSerializeInt)))
		{
			if(simc_debug) cerr << "GenerateScalarGroup(): AddClassToSerialise() Failed" << endl;
			scalarClassHandle->Release();
			return WBEM_E_FAILED;
		}
	}
	else
	{
		if(FAILED(pAdminInt->AddClass(pGroupHandleInt, scalarClassHandle)))
		{
			//pGroupHandleInt->AddRef();
			if(simc_debug) cerr << "GenerateScalarGroup(): AddClass() Failed" << endl;
			scalarClassHandle->Release();
			return WBEM_E_FAILED;
		}
	}

	scalarClassHandle->Release();
	return S_OK;	
}

static STDMETHODIMP SetProvider(IWbemQualifierSet *attributeSet, OLECHAR FAR *providerName)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = SysAllocString(providerName);
	HRESULT result = attributeSet->Put ( PROVIDER_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	if (FAILED(result))
		if(simc_debug) cerr << "MakeKey(): Put Provider failed" << endl;
	
	return result;
}

// Sets the "object_identifier" attribute of a notification class
static STDMETHODIMP SetCIMTYPEAttribute (IWbemQualifierSet *attributeSet, LPCWSTR pszRefClassName)
{
	LPWSTR pszRefValue = new WCHAR[wcslen(pszRefClassName) + wcslen(L"ref:") + 1] ;
	wcscpy(pszRefValue, L"ref:");
	wcscat(pszRefValue, pszRefClassName);

	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = SysAllocString(pszRefValue);
	delete [] pszRefValue;

	HRESULT result = attributeSet->Put ( CIMTYPE_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	if (FAILED(result))
		if(simc_debug) cerr << "MakeKey(): Put CIMTYPE for REF failed" << endl;
	
	return result;
}
 
static STDMETHODIMP MakeDynamic(IWbemQualifierSet *attributeSet)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BOOL ;
	variant.boolVal = VARIANT_TRUE;
	HRESULT result = attributeSet->Put ( DYNAMIC_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	if (FAILED(result))
		if(simc_debug) cerr << "MakeKey(): Put Dynamic failed" << endl;
	
	return result;
}



static STDMETHODIMP GenerateScalar(SIMCScalar *scalar,
				IWbemClassObject *scalarClass, 
				BOOL  mapInaccessibleToo,
				BOOL mapObsoleteToo)
{

	SIMCSymbol *scalarSymbol = scalar->GetSymbol();
	SIMCSymbol **scalarSymbolP = &scalarSymbol;
	SIMCCleanOidValue *oidValue = scalar->GetOidValue();

	SIMCBuiltInValueReference *bvRef;
	SIMCSymbol **typeRefSymbol;
	if( SIMCModule::IsValueReference(scalarSymbolP, typeRefSymbol, bvRef) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;

	SIMCTypeReference *btRef;
	if( SIMCModule::IsTypeReference(typeRefSymbol, btRef) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;

	SIMCSymbol **btRefP = (SIMCSymbol**)&btRef;
	if( SIMCModule::GetSymbolClass(btRefP) != SIMCModule::SYMBOL_BUILTIN_TYPE_REF)
		return WBEM_E_FAILED;

	SIMCType *theType = ((SIMCBuiltInTypeReference *)btRef)->GetType();
	SIMCModule::TypeClass typeClass = SIMCModule::GetTypeClass(theType);

	// Dont map certain objects based on access clause
	if(!mapInaccessibleToo)
	{
		switch(typeClass)
		{
			case SIMCModule::TYPE_OBJECT_TYPE_V1:
				if( ((SIMCObjectTypeV1*)theType)->GetAccess() == SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE)
					return S_OK;
				break;
			case SIMCModule::TYPE_OBJECT_TYPE_V2:
				if( ((SIMCObjectTypeV2*)theType)->GetAccess() == SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE ||
					((SIMCObjectTypeV2*)theType)->GetAccess() == SIMCObjectTypeV2::ACCESS_FOR_NOTIFY )
					return S_OK;
				break;
			default:
				return WBEM_E_FAILED;
		}
	}

	// Dont map certain objects based on status clause
	if(!mapObsoleteToo)
	{
		switch(typeClass)
		{
			case SIMCModule::TYPE_OBJECT_TYPE_V1:
				if( ((SIMCObjectTypeV1*)theType)->GetStatus() == SIMCObjectTypeV1::STATUS_OBSOLETE)
					return S_OK;
				break;
			case SIMCModule::TYPE_OBJECT_TYPE_V2:
				if( ((SIMCObjectTypeV2*)theType)->GetStatus() == SIMCObjectTypeV1::STATUS_OBSOLETE  )
					return S_OK;
				break;
			default:
				return WBEM_E_FAILED;
		}
	}

	SIMCObjectTypeType *objectType = (SIMCObjectTypeType *)theType;
	// Set the PROPERTY NAME corresponding to the OBJECT-TYPE identifier
	wchar_t * objectName = ConvertAnsiToBstr(scalarSymbol->GetSymbolName());
	if(!objectName)
	{
		if(simc_debug) cerr << "GenerateScalar(): ConvertAnsiToBstr - objectName failed" 
			<< endl;
		return WBEM_E_FAILED;
	}

	// Have to decide the 'type' of the property based on the
	// SYNTAX clause of the OBJECT-TYPE.
	HRESULT result = CreatePropertyAndMapSyntaxClause(scalarClass,
				objectType->GetSyntax(),
				objectName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalar() : MapSyntaxClause() failed" << endl;
		return result;
	}

	// Get the attribute set
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalar(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}


	// Map the oid value
	if( FAILED(result = MapOidValue(attributeSet, *oidValue)) )
	{
		if(simc_debug) cerr << "GenerateScalar() : MapOidValue() failed" << endl;
		attributeSet->Release();
		return result;
	}
			
	// Map Access Clause
	if( FAILED(result = MapAccessClause(attributeSet, objectType)) )
	{
		if(simc_debug) cerr << "GenerateScalar() : MapAccess() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// Map Description Clause
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapDescriptionClause(attributeSet, objectType)) )
		{
			if(simc_debug) cerr << "GenerateScalar() : MapDescriptionClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Units Clause (SNMPv2 only)
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapUnitsClause(attributeSet, objectType)) )
		{
			if(simc_debug) cerr << "GenerateScalar() : MapUnitsClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Reference Clause
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapReferenceClause(attributeSet, objectType)) )
		{
			if(simc_debug) cerr << "GenerateScalar() : MapReferenceClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Status Clause
	if( FAILED(result = MapStatusClause(attributeSet, objectType))  )
	{
		if(simc_debug) cerr << "GenerateScalar() : MapStatusClause() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// Map Defval Clause
	if( FAILED(result = MapDefValClause(attributeSet, objectType))  )
	{
		if(simc_debug) cerr << "GenerateScalar() : MapDefvalClause() failed" << endl;
		attributeSet->Release();
		return result;
	}

	attributeSet->Release();
	return S_OK;
}

static STDMETHODIMP MakeKey(IWbemQualifierSet *attributeSet)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BOOL ;
	variant.boolVal = VARIANT_TRUE;
	HRESULT result = attributeSet->Put ( KEY_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	return result;
}

static STDMETHODIMP MakeVirtualKey(IWbemQualifierSet *attributeSet)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BOOL ;
	variant.boolVal = VARIANT_TRUE;
	HRESULT result = attributeSet->Put ( VIRTUAL_KEY_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	if(FAILED(result))
	{
		VariantClear(&variant);
		return result;
	}
	result = attributeSet->Put ( KEY_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	return result;
}


static STDMETHODIMP MapOidValue(IWbemQualifierSet *attributeSet,
				const SIMCCleanOidValue &oidValue)
{
	char * oidStringValue = CleanOidValueToString(oidValue);
	if(!oidStringValue)
	{
		if(simc_debug) cerr << "MapOidValueClause(): CleanOidValueToString() failed" << endl;
		return WBEM_E_FAILED;
	}
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(oidStringValue);
	HRESULT result = attributeSet->Put ( OBJECT_IDENTIFIER_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	// delete []oidStringValue;
	if (FAILED(result))
		if(simc_debug) cerr << "MapOidValueClause(): Put object_identifier failed" << endl;
	
	return result;
}


static STDMETHODIMP CreatePropertyAndMapSyntaxClause(IWbemClassObject *scalarClass,
					SIMCSymbol **syntax,
					wchar_t *objectName)
{
	const char * const syntaxSymbolName = (*syntax)->GetSymbolName();

	SIMCTypeReference *typeRef  = NULL;
	SIMCDefinedTypeReference * defTypeRef = NULL;
	SIMCModule::PrimitiveType primitiveType = SIMCModule::PRIMITIVE_INVALID;
	SIMCModule::TypeClass typeClass = SIMCModule::TYPE_INVALID;
	BOOL isTextualConvention = false;
	
	switch(SIMCModule::GetSymbolClass(syntax))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF: 
			typeRef = (SIMCTypeReference *)(*syntax);
			break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			isTextualConvention = TRUE;
			// FALL THRU
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		{
			defTypeRef = (SIMCDefinedTypeReference*)(*syntax);
			switch(defTypeRef->GetStatus())
			{
				case RESOLVE_IMPORT:
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					return WBEM_E_FAILED;
				case RESOLVE_CORRECT:
					typeRef = defTypeRef->GetRealType();
			}
		}
		break;
		default:
			return WBEM_E_FAILED;
	}

	SIMCSymbol **typeRefP = (SIMCSymbol**)&typeRef;
	switch(SIMCModule::GetSymbolClass(typeRefP))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType *type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			switch(typeClass = SIMCModule::GetTypeClass(type))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					primitiveType = SIMCModule::GetPrimitiveType(typeRef);
					break;
				case SIMCModule::TYPE_SIZE:
				case SIMCModule::TYPE_RANGE:
					switch( ((SIMCSubType *)type)->GetStatus())
					{
						case RESOLVE_CORRECT: 
							break;
						default:
							return WBEM_E_FAILED;
					}
					primitiveType = 
						SIMCModule::GetPrimitiveType(((SIMCSubType *)type)->GetRootType());
					break;
				case SIMCModule::TYPE_ENUM_OR_BITS:
				{
                    switch( ((SIMCEnumOrBitsType *)type)->GetEnumOrBitsType() )
					{
						case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
							primitiveType = SIMCModule::PRIMITIVE_INTEGER;
							break;
						case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
							primitiveType = SIMCModule::PRIMITIVE_BITS;
							break;
						default:
							return WBEM_E_FAILED;
					}
				}
				break;
				default:
					return WBEM_E_FAILED;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			typeClass = SIMCModule::TYPE_PRIMITIVE;
			primitiveType = SIMCModule::GetPrimitiveType(typeRef->GetSymbolName());
		}
		break;
		default:
			return WBEM_E_FAILED;
	}
	return MapSyntaxAttributes(scalarClass, objectName, syntaxSymbolName,
				typeRef, defTypeRef,
				typeClass, primitiveType, isTextualConvention); 
}

static STDMETHODIMP MapSyntaxAttributes(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCTypeReference *btRef,
		SIMCDefinedTypeReference *dtRef,
		SIMCModule::TypeClass typeClass,
		SIMCModule::PrimitiveType primitiveType,
		BOOL isTextualConvention)
{

	// "type" and "encoding" attributes are directly based on the 
	// "textual_convention" attribute. "object_syntax" attribute 
	// requires some more work
	char *typeAttribute = NULL, *textualConventionAttribute = NULL, *encodingAttribute = NULL,
			*objectSyntaxAttribute = NULL, *displayHintAttribute = NULL;

	// Set the display_hint attribute in case of a textual convention
	if(isTextualConvention)
	{
		SIMCTextualConvention *theTC = (SIMCTextualConvention *)dtRef;
		displayHintAttribute = (char *)theTC->GetDisplayHint();
	}


	switch(typeClass)
	{
		case SIMCModule::TYPE_PRIMITIVE:
		{

			if(symbolName[0] != '*')
				objectSyntaxAttribute = NewString(symbolName);
			else
				objectSyntaxAttribute = NewString(btRef->GetSymbolName());

			if(objectSyntaxAttribute)
			{
				// Tackle 2 the special casees since MOF attributes can't have spaces in them
				if(strcmp(objectSyntaxAttribute, "OCTET STRING") == 0 )
				{
					delete objectSyntaxAttribute;
					objectSyntaxAttribute = NewString(OCTETSTRING_TYPE);
				}
				else if(strcmp(objectSyntaxAttribute, "OBJECT IDENTIFIER") == 0 )
				{
					delete objectSyntaxAttribute;
					objectSyntaxAttribute = NewString(OBJECTIDENTIFIER_TYPE);
				}

				switch(primitiveType)
				{
					case SIMCModule::PRIMITIVE_INTEGER:
						textualConventionAttribute = NewString(INTEGER_TYPE);
						typeAttribute = NewString(VT_I4_TYPE);
						encodingAttribute = NewString(INTEGER_TYPE);
						break;
					case SIMCModule::PRIMITIVE_OID:
						textualConventionAttribute = NewString(OBJECTIDENTIFIER_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OBJECTIDENTIFIER_TYPE);
						break;
					case SIMCModule::PRIMITIVE_OCTET_STRING:
						textualConventionAttribute = NewString(OCTETSTRING_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_NULL:
						textualConventionAttribute = NewString(NULL_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(NULL_TYPE);
						break;
					case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
						textualConventionAttribute = NewString(NetworkAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(NetworkAddress_TYPE);
						break;
					case SIMCModule::PRIMITIVE_IP_ADDRESS:
						textualConventionAttribute = NewString(IpAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(IpAddress_TYPE);
						break;
					case SIMCModule::PRIMITIVE_COUNTER:
						textualConventionAttribute = NewString(Counter_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(Counter_TYPE);
						break;
					case SIMCModule::PRIMITIVE_GAUGE:
						textualConventionAttribute = NewString(Gauge_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(Gauge_TYPE);
						break;
					case SIMCModule::PRIMITIVE_TIME_TICKS:
						textualConventionAttribute = NewString(TimeTicks_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(TimeTicks_TYPE);
						break;
					case SIMCModule::PRIMITIVE_OPAQUE:
						textualConventionAttribute = NewString(Opaque_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(Opaque_TYPE);
						break;
					case SIMCModule::PRIMITIVE_DISPLAY_STRING:
						textualConventionAttribute = NewString(DisplayString_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
						textualConventionAttribute = NewString(PhysAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_MAC_ADDRESS:
						textualConventionAttribute = NewString(MacAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_DATE_AND_TIME:
						textualConventionAttribute = NewString(DateAndTime_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_INTEGER_32:
						textualConventionAttribute = NewString(Integer32_TYPE);
						typeAttribute = NewString(VT_I4_TYPE);
						encodingAttribute = NewString(Integer32_TYPE);
						break;
					case SIMCModule::PRIMITIVE_UNSIGNED_32:
						textualConventionAttribute = NewString(Unsigned32_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(Unsigned32_TYPE);
						break;
					case SIMCModule::PRIMITIVE_COUNTER_32:
						textualConventionAttribute = NewString(Counter32_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(Counter32_TYPE);
						break;
					case SIMCModule::PRIMITIVE_COUNTER_64:
						textualConventionAttribute = NewString(Counter64_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(Counter64_TYPE);
						break;
					case SIMCModule::PRIMITIVE_GAUGE_32:
						textualConventionAttribute = NewString(Gauge32_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(Gauge32_TYPE);
						break;
					case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
						textualConventionAttribute = NewString(SnmpUDPAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:
						textualConventionAttribute = NewString(SnmpIPXAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:
						textualConventionAttribute = NewString(SnmpOSIAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					default:
						return WBEM_E_FAILED;
				}
			}
			break;
		}
		case SIMCModule::TYPE_ENUM_OR_BITS:
		{
			SIMCEnumOrBitsType *enumOrBits = (SIMCEnumOrBitsType *)
					((SIMCBuiltInTypeReference *)btRef)->GetType();
			switch(enumOrBits->GetEnumOrBitsType())
			{
				case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
					return MapEnumeratedSyntax(scalarClass, objectName, symbolName,
						enumOrBits, displayHintAttribute);
				case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
					return MapBitsSyntax(scalarClass, objectName, symbolName,
						enumOrBits, displayHintAttribute);
				default:
					return WBEM_E_FAILED;
			}
		}
		break;

		case SIMCModule::TYPE_SIZE:
			return MapSizeTypeSyntax(scalarClass, objectName, symbolName,
				(SIMCSizeType *)((SIMCBuiltInTypeReference *)btRef)->GetType(), displayHintAttribute);
		case SIMCModule::TYPE_RANGE:
			return MapRangeTypeSyntax(scalarClass, objectName, symbolName,
				(SIMCRangeType *)((SIMCBuiltInTypeReference *)btRef)->GetType(), displayHintAttribute);
		default:
			if(simc_debug) cerr << "MapSyntaxAttributes() : Could not get a valid primitive type" << endl;
				return WBEM_E_FAILED;

	}

 	VARIANT typeVariant, 
			textualConventionVariant, 
			encodingVariant,
			objectSyntaxVariant,
			displayHintVariant;

	VariantInit(&typeVariant);
	VariantInit(&textualConventionVariant);
	VariantInit(&encodingVariant);
	VariantInit(&objectSyntaxVariant);
	if(displayHintAttribute)
		VariantInit(&displayHintVariant);

	typeVariant.vt =				VT_BSTR ;
	textualConventionVariant.vt =	VT_BSTR ;
	encodingVariant.vt =			VT_BSTR ;
	objectSyntaxVariant.vt =		VT_BSTR ;
	if(displayHintAttribute)
		displayHintVariant.vt =			VT_BSTR ;

	typeVariant.bstrVal =				ConvertAnsiToBstr(typeAttribute);
	textualConventionVariant.bstrVal =	ConvertAnsiToBstr(textualConventionAttribute);
	encodingVariant.bstrVal =			ConvertAnsiToBstr(encodingAttribute);
	objectSyntaxVariant.bstrVal =		ConvertAnsiToBstr(objectSyntaxAttribute);
	if(displayHintAttribute)
		displayHintVariant.bstrVal =	ConvertAnsiToBstr(displayHintAttribute);

	// Create the property
	VARTYPE varType = VT_NULL ;
	SetPropertyType(varType, typeVariant.bstrVal, 
		textualConventionVariant.bstrVal, NULL);
	HRESULT result = scalarClass->Put (objectName, 0, NULL, varType);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalar(): Put Property objectName failed" << endl;
		return result;
	}

	// Set the attributes of the property
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapSyntaxAttributes(): Unknown return value" << endl;	  
		return WBEM_E_FAILED;
	}

	result = attributeSet->Put( CIMTYPE_ATTRIBUTE, &typeVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( TEXTUAL_CONVENTION_ATTRIBUTE, &textualConventionVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( ENCODING_ATTRIBUTE, &encodingVariant , WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put(OBJECT_SYNTAX_ATTRIBUTE, &objectSyntaxVariant, WBEM_CLASS_DO_PROPAGATION);
	if(displayHintAttribute)
	{
		if(SUCCEEDED(result))
			result = attributeSet->Put(DISPLAY_HINT_ATTRIBUTE, &displayHintVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	attributeSet->Release();
	delete typeAttribute;
	delete textualConventionAttribute;
	delete encodingAttribute;
	delete objectSyntaxAttribute;
	// Do not delete the displayHintAttribute since it was not allocated,
	// but is a part of the TC object
	
	VariantClear (&typeVariant) ;
	VariantClear (&textualConventionVariant) ;
	VariantClear (&encodingVariant) ;
	VariantClear (&objectSyntaxVariant) ;
	if(displayHintAttribute)
		VariantClear (&displayHintVariant);
	return result;

}

static void SetPropertyType(VARTYPE &varType,const BSTR &type, 
							  const BSTR &textualConvention,
							  const char * propertyValue)
{
	varType = VT_NULL ;
	CString typeStr(type); 
	if( typeStr == VT_I4_TYPE )
		varType = VT_I4 ;
	else if( typeStr == VT_UI4_TYPE )
		varType = VT_UI4 ;
	else if ( typeStr == VT_ARRAY_OR_VT_I4_TYPE )
		varType = VT_ARRAY | VT_I4;
	else if ( typeStr == VT_BSTR_TYPE )
		varType = VT_BSTR ;
}

	
static STDMETHODIMP MapSizeTypeSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCSizeType *sizeType,
		const char *const displayHintAttribute)
{
	VARIANT typeVariant; 
	VARIANT	textualConventionVariant; 
	VARIANT	encodingVariant;
	VARIANT	objectSyntaxVariant;
	VARIANT	fixedLengthVariant;
	VARIANT	variableLengthVariant;
	VARIANT displayHintVariant;

	VariantInit(&typeVariant);
	VariantInit(&textualConventionVariant);
	VariantInit(&encodingVariant);
	VariantInit(&objectSyntaxVariant);
	VariantInit(&fixedLengthVariant);
	VariantInit(&variableLengthVariant);
	if(displayHintAttribute) VariantInit(&displayHintVariant);

	switch(sizeType->GetStatus())
	{
		case RESOLVE_CORRECT:
			break;
		default:
			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&fixedLengthVariant);
			VariantClear (&variableLengthVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}


	SIMCSymbol ** typeSymbol = sizeType->GetType();
	SIMCTypeReference *tRef =  NULL;
	SIMCDefinedTypeReference *dtRef = NULL;
	switch(SIMCModule::GetSymbolClass(typeSymbol))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			tRef = (SIMCTypeReference *)(*typeSymbol);
			break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			dtRef = (SIMCDefinedTypeReference *)(*typeSymbol);
			if( dtRef->GetStatus() != RESOLVE_CORRECT)
				return WBEM_E_FAILED;
			tRef = dtRef->GetRealType();
			break;

		default:
			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&fixedLengthVariant);
			VariantClear (&variableLengthVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}

	char	*typeAttribute, 
			*textualConventionAttribute, 
			*encodingAttribute,
			*objectSyntaxAttribute, 
			*variableLengthAttribute= NULL;
	long fixedLengthAttribute = 0;
	
	// Set the objectSyntax attribute	
	if(*symbolName != '*')
		objectSyntaxAttribute = NewString(symbolName);
	else
	{
		if(dtRef)
			objectSyntaxAttribute = NewString(dtRef->GetSymbolName());
		else
			objectSyntaxAttribute = NewString(tRef->GetSymbolName());
	}

 	// Tackle 2 the special cases since MOF attributes can't have spaces in them
	if(objectSyntaxAttribute && strcmp(objectSyntaxAttribute, "OCTET STRING") == 0 )
	{
		delete objectSyntaxAttribute;
		objectSyntaxAttribute = NewString(OCTETSTRING_TYPE);
	}
	else if(objectSyntaxAttribute && strcmp(objectSyntaxAttribute, "OBJECT IDENTIFIER") == 0 )
	{
		delete objectSyntaxAttribute;
		objectSyntaxAttribute = NewString(OBJECTIDENTIFIER_TYPE);
	}

	// Set the other attributes
	SIMCTypeReference *rootTypeRef = sizeType->GetRootType();
	switch(SIMCModule::GetSymbolClass((SIMCSymbol **)(&rootTypeRef)) )
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(SIMCModule::GetTypeClass(((SIMCBuiltInTypeReference *)rootTypeRef)->GetType()) )
			{
				case SIMCModule::TYPE_PRIMITIVE:
					switch(SIMCModule::GetPrimitiveType(rootTypeRef))
					{
						case SIMCModule::PRIMITIVE_INTEGER:
							textualConventionAttribute = NewString(INTEGER_TYPE);
							typeAttribute = NewString(VT_I4_TYPE);
							encodingAttribute = NewString(INTEGER_TYPE);
							break;
						case SIMCModule::PRIMITIVE_INTEGER_32:
							textualConventionAttribute = NewString(Integer32_TYPE);
							typeAttribute = NewString(VT_I4_TYPE);
							encodingAttribute = NewString(Integer32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_UNSIGNED_32:
							textualConventionAttribute = NewString(Unsigned32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Unsigned32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_OID:
							textualConventionAttribute = NewString(OBJECTIDENTIFIER_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OBJECTIDENTIFIER_TYPE);
							break;
						case SIMCModule::PRIMITIVE_OCTET_STRING:
							textualConventionAttribute = NewString(OCTETSTRING_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_NULL:
							textualConventionAttribute = NewString(NULL_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(NULL_TYPE);
							break;
						case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
							textualConventionAttribute = NewString(NetworkAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(NetworkAddress_TYPE);
							break;
						case SIMCModule::PRIMITIVE_IP_ADDRESS:
							textualConventionAttribute = NewString(IpAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(IpAddress_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER:
							textualConventionAttribute = NewString(Counter_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Counter_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER_32:
							textualConventionAttribute = NewString(Counter32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Counter32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER_64:
							textualConventionAttribute = NewString(Counter64_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(Counter64_TYPE);
							break;
						case SIMCModule::PRIMITIVE_GAUGE:
							textualConventionAttribute = NewString(Gauge_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Gauge_TYPE);
							break;
						case SIMCModule::PRIMITIVE_GAUGE_32:
							textualConventionAttribute = NewString(Gauge32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Gauge32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_TIME_TICKS:
							textualConventionAttribute = NewString(TimeTicks_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(TimeTicks_TYPE);
							break;
						case SIMCModule::PRIMITIVE_OPAQUE:
							textualConventionAttribute = NewString(Opaque_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(Opaque_TYPE);
							break;
						case SIMCModule::PRIMITIVE_DISPLAY_STRING:
							textualConventionAttribute = NewString(DisplayString_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
							textualConventionAttribute = NewString(PhysAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_MAC_ADDRESS:
							textualConventionAttribute = NewString(MacAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_DATE_AND_TIME:
							textualConventionAttribute = NewString(DateAndTime_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
							textualConventionAttribute = NewString(SnmpUDPAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:
							textualConventionAttribute = NewString(SnmpIPXAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:
							textualConventionAttribute = NewString(SnmpOSIAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						default:
							VariantClear (&typeVariant) ;
							VariantClear (&textualConventionVariant) ;
							VariantClear (&encodingVariant) ;
							VariantClear (&objectSyntaxVariant) ;
							VariantClear (&fixedLengthVariant);
							if(displayHintAttribute) VariantClear (&displayHintVariant);
							return WBEM_E_FAILED;
					}
					break;

				default:
					VariantClear (&typeVariant) ;
					VariantClear (&textualConventionVariant) ;
					VariantClear (&encodingVariant) ;
					VariantClear (&objectSyntaxVariant) ;
					VariantClear (&fixedLengthVariant);
					VariantClear (&variableLengthVariant);
					if(displayHintAttribute) VariantClear (&displayHintVariant);
					return WBEM_E_FAILED;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			switch(SIMCModule::GetPrimitiveType(rootTypeRef->GetSymbolName()))
			{
				case SIMCModule::PRIMITIVE_DISPLAY_STRING:
					textualConventionAttribute = NewString(DisplayString_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
					textualConventionAttribute = NewString(PhysAddress_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_MAC_ADDRESS:
					textualConventionAttribute = NewString(MacAddress_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_DATE_AND_TIME:
					textualConventionAttribute = NewString(DateAndTime_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
					textualConventionAttribute = NewString(SnmpUDPAddress_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:
					textualConventionAttribute = NewString(SnmpIPXAddress_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:
					textualConventionAttribute = NewString(SnmpOSIAddress_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				default:
					VariantClear (&typeVariant) ;
					VariantClear (&textualConventionVariant) ;
					VariantClear (&encodingVariant) ;
					VariantClear (&objectSyntaxVariant) ;
					VariantClear(&fixedLengthVariant);
					VariantClear(&variableLengthVariant);
					if(displayHintAttribute) VariantClear (&displayHintVariant);
					return WBEM_E_FAILED;
			}
		}
		break;
		default:
 			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear(&fixedLengthVariant);
			VariantClear(&variableLengthVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}

	if(sizeType->IsFixedSize())
		fixedLengthAttribute = sizeType->GetFixedSize();
	else
	{
		if(!(variableLengthAttribute = sizeType->ConvertSizeListToString()))
		{
			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&fixedLengthVariant);
			VariantClear (&variableLengthVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
		}
	}
	


	typeVariant.vt =				VT_BSTR;
	textualConventionVariant.vt =	VT_BSTR;
	encodingVariant.vt =			VT_BSTR;
	objectSyntaxVariant.vt =		VT_BSTR;
	fixedLengthVariant.vt =			VT_I4;
	variableLengthVariant.vt =		VT_BSTR;
	if(displayHintAttribute) displayHintVariant.vt =			VT_BSTR;

	typeVariant.bstrVal = ConvertAnsiToBstr(typeAttribute);
	textualConventionVariant.bstrVal = ConvertAnsiToBstr(textualConventionAttribute);
	encodingVariant.bstrVal = ConvertAnsiToBstr(encodingAttribute);
	objectSyntaxVariant.bstrVal = ConvertAnsiToBstr(objectSyntaxAttribute);
	if(fixedLengthAttribute)
		fixedLengthVariant.lVal = fixedLengthAttribute;
	else
		variableLengthVariant.bstrVal = ConvertAnsiToBstr(variableLengthAttribute);
	if(displayHintAttribute)
		displayHintVariant.bstrVal = ConvertAnsiToBstr(displayHintAttribute);

  	// Create the property
	VARTYPE varType = VT_NULL ;
	SetPropertyType(varType, typeVariant.bstrVal, 
		textualConventionVariant.bstrVal, NULL);
	HRESULT result = scalarClass->Put (objectName, 0, NULL, varType);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "MapSizeTypeSyntax(): Put Property objectName failed" << endl;
		return result;
	}

	// Set the attributes of the property
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapSizeTypeSyntax(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

	result = attributeSet->Put( CIMTYPE_ATTRIBUTE, &typeVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( TEXTUAL_CONVENTION_ATTRIBUTE,&textualConventionVariant,WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( ENCODING_ATTRIBUTE, &encodingVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( OBJECT_SYNTAX_ATTRIBUTE, &objectSyntaxVariant,WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
	{
		if(fixedLengthAttribute)
			result = attributeSet->Put( FIXED_LENGTH_ATTRIBUTE, &fixedLengthVariant,WBEM_CLASS_DO_PROPAGATION);
		else
			result = attributeSet->Put( VARIABLE_LENGTH_ATTRIBUTE, &variableLengthVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	if(displayHintAttribute)
	{
		if(SUCCEEDED(result))
			result = attributeSet->Put(DISPLAY_HINT_ATTRIBUTE, &displayHintVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	attributeSet->Release();
	delete typeAttribute;
	delete textualConventionAttribute;
	delete encodingAttribute;
	delete objectSyntaxAttribute;

	if(fixedLengthAttribute)
  		VariantClear(&fixedLengthVariant);
	else
	{
		// delete variableLengthAttribute;
		VariantClear(&variableLengthVariant);
	}

	VariantClear (&typeVariant);
	VariantClear (&textualConventionVariant);
	VariantClear (&encodingVariant);
	VariantClear (&objectSyntaxVariant);
	if(displayHintAttribute) VariantClear (&displayHintVariant);
	return result;
}

static STDMETHODIMP MapRangeTypeSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCRangeType *rangeType,
		const char * const displayHintAttribute)
{
	VARIANT typeVariant; 
	VARIANT	textualConventionVariant; 
	VARIANT	encodingVariant;
	VARIANT	objectSyntaxVariant;
	VARIANT	variableValueVariant;
	VARIANT displayHintVariant;

	VariantInit(&typeVariant);
	VariantInit(&textualConventionVariant);
	VariantInit(&encodingVariant);
	VariantInit(&objectSyntaxVariant);
	VariantInit(&variableValueVariant);
	if(displayHintAttribute) VariantInit(&displayHintVariant);

	switch(rangeType->GetStatus())
	{
		case RESOLVE_CORRECT:
			break;
		default:
			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&variableValueVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}

	SIMCSymbol ** typeSymbol = rangeType->GetType();
	SIMCTypeReference *tRef =  NULL;
	SIMCDefinedTypeReference *dtRef = NULL;
	switch(SIMCModule::GetSymbolClass(typeSymbol))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			tRef = (SIMCTypeReference *)(*typeSymbol);
			break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
			dtRef = (SIMCDefinedTypeReference *)(*typeSymbol);
			if( dtRef->GetStatus() != RESOLVE_CORRECT)
				return WBEM_E_FAILED;
			tRef = dtRef->GetRealType();
			break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			dtRef = (SIMCTextualConvention *)(*typeSymbol);
			if( dtRef->GetStatus() != RESOLVE_CORRECT)
				return WBEM_E_FAILED;
			tRef = dtRef->GetRealType();
			break;
		default:
			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&variableValueVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}

	char *typeAttribute, *textualConventionAttribute, *encodingAttribute,
			*objectSyntaxAttribute, *variableValueAttribute;
	
	// Set the objectSyntax attribute	
	if(*symbolName != '*')
		objectSyntaxAttribute = NewString(symbolName);
	else
	{
		if(dtRef)
			objectSyntaxAttribute = NewString(dtRef->GetSymbolName());
		else
			objectSyntaxAttribute = NewString(tRef->GetSymbolName());
	}

	// Tackle 2 the special casees since MOF attributes can't have spaces in them
	if(objectSyntaxAttribute && strcmp(objectSyntaxAttribute, "OCTET STRING") == 0 )
	{
		delete objectSyntaxAttribute;
		objectSyntaxAttribute = NewString(OCTETSTRING_TYPE);
	}
	else if(objectSyntaxAttribute && strcmp(objectSyntaxAttribute, "OBJECT IDENTIFIER") == 0 )
	{
		delete objectSyntaxAttribute;
		objectSyntaxAttribute = NewString(OBJECTIDENTIFIER_TYPE);
	}

	SIMCTypeReference *rootTypeRef = rangeType->GetRootType();
	switch(SIMCModule::GetSymbolClass((SIMCSymbol **)(&rootTypeRef)))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(SIMCModule::GetTypeClass( ((SIMCBuiltInTypeReference *)rootTypeRef)->GetType() ) )
			{
				case SIMCModule::TYPE_PRIMITIVE:
					switch(SIMCModule::GetPrimitiveType(rootTypeRef))
					{
						case SIMCModule::PRIMITIVE_INTEGER:
							textualConventionAttribute = NewString(INTEGER_TYPE);
							typeAttribute = NewString(VT_I4_TYPE);
							encodingAttribute = NewString(INTEGER_TYPE);
							break;
						case SIMCModule::PRIMITIVE_INTEGER_32:
							textualConventionAttribute = NewString(Integer32_TYPE);
							typeAttribute = NewString(VT_I4_TYPE);
							encodingAttribute = NewString(Integer32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_UNSIGNED_32:
							textualConventionAttribute = NewString(Unsigned32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Unsigned32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER:
							textualConventionAttribute = NewString(Counter_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Counter_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER_32:
							textualConventionAttribute = NewString(Counter32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Counter32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER_64:
							textualConventionAttribute = NewString(Counter64_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(Counter64_TYPE);
							break;
						case SIMCModule::PRIMITIVE_GAUGE:
							textualConventionAttribute = NewString(Gauge_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Gauge_TYPE);
							break;
						case SIMCModule::PRIMITIVE_GAUGE_32:
							textualConventionAttribute = NewString(Gauge32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Gauge32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_TIME_TICKS:
							textualConventionAttribute = NewString(TimeTicks_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(TimeTicks_TYPE);
							break;
						default:
							VariantClear (&typeVariant) ;
							VariantClear (&textualConventionVariant) ;
							VariantClear (&encodingVariant) ;
							VariantClear (&objectSyntaxVariant) ;
							VariantClear (&variableValueVariant);
							if(displayHintAttribute) VariantClear (&displayHintVariant);
							return WBEM_E_FAILED;
					}
					break;

				default:
					VariantClear (&typeVariant) ;
					VariantClear (&textualConventionVariant) ;
					VariantClear (&encodingVariant) ;
					VariantClear (&objectSyntaxVariant) ;
					VariantClear (&variableValueVariant);
					if(displayHintAttribute) VariantClear (&displayHintVariant);
					return WBEM_E_FAILED;
			}
		}
		break;
		default:
 			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&variableValueVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}


	if(!(variableValueAttribute = rangeType->ConvertRangeListToString()))
	{
		VariantClear (&typeVariant) ;
		VariantClear (&textualConventionVariant) ;
		VariantClear (&encodingVariant) ;
		VariantClear (&objectSyntaxVariant) ;
		VariantClear (&variableValueVariant);
		if(displayHintAttribute) VariantClear (&displayHintVariant);
		return WBEM_E_FAILED;
	}
	


	typeVariant.vt =				VT_BSTR ;
	textualConventionVariant.vt =	VT_BSTR ;
	encodingVariant.vt =			VT_BSTR ;
	objectSyntaxVariant.vt =		VT_BSTR ;
	variableValueVariant.vt =		VT_BSTR ;
	if(displayHintAttribute) displayHintVariant.vt =			VT_BSTR ;

	typeVariant.bstrVal					= ConvertAnsiToBstr(typeAttribute);
	textualConventionVariant.bstrVal	= ConvertAnsiToBstr(textualConventionAttribute);
	encodingVariant.bstrVal				= ConvertAnsiToBstr(encodingAttribute);
	objectSyntaxVariant.bstrVal			= ConvertAnsiToBstr(objectSyntaxAttribute);
	variableValueVariant.bstrVal		= ConvertAnsiToBstr(variableValueAttribute);
	if(displayHintAttribute)
		displayHintVariant.bstrVal = ConvertAnsiToBstr(displayHintAttribute);

  	// Create the property
	VARTYPE varType = VT_NULL ;
	SetPropertyType(varType,typeVariant.bstrVal, 
		textualConventionVariant.bstrVal, NULL);
	HRESULT result = scalarClass->Put (objectName, 0, NULL, varType);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "MapRangeTypeSyntax(): Put Property objectName failed" << endl;
		return result;
	}

	// Set the attributes of the property
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapRangeTypeSyntax(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

	result = attributeSet->Put( CIMTYPE_ATTRIBUTE, &typeVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( TEXTUAL_CONVENTION_ATTRIBUTE, &textualConventionVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( ENCODING_ATTRIBUTE, &encodingVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( OBJECT_SYNTAX_ATTRIBUTE, &objectSyntaxVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( VARIABLE_VALUE_ATTRIBUTE, &variableValueVariant,WBEM_CLASS_DO_PROPAGATION);

	if(displayHintAttribute)
	{
		if(SUCCEEDED(result))
			result = attributeSet->Put(DISPLAY_HINT_ATTRIBUTE, &displayHintVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	delete typeAttribute;
	delete textualConventionAttribute;
	delete encodingAttribute;
	delete objectSyntaxAttribute;
	// delete variableValueAttribute;

	VariantClear (&typeVariant) ;
	VariantClear (&textualConventionVariant) ;
	VariantClear (&encodingVariant) ;
	VariantClear (&objectSyntaxVariant) ;
	VariantClear (&variableValueVariant) ;
	if(displayHintAttribute) VariantClear (&displayHintVariant);
	attributeSet->Release();
	return result;
}


static STDMETHODIMP MapEnumeratedSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCEnumOrBitsType *enumType,
		const char *const displayHintAttribute)
{
	char *textualConventionAttribute = NewString(EnumeratedINTEGER_TYPE);
	char *typeAttribute = NewString(VT_BSTR_TYPE);
	char *encodingAttribute = NewString(INTEGER_TYPE);
	char * objectSyntaxAttribute;

	if(symbolName[0] != '*')
		objectSyntaxAttribute = NewString(symbolName);
	else
		objectSyntaxAttribute = NewString(EnumeratedINTEGER_TYPE);

	char * enumerationAttribute = enumType->ConvertToString();
	if(!enumerationAttribute)
		return WBEM_E_FAILED;
	

 	VARIANT typeVariant; 
	VARIANT	textualConventionVariant; 
	VARIANT	encodingVariant;
	VARIANT	objectSyntaxVariant;
	VARIANT	enumerationVariant;
	VARIANT	displayHintVariant;

	VariantInit(&typeVariant);
	VariantInit(&textualConventionVariant);
	VariantInit(&encodingVariant);
	VariantInit(&objectSyntaxVariant);
	VariantInit(&enumerationVariant);
	if(displayHintAttribute) VariantInit(&displayHintVariant);

	typeVariant.vt				= VT_BSTR ;
	textualConventionVariant.vt = VT_BSTR ;
	encodingVariant.vt			= VT_BSTR ;
	objectSyntaxVariant.vt		= VT_BSTR ;
	enumerationVariant.vt		= VT_BSTR ;
	if(displayHintAttribute) displayHintVariant.vt		= VT_BSTR ;

	typeVariant.bstrVal					= ConvertAnsiToBstr(typeAttribute);
	textualConventionVariant.bstrVal	= ConvertAnsiToBstr(textualConventionAttribute);
	encodingVariant.bstrVal				= ConvertAnsiToBstr(encodingAttribute);
	objectSyntaxVariant.bstrVal			= ConvertAnsiToBstr(objectSyntaxAttribute);
	enumerationVariant.bstrVal			= ConvertAnsiToBstr(enumerationAttribute);
	if(displayHintAttribute )
		displayHintVariant.bstrVal			= ConvertAnsiToBstr(displayHintAttribute);

	// Set propertyValue to be equal to the first enumeration
	// Example: If enumerationAttribute is "up(1),down(2),unknown(3)",
	// then set *propertyValue to be "up(1)"
	char *propertyValue = NewString(enumerationAttribute);
	if(!propertyValue)
		return WBEM_E_FAILED;

	int i = 0;
	while( propertyValue[i] != '(' )
		i++;
	propertyValue[i] = NULL;

	// Create the property
	VARTYPE varType = VT_NULL ;
	SetPropertyType(varType,typeVariant.bstrVal, 
		textualConventionVariant.bstrVal, propertyValue);
	HRESULT result = scalarClass->Put (objectName, 0, NULL, varType);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "MapEnumeratedSyntax(): Put Property objectName failed" << endl;
		return result;
	}

	// Set the attributes of the property
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapEnumeratedSyntax(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}


	if(SUCCEEDED(result))
		result = attributeSet->Put( TEXTUAL_CONVENTION_ATTRIBUTE,&textualConventionVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( ENUMERATION_ATTRIBUTE, &enumerationVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( ENCODING_ATTRIBUTE, &encodingVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( OBJECT_SYNTAX_ATTRIBUTE, &objectSyntaxVariant, WBEM_CLASS_DO_PROPAGATION);

	if(displayHintAttribute)
	{
		if(SUCCEEDED(result))
			result = attributeSet->Put(DISPLAY_HINT_ATTRIBUTE, &displayHintVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	attributeSet->Release();
	VariantClear (&typeVariant) ;
	VariantClear (&textualConventionVariant) ;
	VariantClear (&encodingVariant) ;
	VariantClear (&objectSyntaxVariant) ;
	VariantClear (&enumerationVariant) ;
	if(displayHintAttribute) VariantClear (&displayHintVariant) ;

	delete propertyValue;
	delete typeAttribute;
	delete textualConventionAttribute;
	delete encodingAttribute;
	delete objectSyntaxAttribute;
	// delete enumerationAttribute;
	
	return result;
}	


static STDMETHODIMP MapBitsSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCEnumOrBitsType *bitsType,
		const char *const displayHintAttribute)
{
	char *textualConventionAttribute = NewString(BITS_TYPE);
	char *typeAttribute = NewString(VT_ARRAY_OR_VT_BSTR_TYPE);
	char *encodingAttribute = NewString(OCTETSTRING_TYPE);
	char *objectSyntaxAttribute;

	if(symbolName[0] != '*')
		objectSyntaxAttribute = NewString(symbolName);
	else
		objectSyntaxAttribute = NewString(BITS_TYPE);

	char * enumerationAttribute = bitsType->ConvertToString();
	if(!enumerationAttribute)
		return WBEM_E_FAILED;
	

 	VARIANT typeVariant; 
	VARIANT	textualConventionVariant; 
	VARIANT	encodingVariant;
	VARIANT	objectSyntaxVariant;
	VARIANT	enumerationVariant;
 	VARIANT	displayHintVariant;

	VariantInit(&typeVariant);
	VariantInit(&textualConventionVariant);
	VariantInit(&encodingVariant);
	VariantInit(&objectSyntaxVariant);
	VariantInit(&enumerationVariant);
 	if(displayHintAttribute) VariantInit(&displayHintVariant);

	typeVariant.vt = VT_BSTR ;
	textualConventionVariant.vt = VT_BSTR ;
	encodingVariant.vt = VT_BSTR ;
	objectSyntaxVariant.vt = VT_BSTR ;
	enumerationVariant.vt = VT_BSTR;
	if(displayHintAttribute) displayHintVariant.vt = VT_BSTR;

	typeVariant.bstrVal					= ConvertAnsiToBstr(typeAttribute);
	textualConventionVariant.bstrVal	= ConvertAnsiToBstr(textualConventionAttribute);
	encodingVariant.bstrVal				= ConvertAnsiToBstr(encodingAttribute);
	objectSyntaxVariant.bstrVal			= ConvertAnsiToBstr(objectSyntaxAttribute);
	enumerationVariant.bstrVal			= ConvertAnsiToBstr(enumerationAttribute);
	if(displayHintAttribute)
		displayHintVariant.bstrVal		= ConvertAnsiToBstr(displayHintAttribute);

	// Set propertyValue to be equal to the first enumeration
	// Example: If enumerationAttribute is "up(1),down(2),unknown(3)",
	// then set *propertyValue to be "up(1)"
	char *propertyValue = NewString(enumerationAttribute);
	if(!propertyValue)
		return WBEM_E_FAILED;

	int i = 0;
	while( propertyValue[i] != '(' )
		i++;
	propertyValue[i] = NULL;

	// Create the property and map its value
	VARIANT variant;
	VariantInit(&variant);
	SIMCNamedNumberList *valueList = bitsType->GetListOfItems();
	LONG count = valueList->GetCount() ;
	SAFEARRAY *safeArray ;
	SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
	safeArrayBounds[0].lLbound = 0 ;
	safeArrayBounds[0].cElements = count ;
	safeArray = SafeArrayCreate ( VT_BSTR , 1 , safeArrayBounds ) ;

	POSITION p = valueList->GetHeadPosition();
	SIMCNamedNumberItem *item;
	for ( LONG index = 0 ; p ; index ++ )
	{
		item = valueList->GetNext(p);
		SafeArrayPutElement ( safeArray , &index , ConvertAnsiToBstr(item->_name) );
	}
	variant.vt = VT_ARRAY | VT_BSTR ;
	variant.parray = safeArray ; 		
	VARTYPE varType = VT_ARRAY | VT_BSTR ;
	HRESULT result = scalarClass->Put (objectName, 0, &variant,varType);
	VariantClear(&variant);

	if (FAILED(result))
	{
		if(simc_debug) cerr << "MapEnumeratedSyntax(): Put Property objectName failed" << endl;
		return result;
	}

	// Set the attributes of the property
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapEnumeratedSyntax(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

	if(SUCCEEDED(result))
		result = attributeSet->Put( TEXTUAL_CONVENTION_ATTRIBUTE, &textualConventionVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( ENCODING_ATTRIBUTE, &encodingVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( OBJECT_SYNTAX_ATTRIBUTE, &objectSyntaxVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( BITS_ATTRIBUTE, &enumerationVariant, WBEM_CLASS_DO_PROPAGATION);

	if(displayHintAttribute)
	{
		if(SUCCEEDED(result))
			result = attributeSet->Put(DISPLAY_HINT_ATTRIBUTE, &displayHintVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	attributeSet->Release();
	VariantClear (&typeVariant) ;
	VariantClear (&textualConventionVariant) ;
	VariantClear (&encodingVariant) ;
	VariantClear (&objectSyntaxVariant) ;
	VariantClear (&enumerationVariant) ;
	if(displayHintAttribute) VariantClear (&displayHintVariant) ;

	delete propertyValue;
	delete typeAttribute;
	delete textualConventionAttribute;
	delete encodingAttribute;
	delete objectSyntaxAttribute;
	// delete enumerationAttribute;
	return result;
}	

static STDMETHODIMP MapAccessClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	HRESULT result;

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BOOL ;
	variant.boolVal = VARIANT_TRUE;
	
	switch( SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			switch(((SIMCObjectTypeV1 *)objectType)->GetAccess())
			{
				case SIMCObjectTypeV1::ACCESS_WRITE_ONLY:
					result = attributeSet->Put( WRITE_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV1::ACCESS_READ_ONLY:
				case SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE:
					result = attributeSet->Put( READ_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV1::ACCESS_READ_WRITE:
					if(FAILED(result = attributeSet->Put( READ_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION)) )
					{
						VariantClear ( & variant ) ;
						return result;
					}
					result = attributeSet->Put( WRITE_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				default:
					VariantClear ( & variant ) ;
					return WBEM_E_FAILED;
			}
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			switch(((SIMCObjectTypeV2 *)objectType)->GetAccess())
			{
				case SIMCObjectTypeV2::ACCESS_INVALID:
					VariantClear ( & variant ) ;
					return WBEM_E_FAILED;

				case SIMCObjectTypeV2::ACCESS_READ_ONLY:
				case SIMCObjectTypeV2::ACCESS_READ_CREATE:
				case SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE:
				case SIMCObjectTypeV2::ACCESS_FOR_NOTIFY:
					result = attributeSet->Put( READ_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV2::ACCESS_READ_WRITE:
					if(FAILED(result = attributeSet->Put( READ_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION)) )
					{
						VariantClear ( & variant ) ;
						return result;
					}
					result = attributeSet->Put( WRITE_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				default:
					VariantClear ( & variant ) ;
					return WBEM_E_FAILED;

			}
			break;
	}

	return WBEM_E_FAILED;
}

static STDMETHODIMP MapDescriptionClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	const char * const description = objectType->GetDescription();
	if(!description)
		return S_OK;

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(description);
	HRESULT result = attributeSet->Put( DESCRIPTION_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear (&variant) ;
	return result;	
}

static STDMETHODIMP MapReferenceClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	const char * reference = NULL;
	switch( SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			reference = ((SIMCObjectTypeV1 *)objectType)->GetReference();
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			reference = ((SIMCObjectTypeV2 *)objectType)->GetReference();
			break;
	}

	if(!reference)
		return S_OK;

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(reference);
	HRESULT result = attributeSet->Put( REFERENCE_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear (&variant) ;
	return result;	
}

static STDMETHODIMP MapUnitsClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	const char * units = NULL;
	switch( SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			return S_OK;
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			units = ((SIMCObjectTypeV2 *)objectType)->GetUnitsClause();
			break;
	}

	if(!units)
		return S_OK;

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(units);
	HRESULT result = attributeSet->Put(UNITS_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear (&variant) ;
	return result;	
}

static STDMETHODIMP MapStatusClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	
	HRESULT result;

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;

	switch( SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			switch(((SIMCObjectTypeV1 *)objectType)->GetStatus())
			{
				case SIMCObjectTypeV1::STATUS_INVALID:
					VariantClear(&variant);
					return WBEM_E_FAILED;

				case SIMCObjectTypeV1::STATUS_MANDATORY:
					variant.bstrVal = ConvertAnsiToBstr("mandatory");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV1::STATUS_OPTIONAL:
					variant.bstrVal = ConvertAnsiToBstr("optional");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV1::STATUS_DEPRECATED:
					variant.bstrVal = ConvertAnsiToBstr("deprecated");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV1::STATUS_OBSOLETE:
					variant.bstrVal = ConvertAnsiToBstr("obsolete");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;
			}
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			switch(((SIMCObjectTypeV2 *)objectType)->GetStatus())
			{
				case SIMCObjectTypeV2::STATUS_INVALID:
					VariantClear(&variant);
					return WBEM_E_FAILED;

				case SIMCObjectTypeV2::STATUS_CURRENT:
					variant.bstrVal = ConvertAnsiToBstr("current");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV2::STATUS_DEPRECATED:
					variant.bstrVal = ConvertAnsiToBstr("deprecated");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV2::STATUS_OBSOLETE:
					variant.bstrVal = ConvertAnsiToBstr("obsolete");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;
			}
			break;
	}
	return WBEM_E_FAILED;
}

static STDMETHODIMP MapDefValClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	
	SIMCSymbol **defValSymbol = objectType->GetDefVal();

	if(!defValSymbol)
		return S_OK;

	SIMCBuiltInValueReference *bvRef;

	switch(SIMCModule::GetSymbolClass(defValSymbol))
	{
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF :
			bvRef = (SIMCBuiltInValueReference*)(*defValSymbol);
			break;
		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
			if( ((SIMCDefinedValueReference *)(*defValSymbol))->GetStatus()
				!= RESOLVE_CORRECT)
			{
				if(simc_debug) cerr << "MapDefVal(): Could not get defined value" << endl;
				return WBEM_E_FAILED;
			}
			bvRef =  ((SIMCDefinedValueReference *)(*defValSymbol))->GetRealValue();
			break;
		default:
			if(simc_debug) cerr << "MapDefVal(): Could not get value ref" << endl;
			return WBEM_E_FAILED;
	}

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR;
	SIMCValue *value = bvRef->GetValue();
	switch(SIMCModule::GetValueClass(value))
	{
		case SIMCModule::VALUE_INVALID:
			if(simc_debug) cerr << "MapDefVal(): Could not get value class" << endl;
			return WBEM_E_FAILED;
		case SIMCModule::VALUE_INTEGER:
			return MapIntegerDefVal(attributeSet, (SIMCIntegerValue *)value);
		case SIMCModule::VALUE_OCTET_STRING:
			return MapOctetStringDefVal(attributeSet, (SIMCOctetStringValue *)value);
		case SIMCModule::VALUE_BOOLEAN:
			return MapBooleanDefVal(attributeSet, (SIMCBooleanValue *)value);
		case SIMCModule::VALUE_NULL:
			return MapNullDefVal(attributeSet, (SIMCNullValue *)value);
		case SIMCModule::VALUE_OID:
			return MapOidDefVal(attributeSet, (SIMCOidValue *)value);
		case SIMCModule::VALUE_BITS:
			return MapBitsDefVal(attributeSet, (SIMCBitsValue *)value);
	}

	return WBEM_E_FAILED;

}


static STDMETHODIMP MapIntegerDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCIntegerValue *value)
{
	ostrstream outStream;

	if(value->IsUnsigned())
		outStream << ( (unsigned long)value->GetIntegerValue()) << ends;
	else
		outStream << value->GetIntegerValue() << ends;

	char *str = outStream.str();

	HRESULT result = SetDefValAttribute(attributeSet, str);
	// delete str;
	return result;

}

static STDMETHODIMP MapOctetStringDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCOctetStringValue *value)
{
	strstream outStream;
	outStream << value->GetOctetStringValue() << ends;
	char *str = outStream.str();

	HRESULT result = SetDefValAttribute(attributeSet, str);
	// if(str) delete str;
	return result;


}

static STDMETHODIMP MapNullDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCNullValue *value)
{
	return SetDefValAttribute(attributeSet, "NULL");
}

static STDMETHODIMP MapBooleanDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCBooleanValue *value)
{
	if( value->GetBooleanValue())
		return SetDefValAttribute(attributeSet, "TRUE");
	else
		return SetDefValAttribute(attributeSet, "FALSE");
}

static STDMETHODIMP MapOidDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCOidValue *value)
{
	 SIMCCleanOidValue cleanValue;
	 if(parseTree->GetCleanOidValue("", value, cleanValue, FALSE) != RESOLVE_CORRECT)
		 return WBEM_E_FAILED;

	 char *str = CleanOidValueToString(cleanValue);
	 HRESULT result = SetDefValAttribute(attributeSet, str);
	 // delete []str;
	 return result;
}

static STDMETHODIMP MapBitsDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCBitsValue *value)
{
	const SIMCBitValueList * valueList = value->GetValueList();
	if(!valueList || valueList->IsEmpty())
		return S_OK;
	SIMCBitValue *headValue = valueList->GetHead();
	return SetDefValAttribute(attributeSet, headValue->_name);

}
static STDMETHODIMP SetDefValAttribute( IWbemQualifierSet *attributeSet,
									   const char * const str)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(str);
	HRESULT result = attributeSet->Put ( DEFVAL_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	if (FAILED(result))
		if(simc_debug) cerr << "SetDefValAttribute(): Put DefVal" << endl;
	
	return result;
}

//------------------------------------------------------------------------------
//----------------  TABLE GENERATION -------------------------------------------
//------------------------------------------------------------------------------


static STDMETHODIMP GenerateTable(ISmirAdministrator *pAdminInt,
			  ISmirSerialiseHandle *pSerializeInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCObjectGroup * group,
				SIMCTable *table)
{

	// If the table contains an IMPLIED clause, then it should not
	// be mapped.
	SIMCObjectTypeV2 *objectTypeV2;
  	SIMCSymbol * rowSymbol = table->GetRowSymbol();
	SIMCSymbol **rowSymbolP = &rowSymbol;

	if(SIMCModule::IsObjectTypeV2(rowSymbolP, objectTypeV2) == RESOLVE_CORRECT)
	{
		if(ContainsImpliedClause(objectTypeV2))
			return S_OK;
	}

	// Create a class for the table
	// Form the name of the table group
	SIMCSymbol *tableNode = table->GetTableSymbol();
	SIMCModule *module = tableNode->GetModule();
	const char * const moduleName = module->GetModuleName();
	const char * const tableNodeName = tableNode->GetSymbolName();

	// Set the Table group name
	char *tableName = new char[strlen(GROUP_NAME_PREPEND_STRING) +
					strlen(moduleName) + 1 + strlen(tableNodeName) +1 ];
	strcpy(tableName, GROUP_NAME_PREPEND_STRING);
	strcat(tableName, moduleName);
	strcat(tableName, "_");
	strcat(tableName, tableNodeName);

	BSTR tableClassName = ConvertAnsiToBstr(ConvertHyphensToUnderscores(tableName));
	delete []tableName;
	
	ISmirClassHandle *tableClassHandle = NULL ;
	HRESULT result = pAdminInt->CreateWBEMClass(tableClassName, &tableClassHandle);

	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateTableGroup(): Get Table class failed" << endl;
		tableClassHandle->Release();
		return result;
	}

	IWbemClassObject *tableClass = NULL ;

	result = tableClassHandle->GetWBEMClass ( & tableClass ) ;

	// ---------------- Set Attributes of the class ------------------
	IWbemQualifierSet *attributeSet ;
	result = tableClass->GetQualifierSet (&attributeSet);
 	if (FAILED(result))
	{
		// cerr << "GenerateTable(): GetAttribSet failed" << endl;
		tableClassHandle->Release();
		tableClass->Release();
		return result;
	}


	// "description"
	// Form the description by concatenating the descriptions of the 
	// table and the row OBJECT-TYPES
	const char * const tableDescription = table->GetTableDescription();
	const char * const rowDescription = table->GetRowDescription();

	char * descriptionStr = new char [ 
		((tableDescription)? strlen(tableDescription): 0) + 
		((rowDescription)? strlen(rowDescription) : 0 )   +  2];
	descriptionStr[0] = NULL;
	if(tableDescription)
		strcat(descriptionStr, tableDescription);
	strcat(descriptionStr, "\n");
	if(rowDescription)
		strcat(descriptionStr, rowDescription);
  
	VARIANT variant ;
	VariantInit(&variant);

	if(!UI->SuppressText())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr(descriptionStr);
		result = attributeSet->Put ( DESCRIPTION_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
		VariantClear ( & variant ) ;
		delete [] descriptionStr;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateTable(): Put description failed" << endl;
			tableClassHandle->Release();
			tableClass->Release();
			attributeSet->Release();
			return result;
		}
	}

	// "module_name"
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(moduleName);
	result = attributeSet->Put ( MODULE_NAME_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear ( & variant ) ;
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateTable(): Put module_name failed" << endl;
		tableClassHandle->Release();
		tableClass->Release();
		attributeSet->Release();
		return result;
	}

	// "group_objectid"
	char *groupOidStr = (char *)CleanOidValueToString(*group->GetGroupValue());
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(groupOidStr);
	result = attributeSet->Put ( GROUP_OBJECTID_ATTRIBUTE , &variant , WBEM_CLASS_DO_PROPAGATION ) ;
	VariantClear ( & variant ) ;
	// delete []groupOidStr;
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateTable(): Put group_objectid failed" << endl;
		tableClassHandle->Release();
		tableClass->Release();
		attributeSet->Release();
		return result;
	}

	// "dynamic"
	if(FAILED(MakeDynamic(attributeSet)))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Make Dynamic failed" << endl;
		tableClassHandle->Release();
		tableClass->Release();
		attributeSet->Release();
		return WBEM_E_FAILED;
	}

	// "provider"
	if(FAILED(SetProvider(attributeSet, SNMP_INSTANCE_PROVIDER)))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Make Provider failed" << endl;
		tableClassHandle->Release();
		tableClass->Release();
		attributeSet->Release();
		return WBEM_E_FAILED;
	}

	//Finshed with the attributeSet...
	attributeSet->Release();

	// Set the properties/attributes of the class
	SIMCScalarMembers * columnMembers = table->GetColumnMembers();
	SIMCScalar *nextColumnObject;
	POSITION p = columnMembers->GetHeadPosition();
	while(p)
	{
		nextColumnObject = columnMembers->GetNext(p);
		if( GenerateScalar(nextColumnObject, tableClass, FALSE, FALSE) == WBEM_E_FAILED)
		{
			tableClassHandle->Release();
			tableClass->Release();
			return WBEM_E_FAILED;
		}
	}

	// Now deal with the index clause of the row object
	SIMCObjectTypeType *rowObject;
	if( SIMCModule::IsObjectType(rowSymbolP, rowObject) != RESOLVE_CORRECT )
	{
		tableClassHandle->Release();
		tableClass->Release();
		return WBEM_E_FAILED;
	}

	if (FAILED(MapIndexClause(pAdminInt, pGroupHandleInt, table, rowObject,
			tableClass)))
	{
		if(simc_debug) cerr << "Generatetable(): MapIndexClause() failed " << endl;
		tableClassHandle->Release();
		tableClass->Release();
		return WBEM_E_FAILED;
	}
	
	//finished with the tableclass object
	tableClass->Release();
	
	// Add the class to the Group
	//tableClassHandle->AddRef();

	if(generateMof)
	{
		//pSerializeInt->AddRef();
		if(FAILED(pAdminInt->AddClassToSerialise(pGroupHandleInt, tableClassHandle, pSerializeInt)))
		{
			if(simc_debug) cerr << "GenerateTable(): AddClassToSerialize() Failed" << endl;
			return WBEM_E_FAILED;
		}
	}
	else
	{
		//pGroupHandleInt->AddRef();
		if(FAILED(pAdminInt->AddClass(pGroupHandleInt, tableClassHandle)))
		{
			if(simc_debug) cerr << "GenerateTable(): AddClass() Failed" << endl;
			return WBEM_E_FAILED;
		}
	}

	tableClassHandle->Release();
	return S_OK;	
}


 
static STDMETHODIMP MapIndexClause(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeType *objectType,
				IWbemClassObject *tableClass)
{
	switch(SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			return MapIndexClauseV1(pAdminInt, pGroupHandleInt, table,
				(SIMCObjectTypeV1 *)objectType, tableClass);
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			return MapIndexClauseV2(pAdminInt, pGroupHandleInt, table,
				(SIMCObjectTypeV2 *)objectType, tableClass);
		default:
			return WBEM_E_FAILED;
	}
}

static STDMETHODIMP MapIndexClauseV1(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV1 *objectType,
				IWbemClassObject *tableClass)
{

	SIMCIndexList * indexList = objectType->GetIndexTypes();
	if(!indexList )
		return S_OK;

	SIMCSymbol **symbol;
	POSITION p = indexList->GetHeadPosition();
	
	HRESULT result = S_OK;
	SIMCIndexItem *indexItem;
	long ordinal = 0;
	while(p)
	{
		ordinal ++;

		indexItem = indexList->GetNext(p);
		symbol = indexItem->_item;
		SIMCModule::SymbolClass symbolClass = SIMCModule::GetSymbolClass(symbol);
		switch(symbolClass)
		{
			case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
				if(FAILED(MapIndexTypeReference(table, tableClass, symbol, ordinal)))
					result =  WBEM_E_FAILED;
				break;			

			case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
			case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
				if( FAILED(MapIndexValueReference(table, tableClass, symbol, ordinal)) )
					result = WBEM_E_FAILED;
			break;
			default:
				return WBEM_E_FAILED;
		}

	}
	return result;
}

static STDMETHODIMP MapIndexClauseV2(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV2 *objectType,
				IWbemClassObject *tableClass)
{

	SIMCTable *augmentedTable = table->GetAugmentedTable();
	if(augmentedTable)
		return MapAugmentsClauseV2(pAdminInt, pGroupHandleInt, table, objectType,
						augmentedTable, tableClass);

	SIMCIndexListV2 * indexList = objectType->GetIndexTypes();
	if(!indexList )
		return S_OK;

	SIMCSymbol **symbol;
	POSITION p = indexList->GetHeadPosition();
	
	HRESULT result = S_OK;
	SIMCIndexItemV2 *indexItem;
	long ordinal = 0;
	while(p)
	{
		ordinal ++;

		indexItem = indexList->GetNext(p);
		symbol = indexItem->_item;
		SIMCModule::SymbolClass symbolClass = SIMCModule::GetSymbolClass(symbol);
		switch(symbolClass)
		{
			case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
			case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
				if( FAILED(MapIndexValueReference(table, tableClass, symbol, ordinal)) )
					result = WBEM_E_FAILED;
			break;
			default:
				return WBEM_E_FAILED;
		}

	}
	return result;
}

static STDMETHODIMP MapAugmentsClauseV2(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV2 *objectType,
				SIMCTable *augmentedTable,
				IWbemClassObject *tableClass)
{
	// Set the properties/attributes of the class
	SIMCScalarMembers * columnMembers = augmentedTable->GetColumnMembers();
	SIMCScalar *nextColumnObject;
	POSITION p = columnMembers->GetHeadPosition();
	while(p)
	{
		nextColumnObject = columnMembers->GetNext(p);
		if( GenerateScalar(nextColumnObject, tableClass, FALSE, FALSE) == WBEM_E_FAILED)
				return WBEM_E_FAILED;
	}
 
	// Now deal with the index clause of the row object
	SIMCSymbol * rowSymbol = augmentedTable->GetRowSymbol();
	SIMCSymbol **rowSymbolP = &rowSymbol;
	SIMCObjectTypeType *rowObject;
	if( SIMCModule::IsObjectType(rowSymbolP, rowObject) != RESOLVE_CORRECT )
		return WBEM_E_FAILED;

	if (FAILED(MapIndexClause(pAdminInt, pGroupHandleInt, augmentedTable, rowObject,
			tableClass)))
	{
		if(simc_debug) cerr << "MapAugmentsClauseV2(): MapIndexClause() failed " << endl;
		return WBEM_E_FAILED;
	}

	return S_OK;
}

static HRESULT MapIndexTypeReference(SIMCTable *table, 
					IWbemClassObject *tableClass, 
					SIMCSymbol **syntaxSymbol, 
					long ordinal)
{
	const char * const tableName = (table->GetTableSymbol())->GetSymbolName();
	
	// Form the name of the virtual object-type
	char temp[20];
	sprintf(temp, "_%ld", ordinal);
	char *objectNameStr = new char[strlen(tableName) + strlen(temp) + 1];
	strcpy(objectNameStr, tableName);
	strcat(objectNameStr, temp);
	wchar_t * objectName = ConvertAnsiToBstr(objectNameStr);
	delete []objectNameStr;
	if(!objectName)
	{
		if(simc_debug) cerr << "MapIndexTypeReference(): ConvertAnsiToBstr - objectName failed" 
			<< endl;
		return WBEM_E_FAILED;
	}


	HRESULT result = CreatePropertyAndMapSyntaxClause(tableClass,
				syntaxSymbol,
				objectName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapIndexTypeReference() : CreatePropertyAndMapSyntaxClause() failed" << endl;
		return result;
	}

	// Set the Attributes
	IWbemQualifierSet *attributeSet ;
	result = tableClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapIndexTypeReference(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

	// Set the key_order atribute
	SetKeyOrder(attributeSet, ordinal);
	// Make it the key and virtual key
	MakeKey(attributeSet);
	MakeVirtualKey(attributeSet);
	attributeSet->Release();
	return result;
}


static HRESULT MapIndexValueReference(SIMCTable *table, 
					IWbemClassObject *tableClass, 
					SIMCSymbol **symbol,
					long ordinal)
{	/*
	if(table->IsColumnMember(*symbol))
		return MakeLocalColumnIndex(tableClass, *symbol, ordinal);
	else
		return MakeExternalColumnIndex (table, tableClass, *symbol, ordinal);
	*/

	SIMCObjectTypeType *objectType;

	if(SIMCModule::IsObjectType(symbol, objectType) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;

	HRESULT result;
	IWbemQualifierSet *attributeSet;
	BSTR symbolName = ConvertAnsiToBstr((*symbol)->GetSymbolName());
	
	if(IsInaccessibleObject(objectType) || IsObsoleteObject(objectType))
	{
		// First map the object

		SIMCCleanOidValue *oidValue = new SIMCCleanOidValue;
		wmilib::auto_ptr <SIMCCleanOidValue> oidValue_Guard ( oidValue ) ;

		if(!oidTree->GetOidValue((*symbol)->GetSymbolName(), 
									(*symbol)->GetModule()->GetModuleName(), *oidValue))
		{
			if(simc_debug) cerr << "MapIndexValueReference(): Could not get oidvalue" << endl;
			return WBEM_E_FAILED;
		}

		//
		// get rid of scope guard
		//
		// SIMCCleanOidValue is about to be deleted inside of destructor of
		// SIMCScalar class no matter how scope is left here !
		//
		oidValue_Guard.release () ;

		SIMCScalar dummy(*symbol, oidValue);

		// Map Inaccessible and Obsolete objects too
		result =  GenerateScalar(&dummy, tableClass, TRUE, TRUE);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "MapIndexValueReference(): GenrateScalar() Failed" << endl;
			return result;
		}
		result = tableClass->GetPropertyQualifierSet(symbolName, &attributeSet);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "MapIndexValueReference(): Could not get PropAttribute" << endl;
			return result;
		}
		result = MakeVirtualKey(attributeSet);
	}
	else
	{	
		// Generate a property for external objects
		BOOL internalObject = table->IsColumnMember(*symbol);
		if(!internalObject)
		{
			SIMCCleanOidValue *oidValue = new SIMCCleanOidValue;
			wmilib::auto_ptr <SIMCCleanOidValue> oidValue_Guard ( oidValue ) ;

			if(!oidTree->GetOidValue((*symbol)->GetSymbolName(), (*symbol)->GetModule()->GetModuleName(), *oidValue))
			{
				if(simc_debug) cerr << "MapIndexValueReference(): Could not get oidvalue" << endl;
				return WBEM_E_FAILED;
			}

			//
			// get rid of scope guard
			//
			// SIMCCleanOidValue is about to be deleted inside of destructor of
			// SIMCScalar class no matter how scope is left here !
			//
			oidValue_Guard.release () ;

			SIMCScalar dummy(*symbol, oidValue);

			result =  GenerateScalar(&dummy, tableClass, TRUE, TRUE);
			if(FAILED(result))
			{
				if(simc_debug) cerr << "MapIndexValueReference(): GenrateScalar() Failed" << endl;
				return result;
			}
		}

		result = tableClass->GetPropertyQualifierSet(symbolName, &attributeSet);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "MapIndexValueReference(): Could not get PropAttribute" << endl;
			return result;
		}

		if(internalObject)
			result = MakeKey(attributeSet);
		else
			result = MakeVirtualKey(attributeSet);

	}
	
	// Set the key_order atribute
	SetKeyOrder(attributeSet, ordinal);
	attributeSet->Release();
	return result;	
}

static STDMETHODIMP SetKeyOrder(IWbemQualifierSet *attributeSet, long ordinal)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_I4 ;
	variant.lVal = ordinal;
	HRESULT result = attributeSet->Put ( KEY_ORDER_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear ( & variant ) ;
	return result;
}


// Returns TRUE if :
//		1. the INDEX clause of the object contains an IMPLIED clause
//		2. the AUGMENTS clause of the object contains a table on which condition 1 or 2
//			holds good.
static BOOL ContainsImpliedClause(const SIMCObjectTypeV2 *objectType)
{
	SIMCIndexListV2 *indexList = objectType->GetIndexTypes();
	SIMCSymbol **augmentsSymbol = objectType->GetAugments();

	if(!indexList && !augmentsSymbol)
		return FALSE;

	if(indexList)
	{
		SIMCIndexItemV2 * item = indexList->GetTail();
		if(item->_implied)
			return TRUE;
		return FALSE;
	}

	if(augmentsSymbol)
	{
		SIMCObjectTypeV2 *objectTypeV2;
		if(SIMCModule::IsObjectTypeV2(augmentsSymbol, objectTypeV2) != RESOLVE_CORRECT)
			return FALSE;
		return ContainsImpliedClause(objectTypeV2);
	}

	return FALSE;
}

// Returns TRUE if the symbol resolves ultimately to the NULL type
static BOOL IsNullTypeReference(SIMCSymbol ** symbol)
{
	switch(	SIMCModule::GetSymbolClass(symbol) )
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCBuiltInTypeReference *btRef = NULL;
			btRef = (SIMCBuiltInTypeReference *)(*symbol);
			switch( SIMCModule::GetTypeClass(btRef->GetType()))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					return SIMCModule::GetPrimitiveType((*symbol)->GetSymbolName()) == SIMCModule::PRIMITIVE_NULL;
				default:
					return FALSE;
			}
			break;
		}
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		{
			SIMCDefinedTypeReference * dtRef = (SIMCDefinedTypeReference*)(*symbol);
			SIMCTypeReference *tRef = NULL;
			switch(dtRef->GetStatus())
			{
				case RESOLVE_CORRECT:
					tRef = dtRef->GetRealType();
					return SIMCModule::GetPrimitiveType(tRef->GetSymbolName()) == SIMCModule::PRIMITIVE_NULL;
					break;
				default:
					return FALSE;
			}
			break;
		}
		break;
	}

	return FALSE;
}


//
// Does all the cleaning up tasks associated with the SMIR.
// Currently, just deletes the specified module from the SMIR
//
static void CleanUpSmir(ISmirAdministrator *pAdminInt,
			ISmirModHandle *pModHandleInt)
{
	pAdminInt->DeleteModule(pModHandleInt);
}

//
// Generates the appropriate notification and extended notification classes
//
static STDMETHODIMP GenerateModuleNotifications (
			ISmirAdministrator *pAdminInt,			// To interact with the SMIR
			ISmirSerialiseHandle *pSerializeInt,	// To generate MOF
			const SIMCModule *module  )				// The parse tree for the module
{
	// Get the list of notifications from the module
	const SIMCNotificationList * listOfNotifications = module->GetNotificationTypeList();
	POSITION p = listOfNotifications->GetHeadPosition();
	SIMCNotificationElement *nextElement = NULL;
	HRESULT result = S_OK, retVal = S_OK;


	// Generate a class for every SNMPV2 NOTIFICATION-TYPE or a NOTIFICATION-TYPE
	// fabricated from SNMPV1 TRAP-TYPE
	while(p)
	{
		nextElement = listOfNotifications->GetNext(p);
		if(FAILED( result = GenerateNotificationType(pAdminInt, pSerializeInt, nextElement)))
		{
			retVal = result;
			if(simc_debug)
				cout << "FAILED to generate notification type" << endl;
		}

	}
	return retVal;
}


//
// Generate a class for an SIMCNotificationElement object. This object
// models an SNMPV2 NOTIFICATION-TYPE or a NOTIFICATION-TYPE fabricated from 
// an SNMPV1 TRAP-TYPE
//
static STDMETHODIMP GenerateNotificationType(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement)
{
	// First check to see if is "deprecated" or "obsolete" in which
	// case we dont need to map it.
	SIMCSymbol *notificationSymbol = notificationElement->GetSymbol();
	SIMCNotificationTypeType *notificationType = NULL;
	if(SIMCModule::IsNotificationType(&notificationSymbol, notificationType) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;
	switch(notificationType->GetStatus())
	{
		case SIMCNotificationTypeType::STATUS_OBSOLETE:
		case SIMCNotificationTypeType::STATUS_DEPRECATED:
			return S_OK;
		default:
			break;
	}


	const char * const notificationName = notificationSymbol->GetSymbolName();
	char 	*moduleNameMangled	= ConvertHyphensToUnderscores((notificationSymbol->GetModule())->GetModuleName());
	BSTR	moduleName			= ConvertAnsiToBstr(moduleNameMangled);
	HRESULT result = S_OK;


	// Create a notification class
	if(notifications)
	{
		// Set the notification class name
		char *mangledNotificationNameS = new char[strlen(GROUP_NAME_PREPEND_STRING) +
						strlen(moduleNameMangled) + 1 + strlen(notificationName) +1 + strlen(NOTIFICATION_SUFFIX) + 1];
		strcpy(mangledNotificationNameS, GROUP_NAME_PREPEND_STRING);
		strcat(mangledNotificationNameS, moduleNameMangled);
		strcat(mangledNotificationNameS, "_");
		strcat(mangledNotificationNameS, notificationName);
		strcat(mangledNotificationNameS, "_");
		strcat(mangledNotificationNameS, NOTIFICATION_SUFFIX);

		BSTR mangledNotificationName = ConvertAnsiToBstr(ConvertHyphensToUnderscores(mangledNotificationNameS));
		delete []mangledNotificationNameS;

		// Create the notification class

		ISmirNotificationClassHandle *notificationClassHandle = NULL ;
		result = pAdminInt->CreateWBEMNotificationClass(mangledNotificationName, &notificationClassHandle);

		SysFreeString(mangledNotificationName);
		if(FAILED(result))
		{
			switch(result)
			{
				case E_INVALIDARG:
					if(simc_debug) cerr << "GenerateObjectGroup(): AddGroup() failed" << endl;
					return result;
				case E_UNEXPECTED:
					if(simc_debug) cerr << "GenerateObjectGroup(): AddGroup() failed" << endl;
					return result;
				case S_OK:
					break;
			}
			if(simc_debug) cerr << "GenerateNotificationType(): CreateWBEMNotification class failed" << endl;
			return result;
		}

		IWbemClassObject *notificationClass = NULL ;
		result = notificationClassHandle->GetWBEMNotificationClass ( &notificationClass ) ;
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GetWBEMNotificationClass failed" << endl;
			return result;
		}
		// Set the module name on the class handle
		notificationClassHandle->SetModule(moduleName);

		// Set the attributes of the class
		result = GenerateNotificationAttributes(pAdminInt, pSerializeInt, notificationElement,
			notificationClass);
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GenerateNotificationAttributes failed" << endl;
			notificationClassHandle->Release();
			return result;
		}

		// Set the properties of the class
		result = GenerateNotificationProperties(pAdminInt, pSerializeInt, notificationElement,
			notificationClass);
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GenerateNotificationProperties failed" << endl;
			notificationClassHandle->Release();
			return result;
		}

		if(generateMof)
			result = pAdminInt->AddNotificationClassToSerialise(notificationClassHandle,
						pSerializeInt);
		else
			result = pAdminInt->AddNotificationClass(notificationClassHandle);

		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): AddNotificationClass failed" << endl;
			notificationClass->Release();
			notificationClassHandle->Release();
			return result;
		}

		notificationClass->Release();
		notificationClassHandle->Release();

	}

	// Create an extended notification class
	if(extendedNotifications)
	{
		// Create the interrogator. This is used for the GetWBEMClass() function
		// when setting properties that are references
		ISmirInterrogator *pInterrogateInt = NULL;
		result = pAdminInt->QueryInterface ( IID_ISMIR_Interrogative,(PPVOID)&pInterrogateInt);

 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): CoCreate interrogator class failed" << endl;
			return result;
		}

		// Set the extended notification class name
		char *mangledNotificationNameS =new char[strlen(GROUP_NAME_PREPEND_STRING) +
						strlen(moduleNameMangled) + 1 + strlen(notificationName) +1 + strlen(EX_NOTIFICATION_SUFFIX) + 1];
		strcpy(mangledNotificationNameS, GROUP_NAME_PREPEND_STRING);
		strcat(mangledNotificationNameS, moduleNameMangled);
		strcat(mangledNotificationNameS, "_");
		strcat(mangledNotificationNameS, notificationName);
		strcat(mangledNotificationNameS, "_");
		strcat(mangledNotificationNameS, EX_NOTIFICATION_SUFFIX);

		BSTR mangledNotificationName = ConvertAnsiToBstr(ConvertHyphensToUnderscores(mangledNotificationNameS));
		delete []mangledNotificationNameS;

		// Create the extended notification class

		ISmirExtNotificationClassHandle *exNotificationClassHandle = NULL ;
		result = pAdminInt->CreateWBEMExtNotificationClass(mangledNotificationName, &exNotificationClassHandle);

		SysFreeString(mangledNotificationName);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): Get ExNotification class failed" << endl;
			pInterrogateInt->Release();
			return result;
		}

		IWbemClassObject *exNotificationClass = NULL ;
		result = exNotificationClassHandle->GetWBEMExtNotificationClass ( & exNotificationClass ) ;
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GetWBEMExNotificationClass failed" << endl;
			return result;
		}

		// Set the module name on the class handle
		exNotificationClassHandle->SetModule(moduleName);

		// Set the attributes of the class
		result = GenerateExNotificationAttributes(pAdminInt, pInterrogateInt, pSerializeInt, notificationElement,
			exNotificationClass);
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GenerateExNotificationAttributes failed" << endl;
			exNotificationClassHandle->Release();
			pInterrogateInt->Release();
			return result;
		}

		// Set the properties of the class
		result = GenerateExNotificationProperties(pAdminInt, pInterrogateInt, pSerializeInt, notificationElement,
			exNotificationClass);
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GenerateExNotificationProperties failed" << endl;
			exNotificationClass->Release();
			exNotificationClassHandle->Release();
			pInterrogateInt->Release();
			return result;
		}

		if(generateMof)
			result = pAdminInt->AddExtNotificationClassToSerialise(exNotificationClassHandle,
						pSerializeInt);
		else
			result = pAdminInt->AddExtNotificationClass(exNotificationClassHandle);

		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): AddExNotificationClass failed" << endl;
			exNotificationClass->Release();
			exNotificationClassHandle->Release();
			pInterrogateInt->Release();
			return result;
		}

		exNotificationClass->Release();
		exNotificationClassHandle->Release();
		pInterrogateInt->Release();
	}
	SysFreeString(moduleName);
	return result;
}

// Set the attributes of a notification class
static STDMETHODIMP GenerateNotificationAttributes(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *notificationClass)
{
	// Get the description clause
	SIMCSymbol *notificationSymbol = notificationElement->GetSymbol();
	SIMCNotificationTypeType *notificationType = NULL;
	if(SIMCModule::IsNotificationType(&notificationSymbol, notificationType) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;

	// Set the various qualifiers
	IWbemQualifierSet *attributeSet ;
	HRESULT result = notificationClass->GetQualifierSet (&attributeSet);
  	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateNotificationAttributes(): GetAttribSet failed" << endl;
		return result;
	}
	VARIANT variant;
	VariantInit(&variant);

	// Set the Description attribute
	if(!UI->SuppressText() && notificationType->GetDescription())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr(notificationType->GetDescription());
		result = attributeSet->Put ( DESCRIPTION_NOTIFICATION_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION ) ;
		VariantClear ( & variant ) ;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationAttributes(): Put description failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Set the Reference attribute
	if(!UI->SuppressText() && notificationType->GetReference())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr(notificationType->GetReference());
		result = attributeSet->Put ( REFERENCE_NOTIFICATION_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION ) ;
		VariantClear ( & variant ) ;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationAttributes(): Put reference failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Set the "dynamic" attribute
	if(FAILED(result = MakeDynamic(attributeSet)))
	{
		if(simc_debug) cerr << "GenerateNotificationAttributes(): Make Dynamic failed" << endl;
		attributeSet->Release();
		return result;
	}

	// "provider"
	if(FAILED(result = SetProvider(attributeSet, SNMP_ENCAPSULATED_EVENT_PROVIDER)))
	{
		if(simc_debug) cerr << "GenerateNotificationAttributes(): Make Provider failed" << endl;
		attributeSet->Release();
		return result;
	}

 	attributeSet->Release();
	return result;

}

// Set the attributes of an extended notification class
static STDMETHODIMP GenerateExNotificationAttributes(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *exNotificationClass)
{
	// Get the description clause
	SIMCSymbol *notificationSymbol = notificationElement->GetSymbol();
	SIMCNotificationTypeType *notificationType = NULL;
	if(SIMCModule::IsNotificationType(&notificationSymbol, notificationType) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;

	// Get the Qualifier set
	IWbemQualifierSet *attributeSet ;
	HRESULT result = exNotificationClass->GetQualifierSet (&attributeSet);
  	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationAttributes(): GetAttribSet failed" << endl;
		return result;
	}

	VARIANT variant;
	VariantInit(&variant);

	// Set the Description attribute
	if(!UI->SuppressText() && notificationType->GetDescription())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr(notificationType->GetDescription());
		result = attributeSet->Put ( DESCRIPTION_NOTIFICATION_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION  ) ;
		VariantClear ( & variant ) ;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateExNotificationAttributes(): Put description failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Set the Reference attribute
	if(!UI->SuppressText() && notificationType->GetReference())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr(notificationType->GetReference());
		result = attributeSet->Put ( REFERENCE_NOTIFICATION_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION  ) ;
		VariantClear ( & variant ) ;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateExNotificationAttributes(): Put reference failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Set the "dynamic" attribute
	if(FAILED(result = MakeDynamic(attributeSet)))
	{
		if(simc_debug) cerr << "GenerateExNotificationAttributes(): Make Dynamic failed" << endl;
		attributeSet->Release();
		return result;
	}

	// "provider"
	if(FAILED(result = SetProvider(attributeSet, SNMP_REFERENT_EVENT_PROVIDER)))
	{
		if(simc_debug) cerr << "GenerateExNotificationAttributes(): Make Provider failed" << endl;
		attributeSet->Release();
		return result;
	}

 
 	attributeSet->Release();
	return result;

}

// Generate the "Identification" property and all the other properties of a notification class
static STDMETHODIMP GenerateNotificationProperties(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *notificationClass)
{
	// Get the notification oid value 
	SIMCCleanOidValue *notificationOidValue = notificationElement->GetOidValue();
	char *notificationOidString = CleanOidValueToString(*notificationOidValue);

	// Create the "Identification" property
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(notificationOidString);
	VARTYPE varType = VT_BSTR ;
	// delete[] notificationOidString;
	HRESULT result = notificationClass->Put (IDENTIFICATION_NOTIFICATION_PROPERTY, 0, &variant, varType);
	VariantClear(&variant);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateNotificationProperties(): Put Property SnmpTrapOID failed" << endl;
		return result;
	}

	// Get the OBJECTS clause
	SIMCSymbol *notificationSymbol = notificationElement->GetSymbol();
	SIMCNotificationTypeType *notificationType = NULL;
	if(SIMCModule::IsNotificationType(&notificationSymbol, notificationType) != RESOLVE_CORRECT)
		return E_FAIL;
	SIMCObjectsList *objects = notificationType->GetObjects();

	// Step thru the objects in the OBJECTS clause and generate appropriate properties
	if(!objects)
		return S_OK;
	POSITION p = objects->GetHeadPosition();
	SIMCObjectsItem *nextItem = NULL;
	SIMCSymbol ** object = NULL;
	int varBindIndex = 3; // Start at 3 according to the specifications
	while(p)
	{
		nextItem = objects->GetNext(p);
		object = nextItem->_item;
		result = GenerateNotificationObject(pAdminInt, pSerializeInt, notificationElement, object,
					varBindIndex++, notificationClass);
		if(FAILED(result))
			return result;
	}
	return result;
}


// Generate a property corresponding to an object in the OBJECTS clause
static STDMETHODIMP GenerateNotificationObject(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			SIMCSymbol **object,
			int varBindIndex,
			IWbemClassObject *notificationClass)
{
	SIMCObjectTypeType *objType = NULL;
	switch(SIMCModule::IsObjectType(object, objType))
	{
		case RESOLVE_CORRECT:
			break;
		default:
			if(simc_debug)
				cout << "GenerateNotificationObject(): Object in Notification OBJECTS clause doesn't resolve properly" <<
					endl;
		return WBEM_E_FAILED;
	}

	// Set the PROPERTY NAME corresponding to the OBJECT-TYPE identifier
	wchar_t * objectName = ConvertAnsiToBstr((*object)->GetSymbolName());
	if(!objectName)
	{
		if(simc_debug) cerr << "GenerateNotificationObject(): ConvertAnsiToBstr - objectName failed" 
			<< endl;
		return WBEM_E_FAILED;
	}

	// Have to decide the 'type' of the property based on the
	// SYNTAX clause of the OBJECT-TYPE.
	HRESULT result = CreatePropertyAndMapSyntaxClause(notificationClass,
				objType->GetSyntax(),
				objectName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapSyntaxClause() failed" << endl;
		return result;
	}

	// Get the attribute set
	IWbemQualifierSet *attributeSet ;
	result = notificationClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateNotificationObject(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

			
	// Map Access Clause
	if( FAILED(result = MapAccessClause(attributeSet, objType)) )
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapAccess() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// Map Description Clause
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapDescriptionClause(attributeSet, objType)) )
		{
			if(simc_debug) cerr << "GenerateNotificationObject() : MapDescriptionClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Reference Clause
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapReferenceClause(attributeSet, objType)) )
		{
			if(simc_debug) cerr << "GenerateNotificationObject() : MapReferenceClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Status Clause
	if( FAILED(result = MapStatusClause(attributeSet, objType))  )
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapStatusClause() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// Map Defval Clause
	if( FAILED(result = MapDefValClause(attributeSet, objType))  )
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapDefvalClause() failed" << endl;
		attributeSet->Release();
		return result;
	}


	// The "object_identifier" attribute
	if(FAILED(result = SetObjectIdentifierAttribute(attributeSet, object)))
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : SetObjectIdentifierAttribute() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// The "VarBindIndex" attribute
	if(FAILED(result = SetVarBindIndexAttribute(attributeSet, varBindIndex)))
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : SetVarBindIndexAttribute() failed" << endl;
		attributeSet->Release();
		return result;
	}

	attributeSet->Release();
	return S_OK;

}

static STDMETHODIMP SetObjectIdentifierAttribute (IWbemQualifierSet * attributeSet, SIMCSymbol **object)
{
	SIMCModule *module = (*object)->GetModule();
	SIMCObjectGroup *ownerGroup = module->GetObjectGroup(*object);
	SIMCTable *ownerTable = NULL;
	SIMCScalar *ownerScalar = NULL;
	char * snmpClassName = NULL;
	SIMCCleanOidValue *oidValue = NULL;
	if(!ownerGroup)
	{
		if(simc_debug)
			cout << "SetObjectIdentifierAttribute() : Could not get group for " << (*object)->GetSymbolName()
				<< endl;
		return WBEM_E_FAILED;
	}

	// See if it is a scalar
	if(ownerScalar = ownerGroup->GetScalar(*object))
	{
		// The oid value of the scalar
		oidValue = ownerScalar->GetOidValue();
	}
	// ... or a table
	else if(ownerTable = ownerGroup->GetTable(*object))
	{
		// And the oid value of the object
		SIMCScalar *columnScalar = ownerTable->GetColumnMember(*object);
		oidValue = columnScalar->GetOidValue();
	}
	else
	{
		if(simc_debug)
			cout << "SetObjectIdentifierAttribute() : Could not get table for " << (*object)->GetSymbolName()
				<< endl;
		return WBEM_E_FAILED;
	}


	// Set the "object_identifier" attribute
	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(ConvertHyphensToUnderscores(snmpClassName));
	// Set the object_identifier attribute
	HRESULT result = MapOidValue(attributeSet, *oidValue);
	if( FAILED(result) )
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapOidValue() failed" << endl;
		attributeSet->Release();
		return result;
	}
	return S_OK;
}

static STDMETHODIMP SetVarBindIndexAttribute (IWbemQualifierSet *attributeSet, int varBindIndex)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_I4 ;
	variant.lVal = varBindIndex;
	HRESULT result = attributeSet->Put ( VAR_BIND_INDEX_NOTIFICATION_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION ) ;
	VariantClear(&variant);
	if(FAILED(result))
	{
		if(simc_debug)
			cout << "SetVarBindIndexAttribute() : Could not set VarBindIndex "<< endl;
		return WBEM_E_FAILED;
	}
	return S_OK;

}



// Generate all the properties of the Extended Notification class
static STDMETHODIMP GenerateExNotificationProperties(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *notificationClass)
{
	// Get the notification oid value 
	SIMCCleanOidValue *notificationOidValue = notificationElement->GetOidValue();
	char *notificationOidString = CleanOidValueToString(*notificationOidValue);

	// Create the "Identification" property
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(notificationOidString);
	VARTYPE varType = VT_BSTR ;
	// delete[] notificationOidString;
	HRESULT result = notificationClass->Put (IDENTIFICATION_NOTIFICATION_PROPERTY, 0, &variant, varType);
	VariantClear(&variant);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationProperties(): Put Property SnmpTrapOID failed" << endl;
		return result;
	}

	// Get the OBJECTS clause
	SIMCSymbol *notificationSymbol = notificationElement->GetSymbol();
	SIMCNotificationTypeType *notificationType = NULL;
	if(SIMCModule::IsNotificationType(&notificationSymbol, notificationType) != RESOLVE_CORRECT)
		return E_FAIL;
	SIMCObjectsList *objects = notificationType->GetObjects();

	// Step thru the objects in the OBJECTS clause and generate appropriate properties
	if(!objects)
		return S_OK;
	POSITION p = objects->GetHeadPosition();
	SIMCObjectsItem *nextItem = NULL;
	SIMCSymbol ** object = NULL;
	int varBindIndex = 3; // Start at 3 according to the specifications
	while(p)
	{
		nextItem = objects->GetNext(p);
		object = nextItem->_item;
		result = GenerateExNotificationObject(pAdminInt, 
					pInterrogateInt, pSerializeInt, notificationElement, object,
					varBindIndex++, notificationClass);
		if(FAILED(result))
			return result;
	}

	
		
	return result;
}

// Generate the property in the entended notifications class, corresponding to the object in the OBJECTs clause
static STDMETHODIMP GenerateExNotificationObject(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			SIMCSymbol **object,
			int varBindIndex,
			IWbemClassObject *exNotificationClass)
{
	SIMCModule *module = (*object)->GetModule();
	SIMCObjectGroup *ownerGroup = module->GetObjectGroup(*object);
	SIMCTable *ownerTable = NULL;
	SIMCScalar *ownerScalar = NULL;
	char *snmpClassName = NULL;
	if(!ownerGroup)
	{
		if(simc_debug)
			cout << "GenerateExNotificationObject() : Could not get group for " << (*object)->GetSymbolName()
				<< endl;
		return WBEM_E_FAILED;
	}

	// See if it is a scalar
	if(ownerScalar = ownerGroup->GetScalar(*object))
	{
		// Form the name of the scalar class
		SIMCSymbol * namedNode = ownerGroup->GetNamedNode();
		const char * const namedNodeName = namedNode->GetSymbolName();
		SIMCModule *scalarModule = namedNode->GetModule();
		const char * const moduleName = scalarModule->GetModuleName();

		snmpClassName = new char[strlen(GROUP_NAME_PREPEND_STRING) +
					strlen(moduleName) + 1 + strlen(namedNodeName) +1 ];
		strcpy(snmpClassName, GROUP_NAME_PREPEND_STRING);
		strcat(snmpClassName, moduleName);
		strcat(snmpClassName, "_");
		strcat(snmpClassName, namedNodeName);

	}
	// ... or a table
	else if(ownerTable = ownerGroup->GetTable(*object))
	{
		// Form the name of the table group
		SIMCSymbol *tableNode = ownerTable->GetTableSymbol();
		SIMCModule *tableModule = tableNode->GetModule();
		const char * const moduleName = tableModule->GetModuleName();
		const char * const tableNodeName = tableNode->GetSymbolName();

		snmpClassName = new char[strlen(GROUP_NAME_PREPEND_STRING) +
					strlen(moduleName) + 1 + strlen(tableNodeName) +1 ];
		strcpy(snmpClassName, GROUP_NAME_PREPEND_STRING);
		strcat(snmpClassName, moduleName);
		strcat(snmpClassName, "_");
		strcat(snmpClassName, tableNodeName);
	}
	else
	{
		if(simc_debug)
			cout << "GenerateExNotificationObject() : Could not get table for " << (*object)->GetSymbolName()
				<< endl;
		return WBEM_E_FAILED;
	}


	// We have the class name now, we need to create a property of this type, and with the VarBindIndex
	// qualifier set to the appropriate value.
	// First, get the IWbemClassObject pointer
	IWbemClassObject *pClassBasis = NULL;
	BSTR theClassName = ConvertAnsiToBstr(ConvertHyphensToUnderscores(snmpClassName));
	delete[] snmpClassName;
	HRESULT result = pInterrogateInt->GetWBEMClass(&pClassBasis, theClassName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationObject(): Could not Get WBEM class" << endl;	  
		return result;
	}

	BSTR propertyName = ConvertAnsiToBstr((*object)->GetSymbolName());
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_UNKNOWN ;
	variant.punkVal = pClassBasis;
	VARTYPE varType = VT_UNKNOWN ;

	result = exNotificationClass->Put (propertyName, 0, NULL, CIM_REFERENCE );
	VariantClear(&variant);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationProperties(): Put Property SnmpTrapOID failed" << endl;
		return result;
	}

	// Get the attribute set
	IWbemQualifierSet *attributeSet = NULL;
	result = exNotificationClass->GetPropertyQualifierSet(propertyName, &attributeSet);
	SysFreeString(propertyName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationObject(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

	// Set a CIMTYPE qualifier that is a strong reference
	result = SetCIMTYPEAttribute(attributeSet, theClassName);
	SysFreeString(theClassName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationObject():SetCIMTYPEattributeSet FAILED with " << result << endl;	  
		return WBEM_E_FAILED;
	}

	SIMCObjectTypeType *objType = NULL;
	switch(SIMCModule::IsObjectType(object, objType))
	{
		case RESOLVE_CORRECT:
			break;
		default:
			if(simc_debug)
				cout << "GenerateExNotificationObject(): Object in Notification OBJECTS clause doesn't resolve properly" <<
					endl;
		return WBEM_E_FAILED;
	}

			
	// Map Access Clause
	if( FAILED(result = MapAccessClause(attributeSet, objType)) )
	{
		if(simc_debug) cerr << "GenerateExNotificationObject() : MapAccess() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// Map Description Clause
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapDescriptionClause(attributeSet, objType)) )
		{
			if(simc_debug) cerr << "GenerateNotificationObject() : MapDescriptionClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Status Clause
	if( FAILED(result = MapStatusClause(attributeSet, objType))  )
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapStatusClause() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// The "VarBindIndex" attribute
	if(FAILED(result = SetVarBindIndexAttribute(attributeSet, varBindIndex)))
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : SetVarBindIndexAttribute() failed" << endl;
		attributeSet->Release();
		return result;
	}

	attributeSet->Release();
	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\main.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <snmptempl.h>


#ifndef INITGUID
#define INITGUID
#endif

#ifdef INITGUID_DEFINED
#define INITGUID
#include <initguid.h>
#endif

#include <wchar.h>
#include <process.h> 
#include <wbemidl.h>
#include <objbase.h>
#include <initguid.h>

#include <bool.hpp>
#include <newString.hpp>
	
#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objectType.hpp>
#include <objectTypeV1.hpp>
#include <objectTypeV2.hpp>
#include <objectIdentity.hpp>
#include <trapType.hpp>
#include <notificationType.hpp>
#include <group.hpp>
#include <notificationGroup.hpp>
#include <module.hpp>


#include <stackValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMessage.hpp>
#include <errorContainer.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <abstractParseTree.hpp>
#include <oidTree.hpp>
#include <parseTree.hpp>
#include <infoLex.hpp>
#include <infoYacc.hpp>
#include <moduleInfo.hpp>
#include <registry.hpp>

#include "smir.h"

#include "main.hpp"
#include "generator.hpp"
#include "smimsgif.hpp"

// The errors container used to hold the error messages. This is global too.
static SIMCErrorContainer errorContainer;
// The DLL that contains the information messages
static HINSTANCE infoMessagesDll = LoadLibrary(INFO_MESSAGES_DLL);
// The string that represents the version# of Smi2smir. This is obtained from
// the string resources of the exe.
CString versionString;

void SetEcho ()
{
	HANDLE t_Input = GetStdHandle( STD_INPUT_HANDLE );
	DWORD t_Mode = 0 ;
	BOOL t_Status = GetConsoleMode ( t_Input , & t_Mode ) ;
	t_Mode = t_Mode | ENABLE_ECHO_INPUT ;
	t_Status = SetConsoleMode ( t_Input , t_Mode ) ;
}

void SetNoEcho ()
{
	HANDLE t_Input = GetStdHandle( STD_INPUT_HANDLE );
	DWORD t_Mode = 0 ;
	BOOL t_Status = GetConsoleMode ( t_Input , & t_Mode ) ;
	t_Mode = t_Mode & ( 0xffffffff ^ ENABLE_ECHO_INPUT ) ;
	t_Status = SetConsoleMode ( t_Input , t_Mode ) ;
}


// A routine to generate information messages
void InformationMessage(int messageType, ...)
{
	if( !infoMessagesDll)
	{
		cerr << "smi2smir : Could not load \"" <<
			INFO_MESSAGES_DLL << "\".\n" << endl;
		return;
	}

	va_list argList;
	va_start(argList, messageType);

	char message[INFO_MESSAGE_SIZE];
	char messageText[INFO_MESSAGE_SIZE];
	const char *temp1, *temp2, *temp3;
	long temp4;

	if(!LoadString(infoMessagesDll, messageType, messageText, INFO_MESSAGE_SIZE))
		cerr << "smi2smir: Panic, unable to load message text from " << INFO_MESSAGES_DLL <<
			endl;

	SIMCErrorMessage e;
	if(messageType == FILE_NOT_FOUND || messageType == INVALID_MIB_FILE)
	{
		e.SetSeverityLevel(SIMCParseTree::FATAL);
		e.SetSeverityString("Fatal");
	}
	else
	{
		e.SetSeverityLevel(SIMCParseTree::INFORMATION);
		e.SetSeverityString("Information");
	}
	switch(messageType)
	{
		case SMIR_CONNECT_FAILED:
		case LISTING_MODULES:
		case LISTING_FAILED:
		case PURGE_SUCCEEDED:
		case PURGE_FAILED:
		case MODULE_LISTING:
		case MODULE_LISTING_NO_MODULES:
		case MIB_PATH_LISTING:
		case LISTING_MIB_PATHS:
		case LISTING_MIB_PATHS_NONE:
			temp1 = va_arg(argList, const char *);
			sprintf(message, messageText, temp1);
			break;
		case SMI2SMIR_INFO:
		case SYNTAX_CHECK_FAILED:
		case SYNTAX_CHECK_SUCCEEDED:
		case SEMANTIC_CHECK_FAILED:
		case SEMANTIC_CHECK_SUCCEEDED:
		case SMIR_LOAD_FAILED:
		case SMIR_LOAD_SUCCEEDED:
		case MOF_GENERATION_FAILED:
		case MOF_GENERATION_SUCCEEDED:
		case SYMBOL_RESOLUTION_FAILED:
		case DELETE_SUCCEEDED:
		case DELETE_FAILED:
		case DELETE_MODULE_NOT_FOUND:
		case FILE_NOT_FOUND:
		case MODULE_NAME_SUCCEEDED:
		case MODULE_INFO_FAILED:
		case DIRECTORY_ADDITION_SUCCEEDED:
		case DIRECTORY_ADDITION_FAILED:
		case DIRECTORY_DELETION_SUCCEEDED:
		case DIRECTORY_DELETION_FAILED:
		case INVALID_MIB_FILE:
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			sprintf(message, messageText, temp1, temp2);
			break;
		case COMPILED_FILE:
		case DUPLICATE_MODULES:
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			temp3 = va_arg(argList, const char *);
			sprintf(message, messageText, temp1, temp2, temp3);
			break;
		case NUMBER_OF_ENTRIES:
			temp1 = va_arg(argList, const char *);
			temp4 = va_arg(argList, long);
			sprintf(message, messageText, temp1, temp4);
			break;
	}
	va_end(argList);

	e.SetMessage(message);
	e.SetLineAndColumnValidity(FALSE);
	errorContainer.InsertMessage(e);
}


void CheckForDuplicateModules(SIMCFileMapList &dependencyList, const CString& applicationName)
{
	POSITION pOuter = dependencyList.GetHeadPosition();
	SIMCFileMapElement nextElement, laterElement;
	while(pOuter)
	{
		nextElement = dependencyList.GetNext(pOuter);
		POSITION pInner = pOuter, pTemp;
		while(pInner)
		{
			pTemp = pInner;
			laterElement = dependencyList.GetNext(pInner);
			if(laterElement.moduleName == nextElement.moduleName)
			{
				InformationMessage(DUPLICATE_MODULES, applicationName, 
					nextElement.moduleName,
					nextElement.fileName);
				if(pTemp == pOuter)
					pOuter = pInner;
				dependencyList.RemoveAt(pTemp);
			}
		}
	}
}

// Returns true if there's atleast one module in SMIR
BOOL AreModulesInSmir(ISMIRWbemConfiguration *a_Configuration, const CString& applicationName)
{

	// Create the interrogative interface 
	ISmirInterrogator *pInterrogateInt;
	HRESULT result = a_Configuration->QueryInterface(IID_ISMIR_Interrogative,(PPVOID)&pInterrogateInt);

	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "AreModulesInSmir(): CoCreate() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		return FALSE;
	}

	// Create an enumerator
	IEnumModule *pEnumInt;
	result = pInterrogateInt->EnumModules(&pEnumInt);
	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "AreModulesInSmir(): EnumModules() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		pInterrogateInt->Release();
		return FALSE;
	}

	// If no modules return
	ISmirModHandle *nextModule = NULL;
	if(pEnumInt->Next(1, &nextModule, NULL) != S_OK)
	{
		pEnumInt->Release();
		pInterrogateInt->Release();
		return FALSE;
	}

	// Release all enumeration interfaces
	pEnumInt->Release();
	pInterrogateInt->Release();
	nextModule->Release();
	return TRUE;
}

// Lists all the modules in the SMIR
BOOL SIMCListSmir(ISMIRWbemConfiguration *a_Configuration , const CString& applicationName) 
{
	// Create the interrogative interface 
	ISmirInterrogator *pInterrogateInt;
	HRESULT result = a_Configuration->QueryInterface(IID_ISMIR_Interrogative,(PPVOID)&pInterrogateInt);

	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCListSmir(): CoCreate() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		return FALSE;
	}

	IEnumModule *pEnumInt;
	result = pInterrogateInt->EnumModules(&pEnumInt);
	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCListSmir(): EnumModules() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		pInterrogateInt->Release();
		return FALSE;
	}


	BOOL first = true;
	ISmirModHandle *nextModule = NULL;
	BSTR moduleName;
	while(pEnumInt->Next(1, &nextModule, NULL) == S_OK)
	{
		if(nextModule->GetName(&moduleName) == S_OK)
		{
			if(first)
			{
				InformationMessage(LISTING_MODULES, applicationName);
				cout << endl;
				first = false;
			}

			char *moduleNameStr = ConvertBstrToAnsi(moduleName);
			InformationMessage(MODULE_LISTING, moduleNameStr);
			delete moduleNameStr;
			SysFreeString(moduleName);
		}
		
		nextModule->Release();
		nextModule = NULL;
	}

	if(first)
		InformationMessage(MODULE_LISTING_NO_MODULES, applicationName);

	pEnumInt->Release();
	pInterrogateInt->Release();

	return TRUE;
}

// Lists all the MIB paths (directories) in the registry
BOOL SIMCListMibPaths(const CString& applicationName) 
{

	SIMCStringList pathList;
	if(SIMCRegistryController::GetMibPaths(pathList))
	{
		// Successful in reading the MIB path list from registry
		POSITION p = pathList.GetHeadPosition();
		if(p) // There's atleast one MIB path
		{
			InformationMessage(LISTING_MIB_PATHS, applicationName);
			while(p)
				InformationMessage(MODULE_LISTING, pathList.GetNext(p));
		}
		else // There are no MIB paths in the registry
			InformationMessage(LISTING_MIB_PATHS_NONE, applicationName);
	}
	else // Failed to read the list of paths. Report that there are no paths
		InformationMessage(LISTING_MIB_PATHS_NONE, applicationName);
	
	return true;

}

// Deletes a specified module in the SMIR
BOOL SIMCDeleteModule(ISMIRWbemConfiguration *a_Configuration , const CString& applicationName, const CString& moduleName)
{
	// Create the administrator, to delete the module
	ISmirAdministrator *pAdminInt = NULL;
	HRESULT result=a_Configuration->QueryInterface(IID_ISMIR_Administrative,(PPVOID)&pAdminInt);
	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCDeleteModule() : CoCreate() failed on the Administrator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		return FALSE;
	}

	// Create the Interrogator to get the module handle of the
	// module to be deleted
	ISmirInterrogator *pInterrogateInt = NULL;
	result = a_Configuration->QueryInterface(IID_ISMIR_Interrogative,(PPVOID)&pInterrogateInt);
	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCDeleteModule() : CoCreate() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		return FALSE;
	}

	// Get the module handle using the enumerator and interrogator
	IEnumModule *pEnumInt = NULL;
	result = pInterrogateInt->EnumModules(&pEnumInt);
	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCDeleteModule() : EnumModules() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		pAdminInt->Release();
		pInterrogateInt->Release();
		return FALSE;
	}

	ISmirModHandle *nextModule = NULL;
	BSTR moduleNameBstr;
	char * moduleNameAnsi;
	while( pEnumInt->Next(1, &nextModule, NULL) == S_OK  && nextModule)
	{
		nextModule->GetName(&moduleNameBstr);
		moduleNameAnsi = ConvertBstrToAnsi(moduleNameBstr);
		SysFreeString(moduleNameBstr);
		if(_stricmp(moduleNameAnsi, moduleName) == 0)
		{
			delete moduleNameAnsi;
			//nextModule->AddRef();
			BOOL retval = SUCCEEDED(pAdminInt->DeleteModule(nextModule));
			pAdminInt->Release();
			pInterrogateInt->Release();
			nextModule->Release();

			return retval;
		}
		
		nextModule->Release();
		nextModule = NULL;
	}
 	InformationMessage(DELETE_MODULE_NOT_FOUND, applicationName, moduleName);
	pAdminInt->Release();
	pInterrogateInt->Release();

	return FALSE;
	
}

// Deletes all the modules in the SMIR
BOOL SIMCPurgeSmir(ISMIRWbemConfiguration *a_Configuration , const CString& applicationName)
{

	// Create the administrator, to delete the modules
	ISmirAdministrator *pAdminInt = NULL;
	HRESULT result = a_Configuration->QueryInterface(IID_ISMIR_Administrative,(PPVOID)&pAdminInt);

	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCPurgeSmir() : CoCreate() failed on the Admionistrator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		return FALSE;
	}
 	
	BOOL retval = SUCCEEDED(pAdminInt->DeleteAllModules());
	pAdminInt->Release();

	return retval;
}

// Filters the errors based on the switches on the command-line
void FilterErrors(SIMCErrorContainer *errorContainer,
				  const SIMCUI& theUI)
{
	errorContainer->MoveToFirstMessage();
	SIMCErrorMessage e;
	int i = theUI.GetMaxDiagnosticCount();
	int maxSeverityLevel = theUI.GetDiagnosticLevel();
	while(errorContainer->GetNextMessage(e))
	{
		  if(e.GetSeverityLevel() == 3 )
			  cerr << e;
		  else if(e.GetSeverityLevel() <= maxSeverityLevel && i>0)
		  {
			  cerr << e;
			  i--;
		  }
	}
}

// Checks whether the main mib file and the subsidiary files are
// compilable, and adds them to the priority map
// Adds any files in the include directories to the priority map
BOOL PrepareSubsidiariesAndIncludes(const CString& applicationName,
									const CString& mainFileName,
									const SIMCFileList&	subsidiaryFiles,
									const SIMCPathList& includePaths,
									SIMCFileMapList& priorityMap)
{
	// Parse the subsidiaries and add em to dependency list or 
	//issue messages
	// Same with  includes?
	BOOL retVal = TRUE;
	FILE * fp = fopen(mainFileName, "r");
	if(fp)
	{
 		SIMCModuleInfoScanner smallScanner;
		SIMCModuleInfoParser smallParser;
		smallScanner.setinput(fp);
		if(smallParser.GetModuleInfo(&smallScanner))
			priorityMap.AddTail(SIMCFileMapElement(smallParser.GetModuleName(), mainFileName));
		else
		{
			InformationMessage(INVALID_MIB_FILE, 
				applicationName, mainFileName);
			retVal = FALSE;
		}
		fclose(fp);
	}
	else
	{
		retVal = FALSE;
		InformationMessage(FILE_NOT_FOUND, applicationName, mainFileName);
	}

	POSITION pFiles = subsidiaryFiles.GetHeadPosition();
	CString nextFile;
	while(pFiles)
	{
		nextFile = subsidiaryFiles.GetNext(pFiles);
		fp = fopen(nextFile, "r");
		if(fp)
		{
 			SIMCModuleInfoScanner smallScanner;
			SIMCModuleInfoParser smallParser;
			smallScanner.setinput(fp);
			if(smallParser.GetModuleInfo(&smallScanner))
				priorityMap.AddTail(SIMCFileMapElement(smallParser.GetModuleName(), nextFile));
			else
			{
				InformationMessage(INVALID_MIB_FILE, 
					applicationName, nextFile);
				retVal = FALSE;
			}
			fclose(fp);
		}
		else
		{
			retVal = FALSE;
			InformationMessage(FILE_NOT_FOUND, applicationName, nextFile);
		}
	}

	// Make sure that there arent any duplicates
	CheckForDuplicateModules(priorityMap, applicationName);

	// Now do the same for the files in the include list
	SIMCStringList suffixList;
	if(!SIMCRegistryController::GetMibSuffixes(suffixList))
		return retVal;

	POSITION pPaths = includePaths.GetHeadPosition();
	CString nextPath;
	while(pPaths)
	{
		nextPath = includePaths.GetNext(pPaths);
		SIMCRegistryController::RebuildDirectory(nextPath, 
			suffixList, priorityMap);
	}

	return retVal;

}

int _cdecl main( int argc, const char *argv[])
{
	SIMCUI theUI;

	// Parse the command-line
	if( !theUI.ProcessCommandLine(argc, argv))
		 return 1;

	// Create and initialize variables
	simc_debug = theUI.IsSimcDebug();
	SIMCParseTree theTree(&errorContainer);
	CString inputFileName = theUI.GetInputFileName(), 
			applicationName = theUI.GetApplicationName();
	long snmpVersion = theUI.GetSnmpVersion();
	BOOL retVal = TRUE, generateMof = FALSE;
	versionString = theUI.GetVersionNumber();

	ISMIRWbemConfiguration *t_Configuration = NULL ;

	switch (theUI.GetCommandArgument())
	{
/* 
 *	These commands access the SMIR so Authenticate first.
 */

		case SIMCUI::COMMAND_PURGE:
		case SIMCUI::COMMAND_DELETE:
		case SIMCUI::COMMAND_LIST:	
		case SIMCUI::COMMAND_GENERATE:
		case SIMCUI::COMMAND_GENERATE_CLASSES_ONLY:
		case SIMCUI::COMMAND_ADD:
		case SIMCUI::COMMAND_SILENT_ADD:	
		{
			HRESULT result = CoInitialize(NULL);

			result = CoCreateInstance (

				CLSID_SMIR_Database , NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
				IID_ISMIRWbemConfiguration,
				(PPVOID)&t_Configuration
			) ;

			if ( SUCCEEDED ( result ) )
			{
#if 0
				cout << "Enter password:" << flush;
				char response[80];
				SetNoEcho ();
				cin.get(response, 80);
				SetEcho () ;
#endif
				result = t_Configuration->Authenticate (

					NULL,
					NULL,
					NULL,
					NULL,
					0 ,
					NULL,
					FALSE
				) ;

				if ( ! SUCCEEDED ( result ) )
				{
					InformationMessage(SMIR_CONNECT_FAILED, applicationName);
					if( theUI.GetCommandArgument() != SIMCUI::COMMAND_SILENT_ADD)
						FilterErrors(&errorContainer, theUI);
					return 1;
				}
			}
			else
			{
				if(result != S_OK)
				{
					InformationMessage(SMIR_CONNECT_FAILED, 
						applicationName);
					if( theUI.GetCommandArgument() != SIMCUI::COMMAND_SILENT_ADD)
						FilterErrors(&errorContainer, theUI);
					return 1;
				}
			}
		}
	}


	// Do the action specified on the command-line
	switch (theUI.GetCommandArgument())
	{
		case SIMCUI::COMMAND_HELP1:
		case SIMCUI::COMMAND_HELP2:
			theUI.Usage();
		break;

		case SIMCUI::COMMAND_PURGE:
		{
			// Check to see if there is atleast 1 module
			if(!AreModulesInSmir(t_Configuration, applicationName)) {
				InformationMessage(MODULE_LISTING_NO_MODULES, applicationName);
				retVal = FALSE;
				break;
			}

			// Confirm the purge
			if(!theUI.ConfirmedPurge()) {
				cout << applicationName << " : Version:" << versionString << ": Delete all modules from the SMIR? [y/n]" << flush;
				char response[80];
				cin.get(response, 80);
				if(strcmp(response, "y") != 0)
				{
					retVal = TRUE;
					break;
				}
			}

			// Get on with the purging now.
			if(!SIMCPurgeSmir(t_Configuration, applicationName) )
			{
				InformationMessage(PURGE_FAILED, applicationName);
				retVal = FALSE;
				break;
			}
			else
			{
				InformationMessage(PURGE_SUCCEEDED, applicationName);
				retVal = TRUE;
				break;
			}
		}
		break;
		
		case SIMCUI::COMMAND_DELETE:
		{
			InformationMessage(SMI2SMIR_INFO, applicationName, versionString);
			cout << endl;

			CString moduleName = theUI.GetModuleName();
			
			if(!SIMCDeleteModule(t_Configuration,applicationName, moduleName))
			{
				InformationMessage(DELETE_FAILED, applicationName, moduleName);
				retVal = FALSE;
				break;
			}
			else
			{
				InformationMessage(DELETE_SUCCEEDED, applicationName, moduleName);
				retVal = TRUE;
				break;
			}
		}
 		break;

		case SIMCUI::COMMAND_LIST:	
		{
			InformationMessage(SMI2SMIR_INFO, applicationName, versionString);
			cout << endl;
			
			if(!SIMCListSmir(t_Configuration,applicationName))
			{
				InformationMessage(LISTING_FAILED, applicationName);
				retVal = FALSE;
			}
			else
			{
				retVal = TRUE;
			}
		}
		break;
	
		case SIMCUI::COMMAND_MODULE_NAME:
			{
   				FILE *fp = fopen(inputFileName, "r");
				if(!fp)
				{
					InformationMessage(FILE_NOT_FOUND, applicationName, inputFileName);
					retVal = FALSE;
				}
				else
				{
					SIMCModuleInfoScanner smallScanner;
					smallScanner.setinput(fp);
					SIMCModuleInfoParser smallParser;


					if(smallParser.GetModuleInfo(&smallScanner))
						InformationMessage(MODULE_NAME_SUCCEEDED, applicationName, smallParser.GetModuleName() );
					else
					{
						retVal = FALSE;
						InformationMessage(MODULE_INFO_FAILED, applicationName, inputFileName);
					}
					fclose(fp);
				}
			}
			break;
			
		case SIMCUI::COMMAND_IMPORTS_INFO:
			{
   				FILE *fp = fopen(inputFileName, "r");
				if(!fp)
				{
					InformationMessage(FILE_NOT_FOUND, applicationName, inputFileName);
					retVal = FALSE;
				}
				else
				{
					SIMCModuleInfoScanner smallScanner;
					smallScanner.setinput(fp);
					SIMCModuleInfoParser smallParser;


					if(smallParser.GetModuleInfo(&smallScanner))
					{
						const SIMCStringList * importList = smallParser.GetImportModuleList();
						POSITION p = importList->GetHeadPosition();
						if(p) 
						{
							cout << "IMPORT MODULES" << endl;
							while(p)
								cout << "\t" << importList->GetNext(p) << endl;
						}
						else
							cout << "NO IMPORT MODULES" << endl;
					}
					else
					{
						retVal = FALSE;
						InformationMessage(MODULE_INFO_FAILED, applicationName, inputFileName);
					}
					fclose(fp);
				}
			}
			break;
	
		case SIMCUI::COMMAND_REBUILD_TABLE:
			InformationMessage(NUMBER_OF_ENTRIES, 
				applicationName, SIMCRegistryController::RebuildMibTable());
			break;
		
		case SIMCUI::COMMAND_LIST_MIB_PATHS:
			InformationMessage(SMI2SMIR_INFO, applicationName, versionString);
			cout << endl;

			SIMCListMibPaths(applicationName);

			break;
		
		case SIMCUI::COMMAND_LOCAL_CHECK:
			{

				//----------- 1. Do Syntax Checking -----------------------
   				FILE *fp = fopen(inputFileName, "r");
				if(!fp)
				{
					InformationMessage(FILE_NOT_FOUND, applicationName, inputFileName);
					retVal = FALSE;
				}
				else
				{
					fclose(fp);
					InformationMessage(COMPILED_FILE, applicationName, versionString, inputFileName);
					theTree.SetSnmpVersion(snmpVersion);
					if(!theTree.CheckSyntax(theUI.GetInputFileName()) )
					{
						retVal = FALSE;
						InformationMessage(SYNTAX_CHECK_FAILED, applicationName, inputFileName );
					}
					else
						InformationMessage(SYNTAX_CHECK_SUCCEEDED, applicationName, inputFileName);


					//----------- 2. Do Symbol resolution ----------------------
					if(retVal)
					{
						if(!theTree.Resolve(TRUE))
						{
							retVal = FALSE;
							InformationMessage(SYMBOL_RESOLUTION_FAILED, applicationName, 
									inputFileName);
						}
					}

					//------------ 3. Do Semantic Checking ----------------------
					if(retVal)
					{
						if(!theTree.CheckSemantics(TRUE))
						{
							retVal = FALSE;
							InformationMessage(SEMANTIC_CHECK_FAILED, applicationName, 
									inputFileName);
						}
						else
							InformationMessage(SEMANTIC_CHECK_SUCCEEDED, applicationName, 
									inputFileName);

					}
				}
			}
			break;

		case SIMCUI::COMMAND_EXTERNAL_CHECK: 
			{
   				if(theUI.AutoRefresh())
					InformationMessage(NUMBER_OF_ENTRIES, 
						applicationName, SIMCRegistryController::RebuildMibTable());

				SIMCFileMapList dependencyList, priorityList;

				const SIMCFileList * subsidiaryFiles = theUI.GetSubsidiaryFiles();
				const SIMCPathList * includePaths = theUI.GetPaths();
	
				// Make sure that the files that *have* to be compiled, exist
				// and are valid. Add the files in the includePaths to the
				// priority list
				// Bail out if the subsidiaries or the main file cant be processed
				if(!PrepareSubsidiariesAndIncludes(applicationName, inputFileName, 
					*subsidiaryFiles, *includePaths, priorityList))
				{
					retVal = FALSE;
					break;
				}

				FILE * fp = fopen(inputFileName, "r");
				if(fp)
				{
 					SIMCModuleInfoScanner smallScanner;
					smallScanner.setinput(fp);
					SIMCModuleInfoParser smallParser;
					CString dependentFile, dependentModule;
					if(smallParser.GetModuleInfo(&smallScanner))
					{
						fclose(fp); // Better close it rightnow, because of the recursion below

						// Add the current file to the dependency list
						dependencyList.AddTail(SIMCFileMapElement(smallParser.GetModuleName(), inputFileName));
					}
				}

				// Do a depth first search for dependencies
				SIMCRegistryController::GetDependentModules(inputFileName, 
					dependencyList, priorityList);
				
				theTree.SetSnmpVersion(snmpVersion);
				POSITION p;
				p = dependencyList.GetHeadPosition();
				SIMCFileMapElement element;
				BOOL first = TRUE;
				while(p)
				{
					element = dependencyList.GetNext(p);
   					fp = fopen(element.fileName, "r");
					if(!fp)
					{
						if(first)
							retVal = FALSE;
						InformationMessage(FILE_NOT_FOUND, applicationName, element.fileName);
					}
					else
					{
						fclose(fp);
					
						InformationMessage(COMPILED_FILE, applicationName, versionString, element.fileName);
						if(!theTree.CheckSyntax(element.fileName) )
						{
							if(first)
								retVal = FALSE;
							InformationMessage(SYNTAX_CHECK_FAILED, applicationName, element.fileName);
						}
						else
							InformationMessage(SYNTAX_CHECK_SUCCEEDED, applicationName, element.fileName);
					}
					if(first)
						first = FALSE;
				}
					   
				if(retVal)
				{
					if(!theTree.Resolve(FALSE))
					{
						retVal = FALSE;
						InformationMessage(SYMBOL_RESOLUTION_FAILED, applicationName, 
								inputFileName);
					}
				}

				if(retVal)
				{
					if(!theTree.CheckSemantics(FALSE))
					{
						retVal = FALSE;
						InformationMessage(SEMANTIC_CHECK_FAILED, applicationName, 
								inputFileName);
					}
					else
						InformationMessage(SEMANTIC_CHECK_SUCCEEDED, applicationName, 
								inputFileName);
				}
			}
 			break;

		case SIMCUI::COMMAND_GENERATE:	//  Fall thru
		case SIMCUI::COMMAND_GENERATE_CLASSES_ONLY:
				generateMof = TRUE;
		case SIMCUI::COMMAND_ADD:		//  Fall thru
		case SIMCUI::COMMAND_SILENT_ADD:	

			{
				if(theUI.AutoRefresh())
					InformationMessage(NUMBER_OF_ENTRIES, 
						applicationName, SIMCRegistryController::RebuildMibTable());

				SIMCFileMapList dependencyList, priorityList;

				const SIMCFileList * subsidiaryFiles = theUI.GetSubsidiaryFiles();
				const SIMCPathList * includePaths = theUI.GetPaths();
	
				// Make sure that the files that *have* to be compiled, exist
				// and are valid. Add the files in the includePaths to the
				// priority list
				// Bail out if the subsidiaries or the main file cant be processed
				if(!PrepareSubsidiariesAndIncludes(applicationName, inputFileName, 
					*subsidiaryFiles, *includePaths, priorityList))
				{
					retVal = FALSE;
					break;
				}

				FILE * fp = fopen(inputFileName, "r");
				if(fp)
				{
 					SIMCModuleInfoScanner smallScanner;
					smallScanner.setinput(fp);
					SIMCModuleInfoParser smallParser;
					CString dependentFile, dependentModule;
					if(smallParser.GetModuleInfo(&smallScanner))
					{
						fclose(fp); // Better close it rightnow, because of the recursion below

						// Add the current file to the dependency list
						dependencyList.AddTail(SIMCFileMapElement(smallParser.GetModuleName(), inputFileName));
					}
				}

				// Do a dpeth first seacrh for dependencies
				SIMCRegistryController::GetDependentModules(inputFileName, 
					dependencyList, priorityList);
				
				theTree.SetSnmpVersion(snmpVersion);

				POSITION p;
				p = dependencyList.GetHeadPosition();
				SIMCFileMapElement element;
				BOOL first = TRUE; // Special treatment for the first module
				while(p)
				{
					element = dependencyList.GetNext(p);
   					fp = fopen(element.fileName, "r");
					if(!fp)
					{
						InformationMessage(FILE_NOT_FOUND, applicationName, element.fileName);
						if(first)
							retVal = FALSE;
					}
					else
					{
						fclose(fp);
					
						InformationMessage(COMPILED_FILE, applicationName, versionString, element.fileName);
						if(!theTree.CheckSyntax(element.fileName) )
						{
							if(first)
								retVal = FALSE;
							InformationMessage(SYNTAX_CHECK_FAILED, applicationName, element.fileName);
						}
						else
							InformationMessage(SYNTAX_CHECK_SUCCEEDED, applicationName, element.fileName);
					}
					if(first)
						first = FALSE;
				}
					   
				if(retVal)
				{
					if(!theTree.Resolve(FALSE))
					{
						retVal = FALSE;
						InformationMessage(SYMBOL_RESOLUTION_FAILED, applicationName, 
								inputFileName);
					}
				}


				if(retVal)
				{
					if(!theTree.CheckSemantics(FALSE))
					{
						retVal = FALSE;
						InformationMessage(SEMANTIC_CHECK_FAILED, applicationName, 
								inputFileName);
					}
					else
						InformationMessage(SEMANTIC_CHECK_SUCCEEDED, applicationName, 
								inputFileName);
				}


				if(retVal && simc_debug) cout << theTree;

				// Load the module, or generate mof  
				if(retVal)
				{
					if(FAILED(GenerateClassDefinitions(t_Configuration,theUI, theTree, generateMof)))
					{
						retVal = FALSE;
						if(generateMof)
							InformationMessage(MOF_GENERATION_FAILED, applicationName, 
								inputFileName);
						else
							InformationMessage(SMIR_LOAD_FAILED, applicationName, 
								inputFileName);
					}
					else
					{
						if(generateMof)
							InformationMessage(MOF_GENERATION_SUCCEEDED, applicationName,
									inputFileName);
						else
							InformationMessage(SMIR_LOAD_SUCCEEDED, applicationName,
									inputFileName);
					}
				}
			}
			break;
		case SIMCUI::COMMAND_ADD_DIRECTORY:

			if(SIMCRegistryController::AddRegistryDirectory(theUI.GetDirectory()))
			{
				InformationMessage(DIRECTORY_ADDITION_SUCCEEDED, applicationName,
									theUI.GetDirectory());
				InformationMessage(NUMBER_OF_ENTRIES, 
					applicationName, SIMCRegistryController::RebuildMibTable());
			}
			else
			{
				InformationMessage(DIRECTORY_ADDITION_FAILED, applicationName,
									theUI.GetDirectory());
				retVal = FALSE;
			}
			break;

		case SIMCUI::COMMAND_DELETE_DIRECTORY_ENTRY:
			if(SIMCRegistryController::DeleteRegistryDirectory(theUI.GetDirectory()))
			{
				InformationMessage(DIRECTORY_DELETION_SUCCEEDED, applicationName,
									theUI.GetDirectory());
				InformationMessage(NUMBER_OF_ENTRIES, 
					applicationName, SIMCRegistryController::RebuildMibTable());
			}
			else
			{
				InformationMessage(DIRECTORY_DELETION_FAILED, applicationName,
									theUI.GetDirectory());
				retVal = FALSE;
			}
			 break;

		case SIMCUI::COMMAND_NONE:
		default: 	
			assert(0);
	}

	if ( t_Configuration )
	{
		t_Configuration->Release () ;
		CoUninitialize () ;
	}

	if( theUI.GetCommandArgument() != SIMCUI::COMMAND_SILENT_ADD)
		FilterErrors(&errorContainer, theUI);
	
	if (NULL != infoMessagesDll)
		FreeLibrary(infoMessagesDll);

	if (NULL != SIMCParseTree::semanticErrorsDll)
		FreeLibrary(SIMCParseTree::semanticErrorsDll);

	if (NULL != SIMCParser::semanticErrorsDll)
		FreeLibrary(SIMCParser::semanticErrorsDll);

	if (NULL != SIMCParser::syntaxErrorsDll)
		FreeLibrary(SIMCParser::syntaxErrorsDll);

	return (retVal)? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\main.hpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef SIMC_IMOS_GEN_H
#define SIMC_IMOS_GEN_H


const int INFO_MESSAGE_SIZE = 1024;
#define INFO_MESSAGES_DLL	"smimsgif.dll"

typedef void ** PPVOID;
typedef CList<CString, CString&> SIMCStringList;

void InformationMessage(int messageType, ...);

extern CString versionString;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

 
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <limits.h>

#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>
							   
#include <windows.h>

#include <objbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\generator.hpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef SIMC_GENERATOR_H
#define SIMC_GENERATOR_H

extern BOOL simc_debug;

STDMETHODIMP GenerateClassDefinitions (ISMIRWbemConfiguration *a_Configuration , const SIMCUI& theUI, SIMCParseTree&, BOOL generateMof);
BSTR ConvertAnsiToBstr(const char * const input);
char * ConvertBstrToAnsi(const BSTR& unicodeString);

// prefixes, suffixes for group names, notification names etc
#define GROUP_NAME_PREPEND_STRING			"SNMP_"
#define NOTIFICATION_SUFFIX					"Notification"
#define EX_NOTIFICATION_SUFFIX				"ExtendedNotification"


// WBEM constants
#define WBEM_CLASS_NO_PROPAGATION WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS
#define WBEM_CLASS_DO_PROPAGATION WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

// WBEM properties
#define NAME_PROPERTY		(L"__NAME")
#define CLASS_PROPERTY		(L"__CLASS")
#define DYNASTY_PROPERTY	(L"__DYNASTY")
#define PARENT_PROPERTY		(L"__PARENT")


// Property and Class Attributes
#define PROVIDER_ATTRIBUTE				(L"provider")
#define DYNAMIC_ATTRIBUTE				(L"dynamic")
#define MODULE_NAME_ATTRIBUTE			(L"module_name")
#define MODULE_IMPORTS_ATTRIBUTE		(L"module_imports")
#define GROUP_OBJECTID_ATTRIBUTE		(L"group_objectid")
#define KEY_ATTRIBUTE					(L"key")
#define KEY_ORDER_ATTRIBUTE				(L"key_order")
#define OBJECT_IDENTIFIER_ATTRIBUTE		(L"object_identifier")
#define CIMTYPE_ATTRIBUTE				(L"CIMType")
#define TEXTUAL_CONVENTION_ATTRIBUTE	(L"textual_convention")
#define DISPLAY_HINT_ATTRIBUTE			(L"display_hint")
#define ENCODING_ATTRIBUTE				(L"encoding")
#define OBJECT_SYNTAX_ATTRIBUTE			(L"object_syntax")
#define ODBC_SYNTAX_ATTRIBUTE			(L"odbc_syntax")
#define DEFVAL_ATTRIBUTE				(L"defval")
#define FIXED_LENGTH_ATTRIBUTE			(L"fixed_length")
#define VARIABLE_LENGTH_ATTRIBUTE		(L"variable_length")
#define VARIABLE_VALUE_ATTRIBUTE		(L"variable_value")
#define READ_ATTRIBUTE					(L"read")
#define WRITE_ATTRIBUTE					(L"write")
#define DESCRIPTION_ATTRIBUTE			(L"description")
#define UNITS_ATTRIBUTE					(L"units")
#define REFERENCE_ATTRIBUTE				(L"reference")
#define STATUS_ATTRIBUTE				(L"status")
#define ENUMERATION_ATTRIBUTE			(L"enumeration")
#define VIRTUAL_KEY_ATTRIBUTE			(L"virtual_key")
#define BITS_ATTRIBUTE					(L"bits")
#define SINGLETON_ATTRIBUTE				(L"singleton")


// Variant Types
#define VT_I4_TYPE					"sint32"
#define VT_UI4_TYPE					"uint32"
#define VT_NULL_TYPE				"VT_NULL"
#define VT_BSTR_TYPE				"string"
#define VT_ARRAY_OR_VT_BSTR_TYPE	"VT_BSTR"
#define VT_ARRAY_OR_VT_I4_TYPE		"VT_I4"

// Textual Convention Attribute Values
#define INTEGER_TYPE					"INTEGER"
#define OCTETSTRING_TYPE				"OCTETSTRING"
#define OBJECTIDENTIFIER_TYPE			"OBJECTIDENTIFIER"
#define NULL_TYPE						"NULL"
#define IpAddress_TYPE					"IpAddress"
#define Counter_TYPE					"Counter"
#define Gauge_TYPE						"Gauge"
#define TimeTicks_TYPE					"TimeTicks"
#define Opaque_TYPE						"Opaque"
#define NetworkAddress_TYPE				"NetworkAddress"
#define DisplayString_TYPE				"DisplayString"
#define MacAddress_TYPE					"MacAddress"
#define PhysAddress_TYPE				"PhysAddress"
#define EnumeratedINTEGER_TYPE			"EnumeratedINTEGER"
#define BITS_TYPE						"BITS"
#define Integer32_TYPE					"Integer32"
#define Unsigned32_TYPE					"Unsigned32"
#define Gauge32_TYPE					"Gauge32"
#define Counter32_TYPE					"Counter32"
#define Counter64_TYPE					"Counter64"
#define DateAndTime_TYPE				"DateAndTime"
#define SnmpUDPAddress_TYPE				"SnmpUDPAddress"
#define SnmpIPXAddress_TYPE				"SnmpIPXAddress"
#define SnmpOSIAddress_TYPE				"SnmpOSIAddress"

// Values for the PROVIDER_ATTRIBUTE
#define SNMP_INSTANCE_PROVIDER				(L"MS_SNMP_INSTANCE_PROVIDER")
#define SNMP_REFERENT_EVENT_PROVIDER		(L"MS_SNMP_REFERENT_EVENT_PROVIDER")
#define SNMP_ENCAPSULATED_EVENT_PROVIDER	(L"MS_SNMP_ENCAPSULATED_EVENT_PROVIDER")

// Notification class property/attribute names
#define DESCRIPTION_NOTIFICATION_ATTRIBUTE		(L"Description")
#define REFERENCE_NOTIFICATION_ATTRIBUTE		(L"Reference")
#define IDENTIFICATION_NOTIFICATION_PROPERTY	(L"Identification")
#define VAR_BIND_INDEX_NOTIFICATION_ATTRIBUTE	(L"VarBindIndex")

// Values for the KEY_TYPES_NOTIFICATION_ATTRIBUTE
#define INTEGER_KEY_TYPE						"INTEGER"
#define FIXED_STRING_KEY_TYPE					"FIXED_STRING"
#define VARIABLE_STRING_KEY_TYPE				"VARIABLE_STRING"
#define FIXED_OID_KEY_TYPE						"FIXED_OID"
#define VARIABLE_OID_KEY_TYPE					"VARIABLE_OID"
#define IP_ADDRESS_KEY_TYPE						"IP_ADDRESS"

// The Microsoft Copyright
#define MICROSOFT_COPYRIGHT						"// (c) 1998-2001 Microsoft Corporation.  All rights reserved."

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\bool.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef BOOL_H
#define BOOL_H

/*
 * Just typedefs BOOL to an integer, and defines values for true and false
 */

typedef int BOOL;
#ifndef FALSE
const int FALSE = 0;
const int TRUE = !FALSE;
#endif

#endif // BOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\abstractparsetree.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_ABSTRACT_PARSE_TREE_H
#define SIMC_ABSTRACT_PARSE_TREE_H

/*
 * SIMCAbstractParseTree - This class is an abstract class which has
 * functions for checking the syntax and semantics of MIBs. However, only
 * the syntax-checking functions have an implementation in this class.
 * The semantic checking functions are left as pure virtual, and is up
 * to the derived class, to define, since different applications have
 * different meanings for the Semantic validity of a MIB. All syntax errors
 * are put in an SIMCErrorContainer object, which may be retrieved for
 * processing/reporting.
 */
class SIMCAbstractParseTree
{
	protected:	
		// The place to put error messages
		SIMCErrorContainer *_errorContainer;
	
		// A count of the various kinds of errors, for each call of Parse()
		// Note that there are 3 kinds of messages (fatal, warning, information)
		long _fatalCount, _warningCount, _informationCount;

		// The parse tree
		SIMCModuleList *_listOfModules;


		// This is the flag that decides the way in which the next module
		// is syntactically checked or semantically checked.
		// That is, CheckSyntax() this flag to make decisions. A user 
		// implementing the CheckSemantics() function in a derived class
		// might also find this helpful.
		// 1 indicates conformance to SnmpV1 rules,
		// 2 indicates conformance to SnmpV2 rules,
		// 0 indicates conformance to a union of of V1 and V2 rules, as
		// long as they dont contradict each other.
		int _snmpVersion;

		// Internal representation of the state of a parse tree.
		// Used to decide what methods are allowed to be called
		enum ParseTreeState
		{
			EMPTY,
			UNRESOLVED,
			UNCHECKED,
			FINAL
		};
		ParseTreeState _parseTreeState;

		// All the things to be wrapped up at the end of CheckSyntax()
		BOOL WrapUpSyntaxCheck( const SIMCParser& parser);


	
		// Dont allow instantiation. Used only by derived classes
		// Accept an error container to put in the error messages
		SIMCAbstractParseTree(SIMCErrorContainer *errorContainer)
			:	_errorContainer(errorContainer), _parseTreeState (EMPTY),
				_listOfModules(new SIMCModuleList),
				_fatalCount(0), _warningCount(0), _informationCount(0),
				_snmpVersion(0)
		{}


		 ~SIMCAbstractParseTree();
	public:
		
		// Get the current version setting of the parse tree.
		// This may be changed in between calls to CheckSyntax(),
		// using SetSnmpVersion()
		int GetSnmpVersion() const
		{
			return _snmpVersion;
		}

		// Set the SNMP version to which the parse tree checks its
		// conformance
		BOOL SetSnmpVersion( int x )
		{
			switch(x)
			{
				case 0:		// '0' means union of v1 and v2 SMIs
				case 1:
				case 2:
					_snmpVersion = x;
					return TRUE;
				default:
					_snmpVersion = 0;
					return FALSE;
			}
		}

		// Various ways of specifying input to the parse tree
		// Caution - Only the second one (specifying the name of
		// a file) has been tested. All error messages are written on
		// to the SIMCErrorContainer object, which can be retrieved using
		// GetErrorContainer() function. The user may process the error container
		// in between calls to CheckSyntax(), to after he finishes all his
		// CheckSyntax() calls.
		virtual BOOL CheckSyntax( ifstream& inputStream);
		virtual BOOL CheckSyntax(const CString& inputStreamName);
		virtual BOOL CheckSyntax(const int fileDescriptor);
		virtual BOOL CheckSyntax(FILE *fileStream);

		// Allow obfuscated code to be written using this class
		friend BOOL operator >> (ifstream& inputStream,
			SIMCAbstractParseTree& parseTree)
		{
			return parseTree.CheckSyntax(inputStream);
		}

		// These are the pure virtual functions in this class.
		// These are together used to check the semantics of the
		// MIB module(s).
		// Resolve() is called to set all the external references (IMPORTS)
		// in all the input modules, using their definitions in other input
		// modules, and also to set all forward references to a symbol. 
		// An "input module" is one that has been "entered" into
		// the  parse tree, using a successful call to CheckSyntax().
		// Once resolution has been done successfully, CheckSemantics() should
		// be called to check if the modules conform to the rules the user
		// wishes to impose. The user gets the modules (SIMCModule objects)
		// in the parse tree using GetModule(), GetModuleOfFile() or GetListOfModules(),
		// And goes through each symbol (SIMCSymbol object) in the symbol 
		// table of each module, He uses RTTI to determine the class of the 
		// symbol (ie., which derived class of SIMCSymbol, the object is really
		// an instance of), and checks to see if that object is valid.
		// In both these cases, the boolean argument indicates whether the
		// the resolution/checking should be done without the definitions
		// of IMPORTED symbols, or with them. A true value implies a local
		// check, without resolution of IMPORT symbols
		virtual BOOL Resolve(BOOL local) = 0;
		virtual BOOL CheckSemantics(BOOL local) = 0;

		// Returns the error container
		const SIMCErrorContainer* GetErrorContainer() const
		{
			return _errorContainer;
		}

		// This should not be typically called by a user
		ParseTreeState GetParseTreeState() const
		{
			return _parseTreeState;
		}

		// # of all the messages generated till now
		long GetCurrentDiagnosticCount() const
		{
			return _errorContainer->NumberOfMessages();
		}

		// # of each king of message, generated till now.
		long GetFatalCount() const
		{
			return _fatalCount;
		}
		long GetWarningCount() const
		{
			return _warningCount;
		}
		long GetInformationCount() const
		{
			return _informationCount;
		}


		// Retreiving the parse tree information for a module ,
		// by specifying the module name
		SIMCModule * GetModule(const char *const moduleName)
			const;
		
		// Retreiving the parse tree information for a module ,
		// by specifying the input file name, that was used
		SIMCModule * GetModuleOfFile(const char *const fileName)
			const;

		// Get the parse tree information for all the modules
		const SIMCModuleList *GetListOfModules() const
		{
			return _listOfModules;
		}

		// For debugging
		void WriteTree(ostream& outStream) const;
		friend ostream& operator<< (ostream& out, const SIMCAbstractParseTree& r)
		{
			r.WriteTree(out);
			return out;
		}

};

#endif // SIMC_ABSTRACT_PARSE_TREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\errorcontainer.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_ERROR_MESSAGE_CONTAINER_H
#define SIMC_ERROR_MESSAGE_CONTAINER_H

/*
 * This is basically a linked list of SIMCErrorMessage
 * objects
 */
class SIMCErrorContainer
{
	// A linked list of objects of class SIMCErrorMessage
	// And a pointer to the current position in the list
	CList<SIMCErrorMessage, const SIMCErrorMessage&> _listOfMessages;
	POSITION _currentMessage;

	public:
		// Construct an empty error container
		SIMCErrorContainer();

		// Insert a message at the head of the container
		BOOL InsertMessage(const SIMCErrorMessage& newMessage);

		// Empty the container
		void RemoveAll()
		{
			_listOfMessages.RemoveAll();
		}

		//  Get a count of the number of messages in the container
		inline int NumberOfMessages() const
		{
			return _listOfMessages.GetCount();
		}

		// Functions to iterate the container
		void MoveToFirstMessage();
		BOOL GetNextMessage(SIMCErrorMessage& nextMessage);

		// Debugging functions
		friend ostream& operator << ( ostream& outStream, 
			SIMCErrorContainer&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\infolex.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef ModuleInfo_state_t
#define ModuleInfo_state_t unsigned char
#endif
#define YYNEWLINE 10

// MKS LEX prototype scanner header
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can define YY_PRESERVE to get System V UNIX lex compatibility,
//	if you need to change ModuleInfotext[] in your user actions
// This is quite a bit slower, though, so the default is without

#include <stdio.h>		// uses printf(), et cetera
#include <stdarg.h>		// uses va_list
#include <stdlib.h>		// uses exit()
#include <string.h>		// uses memmove()

#ifdef LEX_WINDOWS

// define, if not already defined
// the flag YYEXIT, which will allow
// graceful exits from ModuleInfolex()
// without resorting to calling exit();

#ifndef YYEXIT
#define YYEXIT	1
#endif // YYEXIT

// include the windows specific prototypes, macros, etc

#include <windows.h>

// the following is the handle to the current
// instance of a windows program. The user
// program calling ModuleInfolex must supply this!

extern HANDLE hInst;	

#endif /* LEX_WINDOWS */

class ModuleInfo_scan {
protected:

#ifdef LEX_WINDOWS

	// protected member function for actual scanning 

	int win_ModuleInfolex();

#endif /* LEX_WINDOWS */

	ModuleInfo_state_t * state;		// state buffer
	int	size;			// length of state buffer
	int	mustfree;		// set if space is allocated
	int	ModuleInfo_end;			// end of pushback
	int	ModuleInfo_start;		// start state
	int	ModuleInfo_lastc;		// previous char
#ifdef YYEXIT
	int ModuleInfoLexFatal;		// Lex Fatal Error Flag
#endif // YYEXIT
#ifndef YY_PRESERVE	// efficient default push-back scheme
	char save;		// saved ModuleInfotext[ModuleInfoleng]
#else			// slower push-back for ModuleInfotext mungers
	char *save;		// saved ModuleInfotext[]
	char *push;
#endif

public:
	char   *ModuleInfotext;		// ModuleInfotext text buffer
	FILE   *ModuleInfoin;			// input stream
	FILE   *ModuleInfoout;			// output stream
	int	ModuleInfolineno;		// line number
	int	ModuleInfoleng;			// ModuleInfotext token length

	ModuleInfo_scan(int = 100);	// constructor for this scanner
			// default token & pushback size is 100 bytes
	ModuleInfo_scan(int, char*, char*, ModuleInfo_state_t*);
				// constructor when tables are given

	~ModuleInfo_scan();		// destructor

	int	ModuleInfolex();		// begin a scan

	virtual int	ModuleInfogetc() {	// scanner source of input characters
		return getc(ModuleInfoin);
	}

	virtual int	ModuleInfowrap() { return 1; }	// EOF processing

	virtual void	ModuleInfoerror(char *,...);	// print error message

	virtual void	output(int c) { putc(c, ModuleInfoout); }

#ifdef YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and set error flag
		ModuleInfoerror(msg); ModuleInfoLexFatal = 1;
	}
#else // YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and stop
		ModuleInfoerror(msg); exit(1);
	}
#endif // YYEXIT
	virtual void	ECHO() {		// print matched input
		fputs((const char *) ModuleInfotext, ModuleInfoout);
	}
	int	input();		// user-callable get-input
	int	unput(int c);		// user-callable unput character
	void	ModuleInfo_reset();		// reset scanner
	void	setinput(FILE * in) {		// switch input streams
		ModuleInfoin = in;
	}
	void	setoutput(FILE * out) {	// switch output
		ModuleInfoout = out;
	}
	void	NLSTATE() { ModuleInfo_lastc = YYNEWLINE; }
	void	YY_INIT() {
		ModuleInfo_start = 0;
		ModuleInfoleng = ModuleInfo_end = 0;
		ModuleInfo_lastc = YYNEWLINE;
	}
	void	YY_USER() {		// set up ModuleInfotext for user
#ifndef YY_PRESERVE
		save = ModuleInfotext[ModuleInfoleng];
#else
		size_t n = ModuleInfo_end - ModuleInfoleng;
		push = save+size - n;
		if (n > 0)
			memmove(push, ModuleInfotext+ModuleInfoleng, n);
#endif
		ModuleInfotext[ModuleInfoleng] = 0;
	}
	void YY_SCANNER() {		// set up ModuleInfotext for scanner
#ifndef YY_PRESERVE
		ModuleInfotext[ModuleInfoleng] = save;
#else
		size_t n = save+size - push;
		if (n > 0)
			memmove(ModuleInfotext+ModuleInfoleng, push, n);
		ModuleInfo_end = ModuleInfoleng + n;
#endif
	}
	void	ModuleInfoless(int n) {		// trim input to 'n' bytes
		if (n >= 0 && n <= ModuleInfo_end) {
			YY_SCANNER();
			ModuleInfoleng = n;
			YY_USER();
		}
	}
	void	ModuleInfocomment(char *const mat); // skip comment input
	int	ModuleInfomapch(int delim, int escape);	// map C escapes
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\lex_yy.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef yy_state_t
#define yy_state_t unsigned char
#endif
#define YYNEWLINE 10

// MKS LEX prototype scanner header
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can define YY_PRESERVE to get System V UNIX lex compatibility,
//	if you need to change yytext[] in your user actions
// This is quite a bit slower, though, so the default is without

#include <stdio.h>		// uses printf(), et cetera
#include <stdarg.h>		// uses va_list
#include <stdlib.h>		// uses exit()
#include <string.h>		// uses memmove()

#ifdef LEX_WINDOWS

// define, if not already defined
// the flag YYEXIT, which will allow
// graceful exits from yylex()
// without resorting to calling exit();

#ifndef YYEXIT
#define YYEXIT	1
#endif // YYEXIT

// include the windows specific prototypes, macros, etc

#include <windows.h>

// the following is the handle to the current
// instance of a windows program. The user
// program calling yylex must supply this!

extern HANDLE hInst;	

#endif /* LEX_WINDOWS */

class yy_scan {
protected:

#ifdef LEX_WINDOWS

	// protected member function for actual scanning 

	int win_yylex();

#endif /* LEX_WINDOWS */

	yy_state_t * state;		// state buffer
	int	size;			// length of state buffer
	int	mustfree;		// set if space is allocated
	int	yy_end;			// end of pushback
	int	yy_start;		// start state
	int	yy_lastc;		// previous char
#ifdef YYEXIT
	int yyLexFatal;		// Lex Fatal Error Flag
#endif // YYEXIT
#ifndef YY_PRESERVE	// efficient default push-back scheme
	char save;		// saved yytext[yyleng]
#else			// slower push-back for yytext mungers
	char *save;		// saved yytext[]
	char *push;
#endif

public:
	char   *yytext;		// yytext text buffer
	FILE   *yyin;			// input stream
	FILE   *yyout;			// output stream
	int	yylineno;		// line number
	int	yyleng;			// yytext token length

	yy_scan(int = 100);	// constructor for this scanner
			// default token & pushback size is 100 bytes
	yy_scan(int, char*, char*, yy_state_t*);
				// constructor when tables are given

	~yy_scan();		// destructor

	int	yylex();		// begin a scan

	virtual int	yygetc() {	// scanner source of input characters
		return getc(yyin);
	}

	virtual int	yywrap() { return 1; }	// EOF processing

	virtual void	yyerror(char *,...);	// print error message

	virtual void	output(int c) { putc(c, yyout); }

#ifdef YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and set error flag
		yyerror(msg); yyLexFatal = 1;
	}
#else // YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and stop
		yyerror(msg); exit(1);
	}
#endif // YYEXIT
	virtual void	ECHO() {		// print matched input
		fputs((const char *) yytext, yyout);
	}
	int	input();		// user-callable get-input
	int	unput(int c);		// user-callable unput character
	void	yy_reset();		// reset scanner
	void	setinput(FILE * in) {		// switch input streams
		yyin = in;
	}
	void	setoutput(FILE * out) {	// switch output
		yyout = out;
	}
	void	NLSTATE() { yy_lastc = YYNEWLINE; }
	void	YY_INIT() {
		yy_start = 0;
		yyleng = yy_end = 0;
		yy_lastc = YYNEWLINE;
	}
	void	YY_USER() {		// set up yytext for user
#ifndef YY_PRESERVE
		save = yytext[yyleng];
#else
		size_t n = yy_end - yyleng;
		push = save+size - n;
		if (n > 0)
			memmove(push, yytext+yyleng, n);
#endif
		yytext[yyleng] = 0;
	}
	void YY_SCANNER() {		// set up yytext for scanner
#ifndef YY_PRESERVE
		yytext[yyleng] = save;
#else
		size_t n = save+size - push;
		if (n > 0)
			memmove(yytext+yyleng, push, n);
		yy_end = yyleng + n;
#endif
	}
	void	yyless(int n) {		// trim input to 'n' bytes
		if (n >= 0 && n <= yy_end) {
			YY_SCANNER();
			yyleng = n;
			YY_USER();
		}
	}
	void	yycomment(char *const mat); // skip comment input
	int	yymapch(int delim, int escape);	// map C escapes
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\group.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_GROUP_H
#define SIMC_GROUP_H

/*
 * This file contains the SIMCScalar, SIMCTable and SIMCObjectGroup classes
 * Please read the "compiler requirements specification" for definitions of 
 * "object group", "named node" etc., since object groups are fabricated 
 * for MIB modules (both V1 and V2) as per the rules in that document.
 *
 */


/*
 * This is a scalar MIB object.
 */
class SIMCScalar
{
		// A pointer to the symbol in a module, that represents this
		// object
		SIMCSymbol *symbol;
		// The "clean" oid value of this scalar object. Note that
		// and "unclean" value may be obtained by  calling the
		// function SIMCModule.IsObjectIdentifierValue(), on the module
		// that defined this symbol.
		SIMCCleanOidValue *value;

	public:
		SIMCScalar(SIMCSymbol *s, SIMCCleanOidValue *v)
			: symbol(s), value(v)
		{}
	
		SIMCScalar()
			: symbol(NULL), value(NULL)
		{}

		~SIMCScalar()
		{
			if(value)
				delete value;
		}

		friend ostream& operator << (ostream& outStream, const SIMCScalar& obj);

		SIMCSymbol *GetSymbol() const
		{
			return symbol;
		}

		void SetSymbol(SIMCSymbol *s) 
		{
			symbol = s;
		}

		SIMCCleanOidValue *GetOidValue() const
		{
			return value;
		}
		void SetOidValue(SIMCCleanOidValue *v) 
		{
			value = v;
		}
};

typedef CList<SIMCScalar *,SIMCScalar *> SIMCScalarMembers;


/*
 * This class represents a MIB table object
 */
class SIMCTable
{
		// A pointer to a symbol that represents this MIB object in a module
		// Example :  ifTable
		SIMCSymbol *tableSymbol;
		// ... and its clean OID value
		SIMCCleanOidValue *tableValue;

		// The symbol or object that represents the row of the table
		// Example : ifEntry
		SIMCSymbol *rowSymbol;
		// ... and its clean OID value
		SIMCCleanOidValue *rowValue;

		// A list of the columns of the table
		SIMCScalarMembers *columnMembers;

		SIMCTable *augmentedTable; // If any, in SNMPv2 SMI
	
	public:
		SIMCTable(SIMCSymbol *ts, SIMCCleanOidValue *tv, SIMCSymbol *rs, SIMCCleanOidValue *rv,
					SIMCScalarMembers *cm)
			: tableSymbol(ts), tableValue(tv), rowSymbol(rs), rowValue(rv), columnMembers(cm),
				augmentedTable(NULL)
		{}
	
		SIMCTable()
			: tableSymbol(NULL), tableValue(NULL), rowSymbol(NULL), 
				rowValue(NULL), columnMembers(NULL), augmentedTable(NULL)
		{}

		~SIMCTable()
		{
			if(tableValue)
				delete tableValue;
			if(rowValue)
				delete rowValue;
		
			if(columnMembers)
			{
				SIMCScalar *nextScalar;
				while(!columnMembers->IsEmpty() )
				{
					nextScalar = columnMembers->RemoveHead();
					delete nextScalar;
				}
				delete columnMembers;
			}
		}



		friend ostream& operator << (ostream& outStream, const SIMCTable& obj);
	
		SIMCSymbol *GetTableSymbol() const
		{
			return tableSymbol;
		}

		void SetTableSymbol(SIMCSymbol *ts) 
		{
			tableSymbol = ts;
		}

		SIMCCleanOidValue *GetTableOidValue() const
		{
			return tableValue;
		}

		void SetTableOidValue(SIMCCleanOidValue *tv) 
		{
			tableValue = tv;
		}

		SIMCSymbol *GetRowSymbol() const
		{
			return rowSymbol;
		}

		void SetRowSymbol(SIMCSymbol *rs) 
		{
			rowSymbol = rs;
		}

		SIMCCleanOidValue *GetRowOidValue() const
		{
			return rowValue;
		}

		void SetRowOidValue(SIMCCleanOidValue *rv) 
		{
			rowValue = rv;
		}

		SIMCScalarMembers *GetColumnMembers() const
		{
			return columnMembers;
		}

		SIMCScalar *GetColumnMember(SIMCSymbol *columnSymbol) const;

		void AddColumnMember(SIMCScalar *cm) 
		{
			if(!columnMembers)
				columnMembers = new SIMCScalarMembers;
			columnMembers->AddTail(cm);
		}
		
		BOOL IsColumnMember(const SIMCSymbol *symbol) const;

		long GetColumnCount() const
		{
			if(columnMembers)
				return columnMembers->GetCount();
			else
				return 0;
		}
		
		SIMCTable *GetAugmentedTable() const
		{
			return augmentedTable;
		}

		void SetAugmentedTable(SIMCTable *ts) 
		{
			augmentedTable = ts;
		}

		const char * const GetTableDescription() const;
		const char * const GetRowDescription() const;
};

typedef CList<SIMCTable *, SIMCTable *> SIMCTableMembers;


// For generating a name for the object group, in case of the V1 SMI
#define OBJ_GROUP_FABRICATION_SUFFIX "V1ObjectGroup"
#define OBJ_GROUP_FABRICATION_SUFFIX_LEN  13


// And finally the object group itself. Please read the "compiler requirements
// specification" for a definitions of "object group", "named node" etc.
class SIMCObjectGroup
{
	public:
		enum ObjectGroupStatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_CURRENT,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	private:
		// Various clauses of the object group
		char *objectGroupName;	
		char *description;
		char *reference;
		SIMCSymbol *namedNode;
		SIMCCleanOidValue *namedNodeValue;
		SIMCScalarMembers *scalars;
		SIMCTableMembers *tables;
		ObjectGroupStatusType status;
		static const char * const StatusStringsTable[3];
		
	public:
		SIMCObjectGroup(SIMCSymbol *n, SIMCCleanOidValue *nv,  SIMCScalarMembers *sm, SIMCTableMembers *tm, 
					ObjectGroupStatusType s, const char * descriptionV, const char *referenceV)
			: namedNode(n), namedNodeValue(nv), scalars(sm), tables(tm), status(s)
		{
			objectGroupName = NewString(strlen(n->GetSymbolName()) + 
									OBJ_GROUP_FABRICATION_SUFFIX_LEN + 1);
			strcpy(objectGroupName, n->GetSymbolName());
			strcat(objectGroupName, OBJ_GROUP_FABRICATION_SUFFIX);

			description = NewString(descriptionV);
			reference = NewString(referenceV);
		}
		
		SIMCObjectGroup()
			: namedNode(NULL), namedNodeValue(NULL), scalars(NULL), tables(NULL), 
				status(STATUS_CURRENT), objectGroupName(NULL), description(NULL),
				reference(NULL)
		{}

		
		~SIMCObjectGroup()
		{
			if(objectGroupName)
				delete [] objectGroupName;
			if(description)
				delete [] description;
			if(reference)
				delete [] reference;

			if(scalars)
			{
				SIMCScalar *nextScalar;
				while(!scalars->IsEmpty() )
				{
					nextScalar = scalars->RemoveHead();
					delete nextScalar;
				}
				delete scalars;
			}

			if(tables)
			{
				SIMCTable *nextTable;
				while(!tables->IsEmpty() )
				{
					nextTable = tables->RemoveHead();
					delete nextTable;
				}
				delete tables;
			}

			if(namedNodeValue) delete namedNodeValue;


		}

		friend ostream& operator << (ostream& outStream, const SIMCObjectGroup& obj);
	
		SIMCSymbol *GetNamedNode() const
		{
			return namedNode;
		}
		
		void SetNamedNode(SIMCSymbol *nn) 
		{
			namedNode = nn;
			if(objectGroupName)
				delete [] objectGroupName;
			objectGroupName = NewString(strlen(nn->GetSymbolName()) + 
									OBJ_GROUP_FABRICATION_SUFFIX_LEN + 1);
			strcpy(objectGroupName, nn->GetSymbolName());
			strcat(objectGroupName, OBJ_GROUP_FABRICATION_SUFFIX);
		}
		
		const char * const GetObjectGroupName() const
		{
			return objectGroupName;
		}

		const char * const GetDescription() const
		{
			return description;
		}

		void SetDescription(const char * const descriptionV)
		{
			if(description)
				delete [] description;
			description = NewString(descriptionV);
		}

		const char * const GetReference() const
		{
			return reference;
		}

		void SetReference(const char * const referenceV)
		{
			if(reference)
				delete [] reference;
			reference = NewString(referenceV);
		}

		SIMCCleanOidValue *GetGroupValue() const
		{
			return namedNodeValue;
		}

		void SetGroupValue(SIMCCleanOidValue *val) 
		{
			namedNodeValue = val;
		}

		SIMCScalarMembers *GetScalarMembers() const
		{
			return scalars;
		}

		void AddScalar(SIMCScalar *s) 
		{
			if(!scalars)
				scalars = new SIMCScalarMembers;
			scalars->AddTail(s);
		}

		long GetScalarCount() const
		{
			if(scalars)
				return scalars->GetCount();
			else
				return 0;
		}

		SIMCTableMembers *GetTableMembers() const
		{
			return tables;
		}
	
		void AddTable(SIMCTable *t) 
		{
			if(!tables)
				tables = new SIMCTableMembers;
			tables->AddTail(t);
		}

		long GetTableCount() const
		{
			if(tables)
				return tables->GetCount();
			else
				return 0;
		}

	
		ObjectGroupStatusType GetStatus() const
		{
			return status;
		}

		void SetStatus(ObjectGroupStatusType s)
		{
			status = s;
		}	

		const char * const GetStatusString() const
		{
			switch(status)
			{
				case STATUS_CURRENT:
					return 	StatusStringsTable[STATUS_CURRENT-1];
				case STATUS_DEPRECATED:
					return 	StatusStringsTable[STATUS_DEPRECATED-1];
				case STATUS_OBSOLETE:
					return 	StatusStringsTable[STATUS_OBSOLETE-1];
				default:
					return NULL;
			}
			return NULL;
		}

		SIMCScalar *GetScalar(SIMCSymbol *objectSymbol) const;
		SIMCTable *GetTable(SIMCSymbol *objectSymbol) const;
		BOOL ObjectsInModule(const SIMCModule *theModule) const;
};

#ifndef SIMC_GROUP_LIST
#define SIMC_GROUP_LIST
typedef CList<SIMCObjectGroup *, SIMCObjectGroup*> SIMCGroupList;
ostream& operator << (ostream& outStream, const SIMCGroupList& obj);
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\newstring.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef NEW_STRING_H
#define NEW_STRING_H

// Return a new string with the same contents as the argument
char *NewString (const char * const s);
// Return a new uninitialized string of the specified length
char *NewString(const int len);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\moduleinfo.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_MODULE_INFO
#define SIMC_MODULE_INFO

/*
 * This file contains the SIMCModuleInfoScanner and SIMCModuleInfoParser 
 * classes, which are light-weight scanners and parsers of a module, 
 * as opposed to the heavy-weights SIMCScanner and SIMCParser.
 * The difference is that the latter are compler scanners and parsers
 * of SNMP modules, while the former just parse a module enough to
 * get the module name, and the information in the IMPORT section
 */

typedef CList<CString, CString&> SIMCStringList;

// The light-weight scanner. This is derived from the ModuleInfo_scan 
// that is generated by the MKS LEX utility, from the information in 
// the file infoLex.l 
class SIMCModuleInfoScanner : public ModuleInfo_scan
{
	public:
		virtual void ModuleInfoerror(char *,...)	
		{}
		virtual void output(int x)
		{}
};

// The light-weight parser. This is derived from the ModuleInfo_parse 
// that is generated by the MKS YACC utility, from the information in 
// the file infoYacc.y. This parser uses the above scanner 

class SIMCModuleInfoParser  : public ModuleInfo_parse
{
		CString moduleName;
		SIMCStringList 	importModules;

	public:

		// Parse the module. Once this function is called, the other
		// functions make sense.
		BOOL GetModuleInfo(SIMCModuleInfoScanner *infoScanner);

		const SIMCStringList * GetImportModuleList() const
		{
			return &importModules;
		}
		void AddImportModule(CString name)
		{
			importModules.AddTail(name);
		}
		CString GetModuleName() const
		{
			return moduleName;
		}
		void SetModuleName(const CString& name) 
		{
			moduleName = name;
		}

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\module.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef SIMC_MODULE_H
#define SIMC_MODULE_H

/* This file contains the SIMCModule class, which basically
 * represents the parse tree for a single module.
 */


// Return value for many of the symbol-table methods. 
#define NOT_FOUND   0
#define AMBIGUOUS   1
#define UNAMBIGUOUS 2


class SIMCSymbol;
class SIMCType;
class SIMCSubType;
class SIMCEnumOrBitsType;
class SIMCValue;
class SIMCOidValue;
class SIMCOctetStringValue;
class SIMCDefinedTypeReference;
class SIMCDefinedValueReference;
class SIMCBuiltInTypeReference;
class SIMCBuiltInValueReference;
class SIMCObjectTypeType;
class SIMCObjectTypeV1;
class SIMCObjectTypeV2;
class SIMCObjectIdentityType;
class SIMCObjectGroup;
class SIMCOidTree;
class SIMCParseTree;

// Some typedefs
#ifndef SIMC_GROUP_LIST
#define SIMC_GROUP_LIST
typedef CList<SIMCObjectGroup *, SIMCObjectGroup*> SIMCGroupList;
ostream& operator << (ostream& outStream, const SIMCGroupList& obj);
#endif
typedef CList<SIMCModule *, SIMCModule *> SIMCModuleList;
typedef CList<CString, const CString&> SIMCModuleNameList;
typedef CMap <CString, LPCSTR, SIMCSymbol **, SIMCSymbol**> 
						SIMCSymbolTable;	


/* Each element in the list of revision clauses
 * in the MODULE-IDENTITY macro
 */
class SIMCRevisionElement
{
		char *_revision, *_description;

	public:
		SIMCRevisionElement( const char * revision, const char * description)
		{
			if(revision)
			   _revision = NewString(revision);
			else 
				_revision = NULL;
			if(description)
			   _description = NewString(description);
			else 
				_description = NULL;
		}

		~SIMCRevisionElement()
		{
			if(_revision)
				delete _revision;
			if(_description)
				delete _description;
		}

		const char * GetRevision() const
		{
			return _revision;
		}
		const char * GetDescription() const
		{
			return _description;
		}
};

// A list of revision clauses
typedef CList<SIMCRevisionElement *, SIMCRevisionElement *> SIMCRevisionList;

/* 
 * This class represents the parse tree information that results from the
 * parsing of a single MIB module. It basically contains.
 *
 *	1. A symbol table, for all the symbols in the module
 *	2. The values of various MODULE-IDENTITY clauses.  These are
 *		fabricated, if the MODULE-IDENTITY clause is absent in the module
 *	3. A list of object groups that are fabricated for this module, as per
 *		the rules in the "compiler requirements specification"
 */
class SIMCModule : public SIMCSymbol
{
		// The version of this module
		// 1 - SNMPv2 SMI
		// 2 - SNMPv2 SMI
		// 0 - Union of V1 and V2 SMIs
		int _snmpVersion;

		// The items from the MODULE-IDENTITY macro
		char * _lastUpdated;
		char * _organization;
		char * _contactInfo;
		char * _moduleIdentityName;
		char * _description;
		SIMCRevisionList _revisionList;
		SIMCCleanOidValue * _moduleIdentityValue;
		
		// This is null if it is the main input module, otherwise it points 
		// to the module that imported this module
		SIMCModule * _parentModule;

		// The names of the modules in the IMPORTS clause
		SIMCModuleNameList _namesOfImportModules;
		// The actual import modules
		SIMCModuleList *_listOfImportModules;

		// The Symbol table
		SIMCSymbolTable	*_symbolTable;

		// A value for the hash table (CMap) object that optimizes
		// its working
		static const int SYMBOLS_PER_MODULE;

		// The fabricated list OBJECT-GROUPS
		SIMCGroupList *_listOfObjectGroups;

		// All the NOTIFICATION-TYPEs in the module
		SIMCNotificationList *_listOfNotificationTypes;

		// Name of the file from which this was constructed
		char *_inputFileName;


	public:

		// Used in RTTIing a SIMCSymbol pointer
		enum SymbolClass
		{ 
			SYMBOL_INVALID,
			SYMBOL_UNKNOWN,
			SYMBOL_IMPORT,
			SYMBOL_MODULE,
			SYMBOL_BUILTIN_TYPE_REF,
			SYMBOL_DEFINED_TYPE_REF,
			SYMBOL_TEXTUAL_CONVENTION,
			SYMBOL_BUILTIN_VALUE_REF,
			SYMBOL_DEFINED_VALUE_REF
		};

		// Used in RTTIing a SIMCType pointer
		enum TypeClass 
		{
			TYPE_INVALID,
			TYPE_PRIMITIVE,
			TYPE_RANGE,
			TYPE_SIZE,
			TYPE_ENUM_OR_BITS,
			TYPE_SEQUENCE_OF,
			TYPE_SEQUENCE,
			TYPE_TRAP_TYPE,
			TYPE_NOTIFICATION_TYPE,
			TYPE_OBJECT_TYPE_V1,
			TYPE_OBJECT_TYPE_V2,
			TYPE_OBJECT_IDENTITY
		};

		// Used in RTTIing a SIMCValue pointer
		enum ValueClass 
		{
			VALUE_INVALID,
			VALUE_INTEGER,
			VALUE_OID,
			VALUE_OCTET_STRING,
			VALUE_BOOLEAN,
			VALUE_BITS,
			VALUE_NULL
		};

		enum PrimitiveType
		{
			PRIMITIVE_INVALID,
			PRIMITIVE_INTEGER,
			PRIMITIVE_OID,
			PRIMITIVE_OCTET_STRING,
			PRIMITIVE_BOOLEAN,
			PRIMITIVE_BITS,
			PRIMITIVE_NULL,
			PRIMITIVE_NETWORK_ADDRESS,
			PRIMITIVE_IP_ADDRESS,
			PRIMITIVE_COUNTER,
			PRIMITIVE_GAUGE,
			PRIMITIVE_TIME_TICKS,
			PRIMITIVE_OPAQUE,
			PRIMITIVE_DISPLAY_STRING,
			PRIMITIVE_PHYS_ADDRESS,
			PRIMITIVE_MAC_ADDRESS,

			PRIMITIVE_INTEGER_32,
			PRIMITIVE_COUNTER_32,
			PRIMITIVE_GAUGE_32,
			PRIMITIVE_COUNTER_64,
			PRIMITIVE_UNSIGNED_32,
			PRIMITIVE_DATE_AND_TIME,
			PRIMITIVE_SNMP_UDP_ADDRESS,
			PRIMITIVE_SNMP_OSI_ADDRESS,
			PRIMITIVE_SNMP_IPX_ADDRESS
		};


		SIMCModule(const char *const moduleName = NULL,
			const char * const inputFileName = NULL,
			SIMCSymbolTable *symbolTable = NULL,			
			SIMCModuleList *listOfImportModules = NULL,
			SIMCModule *parentModule = NULL,
			int snmpVersion = 0,
			long lineNumber = 0, long columnNumber = 0,
			long referenceCount = 0);

		virtual ~SIMCModule();

		// Manipulate the SNMP version of the module
		int GetSnmpVersion() const
		{
			return _snmpVersion;
		}
		BOOL SetSnmpVersion( int x )
		{
			switch(x)
			{
				case 0:		// '0' means union of v1 and v2 SMIs
				case 1:
				case 2:
					_snmpVersion = x;
					return TRUE;
				default:
					_snmpVersion = 0;
					return FALSE;
			}
		}

		// Manipulate the name of this module
		const char * GetModuleName() const
		{	
			return GetSymbolName();
		}
		void SetModuleName(const char * const s) 
		{
			SetSymbolName(s);
		}

		// Manipulate the input file name of this module
		const char * GetInputFileName() const
		{	
			return _inputFileName;
		}
		void SetInputFileName(const char * const s) 
		{
			if(_inputFileName)
				delete []_inputFileName;
			_inputFileName = NewString(s);
		}

		// Manipulate the MODULE-IDENTITY clauses
		const char * GetLastUpdated() const
		{	
			return _lastUpdated;
		}
		void SetLastUpdated(const char * const s) 
		{
			if(_lastUpdated)
				delete [] _lastUpdated;
			_lastUpdated = NewString(s);
		}

		const char * GetOrganization() const
		{	
			return _organization;
		}
		void SetOrganization(const char * const s) 
		{
			if(_organization)
				delete [] _organization;
			_organization = NewString(s);
		}

		const char * GetContactInfo() const
		{	
			return _contactInfo;
		}
		void SetContactInfo(const char * const s) 
		{
			if(_contactInfo)
				delete [] _contactInfo;
			_contactInfo = NewString(s);
		}

		const char * GetDescription() const
		{	
			return _description;
		}
		void SetDescription(const char * const s) 
		{
			if(_description)
				delete [] _description;
			_description = NewString(s);
		}

		void AddRevisionClause(SIMCRevisionElement *revisionElement)
		{
			_revisionList.AddTail(revisionElement);
		}

		const SIMCRevisionList * GetRevisionList() const
		{
			return &_revisionList;
		}

		const char * GetModuleIdentityName() const
		{	
			return _moduleIdentityName;
		}
		void SetModuleIdentityName(const char * const s) 
		{
			if(_moduleIdentityName)
				delete [] _moduleIdentityName;
			_moduleIdentityName = NewString(s);
		}

		void SetModuleIdentityValue(SIMCCleanOidValue * value)
		{
			if(_moduleIdentityValue)
				delete _moduleIdentityValue;
			_moduleIdentityValue = value;
		}
		BOOL GetModuleIdentityValue( SIMCCleanOidValue& retVal) const
		{
			if( _moduleIdentityValue )
			{
				CleanOidValueCopy(retVal, *_moduleIdentityValue);
				return TRUE;
			}
			else
				return FALSE;
		}


		// Get the whole symbol table itself. Very rarely used
		SIMCSymbolTable* GetSymbolTable()  const
		{
			return _symbolTable;
		}

		// Get the list of import modules
		SIMCModuleList *GetListOfImportModules() const
		{
			return _listOfImportModules;
		}
		// Get the names of the import modules
		const SIMCModuleNameList* GetImportModuleNameList() const
		{
			return &_namesOfImportModules;
		}

		// If this module is created just because it appears in the
		// IMPORT clause of a parent module, then a pointer to the parent
		// module is returned. This has to be set by the user, of course
		const SIMCModule* GetParentModule() const
		{
			return _parentModule;
		}
		void SetParentModule( SIMCModule *parentModule);

		// Manipulate the list of import modules of this module
		void AddImportModule( SIMCModule * newModule);
		BOOL RemoveImportModule(SIMCModule *module);
		// This just adds to _namesOfImportModules
		void AddImportModuleName(const SIMCModule *newModule)
		{
			_namesOfImportModules.AddTail(newModule->GetModuleName());
		}
		SIMCModule *GetImportModule(const char * const name) const;
		
		// Manipulate the list of object groups of this module
		void AddObjectGroup(SIMCObjectGroup *group);
		// Gets the object group whose name is the speciified name
		SIMCObjectGroup *GetObjectGroup(const char * const name) const;
		SIMCGroupList *GetObjectGroupList() const
		{
			return _listOfObjectGroups;
		}
		// Returns the object group in which this symbol is present
		SIMCObjectGroup *GetObjectGroup(SIMCSymbol *symbol) const;

		// Manipulate the list of NOTIFICATION-TYPES in this module
		SIMCNotificationList *GetNotificationTypeList() const
		{
			return _listOfNotificationTypes;
		}


		// A debugging function
		virtual void WriteSymbol(ostream& outStream) const;

		//-------------SYMBOL TABLE RELATED METHODS ----------------------
		SIMCSymbol ** GetSymbol(  const char * const symbolName) const;
		int GetImportedSymbol( const char * const symbolName, SIMCSymbol ** &retVal1,
			 SIMCSymbol ** &retVal2) const;
		BOOL AddSymbol(SIMCSymbol * );
		BOOL RemoveSymbol(const char * const symbolName);
		BOOL RemoveSymbol(SIMCSymbol **);
		BOOL ReplaceSymbol(const char *const symbolName, SIMCSymbol *newSymbol);


		//------------ RTTI methods(static)------------------------------------
		static SymbolClass GetSymbolClass(SIMCSymbol **spp);
		static TypeClass GetTypeClass(SIMCType *t);
		static ValueClass GetValueClass(SIMCValue *v);
		
		//-------------- Methods used in semantic checking and resolution -----
		// These set the state of each symbol to one ofenum SIMCResolutionStatus
		// RESOLVE_UNSET,		// Haven't resolved it yet
		// RESOLVE_UNDEFINED,	// Could not resolve it
		// RESOLVE_IMPORT,		// Resolved to IMPORTS
		// RESOLVE_CORRECT		// Resolved properly
		// as defined in enum SIMCResolutionStatus, of SIMCSymbol
		BOOL SetResolutionStatus();
		static SIMCResolutionStatus SetResolutionStatus(SIMCSymbol **symbol);
		static SIMCResolutionStatus SetResolutionStatus(SIMCDefinedTypeReference * orig);
		static SIMCResolutionStatus SetResolutionStatus(SIMCDefinedValueReference *orig);

	private:
		// These are the recursive routines called by the above 2 methods
		static SIMCResolutionStatus SetResolutionStatusRec(SIMCDefinedTypeReference * orig,
											SIMCDefinedTypeReferenceList& checkedList);
		static SIMCResolutionStatus SetResolutionStatusRec(SIMCDefinedValueReference *orig,
											SIMCDefinedValueReferenceList& checkedList);
	
	public:
		// This sets the type that is the root of a subtype (range and size
		// constructs) or an ENUM or BITS type, and also the root value of a symbol that results from
		// successive assignment statements
		BOOL SetRootAll();
		static SIMCResolutionStatus SetRootSymbol(SIMCSymbol **symbol);
		static SIMCResolutionStatus SetRootSubType(SIMCSubType *s);

	private:
		static SIMCResolutionStatus SetRootSubTypeRec(SIMCSubType *s,
											SIMCSubTypeList& checkedList);
		static SIMCResolutionStatus SetRootEnumOrBitsRec(SIMCEnumOrBitsType *t,
											SIMCSubTypeList& checkedList);
	public:
		// This is a hack to take care of DEFVAL clauses
		BOOL SetDefVal();
		SIMCResolutionStatus SetDefVal(SIMCObjectTypeType *objType);

		// Returs the PrimitiveType of a symbol
		static PrimitiveType GetPrimitiveType(const SIMCTypeReference *typeRef);
		static PrimitiveType GetPrimitiveType(const char * const name);

		// Value checking functions
		static SIMCResolutionStatus IsIntegerValue(SIMCSymbol **s, int& retValue);
		static SIMCResolutionStatus IsObjectIdentifierValue(SIMCSymbol **s,
												SIMCOidValue* &retValue);
		static SIMCResolutionStatus IsNullValue(SIMCSymbol **s);
		static SIMCResolutionStatus IsOctetStringValue(SIMCSymbol **s, 
										SIMCOctetStringValue* &retValue);
		static SIMCResolutionStatus IsBitsValue(SIMCSymbol **s,
										SIMCBitsValue * &retValue);
		// Type checking functions
		static SIMCResolutionStatus IsObjectTypeV1(SIMCSymbol **value, 
											  SIMCObjectTypeV1 * &retValObjectType);
		static SIMCResolutionStatus IsObjectTypeV2(SIMCSymbol **value, 
											  SIMCObjectTypeV2 * &retValObjectType);
		static SIMCResolutionStatus IsObjectType(SIMCSymbol **value, 
											  SIMCObjectTypeType * &retValObjectType);
		static SIMCResolutionStatus IsTrapType(SIMCSymbol **value, 
											  SIMCTrapTypeType * &retValTrapType);
		static SIMCResolutionStatus IsNotificationType(SIMCSymbol **value, 
											  SIMCNotificationTypeType * &retValNotificationType);
		static SIMCResolutionStatus IsEnumType(SIMCSymbol **value, 
											  SIMCEnumOrBitsType * &retValEnumType);

		// Reference checking functions
		static SIMCResolutionStatus IsTypeReference(SIMCSymbol **symbol,
											SIMCTypeReference * &retVal);
		static SIMCResolutionStatus IsValueReference(SIMCSymbol **symbol,
											SIMCSymbol ** &retTypeRef,
											SIMCBuiltInValueReference *&retVal);
		static SIMCResolutionStatus IsSequenceTypeReference(SIMCSymbol **symbol,
											SIMCBuiltInTypeReference * &retVal1,
											SIMCSequenceType *&retVal2);
		static SIMCResolutionStatus IsSequenceOfTypeReference(SIMCSymbol **symbol,
											SIMCBuiltInTypeReference * &retVal1,
											SIMCSequenceOfType *&retVal2);
		// For fabrication of OBJECT-GROUPs
		static SIMCResolutionStatus IsNamedNode(SIMCSymbol **symbol);
		static SIMCResolutionStatus IsScalar(SIMCSymbol **symbol);
		static SIMCResolutionStatus IsTable(SIMCSymbol **symbol);
		static SIMCResolutionStatus IsRow(SIMCSymbol **symbol);

		// Other helpers
		static SIMCResolutionStatus IsNotZeroSizeObject(SIMCObjectTypeType *objectType);
		static SIMCResolutionStatus IsFixedSizeObject(SIMCObjectTypeType *objectType);

		// This fabricates NOTICFICATION-TYPEs from TRAP-TYPEs and then proceeds to
		// fabricate NOTIFICATION-GROUPs from them.
		BOOL FabricateNotificationGroups(SIMCParseTree& theParseTree,	
			const SIMCOidTree& theOidTree);


};

template<>
UINT AFXAPI HashKey(LPCSTR key);

#endif // SIMC_MODULE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\infoyacc.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
const MI_BGIN = 257;
const MI_CCE = 258;
const MI_COMMA = 259;
const MI_DEFINITIONS = 260;
const MI_FROM = 261;
const MI_ID = 262;
const MI_IMPORTS = 263;
const MI_NAME = 264;
const MI_SEMICOLON = 265;
const MI_LBRACE = 266;
const MI_RBRACE = 267;
const MI_LPAREN = 268;
const MI_RPAREN = 269;
const MI_DOT = 270;
const MI_LITNUMBER = 271;
typedef union {
	char * yy_name;
} MODULEINFOSTYPE;
extern MODULEINFOSTYPE ModuleInfolval;

// C++ YACC parser header
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// ModuleInfo_parse => class defining a parsing object
//	ModuleInfo_parse needs a class ModuleInfo_scan, which defines the scanner.
// %prefix or option -p xx determines name of this class; if not used,
// defaults to 'ModuleInfo_scan'
//
// constructor fills in the tables for this grammar; give it a size
//    to determine size of state and value stacks. Default is 150 entries.
// destructor discards those state and value stacks
//
// int ModuleInfo_parse::ModuleInfoparse(ModuleInfo_scan *) invokes parse; if this returns,
//	it can be recalled to continue parsing at last point.
// void ModuleInfo_parse::ModuleInforeset() can be called to reset the parse;
//	call ModuleInforeset() before ModuleInfo_parse::ModuleInfoparse(ModuleInfo_scan *)
#include <stdio.h>		// uses printf(), et cetera
#include <stdlib.h>		// uses exit()

const MODULEINFOERRCODE = 256;		// YACC 'error' value

// You can use these macros in your action code
#define MODULEINFOERROR		goto ModuleInfoerrlabel
#define MODULEINFOACCEPT	MODULEINFORETURN(0)
#define MODULEINFOABORT		MODULEINFORETURN(1)
#define MODULEINFORETURN(val)	return(val)

#if MODULEINFODEBUG
typedef struct ModuleInfoNamedType_tag {	/* Tokens */
	char	* name;		/* printable name */
	short	token;		/* token # */
	short	type;		/* token type */
} ModuleInfoNamedType;
typedef struct ModuleInfoTypedRules_tag {	/* Typed rule table */
	char	* name;		/* compressed rule string */
	short	type;		/* rule result type */
} ModuleInfoTypedRules;
#endif

#ifdef YACC_WINDOWS

// include all windows prototypes, macros, constants, etc.

#include <windows.h>

// the following is the handle to the current
// instance of a windows program. The user
// program calling ModuleInfoparse must supply this!

extern HANDLE hInst;	

#endif	/* YACC_WINDOWS */


class ModuleInfo_parse {
protected:

#ifdef YACC_WINDOWS

	// protected member function for actual scanning 

	int	win_ModuleInfoparse(ModuleInfo_scan * ps);	// parse with given scanner

#endif	/* YACC_WINDOWS */

	int	mustfree;	// set if tables should be deleted
	int	size;		// size of state and value stacks
	int	reset;		// if set, reset state
	short	ModuleInfoi;		// table index
	short	ModuleInfostate;	// current state

	short	* stateStack;	// states stack
	MODULEINFOSTYPE	* valueStack;	// values stack
	short	* ModuleInfops;		// top of state stack
	MODULEINFOSTYPE * ModuleInfopv;		// top of value stack

	MODULEINFOSTYPE ModuleInfolval;		// saved ModuleInfolval
	MODULEINFOSTYPE	ModuleInfoval;		// $
	MODULEINFOSTYPE * ModuleInfopvt;	// $n
	int	ModuleInfochar;		// current token
	int	ModuleInfoerrflag;	// error flag
	int	ModuleInfonerrs;	// error count
#if MODULEINFODEBUG
	int	done;		// set from trace to stop parse
	int	rule, npop;	// reduction rule # and length
	short	* typeStack;	// type stack to mirror valueStack[]
	short	* ModuleInfotp;		// top of type stack
	char	* ModuleInfogetState(int);	// read 'states.out'
#endif
public:
#if MODULEINFODEBUG
	// C++ has trouble with initialized arrays inside classes
	static long * States;		// pointer to ModuleInfoStates[]
	static ModuleInfoTypedRules * Rules;	// pointer to ModuleInfoRules[]
	static ModuleInfoNamedType * TokenTypes; // pointer to ModuleInfoTokenTypes[]
	static int	ModuleInfontoken;	// number of tokens
	static int	ModuleInfonvar;		// number of variables (nonterminals)
	static int	ModuleInfonstate;	// number of YACC-generated states
	static int	ModuleInfonrule;	// number of rules in grammar

	char*	ModuleInfoptok(int);		// printable token string
	int	ModuleInfoExpandName(int, int, char *, int);
						// expand encoded string
	virtual int	ModuleInfoGetType(int);		// return type of token
	virtual void	ModuleInfoShowRead();		// see newly read token
	virtual void	ModuleInfoShowState();		// see state, value stacks
	virtual void	ModuleInfoShowReduce();		// see reduction
	virtual void	ModuleInfoShowGoto();		// see goto
	virtual void	ModuleInfoShowShift();		// see shift
	virtual void	ModuleInfoShowErrRecovery();	// see error recovery
	virtual void	ModuleInfoShowErrDiscard();	// see token discard in error
#endif
	ModuleInfo_scan* scan;			// pointer to scanner
	int	ModuleInfodebug;	// if set, tracing if compiled with MODULEINFODEBUG=1

	ModuleInfo_parse(int = 150);	// constructor for this grammar
	ModuleInfo_parse(int, short *, MODULEINFOSTYPE *);	// another constructor

	~ModuleInfo_parse();		// destructor

	int	ModuleInfoparse(ModuleInfo_scan * ps);	// parse with given scanner

	void	ModuleInforeset() { reset = 1; } // restore state for next ModuleInfoparse()

	void	setdebug(int y) { ModuleInfodebug = y; }

// The following are useful in user actions:

	void	ModuleInfoerrok() { ModuleInfoerrflag = 0; }	// clear error
	void	ModuleInfoclearin() { ModuleInfochar = -1; }	// clear input
	int	MODULEINFORECOVERING() { return ModuleInfoerrflag != 0; }
};
// end of .hpp header
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\errormessage.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_ERROR_MESSAGE_H
#define SIC_ERROR_MESSAGE_H



// Models an error message generated by the various components of
// the SNMP Compiler
class SIMCErrorMessage
{
		// The text of the message
		char *_message;

		char *_inputStreamName; // Need not be a file name. Could be anything that the 
								// creator of this error message
								// thinks appropriate. Like "Standard Input".
		// The severity level, both a number as well as a
		// string representation are used. Example
		// 1 - "Fatal"
		// 2 - "Warning"
		char *_severityString;
		int _severityLevel;


		// Column and line numbers
		long _columnNumber;
		long _lineNumber;
		// An indication whether column and line numbers are valid in this
		// message. Example, for global messages, this may be true
		BOOL _lineAndColumnValid;

		// A unique ID for the message. May be used in documenting
		// errors.
		int _errorId;

	public:
		// Construct an empty error message
		SIMCErrorMessage()
		{
			_message = _inputStreamName = _severityString = NULL;
			_lineNumber = _columnNumber = _severityLevel = _errorId = 0;
			_lineAndColumnValid = TRUE;
		}

		// Construct a loaded error message
		SIMCErrorMessage(const char * const inputStreamName, 
				const char * const message,
				const char * const severityString,
				int errorId,
				int severityLevel,
				long lineNumber = 0, long columnNumber = 0 );
				
		// And a copy constructor)
		SIMCErrorMessage (const SIMCErrorMessage& rhs	);

		// Assigment of error messages
		const SIMCErrorMessage& operator = (const SIMCErrorMessage&);

		// Checking equality of errors
		BOOL operator == (const SIMCErrorMessage& rhs) const
		{
			return  _lineNumber == rhs._lineNumber &&
					_columnNumber == rhs._columnNumber &&
					_severityLevel == rhs._severityLevel &&
					_errorId == rhs._errorId &&
					strcmp(_severityString, rhs._severityString) == 0 &&
					strcmp(_message, rhs._message) == 0 &&
					strcmp(_inputStreamName, rhs._inputStreamName) == 0 ;
		}

		virtual ~SIMCErrorMessage();
		
		// Various get and set functions
		const char * GetMessage() const
		{
			return _message;
		}
		const char *GetInputStreamName() const
		{
			return _inputStreamName;
		}
		const char *GetSeverityString() const
		{
			return _severityString;
		}
		long GetLineNumber() const
		{
			return _lineNumber;
		}
		long GetColumnNumber() const
		{
			return _columnNumber;
		}

		int GetSeverityLevel() const
		{
			return _severityLevel;
		}

		int GetErrorId() const
		{
			return _errorId;
		}

		BOOL SetMessage( const char * const message);
		BOOL SetInputStreamName ( const char * const inputStreamName);
		BOOL SetSeverityString ( const char * const severityString);
		void SetLineNumber( const long lineNumber)
		{
			_lineNumber = lineNumber;
		}

		void SetColumnNumber( const long columnNumber)
		{
			_columnNumber = columnNumber;
		}

		void SetSeverityLevel( const int severityLevel)
		{
			_severityLevel = severityLevel;
		}

		void SetErrorId( const int errorId)
		{
			_errorId = errorId;
		}
	 
		void SetLineAndColumnValidity(BOOL value)
		{
			_lineAndColumnValid =  value;
		}

		// And a default output of the error message
		friend ostream& operator << 
			( ostream& outStream, const SIMCErrorMessage& errorMessage) ;
};

#endif // SIMC_ERROR_MESSAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\notificationgroup.hpp ===
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//

#ifndef NOTIFICATION_GROUP
#define NOTIFICATION_GROUP

#include <autoptr.h>

// This encapsulates one of the following:
// A V2 NOTIFICATION-TYPE invocation or
// A NOTIFICATION-TYPE fabricated from a V1 TRAP-TYPE invocation
class SIMCNotificationElement
{
		// A pointer to the symbol in a module, that represents this
		// NOTIFICATION-TYPE
		SIMCSymbol *symbol;
		
		// The "clean" oid value of this NOTIFICATION-TYPE. Note that
		// and "unclean" value may be obtained by  calling the
		// function SIMCModule.IsObjectIdentifierValue(), on the module
		// that defined this symbol.
		SIMCCleanOidValue *value;

		// Indicates whether this was fabricated from a TRAP-TYPE
		BOOL _fabricatedFromTrapType;
		// These 2 fields are valid only if fabricatedFromTrapType is true
		int _specificId;
		SIMCCleanOidValue *_enterpriseOid;

	public:
		SIMCNotificationElement(SIMCSymbol *s, SIMCCleanOidValue *v,
			BOOL fabricatedFromTrapType = FALSE)
			: symbol(s), value(v), _fabricatedFromTrapType(fabricatedFromTrapType)
		{
			// Set the specificId and the enterpriseOid fields
			_enterpriseOid = new SIMCCleanOidValue;
			wmilib::auto_ptr<SIMCCleanOidValue> _enterpriseOid_Guard ( _enterpriseOid ) ;

			_specificId = 0;
			if(fabricatedFromTrapType)
			{
				if(v->GetCount() >= 3)
				{
					POSITION lastPosition = v->GetHeadPosition();
					POSITION lastMinusOnePosition = NULL;
					POSITION lastMinusTwoPosition = NULL;

					while(lastPosition)
					{
						lastMinusTwoPosition = lastMinusOnePosition;
						lastMinusOnePosition = lastPosition;
						_specificId = v->GetNext(lastPosition);
						_enterpriseOid->AddTail(_specificId);
					}
					_enterpriseOid->RemoveTail();
					_enterpriseOid->RemoveTail();
				}
			}

			//
			// dismiss as we succeeded construction
			// without exception being raisen
			// so destructor will take care of cleanup
			//
			_enterpriseOid_Guard.release () ;
		}
	
		SIMCNotificationElement()
			: symbol(NULL), value(NULL)
		{}

		~SIMCNotificationElement()
		{
			delete value;
			delete _enterpriseOid;
		}

		friend ostream& operator << (ostream& outStream, const SIMCNotificationElement& obj);

		SIMCSymbol *GetSymbol() const
		{
			return symbol;
		}

		void SetSymbol(SIMCSymbol *s) 
		{
			symbol = s;
		}

		SIMCCleanOidValue *GetOidValue() const
		{
			return value;
		}
		void SetOidValue(SIMCCleanOidValue *v) 
		{
			value = v;
		}
		BOOL IsFabricatedFromTrapType() const
		{
			return _fabricatedFromTrapType;
		}

		// This is valid only if IsFabricatedFromTrapType() returns TRUE
		int GetSpecificId() const
		{
			return _specificId;
		}

		// This is valid only if IsFabricatedFromTrapType() returns TRUE
		SIMCCleanOidValue * GetEnterpriseOid() const
		{
			return _enterpriseOid;
		}
};

typedef CList<SIMCNotificationElement *, SIMCNotificationElement *> SIMCNotificationList;



// And finally the notification group itself. 
class SIMCNotificationGroup
{
	public:
		enum NotificationGroupStatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_CURRENT,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	// For generating a name for the notification group, in case of the V1 SMI
	static const char *const NOTIFICATION_GROUP_FABRICATION_SUFFIX; 
	static const int NOTIFICATION_GROUP_FABRICATION_SUFFIX_LEN;

	private:
		// Various clauses of the notification group
		char *notificationGroupName;	
		char *description;
		char *reference;
		SIMCSymbol *enterpriseNode;
		SIMCCleanOidValue *enterpriseNodeValue;
		SIMCNotificationList *notifications;
		NotificationGroupStatusType status;
		static const char * const StatusStringsTable[3];
		
	public:
		SIMCNotificationGroup(SIMCSymbol *n, SIMCCleanOidValue *nv,   
			NotificationGroupStatusType s, const char * descriptionV, 
			const char *referenceV, SIMCNotificationList *notificationsV)
			: enterpriseNode(n), enterpriseNodeValue(nv),  status(s),
				notifications(notificationsV)
		{
			notificationGroupName = NewString(strlen(n->GetSymbolName()) + 
									NOTIFICATION_GROUP_FABRICATION_SUFFIX_LEN + 1);
			strcpy(notificationGroupName, n->GetSymbolName());
			strcat(notificationGroupName, NOTIFICATION_GROUP_FABRICATION_SUFFIX);

			description = NewString(descriptionV);
			reference = NewString(referenceV);
		}
		
		SIMCNotificationGroup()
			: enterpriseNode(NULL), enterpriseNodeValue(NULL), notifications(NULL), 
				status(STATUS_CURRENT), notificationGroupName(NULL), description(NULL),
				reference(NULL)
		{}

		
		~SIMCNotificationGroup()
		{
			delete [] notificationGroupName;
			delete [] description;
			delete [] reference;

			if(notifications)
			{
				SIMCNotificationElement *nextElement;
				while(!notifications->IsEmpty() )
				{
					nextElement = notifications->RemoveHead();
					delete nextElement;
				}
				delete notifications;
			}

			if(enterpriseNodeValue) delete enterpriseNodeValue;


		}

		friend ostream& operator << (ostream& outStream, const SIMCNotificationGroup& obj);
	
		SIMCSymbol *GetEnterpriseNode() const
		{
			return enterpriseNode;
		}
		
		void SetEnterpriseNode(SIMCSymbol *nn) 
		{
			enterpriseNode = nn;
			if(notificationGroupName)
				delete [] notificationGroupName;
			notificationGroupName = NewString(strlen(nn->GetSymbolName()) + 
									NOTIFICATION_GROUP_FABRICATION_SUFFIX_LEN + 1);
			strcpy(notificationGroupName, nn->GetSymbolName());
			strcat(notificationGroupName, NOTIFICATION_GROUP_FABRICATION_SUFFIX);
		}
		
		const char * const GetNotificationGroupName() const
		{
			return notificationGroupName;
		}

		const char * const GetDescription() const
		{
			return description;
		}

		void SetDescription(const char * const descriptionV)
		{
			delete [] description;
			description = NewString(descriptionV);
		}

		const char * const GetReference() const
		{
			return reference;
		}

		void SetReference(const char * const referenceV)
		{
			delete [] reference;
			reference = NewString(referenceV);
		}

		SIMCCleanOidValue *GetGroupValue() const
		{
			return enterpriseNodeValue;
		}

		void SetGroupValue(SIMCCleanOidValue *val) 
		{
			enterpriseNodeValue = val;
		}

		SIMCNotificationList *GetNotifications() const
		{
			return notifications;
		}

		void AddNotification(SIMCNotificationElement *s) 
		{
			if(!notifications)
				notifications = new SIMCNotificationList();
			notifications->AddTail(s);
		}

		long GetNotificationCount() const
		{
			if(notifications)
				return notifications->GetCount();
			else
				return 0;
		}

	
		NotificationGroupStatusType GetStatus() const
		{
			return status;
		}

		void SetStatus(NotificationGroupStatusType s)
		{
			status = s;
		}	

		const char * const GetStatusString() const
		{
			switch(status)
			{
				case STATUS_CURRENT:
					return 	StatusStringsTable[STATUS_CURRENT-1];
				case STATUS_DEPRECATED:
					return 	StatusStringsTable[STATUS_DEPRECATED-1];
				case STATUS_OBSOLETE:
					return 	StatusStringsTable[STATUS_OBSOLETE-1];
				default:
					return NULL;
			}
			return NULL;
		}
};

typedef CList<SIMCNotificationGroup *, SIMCNotificationGroup*> SIMCNotificationGroupList;

class SIMCModuleNotificationGroups
{
	SIMCNotificationGroupList theList;

	public:

		BOOL AddNotification(SIMCSymbol *notificationSymbol);
		const SIMCNotificationGroupList *GetNotificationGroupList() const;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\notificationtype.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef NOTIFICATION_TYPE_TYPE
#define NOTIFICATION_TYPE_TYPE



/*
 * This file contains the class that models the NOTIFICATION-TYPE macro
 * and other associated classes
 */

// Each of the objects in the VARIABLES clause
class SIMCObjectsItem
{
	public:
		SIMCSymbol **_item;
		long _line, _column;
		SIMCObjectsItem( SIMCSymbol **item, long line, long column)
			: _item(item), _line(line), _column(column)
		{}
};

// A list of items in the OBJECTS clause
typedef  CList<SIMCObjectsItem *, SIMCObjectsItem *> SIMCObjectsList;

/*
 * This class models the NOTIFICATION-TYPE macro of SNMPV2 SMI. 
 */
class SIMCNotificationTypeType : public SIMCType
{
	public:
		// Symbols for the STATUS clause
		enum StatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_CURRENT,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	// These are for generating a name for the notification type, 
	// from a V1 SMI trap type
	static const char *const NOTIFICATION_TYPE_FABRICATION_SUFFIX;
	static const int NOTIFICATION_TYPE_FABRICATION_SUFFIX_LEN;
	
	private:
		// The various clauses of the NOTIFICATION-TYPE macro
		SIMCObjectsList *_objects;
		char * _description;
		long _descriptionLine, _descriptionColumn;
		char *_reference;
		long _referenceLine, _referenceColumn;
		StatusType _status;
		long _statusLine, _statusColumn;


	public:
		SIMCNotificationTypeType(SIMCObjectsList *objects,
							char * description,
							long descriptionLine, long descriptionColumn,
							char *reference,
							long referenceLine, long referenceColumn,
							StatusType status,
							long statusLine, long statusColumn);

		~SIMCNotificationTypeType();

		static StatusType StringToStatusType (const char * const s);

		SIMCObjectsList* GetObjects() const
		{
			return _objects;
		}

		char *GetDescription() const
		{
			return _description;
		}
		char *GetReference() const
		{
			return _reference;
		}

		virtual void WriteType(ostream& outStream) const;
		
		long GetDescriptionLine() const
		{
			return _descriptionLine;
		}

		void SetDescriptionLine( long x) 
		{
			_descriptionLine = x;
		}

		long GetDescriptionColumn() const
		{
			return _descriptionColumn;
		}

		void SetDescriptionColumn( long x) 
		{
			_descriptionColumn = x;
		}

		long GetReferenceLine() const
		{
			return _referenceLine;
		}

		void SetReferenceLine( long x) 
		{
			_referenceLine = x;
		}

		long GetReferenceColumn() const
		{
			return _referenceColumn;
		}

		void SetReferenceColumn( long x) 
		{
			_referenceColumn = x;
		}

		void SetStatus(StatusType s)
		{
			_status = s;
		}

		StatusType GetStatus() const
		{
			return _status;
		}

		long GetStatusLine() const
		{
			return _statusLine;
		}

		void SetStatusLine(long x) 
		{
			_statusLine = x;
		}

		long GetStatusColumn() const
		{
			return _statusColumn;
		}

		void SetStatusColumn(long x) 
		{
			_statusColumn = x;
		}


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\objectidentity.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef OBJECT_IDENTITY
#define OBJECT_IDENTITY

/* 
 * This class models the OBJECT-IDENTITY macro
 */
class SIMCObjectIdentityType : public SIMCType
{
	public:
		// Symbols for the STATUS clause
		enum StatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_CURRENT,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	private:

		// Various clauses of the OBJECT-IDENTITY macro
		StatusType _status;
		long _statusLine, _statusColumn;
		char *_description;
		long _descriptionLine, _descriptionColumn;
		char *_reference;
		long _referenceLine, _referenceColumn;

	public:
		SIMCObjectIdentityType( StatusType status,
									long statusLine, long statusColumn,
									char *description,
									long descriptionLine, long descriptionColumn,
									char *reference,
									long referenceLine, long referenceColumn);

	
		virtual ~SIMCObjectIdentityType();
		

		/*
		 *
		 * And a whole lotta functions to set/get the various clauses
		 * 
		 */
		void SetStatus(StatusType s)
		{
			_status = s;
		}

		StatusType GetStatus() const
		{
			return _status;
		}

		static StatusType StringToStatusType (const char * const s);

		long GetStatusLine() const
		{
			return _statusLine;
		}
		void SetStatusLine(long x) 
		{
			_statusLine = x;
		}
		long GetStatusColumn() const
		{
			return _statusColumn;
		}
		void SetStatusColumn(long x) 
		{
			_statusColumn = x;
		}

		void SetDescription( const char * const s)
		{
			if( _description)
				delete [] _description;
			_description = NewString(s);
		}
		const char * GetDescription() const
		{
			return _description;
		}
		long GetDescriptionLine() const
		{
			return _descriptionLine;
		}
		long GetDescriptionColumn() const
		{
			return _descriptionColumn;
		}
		void SetDescriptionLine(long x) 
		{
			 _descriptionLine = x;
		}
		void SetDescriptionColumn(long x) 
		{
			 _descriptionColumn = x;
		}

		void SetReference( const char * const s)
		{
			if( _reference)
				delete [] _reference;
			_reference = NewString(s);
		}
		const char * GetReference() const
		{
			return _reference;
		}
		long GetReferenceLine() const
		{
			return _referenceLine;
		}
		long GetReferenceColumn() const
		{
			return _referenceColumn;
		}
		void SetReferenceLine(long x) 
		{
			 _referenceLine = x;
		}
		void SetReferenceColumn(long x) 
		{
			 _referenceColumn = x;
		}

		// A debugging function
		void WriteType(ostream &outStream) const;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\objecttype.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_OBJECT_TYPE_TYPE
#define SIMC_OBJECT_TYPE_TYPE

typedef CList<SIMCSymbol *, SIMCSymbol *> SIMCIndexedObjectsList;

/*
 * This class is an abstract base class for a MIB object, defined using
 * the OBJECT-TYPE clause. It has stuff that is common to SNMPV1 objects
 * and SNMPv2 objects. The SIMCObjectTypeV1 and SIMCObjectTypeV2 classes
 * derive from this class and add the necessary functionality
 */
class SIMCObjectTypeType : public SIMCType
{
		// A pointer to the symbol that defines this object
		SIMCSymbol ** _syntax;

		// The various clauses of the OBJECT-TYPE
		char *_description;
		char *_reference;
		// the value in the defVal clause can refer to an enum item
		// If so _defVal is NULL, and _defValName contains the identifier of the
		// enum item, and _enumValue contains the integral value.
		// Otherwise, _defValName is NULL and _defVal contains a reference to the
		// symbol representing the value
		SIMCSymbol **_defVal;
		char *_defValName;
		SIMCResolutionStatus _defValStatus;
		long _syntaxLine, _syntaxColumn, _descriptionLine, _descriptionColumn,
			_referenceLine, _referenceColumn, _defValLine, _defValColumn;

		// This OBJECT-TYPE is referenced in the INDEX clause of these OBJECT-TYPEs
		SIMCIndexedObjectsList indexedObjectsList;

	protected:
		SIMCObjectTypeType( SIMCSymbol **syntax,
							long syntaxLine, long syntaxColumn,
							const char * const description,
							long descriptionLine, long descriptionColumn,
							const char * const reference,
							long referenceLine, long referenceColumn,
							const char * const defValName,
							SIMCSymbol **defVal,
							long defValLine, long defValColumn)
							: _syntax(syntax), _defVal(defVal),
								_syntaxLine(syntaxLine), _syntaxColumn(syntaxColumn),
								_descriptionLine(descriptionLine), 
								_descriptionColumn(descriptionColumn),
								_referenceLine(referenceLine), 
								_referenceColumn(referenceColumn),
								_defValLine(defValLine), _defValColumn(defValColumn)
		{
			if(_syntax)
				(*_syntax)->IncrementReferenceCount();
			if(_defVal)
				(*_defVal)->IncrementReferenceCount();
			_description = NewString(description);
			_reference = NewString(reference);
			_defValName = NewString(defValName);
			_defValStatus = RESOLVE_UNSET;
		}

	
		virtual ~SIMCObjectTypeType()
		{
			if(UseReferenceCount() && _syntax)
				(*_syntax)->DecrementReferenceCount();
			if(UseReferenceCount() && _defVal)
				(*_defVal)->DecrementReferenceCount();
			if(_description)
				delete [] _description;
			if(_reference)
				delete [] _reference;
			if(_defValName)
				delete [] _defValName;
		}

	public:

		/*
		 * 
		 * A whole lotta functions to get/set the various clauses
		 * of the OBJECT-TYPE macro
		 *
		 */
		void SetDescription( const char * const s)
		{
			if( _description)
				delete [] _description;
			_description = NewString(s);
		}

		const char * GetDescription() const
		{
			return _description;
		}

		void SetReference( const char * const s)
		{
			if( _reference)
				delete [] _reference;
			_reference = NewString(s);
		}

		const char * GetReference() const
		{
			return _reference;
		}
	
		void SetDefValName( const char * const s)
		{
			if( _defValName)
				delete [] _defValName;
			_defValName = NewString(s);
		}

		const char * GetDefValName() const
		{
			return _defValName;
		}

		void SetDefValStatus(SIMCResolutionStatus x)
		{
			_defValStatus = x;
		}

		SIMCResolutionStatus GetDefValStatus() const
		{
			return _defValStatus;
		}

		void SetSyntax( SIMCSymbol ** s)
		{
			if(_syntax && UseReferenceCount())
				(*_syntax)->DecrementReferenceCount();
			_syntax = s;
			if(_syntax)
				(*_syntax)->IncrementReferenceCount();

		}

		SIMCSymbol **GetSyntax() const
		{
			return _syntax;
		}

		void SetDefVal(SIMCSymbol **v)
		{
			if(_defVal && UseReferenceCount())
				(*_defVal)->DecrementReferenceCount();
			_defVal = v;
			if(_defVal)
				(*_defVal)->IncrementReferenceCount();
		}

		SIMCSymbol **GetDefVal() const
		{
			return _defVal;
		}

		void WriteType( ostream& outStream) const
		{
			outStream << "SIMCObjectType::operator<<() : NOT YET IMPLEMENTED" << endl;
		}
		
		// Set and Get for the line numbers
		long GetSyntaxLine() const
		{
			return _syntaxLine;
		}
		long GetSyntaxColumn() const
		{
			return _syntaxColumn;
		}
		long GetDescriptionLine() const
		{
			return _descriptionLine;
		}
		long GetDescriptionColumn() const
		{
			return _descriptionColumn;
		}
		long GetReferenceLine() const
		{
			return _referenceLine;
		}
		long GetReferenceColumn() const
		{
			return _referenceColumn;
		}
		long GetDefValLine() const
		{
			return _defValLine;
		}
		long GetDefValColumn() const
		{
			return _defValColumn;
		}

		void SetSyntaxLine(long x) 
		{
			 _syntaxLine = x;
		}
		void SetSyntaxColumn(long x) 
		{
			 _syntaxColumn = x;
		}
		void SetDescriptionLine(long x) 
		{
			 _descriptionLine = x;
		}
		void SetDescriptionColumn(long x) 
		{
			 _descriptionColumn = x;
		}
		void SetReferenceLine(long x) 
		{
			 _referenceLine = x;
		}
		void SetReferenceColumn(long x) 
		{
			 _referenceColumn = x;
		}
		void SetDefValLine(long x) 
		{
			 _defValLine = x;
		}
		void SetDefValColumn(long x) 
		{
			 _defValColumn = x;
		}
		void AddIndexedObjectType(SIMCSymbol *indexObjectType)
		{
			indexedObjectsList.AddTail(indexObjectType);
		}

		BOOL DoesIndexOtherObjects() const
		{
			return !indexedObjectsList.IsEmpty();
		}

		const SIMCIndexedObjectsList *GetIndexedObjects() const
		{
			return &indexedObjectsList;
		}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\objecttypev1.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_OBJECT_TYPE_V1
#define SIMC_OBJECT_TYPE_V1

/*
 * This file contains the SIMCObjectTypeV1 class that represents a
 * MIB object defined using the OBJECT-TYPE macro, as per the SNMPV1 SMI
 * It is derived from the SIMCObjectTypeType class.
 */


/* Each of the item in the INDEX clause */
class SIMCIndexItem
{
	public:
		SIMCSymbol ** _item;
		long _line, _column;
		SIMCIndexItem(SIMCSymbol **item, long line, long column)
			: _item(item), _line(line), _column(column)
		{}
};

/* A list of index items. This forms the index clause */
typedef CList<SIMCIndexItem *, SIMCIndexItem *> SIMCIndexList;

/* 
 * This models a MIB object defined using the OBJECT-TYPE macro, as per
 * the SNMPV1 SMI rules.
 */
class SIMCObjectTypeV1 : public SIMCObjectTypeType
{
	public:
		// Symbols for the ACCESS clause
		enum AccessType
		{
			ACCESS_INVALID,	// Not used, except as a return value from function calls
			ACCESS_NOT_ACCESSIBLE,
			ACCESS_READ_ONLY,
			ACCESS_READ_WRITE,
			ACCESS_WRITE_ONLY
		};

		// Symbols for the STATUS clause
		enum StatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_MANDATORY,
			STATUS_OPTIONAL,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	private:

		// Values for the various OBJECT-TYPE macro clauses
		AccessType _access;
		long _accessLine, _accessColumn;
		StatusType _status;
		long _statusLine, _statusColumn;
		SIMCIndexList * _indexTypes;
		long _indexLine, _indexColumn;

	public:
		SIMCObjectTypeV1( 	SIMCSymbol **syntax,
								    long syntaxLine, long syntaxColumn,
									AccessType access,
									long accessLine, long accessColumn, 
									StatusType status,
									long statusLine, long statusColumn,
									SIMCIndexList * indexTypes,
									long indexLine, long indexColumn,
									char *description,
									long descriptionLine, long descriptionColumn,
									char *reference,
									long referenceLine, long referenceColumn,
									char *defValName,
									SIMCSymbol **defVal,
									long defValLine, long defValColumn);


	
		virtual ~SIMCObjectTypeV1();
		

		/*
		 *
		 * Lots of functions to get/set the various OBJECT-TYPE clauses
		 *
		 */
		void SetAccess(AccessType a)
		{
			_access = a;
		}

		AccessType GetAccess() const
		{
			return _access;
		}


		void SetStatus(StatusType s)
		{
			_status = s;
		}

		StatusType GetStatus() const
		{
			return _status;
		}

		void SetIndexTypes(SIMCIndexList *l)
		{
			_indexTypes = l;
		}
	
		SIMCIndexList * GetIndexTypes() const
		{
			return _indexTypes;
		}

		static AccessType StringToAccessType (const char * const s);

		static StatusType StringToStatusType (const char * const s);


		long GetAccessLine() const
		{
			return _accessLine;
		}

		void SetAccessLine(long x) 
		{
			_accessLine = x;
		}

		long GetAccessColumn() const
		{
			return _accessColumn;
		}

		void SetAccessColumn(long x) 
		{
			_accessColumn = x;
		}

		long GetStatusLine() const
		{
			return _statusLine;
		}

		void SetStatusLine(long x) 
		{
			_statusLine = x;
		}

		long GetStatusColumn() const
		{
			return _statusColumn;
		}

		void SetStatusColumn(long x) 
		{
			_statusColumn = x;
		}
		long GetIndexLine() const
		{
			return _indexLine;
		}

		void SetIndexLine(long x) 
		{
			_indexLine = x;
		}

		long GetIndexColumn() const
		{
			return _indexColumn;
		}

		void SetIndexColumn(long x) 
		{
			_indexColumn = x;
		}


};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\oidvalue.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_OID_VALUE
#define SIMC_OID_VALUE

/*
 * This file contains classes for modelling OID values
 * OID values are of 2 types, for purposes of the compiler
 * A clean oid value, is one in which the values of the individual components
 * are known presently. Hence a list of integers is all that is required to model
 * it, as is done by the SIMCCleanOidValue typedef.	It is referred to, as a
 * "clean" oid value, in the documentation.
 * However, while compiling a MIB, we might not know the values of
 * of all the components of an OID (these may be symbols that refer
 * to integer values, or to other oid values. Hence, we need to model this
 * too, as is done by the SIMCOidValue class. It is often referred to as
 * an "unclean" OID value in the documentation.
 */


// Each component of the SIMCOidValue Object. This is basically a
// pointer to SIMCSymbol*, with other associated information.
class SIMCOidComponent
{

		char *_name;
		long _nameLine, _nameColumn;
		// The symbol that represents this component.
		// It should resolve to an integer, or another oid value
		SIMCSymbol **_value;   
		long _valueLine, _valueColumn;

	public:
		SIMCOidComponent(SIMCSymbol **value, long valueLine, long valueColumn,
			char *name, long nameLine, long nameColumn)
			: _value(value), _valueLine(valueLine), _valueColumn(valueColumn),
				_nameLine(nameLine), _nameColumn(nameColumn)
		{
			if(name)
				_name = NewString(name);
			else
				_name = NULL;
		}

		virtual ~SIMCOidComponent()
		{
			if(_name)
				delete []_name;
		}

		SIMCSymbol ** GetValue() const
		{
			return _value;
		}

		long GetNameLine() const
		{
			return _nameLine;
		}

		void SetNameLine(long x)
		{
			_nameLine = x;
		}
		long GetNameColumn() const
		{
			return _nameColumn;
		}

		void SetNameColumn(long x)
		{
			_nameColumn = x;
		}
		long GetValueLine() const
		{
			return _valueLine;
		}

		void SetValueLine(long x)
		{
			_valueLine = x;
		}
		long GetValueColumn() const
		{
			return _valueColumn;
		}

		void SetValueColumn(long x)
		{
			_valueColumn = x;
		}

		friend ostream& operator << ( ostream& outStream, const SIMCOidComponent& obj);
};

typedef CList<SIMCOidComponent *, SIMCOidComponent*> SIMCOidComponentList;


// An "unclean" oid value
class SIMCOidValue : public SIMCValue
{

		SIMCOidComponentList  * _listOfComponents;


	public:

		SIMCOidValue( SIMCOidComponentList* listOfComponents, 
			long line = 0, long column = 0)
			: _listOfComponents(listOfComponents), 
			SIMCValue(line, column)
		{
			if(_listOfComponents)
			{
				SIMCOidComponent *next;
				POSITION p = _listOfComponents->GetHeadPosition(); 
				while(p)
				{
					next = _listOfComponents->GetNext(p);
					(*next->GetValue())->IncrementReferenceCount();
				}
			}
		}

		~SIMCOidValue()
		{
			if(_listOfComponents)
			{
				SIMCOidComponent *next;
				BOOL useReferenceCount = UseReferenceCount();
				while(!_listOfComponents->IsEmpty())
				{
					next = _listOfComponents->RemoveHead();
					if(useReferenceCount)
						(*next->GetValue())->DecrementReferenceCount();
					delete next;
				}
				delete _listOfComponents;
			}
		}

		void SetListOfComponents(SIMCOidComponentList *list)
		{
			_listOfComponents = list;
		}

		SIMCOidComponentList  *GetListOfComponents() const 
		{
			return _listOfComponents;
		}

		virtual void WriteValue( ostream& outStream) const;

};

/*
* A "clean" oid value
*/
typedef CList<int, int> SIMCCleanOidValue;

// Functions to operate on a clean OID value
ostream& operator << (ostream& outStream, const SIMCCleanOidValue& obj);
operator == (const SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs);
operator < (const SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs);
void AppendOid(SIMCCleanOidValue& to, const SIMCCleanOidValue& from);
char * CleanOidValueToString(const SIMCCleanOidValue& value);
SIMCCleanOidValue& CleanOidValueCopy(SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\oidtree.hpp ===
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//

#ifndef SIMC_OID_TREE_H
#define SIMC_OID_TREE_H

#include <autoptr.h>

/* 
 * This file contains the SIMCOidTree class, which is a class that
 * represents the OID tree of an SNMP MIB module, and the associated classes
 */


// Forward references
class SIMCOidTreeNode;
class SIMCParseTree;
class SIMCOidTree;
// Helpful typedefs
typedef CList<const SIMCSymbol **, const SIMCSymbol **> SIMCSymbolList;
typedef CList<SIMCOidTreeNode *, SIMCOidTreeNode *> SIMCNodeList;



// Each node in the OID tree
class SIMCOidTreeNode
{
		// The integer value of this node. Basically a component of the
		// OID value
		int _val;
		// A list of symbols that have an OID value represented by this node
		SIMCSymbolList _listOfSymbols;
		// A list of child nodes
		SIMCNodeList _listOfChildNodes;

	public:
		
		// You *have* to supply an integer value for this node
		SIMCOidTreeNode(int val)
			: _val(val)
		{}

		~SIMCOidTreeNode();

		// Add a symbol to the list of symbols that have this oid value
		void AddSymbol(const SIMCSymbol ** s)
		{
			_listOfSymbols.AddTail(s);
		}
		
		int GetValue() const
		{
			return _val;
		}

		const SIMCSymbolList *GetSymbolList() const
		{
			return &_listOfSymbols;
		}

		// Check whether the specified symbol is in the list of symbols
		// of this node
		BOOL HasSymbol(SIMCSymbol *symbol)
		{
			POSITION p = _listOfSymbols.GetHeadPosition();
			const SIMCSymbol **next;
			const char * const symbolName = symbol->GetSymbolName();
			const char * const moduleName = (symbol->GetModule())->GetModuleName();
			while(p)
			{
				next = _listOfSymbols.GetNext(p);
				if(strcmp((*next)->GetSymbolName(), symbolName) == 0 &&
					strcmp( ((*next)->GetModule())->GetModuleName(), moduleName) == 0)

					return TRUE;
			}
			return FALSE;
		}

		// Add a child node
		BOOL AddChild(int val)
		{
			POSITION p = _listOfChildNodes.GetHeadPosition();
			SIMCOidTreeNode * next;
			while(p)
			{
				next = _listOfChildNodes.GetNext(p);
				if( next->GetValue() == val )
					return FALSE;
			}

			SIMCOidTreeNode * pTmp = new SIMCOidTreeNode(val) ;
			wmilib::auto_ptr<SIMCOidTreeNode> pTmp_Guard ( pTmp ) ;

			_listOfChildNodes.AddTail ( pTmp ) ;

			//
			// dismiss as we succeeded to add that node
			//
			pTmp_Guard.release () ;
			return TRUE;
		}

		const SIMCNodeList * GetListOfChildNodes() const
		{
			return &_listOfChildNodes;
		}

		// Get a child node that has the specified value
		SIMCOidTreeNode *GetChild(int val) const
		{
			POSITION p = _listOfChildNodes.GetHeadPosition();
			SIMCOidTreeNode * next;
			while(p)
			{
				next = _listOfChildNodes.GetNext(p);
				if( next->GetValue() == val )
					return next;
			}
			return NULL;
		}

		// Check whether the specified symbol is an any of the child
		// nodes
		BOOL HasChild(SIMCSymbol *child)
		{
			POSITION p = _listOfChildNodes.GetHeadPosition();
			SIMCOidTreeNode * next;
			while(p)
			{
				next = _listOfChildNodes.GetNext(p);
				if( next->HasSymbol(child))
					return TRUE;
			}
			return FALSE;
		}

		// These functions make semantic checks on a node
		BOOL CheckNode(BOOL local, SIMCParseTree *const parseTree, 
								SIMCSymbol *parentSequence,
								SIMCSymbol *parentSequenceOf, 
								SIMCSymbol *ancestor);
		BOOL CheckSequenceProperty(BOOL local, SIMCParseTree *const parseTree, 
									SIMCSymbol *objectTypeSymbol, 
									SIMCObjectTypeType *objectType,
									SIMCBuiltInTypeReference *seqTypeRef);
		BOOL CheckSequenceOfProperty(BOOL local, SIMCParseTree *const parseTree, 
								   SIMCSymbol *objectTypeSymbol, 
								   SIMCBuiltInTypeReference *seqOfTypeRef);
		// These functions are used in the implementation of
		// SIMCOidTree functions and should never be called by
		// the user. the user should always call the corresponding
		// SIMCOidTree functions
		BOOL GetOidValue(const char * const symbolName,
						const char * const moduleName,
						SIMCCleanOidValue& val) const;

		SIMCOidTreeNode *GetParentOf(const SIMCOidTreeNode * node);
		SIMCOidTreeNode *GetParentOf(SIMCSymbol *symbol);

		
		// Gets all the object groups, from this node, downwards.
		// Never called by the user. Use the corresponding SIMCOidTree
		// functions
		BOOL GetObjectGroups(SIMCOidTree *tree,
			SIMCGroupList *groupList);
		// These functions deal with fabrication
		// Never called by the user. Use the corresponding SIMCOidTree
		// functions
		BOOL FabricateGroup(SIMCOidTree *tree,
			SIMCSymbol *namedNode, SIMCGroupList *groupList);
		BOOL FabricateTable(SIMCOidTree *tree, SIMCTable *table);
		BOOL FabricateRow(SIMCOidTree *tree, SIMCTable *table);

};


/* And the OID tree */
class SIMCOidTree
{
		SIMCOidTreeNode _root;

	public:

		SIMCOidTree() 
			: _root(0)
		{}

		// Gets the root of the OID tree
		const SIMCOidTreeNode * GetRoot() const
		{
			return &_root;
		}

		// Adds a symbol with the specified OID value to the OID tree
		BOOL AddSymbol(const SIMCSymbol ** s, const SIMCCleanOidValue& val);

		// Gets a list of symbols that have the specified OID value
		const SIMCSymbolList *GetSymbolList(const SIMCCleanOidValue& val);
		
		// Gets the OID value of a symbol, based on its name and its module name
		BOOL GetOidValue(const char * const symbolName, 
			const char * const moduleName,
			SIMCCleanOidValue& val) const;

		// Gets the parent node of the specified node
		SIMCOidTreeNode *GetParentOf(const SIMCOidTreeNode * node);
		// Gets the parent node of the specified symbol
		SIMCOidTreeNode *GetParentOf(SIMCSymbol *symbol);

		// Gets all the OBJECT-GROUPS that can be fabricated from
		// this tree.
		BOOL GetObjectGroups(SIMCGroupList *groupList);

		// Checks the semantics of the OID tree
		BOOL CheckOidTree(BOOL local, SIMCParseTree * const parseTree);
		// Checks the semantics of single node
		BOOL CheckNode(BOOL local, SIMCParseTree * const parseTree);

		// Never called by the user
		static void SetAugmentedTable(SIMCTable *table, 
			SIMCSymbol *augmentsSymbol,
			SIMCGroupList *groupList);

		// debugging functions
		friend ostream& operator<< (ostream& outStream, const SIMCOidTree& obj)
		{
			obj.WriteTree(outStream);
			return outStream;
		}
		void WriteTree(ostream& outStream) const;
		static void WriteSubTree(ostream& outStream, 
							   const SIMCOidTreeNode *subNode,
							   SIMCCleanOidValue& realValue);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\objecttypev2.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_OBJECT_TYPE_V2
#define SIMC_OBJECT_TYPE_V2
/*
 * This file contains the SIMCObjectTypeV2 class that represents a
 * MIB object defined using the OBJECT-TYPE macro, as per the SNMPV2 SMI
 * It is derived from the SIMCObjectTypeType class.
 */

/* Each of the item in the INDEX clause */
class SIMCIndexItemV2
{
	public:
		SIMCSymbol ** _item;
		long _line, _column;
		BOOL _implied;
		SIMCIndexItemV2(SIMCSymbol **item, long line, long column, BOOL implied = FALSE)
			: _item(item), _line(line), _column(column), _implied(implied)
		{}
};

/* A list of index items. This forms the index clause */
typedef CList<SIMCIndexItemV2 *, SIMCIndexItemV2 *> SIMCIndexListV2;

/* 
 * This models a MIB object defined using the OBJECT-TYPE macro, as per
 * the SNMPV2 SMI rules.
 */
class SIMCObjectTypeV2 : public SIMCObjectTypeType
{
	public:
		// Symbols for the ACCESS clause
		enum AccessType
		{
			ACCESS_INVALID,	// Not used, except as a return value from function calls
			ACCESS_NOT_ACCESSIBLE,
			ACCESS_READ_ONLY,
			ACCESS_READ_WRITE,
			ACCESS_READ_CREATE,
			ACCESS_FOR_NOTIFY
		};

		// Symbols for the STATUS clause
		enum StatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_CURRENT,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	private:

		// Values for the various OBJECT-TYPE macro clauses
		AccessType _access;
		long _accessLine, _accessColumn;
		StatusType _status;
		long _statusLine, _statusColumn;
		SIMCIndexListV2 * _indexTypes;
		long _indexLine, _indexColumn;
		SIMCSymbol ** _augmentsClause;
		char * _unitsClause;
		long _unitsLine, _unitsColumn;

	public:
		SIMCObjectTypeV2( 	SIMCSymbol **syntax,
								    long syntaxLine, long syntaxColumn,
									const char * const units,
									long unitsLine, long unitsColumn,
									AccessType access,
									long accessLine, long accessColumn, 
									StatusType status,
									long statusLine, long statusColumn,
									SIMCIndexListV2 * indexTypes,
									long indexLine, long indexColumn,
									SIMCSymbol ** augmentsClause,
									const char * const description,
									long descriptionLine, long descriptionColumn,
									const char * const reference,
									long referenceLine, long referenceColumn,
									const char * const defValName,
									SIMCSymbol **defVal,
									long defValLine, long defValColumn);


	
		virtual ~SIMCObjectTypeV2();
		

		
		/*
		 *
		 * Lots of functions to get/set the various OBJECT-TYPE clauses
		 *
		 */
		void SetAccess(AccessType a)
		{
			_access = a;
		}

		AccessType GetAccess() const
		{
			return _access;
		}


		void SetStatus(StatusType s)
		{
			_status = s;
		}

		StatusType GetStatus() const
		{
			return _status;
		}

		void SetIndexTypes(SIMCIndexListV2 *l)
		{
			_indexTypes = l;
		}
	
		SIMCIndexListV2 * GetIndexTypes() const
		{
			return _indexTypes;
		}

		static AccessType StringToAccessType (const char * const s);

		static StatusType StringToStatusType (const char * const s);


		long GetAccessLine() const
		{
			return _accessLine;
		}

		void SetAccessLine(long x) 
		{
			_accessLine = x;
		}

		long GetAccessColumn() const
		{
			return _accessColumn;
		}

		void SetAccessColumn(long x) 
		{
			_accessColumn = x;
		}

		long GetStatusLine() const
		{
			return _statusLine;
		}

		void SetStatusLine(long x) 
		{
			_statusLine = x;
		}

		long GetStatusColumn() const
		{
			return _statusColumn;
		}

		void SetStatusColumn(long x) 
		{
			_statusColumn = x;
		}
		long GetIndexLine() const
		{
			return _indexLine;
		}

		void SetIndexLine(long x) 
		{
			_indexLine = x;
		}

		long GetIndexColumn() const
		{
			return _indexColumn;
		}

		void SetIndexColumn(long x) 
		{
			_indexColumn = x;
		}

		SIMCSymbol ** GetAugments() const
		{
			return _augmentsClause;
		}

		void SetAugments(SIMCSymbol **augmentsClause)
		{
			if(_augmentsClause && UseReferenceCount())
				(*_augmentsClause)->DecrementReferenceCount();
			_augmentsClause = augmentsClause;
			if(_augmentsClause)
				(*_augmentsClause)->IncrementReferenceCount();
		}

		long GetAugmentsLine() const
		{
			return _indexLine;
		}

		void SetAugmentsLine(long x) 
		{
			_indexLine = x;
		}

		long GetAugmentsColumn() const
		{
			return _indexColumn;
		}

		void SetAugmentsColumn(long x) 
		{
			_indexColumn = x;
		}

		const char *GetUnitsClause()
		{
			return _unitsClause;
		}
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\scanner.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_SCANNER_H
#define SIMC_SCANNER_H 

class SIMCParser;

/*
 * This is the SIMCScanner class that forms the scanner (tokenizer)
 * used by the SIMCParser class, which is the parser. The SIMCScanner
 * class is derived form the yy_scan class that is generated by the 
 * MKS LEX utility from the information in the lex.l file.
 *
 * It adds functionality to it, like column numbers, naming the
 * input stream, and redefining yyerror().
 */
class SIMCScanner : public yy_scan
{
		CString _inputStreamName;

		// The parser that is making use of this scanner currently.
		// This value *has* to be set by the parser, if it makes
		// a call to yy_scan::yyerror, since this value is used there
		SIMCParser *_theParser;
	public:

		// Create s scanner, by specifying a parser. If this is specified
		// as null, it has to be set using the SetParser() function, before
		// it is used
		SIMCScanner(SIMCParser * parser = NULL);
		~SIMCScanner();

		// Various ways of setting the input that is scanned. This is used as
		// the source. NOTE: Only the second one has been tested (ie., the
		// one that specifies an input file name
		BOOL SetInput(ifstream& inputStream);
		BOOL SetInput(const CString& inputFile);
		BOOL SetInput(const int fd = 0);
		BOOL SetInput(FILE * fileStream);
		
		// Column number. Make it public, as is the LEX tradition
		long columnNo;
		virtual void output(int);

		// Sets the parse that uses this scanner currently
		void SetParser(SIMCParser *parser)
		{
			_theParser = parser;
		}
		SIMCParser *GetParser() const
		{
			return _theParser;
		}

		// The redefinition of yy_scan.yyerror() to suit our needs
		// of error reporting
		virtual void yyerror (char *fmt, ...);

		inline const char * const GetInputStreamName() const
		{
			return _inputStreamName;
		}
		void SetInputStreamName( const CString& streamName);
};
	

#endif SIMC_SCANNER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\registry.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_REGISTRY_CONTROLLER
#define SIMC_REGISTRY_CONTROLLER

/* 
 * This file contains the classes that are used to manipulate the
 * registry by the SNMP Compiler. The compiler stores MIB dependency
 * information in the registry, as per the "compiler requirements spec"
 */

// The class that represents the mapping between a file name
// and a module name
class SIMCFileMapElement
{
	public:
		CString fileName;
		CString moduleName;
		SIMCFileMapElement(const CString mName, const CString fName)
			: moduleName(mName), fileName(fName)
		{}
		SIMCFileMapElement() {}
};

// A list of such mappings
typedef CList<SIMCFileMapElement, SIMCFileMapElement> SIMCFileMapList;


// The class that controls the registry, and has functions for retreiving
// mappings, adding/deleting mappings etc. from the registry. Most
// functions are static
class SIMCRegistryController
{
	private:

		// The keys in the registry that the SNMP compiler uses.
		// These are defined in the "compiler requirements spec"
		static const char *rootKeyName;
		static const char *filePaths;
		static const char *fileSuffixes;
		static const char *mibTable;
 		
		// Checks whether the file name is a path name
		static BOOL IsAbsolutePath(CString pathName);

		static BOOL GetMibFileFromMap(const SIMCFileMapList& theList, 
			const CString& module, 
			CString &file);

		static BOOL ShouldAddDependentFile(SIMCFileMapList& dependencyList,
				  const CString& dependentModule,
				  CString& dependentFile,
				  const SIMCFileMapList& priorityList);

		static BOOL IsModulePresent(SIMCFileMapList& dependencyList,
											  const CString& dependentModule);
		static BOOL IsFilePresent(SIMCFileMapList& dependencyList,
											  const CString& dependentFile);
		
	public:
		// Gets the entry from the lookup table
		static BOOL GetMibFileFromRegistry(const char * const moduleName, 
			CString &fullPathName);

		// Prints out the lookup table on to stdout
		static BOOL ListMibTable();

		// Gets the list of suffixes from teh registry
		static BOOL GetMibSuffixes(SIMCStringList & theList);

		// Gets the list of paths from teh registry
		static BOOL GetMibPaths(SIMCStringList & theList);

		// Deletes the lookup table from the registry
		static BOOL DeleteMibTable();

		// Deletes the lookup table and rebuilds it.
		// Returns the # of entries entered
		static long RebuildMibTable();

		// Builds the lookup table afresh, and gets it
		static long GetFileMap(SIMCFileMapList &theList);

		// Adds the mappings from a directory to theList
		static long RebuildDirectory(const CString& directory, 
					const SIMCStringList& suffixList,
					SIMCFileMapList &theList);

		// Adds the mapping of a file to theList
		static BOOL ProcessFile(const char * const fileName,
					SIMCFileMapList &theList);
		
		// Given a priority list of mappings, builds a dependency list
		// using a depth first search using the priority mappings first,
		// and then the registry lookup table to locate any required mib modules
		static BOOL GetDependentModules(const char * const fileName,
					SIMCFileMapList& dependencyList,
					const SIMCFileMapList& priorityList);
		
		// Deletes a specified directory from the list of paths in the registry
		static BOOL DeleteRegistryDirectory(const CString& directoryName);
		
		// Adds a specified directory to the list of paths in the registry
		static BOOL AddRegistryDirectory(const CString& directoryName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\parsetree.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_PARSE_TREE_H
#define SIMC_PARSE_TREE_H

typedef CList<int, int> SIMCCleanOidValue;
ostream& operator << (ostream& outStream, const SIMCCleanOidValue& obj);

/*
 * SIMCParseTree - This is derived from the SIMCAbstractParseTree class
 * and provides implementation of all the pure virtual functions in it (the
 * semantic checking functions).
 * It uses the dll "smierrsy.dll" to hold the strings for the error messages
 * that it generates while checking semantics.
 * It uses the error container of the base class to place these messages.
 */
class SIMCParseTree : public SIMCAbstractParseTree
{
		// An OID tree that spans all modules.
		// Constructed as an aid to semantic checking
		SIMCOidTree _theTree;

		// The lowest semantic error Id
		static const int SEMANTIC_ERROR_BASE;
		
		// The size of the buffer used to construct an error message
		static const int MESSAGE_SIZE;


	public:

		// The resource-only dll with semantic error text string table
		static  HINSTANCE semanticErrorsDll;

		// Accept an error container to put the error messages in.
		SIMCParseTree(SIMCErrorContainer * ec)
			: SIMCAbstractParseTree(ec)
		{
			if ( semanticErrorsDll == NULL )
				semanticErrorsDll = LoadLibrary(SIMCParser::semanticErrorsDllFile);
		}

		// Severity levels for the various erro messages generated
		// by this class
		enum SeverityLevel
		{
			INVALID,
			FATAL,
			WARNING,
			INFORMATION
		};

		// A function for constructing the error messages, to be put into
		// the error container
		void SemanticError(const char *const inputStreamName, int errorType,
			int lineNo,
			int columnNo,
			...);
	
		// Resolve the forward references and the external references. 
		// See the description in SIMCAbstractParseTree
		virtual BOOL Resolve(BOOL local);
		
	// Privately used functions, in Resolve()
	private:
		BOOL SetResolutionStatus();
		BOOL SetRootAll();
		BOOL SetDefVal();
		BOOL ResolveModule(SIMCModule *m, BOOL local);
		BOOL ResolveImportModule(SIMCModule *m, BOOL local);
		BOOL ResolveSymbol(SIMCSymbol **symbol, BOOL local);
		
	public:		
		// Check the Semantics of the modules 
		// See the description in SIMCAbstractParseTree
		virtual BOOL CheckSemantics(BOOL local = FALSE);

		// A user will rarely use this function. It gets him the
		// OID tree that spans all the modules fed into the
		// SIMCParseTree, till now.
		const SIMCOidTree *GetOidTree() const
		{
			return &_theTree;
		}
		// A user will rarely use this function. It converts an unclean
		// OID value (SIMCOidValue) (ie, one that has references to symbols)
		// to a clean OID value (SIMCCleanOidValue) (ie, one in which all the
		// components are integer values)
		SIMCResolutionStatus GetCleanOidValue( const char *const filename,
							SIMCOidValue * input,
							SIMCCleanOidValue& result,
							BOOL local); 

	
	// Privately used functions, in CheckSemantics()
	// These functions check the various MIB constructs.
	private:
		// Steps thru the symbol table and calls CheckSymbol() on each function
		BOOL CheckModule(SIMCModule *, BOOL);
		// Uses RTTI to check the type of the symbol and calls
		// CheckBuiltInTypeRef() or CheckDefinedTypeRef() or
		// CheckBuiltInValueRef() or CheckDefinedValueRef() or
		// CheckTextualConvention().
		BOOL CheckSymbol(SIMCSymbol **, BOOL);

		// Check type references
		BOOL CheckBuiltInTypeRef(SIMCBuiltInTypeReference *symbol, BOOL);
		BOOL CheckDefinedTypeRef(SIMCDefinedTypeReference *symbol, BOOL);
		BOOL CheckTextualConvention(SIMCTextualConvention *symbol, BOOL local);
		// Check types
		BOOL CheckRangeTypeV0(const char *const fileName,
			SIMCRangeType *rangeType, BOOL);
		BOOL CheckRangeTypeV1(const char *const fileName,
			SIMCRangeType *rangeType, BOOL);
		BOOL CheckRangeTypeV2(const char *const fileName,
			SIMCRangeType *rangeType, BOOL);
		BOOL CheckRangeRange(const SIMCRangeList *baseList);
		BOOL CheckSizeTypeV1(const char *const fileName,
			SIMCSizeType *sizeType, BOOL);
		BOOL CheckSizeTypeV0(const char *const fileName,
			SIMCSizeType *sizeType, BOOL);
		BOOL CheckSizeTypeV2(const char *const fileName,
			SIMCSizeType *sizeType, BOOL);
		BOOL CheckEnumTypeV0(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL);
		BOOL CheckEnumTypeV1(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL);
		BOOL CheckEnumTypeV2(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL);
		BOOL CheckBitsTypeV2(const char *const fileName,
			SIMCEnumOrBitsType *bitsType, BOOL local);
		BOOL CheckSequenceOfType(const char *const fileName,
			SIMCSequenceOfType *sequenceOfType, BOOL);
		BOOL CheckSequenceType(const char *const fileName,
			SIMCSequenceType *sequenceType, BOOL);
		BOOL CheckTrapType(const char *const fileName,
			SIMCTrapTypeType *trapType, BOOL);
		BOOL CheckNotificationType(const char *const fileName,
			SIMCNotificationTypeType *notificationType, BOOL);
		BOOL CheckObjectIdentityType(const char *const fileName, 
			SIMCObjectIdentityType *rhs, BOOL local);
		BOOL CheckObjectTypeV1(const char *const fileName,
			SIMCObjectTypeV1 *objectType, BOOL);
		BOOL CheckObjectTypeV2(const char *const fileName,
			SIMCObjectTypeV2 *objectType, BOOL);
		BOOL CheckObjectTypeV1Syntax(const char *const fileName,
			SIMCObjectTypeV1 *objectType, BOOL local);
		BOOL CheckObjectTypeV2Syntax(const char *const fileName,
			SIMCObjectTypeV2 *objectType, BOOL local);
		BOOL CheckObjectTypeV1Index(const char *const fileName,
			SIMCSymbol *objectTypeSymbol,
			SIMCObjectTypeV1 *objectType, BOOL local);
		BOOL CheckObjectTypeV2Index(const char *const fileName,
			SIMCSymbol *objectTypeSymbol,
			SIMCObjectTypeV2 *objectType, BOOL local);
		BOOL CheckObjectTypeDefVal(const char *const fileName,
			SIMCObjectTypeType *objectType, BOOL local);


		// Check value references
		BOOL CheckBuiltInValueRef(SIMCBuiltInValueReference *symbol, BOOL);
		BOOL CheckDefinedValueRef(SIMCDefinedValueReference *symbol, BOOL);
		
		BOOL CheckObjectTypeValueAssignmentV1(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCObjectTypeV1 *objectType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckObjectTypeValueAssignmentV2(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCObjectTypeV2 *objectType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckTrapTypeValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCTrapTypeType *trapType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckNotificationTypeValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCNotificationTypeType *notificationType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckObjectIdentityValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef, 
										SIMCBuiltInTypeReference *btRef,
										SIMCObjectIdentityType *type, 
										SIMCValue *value, 
										BOOL local);
		BOOL CheckEnumValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCEnumOrBitsType *enumType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckSubTypeValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCSubType *subType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckPrimitiveValueAssignment(const char * const fileName, 
										SIMCBuiltInValueReference *bvRef, 
										SIMCTypeReference *btRef,
										SIMCValue *value, 
										BOOL local);
		BOOL CheckBitsTypeValueAssignment(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCEnumOrBitsType *bitsType,
								SIMCValue *value, 
								BOOL local);

		BOOL MatchSequenceObjectTypeSyntax(const char *const fileName,
					SIMCObjectTypeType *objectType, 
					SIMCTypeReference *typeRef,
					SIMCSequenceItem *item,
					BOOL local);
	
		BOOL CheckObjectSequenceItem( const char *const fileName,
								SIMCSequenceItem * item, 
								SIMCValueReference *parentObjectType,
								BOOL local);
		BOOL CheckObjectSequenceOfTypeV1(const char *const fileName,
								SIMCObjectTypeV1 *objType,
								SIMCSequenceOfType *sequenceOfType, 
								BOOL local);
		BOOL CheckObjectSequenceOfTypeV2(const char *const fileName,
								SIMCObjectTypeV2 *objType,
								SIMCSequenceOfType *sequenceOfType, 
								BOOL local);
		BOOL CheckObjectSequenceTypeV1(const char *const fileName,
								SIMCObjectTypeV1 *objType,
								SIMCSequenceType *sequenceType, 
								BOOL local);
		BOOL CheckObjectSequenceTypeV2(const char *const fileName,
								SIMCObjectTypeV2 *objType,
								SIMCSequenceType *sequenceType, 
								BOOL local);


		// Build the OID tree for all the modules.
		// Calls BuildModuleOidTree() on each module
		BOOL BuildOidTree(BOOL local);
		// Builds OID tree for a module
		BOOL BuildModuleOidTree(SIMCModule *m, BOOL);
		// Makes Semantic checks on the OID tree.
		BOOL CheckOidTree(BOOL local);
 
		// Converts TRAP-TYPEs, if any to NOTIFICATION-TYPES
		// Then fabricates NOTIFICATION-GROUPs from NOTIFICATION-TYPEs
		BOOL FabricateNotificationGroups();

		// The recursive routine called by GetCleanOidValue()
		SIMCResolutionStatus GetCleanOidValueRec( const char *const fileName,
								SIMCOidValue * input,
								SIMCCleanOidValue& result,
								BOOL local,
								SIMCSymbolList& checkedList); 
	

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\smierrsm.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by smierrsm.rc
//
#define OBJ_TYPE_SYNTAX_RESOLUTION      1
#define OBJ_TYPE_INVALID_ACCESS         2
#define OBJ_TYPE_INVALID_STATUS         3
#define OBJ_TYPE_SINGULAR_COUNTER       4
#define OBJ_TYPE_ACCESSIBLE_TABLE       5
#define OBJ_TYPE_SEQUENCE_NO_INDEX      6
#define OBJ_TYPE_SEQUENCE_MULTI_REFERENCE 7
#define OBJ_TYPE_SEQUENCE_UNUSED        8
#define SEQUENCE_WRONG_CHILD            9
#define OBJ_TYPE_WRONG_CHILD            10
#define OBJ_TYPE_SEQUENCE_INVALID_SYNTAX 11
#define OBJ_TYPE_INDEX_UNNECESSARY      12
#define INVALID_SEQUENCE_OF             13
#define OBJ_TYPE_ZERO_IN_OID            14
#define ZERO_IN_OID                     14
#define OBJ_TYPE_DUPLICATE_OID          15
#define OBJ_TYPE_INVALID_DEFVAL         16
#define OBJ_TYPE_OID_RESOLUTION         17
#define TRAP_TYPE_ENTERPRISE_RESOLUTION 18
#define TRAP_TYPE_DUPLICATE_VALUES      19
#define TRAP_TYPE_VALUE_RESOLUTION      20
#define TRAP_TYPE_VARIABLES_RESOLUTION  21
#define VALUE_ASSIGN_MISMATCH           22
#define VALUE_ASSIGN_RESOLUTION         23
#define OID_NEGATIVE_INTEGER            24
#define OID_RESOLUTION                  25
#define OID_HEAD_ERROR                  26
#define IMPORT_UNUSED                   27
#define IMPORT_MODULE_ABSENT            28
#define IMPORT_CURRENT                  29
#define IMPORT_SYMBOL_ABSENT            30
#define IMPORT_KNOWN_WRONG_MODULE       31
#define ENUM_DUPLICATE_VALUE            32
#define ENUM_DUPLICATE_NAME             33
#define ENUM_ZERO_VALUE                 34
#define ENUM_NEGATIVE_VALUE             35
#define ENUM_RESOLUTION                 36
#define SIZE_TYPE_RESOLUTION            37
#define RANGE_TYPE_RESOLUTION           38
#define SIZE_INVALID_VALUE              39
#define SIZE_VALUE_RESOLUTION           40
#define RANGE_VALUE_RESOLUTION          41
#define RANGE_INVALID_BOUNDS            42
#define OBJ_TYPE_ACCESSIBLE_ROW         43
#define SYMBOL_REDEFINITION             44
#define KNOWN_REDEFINITION              45
#define KNOWN_UNDEFINED                 46
#define TYPE_UNREFERENCED               47
#define VALUE_UNREFERENCED              48
#define OBJ_TYPE_DEFVAL_NET_ADDR        49
#define SYMBOL_UNDEFINED                50
#define IMPORT_AMBIGUOUS_REFERENCE      51
#define OBJ_TYPE_DEFVAL_DISALLOWED      52
#define OBJ_TYPE_DEFVAL_RESOLUTION      53
#define OBJ_TYPE_INDEX_RESOLUTION       54
#define OBJ_TYPE_INDEX_SYNTAX           55
#define TYPE_UNRESOLVED                 56
#define VALUE_UNRESOLVED                57
#define SUBTYPE_ROOT_RESOLUTION         58
#define VALUE_ASSIGN_INVALID            60
#define RANGE_NEGATIVE_GAUGE            62
#define SIZE_INVALID_BOUNDS             63
#define SEQUENCE_ITEM_NO_OBJECT         64
#define SEQUENCE_TYPE_UNRESOLVED        65
#define INTEGER_TOO_BIG                 66
#define VALUE_ASSIGN_ENUM_INVALID       68
#define VALUE_ASSIGN_NEGATIVE_INTEGER   69
#define IR_MODULE_MISSING               70
#define IR_MODULE_MISSING_FATAL         70
#define IR_SYMBOL_MISSING               71
#define IR_SYMBOL_MISSING_FATAL         71
#define OBJ_TYPE_PRIMITIVE_CHILD        72
#define OBJ_TYPE_SEQUENCE_CHILD         73
#define OBJ_TYPE_SEQUENCE_NO_PARENT     74
#define OBJ_TYPE_SEQUENCE_EXTRA_CHILD   75
#define OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD 76
#define OBJ_TYPE_SEQUENCE_OF_SYNTAX_MISMATCH 77
#define OBJ_TYPE_SEQUENCE_OF_EXTRA_CHILD 78
#define STANDARD_AMBIGUOUS_REFERENCE    79
#define IR_MODULE_MISSING_WARNING       80
#define IR_SYMBOL_MISSING_WARNING       81
#define OBJ_IDENTITY_INVALID_STATUS     82
#define MODULE_NO_GROUPS                83
#define MODULE_IDENTITY_MISSING         84
#define MODULE_NO_GROUPS_V1             85
#define MODULE_NO_GROUPS_V2             86
#define TC_INVALID_STATUS               87
#define INVALID_BIT_VALUE               88
#define AUGMENTS_CLAUSE_RESOLUTION      89
#define IMPLIED_USELESS                 90
#define IMPLIED_FIXED_SIZE              91
#define IMPLIED_POSSIBLE_ZERO_SIZE      92
#define V1_ENUM_ONLY_INTEGER            93
#define V2_ENUM_ROOT_RESOLUTION         94
#define V2_ENUM_CLOSURE                 95
#define V2_BITS_ROOT_RESOLUTION         96
#define BITS_VALUE_RESOLUTION           97
#define BITS_DUPLICATE_VALUE            98
#define BITS_DUPLICATE_NAME             99
#define ENUM_OR_BITS_RESOLUTION         100
#define RANGE_BIG_RANGE                 101
#define NOTIFICATION_TYPE_INVALID_STATUS 102
#define OBJECT_IDENTITY_VALUE_RESOLUTION 103
#define NOTIFICATION_TYPE_VALUE_RESOLUTION 104
#define NOTIFICATION_TYPE_OBJECTS_RESOLUTION 105
#define NOTIFICATION_TYPE_UNACCESSIBLE_OBJECT 106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\smimsgif.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by D:\pandorang\snmpProvider\Compilers\smi2smir\lib\smimsgif\smimsgif.rc
//
#define COMPILED_FILE                   1
#define SYNTAX_CHECK_FAILED             2
#define SEMANTIC_CHECK_FAILED           3
#define SMIR_LOAD_FAILED                4
#define SMIR_LOAD_SUCCEEDED             5
#define SYNTAX_CHECK_SUCCEEDED          6
#define SEMANTIC_CHECK_SUCCEEDED        7
#define SYMBOL_RESOLUTION_FAILED        8
#define SMIR_CONNECT_FAILED             9
#define LISTING_MODULES                 10
#define LISTING_FAILED                  11
#define DELETE_SUCCEEDED                12
#define DELETE_FAILED                   13
#define PURGE_SUCCEEDED                 14
#define PURGE_FAILED                    15
#define DELETE_MODULE_NOT_FOUND         16
#define SMI2SMIR_INFO                   17
#define FILE_NOT_FOUND                  18
#define MODULE_LISTING                  19
#define MOF_GENERATION_SUCCEEDED        20
#define MOF_GENERATION_FAILED           21
#define MODULE_NAME_SUCCEEDED           22
#define MODULE_INFO_FAILED              23
#define NUMBER_OF_ENTRIES               24
#define DUPLICATE_MODULES               25
#define DIRECTORY_ADDITION_SUCCEEDED    26
#define DIRECTORY_ADDITION_FAILED       27
#define DIRECTORY_DELETION_SUCCEEDED    28
#define DIRECTORY_DELETION_FAILED       29
#define INVALID_MIB_FILE                30
#define PURGE_CONFIRMATION              31
#define MODULE_LISTING_NO_MODULES       31
#define LISTING_MIB_PATHS               32
#define LISTING_MIB_PATHS_NONE          33
#define MIB_PATH_LISTING                34

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\smierrsy.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by smierrsy.rc
//
#define SYNTAX_CLAUSE                   1
#define ACCESS_CLAUSE                   2
#define STATUS_CLAUSE                   3
#define DESCRIPTION_CLAUSE              4
#define REFERENCE_CLAUSE                5
#define INDEX_CLAUSE                    6
#define DEFVAL_CLAUSE                   7
#define SKIPPING_OBJECT_TYPE            8
#define ENTERPRISE_CLAUSE               9
#define VARIABLES_CLAUSE                10
#define SKIPPING_TRAP_TYPE              11
#define SEQUENCE_DEFINITION             12
#define OBJECT_IDENTIFIER_VALUE         13
#define LIST_IN_IMPORTS                 14
#define MISSING_MODULE_NAME             15
#define IMPORTS_SECTION                 16
#define INTEGER_ENUMERATION             17
#define SUB_TYPE_SPECIFICATION          18
#define SIZE_SPECIFICATION              19
#define V2_OBJECT_TYPE_DISALLOWED       20
#define NOTIFICATION_TYPE_DISALLOWED    22
#define MODULE_IDENTITY_DISALLOWED      23
#define OBJECT_IDENTITY_DISALLOWED      24
#define TEXTUAL_CONVENTION_DISALLOWED   25
#define OBJECT_GROUP_DISALLOWED         26
#define NOTIFICATION_GROUP_DISALLOWED   27
#define MODULE_COMPLIANCE_DISALLOWED    28
#define AGENT_CAPABILITIES_DISALLOWED   29
#define INSTEAD_OF_CCE                  30
#define SYNTAX_ERROR_MAX                31
#define ERROR_OBJECT_TYPE               31
#define SYNTAX_ERROR_MAX1               32
#define MAX_SYNTAX_ERROR                32
#define V1_OBJECT_TYPE_DISALLOWED       32
#define V1_TRAP_TYPE_DISALLOWED         33
#define MODULE_IDENTITY_ONLY_AFTER_IMPORTS 34
#define UNRECOGNIZED_CHARACTER          35
#define TOO_BIG_NUM                     36
#define UNTERMINATED_STRING             37
#define OBJECTS_CLAUSE                  38
#define NAME_INSTEAD_OF_ID              39

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\stackvalues.hpp ===
//
//	Copyright (c) 1997-2001 Microsoft Corporation
//
#ifndef SIMC_STACK_VALUES_H
#define SIMC_STACK_VALUES_H

// The declarations for the various values passed up using the stack
// of the parser. A user of the parser never needs to understand the contents
// of this file.

// The $$ for the DefVal clause. This is a bit of a kludge.
class SIMCDefValInfo
{
	public:
		char *name;
		SIMCSymbol **symbol;
		long line, column;
		SIMCDefValInfo(char *n, SIMCSymbol **s, long l, long c)
			: symbol(s), line(l), column(c)
		{
			name = NewString(n);
		}
		~SIMCDefValInfo()
		{
			if(name)
				delete name;
		}
};

class SIMCIndexInfo
{
	public:
		SIMCIndexList *indexList;
		long line, column;
		SIMCIndexInfo(SIMCIndexList *list, long l, long c)
			: indexList(list), line(l), column(c)
		{}
};

class SIMCIndexInfoV2
{
	public:
		SIMCIndexListV2 *indexList;
		SIMCSymbol **augmentsClause;
		long line, column;
		SIMCIndexInfoV2(SIMCIndexListV2 *list, long l, long c, SIMCSymbol **augments = NULL)
			: indexList(list), line(l), column(c), augmentsClause(augments)
		{}
};

class SIMCNameInfo
{
	public:
		char *name;
		long line, column;
		SIMCNameInfo(char *n, long l, long c)
			: line(l), column(c)
		{
			name = NewString(n);
		}

		virtual ~SIMCNameInfo()
		{
			delete(name);
		}
};

class SIMCNumberInfo
{
	public:
		long number;
		BOOL isUnsigned;
		long line, column;
		SIMCNumberInfo(long n, long l, long c, BOOL u)
			: number(n), line(l), column(c), isUnsigned(u)
		{}

};

class SIMCHexStringInfo
{
	public:
		char *value;
		long line, column;
		SIMCHexStringInfo(char *v, long l, long c)
			: line(l), column(c)
		{
			value = NewString(v);
		}

		virtual ~SIMCHexStringInfo()
		{
			delete(value);
		}
};

typedef SIMCHexStringInfo SIMCBinaryStringInfo;


enum SIMCValueContents {	NAME_INFO, 
							NUMBER_INFO, 
							HEX_STRING_INFO, 
							BINARY_STRING_INFO,
							BIT_INFO
						};

class SIMCValueInfo
{
	public:
		enum SIMCValueContents contents;
		union
		{
			SIMCNameInfo *nameInfo;
			SIMCNumberInfo *numberInfo;
			SIMCHexStringInfo *hexStringInfo;
			SIMCBinaryStringInfo *binaryStringInfo;
			SIMCBitsValue *bitsValueInfo;
		};
};


class SIMCAccessInfo
{
	public:
		SIMCObjectTypeV1::AccessType a;
		long line, column;
		SIMCAccessInfo(SIMCObjectTypeV1::AccessType n, long l, long c)
			: a(n), line(l), column(c)
		{}

};

class SIMCAccessInfoV2
{
	public:
		SIMCObjectTypeV2::AccessType a;
		long line, column;
		SIMCAccessInfoV2(SIMCObjectTypeV2::AccessType n, long l, long c)
			: a(n), line(l), column(c)
		{}

};

class SIMCStatusInfo
{
	public:
		SIMCObjectTypeV1::StatusType a;
		long line, column;
		SIMCStatusInfo(SIMCObjectTypeV1::StatusType n, long l, long c)
			: a(n), line(l), column(c)
		{}

};

class SIMCStatusInfoV2
{
	public:
		SIMCObjectTypeV2::StatusType a;
		long line, column;
		SIMCStatusInfoV2(SIMCObjectTypeV2::StatusType n, long l, long c)
			: a(n), line(l), column(c)
		{}

};

class SIMCObjectIdentityStatusInfo
{
	public:
		SIMCObjectIdentityType::StatusType a;
		long line, column;
		SIMCObjectIdentityStatusInfo(SIMCObjectIdentityType::StatusType n, 
			long l, long c)
			: a(n), line(l), column(c)
		{}
};

class SIMCNotificationTypeStatusInfo
{
	public:
		SIMCNotificationTypeType::StatusType a;
		long line, column;
		SIMCNotificationTypeStatusInfo(SIMCNotificationTypeType::StatusType n, 
			long l, long c)
			: a(n), line(l), column(c)
		{}
};

class SIMCSymbolReference
{
	public:
		SIMCSymbol  **s;
		long line, column;
		SIMCSymbolReference(SIMCSymbol **n, long l, long c)
			: s(n), line(l), column(c)
		{}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\parser.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_PARSER_H
#define SIMC_PARSER_H


/* This file contains the SIMCParse class, which is the parsing engine
 * for parsing MIB files, and it works with the SIMCScanner class, which
 * is the tokenizing engine
 */


/* 
 * The SIMCParser class is derived form the yy_parse class that is
 * generated by the MKS YACC utility, using the information
 * provided in the yacc.y file. This uses the class SIMCScanner as its
 * scanner. SIMCScanner is derived form the class yy_scan that is generated
 * by the MKS LEX utility, using the information provided by the lex.l
 * file.
 * This uses 2 dlls "smierrsy.dll" and "smierrsm.dll" to hold the
 * strings that represent the syntax errors and semantic errors
 * respectively.
 * It uses an SIMCErrorContainer object to put the error messages, it
 * generates.
 * It put the parse information generated for a single parse, info
 * an SIMCModule object.
 * It "knows" about the commonly occuring SMI symbols, like "ip",
 * "transmission" etc., as defined in the "compiler requirements spec".
 */

class SIMCParser : public yy_parse
{
	
	// The size of the buffer used to construct an error message
	static const int MESSAGE_SIZE;

	// The lowest syntax error Id
	static const int SYNTAX_ERROR_BASE;

	// The lowest parser semantic error Id
	static const int SEMANTIC_ERROR_BASE;

	// The text for the various severity levels enumerated by 
	// enum severityLevel
	static const char * const severityLevels[];

	// The place to put the error messages
	SIMCErrorContainer *_errorContainer;	

	// The information collected from the module
	SIMCModule * _module;

	// The flag that is used to decide whether to parse the next module as
	// a V1 or a V2 one. Used by Parse()
	int _snmpVersion;

	// Used to set those pesky references that are initially beleived to be forward
	// references, but actually are references to imported symbols.
	BOOL SetImportSymbols();

	// A count of errors, for each call of Parse()
	long _fatalCount, _warningCount, _informationCount;

	public:

		// The resource-only dll with parser error text string table
		static  HINSTANCE semanticErrorsDll;

		// The resource-only dll with syntax error text string table
		static  HINSTANCE syntaxErrorsDll;

 
		// You always need an error container and a scanner, to parse
		SIMCParser(SIMCErrorContainer * errorContainer, SIMCScanner * scanner);
		
		virtual ~SIMCParser();


 		// The names of the dlls
		static const char * const semanticErrorsDllFile;
		static const char * const syntaxErrorsDllFile;


		// The scanner associated with this parser
		SIMCScanner *_theScanner;

		// ---------------- The symbols known by the parser ---------------------
		SIMCModule	*other,		// Modules common to V1 and V2
					*rfc1155,	// These are V1 only
					*rfc1213, 
					*rfc1212, 
					*rfc1215, 
					*rfc1230, 
					*rfc1902,	// These are V2 only
					*rfc1903,
					*rfc1904,
					*rfc1906;

		SIMCSymbol	**objectIdentifierType,  // These are primitive ASN.1 types 
					**integerType, 
					**octetStringType,
					**nullType, 
					**bitsType, 
					**booleanType;

		SIMCSymbol							// These are V1 OIDs
					**isoV1, 				
					**ccittV1, 
					**jointIsoCcittV1,
					**internetV1, 
					**directoryV1, 
					**mgmtV1, 
					**experimentalV1,
					**privateV1, 
					**enterprisesV1, 
					**mib2V1, 
					**ipV1, 
					**interfacesV1,
					**transmissionV1,
					**zeroDotZeroV2,
					**orgV2,				// These are V2 OIDs
					**dodV2,
					**internetV2,
					**directoryV2,
					**mgmtV2,
					**mib2V2,
					**ipV2,
					**interfacesV2,
					**transmissionV2,
					**experimentalV2,
					**privateV2,
					**enterprisesV2,
					**securityV2,
					**snmpV2V2,
					**snmpDomainsV2,
					**snmpProxysV2,
					**snmpModulesV2,
					**snmpUDPDomainV2,
					**snmpCLNSDomainV2,
					**snmpCONSDomainV2,
					**snmpDDPDomainV2,
					**snmpIPXDomainV2,
					**rfc1157DomainV2,
					**rfc1157ProxyV2;

		SIMCSymbol	**trueValueReference,  // Some values 
					**falseValueReference, 
					**nullValueReference;
		
		// Symbols for the severity levels of the messages
		enum SeverityLevel
		{
			INVALID,
			FATAL,
			WARNING,
			INFORMATION
		};
		
		// Manipulate the SNMP version of this parser. Parsing is done based
		// on this value, as follows
		// 1 - SNMPv2 SMI
		// 2 - SNMPv2 SMI
		// 0 - Union of V1 and V2 SMIs
		int GetSnmpVersion() const
		{
			return _snmpVersion;
		}
		BOOL SetSnmpVersion( int x )
		{
			switch(x)
			{
				case 0:		// '0' means union of v1 and v2 SMIs
				case 1:
				case 2:
					_snmpVersion = x;
					return TRUE;
				default:
					_snmpVersion = 0;
					return FALSE;
			}
		}

		/*
		 * The main parsing function that is called by the user
		 * Return TRUE if the parse is successful. The GetModule() function
		 * may then be called to retrieve the parsed information.
		 * It it returns false, check the error container for error
		 * messages
		 */
		BOOL Parse();

		// A function to generate syntax error messages
		void SyntaxError(int errorType, 
			int lineNo = -1, 
			int columnNo = -1,
			char *lastToken = NULL, char *infoString = NULL);

		// Convert severity level to "readable" form
		const char * const GetSeverityString(int severityLevel)
		{
			return severityLevels[severityLevel];
		}

		// A function to generate semantic error messages
		void SemanticError(const char * const fileName, int errorType,
			int lineNo,
			int columnNo,
			...);

		// Get the parsed information, after a successful call to Parse()
		SIMCModule * GetModule() const;

		void SetErrorContainer(SIMCErrorContainer *errorContainer)
		{
			if(errorContainer)
				_errorContainer = errorContainer;
		}
		SIMCErrorContainer * GetErrorContainer() const
		{
			return _errorContainer;
		}
		void SetScanner( SIMCScanner * scanner)
		{
			_theScanner = scanner;
		}

		/*
		 * Utility functions that are used in Parse(), and also
		 * can be used by the user of this class.
		 *
		 */

		// TRUE, if the symbol specified, is viewed as a symbol
		// "known" to the parser, from the module specified, as per
		// SNMPV1 SMI rules
		static BOOL IsReservedSymbolV1(const char *const name,
						const char * const moduleName);
		// Returns the module in which this "known" symbol is defined, as
		// per the SNMPV1 SMI. Return null if the symbol is "unknown"
		const SIMCModule* IsReservedSymbolV1(const char * const symbolName);
		
		// TRUE, if the symbol specified, is viewed as a symbol
		// "known" to the parser, from the module specified, as per
		// SNMPV2 SMI rules
		static BOOL IsReservedSymbolV2(const char *const name,
						const char * const moduleName);
		// Returns the module in which this "known" symbol is defined, as
		// per the SNMPV2 SMI. Return null if the symbol is "unknown"
		const SIMCModule* IsReservedSymbolV2(const char * const symbolName);

		// Another way of using the above functions
		const SIMCModule* IsReservedSymbol(const char * const symbolName);
		BOOL IsReservedSymbol(const char *const name, const char * const moduleName);
		static BOOL IsReservedSymbol(long snmpVersion, const char *const name,
						const char * const moduleName);
	
		// TRUE, if the module specified, is viewed as a module
		// "known" to the parser, as per SNMPV1 SMI rules
		static BOOL IsReservedModuleV1(const char *const name);
		// TRUE, if the module specified, is viewed as a module
		// "known" to the parser, as per SNMPV2 SMI rules
		static BOOL IsReservedModuleV2(const char *const name);
		// Another way of using the above functions
		static BOOL IsReservedModule(long snmpVersion, const char *const name);
	
		// Used in error-tolerance. Never called by the user
		static const char * GetCorrectModuleNames(const char * const symbolName);

		// Helper functions
		void DoImportModule( SIMCModule *mainModule, SIMCModule *importModule);
		void CreateReservedModules();
		void RemoveExtraneousReservedModule(SIMCModule *module);

		// Generate a unique name of the form "*n" for an anonymnous symbol.
		// n is an integer
		char * GenerateSymbolName()
		{
			static long n = 1;
			char buf[25];
			buf[0] = '*';
			sprintf(buf+1, "%ld", n++);
			return NewString(buf);
		}
		


		long GetFatalCount() const
		{
			return _fatalCount;
		}
		long GetWarningCount() const
		{
			return _warningCount;
		}
		long GetInformationCount() const
		{
			return _informationCount;
		}


};


#endif // SIMC_PARSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\traptype.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef TRAP_TYPE_TYPE
#define TRAP_TYPE_TYPE

/*
 * This file contains the class that models the TRAP-TYPE macro
 * and other associated classes
 */

// Each of the variables in the VARIABLES clause
class SIMCVariablesItem
{
	public:
		SIMCSymbol **_item;
		long _line, _column;
		SIMCVariablesItem( SIMCSymbol **item, long line, long column)
			: _item(item), _line(line), _column(column)
		{}
};

// A list of items in the VARIABLES clause
typedef  CList<SIMCVariablesItem *, SIMCVariablesItem *> SIMCVariablesList;

/*
 * This class models the TRAP-TYPE macro of SNMPV1 SMI. 
 */
class SIMCTrapTypeType : public SIMCType
{
		// The various clauses of the TRAP-TYPE macro
		SIMCSymbol ** _enterprise;
		long _enterpriseLine, _enterpriseColumn;
		SIMCVariablesList *_variables;
		char * _description;
		long _descriptionLine, _descriptionColumn;
		char *_reference;
		long _referenceLine, _referenceColumn;

	public:
		SIMCTrapTypeType( SIMCSymbol **enterprise,
							long enterpriseLine, long enterpriseColumn,
							SIMCVariablesList *variables,
							char * description,
							long descriptionLine, long descriptionColumn,
							char *reference,
							long referenceLine, long referenceColumn);

		~SIMCTrapTypeType();

		SIMCSymbol ** GetEnterprise() const
		{
			return _enterprise;
		}
		SIMCVariablesList* GetVariables() const
		{
			return _variables;
		}
		char *GetDescription() const
		{
			return _description;
		}
		char *GetReference() const
		{
			return _reference;
		}

		virtual void WriteType(ostream& outStream) const;
		
		long GetEnterpriseLine() const
		{
			return _enterpriseLine;
		}

		void SetEnterpriseLine( long x) 
		{
			_enterpriseLine = x;
		}

		long GetEnterpriseColumn() const
		{
			return _enterpriseColumn;
		}

		void SetEnterpriseColumn( long x) 
		{
			_enterpriseColumn = x;
		}

		long GetDescriptionLine() const
		{
			return _descriptionLine;
		}

		void SetDescriptionLine( long x) 
		{
			_descriptionLine = x;
		}

		long GetDescriptionColumn() const
		{
			return _descriptionColumn;
		}

		void SetDescriptionColumn( long x) 
		{
			_descriptionColumn = x;
		}

		long GetReferenceLine() const
		{
			return _referenceLine;
		}

		void SetReferenceLine( long x) 
		{
			_referenceLine = x;
		}

		long GetReferenceColumn() const
		{
			return _referenceColumn;
		}

		void SetReferenceColumn( long x) 
		{
			_referenceColumn = x;
		}


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\symbol.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef SIMC_SYMBOL_H
#define SIMC_SYMBOL_H

// These are the status for objects of classes SIMCDefinedValueReference
// and SIMCDefinedTypeReference
enum SIMCResolutionStatus
{
	RESOLVE_UNSET,		// Haven't resolved it yet
	RESOLVE_UNDEFINED,	// Could not resolve it
	RESOLVE_IMPORT,		// Resolved to IMPORTS
	RESOLVE_CORRECT,		// Resolved properly, to the type expected
	RESOLVE_FALSE		// Resolved properly, but not to the type expected
};


class SIMCModule;

// The base class for all the symbols that can occur in a module.
// It is an abstract class.	See the files "typeRef.hpp" and "valueRef.hpp"
// for classes derived from this
class SIMCSymbol
{
	
	public:
		enum SymbolType 
		{ 	
			PRIMITIVE, 	// Primitive ASN.1 type
			LOCAL, 		// Locally defined in this module
			IMPORTED, 	// From another module. The Internet SMI
						// definitions that the compiler 'knows' about,
						// lie in the IMPORTED category.
			MODULE_NAME
		};
	private:
		// Various charcteristics of a symbol
		char *_symbolName;
		SymbolType _symbolType; 
		SIMCModule *_module; 		// Null for a PRIMITIVE, LOCAL or MODULE_NAME symbol
		long _lineNumber, _columnNumber;
		long _referenceCount;

		// Used in mostly in the destructors of the derived classes.
		// Says whether the _referenceCount value should be uses at all
		BOOL _useReferenceCount;	

	protected:
		SIMCSymbol(const char * const symbolName, 
					SymbolType symbolType = LOCAL,
					SIMCModule *module = NULL,
					long _lineNumber = 0, long _columnNumber = 0,
					long _referenceCount = 0);

		SIMCSymbol(const SIMCSymbol& rhs);
	
	public:
		virtual ~SIMCSymbol();
		BOOL operator == (const SIMCSymbol& rhs) const;

		const char* GetSymbolName() const
		{
			return (_symbolName)? _symbolName : "";
		}

		SymbolType GetSymbolType() const
		{
			return _symbolType;
		}

		SIMCModule *GetModule() const
		{
			return _module;
		}

		long GetLineNumber() const
		{
			return _lineNumber;
		}

		long GetColumnNumber() const
		{
			return _columnNumber;
		}

		void SetLineNumber( long line)
		{
			_lineNumber = line;
		}

		void SetColumnNumber( long col)
		{
			_columnNumber = col;
		}

		BOOL SetSymbolName(const char * name)
		{
			if( _symbolName )
			{
				delete []_symbolName;
				_symbolName = NULL;
			}
			return  (_symbolName = NewString(name)) !=  NULL;
		}
		
		void SetSymbolType ( SymbolType x )
		{
			_symbolType = x;
		}
		void SetModule(SIMCModule * module)
		{
			_module = module;
		}
		
		long GetReferenceCount() const
		{
			return _referenceCount;
		}

		void SetReferenceCount(long refCount)
		{
			/*
			if( _symbolType == PRIMITIVE)
				return;
			*/
			_referenceCount = refCount;
			/*
			if( refCount == 0 )
				delete this;
			*/
		}

		long IncrementReferenceCount()
		{
			return ++_referenceCount;
		}
		
		long DecrementReferenceCount ()
		{
			return --_referenceCount;
		}
		
		void SetUseReferenceCount(BOOL val)
		{
			_useReferenceCount = val;
		}

		BOOL UseReferenceCount() const
		{
			return _useReferenceCount;
		}

		virtual void WriteSymbol(ostream&) const;
		
		friend ostream& operator << (ostream& outStream, const SIMCSymbol& symbol)
		{
			symbol.WriteSymbol(outStream);
			return outStream;
		}

		void WriteBrief(ostream& outStream) const;


};

// A forward-referenced symbol, whose details are
// not known presently
class SIMCUnknown : public SIMCSymbol
{

	public:
		SIMCUnknown(const char * const symbolName, 
					SymbolType symbolType = LOCAL,
					SIMCModule *module = NULL,
					long _lineNumber = 0, long _columnNumber = 0,
					long _referenceCount = 0)
					: SIMCSymbol( symbolName, symbolType,module, 
					 _lineNumber,  _columnNumber, _referenceCount)
		{}
		
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "UNKNOWN " ;
			SIMCSymbol::WriteSymbol(outStream);
		}

};

// An imported symbol, whose details are
// not known presently
class SIMCImport : public SIMCSymbol
{

	public:
		SIMCImport(const char * const symbolName, 
					SymbolType symbolType = LOCAL,
					SIMCModule *module = NULL,
					long _lineNumber = 0, long _columnNumber = 0,
					long _referenceCount = 0)
					: SIMCSymbol( symbolName, symbolType,module, 
					 _lineNumber,  _columnNumber, _referenceCount)
		{}
		
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "IMPORT " ;
			SIMCSymbol::WriteSymbol(outStream);
		}

};

#endif // SIMC_SYMBOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\type.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_TYPE
#define SIMC_TYPE


/* This file contain the various classes that model some of the types that
* can occur in a MIB. These include :
*
*	SIMCPrimitiveType (INTEGER, OCTET STRING, OID, NULL etc)
*	SIMCRangeType
*	SIMCSizeType
*	SIMCEnumOrBitsType
*	SIMCSequenceType
*	SIMCSequenceOfType
*
*
*	The base class for all these types is the SIMCType class.
*	Some classes such as SIMCObjectTypeType, SIMCTrapTypeType are
*	declared in other files since they are considerably big.
*/



/*
 * This is the base class of all the types that can be defined in a
 * MIB.
 */
class SIMCType
{
	private:

		// Used mostly in the destructors of the derived classes. Indicates
		// whether the reference count should be considered valid.
		BOOL _useReferenceCount;	

	public:
		SIMCType() { _useReferenceCount = FALSE; }

		friend ostream& operator << (ostream& outStream, const SIMCType& obj)
		{
			obj.WriteType(outStream);
			return outStream;
		}

		void SetUseReferenceCount(BOOL val)
		{
			_useReferenceCount = val;
		}

		BOOL UseReferenceCount() const
		{
			return _useReferenceCount;
		}


		virtual void WriteType(ostream& outStream) const = 0;
		virtual ~SIMCType() {}
};

// INTEGER, OID, OCTET STRING, NULL etc., are instances of this class
class SIMCPrimitiveType : public SIMCType
{
	public:
	void WriteType(ostream& outStream) const
	{
		outStream << "SIMCPrimitiveType" << endl;
	}
};



class SIMCTypeReference;

// A common base class fror range and size subtypes
class SIMCSubType : public SIMCType
{
		// The immediate type used in forming the sub type
		SIMCSymbol ** _type;
		long _typeLine, _typeColumn;
		// The root of the type used in forming the sub type.
		// This has to be an SIMCPrimitiveType
		SIMCTypeReference *_rootType;
		// This is set when the based on whether the _rootType could
		// be determined for the _type
		SIMCResolutionStatus _status;
	
	protected:
		
		SIMCSubType( SIMCSymbol ** type, long typeLine, long typeColumn)
			: _type(type), _rootType(NULL), _status(RESOLVE_UNSET),
				_typeLine(typeLine), _typeColumn(typeColumn)
		{
			(*type)->IncrementReferenceCount();
		}

		virtual ~SIMCSubType()
		{
			if(UseReferenceCount())
				(*_type)->DecrementReferenceCount();
		}	
	public:
		
		SIMCSymbol **GetType() const
		{
			return _type;
		}
		SIMCTypeReference *GetRootType() const
		{
			return _rootType;
		}
		void SetRootType(SIMCTypeReference *root)
		{
			_rootType = root;
		}
		SIMCResolutionStatus GetStatus() const
		{
			return _status;
		}

		void SetStatus( SIMCResolutionStatus val)
		{
			_status = val;
		}

		long GetTypeLine() const
		{
			return _typeLine;
		}

		void SetTypeLine( long x) 
		{
			_typeLine = x;
		}

		long GetTypeColumn() const
		{
			return _typeColumn;
		}

		void SetTypeColumn( long x) 
		{
			_typeColumn = x;
		}
		
};

typedef CList<SIMCSubType *, SIMCSubType *> SIMCSubTypeList;

// Each item in a range or SIZE clause
class SIMCRangeOrSizeItem
{

	public:
		long _lowerBound, _upperBound;
		BOOL _isUnsignedL, _isUnsignedU;
		long _lbLine, _lbColumn, _ubLine, _ubColumn;
		SIMCRangeOrSizeItem(long l, BOOL isUnsignedL,
							long lbLine, long lbColumn,
							long u, BOOL isUnsignedU,
							long ubLine, long ubColumn)
			: _lowerBound(l), _upperBound(u), 
				_isUnsignedL(isUnsignedL), _isUnsignedU(isUnsignedU),
				_lbLine(lbLine), _lbColumn(lbColumn),
				_ubLine(ubLine), _ubColumn(ubColumn)
		{}
		friend ostream& operator << (ostream& outStream, const SIMCRangeOrSizeItem& obj);

};

typedef CList<SIMCRangeOrSizeItem *, SIMCRangeOrSizeItem *> SIMCSizeList;

// The SIZE type
class SIMCSizeType : public SIMCSubType
{
		SIMCSizeList *_listOfSizes;
	public:
		SIMCSizeType( SIMCSymbol **type,
						long typeLine, long typeColumn,
						SIMCSizeList *listOfSizes)
						: _listOfSizes(listOfSizes),
							SIMCSubType(type, typeLine, typeColumn)
		{}

		virtual ~SIMCSizeType();
		
		const SIMCSizeList *GetListOfSizes() const
		{
			return _listOfSizes;
		}
		void WriteType(ostream& outStream) const;
		char * ConvertSizeListToString() const;
		long GetFixedSize() const;
		BOOL IsFixedSize() const;
		long GetMaximumSize() const;
		BOOL IsNotZeroSizeObject() const;
};

typedef CList<SIMCRangeOrSizeItem *, SIMCRangeOrSizeItem *> SIMCRangeList;

// The range type
class SIMCRangeType : public SIMCSubType
{
		SIMCRangeList *_listOfRanges;
	public:
		SIMCRangeType( SIMCSymbol **type,
						long typeLine, long typeColumn,
						SIMCRangeList *listOfRanges)
						: _listOfRanges(listOfRanges),
							SIMCSubType(type, typeLine, typeColumn)
		{}

		virtual ~SIMCRangeType();
		
		const SIMCRangeList *GetListOfRanges() const
		{
			return _listOfRanges;
		}

		void WriteType(ostream& outStream) const;
		char * ConvertRangeListToString() const;
};

// This class represents each item of an ENUM or BITS construct
class SIMCNamedNumberItem
{
	public:
		SIMCSymbol **_value;
		long _valueLine, _valueColumn;
		char *_name;
		long _nameLine, _nameColumn;

		SIMCNamedNumberItem ( SIMCSymbol **value, long valueLine, long valueColumn,
						char *name, long nameLine, long nameColumn)
			: _value(value), _name(NewString(name)), 
				_valueLine(valueLine), _valueColumn(valueColumn), 
				_nameLine(nameLine), _nameColumn(nameColumn)
		{}

		virtual ~SIMCNamedNumberItem()
		{
			if(_name)
				delete [] _name;
		}
};

typedef CList<SIMCNamedNumberItem *, SIMCNamedNumberItem *> SIMCNamedNumberList;

// An ENUM or BITS definition. They're considered the same
class SIMCEnumOrBitsType : public SIMCSubType
{
		SIMCNamedNumberList * _listOfItems;

	public:
		enum EnumOrBitsType
		{
			ENUM_OR_BITS_UNKNOWN,
			ENUM_OR_BITS_IMPORT,
			ENUM_OR_BITS_ENUM,
			ENUM_OR_BITS_BITS
		};

	private:
		EnumOrBitsType	_enumOrBitsType;

	public:
		SIMCEnumOrBitsType (SIMCSymbol **type,
						long typeLine, long typeColumn,
						SIMCNamedNumberList * listOfItems,
						EnumOrBitsType enumOrBitsType);

		~SIMCEnumOrBitsType ();

		EnumOrBitsType GetEnumOrBitsType() const
		{
			return _enumOrBitsType;
		}

		void SetEnumOrBitsType( EnumOrBitsType enumOrBitsType)
		{
			_enumOrBitsType = enumOrBitsType;
		}

		SIMCSymbol **GetValue(const char * const name) const;
		SIMCResolutionStatus GetIdentifier(int x, const char * &retVal) const;

		SIMCNamedNumberList *GetListOfItems() const
		{
			return _listOfItems;
		}

		char * ConvertToString() const;
		BOOL CheckClosure(const SIMCEnumOrBitsType *rhs) const;
		long GetLengthOfLongestName() const;
		void WriteType(ostream& outStream) const
		{
			outStream << "SIMCEnumOrBitsType" << endl;
		}

};



// A type resulting from a SEQUENCE OF construct
class SIMCSequenceOfType : public SIMCType
{
		SIMCSymbol ** _type;
		long _typeLine, _typeColumn;
	public:
		SIMCSequenceOfType( SIMCSymbol ** type, long typeLine, long typeColumn)
			: _type(type), _typeLine(typeLine), _typeColumn(typeColumn)
		{
			if(type)
				(*type)->IncrementReferenceCount();
		}

		~SIMCSequenceOfType()
		{
			if(UseReferenceCount() && _type)
				(*_type)->DecrementReferenceCount();
		}	
		SIMCSymbol **GetType() const
		{
			return _type;
		}
		void WriteType(ostream& outStream) const
		{
			outStream << "SIMCSequenceOfType of ";
			(*_type)->WriteBrief(outStream);
			outStream << endl;
		}

		long GetTypeLine() const
		{
			return _typeLine;
		}

		void SetTypeLine( long x) 
		{
			_typeLine = x;
		}

		long GetTypeColumn() const
		{
			return _typeColumn;
		}

		void SetTypeColumn( long x) 
		{
			_typeColumn = x;
		}

};

// A type resulting form a SEQUENCE construct
class SIMCSequenceItem
{
	public:
		SIMCSymbol **_type;
		long _typeLine, _typeColumn;
		SIMCSymbol **_value;
		long _valueLine, _valueColumn;

		SIMCSequenceItem ( SIMCSymbol **type, long typeLine, long typeColumn,
			SIMCSymbol **value, long valueLine, long valueColumn)
			: _type(type), _typeLine(typeLine), _typeColumn(typeColumn),
			_value(value), _valueLine(valueLine), _valueColumn(valueColumn)
		{}

};

typedef CList<SIMCSequenceItem *, SIMCSequenceItem *> SIMCSequenceList;

class SIMCSequenceType : public SIMCType
{
		SIMCSequenceList * _listOfSequences;
	
	public:
		SIMCSequenceType (SIMCSequenceList * listOfSequences);

		~SIMCSequenceType ();

		SIMCSequenceList *GetListOfSequences() const
		{
			return _listOfSequences;
		}

		void WriteType(ostream& outStream) const
		{
			outStream << "SIMCSequenceType" << endl;
		}
		int GetNumberOfItems() const
		{
			if(_listOfSequences)
				return _listOfSequences->GetCount();
			return 0;
		}

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\typeref.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_TYPE_REFERENCE
#define SIMC_TYPE_REFERENCE

/*
 * This file contains classes  that model symbols that result from
 * a type assignement, or a TEXTUAL-CONVENTION definition. 
 * Refer to the "Compiler Design Spec" for more  detailed definitions
 * of a "defined type reference" and a "built-in type reference"
 * A defined type reference is caused by a type assignment statement
 * in which the RHS is just another symbol. A built-in type reference is
 * caused by a type assignment statement in which the RHS is a new type
 * constructed using sub-typing, enum or BITS constructs, SEQUENCE or SEQUENCE OF
 * constructs. 
 */


/* This is the base class for a defined or a built-in type reference
 * All type references are symbols. Hence this class is derived from 
 * SIMCSymbol
 */
class SIMCTypeReference : public SIMCSymbol
{
	protected:
		SIMCTypeReference(const char * const symbolName, 
					SymbolType symbolType = LOCAL,
					SIMCModule *module = NULL,
					long _lineNumber = 0, long _columnNumber = 0,
					long _referenceCount = 0)
					: SIMCSymbol(symbolName, symbolType, module, 
						_lineNumber, _columnNumber, _referenceCount)
		{}


		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "TYPE REFERENCE " ;
			SIMCSymbol::WriteSymbol( outStream);
		}


};



/* This class models a built-in type reference. So, it has a pointer
 * to the SIMCType object that resulted in this type reference
 */
class SIMCBuiltInTypeReference : public SIMCTypeReference
{
		
		SIMCType *_type;

	public:
		SIMCBuiltInTypeReference (SIMCType *type, 
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long lineNumber = 0, long columnNumber = 0,
			long referenceCount = 0)
			:  _type(type),
			SIMCTypeReference(symbolName, symbolType, module, 
				lineNumber, columnNumber, referenceCount)
		{}

		~SIMCBuiltInTypeReference()
		{
			delete _type;
		}

		SIMCType * GetType() const
		{
			return _type;
		}
		
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "BuiltinTypeReference " ;
			SIMCSymbol::WriteSymbol(outStream);

			outStream << "TYPE DETAILS "  << endl;
			outStream << (*_type) << endl;
			
		}
};


/* This class models a defined type reference, and hence has a pointer
 * to another symbol that was used in creating this defined type reference
 */
class SIMCDefinedTypeReference : public SIMCTypeReference
{
		// The symbol that was used to create this type reference
		SIMCSymbol ** _type;
		long _typeLine, _typeColumn;

		// the _type symbol itself may be another defined type reference
		// All defined type references have to finally end on a built-in
		// type reference. _realType is that type reference
		SIMCTypeReference *_realType;

		// What happened when an attempt was made to set _realType
		SIMCResolutionStatus _status;

	public:
		SIMCDefinedTypeReference (SIMCSymbol **type,
			long typeLine, long typeColumn,
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long lineNumber = 0, long columnNumber = 0,
			long referenceCount = 0)
			:  _type(type), _typeLine(typeLine), _typeColumn(typeColumn),
				_realType(NULL), _status(RESOLVE_UNSET),
				SIMCTypeReference( symbolName, symbolType, module, 
					lineNumber, columnNumber, referenceCount)
		{
			if(_type)
				(*_type)->IncrementReferenceCount();
		}

		virtual ~SIMCDefinedTypeReference()
		{
			if(UseReferenceCount() && _type) 
				(*_type)->DecrementReferenceCount();
		}

		SIMCSymbol ** GetTypeReference() const
		{
			return _type;
		}
		
		SIMCTypeReference *GetRealType() const
		{
			return _realType;
		}

		void SetRealType(SIMCTypeReference *type)
		{
			_realType = type;
		}

		SIMCResolutionStatus GetStatus() const
		{
			return _status;
		}

		void SetStatus( SIMCResolutionStatus val)
		{
			_status = val;
		}
		long GetTypeLine() const
		{
			return _typeLine;
		}

		void SetTypeLine( long x) 
		{
			_typeLine = x;
		}

		long GetTypeColumn() const
		{
			return _typeColumn;
		}

		void SetTypeColumn( long x) 
		{
			_typeColumn = x;
		}
		

		virtual void WriteSymbol( ostream& outStream ) const;

};

typedef CList<SIMCDefinedTypeReference *, SIMCDefinedTypeReference *> SIMCDefinedTypeReferenceList;

/*
 * A TEXTUAL-CONVENTION macro is considered as a defined type reference
 * with extra clauses
 */
class SIMCTextualConvention : public SIMCDefinedTypeReference
{

	public:
		enum SIMCTCStatusType
		{
			TC_INVALID,
			TC_CURRENT,
			TC_DEPRECATED,
			TC_OBSOLETE
		};

	private:
		// Various clauses of the TEXTUAL-CONVENTION macro
		char * _displayHint;
		SIMCTCStatusType _status;
		long _statusLine;
		long _statusColumn;
		char * _description;
		char * _reference;

	public:
	   SIMCTextualConvention(const char * const displayHint,
			SIMCTCStatusType status,
			long statusLine, long statusColumn,
			const char * const description,
			const char * const reference,
			SIMCSymbol **type,
			long typeLine, long typeColumn,
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long lineNumber = 0, long columnNumber = 0,
			long referenceCount = 0);

		virtual ~SIMCTextualConvention()
		{
			delete _displayHint;
			delete _description;
			delete _reference;
		}

		const char * GetDisplayHint() const
		{
			return _displayHint;
		}
		void SetDisplayHint(const char * const displayHint)
		{
			delete _displayHint;
			_displayHint = NewString(displayHint);
		}

		const char * GetDescription() const
		{
			return _description;
		}
		void SetDescription(const char * const description)
		{
			delete _description;
			_description = NewString(description);
		}

		const char * GetReference() const
		{
			return _reference;
		}
		void SetReference(const char * const reference)
		{
			delete _reference;
			_reference = NewString(reference);
		}

		SIMCTCStatusType GetStatus() const
		{
			return _status;
		}
		void SetStatus(SIMCTCStatusType status)
		{
			_status = status;
		}

		long GetStatusLine() const
		{
			return _statusLine;
		}

		void SetStatusLine(long x) 
		{
			_statusLine = x;
		}

		long GetStatusColumn() const
		{
			return _statusColumn;
		}

		void SetStatusColumn(long x) 
		{
			_statusColumn = x;
		}

		static SIMCTCStatusType StringToStatusType (const char * const s);


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\valueref.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_VALUE_REFERENCE
#define SIMC_VALUE_REFERENCE

/*
 * This file contains classes  that model symbols that result from
 * a value assignement. 
 * Refer to the "Compiler Design Spec" for more  detailed definitions
 * of a "defined value reference" and a "built-in value reference"
 * A defined value reference is caused by a value assignment statement
 * in which the RHS is just another symbol. A built-in value reference is
 * caused by a value assignment statement in which the RHS is a literal 
 * value
 */


/* This is the base class for a defined or a built-in value reference
 * All value references are symbols. Hence this class is derived from 
 * SIMCSymbol. It stores a pointer to a symbol that represents the
 * type of the value
 */
class SIMCValueReference: public SIMCSymbol
{
		SIMCSymbol **_type;
		long _typeLine, _typeColumn;

	protected:
		
		SIMCValueReference (SIMCSymbol **type,
			long typeLine, long typeColumn,
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long _lineNumber = 0, long _columnNumber = 0,
			long _referenceCount = 0)
			: _type(type), _typeLine(typeLine), _typeColumn(typeColumn),
			SIMCSymbol( symbolName, symbolType, module, 
				_lineNumber, _columnNumber, _referenceCount)
		{
			if(_type)
				(*_type)->IncrementReferenceCount();
		}

		virtual ~SIMCValueReference ()
		{
			if(UseReferenceCount() && _type)
				(*_type)->DecrementReferenceCount();
		}

	public:	
		SIMCSymbol ** GetTypeReference() const
		{
			return _type;
		}
		const char *GetTypeName() const
		{
			return (*_type)->GetSymbolName();
		}
		long GetTypeLine() const
		{
			return _typeLine;
		}

		void SetTypeLine( long x) 
		{
			_typeLine = x;
		}

		long GetTypeColumn() const
		{
			return _typeColumn;
		}

		void SetTypeColumn( long x) 
		{
			_typeColumn = x;
		}
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "VALUE REFERENCE ";
			SIMCSymbol::WriteSymbol(outStream);
			outStream << endl;
			outStream << "\t TYPE DETAILS ";
			(*_type)->WriteBrief(outStream);
			outStream << endl;
		}
};

/* This class models a built-in value reference. So, it has a pointer
 * to the SIMCValue object that resulted in this value reference
 */

class SIMCBuiltInValueReference : public SIMCValueReference
{
		
		SIMCValue *_value;
		BOOL _isSharedValue; // Set on the basis of the constructor used

	public:
		SIMCBuiltInValueReference (SIMCSymbol **type,
			long typeLine, long typeColumn,
			SIMCValue *value,
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long lineNumber = 0, long columnNumber = 0,
			long referenceCount = 0)
			:  _value(value), _isSharedValue(FALSE),
			SIMCValueReference( type, typeLine, typeColumn,
				symbolName, symbolType, module, 
				lineNumber, columnNumber, referenceCount)
		{}

		SIMCBuiltInValueReference(SIMCValueReference *symbol, 
			SIMCBuiltInValueReference *bvRef)
			: _value(bvRef->GetValue()), _isSharedValue(TRUE),
			SIMCValueReference(symbol->GetTypeReference(),
					symbol->GetTypeLine(), symbol->GetTypeColumn(),
					symbol->GetSymbolName(),
					symbol->GetSymbolType(), symbol->GetModule(),
					symbol->GetLineNumber(), symbol->GetColumnNumber(),
					symbol->GetReferenceCount())
		{}


		virtual ~SIMCBuiltInValueReference()
		{
			if(!_isSharedValue)
				delete _value;
		}

		SIMCValue * GetValue() const
		{
			return _value;
		}
		
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "BUILTINVALUE REFERENCE " ;
			SIMCValueReference::WriteSymbol(outStream);


			outStream << "\tVALUE DETAILS" << endl << (*_value) << endl;
		}

};

/* This class models a defined value reference, and hence has a pointer
 * to another symbol that was used in creating this defined value reference
 */
class SIMCDefinedValueReference : public SIMCValueReference
{
		SIMCSymbol ** _value;
		long _valueLine, _valueColumn;
		// the _value symbol itself may be another defined value reference
		// All defined value references have to finally end on a built-in
		// value reference. _realValue is that value reference
		SIMCBuiltInValueReference *_realValue;

		// What happened when an attempt was made to set _realType
		SIMCResolutionStatus _status;

	public:
		SIMCDefinedValueReference (SIMCSymbol **type,
			long typeLine, long typeColumn,
			SIMCSymbol  **value,
			long valueLine, long valueColumn,
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long _lineNumber = 0, long _columnNumber = 0,
			long _referenceCount = 0)
			:  _value(value), _valueLine(valueLine), _valueColumn(valueColumn),
				_realValue(NULL), _status(RESOLVE_UNSET),
				SIMCValueReference( type, typeLine, typeColumn, 
					symbolName, symbolType, module, 
					_lineNumber, _columnNumber, _referenceCount)
		{
			if( _value )
				(*_value)->IncrementReferenceCount();
		}

		virtual ~SIMCDefinedValueReference()
		{
			if( UseReferenceCount() && _value )
				(*_value)->DecrementReferenceCount();
		}


		SIMCSymbol ** GetValueReference() const
		{
			return _value;
		}
		
		SIMCBuiltInValueReference * GetRealValue() const
		{
			return _realValue;
		}

		void SetRealValue(SIMCBuiltInValueReference *value)
		{
			_realValue = value;
		}
		SIMCResolutionStatus GetStatus() const
		{
			return _status;
		}

		void SetStatus( SIMCResolutionStatus val)
		{
			_status = val;
		}
		long GetValueLine() const
		{
			return _valueLine;
		}

		void SetValueLine( long x) 
		{
			_valueLine = x;
		}

		long GetValueColumn() const
		{
			return _valueColumn;
		}

		void SetValueColumn( long x) 
		{
			_valueColumn = x;
		}
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "DEFINEDVALUEREFRENCE " ;
			SIMCValueReference::WriteSymbol(outStream);
			outStream << "\tVALUE DETAILS " ;
			(*_value)->WriteBrief(outStream);
			// SIMCValueReference::WriteSymbol(outStream);
			outStream << endl;

			switch(_status)
			{
				case RESOLVE_UNSET:
					outStream << "UNSET RESOLUTION" << endl;
					break;
				case RESOLVE_UNDEFINED:
					outStream << "UNDEFINED RESOLUTION" << endl;
					break;
				case RESOLVE_IMPORT:
					outStream << "RESOLVES TO IMPORT" << endl;
					break;
				case RESOLVE_CORRECT:
					outStream << "RESOLVES TO " << _realValue->GetSymbolName()
						<< endl;
					break;
			}

		}
};

typedef CList<SIMCDefinedValueReference *, SIMCDefinedValueReference *> SIMCDefinedValueReferenceList;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\value.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_VALUE
#define SIMC_VALUE


/* 
 * This file contains classes that model the various kinds of values that
 * can occur in a MIB module
 */

/*
 * The base class for all the values. Just stores the line and column number
 */
class SIMCValue
{

		long _line, _column;
		// Used in mostly in the destructors of the derived classes
		BOOL _useReferenceCount;	

	protected:

		SIMCValue( long line = 0, long column = 0)
			: _line(line), _column(column), _useReferenceCount(FALSE)
		{}

	public:

 		virtual ~SIMCValue() {}

		friend ostream& operator<< ( ostream& outStream, const SIMCValue& obj)
		{
			obj.WriteValue(outStream);
			return outStream;
		}

		long GetLine() const
		{
			return _line;
		}

		void SetLine( long x) 
		{
			_line = x;
		}
		long GetColumn() const
		{
			return _column;
		}

		void SetColumn( long x) 
		{
			_column = x;
		}

		void SetUseReferenceCount(BOOL val)
		{
			_useReferenceCount = val;
		}

		BOOL UseReferenceCount() const
		{
			return _useReferenceCount;
		}

		virtual void WriteValue(ostream& outStream) const
		{
			outStream << "line(" << _line << "), column(" << _column << ")";
		}
};

/* 
 * Value for the INTEGER type
 */
class SIMCIntegerValue : public SIMCValue
{

		long _val;

		/* A long value is used to store 32 bit unsigned, as well as signed
		* values. Hence this flag is required to indicate whether a minus sign
		* was present in front of this number in a MIB file. If this is false,
		* then the above long value should be treated as an unsigned value
		*/
		BOOL _isUnsigned;
	public:

		SIMCIntegerValue ( long x, BOOL isUnsigned, long line = 0, long column = 0)
			: _val(x), _isUnsigned(isUnsigned), SIMCValue(line, column)
		{}

		long GetIntegerValue() const { return _val; }
		void SetIntegerValue(long x) { _val = x; }
		BOOL IsUnsigned() const
		{
			return _isUnsigned;
		}
		virtual void WriteValue( ostream& outStream) const
		{
			outStream << "Integer (" << _val << "), ";
			SIMCValue::WriteValue(outStream);
			outStream << endl;
		}
		virtual BOOL operator == (const SIMCIntegerValue& rhs) const
		{
			return _val == rhs._val;
		}
};

BOOL IsLessThan(long a, BOOL aUnsigned, long b, BOOL bUnsigned);

/*
 * Value for the NULL type
 */
class SIMCNullValue : public SIMCValue
{

	public:

		SIMCNullValue ( long line = 0, long column = 0)
			: SIMCValue(line, column)
		{}

		virtual void WriteValue( ostream& outStream) const
		{
			outStream << "NULL value ";
			SIMCValue::WriteValue(outStream);
			outStream << endl;
		}
		virtual BOOL operator == (const SIMCIntegerValue& rhs) const
		{
			return TRUE;
		}
};

/*
 * Value for the BOOL type
 */
class SIMCBooleanValue : public SIMCValue
{
		BOOL _val;

	public:
	
		SIMCBooleanValue ( BOOL val, long line = 0, long column = 0 )
			: _val(val), SIMCValue(line, column)
		{}

		BOOL GetBooleanValue() const
		{
			return _val;
		}

		void SetBooleanValue(BOOL x) 
		{
			_val = x;
		}

		virtual void WriteValue( ostream& outStream) const
		{
			outStream << "BOOLEAN VALUE (" << ((_val)? "TRUE" : "FALSE") << 
					") ";
			SIMCValue::WriteValue(outStream);
			outStream << endl;
		}

		virtual BOOL operator == (const SIMCBooleanValue& rhs) const
		{
			if (_val)
				return  rhs._val;
			else
				return !rhs._val;
		}
};

/*
 * value for the OCTET STRING type
 */
class SIMCOctetStringValue : public SIMCValue
{

		char * _val;
		BOOL _binary;

	public:

		SIMCOctetStringValue ( BOOL binary, char * x, long line = 0, long column = 0)
			: _binary(binary), SIMCValue(line, column)
		{
			_val = NewString(x);
		}

		virtual ~SIMCOctetStringValue()
		{
			if(_val)
				delete []_val;
		}

		BOOL IsBinary() const
		{
			return _binary;
		}

		const char *GetOctetStringValue() const { return _val; }
		
		void SetOctetStringValue(BOOL binary, char * x) 
		{ 
			if(_val)
				delete _val;
			_val = NewString(x); 
			_binary = binary;
		}

		virtual void WriteValue( ostream& outStream) const
		{
			outStream << "Octet String (" << _val << "), ";
			SIMCValue::WriteValue(outStream);
			outStream << endl;
		}
		virtual BOOL operator == (const SIMCOctetStringValue& rhs) const
		{
			return (_binary == rhs._binary) &&(strcmp(_val, rhs._val) == 0);
		}
		int GetNumberOfOctets() const
		{
			if(_val)
			{
				int l = strlen(_val);
				if(!_binary)
					return l/2 + ((l%2)?1:0);
				return l/4 + ((l%4)?1:0);
			}
			else
				return 0;
		}

};

class SIMCBitValue
{
	public:
		CString	_name;
		long _line, _column;

		SIMCBitValue(const CString& name, long line, long column)
			: _name(name), _line(line), _column(column)
		{}
};

typedef CList<SIMCBitValue *, SIMCBitValue*> SIMCBitValueList;

class SIMCBitsValue : public SIMCValue
{
		SIMCBitValueList   *_valueList;

	public:
		SIMCBitsValue(SIMCBitValueList *valueList)
		{
			_valueList = valueList;
		}
		void AddValue( SIMCBitValue *value)
		{
			_valueList->AddTail(value);
		}

		const SIMCBitValueList * GetValueList() const
		{
			return _valueList;
		}
};


#endif // SIMC_VALUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\ui.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_UI_H
#define SIMC_UI_H



typedef CList<CString, const CString&> SIMCFileList;
typedef CList<CString, const CString&> SIMCPathList;

/*
 * This class has methods for parsing and storing the information
 * in the command-line, used to invoke the SNMP compiler
 */
class SIMCUI
{

public:
	enum CommandArgumentType;

private:
	// Error Messages that can occur on the commandline
	// 1-to-1 correspondence with the symbolic error constants 
	// defined by the enum ErrorMessageSymbol below
	static const char * const commandLineErrors[];
	

	int _snmpVersion;
	BOOL _simcDebug;
	CString _inputFileOrModuleName;
	int _diagnosticLevel;
	long _diagnosticMaximumCount;
	CommandArgumentType _commandArgument;
	BOOL _suppressText;			// Set by the /s switch
	BOOL _classDefinitionsOnly; // Set by the /gc switch
	BOOL _notificationsOnly;	// Set by the /o switch
	BOOL _extendedNotifications;// Set by the /ext switch
	BOOL _notifications	;		// Set by the /t switche
	BOOL _autoRefresh;			// Set by the /auto switch
	BOOL _contextInfo;			// Set by the /c switch
	BOOL _authenticateUser;		// Set by the /u switch
	BOOL _confirmedPurge;		// Set by the /y switch
	// The exe in the command used to invoke the compiler. argv[0]
	CString _applicationName;
	CString _commandLine;
	CString _currentDirectory;
	CString _userName;
	CString _dateAndTime;
	CString _hostName;
	SIMCFileList _subsidiaryFiles;
	SIMCPathList _includePaths;
	CString _authenticationUserName;

	void CheckIncludePaths(int& nextArg, int argc, const char *argv[]);

public:

	// Symbolic constants for the various error messages on the command-line
	enum ErrorMessageSymbol
	{
		ERROR_NONE,
		USAGE,
		INVALID_ARGS,
		MISSING_DIAG_LEVEL,
		WRONG_DIAG_LEVEL,
		MISSING_DIAG_COUNT,
		WRONG_DIAG_COUNT,
		MISSING_FILE_NAME,
		MISSING_COMMAND_ARG,
		MISSING_MODULE_NAME,
		MISSING_INCLUDE_PATH,
		NOTIFICATIONS_ONLY_USELESS,
		INVALID_COMBINATION_OF_SWITCHES,
		INVALID_SWITCH,
		// And a delimiter. No error message corresponds to this.
		// Used to check up whether a symbolic value is within limits
		MAX_COMMAND_LINE_ERROR
	};
	
	// Symbolic constants for the action requested by the user on the module
	enum CommandArgumentType 
	{	
		COMMAND_NONE,
		COMMAND_LOCAL_CHECK,
		COMMAND_EXTERNAL_CHECK,
		COMMAND_ADD,
		COMMAND_SILENT_ADD,
		COMMAND_GENERATE,
		COMMAND_GENERATE_CLASSES_ONLY,
		COMMAND_DELETE,
		COMMAND_PURGE,
		COMMAND_LIST,
		COMMAND_HELP1,
		COMMAND_HELP2,
		COMMAND_MODULE_NAME,
		COMMAND_IMPORTS_INFO,
		COMMAND_REBUILD_TABLE,
		COMMAND_ADD_DIRECTORY,
		COMMAND_DELETE_DIRECTORY_ENTRY,
		COMMAND_LIST_MIB_PATHS,
		COMMAND_MAX
	};


	static CString commandArgumentStrings[COMMAND_MAX];
	static CString	diagnosticLevelSwitch, 
					maxDiagnosticCountSwitch,
					snmpV1VersionSwitch,
					snmpV2VersionSwitch,
					suppressTextSwitch,
					undocumentedDebugSwitch,
					includePathSwitch,
					autoSwitch,
					contextInfoSwitch,
					notificationsSwitch,
					notificationsOnlySwitch,
					extendedNotificationsSwitch,
					yesSwitch;
	
	SIMCUI();
	BOOL ProcessCommandLine(int argc, const char *argv[]);

	void Usage (ErrorMessageSymbol messageSymbol = ERROR_NONE, 
		const char *infoString = NULL, BOOL shouldAbort = TRUE);


	inline int GetSnmpVersion() const { return _snmpVersion; }
	

	// These two functions get/set the main input MIB module
	inline void SetInputFileName(const char * const inputFileName)
	{
		_inputFileOrModuleName = inputFileName;
	}
	inline CString GetInputFileName() const 
	{ 
		return _inputFileOrModuleName; 
	}

	inline CString GetApplicationName() const
	{
		return _applicationName;
	}

	inline CString GetCommandLine() const 
	{ 
		return _commandLine; 
	}

	inline CString GetUserName() const 
	{ 
		return _userName; 
	}

	inline BOOL AuthenticateUser () const 
	{ 
		return _authenticateUser; 
	}

	inline CString GetProcessDirectory() const 
	{ 
		return _currentDirectory; 
	}

	inline CString GetDateAndTime() const 
	{ 
		return _dateAndTime; 
	}

	inline CString GetHostName() const 
	{ 
		return _hostName; 
	}

	inline BOOL ConfirmedPurge()
	{
		return _confirmedPurge;
	}
	// This is set by the undocumented /z switch
	BOOL IsSimcDebug() const
	{
		return _simcDebug;
	}



	// These two set the diagnostic level of the errors generated
	// No symbolic constants here. As specified in the requirements 
	// spec, "diagnosticLevel" can be :
	// 0 - Fatal errors only
	// 1 - Fatal errors and Warnings
	// 2 - Fatal errors, Warnings and Information messages
	inline void SetDiagnosticLevel(const int diagnosticLevel = 0)
	{
		_diagnosticLevel = diagnosticLevel;
	}
	
	inline int GetDiagnosticLevel() const 
	{ 
		return _diagnosticLevel; 
	}
	
	// These two get/set the maximum diagnostic count 
	inline void SetMaxDiagnosticCount(const int diagnosticMaximumCount = INT_MAX)
	{
		_diagnosticMaximumCount = diagnosticMaximumCount;
	}
	inline long GetMaxDiagnosticCount() const 
	{ 
		return _diagnosticMaximumCount; 
	}

	// These two deal with the action to be taken on the main
	// input file.
	inline CommandArgumentType GetCommandArgument() const 
	{
		return _commandArgument;
	}
	inline void SetCommandArgument(CommandArgumentType commandArgument) 
	{
		_commandArgument = commandArgument;
	}

	// These two deal with the /s switch
	inline BOOL SuppressText() const
	{
		return _suppressText;
	}
	inline void SetSuppressText( BOOL suppressText = FALSE)
	{
		_suppressText = suppressText;
	}

	// These two deal with the /auto switch
	inline BOOL AutoRefresh() const
	{
		return _autoRefresh;
	}
	inline void SetAutoRefresh( BOOL autoRefresh = FALSE)
	{
		_autoRefresh = autoRefresh;
	}

	// These two get/set the module specified on the /d switch
	inline CString GetModuleName() const
	{
		return _inputFileOrModuleName;
	}
	inline void SetModuleName( const CString& moduleName)
	{
		_inputFileOrModuleName = moduleName;
	}

	// These two get/set the subsidiary files
	inline const SIMCFileList *GetSubsidiaryFiles() const
	{
		return &_subsidiaryFiles;
	}

	inline void AddSubsidiaryFile( const CString& fileName)
	{
		_subsidiaryFiles.AddTail(fileName);
	}

	// These two get/set the path specified on the /pa and /px switch
	inline CString GetDirectory() const
	{
		return _inputFileOrModuleName;
	}
	inline void SetDirectory( const CString& directory)
	{
		_inputFileOrModuleName = directory;
	}

	// These two get/set the paths specified on the /i switch
	inline const SIMCPathList *GetPaths() const
	{
		return &_includePaths;
	}

	inline void AddPath( const CString& path)
	{
		_includePaths.AddTail(path);
	}

	// This is set by the /gc switch
	inline BOOL ClassDefinitionsOnly() const
	{
		return _classDefinitionsOnly;
	}

	// This is set by the /c switch
	inline BOOL GenerateContextInfo() const
	{
		return _contextInfo;
	}

	// This is set by the /t switch
	inline BOOL DoNotifications() const
	{
		return _notifications;
	}

	// This is set by the /ext switch
	inline BOOL DoExtendedNotifications() const
	{
		return _extendedNotifications;
	}

	// This is set by the /o switch
	inline BOOL DoNotificationsOnly() const
	{
		return _notificationsOnly;
	}

	// This gets the FileVersion resource from the resource of the exe
	CString GetVersionNumber();

	friend ostream& operator << ( ostream&, const SIMCUI&);
};

#endif // SIMC_UI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\errorcontainer.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"


SIMCErrorContainer::SIMCErrorContainer()
{
	_currentMessage = NULL;
}


BOOL SIMCErrorContainer::InsertMessage(const SIMCErrorMessage& newMessage)
{	
	_listOfMessages.AddTail(newMessage);
	return TRUE;
}

void SIMCErrorContainer::MoveToFirstMessage()
{
	_currentMessage = _listOfMessages.GetHeadPosition();
}

int SIMCErrorContainer::GetNextMessage(SIMCErrorMessage& nextMessage)
{
	if (_currentMessage == NULL)
		return FALSE;
	nextMessage =  _listOfMessages.GetNext(_currentMessage);
	return TRUE;
}

ostream& operator << ( ostream& outStream, SIMCErrorContainer& object)
{
	object.MoveToFirstMessage();
	SIMCErrorMessage msg;

	while(object.GetNextMessage(msg))
		outStream << msg;

	return outStream;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\infolex.cpp ===
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <autoptr.h>

#define INITIAL 0
const ModuleInfo_endst = 25;
const ModuleInfo_nxtmax = 310;
#define YY_LA_SIZE 4

static unsigned short ModuleInfo_la_act[] = {
 17, 16, 17, 2, 17, 3, 17, 4, 17, 5, 17, 6, 17, 7, 17, 8,
 17, 9, 17, 11, 17, 12, 17, 13, 17, 14, 15, 17, 17, 13, 12, 11,
 9, 1, 0, 10, 0
};

static unsigned char ModuleInfo_look[] = {
 0
};

static short ModuleInfo_final[] = {
 0, 0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 26,
 28, 29, 30, 31, 32, 33, 33, 34, 35, 36
};
#ifndef ModuleInfo_state_t
#define ModuleInfo_state_t unsigned char
#endif

static ModuleInfo_state_t ModuleInfo_begin[] = {
 0, 0, 0
};

static ModuleInfo_state_t ModuleInfo_next[] = {
 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 13, 16, 16, 16, 16, 16, 16, 16, 8, 9, 16, 16, 5, 1, 3, 16,
 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 2, 4, 16, 15, 16, 16,
 16, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 16, 16, 16, 16, 16,
 16, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 6, 16, 7, 16, 16,
 17, 21, 22, 25, 18, 25, 25, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 25, 25, 25, 25, 25, 25, 17, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 25, 25, 25, 25, 25, 25, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 19, 25, 25, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 25,
 25, 25, 25, 25, 25, 25, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 25, 25, 25, 25, 25, 25, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 23, 25, 25, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 0
};

static ModuleInfo_state_t ModuleInfo_check[] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 13, 2, 21, 24, 12, ~0, ~0, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, ~0, ~0, ~0, ~0, ~0, ~0, 13, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, ~0, ~0, ~0, ~0, ~0, ~0, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, 11, ~0, ~0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, ~0,
 ~0, ~0, ~0, ~0, ~0, ~0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 ~0, ~0, ~0, ~0, ~0, ~0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 1, ~0, ~0, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 0
};

static ModuleInfo_state_t ModuleInfo_default[] = {
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 13, 12, 11, 10, 25, 25, 25, 1, 0
};

static short ModuleInfo_base[] = {
 0, 253, 71, 311, 311, 311, 311, 311, 311, 311, 240, 165, 87, 119, 311, 311,
 311, 311, 311, 311, 311, 69, 311, 311, 86, 311
};



// MKS LEX prototype scanner code
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can redefine YY_INTERACTIVE to be 0 to get a very slightly
// faster scanner:
#ifndef YY_INTERACTIVE
#define	YY_INTERACTIVE	1
#endif

// You can compile with -DYY_DEBUG to get a print trace of the scanner
#ifdef YY_DEBUG
#undef YY_DEBUG
#define YY_DEBUG(fmt,a1,a2)	fprintf(stderr,fmt,a1,a2)
#else
#define YY_DEBUG(fmt,a1,a2)
#endif

const MIN_NUM_STATES = 20;

// Do *NOT* redefine the following:
#define	BEGIN		ModuleInfo_start =

#if 0 //removed because of build warnings
#define	REJECT		goto ModuleInfo_reject
#define	ModuleInfomore()	goto ModuleInfo_more
#endif


#ifndef	lint
static char *RCSid = "$Header$";
#endif

/* 
 * $Header$
 *
 *
 * $Log$
 */

/*
 *			  ISODE 8.0 NOTICE
 *
 *   Acquisition, use, and distribution of this module and related
 *   materials are subject to the restrictions of a license agreement.
 *   Consult the Preface in the User's Manual for the full terms of
 *   this agreement.
 *
 *
 *			4BSD/ISODE SNMPv2 NOTICE
 *
 *    Acquisition, use, and distribution of this module and related
 *    materials are subject to the restrictions given in the file
 *    SNMPv2-READ-ME.
 *
 */

#include <snmptempl.h>


#include <newString.hpp>
#include "infoLex.hpp"
#include "infoYacc.hpp"


MODULEINFOSTYPE ModuleInfolval;

struct table {
    char   *t_keyword;
    int	    t_value;
    int	    t_porting;
};

static struct table reserved[] = {
    "BEGIN", MI_BGIN, 0,
    "DEFINITIONS", MI_DEFINITIONS, 0,
    "FROM", MI_FROM, 0,
    "IMPORTS", MI_IMPORTS, 0,

    NULL, 0
};




// Constructor for ModuleInfo_scan. Set up tables
#if 0 //removed because of build warning
#pragma argsused
#endif

ModuleInfo_scan::ModuleInfo_scan(int sz, char* buf, char* sv, ModuleInfo_state_t* states)
{
	mustfree = 0;
	if ((size = sz) < MIN_NUM_STATES
	  || (ModuleInfotext = buf) == 0
	  || (state = states) == 0) {
		ModuleInfoerror("Bad space for scanner!");
		exit(1);
	}
#ifdef YY_PRESERVE
	save = sv;
#endif
}
// Constructor for ModuleInfo_scan. Set up tables
ModuleInfo_scan::ModuleInfo_scan(int sz)
{
	size = sz;

	ModuleInfotext = new char[sz+1];	// text buffer
	wmilib::auto_buffer<char> ModuleInfotext_Guard ( ModuleInfotext ) ;

	state = new ModuleInfo_state_t[sz+1];	// state buffer
	wmilib::auto_buffer<ModuleInfo_state_t> state_Guard ( state ) ;

#ifdef YY_PRESERVE
	save = new char[sz];	// saved ModuleInfotext[]
	push = save + sz;
#endif
	if (ModuleInfotext == NULL
#ifdef YY_PRESERVE
	  || save == NULL
#endif
	  || state == NULL) {
		ModuleInfoerror("No space for scanner!");
		exit(1);
	}
	mustfree = 1;
	ModuleInfo_end = 0;
	ModuleInfo_start = 0;
	ModuleInfo_lastc = YYNEWLINE;
	ModuleInfoin = stdin;
	ModuleInfoout = stdout;
	ModuleInfolineno = 1;
	ModuleInfoleng = 0;

	//
	// Get rid of scope guard
	//
	state_Guard.release () ;
	ModuleInfotext_Guard.release () ;
}

// Descructor for ModuleInfo_scan
ModuleInfo_scan::~ModuleInfo_scan()
{
	if (mustfree) {
		mustfree = 0;
		delete[] (ModuleInfotext);
		delete[] (state);
#ifdef YY_PRESERVE
		delete(save);
#endif
	}
}

// Print error message, showing current line number
void
ModuleInfo_scan::ModuleInfoerror(char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
#ifdef LEX_WINDOWS
	// Windows has no concept of a standard error output!
	// send output to ModuleInfoout as a simple solution
	if (ModuleInfolineno)
		fprintf(ModuleInfoout, "%d: ", ModuleInfolineno);
	(void) vfprintf(ModuleInfoout, fmt, va);
	fputc('\n', ModuleInfoout);
#else /* LEX_WINDOWS */
	if (ModuleInfolineno)
		fprintf(stderr, "%d: ", ModuleInfolineno);
	(void) vfprintf(stderr, fmt, va);
	fputc('\n', stderr);
#endif /* LEX_WINDOWS */
	va_end(va);
}


#ifdef LEX_WINDOWS

// The initial portion of the lex scanner
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_ModuleInfolex() to acutally begin the
// scanning. When complete, win_ModuleInfolex() will return a
// value back to our new ModuleInfolex() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of ModuleInfolex().

int
ModuleInfo_scan::ModuleInfolex()
{
	int wReturnValue;
	HANDLE hRes_table;
	unsigned short *old_ModuleInfo_la_act;	// remember previous pointer values
	short *old_ModuleInfo_final;
	ModuleInfo_state_t *old_ModuleInfo_begin;
	ModuleInfo_state_t *old_ModuleInfo_next;
	ModuleInfo_state_t *old_ModuleInfo_check;
	ModuleInfo_state_t *old_ModuleInfo_default;
	short *old_ModuleInfo_base;

	// the following code will load the required
	// resources for a Windows based parser. 

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_ModuleInfoLEX", "ModuleInfoLEXTBL"));
	
	// return an error code if any
	// of the resources did not load 

	if (hRes_table == (HANDLE)NULL) 
		return (0);
	
	// the following code will lock the resources
	// into fixed memory locations for the scanner
	// (remember previous pointer locations)

	old_ModuleInfo_la_act = ModuleInfo_la_act;
	old_ModuleInfo_final = ModuleInfo_final;
	old_ModuleInfo_begin = ModuleInfo_begin;
	old_ModuleInfo_next = ModuleInfo_next;
	old_ModuleInfo_check = ModuleInfo_check;
	old_ModuleInfo_default = ModuleInfo_default;
	old_ModuleInfo_base = ModuleInfo_base;

	ModuleInfo_la_act = (unsigned short *)LockResource (hRes_table);
	ModuleInfo_final = (short *)(ModuleInfo_la_act + Sizeof_ModuleInfo_la_act);
	ModuleInfo_begin = (ModuleInfo_state_t *)(ModuleInfo_final + Sizeof_ModuleInfo_final);
	ModuleInfo_next = (ModuleInfo_state_t *)(ModuleInfo_begin + Sizeof_ModuleInfo_begin);
	ModuleInfo_check = (ModuleInfo_state_t *)(ModuleInfo_next + Sizeof_ModuleInfo_next);
	ModuleInfo_default = (ModuleInfo_state_t *)(ModuleInfo_check + Sizeof_ModuleInfo_check);
	ModuleInfo_base = (short *)(ModuleInfo_default + Sizeof_ModuleInfo_default);


	// call the standard ModuleInfolex() code

	wReturnValue = win_ModuleInfolex();

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previously saved pointers
	//

	ModuleInfo_la_act = old_ModuleInfo_la_act;
	ModuleInfo_final = old_ModuleInfo_final;
	ModuleInfo_begin = old_ModuleInfo_begin;
	ModuleInfo_next = old_ModuleInfo_next;
	ModuleInfo_check = old_ModuleInfo_check;
	ModuleInfo_default = old_ModuleInfo_default;
	ModuleInfo_base = old_ModuleInfo_base;

	return (wReturnValue);
}	// end ModuleInfolex()

// The actual lex scanner
// ModuleInfo_sbuf[0:ModuleInfoleng-1] contains the states corresponding to ModuleInfotext.
// ModuleInfotext[0:ModuleInfoleng-1] contains the current token.
// ModuleInfotext[ModuleInfoleng:ModuleInfo_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains ModuleInfotext[ModuleInfoleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 

int 
ModuleInfo_scan::win_ModuleInfolex()

#else /* LEX_WINDOWS */

// The actual lex scanner
// ModuleInfo_sbuf[0:ModuleInfoleng-1] contains the states corresponding to ModuleInfotext.
// ModuleInfotext[0:ModuleInfoleng-1] contains the current token.
// ModuleInfotext[ModuleInfoleng:ModuleInfo_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains ModuleInfotext[ModuleInfoleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 
int
ModuleInfo_scan::ModuleInfolex()
#endif /* LEX_WINDOWS */

{
	int c, i, ModuleInfobase;
	unsigned  ModuleInfost;		/* state */
	int ModuleInfofmin, ModuleInfofmax;	/* ModuleInfo_la_act indices of final states */
	int ModuleInfooldi, ModuleInfooleng;	/* base i, ModuleInfoleng before look-ahead */
	int ModuleInfoeof;		/* 1 if eof has already been read */



#ifdef YYEXIT
	ModuleInfoLexFatal = 0;
#endif
	ModuleInfoeof = 0;
	i = ModuleInfoleng;
	YY_SCANNER();

  ModuleInfo_again:
	if ((ModuleInfoleng = i) > 0) {
		ModuleInfo_lastc = ModuleInfotext[i-1];	// determine previous char
		while (i > 0)	//	// scan previously token
			if (ModuleInfotext[--i] == YYNEWLINE)	// fix ModuleInfolineno
				ModuleInfolineno++;
	}
	ModuleInfo_end -= ModuleInfoleng;		// adjust pushback
	memmove(ModuleInfotext, ModuleInfotext+ModuleInfoleng, (size_t) ModuleInfo_end);
	i = 0;

  ModuleInfo_contin:
	ModuleInfooldi = i;

	/* run the state machine until it jams */
	ModuleInfost = ModuleInfo_begin[ModuleInfo_start + (ModuleInfo_lastc == YYNEWLINE)];
	state[i] = (ModuleInfo_state_t) ModuleInfost;
	do {
		YY_DEBUG("<state %d, i = %d>\n", ModuleInfost, i);
		if (i >= size) {
			YY_FATAL("Token buffer overflow");
#ifdef YYEXIT
			if (ModuleInfoLexFatal)
				return -2;
#endif
		}	/* endif */

		/* get input char */
		if (i < ModuleInfo_end)
			c = ModuleInfotext[i];		/* get pushback char */
		else if (!ModuleInfoeof && (c = ModuleInfogetc()) != EOF) {
			ModuleInfo_end = i+1;
			ModuleInfotext[i] = (char)c;
		} else /* c == EOF */ {
			c = EOF;		/* just to make sure... */
			if (i == ModuleInfooldi) {	/* no token */
				ModuleInfoeof = 0;
				if (ModuleInfowrap())
					return 0;
				else
					goto ModuleInfo_again;
			} else {
				ModuleInfoeof = 1;	/* don't re-read EOF */
				break;
			}
		}
		YY_DEBUG("<input %d = 0x%02x>\n", c, c);

		/* look up next state */
		while ((ModuleInfobase = ModuleInfo_base[ModuleInfost]+(unsigned char)c) > ModuleInfo_nxtmax
		    || ModuleInfo_check[ModuleInfobase] != (ModuleInfo_state_t) ModuleInfost) {
			if (ModuleInfost == ModuleInfo_endst)
				goto ModuleInfo_jammed;
			ModuleInfost = ModuleInfo_default[ModuleInfost];
		}
		ModuleInfost = ModuleInfo_next[ModuleInfobase];
	  ModuleInfo_jammed: ;
	     state[++i] = (ModuleInfo_state_t) ModuleInfost;
	} while (!(ModuleInfost == ModuleInfo_endst || YY_INTERACTIVE &&
		ModuleInfo_base[ModuleInfost] > ModuleInfo_nxtmax && ModuleInfo_default[ModuleInfost] == ModuleInfo_endst));

	YY_DEBUG("<stopped %d, i = %d>\n", ModuleInfost, i);
	if (ModuleInfost != ModuleInfo_endst)
		++i;

  ModuleInfo_search:
	/* search backward for a final state */
	while (--i > ModuleInfooldi) {
		ModuleInfost = state[i];
		if ((ModuleInfofmin = ModuleInfo_final[ModuleInfost]) < (ModuleInfofmax = ModuleInfo_final[ModuleInfost+1]))
			goto ModuleInfo_found;	/* found final state(s) */
	}
	/* no match, default action */
	i = ModuleInfooldi + 1;
	output(ModuleInfotext[ModuleInfooldi]);
	goto ModuleInfo_again;

  ModuleInfo_found:
	YY_DEBUG("<final state %d, i = %d>\n", ModuleInfost, i);
	ModuleInfooleng = i;		/* save length for REJECT */
	
	// pushback look-ahead RHS, handling trailing context
	if ((c = (int)(ModuleInfo_la_act[ModuleInfofmin]>>9) - 1) >= 0) {
		unsigned char *bv = ModuleInfo_look + c*YY_LA_SIZE;
		static unsigned char bits [8] = {
			1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7
		};
		while (1) {
			if (--i < ModuleInfooldi) {	/* no / */
				i = ModuleInfooleng;
				break;
			}
			ModuleInfost = state[i];
			if (bv[(unsigned)ModuleInfost/8] & bits[(unsigned)ModuleInfost%8])
				break;
		}
	}

	/* perform action */
	ModuleInfoleng = i;
	YY_USER();
	switch (ModuleInfo_la_act[ModuleInfofmin] & 0777) {
	case 0:
	{   register int c, d;
					for (d = 0; c = input (); d = c == '-')
					{
						if ( c == EOF || c == '\n' || (d && c == '-'))
							break;
					}
				}
	break;
	case 1:
	{
				return MI_CCE;
			}
	break;
	case 2:
	{
			    return MI_DOT;
			}
	break;
	case 3:
	{
			    return MI_SEMICOLON;
			}
	break;
	case 4:
	{
			    return MI_COMMA;
			}
	break;
	case 5:
	{
			    return MI_LBRACE;
			}
	break;
	case 6:
	{
			    return MI_RBRACE;
			}
	break;
	case 7:
	{
			    return MI_LPAREN;
			}
	break;
	case 8:
	{
			    return MI_RPAREN;
			}
	break;
	case 9:
	{
			    return MI_LITNUMBER;
			}
	break;
	case 10:
	{
			    return MI_LITNUMBER;
			}
	break;
	case 11:
	{   	// Rule 20
				
				register struct table *t;

				ModuleInfolval.yy_name = NewString(ModuleInfotext);

			    for (t = reserved; t -> t_keyword; t++)
					if (strcmp (t -> t_keyword, ModuleInfotext) == 0) 
						return t -> t_value;
			    return MI_ID;
			}
	break;
	case 12:
	{ 
			    return MI_NAME;
			}
	break;
	case 13:
	{}
	break;
	case 14:
	{}
	break;
	case 15:
	{
			    return '=';
			}
	break;
	case 16:
	{
			    return ':';
			}
	break;
	case 17:
	{   
			}
	break;


	}
	YY_SCANNER();
	i = ModuleInfoleng;
	goto ModuleInfo_again;			/* action fell though */

#if 0 //removed because of build warning
  ModuleInfo_reject:
#endif
	YY_SCANNER();
	i = ModuleInfooleng;			/* restore original ModuleInfotext */
	if (++ModuleInfofmin < ModuleInfofmax)
		goto ModuleInfo_found;		/* another final state, same length */
	else
		goto ModuleInfo_search;		/* try shorter ModuleInfotext */

#if 0 //removed because of build warning
  ModuleInfo_more:
#endif

	YY_SCANNER();
	i = ModuleInfoleng;
	if (i > 0)
		ModuleInfo_lastc = ModuleInfotext[i-1];
	goto ModuleInfo_contin;
}

/*
 * user callable input/unput functions.
 */
void
ModuleInfo_scan::ModuleInfo_reset()
{
	YY_INIT();
	ModuleInfolineno = 1;
}
/* get input char with pushback */
int
ModuleInfo_scan::input()
{
	int c;
#ifndef YY_PRESERVE
	if (ModuleInfo_end > ModuleInfoleng) {
		ModuleInfo_end--;
		memmove(ModuleInfotext+ModuleInfoleng, ModuleInfotext+ModuleInfoleng+1,
			(size_t) (ModuleInfo_end-ModuleInfoleng));
		c = save;
		YY_USER();
#else
	if (push < save+size) {
		c = *push++;
#endif
	} else
		c = ModuleInfogetc();
	ModuleInfo_lastc = c;
	if (c == YYNEWLINE)
		ModuleInfolineno++;
	return c;
}

/* pushback char */
int
ModuleInfo_scan::unput(int c)
{
#ifndef YY_PRESERVE
	if (ModuleInfo_end >= size) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		if (ModuleInfo_end > ModuleInfoleng) {
			ModuleInfotext[ModuleInfoleng] = save;
			memmove(ModuleInfotext+ModuleInfoleng+1, ModuleInfotext+ModuleInfoleng,
				(size_t) (ModuleInfo_end-ModuleInfoleng));
			ModuleInfotext[ModuleInfoleng] = 0;
		}
		ModuleInfo_end++;
		save = (char)c;
#else
	if (push <= save) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		*--push = c;
#endif
		if (c == YYNEWLINE)
			ModuleInfolineno--;
	}	/* endif */
	return c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\errormessage.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"

#include <iostream.h>

#include "bool.hpp"
#include "newString.hpp"
#include "errorMessage.hpp"

SIMCErrorMessage::SIMCErrorMessage(const char * const inputStreamName, 
								   const char * const message,
								   const char * const severityString,
								   int errorId,
								   int severityLevel,
								   long lineNumber, long columnNumber)
				:	_errorId(errorId),
					_severityLevel(severityLevel),
					_lineNumber(lineNumber), 
					_columnNumber(columnNumber),
					_lineAndColumnValid(TRUE)
{
	if(inputStreamName)
	{
		if( !(_inputStreamName = NewString(inputStreamName)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_inputStreamName = NULL;

	if(message)
	{
		if( !(_message = NewString(message)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_message = NULL;

	if(severityString)
	{
		if( !(_severityString = NewString(severityString)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_severityString = NULL;

}
		
			
SIMCErrorMessage::~SIMCErrorMessage()
{
	if(_inputStreamName)
		delete[] _inputStreamName;
	if(_message)
		delete [] _message;
	if(_severityString)
		delete [] _severityString;
}

// And a copy constructor
SIMCErrorMessage::SIMCErrorMessage(const SIMCErrorMessage& rhs)
:	_errorId(rhs._errorId), _severityLevel(rhs._severityLevel),
	_lineNumber(rhs._lineNumber), _columnNumber(rhs._columnNumber),
	_lineAndColumnValid(rhs._lineAndColumnValid)
{
	if(rhs._inputStreamName)
	{
		if( !(_inputStreamName = NewString(rhs._inputStreamName)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_inputStreamName = NULL;

	if(rhs._message)
	{
		if( !(_message = NewString(rhs._message)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_message = NULL;

	if(rhs._severityString)
	{
		if( !(_severityString = NewString(rhs._severityString)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_severityString = NULL;

}

const SIMCErrorMessage& SIMCErrorMessage::operator = (const SIMCErrorMessage& rhs)
{
	_errorId = rhs._errorId;
	_severityLevel = rhs._severityLevel;
	_lineNumber = rhs._lineNumber;
	_columnNumber = rhs._columnNumber;
	_lineAndColumnValid = rhs._lineAndColumnValid;

	if( _inputStreamName )
		delete []_inputStreamName;
	if(rhs._inputStreamName)
		_inputStreamName = NewString(rhs._inputStreamName);
	else
		_inputStreamName = NULL;

	if(_message)
		delete []_message;
	if(rhs._message)
		_message = NewString(rhs._message);
	else
		_message = NULL;

	if(_severityString)
		delete []_severityString;
	if(rhs._severityString)
		_severityString = NewString(rhs._severityString);
	else
		_severityString = NULL;

	return *this;
}

	
BOOL SIMCErrorMessage::SetMessage( const char * const message)
{
	if(_message)
		delete [] _message;
	if(message)
	{
		if( !(_message = NewString(message)))
			return FALSE;
	}
	else
		_message = NULL;
	return TRUE;
}
		
BOOL SIMCErrorMessage::SetInputStreamName( const char * const inputStreamName)
{
	if(_inputStreamName)
		delete [] _inputStreamName;
	if(inputStreamName)
	{
		if( !(_inputStreamName = NewString(inputStreamName)))
			return FALSE;
	}
	else
		_inputStreamName = NULL;
	return TRUE;
}
		
BOOL SIMCErrorMessage::SetSeverityString( const char * const severityString)
{
	if(_severityString)
		delete [] _severityString;
	if(severityString)
	{
		if( !(_severityString = NewString(severityString)))
			return FALSE;
	}
	else
		_severityString = NULL;
	return TRUE;
}
		
// And a default output of the error message
ostream& operator << 
		( ostream& outStream, const SIMCErrorMessage& errorMessage)
{
	if(errorMessage._lineAndColumnValid)
	{
		outStream << "<" << errorMessage._errorId  << "," <<
		errorMessage._severityString << ">: \"" <<
		errorMessage._inputStreamName << "\" (line " <<
		errorMessage._lineNumber << ", col " <<
		errorMessage._columnNumber << "): " <<
		errorMessage._message <<  endl;
	}
	else
		outStream << errorMessage._message;

	return outStream;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\abstractparsetree.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "smierrsy.hpp"
#include "smierrsm.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "parser.hpp"
#include "abstractParseTree.hpp"

SIMCAbstractParseTree::~SIMCAbstractParseTree()
{
	if(_listOfModules)
	{
		SIMCModule *nextModule;
		while(!_listOfModules->IsEmpty() )
		{
			nextModule = _listOfModules->RemoveHead();
			delete nextModule;
		}
		delete _listOfModules;
	}
}

SIMCModule * SIMCAbstractParseTree::GetModule(
		const char *const moduleName) const
{
	POSITION p = _listOfModules->GetHeadPosition();

	SIMCModule * nextModule;
	while( p != NULL )
	{
		nextModule = _listOfModules->GetNext(p);
		if( strcmp(moduleName, nextModule->GetModuleName()) == 0 )
			return nextModule;
	}
	return NULL;
}

SIMCModule * SIMCAbstractParseTree::GetModuleOfFile(const char *const fileName) const
{
	POSITION p = _listOfModules->GetHeadPosition();

	SIMCModule * nextModule;
	while( p != NULL )
	{
		nextModule = _listOfModules->GetNext(p);
		if( strcmp(fileName, nextModule->GetInputFileName()) == 0 )
			return nextModule;
	}
	return NULL;
}



void SIMCAbstractParseTree::WriteTree(ostream& outStream) const
{
	const SIMCModuleList *x = GetListOfModules();
	SIMCModule *m;
	POSITION p = x->GetHeadPosition();
	while(p)
	{
		m = x->GetNext(p);
		outStream << (*m);
	}				
}

BOOL SIMCAbstractParseTree::CheckSyntax(ifstream& inputStream)
{
	SIMCScanner scanner;
	SIMCParser parser(_errorContainer, &scanner);
	if(!parser.SetSnmpVersion(_snmpVersion))
		return FALSE;
	if(!scanner.SetInput(inputStream))
		return FALSE;
	// parser->yydebug = 1;
	scanner.SetParser(&parser);
	if(parser.Parse())
		return WrapUpSyntaxCheck(parser);
	else
		return FALSE;
}

BOOL SIMCAbstractParseTree::CheckSyntax(const CString& inputFileName)
{
	SIMCScanner scanner;
	SIMCParser parser(_errorContainer, &scanner);
	if(!parser.SetSnmpVersion(_snmpVersion))
		return FALSE;
	if(!scanner.SetInput(inputFileName))
		return FALSE;
	// parser.yydebug = 1;
	scanner.SetParser(&parser);
	if(parser.Parse())
		return WrapUpSyntaxCheck(parser);
	else
		return FALSE;
}

BOOL SIMCAbstractParseTree::CheckSyntax(const int fileDescriptor)
{
	SIMCScanner scanner;
	SIMCParser parser(_errorContainer, &scanner);
	if(!parser.SetSnmpVersion(_snmpVersion))
		return FALSE;
	if(!scanner.SetInput(fileDescriptor))
		return FALSE;
	// parser.yydebug = 1;
	scanner.SetParser(&parser);
	if(parser.Parse())
		return WrapUpSyntaxCheck(parser);
	else
		return FALSE;
}

BOOL SIMCAbstractParseTree::CheckSyntax(FILE *fileStream)
{
	SIMCScanner scanner;
	SIMCParser parser(_errorContainer, &scanner);
	if(!parser.SetSnmpVersion(_snmpVersion))
		return FALSE;
	if(!scanner.SetInput(fileStream))
		return FALSE;
	// parser.yydebug = 1;
	scanner.SetParser(&parser);
	if(parser.Parse())
		return WrapUpSyntaxCheck(parser);
	else
		return FALSE;
}

BOOL SIMCAbstractParseTree::WrapUpSyntaxCheck( const SIMCParser& parser)
{	
	_fatalCount += parser.GetFatalCount();
	_warningCount += parser.GetWarningCount();
	_informationCount += parser.GetInformationCount();

	if (!parser.GetFatalCount()) // Parse() was  successful
	{
		_listOfModules->AddTail(parser.GetModule());
		// Set the new state
		_parseTreeState = UNRESOLVED;
		return TRUE;
	}
	else // State remamins the same
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\ytab.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
const ABSENT = 257;
const ANY = 258;
const APPLICATION = 259;
const BAR = 260;
const BGIN = 261;
const BIT = 262;
const BITSTRING = 263;
const _BOOLEAN = 264;
const BY = 265;
const CCE = 266;
const CHOICE = 267;
const COMMA = 268;
const COMPONENT = 269;
const COMPONENTS = 270;
const COMPONENTSOF = 271;
const CONTROL = 272;
const DECODER = 273;
const DEFAULT = 274;
const DEFINED = 275;
const DEFINITIONS = 276;
const DOT = 277;
const DOTDOT = 278;
const DOTDOTDOT = 279;
const ENCODER = 280;
const ENCRYPTED = 281;
const END = 282;
const ENUMERATED = 283;
const EXPORTS = 284;
const EXPLICIT = 285;
const FALSE_VAL = 286;
const FROM = 287;
const ID = 288;
const IDENTIFIER = 289;
const IMPLICIT = 290;
const IMPORTS = 291;
const INCLUDES = 292;
const INTEGER = 293;
const LANGLE = 294;
const LBRACE = 295;
const LBRACKET = 296;
const LITNUMBER = 297;
const LIT_HEX_STRING = 298;
const LIT_BINARY_STRING = 299;
const LITSTRING = 300;
const LPAREN = 301;
const MIN = 302;
const MAX = 303;
const NAME = 304;
const NIL = 305;
const OBJECT = 306;
const OCTET = 307;
const OCTETSTRING = 308;
const OF = 309;
const PARAMETERTYPE = 310;
const PREFIXES = 311;
const PRESENT = 312;
const PRINTER = 313;
const PRIVATE = 314;
const RBRACE = 315;
const RBRACKET = 316;
const REAL = 317;
const RPAREN = 318;
const SECTIONS = 319;
const SEMICOLON = 320;
const SEQUENCE = 321;
const SEQUENCEOF = 322;
const SET = 323;
const _SIZE = 324;
const STRING = 325;
const TAGS = 326;
const TRUE_VAL = 327;
const UNIVERSAL = 328;
const WITH = 329;
const PLUSINFINITY = 330;
const MINUSINFINITY = 331;
const MODULEID = 332;
const LASTUPDATE = 333;
const ORGANIZATION = 334;
const CONTACTINFO = 335;
const DESCRIPTION = 336;
const REVISION = 337;
const OBJECTIDENT = 338;
const STATUS = 339;
const REFERENCE = 340;
const OBJECTYPE = 341;
const SYNTAX = 342;
const BITSXX = 343;
const UNITS = 344;
const MAXACCESS = 345;
const ACCESS = 346;
const INDEX = 347;
const IMPLIED = 348;
const AUGMENTS = 349;
const DEFVAL = 350;
const NOTIFY = 351;
const OBJECTS = 352;
const TRAPTYPE = 353;
const ENTERPRISE = 354;
const VARIABLES = 355;
const TEXTCONV = 356;
const DISPLAYHINT = 357;
const OBJECTGROUP = 358;
const NOTIFYGROUP = 359;
const NOTIFICATIONS = 360;
const MODCOMP = 361;
const MODULE = 362;
const MANDATORY = 363;
const GROUP = 364;
const WSYNTAX = 365;
const MINACCESS = 366;
const AGENTCAP = 367;
const PRELEASE = 368;
const SUPPORTS = 369;
const INCLUDING = 370;
const VARIATION = 371;
const CREATION = 372;
typedef union {
	void			*yy_void;
	SIMCNumberInfo	*yy_number;
    int				yy_int;
	long			yy_long;
	SIMCModule		*yy_module;
	CList <SIMCModule *, SIMCModule *> *yy_module_list;
	SIMCSymbolReference *yy_symbol_ref;
	SIMCNameInfo * yy_name;
	SIMCHexStringInfo *yy_hex_string;
	SIMCBinaryStringInfo *yy_binary_string;
	SIMCAccessInfo *yy_access;
	SIMCAccessInfoV2 *yy_accessV2;
	SIMCStatusInfo *yy_status;
	SIMCStatusInfoV2 *yy_statusV2;
	SIMCObjectIdentityStatusInfo *yy_object_identity_status;
	SIMCNotificationTypeStatusInfo *yy_notification_type_status;
	SIMCIndexInfo		*yy_index;
	SIMCIndexInfoV2		*yy_indexV2;
	SIMCVariablesList	*yy_variables_list;
	SIMCObjectsList		*yy_objects_list;
	SIMCRangeOrSizeItem *yy_range_or_size_item;
	SIMCRangeList *yy_range_list;
	SIMCNamedNumberItem *yy_named_number_item;
	SIMCNamedNumberList *yy_named_number_list;
	SIMCDefValInfo *yy_def_val;
} YYSTYPE;
extern YYSTYPE yylval;

// C++ YACC parser header
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// yy_parse => class defining a parsing object
//	yy_parse needs a class yy_scan, which defines the scanner.
// %prefix or option -p xx determines name of this class; if not used,
// defaults to 'yy_scan'
//
// constructor fills in the tables for this grammar; give it a size
//    to determine size of state and value stacks. Default is 150 entries.
// destructor discards those state and value stacks
//
// int yy_parse::yyparse(yy_scan *) invokes parse; if this returns,
//	it can be recalled to continue parsing at last point.
// void yy_parse::yyreset() can be called to reset the parse;
//	call yyreset() before yy_parse::yyparse(yy_scan *)
#include <stdio.h>		// uses printf(), et cetera
#include <stdlib.h>		// uses exit()

const YYERRCODE = 256;		// YACC 'error' value

// You can use these macros in your action code
#define YYERROR		goto yyerrlabel
#define YYACCEPT	YYRETURN(0)
#define YYABORT		YYRETURN(1)
#define YYRETURN(val)	return(val)

#if YYDEBUG
typedef struct yyNamedType_tag {	/* Tokens */
	char	* name;		/* printable name */
	short	token;		/* token # */
	short	type;		/* token type */
} yyNamedType;
typedef struct yyTypedRules_tag {	/* Typed rule table */
	char	* name;		/* compressed rule string */
	short	type;		/* rule result type */
} yyTypedRules;
#endif

#ifdef YACC_WINDOWS

// include all windows prototypes, macros, constants, etc.

#include <windows.h>

// the following is the handle to the current
// instance of a windows program. The user
// program calling yyparse must supply this!

extern HANDLE hInst;	

#endif	/* YACC_WINDOWS */


class yy_parse {
protected:

#ifdef YACC_WINDOWS

	// protected member function for actual scanning 

	int	win_yyparse(yy_scan * ps);	// parse with given scanner

#endif	/* YACC_WINDOWS */

	int	mustfree;	// set if tables should be deleted
	int	size;		// size of state and value stacks
	int	reset;		// if set, reset state
	short	yyi;		// table index
	short	yystate;	// current state

	short	* stateStack;	// states stack
	YYSTYPE	* valueStack;	// values stack
	short	* yyps;		// top of state stack
	YYSTYPE * yypv;		// top of value stack

	YYSTYPE yylval;		// saved yylval
	YYSTYPE	yyval;		// $
	YYSTYPE * yypvt;	// $n
	int	yychar;		// current token
	int	yyerrflag;	// error flag
	int	yynerrs;	// error count
#if YYDEBUG
	int	done;		// set from trace to stop parse
	int	rule, npop;	// reduction rule # and length
	short	* typeStack;	// type stack to mirror valueStack[]
	short	* yytp;		// top of type stack
	char	* yygetState(int);	// read 'states.out'
#endif
public:
#if YYDEBUG
	// C++ has trouble with initialized arrays inside classes
	static long * States;		// pointer to yyStates[]
	static yyTypedRules * Rules;	// pointer to yyRules[]
	static yyNamedType * TokenTypes; // pointer to yyTokenTypes[]
	static int	yyntoken;	// number of tokens
	static int	yynvar;		// number of variables (nonterminals)
	static int	yynstate;	// number of YACC-generated states
	static int	yynrule;	// number of rules in grammar

	char*	yyptok(int);		// printable token string
	int	yyExpandName(int, int, char *, int);
						// expand encoded string
	virtual int	yyGetType(int);		// return type of token
	virtual void	yyShowRead();		// see newly read token
	virtual void	yyShowState();		// see state, value stacks
	virtual void	yyShowReduce();		// see reduction
	virtual void	yyShowGoto();		// see goto
	virtual void	yyShowShift();		// see shift
	virtual void	yyShowErrRecovery();	// see error recovery
	virtual void	yyShowErrDiscard();	// see token discard in error
#endif
	yy_scan* scan;			// pointer to scanner
	int	yydebug;	// if set, tracing if compiled with YYDEBUG=1

	yy_parse(int = 150);	// constructor for this grammar
	yy_parse(int, short *, YYSTYPE *);	// another constructor

	~yy_parse();		// destructor

	int	yyparse(yy_scan * ps);	// parse with given scanner

	void	yyreset() { reset = 1; } // restore state for next yyparse()

	void	setdebug(int y) { yydebug = y; }

// The following are useful in user actions:

	void	yyerrok() { yyerrflag = 0; }	// clear error
	void	yyclearin() { yychar = -1; }	// clear input
	int	YYRECOVERING() { return yyerrflag != 0; }
};
// end of .hpp header
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\lex_yy.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"


#define INITIAL 0
const yy_endst = 39;
const yy_nxtmax = 387;
#define YY_LA_SIZE 5

static unsigned short yy_la_act[] = {
 0, 26, 26, 25, 26, 5, 26, 6, 26, 7, 26, 8, 26, 9, 26, 10,
 26, 11, 26, 12, 26, 13, 26, 14, 26, 15, 26, 16, 26, 26, 20, 26,
 21, 26, 22, 26, 23, 24, 26, 26, 22, 21, 20, 19, 18, 16, 4, 3,
 2, 1, 17, 0
};

static unsigned char yy_look[] = {
 0
};

static short yy_final[] = {
 0, 0, 2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27,
 29, 30, 32, 34, 36, 37, 39, 40, 41, 42, 43, 43, 43, 43, 43, 44,
 45, 46, 47, 48, 48, 49, 50, 51
};
#ifndef yy_state_t
#define yy_state_t unsigned char
#endif

static yy_state_t yy_begin[] = {
 0, 0, 0
};

static yy_state_t yy_next[] = {
 22, 22, 22, 22, 22, 22, 22, 22, 22, 19, 20, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 19, 22, 1, 22, 22, 22, 22, 16, 13, 14, 22, 22, 6, 2, 4, 22,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 3, 5, 12, 21, 22, 22,
 22, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 10, 22, 11, 22, 22,
 22, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 7, 9, 8, 22, 22,
 23, 33, 34, 35, 24, 36, 39, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 39, 30, 31, 39, 39, 39, 23, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 30, 31, 39, 39, 39, 39, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 25, 39, 39, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 39,
 39, 39, 39, 39, 39, 39, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 39, 39, 39, 39, 39, 39, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 27, 39, 39, 39, 39, 39, 39, 39, 39, 26, 26, 28, 28, 28, 28, 28,
 28, 28, 28, 39, 39, 39, 39, 29, 39, 39, 28, 28, 28, 28, 28, 28,
 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 39, 39, 39, 39, 39, 39,
 39, 28, 28, 28, 28, 28, 28, 39, 39, 39, 28, 28, 28, 28, 28, 28,
 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 39, 39, 39, 39, 39, 39,
 39, 28, 28, 28, 28, 28, 28, 37, 39, 39, 38, 38, 38, 38, 38, 38,
 38, 38, 38, 38, 0
};

static yy_state_t yy_check[] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 19, 4, 33, 3, 18, 35, 38, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, ~0, 29, 27, ~0, ~0, ~0, 19, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 29, 27, ~0, ~0, ~0, ~0, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 17, ~0, ~0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, ~0,
 ~0, ~0, ~0, ~0, ~0, ~0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
 ~0, ~0, ~0, ~0, ~0, ~0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
 16, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, ~0, ~0, ~0, ~0, 28, ~0, ~0, 16, 16, 16, 16, 16, 16,
 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, ~0, ~0, ~0, ~0, ~0, ~0,
 ~0, 28, 28, 28, 28, 28, 28, ~0, ~0, ~0, 16, 16, 16, 16, 16, 16,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, ~0, ~0, ~0, ~0, ~0, ~0,
 ~0, 28, 28, 28, 28, 28, 28, 2, ~0, ~0, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 0
};

static yy_state_t yy_default[] = {
 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
 39, 39, 39, 39, 39, 39, 39, 19, 18, 17, 16, 29, 39, 39, 39, 39,
 15, 39, 39, 39, 39, 39, 2, 0
};

static short yy_base[] = {
 0, 388, 330, 73, 83, 388, 388, 388, 388, 388, 388, 388, 388, 388, 388, 304,
 249, 165, 87, 119, 388, 388, 388, 388, 388, 388, 388, 81, 272, 74, 388, 388,
 388, 84, 388, 72, 388, 388, 89, 388
};



// MKS LEX prototype scanner code
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can redefine YY_INTERACTIVE to be 0 to get a very slightly
// faster scanner:
#ifndef YY_INTERACTIVE
#define	YY_INTERACTIVE	1
#endif

// You can compile with -DYY_DEBUG to get a print trace of the scanner
#ifdef YY_DEBUG
#undef YY_DEBUG
#define YY_DEBUG(fmt,a1,a2)	fprintf(stderr,fmt,a1,a2)
#else
#define YY_DEBUG(fmt,a1,a2)
#endif

const MIN_NUM_STATES = 20;

// Do *NOT* redefine the following:
#define	BEGIN		yy_start =

#if 0 //removed because of build warning
#define	REJECT		goto yy_reject
#define	yymore()	goto yy_more
#endif


#ifndef	lint
static char *RCSid = "$Header$";
#endif

/* 
 * $Header$
 *
 *
 * $Log$
 */

/*
 *			  ISODE 8.0 NOTICE
 *
 *   Acquisition, use, and distribution of this module and related
 *   materials are subject to the restrictions of a license agreement.
 *   Consult the Preface in the User's Manual for the full terms of
 *   this agreement.
 *
 *
 *			4BSD/ISODE SNMPv2 NOTICE
 *
 *    Acquisition, use, and distribution of this module and related
 *    materials are subject to the restrictions given in the file
 *    SNMPv2-READ-ME.
 *
 */

#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>

#include "smierrsy.hpp"
#include "scanner.hpp"
#include "parser.hpp"

#define theScanner ((SIMCScanner *)this)
#define theParser  ( theScanner->GetParser())

YYSTYPE yylval;

struct table {
    char   *t_keyword;
    int	    t_value;
    int	    t_porting;
};

static struct table reserved[] = {
    "ABSENT", ABSENT, 0,
    "ANY", ANY, 0,
    "APPLICATION", APPLICATION, 0, 	// For Tagged types
    "BEGIN", BGIN, 0,
    "BIT", BIT, 0,
    "BITSTRING", BITSTRING, 0,
    "BOOLEAN", _BOOLEAN, 0,
    "BY", BY, 0,
    "CHOICE", CHOICE, 0,
	
    "DEFAULT", DEFAULT, 0,
    "DEFINED", DEFINED, 0,
    "DEFINITIONS", DEFINITIONS, 0,

    "END", END, 0,
	
	"FALSE", FALSE_VAL, 0,
    "FROM", FROM, 0,
    "IDENTIFIER", IDENTIFIER, 0,
    "IMPLICIT", IMPLICIT, 0,
    "IMPORTS", IMPORTS, 0,
	
    "INTEGER", INTEGER, 0,
    "MIN", MIN, 0,
    "MAX", MAX, 0,
    "NULL", NIL, 0,
    "OBJECT", OBJECT, 0,
    "OCTET", OCTET, 0,
    "OCTETSTRING", OCTETSTRING, 0,
    "OF", OF, 0,
	
    "PRIVATE", PRIVATE, 0,				// For Tagged Types
    
    "SEQUENCE", SEQUENCE, 0,
    "SEQUENCEOF", SEQUENCEOF, 0,
    "SIZE", _SIZE, 0,
    "STRING", STRING, 0,
    "TAGS", TAGS, 0,
    "TRUE", TRUE_VAL, 0,
    "UNIVERSAL", UNIVERSAL, 0,			// For Tagged Types
    
	"MODULE-IDENTITY", MODULEID, 1,
    "LAST-UPDATED", LASTUPDATE, 0,
    "ORGANIZATION", ORGANIZATION, 0,
    "CONTACT-INFO", CONTACTINFO, 0,
    "DESCRIPTION", DESCRIPTION, 0,
    "REVISION", REVISION, 0,
    
    "OBJECT-IDENTITY", OBJECTIDENT, 1,
    "STATUS", STATUS, 0,
    "REFERENCE", REFERENCE, 0,

    "OBJECT-TYPE", OBJECTYPE, 1,
    "SYNTAX", SYNTAX, 0,
    "BITS", BITSXX, 0,
    "UNITS", UNITS, 0,
    "MAX-ACCESS", MAXACCESS, 0,
    "ACCESS", ACCESS, 0,		/* backwards compatibility */
    "INDEX", INDEX, 0,
    "IMPLIED", IMPLIED, 0,
    "AUGMENTS", AUGMENTS, 0,
    "DEFVAL", DEFVAL, 0,

    "NOTIFICATION-TYPE", NOTIFY, 1,
    "OBJECTS",      OBJECTS, 0,

    "TRAP-TYPE", TRAPTYPE, 1,		/* backwards compatibility */
    "ENTERPRISE", ENTERPRISE, 0,	/*   .. */
    "VARIABLES", VARIABLES, 0,		/*   .. */

    "TEXTUAL-CONVENTION", TEXTCONV, 1,
    "DISPLAY-HINT", DISPLAYHINT, 0,

    "OBJECT-GROUP", OBJECTGROUP, 1,

    "NOTIFICATION-GROUP", NOTIFYGROUP, 1,
    "NOTIFICATIONS", NOTIFICATIONS, 0,

    "MODULE-COMPLIANCE", MODCOMP, 1,
    "MODULE", MODULE, 0,
    "MANDATORY-GROUPS", MANDATORY, 0,
    "GROUP", GROUP, 0,
    "WRITE-SYNTAX", WSYNTAX, 0,
    "MIN-ACCESS", MINACCESS, 0,

    "AGENT-CAPABILITIES", AGENTCAP, 1,
    "PRODUCT-RELEASE", PRELEASE, 0,
    "SUPPORTS", SUPPORTS, 0,
    "INCLUDES", INCLUDING, 0,
    "VARIATION", VARIATION, 0,
    "CREATION-REQUIRES", CREATION, 0,

    NULL, 0
};

static int simc_debug = 0;

static BOOL CanFitInto32Bits(const char *  text)
{
	if(text[0] == '-')
	{
		// Check if > -2147483648
		text ++;
		unsigned long length = strlen(text);
		if(length < 10)
			return TRUE;
		else if(length > 10 )
			return FALSE;
		else
		{
			int index = 0;
	
			if(text[index] > '2')
				return FALSE;
			else if (text[index] < '2')
				return TRUE;
			index ++;

			if(text[index] > '1')
				return FALSE;
			else if (text[index] < '1')
				return TRUE;
			index ++;

			if(text[index] > '4')
				return FALSE;
			else if (text[index] < '4')
				return TRUE;
			index ++;

			if(text[index] > '7')
				return FALSE;
			else if (text[index] < '7')
				return TRUE;
			index ++;

			if(text[index] > '4')
				return FALSE;
			else if (text[index] < '4')
				return TRUE;
			index ++;

			if(text[index] > '8')
				return FALSE;
			else if (text[index] < '8')
				return TRUE;
			index ++;

			if(text[index] > '3')
				return FALSE;
			else if (text[index] < '3')
				return TRUE;
			index ++;

			if(text[index] > '6')
				return FALSE;
			else if (text[index] < '6')
				return TRUE;
			index ++;

			if(text[index] > '4')
				return FALSE;
			else if (text[index] < '4')
				return TRUE;
			index ++;

			if(text[index] > '8')
				return FALSE;
			else if (text[index] < '8')
				return TRUE;

			return TRUE;
		}
	}
	else
	{
		// Check if < 4294967295
		unsigned long length = strlen(text);
		if(length < 10)
			return TRUE;
		else if(length > 10 )
			return FALSE;
		else
		{
			int index = 0;

			if(text[index] > '4')
				return FALSE;
			else if (text[index] < '4')
				return TRUE;
			index ++;

			if(text[index] > '2')
				return FALSE;
			else if (text[index] < '2')
				return TRUE;
			index ++;

			if(text[index] > '9')
				return FALSE;
			else if (text[index] < '9')
				return TRUE;
			index ++;

			if(text[index] > '4')
				return FALSE;
			else if (text[index] < '4')
				return TRUE;
			index ++;

			if(text[index] > '9')
				return FALSE;
			else if (text[index] < '9')
				return TRUE;
			index ++;

			if(text[index] > '6')
				return FALSE;
			else if (text[index] < '6')
				return TRUE;
			index ++;

			if(text[index] > '7')
				return FALSE;
			else if (text[index] < '7')
				return TRUE;
			index ++;

			if(text[index] > '2')
				return FALSE;
			else if (text[index] < '2')
				return TRUE;
			index ++;

			if(text[index] > '9')
				return FALSE;
			else if (text[index] < '9')
				return TRUE;
			index ++;

			if(text[index] > '5')
				return FALSE;
			else if (text[index] < '5')
				return TRUE;

			return TRUE;
		}
	}
}
	



// Constructor for yy_scan. Set up tables
#if 0 //removed because build warning
#pragma argsused
#endif
yy_scan::yy_scan(int sz, char* buf, char* sv, yy_state_t* states)
{
	mustfree = 0;
	if ((size = sz) < MIN_NUM_STATES
	  || (yytext = buf) == 0
	  || (state = states) == 0) {
		yyerror("Bad space for scanner!");
		exit(1);
	}
#ifdef YY_PRESERVE
	save = sv;
#endif
}
// Constructor for yy_scan. Set up tables
yy_scan::yy_scan(int sz)
{
	size = sz;
	yytext = new char[sz+1];	// text buffer
	state = new yy_state_t[sz+1];	// state buffer
#ifdef YY_PRESERVE
	save = new char[sz];	// saved yytext[]
	push = save + sz;
#endif
	if (yytext == NULL
#ifdef YY_PRESERVE
	  || save == NULL
#endif
	  || state == NULL) {
		yyerror("No space for scanner!");
		exit(1);
	}
	mustfree = 1;
	yy_end = 0;
	yy_start = 0;
	yy_lastc = YYNEWLINE;
	yyin = stdin;
	yyout = stdout;
	yylineno = 1;
	yyleng = 0;
}

// Descructor for yy_scan
yy_scan::~yy_scan()
{
	if (mustfree) {
		mustfree = 0;
		delete(yytext);
		delete(state);
#ifdef YY_PRESERVE
		delete(save);
#endif
	}
}

// Print error message, showing current line number
void
yy_scan::yyerror(char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
#ifdef LEX_WINDOWS
	// Windows has no concept of a standard error output!
	// send output to yyout as a simple solution
	if (yylineno)
		fprintf(yyout, "%d: ", yylineno);
	(void) vfprintf(yyout, fmt, va);
	fputc('\n', yyout);
#else /* LEX_WINDOWS */
	if (yylineno)
		fprintf(stderr, "%d: ", yylineno);
	(void) vfprintf(stderr, fmt, va);
	fputc('\n', stderr);
#endif /* LEX_WINDOWS */
	va_end(va);
}


#ifdef LEX_WINDOWS

// The initial portion of the lex scanner
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_yylex() to acutally begin the
// scanning. When complete, win_yylex() will return a
// value back to our new yylex() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of yylex().

int
yy_scan::yylex()
{
	int wReturnValue;
	HANDLE hRes_table;
	unsigned short *old_yy_la_act;	// remember previous pointer values
	short *old_yy_final;
	yy_state_t *old_yy_begin;
	yy_state_t *old_yy_next;
	yy_state_t *old_yy_check;
	yy_state_t *old_yy_default;
	short *old_yy_base;

	// the following code will load the required
	// resources for a Windows based parser. 

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_yyLEX", "yyLEXTBL"));
	
	// return an error code if any
	// of the resources did not load 

	if (hRes_table == (HANDLE)NULL) 
		return (0);
	
	// the following code will lock the resources
	// into fixed memory locations for the scanner
	// (remember previous pointer locations)

	old_yy_la_act = yy_la_act;
	old_yy_final = yy_final;
	old_yy_begin = yy_begin;
	old_yy_next = yy_next;
	old_yy_check = yy_check;
	old_yy_default = yy_default;
	old_yy_base = yy_base;

	yy_la_act = (unsigned short *)LockResource (hRes_table);
	yy_final = (short *)(yy_la_act + Sizeof_yy_la_act);
	yy_begin = (yy_state_t *)(yy_final + Sizeof_yy_final);
	yy_next = (yy_state_t *)(yy_begin + Sizeof_yy_begin);
	yy_check = (yy_state_t *)(yy_next + Sizeof_yy_next);
	yy_default = (yy_state_t *)(yy_check + Sizeof_yy_check);
	yy_base = (short *)(yy_default + Sizeof_yy_default);


	// call the standard yylex() code

	wReturnValue = win_yylex();

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previously saved pointers
	//

	yy_la_act = old_yy_la_act;
	yy_final = old_yy_final;
	yy_begin = old_yy_begin;
	yy_next = old_yy_next;
	yy_check = old_yy_check;
	yy_default = old_yy_default;
	yy_base = old_yy_base;

	return (wReturnValue);
}	// end yylex()

// The actual lex scanner
// yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
// yytext[0:yyleng-1] contains the current token.
// yytext[yyleng:yy_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains yytext[yyleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 

int 
yy_scan::win_yylex()

#else /* LEX_WINDOWS */

// The actual lex scanner
// yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
// yytext[0:yyleng-1] contains the current token.
// yytext[yyleng:yy_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains yytext[yyleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 
int
yy_scan::yylex()
#endif /* LEX_WINDOWS */

{
	int c, i, yybase;
	unsigned  yyst;		/* state */
	int yyfmin, yyfmax;	/* yy_la_act indices of final states */
	int yyoldi, yyoleng;	/* base i, yyleng before look-ahead */
	int yyeof;		/* 1 if eof has already been read */



#ifdef YYEXIT
	yyLexFatal = 0;
#endif
	yyeof = 0;
	i = yyleng;
	YY_SCANNER();

  yy_again:
	if ((yyleng = i) > 0) {
		yy_lastc = yytext[i-1];	// determine previous char
		while (i > 0)	//	// scan previously token
			if (yytext[--i] == YYNEWLINE)	// fix yylineno
				yylineno++;
	}
	yy_end -= yyleng;		// adjust pushback
	memmove(yytext, yytext+yyleng, (size_t) yy_end);
	i = 0;

  yy_contin:
	yyoldi = i;

	/* run the state machine until it jams */
	yyst = yy_begin[yy_start + (yy_lastc == YYNEWLINE)];
	state[i] = (yy_state_t) yyst;
	do {
		YY_DEBUG("<state %d, i = %d>\n", yyst, i);
		if (i >= size) {
			YY_FATAL("Token buffer overflow");
#ifdef YYEXIT
			if (yyLexFatal)
				return -2;
#endif
		}	/* endif */

		/* get input char */
		if (i < yy_end)
			c = yytext[i];		/* get pushback char */
		else if (!yyeof && (c = yygetc()) != EOF) {
			yy_end = i+1;
			yytext[i] = (char)c;
		} else /* c == EOF */ {
			c = EOF;		/* just to make sure... */
			if (i == yyoldi) {	/* no token */
				yyeof = 0;
				if (yywrap())
					return 0;
				else
					goto yy_again;
			} else {
				yyeof = 1;	/* don't re-read EOF */
				break;
			}
		}
		YY_DEBUG("<input %d = 0x%02x>\n", c, c);

		/* look up next state */
		while ((yybase = yy_base[yyst]+(unsigned char)c) > yy_nxtmax
		    || yy_check[yybase] != (yy_state_t) yyst) {
			if (yyst == yy_endst)
				goto yy_jammed;
			yyst = yy_default[yyst];
		}
		yyst = yy_next[yybase];
	  yy_jammed: ;
	     state[++i] = (yy_state_t) yyst;
	} while (!(yyst == yy_endst || YY_INTERACTIVE &&
		yy_base[yyst] > yy_nxtmax && yy_default[yyst] == yy_endst));

	YY_DEBUG("<stopped %d, i = %d>\n", yyst, i);
	if (yyst != yy_endst)
		++i;

  yy_search:
	/* search backward for a final state */
	while (--i > yyoldi) {
		yyst = state[i];
		if ((yyfmin = yy_final[yyst]) < (yyfmax = yy_final[yyst+1]))
			goto yy_found;	/* found final state(s) */
	}
	/* no match, default action */
	i = yyoldi + 1;
	output(yytext[yyoldi]);
	goto yy_again;

  yy_found:
	YY_DEBUG("<final state %d, i = %d>\n", yyst, i);
	yyoleng = i;		/* save length for REJECT */
	
	// pushback look-ahead RHS, handling trailing context
	if ((c = (int)(yy_la_act[yyfmin]>>9) - 1) >= 0) {
		unsigned char *bv = yy_look + c*YY_LA_SIZE;
		static unsigned char bits [8] = {
			1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7
		};
		while (1) {
			if (--i < yyoldi) {	/* no / */
				i = yyoleng;
				break;
			}
			yyst = state[i];
			if (bv[(unsigned)yyst/8] & bits[(unsigned)yyst%8])
				break;
		}
	}

	/* perform action */
	yyleng = i;
	YY_USER();
	switch (yy_la_act[yyfmin] & 0777) {
	case 0:
	{	  // Rule 0
	
					theScanner->columnNo ++;
			    int	    c, len;
			    register char *cp, *ep, *pp;

			    if ((pp = (char *)malloc ((unsigned) (len = BUFSIZ)))
				    == NULL)
					yyerror ("out of memory");

			    for (ep = (cp = pp) + len - 1;;) 
				{
					if ((c = input ()) == EOF)
					{
						theParser->SyntaxError(UNTERMINATED_STRING, 
							yylineno, theScanner->columnNo);
						 
						return 0;

					}
					else
					{
						((SIMCScanner *) this)->columnNo++;
						if (c == '"')
							break;
		
						if (cp >= ep) 
						{
							register int curlen = (int)(cp - pp);
							register char *dp;

							if ((dp = (char *)realloc (pp,
									   (unsigned) (len += BUFSIZ)))
								== NULL)
								yyerror ("out of memory");
							cp = dp + curlen;
							ep = (pp = dp) + len - 1;
						}
						*cp++ = (char)c;
					}
			    }
			    *cp = NULL;
			    yylval.yy_name = new SIMCNameInfo(pp, yylineno,
								theScanner->columnNo - yyleng);
			    return LITSTRING;
			}
	break;
	case 1:
	{   register int c, d;
					theScanner->columnNo += 2;
					for (d = 0; c = input (); d = c == '-')
					{
						theScanner->columnNo++;
						if ( c == EOF || c == '\n' || (d && c == '-'))
							break;
					}
				}
	break;
	case 2:
	{
				theScanner->columnNo += 3;
				return CCE;
			}
	break;
	case 3:
	{
				theScanner->columnNo += 3;
				return DOTDOTDOT;	
			}
	break;
	case 4:
	{
    			theScanner->columnNo += 2;
			    return DOTDOT;
			}
	break;
	case 5:
	{	theScanner->columnNo ++;
			    return DOT;
			}
	break;
	case 6:
	{
			    theScanner->columnNo ++;
			    return SEMICOLON;
			}
	break;
	case 7:
	{
			    theScanner->columnNo ++;
			    return COMMA;
			}
	break;
	case 8:
	{
				yylval.yy_name = new SIMCNameInfo(yytext, yylineno, 
						theScanner->columnNo);

			    theScanner->columnNo ++;
			    return LBRACE;
			}
	break;
	case 9:
	{
			    theScanner->columnNo ++;
			    return RBRACE;
			}
	break;
	case 10:
	{	// Rule 10
			    theScanner->columnNo ++;
			    return BAR;
			}
	break;
	case 11:
	{
			    theScanner->columnNo ++;
			    return LBRACKET;
			}
	break;
	case 12:
	{
			    theScanner->columnNo ++;
			    return RBRACKET;
			}
	break;
	case 13:
	{
			    theScanner->columnNo ++;
			    return LANGLE;
			}
	break;
	case 14:
	{
			    theScanner->columnNo ++;
			    return LPAREN;
			}
	break;
	case 15:
	{
			    theScanner->columnNo ++;
			    return RPAREN;
			}
	break;
	case 16:
	{
				long retVal;
			    theScanner->columnNo +=  yyleng;

				if(!CanFitInto32Bits(yytext) )			
					theParser->SyntaxError(TOO_BIG_NUM, 
						yylineno, theScanner->columnNo,
						NULL, yytext);

				sscanf (yytext, "%ld", &retVal);
				yylval.yy_number = new SIMCNumberInfo(retVal, 
							yylineno, theScanner->columnNo - yyleng, TRUE);
			    return LITNUMBER;
			}
	break;
	case 17:
	{
				long retVal;
			    theScanner->columnNo +=  yyleng;

				if(!CanFitInto32Bits(yytext) )			
					theParser->SyntaxError(TOO_BIG_NUM, 
						yylineno, theScanner->columnNo,
						NULL, yytext);

				sscanf (yytext, "%ld", &retVal);
				yylval.yy_number = new SIMCNumberInfo(retVal, 
							yylineno, theScanner->columnNo - yyleng, FALSE);
			    return LITNUMBER;
			}
	break;
	case 18:
	{   
				theScanner->columnNo +=  yyleng;
				
				yytext[yyleng-2] = NULL;	

				/*
				if(strlen(yytext+1) > 32 )			
					theParser->SyntaxError(TOO_BIG_NUM, 
						yylineno, theScanner->columnNo,
						NULL, yytext+1);
				*/
				yylval.yy_hex_string = new SIMCBinaryStringInfo(yytext, 
							yylineno, theScanner->columnNo - yyleng);
			    return LIT_BINARY_STRING;
			}
	break;
	case 19:
	{   
				theScanner->columnNo +=  yyleng;
				
				yytext[yyleng-2] = NULL;	// Remove the apostrophe and h 

				yylval.yy_hex_string = new SIMCHexStringInfo(yytext+1, 
							yylineno, theScanner->columnNo - yyleng);
			    return LIT_HEX_STRING;
			}
	break;
	case 20:
	{   	// Rule 20
				
				theScanner->columnNo += yyleng;
				register struct table *t;

				yylval.yy_name = new SIMCNameInfo(yytext, yylineno,
										theScanner->columnNo - yyleng);

			    for (t = reserved; t -> t_keyword; t++)
					if (strcmp (t -> t_keyword, yytext) == 0) 
					{
						if( simc_debug)
							cerr << "yylex(): Returning RESERVED_WORD" << 
								"(" << yytext << ")" << endl;
						return t -> t_value;
					}
			 	if( simc_debug)
					cerr << "yylex(): Returning ID" <<
								"(" << yytext << ")" << endl;
			    return ID;
			}
	break;
	case 21:
	{ 

				theScanner->columnNo += yyleng;
				  
				yylval.yy_name = new SIMCNameInfo(yytext, yylineno,
										theScanner->columnNo - yyleng);
			    return NAME;
			}
	break;
	case 22:
	{
					theScanner->columnNo +=  yyleng;
			}
	break;
	case 23:
	{
				theScanner->columnNo = 0;
			}
	break;
	case 24:
	{
				theScanner->columnNo++;
			    return '=';
			}
	break;
	case 25:
	{
			    theScanner->columnNo++;
			    return ':';
			}
	break;
	case 26:
	{   
				theParser->SyntaxError(UNRECOGNIZED_CHARACTER, 
					yylineno, theScanner->columnNo,
					yytext);
			}
	break;


	}
	YY_SCANNER();
	i = yyleng;
	goto yy_again;			/* action fell though */

#if 0 //removed because of build warning
  yy_reject:
#endif

	YY_SCANNER();
	i = yyoleng;			/* restore original yytext */
	if (++yyfmin < yyfmax)
		goto yy_found;		/* another final state, same length */
	else
		goto yy_search;		/* try shorter yytext */

#if 0 //removed because of build warning
  yy_more:
#endif

	YY_SCANNER();
	i = yyleng;
	if (i > 0)
		yy_lastc = yytext[i-1];
	goto yy_contin;
}

/*
 * user callable input/unput functions.
 */
void
yy_scan::yy_reset()
{
	YY_INIT();
	yylineno = 1;
}
/* get input char with pushback */
int
yy_scan::input()
{
	int c;
#ifndef YY_PRESERVE
	if (yy_end > yyleng) {
		yy_end--;
		memmove(yytext+yyleng, yytext+yyleng+1,
			(size_t) (yy_end-yyleng));
		c = save;
		YY_USER();
#else
	if (push < save+size) {
		c = *push++;
#endif
	} else
		c = yygetc();
	yy_lastc = c;
	if (c == YYNEWLINE)
		yylineno++;
	return c;
}

/* pushback char */
int
yy_scan::unput(int c)
{
#ifndef YY_PRESERVE
	if (yy_end >= size) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		if (yy_end > yyleng) {
			yytext[yyleng] = save;
			memmove(yytext+yyleng+1, yytext+yyleng,
				(size_t) (yy_end-yyleng));
			yytext[yyleng] = 0;
		}
		yy_end++;
		save = (char)c;
#else
	if (push <= save) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		*--push = c;
#endif
		if (c == YYNEWLINE)
			yylineno--;
	}	/* endif */
	return c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\infoyacc.cpp ===
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//

#ifdef MODULEINFOTRACE
#define MODULEINFODEBUG 1
#else
#ifndef MODULEINFODEBUG
#define MODULEINFODEBUG 1
#endif
#endif


#include <iostream.h>
#include <fstream.h>

#include "precomp.h"
#include <snmptempl.h>


#include "infoLex.hpp"
#include "infoYacc.hpp"
#include "moduleInfo.hpp"

#include <autoptr.h>

#define theModuleInfo ((SIMCModuleInfoParser *)this)



extern MODULEINFOSTYPE ModuleInfolval;
#if MODULEINFODEBUG
enum MODULEINFO_Types { MODULEINFO_t_NoneDefined, MODULEINFO_t_yy_name
};
#endif
#if MODULEINFODEBUG
ModuleInfoTypedRules ModuleInfoRules[] = {
	{ "&00: %01 &00",  0},
	{ "%01: %02 &05 %03 &02 %04",  0},
	{ "%02: &07 &11 %05 &12",  1},
	{ "%02: &07 &11 &01 &12",  1},
	{ "%02: &07",  1},
	{ "%02: &09",  1},
	{ "%04: &08 %06 &10",  0},
	{ "%04: &08 &01 &10",  0},
	{ "%04: &08 %07 &10",  0},
	{ "%04: %08",  0},
	{ "%04: &07",  0},
	{ "%04: &09",  0},
	{ "%07: %09",  0},
	{ "%07: %08",  0},
	{ "%09: %09 %10",  0},
	{ "%09: %10",  0},
	{ "%10: %06 &06 %11",  0},
	{ "%10: &01 &06 %11",  0},
	{ "%11: &07 &11 %05 &12",  0},
	{ "%11: &07 &11 &01 &12",  0},
	{ "%11: &07",  0},
	{ "%06: %06 &04 %12",  0},
	{ "%06: %12",  0},
	{ "%12: &07",  0},
	{ "%12: &09",  0},
	{ "%05: %13 %05",  0},
	{ "%05: %13",  0},
	{ "%13: %14",  0},
	{ "%13: &09 &13 &16 &14",  0},
	{ "%13: &09 &13 %14 &14",  0},
	{ "%13: &16",  0},
	{ "%14: &07 &15 &09",  0},
	{ "%14: &09",  0},
	{ "%08:",  0},
	{ "%03: %15",  0},
	{ "%03: &03",  0},
	{ "%15: &17 &17",  0},
	{ "%15: &17 &18",  0},
	{ "%15: &18",  0},
{ "$accept",  0},{ "error",  0}
};
ModuleInfoNamedType ModuleInfoTokenTypes[] = {
	{ "$end",  0,  0},
	{ "error",  256,  0},
	{ "MI_BGIN",  257,  0},
	{ "MI_CCE",  258,  0},
	{ "MI_COMMA",  259,  0},
	{ "MI_DEFINITIONS",  260,  0},
	{ "MI_FROM",  261,  0},
	{ "MI_ID",  262,  1},
	{ "MI_IMPORTS",  263,  0},
	{ "MI_NAME",  264,  1},
	{ "MI_SEMICOLON",  265,  0},
	{ "MI_LBRACE",  266,  0},
	{ "MI_RBRACE",  267,  0},
	{ "MI_LPAREN",  268,  0},
	{ "MI_RPAREN",  269,  0},
	{ "MI_DOT",  270,  0},
	{ "MI_LITNUMBER",  271,  0},
	{ "':'",  58,  0},
	{ "'='",  61,  0}

};
#endif
#if MODULEINFODEBUG
static char *	MODULEINFOStatesFile = "states.out";
long ModuleInfoStates[] = {
0L, 14L, 25L, 88L, 114L, 128L, 172L, 198L, 216L, 227L, 302L, 313L, 346L, 
368L, 390L, 401L, 429L, 440L, 451L, 477L, 495L, 539L, 554L, 577L, 600L, 
615L, 630L, 671L, 690L, 701L, 723L, 745L, 756L, 767L, 778L, 847L, 874L, 
897L, 920L, 931L, 942L, 953L, 964L, 975L, 1008L, 1026L, 1062L, 1116L, 
1134L, 1170L, 1185L, 1204L, 1222L, 1241L, 1259L, 1277L, 1296L, 1371L, 
1390L, 1409L, 1428L, 1472L, 1494L, 1516L, 1539L
};
const MODULEINFOMAX_READ = 75;
#endif
static short ModuleInfodef[] = {

	  40,   -1,   31,   38,   -5,   -9,  -13,    3
};
static short ModuleInfoex[] = {

	   0,    0,   -1,    1,    0,   37,   -1,    1,  265,   37, 
	  -1,    1,  265,   39,   -1,    1
};
static short ModuleInfoact[] = {

	  -1,  -40,  264,  262,  -30,  266,  -29,  260,  -27,  -28, 
	  -3,  -58,  271,  264,  262,  256,  -25,  -65,  -62,  258, 
	  61,   58,  -23,  270,  -22,  268,  -28,   -3,  -58,  271, 
	 264,  262,  -39,  267,  -38,  267,  -63,  -64,   61,   58, 
	  -5,  257,  -59,  264,  -28,  -60,  -20,  271,  264,  262, 
	 -36,   -6,  -45,  264,  263,  262,  -57,  269,  -56,  269, 
	 -18,  -33,  -53,  264,  262,  256,  -16,  -33,  -53,  264, 
	 262,  256,  -43,  265,  -14,  -42,  265,  261,  -13,  -12, 
	 -41,  265,  261,  259,  -14,  261,  -13,  -12,  261,  259, 
	  -8,  262,  -33,  -53,  264,  262,  -11,  266,  -10,  -28, 
	  -3,  -58,  271,  264,  262,  256,  -34,  267,  -35,  267,   -1
};
static short ModuleInfopact[] = {

	   5,    8,   25,   29,   53,   63,   69,   97,  109,  107, 
	 102,   91,   94,   91,   88,   85,   81,   76,   73,   59, 
	  57,   47,   43,   41,   38,   35,   33,   23,   19,   12, 
	   7,    2
};
static short ModuleInfogo[] = {

	  -2,  -31,  -24,  -37,  -54,   -9,  -26,   10,    3,  -15, 
	 -17,    6,  -19,  -46,  -44,    5,   -7,  -47,  -48,    6, 
	 -49,  -50,   11,  -51,  -52,   12,   -4,  -21,  -55,   21, 
	 -61,   -1
};
static short ModuleInfopgo[] = {

	   0,    0,    0,   21,   24,   21,   21,    3,    0,    1, 
	   1,    1,    3,    3,    3,    3,    3,   12,   16,   16, 
	  18,   18,   10,   10,   24,    6,   26,   26,   26,   26, 
	  28,   28,    2,    2,   30,   30,   30,   14,    6,   12, 
	   1,    0
};
static short ModuleInforlen[] = {

	   0,    0,    0,    1,    1,    4,    4,    1,    5,    4, 
	   4,    1,    3,    3,    3,    1,    1,    1,    2,    1, 
	   3,    3,    3,    1,    1,    2,    1,    4,    4,    1, 
	   3,    1,    1,    1,    2,    2,    1,    0,    1,    1, 
	   1,    2
};
#define MODULEINFOS0	31
#define MODULEINFODELTA	28
#define MODULEINFONPACT	32
#define MODULEINFONDEF	8

#define MODULEINFOr39	0
#define MODULEINFOr40	1
#define MODULEINFOr41	2
#define MODULEINFOr20	3
#define MODULEINFOr23	4
#define MODULEINFOr19	5
#define MODULEINFOr18	6
#define MODULEINFOr10	7
#define MODULEINFOr1	8
#define MODULEINFOrACCEPT	MODULEINFOr39
#define MODULEINFOrERROR	MODULEINFOr40
#define MODULEINFOrLR2	MODULEINFOr41
#if MODULEINFODEBUG
char * ModuleInfosvar[] = {
	"$accept",
	"ModuleDefinition",
	"ModuleIdentifier",
	"AllowedCCE",
	"Imports",
	"ObjectIDComponentList",
	"SymbolList",
	"SymbolsImported",
	"empty",
	"SymbolsFromModuleList",
	"SymbolsFromModule",
	"ImportModuleIdentifier",
	"Symbol",
	"ObjectSubID",
	"QualifiedName",
	"InsteadOfCCE",
	0
};
short ModuleInformap[] = {

	  39,   40,   41,   20,   23,   19,   18,   10,    1,    2, 
	   3,    5,    6,    7,    8,    9,   11,   13,   14,   15, 
	  16,   17,   21,   22,   24,   25,   27,   28,   29,   30, 
	  31,   32,   34,   35,   36,   37,   38,   33,   26,   12, 
	   4,    0
};
short ModuleInfosmap[] = {

	   2,    4,    9,   11,   26,   34,   43,   56,   62,   61, 
	  60,   54,   53,   51,   48,   47,   46,   45,   44,   30, 
	  29,   20,   19,   18,   15,   13,   12,    7,    6,    5, 
	   3,    0,   39,   63,   64,   32,   35,   23,   22,    1, 
	  55,   52,   50,   33,   31,   42,   49,   41,   59,   57, 
	  58,   40,   38,   21,   10,   37,   36,    8,   27,   28, 
	  17,   16,   25,   24,   14
};
int ModuleInfo_parse::ModuleInfontoken = 19;
int ModuleInfo_parse::ModuleInfonvar = 16;
int ModuleInfo_parse::ModuleInfonstate = 65;
int ModuleInfo_parse::ModuleInfonrule = 42;
#endif



// C++ YACC parser code
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// If MODULEINFODEBUG is defined as 1 and ModuleInfo_parse::ModuleInfodebug is set to 1,
// ModuleInfoparse() will print a travelogue of its actions as it reads
// and parses input.
//
// MODULEINFOSYNC can be defined to cause ModuleInfoparse() to attempt to always
// hold a lookahead token

const MODULEINFO_MIN_STATE_NUM = 20;	// not useful to be too small!

#if MODULEINFODEBUG
#ifdef MODULEINFOTRACE
long	* ModuleInfo_parse::States	= ModuleInfoStates;
#endif
ModuleInfoTypedRules * ModuleInfo_parse::Rules	= ModuleInfoRules;
ModuleInfoNamedType * ModuleInfo_parse::TokenTypes = ModuleInfoTokenTypes;

#define MODULEINFO_TRACE(fn) { done = 0; fn(); if (done) MODULEINFORETURN(-1); }
#endif

// Constructor for ModuleInfo_parse: user-provided tables
ModuleInfo_parse::ModuleInfo_parse(int sz, short * states, MODULEINFOSTYPE * stack)
{
	mustfree = 0;
	if ((size = sz) < MODULEINFO_MIN_STATE_NUM
	 || (stateStack = states) == (short *) 0
	 || (valueStack = stack) == (MODULEINFOSTYPE *) 0) {
		fprintf(stderr,"Bad state/stack given");
		exit(1);
	}
	reset = 1;		// force reset
#if MODULEINFODEBUG
	ModuleInfodebug = 0;
	typeStack = new short[size+1];
	if (typeStack == (short *) 0) {
		fprintf(stderr,"Cannot allocate typeStack");
		exit(1);
	}
#endif
}
// Constructor for ModuleInfo_parse: allocate tables with new
ModuleInfo_parse::ModuleInfo_parse(int sz)
{
	size = sz;
	reset = 1;		// force reset
	mustfree = 1;		// delete space in deconstructor
#if MODULEINFODEBUG
	ModuleInfodebug = 0;

	typeStack = new short[size+1];
	wmilib::auto_buffer<short> typeStack_Guard ( typeStack ) ;

#endif
	stateStack = new short[size+1];
	wmilib::auto_buffer<short> stateStack_Guard ( stateStack ) ;

	valueStack = new MODULEINFOSTYPE[size+1];
	wmilib::auto_buffer<MODULEINFOSTYPE> valueStack_Guard ( valueStack ) ;

	if (stateStack == (short *) 0 || valueStack == (MODULEINFOSTYPE *) 0
#if MODULEINFODEBUG
		|| typeStack == (short *) 0
#endif
	    ) {
		fprintf(stderr,"Not enough space for parser stacks");
		exit(1);
	}

	//
	// Get rid of scope guard
	//
	valueStack_Guard.release () ;
	stateStack_Guard.release () ;

#if MODULEINFODEBUG
	typeStack_Guard.release () ;
#endif
}
// Destructor for class ModuleInfo_parse
//	Free up space
ModuleInfo_parse::~ModuleInfo_parse()
{
	if (mustfree) {
		delete [] stateStack;
		delete [] valueStack;
	}
	stateStack = (short *) 0;
#if MODULEINFODEBUG
	delete [] typeStack;
#endif
}

#ifdef YACC_WINDOWS

// The initial portion of the yacc parser.
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_ModuleInfoparse() to acutally begin the
// parsing. When complete, win_ModuleInfoparse() will return a
// value back to our new ModuleInfoparse() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of ModuleInfoparse().

int
ModuleInfo_parse::ModuleInfoparse(ModuleInfo_scan* ps)
{
	int wReturnValue;
	HANDLE hRes_table;
	short *old_ModuleInfodef;		// the following are used for saving
	short *old_ModuleInfoex;		// the current pointers
	short *old_ModuleInfoact;
	short *old_ModuleInfopact;
	short *old_ModuleInfogo;
	short *old_ModuleInfopgo;
	short *old_ModuleInforlen;

	// the following code will load the required
	// resources for a Windows based parser.

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_ModuleInfoYACC", "ModuleInfoYACCTBL"));
	
	// return an error code if any
	// of the resources did not load

	if (hRes_table == (HANDLE)NULL)
		return (1);
	
	// the following code will lock the resources
	// into fixed memory locations for the parser
	// (also, save away the old pointer values)

	old_ModuleInfodef = ModuleInfodef;
	old_ModuleInfoex = ModuleInfoex;
	old_ModuleInfoact = ModuleInfoact;
	old_ModuleInfopact = ModuleInfopact;
	old_ModuleInfogo = ModuleInfogo;
	old_ModuleInfopgo = ModuleInfopgo;
	old_ModuleInforlen = ModuleInforlen;

	ModuleInfodef = (short *)LockResource (hRes_table);
	ModuleInfoex = (short *)(ModuleInfodef + Sizeof_ModuleInfodef);
	ModuleInfoact = (short *)(ModuleInfoex + Sizeof_ModuleInfoex);
	ModuleInfopact = (short *)(ModuleInfoact + Sizeof_ModuleInfoact);
	ModuleInfogo = (short *)(ModuleInfopact + Sizeof_ModuleInfopact);
	ModuleInfopgo = (short *)(ModuleInfogo + Sizeof_ModuleInfogo);
	ModuleInforlen = (short *)(ModuleInfopgo + Sizeof_ModuleInfopgo);

	// call the official ModuleInfoparse() function

	wReturnValue = win_ModuleInfoparse (ps);

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previous pointer values
	//

	ModuleInfodef = old_ModuleInfodef;
	ModuleInfoex = old_ModuleInfoex;
	ModuleInfoact = old_ModuleInfoact;
	ModuleInfopact = old_ModuleInfopact;
	ModuleInfogo = old_ModuleInfogo;
	ModuleInfopgo = old_ModuleInfopgo;
	ModuleInforlen = old_ModuleInforlen;

	return (wReturnValue);
}	// end ModuleInfoparse()


// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling ModuleInfoparse().
//	Call ModuleInforeset() before ModuleInfoparse() if you want a fresh start

int
ModuleInfo_parse::win_ModuleInfoparse(ModuleInfo_scan* ps)

#else /* YACC_WINDOWS */

// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling ModuleInfoparse().
//	Call ModuleInforeset() before ModuleInfoparse() if you want a fresh start
int
ModuleInfo_parse::ModuleInfoparse(ModuleInfo_scan* ps)

#endif /* YACC_WINDOWS */

{
	short	* ModuleInfop, * ModuleInfoq;		// table lookup
	int	ModuleInfoj;
#if MODULEINFODEBUG
	int	ModuleInforuletype = 0;
#endif

	if ((scan = ps) == (ModuleInfo_scan *) 0) {	// scanner
		fprintf(stderr,"No scanner");
		exit(1);
	}

	if (reset) {			// start new parse
		ModuleInfonerrs = 0;
		ModuleInfoerrflag = 0;
		ModuleInfops = stateStack;
		ModuleInfopv = valueStack;
#if MODULEINFODEBUG
		ModuleInfotp = typeStack;
#endif
		ModuleInfostate = MODULEINFOS0;
		ModuleInfoclearin();
		reset = 0;
	} else			// continue saved parse
		goto ModuleInfoNext;			// after action

ModuleInfoStack:
	if (++ModuleInfops > &stateStack[size]) {
		scan->ModuleInfoerror("Parser stack overflow");
		MODULEINFOABORT;
	}
	*ModuleInfops = ModuleInfostate;	/* stack current state */
	*++ModuleInfopv = ModuleInfoval;	/* ... and value */
#if MODULEINFODEBUG
	if (ModuleInfodebug) {
		*++ModuleInfotp = (short)ModuleInforuletype;	/* ... and type */
		MODULEINFO_TRACE(ModuleInfoShowState)
	}
#endif

	/*
	 * Look up next action in action table.
	 */
ModuleInfoEncore:
#ifdef MODULEINFOSYNC
	if (ModuleInfochar < 0) {
		if ((ModuleInfochar = scan->ModuleInfolex()) < 0) {
			if (ModuleInfochar == -2) MODULEINFOABORT;
			ModuleInfochar = 0;
		}	/* endif */
		ModuleInfolval = ::ModuleInfolval;
#if MODULEINFODEBUG
		if (ModuleInfodebug)
			ModuleInfoShowRead();	// show new input token
#endif
	}
#endif
#ifdef YACC_WINDOWS
	if (ModuleInfostate >= Sizeof_ModuleInfopact) 	/* simple state */
#else /* YACC_WINDOWS */
	if (ModuleInfostate >= sizeof ModuleInfopact/sizeof ModuleInfopact[0]) 	/* simple state */
#endif /* YACC_WINDOWS */
		ModuleInfoi = ModuleInfostate - MODULEINFODELTA;	/* reduce in any case */
	else {
		if(*(ModuleInfop = &ModuleInfoact[ModuleInfopact[ModuleInfostate]]) >= 0) {
			/* Look for a shift on ModuleInfochar */
#ifndef MODULEINFOSYNC
			if (ModuleInfochar < 0) {
				if ((ModuleInfochar = scan->ModuleInfolex()) < 0) {
					if (ModuleInfochar == -2) MODULEINFOABORT;
					ModuleInfochar = 0;
				}	/* endif */
				ModuleInfolval = ::ModuleInfolval;
#if MODULEINFODEBUG
				if (ModuleInfodebug)
					ModuleInfoShowRead();	// show new input token
#endif
			}
#endif
			ModuleInfoq = ModuleInfop;
			ModuleInfoi = (short)ModuleInfochar;
			while (ModuleInfoi < *ModuleInfop++)
				;
			if (ModuleInfoi == ModuleInfop[-1]) {
				ModuleInfostate = ~ModuleInfoq[ModuleInfoq-ModuleInfop];
#if MODULEINFODEBUG
				if (ModuleInfodebug) {
					ModuleInforuletype = ModuleInfoGetType(ModuleInfochar);
					MODULEINFO_TRACE(ModuleInfoShowShift)
				}
#endif
				ModuleInfoval = ModuleInfolval;		/* stack value */
				ModuleInfoclearin();		/* clear token */
				if (ModuleInfoerrflag)
					ModuleInfoerrflag--;	/* successful shift */
				goto ModuleInfoStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

#ifdef YACC_WINDOWS
		if (ModuleInfostate >= Sizeof_ModuleInfodef) 	/* simple state */
#else /* YACC_WINDOWS */
		if (ModuleInfostate >= sizeof ModuleInfodef /sizeof ModuleInfodef[0])
#endif /* YACC_WINDOWS */
			goto ModuleInfoError;
		if ((ModuleInfoi = ModuleInfodef[ModuleInfostate]) < 0)	 { /* default == reduce? */

			/* Search exception table */
			ModuleInfop = &ModuleInfoex[~ModuleInfoi];
#ifndef MODULEINFOSYNC
			if (ModuleInfochar < 0) {
				if ((ModuleInfochar = scan->ModuleInfolex()) < 0) {
					if (ModuleInfochar == -2) MODULEINFOABORT;
					ModuleInfochar = 0;
				}	/* endif */
				ModuleInfolval = ::ModuleInfolval;
#if MODULEINFODEBUG
				if (ModuleInfodebug)
					ModuleInfoShowRead();	// show new input token
#endif
			}
#endif
			while((ModuleInfoi = *ModuleInfop) >= 0 && ModuleInfoi != ModuleInfochar)
				ModuleInfop += 2;
			ModuleInfoi = ModuleInfop[1];
		}
	}

	ModuleInfoj = ModuleInforlen[ModuleInfoi];

#if MODULEINFODEBUG
	if (ModuleInfodebug) {
		npop = ModuleInfoj; rule = ModuleInfoi;
		MODULEINFO_TRACE(ModuleInfoShowReduce)
		ModuleInfotp -= ModuleInfoj;
	}
#endif
	ModuleInfops -= ModuleInfoj;		/* pop stacks */
	ModuleInfopvt = ModuleInfopv;		/* save top */
	ModuleInfopv -= ModuleInfoj;
	ModuleInfoval = ModuleInfopv[1];	/* default action $ = $1 */
#if MODULEINFODEBUG
	if (ModuleInfodebug)
		ModuleInforuletype = ModuleInfoRules[ModuleInformap[ModuleInfoi]].type;
#endif
	switch (ModuleInfoi) {		/* perform semantic action */
		
case MODULEINFOr1: {	/* ModuleDefinition :  ModuleIdentifier MI_DEFINITIONS AllowedCCE MI_BGIN Imports */

						theModuleInfo->SetModuleName(ModuleInfopvt[-4].yy_name);
						return 0;
					
} break;

case MODULEINFOr10: {	/* Imports :  MI_ID */

			delete ModuleInfopvt[0].yy_name;
		
} break;

case MODULEINFOr18: {	/* ImportModuleIdentifier :  MI_ID MI_LBRACE ObjectIDComponentList MI_RBRACE */

			theModuleInfo->AddImportModule(ModuleInfopvt[-3].yy_name);
			delete ModuleInfopvt[-3].yy_name;
		
} break;

case MODULEINFOr19: {	/* ImportModuleIdentifier :  MI_ID MI_LBRACE error MI_RBRACE */

			theModuleInfo->AddImportModule(ModuleInfopvt[-3].yy_name);
			delete ModuleInfopvt[-3].yy_name;
		
} break;

case MODULEINFOr20: {	/* ImportModuleIdentifier :  MI_ID */

			theModuleInfo->AddImportModule(ModuleInfopvt[0].yy_name);
			delete ModuleInfopvt[0].yy_name;
		
} break;

case MODULEINFOr23: {	/* Symbol :  MI_ID */

			delete ModuleInfopvt[0].yy_name;
		
} break;
	case MODULEINFOrACCEPT:
		MODULEINFOACCEPT;
	case MODULEINFOrERROR:
		goto ModuleInfoError;
	}
ModuleInfoNext:
	/*
	 *	Look up next state in goto table.
	 */

	ModuleInfop = &ModuleInfogo[ModuleInfopgo[ModuleInfoi]];
	ModuleInfoq = ModuleInfop++;
	ModuleInfoi = *ModuleInfops;
	while (ModuleInfoi < *ModuleInfop++)		/* busy little loop */
		;
	ModuleInfostate = ~(ModuleInfoi == *--ModuleInfop? ModuleInfoq[ModuleInfoq-ModuleInfop]: *ModuleInfoq);
#if MODULEINFODEBUG
	if (ModuleInfodebug)
		MODULEINFO_TRACE(ModuleInfoShowGoto)
#endif
	goto ModuleInfoStack;

#if 0 //removed because of build warning
ModuleInfoerrlabel:	;		/* come here from MODULEINFOERROR	*/
#endif

	ModuleInfoerrflag = 1;
	if (ModuleInfoi == MODULEINFOrERROR) {
		ModuleInfops--, ModuleInfopv--;
#if MODULEINFODEBUG
		if (ModuleInfodebug) ModuleInfotp--;
#endif
	}
	
ModuleInfoError:
	switch (ModuleInfoerrflag) {

	case 0:		/* new error */
		ModuleInfonerrs++;
		ModuleInfoi = (short)ModuleInfochar;
		scan->ModuleInfoerror("Syntax error");
		if (ModuleInfoi != ModuleInfochar) {
			/* user has changed the current token */
			/* try again */
			ModuleInfoerrflag++;	/* avoid loops */
			goto ModuleInfoEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		ModuleInfoerrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; ModuleInfops > stateStack; ModuleInfops--, ModuleInfopv--
#if MODULEINFODEBUG
					, ModuleInfotp--
#endif
		) {
#ifdef YACC_WINDOWS
			if (*ModuleInfops >= Sizeof_ModuleInfopact) 	/* simple state */
#else /* YACC_WINDOWS */
			if (*ModuleInfops >= sizeof ModuleInfopact/sizeof ModuleInfopact[0])
#endif /* YACC_WINDOWS */
				continue;
			ModuleInfop = &ModuleInfoact[ModuleInfopact[*ModuleInfops]];
			ModuleInfoq = ModuleInfop;
			do
				;
			while (MODULEINFOERRCODE < *ModuleInfop++);
			if (MODULEINFOERRCODE == ModuleInfop[-1]) {
				ModuleInfostate = ~ModuleInfoq[ModuleInfoq-ModuleInfop];
				goto ModuleInfoStack;
			}
				
			/* no shift in this state */
#if MODULEINFODEBUG
			if (ModuleInfodebug && ModuleInfops > stateStack+1)
				MODULEINFO_TRACE(ModuleInfoShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (ModuleInfochar == 0)  /* but not EOF */
			break;
#if MODULEINFODEBUG
		if (ModuleInfodebug)
			MODULEINFO_TRACE(ModuleInfoShowErrDiscard)
#endif
		ModuleInfoclearin();
		goto ModuleInfoEncore;	/* try again in same state */
	}
	MODULEINFOABORT;

}
#if MODULEINFODEBUG
/*
 * Return type of token
 */
int
ModuleInfo_parse::ModuleInfoGetType(int tok)
{
	ModuleInfoNamedType * tp;
	for (tp = &ModuleInfoTokenTypes[ModuleInfontoken-1]; tp > ModuleInfoTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}

	
// Print a token legibly.
char *
ModuleInfo_parse::ModuleInfoptok(int tok)
{
	ModuleInfoNamedType * tp;
	for (tp = &ModuleInfoTokenTypes[ModuleInfontoken-1]; tp > ModuleInfoTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}
/*
 * Read state 'num' from MODULEINFOStatesFile
 */
#ifdef MODULEINFOTRACE

char *
ModuleInfo_parse::ModuleInfogetState(int num)
{
	int	size;
	char	*cp;
	static FILE *ModuleInfoStatesFile = (FILE *) 0;
	static char ModuleInfoReadBuf[MODULEINFOMAX_READ+1];

	if (ModuleInfoStatesFile == (FILE *) 0
	 && (ModuleInfoStatesFile = fopen(MODULEINFOStatesFile, "r")) == (FILE *) 0)
		return "ModuleInfoExpandName: cannot open states file";

	if (num < ModuleInfonstate - 1)
		size = (int)(States[num+1] - States[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(ModuleInfoStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(ModuleInfoStatesFile) - States[num]);
	}
	if (size < 0 || size > MODULEINFOMAX_READ)
		return "ModuleInfoExpandName: bad read size";
	if (fseek(ModuleInfoStatesFile, States[num], 0) < 0) {
	cannot_seek:
		return "ModuleInfoExpandName: cannot seek in states file";
	}

	(void) fread(ModuleInfoReadBuf, 1, size, ModuleInfoStatesFile);
	ModuleInfoReadBuf[size] = '\0';
	return ModuleInfoReadBuf;
}
#endif /* MODULEINFOTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode ModuleInfoStates and ModuleInfoRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
ModuleInfo_parse::ModuleInfoExpandName(int num, int isrule, char * buf, int len)
{
	int	i, n, cnt, type;
	char	* endp, * cp, * s;

	if (isrule)
		s = ModuleInfoRules[num].name;
	else
#ifdef MODULEINFOTRACE
		s = ModuleInfogetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = ModuleInfonvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = ModuleInfontoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= ModuleInfonvar)
					goto too_big;
				cp = ModuleInfosvar[n];
			} else if (n >= ModuleInfontoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = ModuleInfoTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef MODULEINFOTRACE
/*
 * Show current state of ModuleInfoparse
 */
void
ModuleInfo_parse::ModuleInfoShowState()
{
	(void) printf("state %d (%d), char %s (%d)\n%d stateStack entries\n",
		ModuleInfosmap[ModuleInfostate],ModuleInfostate,ModuleInfoptok(ModuleInfochar),ModuleInfochar,
		ModuleInfopv - valueStack);
}
// show results of reduction: ModuleInfoi is rule number
void
ModuleInfo_parse::ModuleInfoShowReduce()
{
	(void) printf("Reduce by rule %d (pop#=%d)\n", ModuleInformap[rule], npop);
}
// show read token
void
ModuleInfo_parse::ModuleInfoShowRead()
{
	(void) printf("read %s (%d)\n", ModuleInfoptok(ModuleInfochar), ModuleInfochar);
}
// show Goto
void
ModuleInfo_parse::ModuleInfoShowGoto()
{
	(void) printf("goto %d (%d)\n", ModuleInfosmap[ModuleInfostate], ModuleInfostate);
}
// show Shift
void
ModuleInfo_parse::ModuleInfoShowShift()
{
	(void) printf("shift %d (%d)\n", ModuleInfosmap[ModuleInfostate], ModuleInfostate);
}
// show error recovery
void
ModuleInfo_parse::ModuleInfoShowErrRecovery()
{
	(void) printf("Error recovery pops state %d (%d), uncovers %d (%d)\n",
		ModuleInfosmap[*(ModuleInfops-1)], *(ModuleInfops-1), ModuleInfosmap[ModuleInfostate], ModuleInfostate);
}
// show token discards in error processing
void
ModuleInfo_parse::ModuleInfoShowErrDiscard()
{
	(void) printf("Error recovery discards %s (%d), ",
		ModuleInfoptok(ModuleInfochar), ModuleInfochar);
}
#endif	/* ! MODULEINFOTRACE */
#endif	/* MODULEINFODEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\group.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>
#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "oidValue.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "objectType.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"



const char * const SIMCObjectGroup::StatusStringsTable[] = 
{
	"current",
	"deprecated",
	"obsolete"
};



ostream& operator << (ostream& outStream, const SIMCScalar& obj)
{
	outStream << "SCALAR: " << obj.symbol->GetSymbolName() <<  "(" <<
		(obj.symbol->GetModule())->GetModuleName() << ")" << endl;
	return outStream;
}



ostream& operator << (ostream& outStream, const SIMCTable& obj)
{

	outStream << "TABLE: " << obj.tableSymbol->GetSymbolName() <<  "(" <<
		(obj.tableSymbol->GetModule())->GetModuleName() << ")" << endl;
	outStream << "\tROW: " << obj.rowSymbol->GetSymbolName() << "(" <<
		(obj.rowSymbol->GetModule())->GetModuleName() << ")"   << endl;
	outStream <<"\tCOLUMNS :" << (int)(obj.columnMembers)->GetCount() << endl;
	POSITION p = (obj.columnMembers)->GetHeadPosition();
	SIMCScalar *s;
	while(p)
	{
		s = (obj.columnMembers)->GetNext(p);
		outStream << (*s) ;
	}
	return outStream;
}

ostream& operator << (ostream& outStream, const SIMCObjectGroup& obj)
{

	 outStream << "Group: " << (obj.namedNode)->GetSymbolName() << endl;
	POSITION p;
	if(obj.scalars)
	{
		p = (obj.scalars)->GetHeadPosition();
		while(p)
			outStream << (*(obj.scalars)->GetNext(p)) ;
	}

	if(obj.tables)
	{
		p = (obj.tables)->GetHeadPosition();
		while(p)
			outStream << (*(obj.tables)->GetNext(p)) ;
	}
	outStream << "End of Group =================================" << endl;
	return outStream;
}

ostream& operator << (ostream& outStream, const SIMCGroupList& obj)
{
	outStream << "GROUPS:" << endl;

	POSITION p = obj.GetHeadPosition();
	while(p)
		outStream << (* obj.GetNext(p)) ;
	outStream << "END OF GROUPS" << endl;
	return outStream;
}

BOOL SIMCTable::IsColumnMember(const SIMCSymbol *symbol) const
{
	if(!columnMembers)
		return FALSE;

	SIMCScalar *nextScalar;
	POSITION p = columnMembers->GetHeadPosition();
	while(p)
	{
		nextScalar = columnMembers->GetNext(p);
		if((*nextScalar->GetSymbol()) == *symbol )
			return TRUE;
	}
	return FALSE;
}

const char * const SIMCTable::GetTableDescription() const
{
	SIMCSymbol **typeRef = ((SIMCValueReference *)tableSymbol)->GetTypeReference();
	SIMCTypeReference *btRef;
	if( SIMCModule::IsTypeReference(typeRef, btRef) != RESOLVE_CORRECT)
		return NULL;

	SIMCObjectTypeType *objType = ( SIMCObjectTypeType *) ((SIMCBuiltInTypeReference*)btRef)->GetType();
	return objType->GetDescription();
}


const char * const SIMCTable::GetRowDescription() const
{
	SIMCSymbol **typeRef = ((SIMCValueReference *)rowSymbol)->GetTypeReference();
	SIMCTypeReference *btRef;
	if( SIMCModule::IsTypeReference(typeRef, btRef) != RESOLVE_CORRECT)
		return NULL;

	SIMCObjectTypeType *objType = ( SIMCObjectTypeType *) ((SIMCBuiltInTypeReference*)btRef)->GetType();
	return objType->GetDescription();
}

SIMCScalar *SIMCTable::GetColumnMember(SIMCSymbol *columnSymbol) const
{
	if(!columnMembers)
		return NULL;

	POSITION p = columnMembers->GetHeadPosition();
	SIMCScalar *nextMember =  NULL;
	while(p)
	{
		nextMember = columnMembers->GetNext(p);
		if(nextMember->GetSymbol() == columnSymbol)
			return nextMember;
	}
	return NULL;
}

SIMCScalar *SIMCObjectGroup::GetScalar(SIMCSymbol *objectSymbol) const
{
	if(!scalars)
		return NULL;

	POSITION p = scalars->GetHeadPosition();
	SIMCScalar *nextScalar = NULL;
	while(p)
	{
		nextScalar = scalars->GetNext(p);
		if(nextScalar->GetSymbol() == objectSymbol)
			return nextScalar;
	}
	return NULL;
}

SIMCTable* SIMCObjectGroup::GetTable(SIMCSymbol *objectSymbol) const
{
	if(!tables)
		return NULL;

	POSITION p = tables->GetHeadPosition();
	SIMCTable *nextTable = NULL;
	while(p)
	{
		nextTable = tables->GetNext(p);
		if(nextTable->IsColumnMember(objectSymbol))
			return nextTable;
	}
	return NULL;
}

// This function checks whether any of the scalars or tables present in a group are
// defined in the module specified.
BOOL SIMCObjectGroup::ObjectsInModule(const SIMCModule *theModule) const
{
	// First check the scalars
	if(scalars) 
	{
		POSITION p = scalars->GetHeadPosition();
		SIMCScalar *nextScalar = NULL;
		while(p)
		{
			nextScalar = scalars->GetNext(p);
			if(nextScalar->GetSymbol()->GetModule() == theModule)
				return TRUE;
		}
	}

	// Then the tables. Only the root of the tables are checked
	if(tables)
	{
		POSITION p = tables->GetHeadPosition();
		SIMCTable *nextTable = NULL;
		while(p)
		{
			nextTable = tables->GetNext(p);
			if(nextTable->GetTableSymbol()->GetModule() == theModule)
				return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\moduleinfo.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"
#include <snmptempl.h>


#include "infoLex.hpp"
#include "infoYacc.hpp"
#include "moduleInfo.hpp"

BOOL SIMCModuleInfoParser::GetModuleInfo( SIMCModuleInfoScanner *tempScanner)
{
	if(ModuleInfoparse(tempScanner) != 0 ) 
		return FALSE;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\newstring.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"
#include "newString.hpp"

char   *NewString (const char * const s)
{
    register char  *p;
	if(!s)
		return NULL;
    if (	(p = (char *) 
					new    char [(unsigned) (strlen (s) + 1) ] 
			) 
			== NULL
		)
    	return NULL;

    strcpy (p, s);
    return p;
}

char *NewString(const int len)
{
	if(len<1)
		return NULL;

	return new char[len];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\notificationgroup.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>
#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "oidValue.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"



const char * const SIMCNotificationGroup::StatusStringsTable[] = 
{
	"current",
	"deprecated",
	"obsolete"
};

const char *const SIMCNotificationGroup::NOTIFICATION_GROUP_FABRICATION_SUFFIX = "V1NotificationGroup";
const int SIMCNotificationGroup::NOTIFICATION_GROUP_FABRICATION_SUFFIX_LEN = 19;


ostream& operator << (ostream& outStream, const SIMCNotificationElement& obj)
{
	outStream << "NOTIFICATION: " << obj.symbol->GetSymbolName() <<  "(" <<
		(obj.symbol->GetModule())->GetModuleName() << ")" << endl;
	return outStream;
}



ostream& operator << (ostream& outStream, const SIMCNotificationGroup& obj)
{

	 outStream << "Notification Group: " << (obj.enterpriseNode)->GetSymbolName() << endl;
	POSITION p;
	if(obj.notifications)
	{
		p = (obj.notifications)->GetHeadPosition();
		while(p)
			outStream << (*(obj.notifications)->GetNext(p)) ;
	}

	outStream << "End of Notification Group =================================" << endl;
	return outStream;
}

ostream& operator << (ostream& outStream, const SIMCNotificationList& obj)
{
	outStream << "NOTIFICATION GROUPS:" << endl;

	POSITION p = obj.GetHeadPosition();
	while(p)
		outStream << (* obj.GetNext(p)) ;
	outStream << "END OF NOTIFICATION GROUPS" << endl;
	return outStream;
}



BOOL SIMCModuleNotificationGroups::AddNotification(SIMCSymbol *notificationSymbol)
{
	// NOT IMPELEMNTED
	return FALSE;
}

const SIMCNotificationGroupList *SIMCModuleNotificationGroups::GetNotificationGroupList() const
{
	return &theList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\module.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "newString.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "oidValue.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "module.hpp"
#include "oidTree.hpp"
#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "parser.hpp"
#include "abstractParseTree.hpp"
#include "parseTree.hpp"
 
const int SIMCModule::SYMBOLS_PER_MODULE = 1000;



SIMCModule::SIMCModule(const char *const moduleName,
			const char *const inputFileName,
			SIMCSymbolTable *symbolTable,			
			CList < SIMCModule *,  SIMCModule *> *listOfImportModules,
			SIMCModule *parentModule,
			int snmpVersion,
			long lineNumber, long columnNumber,
			long referenceCount) 
				:	_snmpVersion(snmpVersion),
					_parentModule(parentModule),
					_description(NULL),
					_contactInfo(NULL),
					_lastUpdated(NULL),
					_organization(NULL),
					_moduleIdentityValue(NULL),
					_moduleIdentityName(NULL),
					SIMCSymbol(moduleName, MODULE_NAME, NULL, lineNumber,
								columnNumber, referenceCount)
{

	_inputFileName = NewString(inputFileName);
	_listOfObjectGroups = new SIMCGroupList;
	_listOfNotificationTypes = new SIMCNotificationList;

	if( symbolTable)
	{
		_symbolTable = symbolTable;
		// Set the module pointer of each symbol to this one
		POSITION p = _symbolTable->GetStartPosition();
		CString s;
		SIMCSymbol ** spp;
		while(p)
		{
			_symbolTable->GetNextAssoc(p, s, spp);
			(*spp)->SetModule(this);
		}
	}
	else // Create a new symbol table
	{
		_symbolTable = new SIMCSymbolTable;
		_symbolTable->InitHashTable(SYMBOLS_PER_MODULE);
	}

	// For each import module, set the current module as the parent
	// and increment the reference count of the module
	if(listOfImportModules)
	{
		_listOfImportModules = listOfImportModules;
		SIMCModule *m;
		POSITION p = _listOfImportModules->GetHeadPosition();
		while(p)
		{
			m = _listOfImportModules->GetNext(p);
			m->IncrementReferenceCount();
			m->SetParentModule(this);
		}
	}
	else
		_listOfImportModules = new CList < SIMCModule *,  SIMCModule *>;
}

SIMCModule::~SIMCModule()
{
	if(_inputFileName)
		delete [] _inputFileName;
	if(_moduleIdentityName)
		delete [] _moduleIdentityName;
	if(_description)
		delete [] _description;
	if(_contactInfo)
		delete [] _contactInfo;
	if(_lastUpdated)
		delete [] _lastUpdated;
	if(_organization)
		delete [] _organization;
	if( _moduleIdentityValue)
		delete _moduleIdentityValue;

	if(!_revisionList.IsEmpty())
	{
		POSITION p = _revisionList.GetHeadPosition();
		SIMCRevisionElement *element;
		while(p)
		{
			element = _revisionList.GetNext(p);
			delete element;
		}
	}


 	SIMCModule* m;
	if( _listOfImportModules)
	{
		while(!_listOfImportModules->IsEmpty() )
		{
			m = _listOfImportModules->RemoveHead();
			m->DecrementReferenceCount();
			delete m;
		}
		delete _listOfImportModules;
	}


	SIMCObjectGroup *nextGroup;
	if(_listOfObjectGroups)
	{
		while(!_listOfObjectGroups->IsEmpty() )
		{
			nextGroup = _listOfObjectGroups->RemoveHead();
			delete nextGroup;
		}
		delete _listOfObjectGroups;
	}

	SIMCNotificationElement *nextElement;
	if(_listOfNotificationTypes)
	{
		while(!_listOfNotificationTypes->IsEmpty() )
		{
			nextElement = _listOfNotificationTypes->RemoveHead();
			delete nextElement;
		}
		delete _listOfNotificationTypes;
	}

	if(_symbolTable)
	{
		SIMCSymbol **symbol;
		CString s;
		POSITION p;
		p = _symbolTable->GetStartPosition();
		while(p)
		{
			_symbolTable->GetNextAssoc(p, s, symbol);

			void *myTemp = (void *)(*symbol);

			if((*symbol)->GetModule() != this)
				continue;

			/* BUG : This has been commented and leads to memory leaks
			* Leaving it in was leading to a crash in destructor when
			* compiling the cisco-cipcsna-mib-v1smi MIB
			delete *symbol;
			delete symbol;
			*/
			_symbolTable->RemoveKey(s);
		}
		delete _symbolTable;	
	}

}


void SIMCModule::SetParentModule( SIMCModule * parentModule)
{
	if(_parentModule)
		_parentModule->DecrementReferenceCount();
	if(_parentModule = parentModule)
		_parentModule->IncrementReferenceCount();
}

 SIMCSymbol ** SIMCModule::GetSymbol(  const char* const symbolName) const
{
	SIMCSymbol ** x;
	if( _symbolTable->Lookup(CString(symbolName), x))
		return x;
	else
		return NULL;
}

int SIMCModule::GetImportedSymbol( const char * const symbolName,  SIMCSymbol ** &retVal1,
								  SIMCSymbol ** &retVal2) const
{
	if( ! _listOfImportModules )
		return NOT_FOUND;

	int retStatus = NOT_FOUND;
	SIMCSymbol ** retVal;
	
	SIMCModule *m;
	POSITION p = _listOfImportModules->GetHeadPosition();
	while(p)
	{
		m = _listOfImportModules->GetNext(p);
		if( retVal = m->GetSymbol(symbolName))
		{
			if( retStatus == NOT_FOUND )
			{
				retVal1 = retVal;
				retStatus = UNAMBIGUOUS;
			}
			else if (retStatus == UNAMBIGUOUS)
			{
				retStatus = AMBIGUOUS;
				retVal2 = retVal;
				return retStatus;
			}
		}
	}

	return retStatus;
}



void SIMCModule::AddImportModule( SIMCModule * newModule)
{
	_listOfImportModules->AddTail(newModule);
	newModule->IncrementReferenceCount();
	newModule->SetParentModule(this);

}

BOOL SIMCModule::RemoveImportModule(SIMCModule *module)
{
	POSITION p = _listOfImportModules->GetHeadPosition();
	POSITION temp;

	SIMCModule *next;
	while(p)
	{
		temp = p;
		 next = _listOfImportModules->GetNext(p);
		 if(module == next)
		 {
			 _listOfImportModules->RemoveAt(temp);
			 return TRUE;
		 }
	}

	return FALSE;
}

void SIMCModule::AddObjectGroup( SIMCObjectGroup * group)
{
	_listOfObjectGroups->AddTail(group);
}

SIMCModule *SIMCModule::GetImportModule(const char * const name) const
{
	POSITION p = _listOfImportModules->GetHeadPosition();
	SIMCModule *m;
	while(p)
	{
		m = _listOfImportModules->GetNext(p);
		if( strcmp(m->GetSymbolName(), name) == 0)
			return m;
	}
	return NULL;
}


// Gets the object group whose name is the speciified name
SIMCObjectGroup *SIMCModule::GetObjectGroup(const char * const name) const
{
	POSITION p = _listOfObjectGroups->GetHeadPosition();
	SIMCObjectGroup *m;
	while(p)
	{
		m = _listOfObjectGroups->GetNext(p);
		if( strcmp(m->GetObjectGroupName(), name) == 0)
			return m;
	}
	return NULL;
}

// Returns the object group in which this symbol is present
SIMCObjectGroup *SIMCModule::GetObjectGroup(SIMCSymbol *symbol) const
{
	POSITION p = _listOfObjectGroups->GetHeadPosition();
	SIMCObjectGroup *m;
	while(p)
	{
		m = _listOfObjectGroups->GetNext(p);
		if(m->GetScalar(symbol) || m->GetTable(symbol))
			return m;
	}
	return NULL;
}


BOOL SIMCModule::AddSymbol(SIMCSymbol * newSymbol)
{
	SIMCSymbol ** newSymbolP = new SIMCSymbol *;
	newSymbol->SetModule(this);
	*newSymbolP = newSymbol;
	(*_symbolTable)[CString(newSymbol->GetSymbolName())] = newSymbolP;
	return TRUE;
}

BOOL SIMCModule::RemoveSymbol(const char * const symbolName)
{
	return _symbolTable->RemoveKey(CString(symbolName));
}

BOOL SIMCModule::ReplaceSymbol(const char * const oldSymbol, 
							   SIMCSymbol * newSymbol)
{
	SIMCSymbol ** oldP = GetSymbol(oldSymbol);
	if(oldP)
	{
		delete *oldP;
		*oldP = newSymbol;
		return TRUE;
	}
	return FALSE;
}

void SIMCModule::WriteSymbol(ostream& outStream) const
{

	outStream << "BEGINNING PRINTING MODULE \"" << GetSymbolName() <<
		"\"" << endl;
	outStream << "\tParent Module : " <<
		((_parentModule)? (_parentModule)->GetSymbolName() : "NONE") << endl;
	outStream << "\tSNMP Version" << _snmpVersion << endl;

	POSITION p = (_listOfImportModules)->GetHeadPosition();

	if(_listOfObjectGroups)
		outStream << (*_listOfObjectGroups);
	
	outStream << "END OF MODULE " << GetSymbolName() << endl;

}

class SIMCTypeReference;
class SIMCValueReference;
class SIMCUnknown;
class SIMCBuiltInTypeReference;
class SIMCDefinedTypeReference;
class SIMCBuiltInValueReference;
class SIMCDefinedValueReference;
class SIMCTextualConvention;


SIMCModule::SymbolClass SIMCModule::GetSymbolClass(SIMCSymbol **spp) 
{
	if(!spp || !(*spp) )
		return SYMBOL_INVALID;

	if(typeid(**spp) == typeid(SIMCUnknown) )
		return SYMBOL_UNKNOWN;
	else if (typeid(**spp) == typeid(SIMCModule) )
		return SYMBOL_MODULE;
	else if (typeid(**spp) == typeid(SIMCBuiltInTypeReference) )
		return SYMBOL_BUILTIN_TYPE_REF;
	else if (typeid(**spp) == typeid(SIMCDefinedTypeReference) )
		return SYMBOL_DEFINED_TYPE_REF;
	else if (typeid(**spp) == typeid(SIMCTextualConvention) )
		return SYMBOL_TEXTUAL_CONVENTION;
	else if (typeid(**spp) == typeid(SIMCBuiltInValueReference) )
		return SYMBOL_BUILTIN_VALUE_REF;
	else if (typeid(**spp) == typeid(SIMCDefinedValueReference) )
		return SYMBOL_DEFINED_VALUE_REF;
	else if (typeid(**spp) == typeid(SIMCImport) )
		return SYMBOL_IMPORT;
	else 
		return SYMBOL_INVALID;
}

SIMCModule::TypeClass SIMCModule::GetTypeClass(SIMCType *t) 
{
	if(!t)
		return TYPE_INVALID;
	if(typeid(*t) == typeid(SIMCPrimitiveType) )
		return TYPE_PRIMITIVE;
	else if (typeid(*t) == typeid(SIMCRangeType) )
		return TYPE_RANGE;
	else if (typeid(*t) == typeid(SIMCSizeType) )
		return TYPE_SIZE;
	else if (typeid(*t) == typeid(SIMCEnumOrBitsType) )
		return TYPE_ENUM_OR_BITS;
	else if (typeid(*t) == typeid(SIMCSequenceOfType) )
		return TYPE_SEQUENCE_OF;
	else if (typeid(*t) == typeid(SIMCSequenceType) )
		return TYPE_SEQUENCE;
	else if (typeid(*t) == typeid(SIMCTrapTypeType) )
		return TYPE_TRAP_TYPE;
	else if (typeid(*t) == typeid(SIMCNotificationTypeType) )
		return TYPE_NOTIFICATION_TYPE;
	else if (typeid(*t) == typeid(SIMCObjectTypeV1) )
		return TYPE_OBJECT_TYPE_V1;
	else if (typeid(*t) == typeid(SIMCObjectTypeV2) )
		return TYPE_OBJECT_TYPE_V2;
	else if (typeid(*t) == typeid(SIMCObjectIdentityType) )
		return TYPE_OBJECT_IDENTITY;
	else if (typeid(*t) == typeid(SIMCEnumOrBitsType) )
		return TYPE_ENUM_OR_BITS;
	else 
		return TYPE_INVALID;
}


SIMCModule::ValueClass SIMCModule::GetValueClass(SIMCValue * v)
{
	if(!v)
		return VALUE_INVALID;
	else if( typeid(*v) == typeid(SIMCNullValue) )
		return VALUE_NULL;
	else if( typeid(*v) == typeid(SIMCIntegerValue) )
		return VALUE_INTEGER;
	else if( typeid(*v) == typeid(SIMCOidValue) )
		return VALUE_OID;
	else if( typeid(*v) == typeid(SIMCOctetStringValue) )
		return VALUE_OCTET_STRING;
	else if( typeid(*v) == typeid(SIMCBooleanValue) )
		return VALUE_BOOLEAN;
	else if( typeid(*v) == typeid(SIMCBitsValue) )
		return VALUE_BITS;
	else 
		return VALUE_INVALID;
};

SIMCModule::PrimitiveType SIMCModule::GetPrimitiveType(const char * const name)
{
	if(!name)
		return PRIMITIVE_INVALID;
	if( strcmp(name, "INTEGER") == 0 )
		return PRIMITIVE_INTEGER;
	else if (strcmp(name, "OBJECT IDENTIFIER") == 0 )
		return PRIMITIVE_OID;
	else if (strcmp(name, "BOOLEAN") == 0 )
		return PRIMITIVE_BOOLEAN;
	else if (strcmp(name, "OCTET STRING") == 0 )
		return PRIMITIVE_OCTET_STRING;
	else if (strcmp(name, "BITS") == 0 )
		return PRIMITIVE_BITS;
	else if (strcmp(name, "NULL") == 0 )
		return PRIMITIVE_NULL;
	else if (strcmp(name, "NetworkAddress") == 0 )
		return PRIMITIVE_NETWORK_ADDRESS;
	else if (strcmp(name, "IpAddress") == 0 )
		return PRIMITIVE_IP_ADDRESS ;
	else if (strcmp(name, "Counter") == 0 )
		return PRIMITIVE_COUNTER;
	else if (strcmp(name, "Gauge") == 0 )
		return PRIMITIVE_GAUGE;
	else if (strcmp(name, "TimeTicks") == 0 )
		return PRIMITIVE_TIME_TICKS;
	else if (strcmp(name, "Opaque") == 0 )
		return PRIMITIVE_OPAQUE;
	else if (strcmp(name, "DisplayString") == 0 )
		return PRIMITIVE_DISPLAY_STRING;
	else if (strcmp(name, "PhysAddress") == 0 )
		return PRIMITIVE_PHYS_ADDRESS;
	else if (strcmp(name, "MacAddress") == 0 )
		return PRIMITIVE_MAC_ADDRESS;
	else if (strcmp(name, "Integer32") == 0 )
		return PRIMITIVE_INTEGER_32;
	else if (strcmp(name, "Counter32") == 0 )
		return PRIMITIVE_COUNTER_32;
	else if (strcmp(name, "Gauge32") == 0 )
		return PRIMITIVE_GAUGE_32;
	else if (strcmp(name, "Counter64") == 0 )
		return PRIMITIVE_COUNTER_64;
	else if (strcmp(name, "Unsigned32") == 0 )
		return PRIMITIVE_UNSIGNED_32;
	else if (strcmp(name, "DateAndTime") == 0 )
		return PRIMITIVE_DATE_AND_TIME;
	else if (strcmp(name, "SnmpUDPAddress") == 0 )
		return PRIMITIVE_SNMP_UDP_ADDRESS;
	else if (strcmp(name, "SnmpOSIAddress") == 0 )
		return PRIMITIVE_SNMP_OSI_ADDRESS;
	else if (strcmp(name, "SnmpIPXAddress") == 0 )
		return PRIMITIVE_SNMP_IPX_ADDRESS;
	else 
		return PRIMITIVE_INVALID;
}

SIMCModule::PrimitiveType SIMCModule::GetPrimitiveType(const SIMCTypeReference *typeRef)
{
	SIMCSymbol **temp = (SIMCSymbol**)&typeRef;
	switch(GetSymbolClass(temp))
	{
		case SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType * type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			switch(GetTypeClass(type))
			{
				case TYPE_INVALID:
				case TYPE_SEQUENCE_OF:
				case TYPE_SEQUENCE:
				case TYPE_TRAP_TYPE:
				case TYPE_NOTIFICATION_TYPE:
				case TYPE_OBJECT_TYPE_V1:
				case TYPE_OBJECT_TYPE_V2:
				case TYPE_OBJECT_IDENTITY:
				case TYPE_ENUM_OR_BITS:
					return PRIMITIVE_INVALID;
				case TYPE_PRIMITIVE:
					return GetPrimitiveType(typeRef->GetSymbolName());
				case TYPE_RANGE:
				case TYPE_SIZE:
				{
					SIMCTypeReference *rhs = ((SIMCSubType *)type)->GetRootType();
					if(rhs)
					{
						SIMCSymbol **tempRhs = (SIMCSymbol **)&rhs;
						switch(GetSymbolClass(tempRhs))
						{
							case SYMBOL_BUILTIN_TYPE_REF:
								return GetPrimitiveType((SIMCBuiltInTypeReference*)rhs);
							case SYMBOL_TEXTUAL_CONVENTION:
								return GetPrimitiveType(rhs->GetSymbolName());
						}
					}
					else
						return PRIMITIVE_INVALID;
				}
			}
		}
		break;
		case SYMBOL_TEXTUAL_CONVENTION:
			return GetPrimitiveType(typeRef->GetSymbolName());
	}
	return PRIMITIVE_INVALID;
}

SIMCResolutionStatus SIMCModule::SetResolutionStatus(SIMCDefinedTypeReference * orig)
{
	SIMCDefinedTypeReferenceList checkedList;
	return SetResolutionStatusRec(orig, checkedList);
}

SIMCResolutionStatus SIMCModule::SetResolutionStatusRec(SIMCDefinedTypeReference * orig,
									SIMCDefinedTypeReferenceList& checkedList)
{

	SIMCTypeReference *result = NULL;
	SIMCResolutionStatus retVal = orig->GetStatus();
	if(retVal != RESOLVE_UNSET)
		return retVal;

	POSITION pChecked = checkedList.GetHeadPosition();
	SIMCDefinedTypeReference *checkedSymbol;
	while(pChecked)
	{
		checkedSymbol = checkedList.GetNext(pChecked);
		if(checkedSymbol == orig)
		{
			orig->SetStatus(RESOLVE_UNDEFINED);
			orig->SetRealType(NULL);
			return RESOLVE_UNDEFINED;
		}
	}
	
	checkedList.AddTail(orig);

	SIMCSymbol **rhs = orig->GetTypeReference();
	switch(GetSymbolClass(rhs))
	{
		case SYMBOL_IMPORT:
			orig->SetStatus(RESOLVE_IMPORT);
			orig->SetRealType(NULL);
			return RESOLVE_IMPORT;
		case SYMBOL_BUILTIN_TYPE_REF:
			result = (SIMCTypeReference *)(*rhs);
			orig->SetStatus(RESOLVE_CORRECT);
			orig->SetRealType(result);
			return RESOLVE_CORRECT;
		case SYMBOL_DEFINED_TYPE_REF:
		case SYMBOL_TEXTUAL_CONVENTION:
		{
			if( GetPrimitiveType((*rhs)->GetSymbolName()) != PRIMITIVE_INVALID)
			{
				orig->SetStatus(retVal = RESOLVE_CORRECT);
				orig->SetRealType((SIMCTypeReference *)(*rhs));
				return retVal;
			}

			SIMCDefinedTypeReference *rhsRef = (SIMCDefinedTypeReference *)(*rhs);
			
			switch(rhsRef->GetStatus())
			{
				case RESOLVE_UNSET:
					retVal = SetResolutionStatusRec(rhsRef, checkedList);
					orig->SetStatus(retVal);
					orig->SetRealType(rhsRef->GetRealType());
					return retVal;
				default:
					retVal = rhsRef->GetStatus();
					orig->SetStatus(retVal);
					orig->SetRealType(rhsRef->GetRealType());
					return retVal;
			}
		}
		default:
			orig->SetStatus(RESOLVE_UNDEFINED);
			orig->SetRealType(NULL);
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::SetResolutionStatus(SIMCDefinedValueReference * orig)
{
	SIMCDefinedValueReferenceList checkedList;

	return SetResolutionStatusRec(orig, checkedList);
}


SIMCResolutionStatus SIMCModule::SetResolutionStatusRec(SIMCDefinedValueReference * orig,
									SIMCDefinedValueReferenceList& checkedList)

{
	SIMCBuiltInValueReference *result = NULL;
	SIMCResolutionStatus retVal = orig->GetStatus();
	if(retVal != RESOLVE_UNSET)
		return retVal;

	POSITION pChecked = checkedList.GetHeadPosition();
	SIMCDefinedValueReference *checkedSymbol;
	while(pChecked)
	{
		checkedSymbol = checkedList.GetNext(pChecked);
		if(checkedSymbol == orig)
		{
			orig->SetStatus(RESOLVE_UNDEFINED);
			orig->SetRealValue(NULL);
			return RESOLVE_UNDEFINED;
		}
	}
	
	checkedList.AddTail(orig);

	SIMCSymbol **rhs = orig->GetValueReference();
	switch(GetSymbolClass(rhs))
	{
		case SYMBOL_IMPORT:
			orig->SetStatus(RESOLVE_IMPORT);
			orig->SetRealValue(NULL);
			return RESOLVE_IMPORT;
		case SYMBOL_BUILTIN_VALUE_REF:
			result = (SIMCBuiltInValueReference *)(*rhs);
			orig->SetStatus(RESOLVE_CORRECT);
			orig->SetRealValue(result);
			return RESOLVE_CORRECT;
		case SYMBOL_DEFINED_VALUE_REF:
		case SYMBOL_TEXTUAL_CONVENTION:
		{
			SIMCDefinedValueReference *rhsRef = (SIMCDefinedValueReference *)(*rhs);
			switch(rhsRef->GetStatus())
			{
				case RESOLVE_UNSET:
					retVal = SetResolutionStatusRec(rhsRef, checkedList);
					orig->SetStatus(retVal);
					orig->SetRealValue(rhsRef->GetRealValue());
					return retVal;
				default:
					retVal = rhsRef->GetStatus();
					orig->SetStatus(retVal);
					orig->SetRealValue(rhsRef->GetRealValue());
					return retVal;
			}
		}
		default:
			orig->SetStatus(RESOLVE_UNDEFINED);
			orig->SetRealValue(NULL);
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::SetResolutionStatus(SIMCSymbol **symbol)
{
	switch(GetSymbolClass(symbol))
	{
		case SIMCModule::SYMBOL_INVALID:
		case SIMCModule::SYMBOL_UNKNOWN:
		case SIMCModule::SYMBOL_IMPORT:
		case SIMCModule::SYMBOL_MODULE:
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
				return RESOLVE_CORRECT;

		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			return SetResolutionStatus((SIMCDefinedTypeReference *)(*symbol));

		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
			return SetResolutionStatus((SIMCDefinedValueReference *)(*symbol));

	}
	return RESOLVE_UNDEFINED;
}

BOOL SIMCModule::SetResolutionStatus()
{
	POSITION p = (_symbolTable)->GetStartPosition();
	SIMCSymbol **symbol;
	CString s;
	BOOL retVal = TRUE;
	while(p)
	{
		(_symbolTable)->GetNextAssoc(p, s, symbol);
		const char * const name = s;

		if(SetResolutionStatus(symbol) == RESOLVE_UNDEFINED)
			retVal = FALSE;
	}
	return retVal;
}

SIMCResolutionStatus SIMCModule::SetRootSubType(SIMCSubType *t)
{
	SIMCSubTypeList checkedList;
	switch(GetTypeClass(t))
	{
		case TYPE_ENUM_OR_BITS:
			return SetRootEnumOrBitsRec((SIMCEnumOrBitsType*)t, checkedList);
		case TYPE_RANGE:
		case TYPE_SIZE:
			return SetRootSubTypeRec(t, checkedList);
		default:
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::SetRootSubTypeRec(SIMCSubType *t,
							SIMCSubTypeList& checkedList)
{
	SIMCResolutionStatus retVal = t->GetStatus();
	if(retVal != RESOLVE_UNSET)
		return retVal;

	POSITION pChecked = checkedList.GetHeadPosition();
	SIMCSubType *checkedSymbol;
	while(pChecked)
	{
		checkedSymbol = checkedList.GetNext(pChecked);
		if(checkedSymbol == t)
		{
			t->SetStatus(RESOLVE_UNDEFINED);
			t->SetRootType(NULL);
			return RESOLVE_UNDEFINED;
		}
	}
	
	checkedList.AddTail(t);

	SIMCSymbol **s = t->GetType();
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_INVALID:
		case SIMCModule::SYMBOL_UNKNOWN:
		case SIMCModule::SYMBOL_MODULE:
		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
		{
			t->SetStatus(RESOLVE_UNDEFINED);
			t->SetRootType(NULL);
			return RESOLVE_UNDEFINED;
		}

		case SIMCModule::SYMBOL_IMPORT:
		{
			t->SetStatus(RESOLVE_IMPORT);
			t->SetRootType(NULL);
			return RESOLVE_IMPORT;
		}

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType *rhs = ((SIMCBuiltInTypeReference*)(*s))->GetType();
			switch(GetTypeClass(rhs))
			{
				case TYPE_INVALID:
				case TYPE_ENUM_OR_BITS:
				case TYPE_SEQUENCE_OF:
				case TYPE_SEQUENCE:
				case TYPE_TRAP_TYPE:
				case TYPE_NOTIFICATION_TYPE:
				case TYPE_OBJECT_TYPE_V1:
				case TYPE_OBJECT_TYPE_V2:
				case TYPE_OBJECT_IDENTITY:
					t->SetStatus(RESOLVE_UNDEFINED);
					t->SetRootType(NULL);
					return RESOLVE_UNDEFINED;

				case TYPE_PRIMITIVE:
					t->SetRootType((SIMCBuiltInTypeReference*)(*s));
					t->SetStatus(RESOLVE_CORRECT);
					return RESOLVE_CORRECT;

				case TYPE_RANGE:
				case TYPE_SIZE:
				{
					if( ((SIMCSubType*)rhs)->GetStatus() == RESOLVE_UNSET)
						retVal = SetRootSubTypeRec((SIMCSubType*)rhs, checkedList);
					else
						retVal = ((SIMCSubType *)rhs)->GetStatus();
					t->SetRootType(((SIMCSubType*)rhs)->GetRootType());
					t->SetStatus(retVal);
					return retVal;
				}
			}
		}
		break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			if(GetPrimitiveType((*s)->GetSymbolName()) != PRIMITIVE_INVALID)
			{
				t->SetStatus(retVal = RESOLVE_CORRECT);
				t->SetRootType((SIMCTypeReference *)(*s));
				return retVal;
			}

			switch ( ((SIMCDefinedTypeReference*)(*s))->GetStatus())
			{
				case RESOLVE_UNSET:
				case RESOLVE_UNDEFINED:
					t->SetRootType(NULL);
					t->SetStatus(RESOLVE_UNDEFINED);
					return RESOLVE_UNDEFINED;
				case RESOLVE_IMPORT:
					t->SetRootType(NULL);
					t->SetStatus(RESOLVE_IMPORT);
					return RESOLVE_IMPORT;
				case RESOLVE_CORRECT:
				{
					SIMCTypeReference *sb =
						((SIMCDefinedTypeReference*)(*s))->GetRealType(); 

					SIMCSymbol **tempSb = (SIMCSymbol **)&sb;
					switch(GetSymbolClass(tempSb))
					{
						case SYMBOL_BUILTIN_TYPE_REF:
						{
							SIMCType *rhs = ((SIMCBuiltInTypeReference *)sb)->GetType();
							switch(GetTypeClass(rhs))
							{
								case TYPE_INVALID:
								case TYPE_ENUM_OR_BITS:
								case TYPE_SEQUENCE_OF:
								case TYPE_SEQUENCE:
								case TYPE_TRAP_TYPE:
								case TYPE_NOTIFICATION_TYPE:
								case TYPE_OBJECT_TYPE_V1:
								case TYPE_OBJECT_TYPE_V2:
								case TYPE_OBJECT_IDENTITY:
									t->SetStatus(RESOLVE_UNDEFINED);
									t->SetRootType(NULL);
									return RESOLVE_UNDEFINED;

								case TYPE_PRIMITIVE:
									t->SetRootType(sb);
									t->SetStatus(RESOLVE_CORRECT);
									return RESOLVE_CORRECT;

								case TYPE_RANGE:
								case TYPE_SIZE:
								{
									if( ((SIMCSubType*)rhs)->GetStatus() == RESOLVE_UNSET)
										retVal = SetRootSubTypeRec((SIMCSubType*)rhs, checkedList);
									else
										retVal = ((SIMCSubType*)rhs)->GetStatus();
									t->SetStatus(retVal);
									t->SetRootType(((SIMCSubType*)rhs)->GetRootType());
									return retVal;
								}
							}
						}
						break;
						case SYMBOL_TEXTUAL_CONVENTION:
						{
							t->SetRootType(sb);
							t->SetStatus(RESOLVE_CORRECT);
							return RESOLVE_CORRECT;
						}
						break;
					}
				}
			}
		}
	}	
	return RESOLVE_UNDEFINED;
}

SIMCResolutionStatus SIMCModule::SetRootEnumOrBitsRec(SIMCEnumOrBitsType *t,
							SIMCSubTypeList& checkedList)
{
	SIMCResolutionStatus retVal = t->GetStatus();
	if(retVal != RESOLVE_UNSET)
		return retVal;

	POSITION pChecked = checkedList.GetHeadPosition();
	SIMCSubType *checkedSymbol;
	while(pChecked)
	{
		checkedSymbol = checkedList.GetNext(pChecked);
		if(checkedSymbol == t)
		{
			t->SetStatus(RESOLVE_UNDEFINED);
			t->SetRootType(NULL);
			return RESOLVE_UNDEFINED;
		}
	}
	
	checkedList.AddTail(t);

	SIMCSymbol **s = t->GetType();
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_INVALID:
		case SIMCModule::SYMBOL_UNKNOWN:
		case SIMCModule::SYMBOL_MODULE:
		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
		{
			t->SetStatus(RESOLVE_UNDEFINED);
			t->SetRootType(NULL);
			return RESOLVE_UNDEFINED;
		}

		case SIMCModule::SYMBOL_IMPORT:
		{
			t->SetStatus(RESOLVE_IMPORT);
			t->SetRootType(NULL);
			t->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT);
			return RESOLVE_IMPORT;
		}

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType *rhs = ((SIMCBuiltInTypeReference*)(*s))->GetType();
			switch(GetTypeClass(rhs))
			{
				case TYPE_INVALID:
				case TYPE_SEQUENCE_OF:
				case TYPE_SEQUENCE:
				case TYPE_TRAP_TYPE:
				case TYPE_NOTIFICATION_TYPE:
				case TYPE_OBJECT_TYPE_V1:
				case TYPE_OBJECT_TYPE_V2:
				case TYPE_OBJECT_IDENTITY:
				case TYPE_RANGE:
				case TYPE_SIZE:
					t->SetStatus(RESOLVE_UNDEFINED);
					t->SetRootType(NULL);
					return RESOLVE_UNDEFINED;

				case TYPE_PRIMITIVE:
					t->SetRootType((SIMCBuiltInTypeReference*)(*s));
					t->SetStatus(RESOLVE_CORRECT);
					switch(GetPrimitiveType((*s)->GetSymbolName()))
					{
						case SIMCModule::PRIMITIVE_INTEGER:
							((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM);
							break;
						case SIMCModule::PRIMITIVE_BITS:
							((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_BITS);
							break;
						default:
							((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_UNKNOWN);
							break;
					}
					return RESOLVE_CORRECT;
 				case TYPE_ENUM_OR_BITS:

				{
					if( ((SIMCSubType*)rhs)->GetStatus() == RESOLVE_UNSET)
						retVal = SetRootSubTypeRec((SIMCSubType*)rhs, checkedList);
					else
						retVal = ((SIMCSubType *)rhs)->GetStatus();
					t->SetRootType( ((SIMCSubType*)rhs)->GetRootType() );
					t->SetStatus(retVal);
					( (SIMCEnumOrBitsType *) t)->SetEnumOrBitsType( 
						((SIMCEnumOrBitsType *)rhs)->GetEnumOrBitsType()  );
					return retVal;
				}
			}
		}
		break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			if(GetPrimitiveType((*s)->GetSymbolName()) != PRIMITIVE_INVALID)
			{
				t->SetStatus(retVal = RESOLVE_CORRECT);
				t->SetRootType((SIMCTypeReference *)(*s));
				return retVal;
			}

			switch ( ((SIMCDefinedTypeReference*)(*s))->GetStatus())
			{
				case RESOLVE_UNSET:
				case RESOLVE_UNDEFINED:
					t->SetRootType(NULL);
					t->SetStatus(RESOLVE_UNDEFINED);
					return RESOLVE_UNDEFINED;
				case RESOLVE_IMPORT:
					t->SetRootType(NULL);
					t->SetStatus(RESOLVE_IMPORT);
					return RESOLVE_IMPORT;
				case RESOLVE_CORRECT:
				{
					SIMCTypeReference *sb =
						((SIMCDefinedTypeReference*)(*s))->GetRealType(); 
					SIMCSymbol **tempSb = (SIMCSymbol **)&sb;
					switch(GetSymbolClass(tempSb))
					{
						case SYMBOL_BUILTIN_TYPE_REF:
						{
							SIMCType *rhs = ((SIMCBuiltInTypeReference *)sb)->GetType();
							switch(GetTypeClass(rhs))
							{
								case TYPE_INVALID:
								case TYPE_SEQUENCE_OF:
								case TYPE_SEQUENCE:
								case TYPE_TRAP_TYPE:
								case TYPE_NOTIFICATION_TYPE:
								case TYPE_OBJECT_TYPE_V1:
								case TYPE_OBJECT_TYPE_V2:
								case TYPE_OBJECT_IDENTITY:
								case TYPE_RANGE:
								case TYPE_SIZE:
									t->SetStatus(RESOLVE_UNDEFINED);
									t->SetRootType(NULL);
									return RESOLVE_UNDEFINED;

								case TYPE_PRIMITIVE:
									t->SetRootType(sb);
									t->SetStatus(RESOLVE_CORRECT);
									switch(GetPrimitiveType(sb->GetSymbolName()) )
									{
										case SIMCModule::PRIMITIVE_INTEGER:
											((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM);
											break;
										case SIMCModule::PRIMITIVE_BITS:
											((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_BITS);
											break;
										default:
											((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_UNKNOWN);
											break;
									}
								return RESOLVE_CORRECT;
								case TYPE_ENUM_OR_BITS:
								{
									if( ((SIMCSubType*)rhs)->GetStatus() == RESOLVE_UNSET)
										retVal = SetRootSubTypeRec((SIMCSubType*)rhs, checkedList);
									else
										retVal = ((SIMCSubType*)rhs)->GetStatus();
									t->SetStatus(retVal);
									t->SetRootType(((SIMCSubType*)rhs)->GetRootType());
									((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(((SIMCEnumOrBitsType *)rhs)->GetEnumOrBitsType());
									return retVal;
								}
							}
						}
						break;
						case SYMBOL_TEXTUAL_CONVENTION:
						{
							t->SetRootType(sb);
							t->SetStatus(RESOLVE_CORRECT);
							return RESOLVE_CORRECT;
						}
						break;
					}
				}
			}
		}
	}	
	return RESOLVE_UNDEFINED;
}


SIMCResolutionStatus SIMCModule::SetRootSymbol(SIMCSymbol **symbol)
{

	switch(GetSymbolClass(symbol))
	{
		case SIMCModule::SYMBOL_INVALID:
		case SIMCModule::SYMBOL_IMPORT:
		case SIMCModule::SYMBOL_UNKNOWN:
		case SIMCModule::SYMBOL_MODULE:
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			return RESOLVE_CORRECT;
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCBuiltInTypeReference *b = (SIMCBuiltInTypeReference *)(*symbol);
			TypeClass x = GetTypeClass(b->GetType());
			switch(x)
			{
				case TYPE_RANGE:
				case TYPE_SIZE:
				case TYPE_ENUM_OR_BITS:
					return SetRootSubType((SIMCSubType *)(b->GetType()) );
				default:
					return RESOLVE_CORRECT;
			}
		}
	}
	return RESOLVE_UNDEFINED;
}

BOOL SIMCModule::SetRootAll()
{
	POSITION p = (_symbolTable)->GetStartPosition();
	SIMCSymbol **symbol;
	CString s;
	BOOL retVal = TRUE;
	while(p)
	{
		(_symbolTable)->GetNextAssoc(p, s, symbol);
		if(SetRootSymbol(symbol) == RESOLVE_UNDEFINED)
			retVal = FALSE;
	}
	return retVal;
}

SIMCResolutionStatus SIMCModule::SetDefVal(SIMCObjectTypeType *objType)
{
	const char *name;
	SIMCSymbol ** enumValue;

	if( ! (name = objType->GetDefValName()) )
	{
		objType->SetDefValStatus(RESOLVE_CORRECT);
		return RESOLVE_CORRECT;
	}

	 SIMCSymbol ** syntax  = objType->GetSyntax();
	 SIMCEnumOrBitsType * enumType;
	 if(syntax)
	 {
		 if(IsEnumType(syntax, enumType) == RESOLVE_CORRECT)
		 {
			 if( enumValue = enumType->GetValue(name) )
			 {
				 objType->SetDefVal(enumValue);
				 objType->SetDefValStatus(RESOLVE_CORRECT);
				 return RESOLVE_CORRECT;
			 }
		 }
	 }

	 // If you reach here, then an enum item could not be found
	 // Try to set the symbolic reference
	SIMCSymbol **s;
	if( s = GetSymbol(name) )  // Symbol exists
	{
		objType->SetDefVal(s);
		objType->SetDefValName(NULL);
		objType->SetDefValStatus(RESOLVE_CORRECT);
		return RESOLVE_CORRECT;
	}

	// Symbol could not be resolved within the current module
	// Search in import modules.

	SIMCSymbol **import1, **import2;
	switch( GetImportedSymbol(name, import1, import2))
	{
		case NOT_FOUND:
		case AMBIGUOUS:
			objType->SetDefValStatus(RESOLVE_UNDEFINED);
			return RESOLVE_UNDEFINED;
		case UNAMBIGUOUS:
			objType->SetDefVal(import1);
			objType->SetDefValName(NULL);
			objType->SetDefValStatus(RESOLVE_CORRECT);
			return RESOLVE_CORRECT;
	}

	objType->SetDefValStatus(RESOLVE_UNDEFINED);
	return RESOLVE_UNDEFINED;
}

BOOL SIMCModule::SetDefVal()
{
	POSITION p = (_symbolTable)->GetStartPosition();
	SIMCSymbol **symbol;
	CString s;
	BOOL retVal = TRUE;
	SIMCObjectTypeType *objType;
	while(p)
	{
		(_symbolTable)->GetNextAssoc(p, s, symbol);
		if(IsObjectType(symbol, objType) == RESOLVE_CORRECT)
			retVal = SetDefVal(objType) && retVal;
	}
	return retVal;
}


SIMCResolutionStatus SIMCModule::IsIntegerValue(SIMCSymbol **s, int& retValue)
{
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		{
			SIMCBuiltInValueReference *b = (SIMCBuiltInValueReference*)(*s);
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_INTEGER:
					retValue =  ((SIMCIntegerValue *)v)->GetIntegerValue();
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCDefinedValueReference *d = (SIMCDefinedValueReference*)(*s);
			if(d->GetStatus() != RESOLVE_CORRECT && d->GetStatus() != RESOLVE_IMPORT)
				return RESOLVE_UNDEFINED;
			if(d->GetStatus() == RESOLVE_IMPORT)
				return RESOLVE_IMPORT;
			SIMCBuiltInValueReference *b = d->GetRealValue();
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_INTEGER:
					retValue =  ((SIMCIntegerValue *)v)->GetIntegerValue();
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		default:
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::IsNullValue(SIMCSymbol **s)
{
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		{
			SIMCBuiltInValueReference *b = (SIMCBuiltInValueReference*)(*s);
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_NULL:
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCDefinedValueReference *d = (SIMCDefinedValueReference*)(*s);
			if(d->GetStatus() != RESOLVE_CORRECT && d->GetStatus() != RESOLVE_IMPORT)
				return RESOLVE_UNDEFINED;
			if(d->GetStatus() == RESOLVE_IMPORT)
				return RESOLVE_IMPORT;
			SIMCBuiltInValueReference *b = d->GetRealValue();
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_NULL:
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		default:
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::IsObjectIdentifierValue(SIMCSymbol **s, SIMCOidValue * &retValue)
{
	retValue = NULL;
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		{
			SIMCBuiltInValueReference *b = (SIMCBuiltInValueReference*)(*s);
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_OID:
					retValue =  (SIMCOidValue *)v;
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCDefinedValueReference *d = (SIMCDefinedValueReference*)(*s);
			if(d->GetStatus() != RESOLVE_CORRECT && d->GetStatus() != RESOLVE_IMPORT)
				return RESOLVE_UNDEFINED;
			if(d->GetStatus() == RESOLVE_IMPORT)
				return RESOLVE_IMPORT;
			SIMCBuiltInValueReference *b = d->GetRealValue();
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_OID:
					retValue =  (SIMCOidValue *)v;
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		default:
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::IsBitsValue(SIMCSymbol **s, SIMCBitsValue * &retValue)
{
	retValue = NULL;
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		{
			SIMCBuiltInValueReference *b = (SIMCBuiltInValueReference*)(*s);
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_BITS:
					retValue =  (SIMCBitsValue *)v;
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCDefinedValueReference *d = (SIMCDefinedValueReference*)(*s);
			if(d->GetStatus() != RESOLVE_CORRECT && d->GetStatus() != RESOLVE_IMPORT)
				return RESOLVE_UNDEFINED;
			if(d->GetStatus() == RESOLVE_IMPORT)
				return RESOLVE_IMPORT;
			SIMCBuiltInValueReference *b = d->GetRealValue();
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_BITS:
					retValue =  (SIMCBitsValue *)v;
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		default:
			return RESOLVE_UNDEFINED;
	}
}



SIMCResolutionStatus SIMCModule::IsObjectTypeV1(SIMCSymbol **value, 
											  SIMCObjectTypeV1 * &retValObjectType)
{
	retValObjectType = NULL;


	// Check that the type of the symbol is indeed an OBJECT-TYPE
	switch(GetSymbolClass(value))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCSymbol **typeRef = ((SIMCValueReference *)(*value))->GetTypeReference();
			SIMCType *type;
			switch(SIMCModule::GetSymbolClass(typeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
					type = ((SIMCBuiltInTypeReference *)(*typeRef))->GetType();
				break;
				default:
						return RESOLVE_UNDEFINED;
			}

			if( SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_OBJECT_TYPE_V1)
						return RESOLVE_UNDEFINED;
			else
				retValObjectType = (SIMCObjectTypeV1*)type;
		}
		break;
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsObjectTypeV2(SIMCSymbol **value, 
											  SIMCObjectTypeV2 * &retValObjectType)
{
	retValObjectType = NULL;


	// Check that the type of the symbol is indeed an OBJECT-TYPE
	switch(GetSymbolClass(value))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCSymbol **typeRef = ((SIMCValueReference *)(*value))->GetTypeReference();
			SIMCType *type;
			switch(SIMCModule::GetSymbolClass(typeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
					type = ((SIMCBuiltInTypeReference *)(*typeRef))->GetType();
					break;
				default:
						return RESOLVE_UNDEFINED;
			}

			if( SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_OBJECT_TYPE_V2)
						return RESOLVE_UNDEFINED;
			else
				retValObjectType = (SIMCObjectTypeV2*)type;
		}
		break;
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsObjectType(SIMCSymbol **value, 
											  SIMCObjectTypeType * &retValObjectType)
{
	retValObjectType = NULL;


	// Check that the type of the symbol is indeed an OBJECT-TYPE
	switch(GetSymbolClass(value))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCSymbol **typeRef = ((SIMCValueReference *)(*value))->GetTypeReference();
			SIMCType *type;
			switch(SIMCModule::GetSymbolClass(typeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
					type = ((SIMCBuiltInTypeReference *)(*typeRef))->GetType();
					break;
				default:
						return RESOLVE_UNDEFINED;
			}

			if( SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_OBJECT_TYPE_V1 &&
				SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_OBJECT_TYPE_V2)
						return RESOLVE_UNDEFINED;
			else
				retValObjectType = (SIMCObjectTypeType*)type;
		}
		break;
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsTrapType(SIMCSymbol **value, 
											  SIMCTrapTypeType * &retValTrapType)
{
	retValTrapType = NULL;

	// Check that the type of the symbol is indeed an TRAP-TYPE
	switch(GetSymbolClass(value))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCSymbol **typeRef = ((SIMCValueReference *)(*value))->GetTypeReference();
			SIMCType *type;
			switch(SIMCModule::GetSymbolClass(typeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
					type = ((SIMCBuiltInTypeReference *)(*typeRef))->GetType();
					break;
				default:
						return RESOLVE_UNDEFINED;
			}

			if( SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_TRAP_TYPE)
						return RESOLVE_UNDEFINED;
			else
				retValTrapType = (SIMCTrapTypeType*)type;
		}
		break;
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsNotificationType(SIMCSymbol **value, 
											  SIMCNotificationTypeType * &retValNotificationType)
{
	retValNotificationType = NULL;

	// Check that the type of the symbol is indeed an NOTIFICATION-TYPE
	switch(GetSymbolClass(value))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCSymbol **typeRef = ((SIMCValueReference *)(*value))->GetTypeReference();
			SIMCType *type;
			switch(SIMCModule::GetSymbolClass(typeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
					type = ((SIMCBuiltInTypeReference *)(*typeRef))->GetType();
					break;
				default:
						return RESOLVE_UNDEFINED;
			}

			if( SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_NOTIFICATION_TYPE)
						return RESOLVE_UNDEFINED;
			else
				retValNotificationType = (SIMCNotificationTypeType*)type;
		}
		break;
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsEnumType(SIMCSymbol **symbol, 
											  SIMCEnumOrBitsType * &retValEnumType)
{
	retValEnumType = NULL;
	SIMCTypeReference * bTypeRef;
	SIMCType *type;
	switch(IsTypeReference(symbol, bTypeRef))
	{
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			return RESOLVE_UNDEFINED;
			
		case RESOLVE_CORRECT:
		{
			SIMCSymbol **tempBTypeRef =  (SIMCSymbol **)&bTypeRef;
			switch(	GetSymbolClass(tempBTypeRef) )
			{
				case SYMBOL_BUILTIN_TYPE_REF:
				{
					type = ((SIMCBuiltInTypeReference *)bTypeRef)->GetType();
					switch( GetTypeClass(type) )
					{
						case TYPE_ENUM_OR_BITS:
							retValEnumType = (SIMCEnumOrBitsType *)type;
							return RESOLVE_CORRECT;
						default:
							return RESOLVE_UNDEFINED;
					}
				}
				break;
				case SYMBOL_TEXTUAL_CONVENTION:
				{
					return RESOLVE_UNDEFINED;
				}
				break;
			}
		}
		break;
	}
	return RESOLVE_UNDEFINED;

}

SIMCResolutionStatus SIMCModule::IsTypeReference(SIMCSymbol **symbol,
									SIMCTypeReference * &retVal)
{
	switch(SIMCModule::GetSymbolClass(symbol))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF: 
			retVal = (SIMCBuiltInTypeReference *)(*symbol);
			return RESOLVE_CORRECT;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			SIMCDefinedTypeReference * valueDefTypeRef = (SIMCDefinedTypeReference*)(*symbol);
			switch(valueDefTypeRef->GetStatus())
			{
				case RESOLVE_IMPORT:
					return RESOLVE_IMPORT;
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					return RESOLVE_UNDEFINED;
				case RESOLVE_CORRECT:
					retVal = valueDefTypeRef->GetRealType();
					return RESOLVE_CORRECT;
					break;
			}
			break;
		}
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_UNDEFINED;

}

SIMCResolutionStatus SIMCModule::IsValueReference(SIMCSymbol **s,
									SIMCSymbol ** &retTypeRef,
									SIMCBuiltInValueReference *&retVal)
{
	retTypeRef = NULL;
	retVal = NULL;

	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
			retVal = (SIMCBuiltInValueReference*)(*s);
			retTypeRef = ((SIMCBuiltInValueReference*)(*s))->GetTypeReference();
			return RESOLVE_CORRECT;

		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCDefinedValueReference *d = (SIMCDefinedValueReference*)(*s);
			retTypeRef = d->GetTypeReference();

			switch(d->GetStatus())
			{
				case RESOLVE_IMPORT:
					return RESOLVE_IMPORT;
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					return RESOLVE_UNDEFINED;
				case RESOLVE_CORRECT:
					retVal = d->GetRealValue();
					return RESOLVE_CORRECT;
			}
		}
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_UNDEFINED;
}

SIMCResolutionStatus SIMCModule::IsSequenceTypeReference(SIMCSymbol **symbol,
								SIMCBuiltInTypeReference * &retVal1,
								SIMCSequenceType *&retVal2)
{
	SIMCTypeReference *typeRef;
	switch(IsTypeReference(symbol, typeRef)	)
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
		case RESOLVE_CORRECT:
		{
			SIMCSymbol **tempTypeRef = (SIMCSymbol **)&typeRef;
			switch(GetSymbolClass(tempTypeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
				{
					retVal1 = (SIMCBuiltInTypeReference *)typeRef;
					SIMCType *type = ((SIMCBuiltInTypeReference *)retVal1)->GetType();
					switch(GetTypeClass(type))
					{
						case TYPE_SEQUENCE:
							retVal2 = (SIMCSequenceType *)type;
							return RESOLVE_CORRECT;
						default:
							return RESOLVE_UNDEFINED;
					}
				}
				break;
				case SYMBOL_TEXTUAL_CONVENTION:
				{
					return RESOLVE_UNDEFINED;
				}
				break;
			}
		}
	}
	return RESOLVE_UNDEFINED;
}


SIMCResolutionStatus SIMCModule::IsSequenceOfTypeReference(SIMCSymbol **symbol,
								SIMCBuiltInTypeReference * &retVal1,
								SIMCSequenceOfType *&retVal2)
{
	SIMCTypeReference *typeRef;
	switch(IsTypeReference(symbol, typeRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
		case RESOLVE_CORRECT:
		{
			SIMCSymbol **tempTypeRef = 	(SIMCSymbol **)&typeRef;
			switch(GetSymbolClass(tempTypeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
				{
					retVal1 = (SIMCBuiltInTypeReference *)typeRef;
					SIMCType *type = retVal1->GetType();
					switch(GetTypeClass(type))
					{
						case TYPE_SEQUENCE_OF:
							retVal2 = (SIMCSequenceOfType *)type;
							return RESOLVE_CORRECT;
						default:
							return RESOLVE_UNDEFINED;
					}
				}
				break;
				case SYMBOL_TEXTUAL_CONVENTION:
				{
					return RESOLVE_UNDEFINED;
				}
				break;
			}
		}
	}
	return RESOLVE_UNDEFINED;
}

SIMCResolutionStatus SIMCModule::IsNamedNode(SIMCSymbol **symbol)
{

	// See whether the symbol is a value reference
	SIMCBuiltInValueReference *bvRef;
	SIMCSymbol **dummy;
	switch(IsValueReference(symbol, dummy, bvRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	// See whether the type of the symbol is OID
	SIMCSymbol **typeRef = ((SIMCValueReference *)(*symbol))->GetTypeReference();
	SIMCTypeReference *btRef;
	switch(IsTypeReference(typeRef, btRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCSymbol **tempBtRef = (SIMCSymbol**)&btRef;
	switch(GetSymbolClass(tempBtRef))
	{
		case SYMBOL_BUILTIN_TYPE_REF:
		{
			if(GetPrimitiveType((SIMCBuiltInTypeReference *)btRef) != PRIMITIVE_OID &&
				GetTypeClass(((SIMCBuiltInTypeReference *)btRef)->GetType()) != TYPE_OBJECT_IDENTITY )
				return RESOLVE_UNDEFINED;
		}
		break;
		case SYMBOL_TEXTUAL_CONVENTION:
		{
			return RESOLVE_UNDEFINED;
		}
		break;
	}

	// See whether it's value is an OID
	if(SIMCModule::GetValueClass(bvRef->GetValue()) != SIMCModule::VALUE_OID)
		return RESOLVE_UNDEFINED;

	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsScalar(SIMCSymbol **symbol)
{
	SIMCObjectTypeType *objType;

	switch(IsObjectType(symbol, objType))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCSymbol **syntaxSymbol = objType->GetSyntax();
	SIMCTypeReference *btRef;
	switch(IsTypeReference(syntaxSymbol, btRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCSymbol **tempBtRef = (SIMCSymbol**)&btRef;
	switch(GetSymbolClass(tempBtRef))
	{
		case SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(GetTypeClass(((SIMCBuiltInTypeReference *)btRef)->GetType()))
			{
				case TYPE_SEQUENCE:
				case TYPE_SEQUENCE_OF:
					return RESOLVE_UNDEFINED;
				default:
					return RESOLVE_CORRECT;
			}
		}
		break;
		case SYMBOL_TEXTUAL_CONVENTION:
		{
			return RESOLVE_CORRECT;
		}
		break;
	}


	

	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsTable(SIMCSymbol **symbol)
{
	SIMCObjectTypeType *objType;

	switch(IsObjectType(symbol, objType))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCSymbol **syntaxSymbol = objType->GetSyntax();
	SIMCBuiltInTypeReference *btRef;
	SIMCSequenceOfType *type;
	return IsSequenceOfTypeReference(syntaxSymbol, btRef, type);
}

SIMCResolutionStatus SIMCModule::IsRow(SIMCSymbol **symbol)
{
	SIMCObjectTypeType *objType;

	switch(IsObjectType(symbol, objType))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCSymbol **syntaxSymbol = objType->GetSyntax();
	SIMCBuiltInTypeReference *btRef;
	SIMCSequenceType *type;
	return IsSequenceTypeReference(syntaxSymbol, btRef, type);
}

SIMCResolutionStatus SIMCModule::IsFixedSizeObject(SIMCObjectTypeType *objectType)
{
	SIMCSymbol ** syntaxSymbol = objectType->GetSyntax();
	SIMCTypeReference *typeRef;
	switch(IsTypeReference(syntaxSymbol, typeRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCType *type = NULL;
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol**)&typeRef;
	switch(GetSymbolClass(tempTypeRef))
	{
		case SYMBOL_BUILTIN_TYPE_REF:
			type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			break;
		case SYMBOL_TEXTUAL_CONVENTION:
			switch(GetPrimitiveType(typeRef->GetSymbolName()))
			{
				case PRIMITIVE_MAC_ADDRESS:
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_FALSE;
			}
			break;
	}

	switch(GetTypeClass(type))
	{
		case TYPE_INVALID:
		case TYPE_SEQUENCE_OF:
		case TYPE_SEQUENCE:
		case TYPE_TRAP_TYPE:
		case TYPE_NOTIFICATION_TYPE:
		case TYPE_OBJECT_TYPE_V1:
		case TYPE_OBJECT_TYPE_V2:
		case TYPE_OBJECT_IDENTITY:
			return RESOLVE_FALSE;

		case TYPE_PRIMITIVE:
			switch(GetPrimitiveType(typeRef->GetSymbolName()))
			{
				case PRIMITIVE_INTEGER:
				case PRIMITIVE_BOOLEAN:
				case PRIMITIVE_BITS:
				case PRIMITIVE_NULL:
				case PRIMITIVE_IP_ADDRESS:
				case PRIMITIVE_TIME_TICKS:
				case PRIMITIVE_MAC_ADDRESS:
				case PRIMITIVE_INTEGER_32:
				case PRIMITIVE_COUNTER_32:
				case PRIMITIVE_GAUGE_32:
				case PRIMITIVE_COUNTER_64:
				case PRIMITIVE_UNSIGNED_32:
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_FALSE;
			}
			break;
		case TYPE_RANGE:
		case TYPE_ENUM_OR_BITS:
			return RESOLVE_CORRECT;
		case TYPE_SIZE:
			return (((SIMCSizeType*)type)->IsFixedSize())? RESOLVE_CORRECT : RESOLVE_FALSE;
	}
	return RESOLVE_UNDEFINED;

}

SIMCResolutionStatus SIMCModule::IsNotZeroSizeObject(SIMCObjectTypeType *objectType)
{
	SIMCSymbol ** syntaxSymbol = objectType->GetSyntax();
	SIMCTypeReference *typeRef;
	switch(IsTypeReference(syntaxSymbol, typeRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCType *type = NULL;
	SIMCSymbol **tempTypeRef = (SIMCSymbol**)&typeRef;
	switch(GetSymbolClass(tempTypeRef))
	{
		case SYMBOL_BUILTIN_TYPE_REF:
			type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			break;
		case SYMBOL_TEXTUAL_CONVENTION:
			switch(GetPrimitiveType(typeRef->GetSymbolName()))
			{
				case PRIMITIVE_MAC_ADDRESS:
				case PRIMITIVE_DATE_AND_TIME:
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_FALSE;
			}
			break;
	}

	switch(GetTypeClass(type))
	{
		case TYPE_INVALID:
		case TYPE_SEQUENCE_OF:
		case TYPE_SEQUENCE:
		case TYPE_TRAP_TYPE:
		case TYPE_NOTIFICATION_TYPE:
		case TYPE_OBJECT_TYPE_V1:
		case TYPE_OBJECT_TYPE_V2:
		case TYPE_OBJECT_IDENTITY:
			return RESOLVE_FALSE;

		case TYPE_PRIMITIVE:
			switch(GetPrimitiveType(typeRef->GetSymbolName()))
			{
				case PRIMITIVE_INTEGER:
				case PRIMITIVE_BOOLEAN:
				case PRIMITIVE_BITS:
				case PRIMITIVE_IP_ADDRESS:
				case PRIMITIVE_TIME_TICKS:
				case PRIMITIVE_MAC_ADDRESS:
				case PRIMITIVE_INTEGER_32:
				case PRIMITIVE_COUNTER_32:
				case PRIMITIVE_GAUGE_32:
				case PRIMITIVE_COUNTER_64:
				case PRIMITIVE_UNSIGNED_32:
						return RESOLVE_CORRECT;
				default:
						return RESOLVE_FALSE;
			}
			break;
		case TYPE_RANGE:
		case TYPE_ENUM_OR_BITS:
			return RESOLVE_CORRECT;
		case TYPE_SIZE:
			return (((SIMCSizeType*)type)->IsNotZeroSizeObject())? RESOLVE_CORRECT : RESOLVE_FALSE;
	}
	return RESOLVE_UNDEFINED;

}

// This fabricates NOTICFICATION-TYPEs from TRAP-TYPEs and then proceeds to
// fabricate NOTIFICATION-GROUPs from them.
BOOL SIMCModule::FabricateNotificationGroups(SIMCParseTree& theParseTree,
											 const SIMCOidTree& theOidTree)
{

	// Get the symbol for the "INTEGER" type first
	SIMCSymbol **dummy = NULL;
	SIMCSymbol **integerType = NULL;
	if(GetImportedSymbol("INTEGER", integerType, dummy) != UNAMBIGUOUS)
		return FALSE;

	// Convert TRAP-TYPEs to NOTIFICATION-TYPEs and add  them to the list of  NOTIFICATION-TYPES
	// Add the NOTIFICATION-TYPEs without any change
	POSITION p = (_symbolTable)->GetStartPosition();
	SIMCSymbol **symbol = NULL;
	SIMCTrapTypeType *trapType = NULL;
	SIMCNotificationTypeType *notificationType = NULL;
	SIMCSymbol **trapTypeRefSymbol = NULL;
	SIMCBuiltInValueReference *trapIntegerValueRef = NULL;
	SIMCNotificationElement *nextElement = NULL;
	SIMCCleanOidValue *cleanNotificationValue = NULL;
	int trapValue;
	CString s;
	BOOL retVal = TRUE;
	while(p)
	{
		trapType = NULL;
		notificationType = NULL;
		cleanNotificationValue = NULL;

		// Get the next symbol
		(_symbolTable)->GetNextAssoc(p, s, symbol);

		// Is it a value reference? If so, we get the type of the value
		// This type may be SIMCTrapTypeType or SIMCNotificationTypeType or something else
		if(IsValueReference(symbol,	trapTypeRefSymbol,trapIntegerValueRef) 
			!= RESOLVE_CORRECT)
			continue;

		// Is the type SIMCTrapTypeType
		if(IsTrapType(symbol, trapType) == RESOLVE_CORRECT )
		{
			// Convert the TRAP-TYPE to a NOTIFICATION-TYPE

			// Get its integer value
			if(IsIntegerValue((SIMCSymbol **)&trapIntegerValueRef, trapValue) != RESOLVE_CORRECT)
				continue;


			// Create an OBJECTS clause form  the VARIBALES clause
			SIMCVariablesList *variablesList = trapType->GetVariables();
			SIMCObjectsList *objectsList = new SIMCObjectsList();
			POSITION p = variablesList->GetHeadPosition();
			while(p)
			{
				SIMCVariablesItem * nextVariable = variablesList->GetNext(p);
				SIMCObjectsItem *nextObject = new SIMCObjectsItem(nextVariable->_item,
					nextVariable->_line, nextVariable->_column);
				objectsList->AddTail(nextObject);
			}


			// Create the SIMCNotificationType object
			SIMCNotificationTypeType *notificationType = new SIMCNotificationTypeType(
			objectsList,
			trapType->GetDescription(), 
			trapType->GetDescriptionLine(), trapType->GetDescriptionColumn(),
			NULL, 0, 0,
			SIMCNotificationTypeType::STATUS_CURRENT, 0, 0);


			// Create a type reference to the SIMCNotificationTypeType
			SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
					notificationType, "+*", SIMCSymbol::LOCAL, this,
					(*trapTypeRefSymbol)->GetLineNumber(), (*trapTypeRefSymbol)->GetColumnNumber());
			SIMCSymbol **typeRefSymbol = new SIMCSymbol *;
			*typeRefSymbol = (SIMCSymbol *)typeRef;
			
			// Create a name for the value reference which represents the fabricated
			// NOTFICATION-TYPE
			char *fabricatedName = new char [s.GetLength() + 
				SIMCNotificationTypeType::NOTIFICATION_TYPE_FABRICATION_SUFFIX_LEN + 1];
			fabricatedName = strcpy(fabricatedName, s);
			fabricatedName = strcat(fabricatedName, SIMCNotificationTypeType::NOTIFICATION_TYPE_FABRICATION_SUFFIX);
		
			// Add an OID value reference of { enterpriseOid 0 trapValue }
			SIMCOidComponentList *oidList = new SIMCOidComponentList();
			oidList->AddTail(new SIMCOidComponent(trapType->GetEnterprise(),
				trapType->GetEnterpriseLine(), trapType->GetEnterpriseColumn(),
				"", trapType->GetEnterpriseLine(), trapType->GetEnterpriseColumn()));
			SIMCSymbol *zeroVal = new SIMCBuiltInValueReference(integerType, 0, 0, 
				new SIMCIntegerValue(0, TRUE),
				"", SIMCSymbol::LOCAL, this);		
			oidList->AddTail(new SIMCOidComponent(&zeroVal, 
				trapIntegerValueRef->GetLineNumber(), trapIntegerValueRef->GetColumnNumber(),
				"", 0, 0));
			oidList->AddTail(new SIMCOidComponent((SIMCSymbol **)&trapIntegerValueRef, 
				trapIntegerValueRef->GetLineNumber(), trapIntegerValueRef->GetColumnNumber(),
				"", 0, 0));

			SIMCOidValue *notificationOidValue = new  SIMCOidValue(oidList,
				trapIntegerValueRef->GetLineNumber(), trapIntegerValueRef->GetColumnNumber());

			SIMCSymbol ** s = GetSymbol(fabricatedName);	
			if(s) // Symbol exists in symbol table
			{
					retVal = FALSE;
					continue;
			}
			else
			{
				s = new SIMCSymbol *;
				*s = new SIMCBuiltInValueReference (
						typeRefSymbol, 
						typeRef->GetLineNumber(), typeRef->GetColumnNumber(), 
						notificationOidValue,
						fabricatedName, SIMCSymbol::LOCAL, this, 
						(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber());
			}

			// Now create an SIMCNotificationElement with an SIMCCleanOidValue in it
			// Before  that you need an SIMCCleanOidValue object

			// Get the OID value of the ENTERPRISE clause
			SIMCSymbol *enterpriseSymbol = *trapType->GetEnterprise();
			SIMCOidValue *enterpriseOid = NULL;
			if(IsObjectIdentifierValue(&enterpriseSymbol, enterpriseOid) != RESOLVE_CORRECT)
				continue;

			cleanNotificationValue = new SIMCCleanOidValue;
			if(theParseTree.GetCleanOidValue(_inputFileName, enterpriseOid,	*cleanNotificationValue,
								FALSE) != RESOLVE_CORRECT)
			{
				delete cleanNotificationValue;
				continue;
			}

			cleanNotificationValue->AddTail(0);
			cleanNotificationValue->AddTail(trapValue);
			nextElement = new SIMCNotificationElement(*s, cleanNotificationValue, TRUE);

		}
		// Or is the type SIMCNotificationTypeTyep
		else if	(IsNotificationType(symbol, notificationType) == RESOLVE_CORRECT)
		{
			cleanNotificationValue = new SIMCCleanOidValue;
			if(!theOidTree.GetOidValue((*symbol)->GetSymbolName(), 
				(*symbol)->GetModule()->GetModuleName(),
				*cleanNotificationValue)  )
			{
				delete cleanNotificationValue;
				continue;
			}
			nextElement = new SIMCNotificationElement(*symbol, cleanNotificationValue);
		}
		else // Do nothing
			continue;

		// Add the the fabricated or original notification type into the list of 
		// notification types
		_listOfNotificationTypes->AddTail(nextElement);

	}	// while()


	// Now fabricate the NOTIFICATION-GROUP macros. Not implemented yet.
	return retVal;

}


template<>
inline UINT AFXAPI HashKey(LPCSTR key)
{
	UINT hashVal = 0;

	int length = strlen(key);

	while (length--)
		hashVal += UINT(key[length]);

	return hashVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\objectidentity.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "objectIdentity.hpp"



SIMCObjectIdentityType::SIMCObjectIdentityType( SIMCObjectIdentityType::StatusType status,
							long statusLine, long statusColumn,
							char *description,
							long descriptionLine, long descriptionColumn,
							char *reference,
							long referenceLine, long referenceColumn)
							:
							_status(status), _statusLine(statusLine),
							_statusColumn(statusColumn),
							_descriptionLine(descriptionLine),
							_descriptionColumn(descriptionColumn),
							_referenceLine(referenceLine),
							_referenceColumn(referenceColumn)

{
	_description = NewString(description);
	_reference = NewString(reference);
}


SIMCObjectIdentityType::~SIMCObjectIdentityType()
{
	if(_description)
		delete [] _description;
	if(_reference)
		delete [] _reference;
}

SIMCObjectIdentityType::StatusType SIMCObjectIdentityType::StringToStatusType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "current") == 0)
			return STATUS_CURRENT;
		else if (strcmp(s, "deprecated") == 0)
			return STATUS_DEPRECATED;
		else if (strcmp(s, "obsolete") == 0)
			return STATUS_OBSOLETE;
		else
			return STATUS_INVALID;
	}
	return STATUS_INVALID;
}

void SIMCObjectIdentityType::WriteType(ostream &outStream) const
{
	outStream << "OBJECT-IDENTITY type" << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\notificationtype.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "notificationType.hpp"


const char *const SIMCNotificationTypeType::NOTIFICATION_TYPE_FABRICATION_SUFFIX = "V1NotificationType";
const int SIMCNotificationTypeType::NOTIFICATION_TYPE_FABRICATION_SUFFIX_LEN  = 18;

SIMCNotificationTypeType::SIMCNotificationTypeType( SIMCObjectsList *objects,
					char * description,
					long descriptionLine, long descriptionColumn,
					char *reference,
					long referenceLine, long referenceColumn,
					StatusType status,
					long statusLine, long statusColumn)
					:	_objects(objects),
						_descriptionLine(descriptionLine), _descriptionColumn(descriptionColumn),
						_referenceLine(referenceLine), _referenceColumn(referenceColumn),
						_status(status),
						_statusLine(statusLine), _statusColumn(statusColumn)
{

	if (objects)
	{
		POSITION p = objects->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (objects->GetNext(p))->_item;
			(*s)->IncrementReferenceCount();
		}
	}

	_description = NewString(description);
	_reference = NewString(reference);
}

SIMCNotificationTypeType::~SIMCNotificationTypeType()
{

	if (UseReferenceCount() && _objects)
	{
		POSITION p = _objects->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (_objects->GetNext(p))->_item;
			(*s)->DecrementReferenceCount();
		}
	}

	if(_description)
		delete [] _description;
	if(_reference)
		delete [] _reference;
}

SIMCNotificationTypeType::StatusType SIMCNotificationTypeType::StringToStatusType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "current") == 0)
			return STATUS_CURRENT;
		else if (strcmp(s, "deprecated") == 0)
			return STATUS_DEPRECATED;
		else if (strcmp(s, "obsolete") == 0)
			return STATUS_OBSOLETE;
		else
			return STATUS_INVALID;
	}
	return STATUS_INVALID;
}

void SIMCNotificationTypeType::WriteType(ostream& outStream) const
{
	outStream << "SIMCNotificationTypeType::WriteType() : NOT YET IMPLEMENTED" << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\objecttypev1.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <iostream.h>
#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"




SIMCObjectTypeV1::SIMCObjectTypeV1( SIMCSymbol **syntax,
								    long syntaxLine, long syntaxColumn,
									SIMCObjectTypeV1::AccessType access,
									long accessLine, long accessColumn, 
									SIMCObjectTypeV1::StatusType status,
									long statusLine, long statusColumn,
									SIMCIndexList * indexTypes,
									long indexLine, long indexColumn,
									char *description,
									long descriptionLine, long descriptionColumn,
									char *reference,
									long referenceLine, long referenceColumn,
									char *defValName,
									SIMCSymbol **defVal,
									long defValLine, long defValColumn)
					: 	_access(access), _accessLine(accessLine), 
						_accessColumn(accessColumn),
						_status(status), _statusLine(statusLine),
						_statusColumn(statusColumn),
						_indexTypes(indexTypes),
						_indexLine(indexLine), _indexColumn(indexColumn),
						SIMCObjectTypeType( syntax, syntaxLine, syntaxColumn,
							description, descriptionLine, descriptionColumn,
							reference, referenceLine, referenceColumn,
							defValName, defVal, defValLine, defValColumn)
{ 
	if (indexTypes)
	{
		POSITION p = indexTypes->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (indexTypes->GetNext(p))->_item;
			(*s)->IncrementReferenceCount();

		}
	}
}


SIMCObjectTypeV1::~SIMCObjectTypeV1()
{
	if (UseReferenceCount() && _indexTypes)
	{
		POSITION p = _indexTypes->GetHeadPosition();
		SIMCSymbol **s;
		SIMCIndexItem *next;
		while(p)
		{
			next = 	_indexTypes->GetNext(p);
			s = next->_item;
			(*s)->DecrementReferenceCount();
			delete next;
		}
	}
}

SIMCObjectTypeV1::AccessType SIMCObjectTypeV1::StringToAccessType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "read-only") == 0)
			return ACCESS_READ_ONLY;
		else if (strcmp(s, "read-write") == 0)
			return ACCESS_READ_WRITE;
		else if (strcmp(s, "write-only") == 0)
			return ACCESS_WRITE_ONLY;
		else if (strcmp(s, "not-accessible") == 0)
			return ACCESS_NOT_ACCESSIBLE;
		else
			return ACCESS_INVALID;
	}
	return ACCESS_INVALID;
}


SIMCObjectTypeV1::StatusType SIMCObjectTypeV1::StringToStatusType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "mandatory") == 0)
			return STATUS_MANDATORY;
		else if (strcmp(s, "optional") == 0)
			return STATUS_OPTIONAL;
		else if (strcmp(s, "deprecated") == 0)
			return STATUS_DEPRECATED;
		else if (strcmp(s, "obsolete") == 0)
			return STATUS_OBSOLETE;
		else
			return STATUS_INVALID;
	}
	return STATUS_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\objecttypev2.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "objectType.hpp"
#include "objectTypeV2.hpp"




SIMCObjectTypeV2::SIMCObjectTypeV2( SIMCSymbol **syntax,
								    long syntaxLine, long syntaxColumn,
									const char * const unitsClause,
									long unitsLine, long unitsColumn,
									SIMCObjectTypeV2::AccessType access,
									long accessLine, long accessColumn, 
									SIMCObjectTypeV2::StatusType status,
									long statusLine, long statusColumn,
									SIMCIndexListV2 * indexTypes,
									long indexLine, long indexColumn,
									SIMCSymbol **augmentsClause,
									const char * const description,
									long descriptionLine, long descriptionColumn,
									const char * const reference,
									long referenceLine, long referenceColumn,
									const char * const defValName,
									SIMCSymbol **defVal,
									long defValLine, long defValColumn)
					: 	_unitsLine(unitsLine), _unitsColumn(unitsColumn),
						_access(access), _accessLine(accessLine), 
						_accessColumn(accessColumn),
						_status(status), _statusLine(statusLine),
						_statusColumn(statusColumn),
						_indexTypes(indexTypes),
						_indexLine(indexLine), _indexColumn(indexColumn),
						_augmentsClause(augmentsClause),
						SIMCObjectTypeType( syntax, syntaxLine, syntaxColumn,
							description, descriptionLine, descriptionColumn,
							reference, referenceLine, referenceColumn,
							defValName, defVal, defValLine, defValColumn)
{ 
	_unitsClause = NewString(unitsClause);
	if (indexTypes)
	{
		POSITION p = indexTypes->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (indexTypes->GetNext(p))->_item;
			(*s)->IncrementReferenceCount();

		}
	}
	
	if(augmentsClause)
		(*augmentsClause)->IncrementReferenceCount();

}


SIMCObjectTypeV2::~SIMCObjectTypeV2()
{
	if (UseReferenceCount() && _indexTypes)
	{
		POSITION p = _indexTypes->GetHeadPosition();
		SIMCSymbol **s;
		SIMCIndexItemV2 *next;
		while(p)
		{
			next = 	_indexTypes->GetNext(p);
			s = next->_item;
			(*s)->DecrementReferenceCount();
			delete next;
		}
	}

	if(UseReferenceCount() && _augmentsClause)
		(*_augmentsClause)->DecrementReferenceCount();

}

SIMCObjectTypeV2::AccessType SIMCObjectTypeV2::StringToAccessType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "read-only") == 0)
			return ACCESS_READ_ONLY;
		else if (strcmp(s, "read-write") == 0)
			return ACCESS_READ_WRITE;
		else if (strcmp(s, "read-create") == 0)
			return ACCESS_READ_CREATE;
		else if (strcmp(s, "accessible-for-notify") == 0)
			return ACCESS_FOR_NOTIFY;
		else if (strcmp(s, "not-accessible") == 0)
			return ACCESS_NOT_ACCESSIBLE;
		else
			return ACCESS_INVALID;
	}
	return ACCESS_INVALID;
}


SIMCObjectTypeV2::StatusType SIMCObjectTypeV2::StringToStatusType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "current") == 0)
			return STATUS_CURRENT;
		else if (strcmp(s, "deprecated") == 0)
			return STATUS_DEPRECATED;
		else if (strcmp(s, "obsolete") == 0)
			return STATUS_OBSOLETE;
		else
			return STATUS_INVALID;
	}
	return STATUS_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <io.h>
#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>
#include <typeinfo.h>
#include <ole2.h>
#include <windows.h>
#include <limits.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\oidtree.cpp ===
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <snmptempl.h>

#include <autoptr.h>

#include "bool.hpp"
#include "newString.hpp"

#include "smierrsm.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"

#include "module.hpp"

#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "parser.hpp"

#include "oidTree.hpp"
#include "abstractParseTree.hpp"
#include "parseTree.hpp"

SIMCOidTreeNode::~SIMCOidTreeNode()
{
	SIMCOidTreeNode * next;
	while(!_listOfChildNodes.IsEmpty())
	{
		next = _listOfChildNodes.RemoveHead();
		delete next;
	}
}

BOOL SIMCOidTree::AddSymbol(const SIMCSymbol ** s, const SIMCCleanOidValue& val)
{
	POSITION p = val.GetHeadPosition();
	int nextVal;
	SIMCOidTreeNode *current = &_root, *child;

	while(p)
	{
		nextVal = val.GetNext(p);

		if( child = current->GetChild(nextVal) )
		{
			current = child;
		}
		else
		{
			current->AddChild(nextVal);
			current = current->GetChild(nextVal);
		}
	}
	current->AddSymbol(s);
	return TRUE;
}

void SIMCOidTree::WriteSubTree(ostream& outStream, 
							   const SIMCOidTreeNode *subNode,
							   SIMCCleanOidValue& realValue)
{
	realValue.AddTail(subNode->GetValue());
	const SIMCSymbolList *symbols = subNode->GetSymbolList();
	POSITION p = symbols->GetHeadPosition();
	const SIMCSymbol **symbol;
	while(p)
	{
		symbol = symbols->GetNext(p);
		outStream << (*symbol)->GetSymbolName() << " :" << realValue << endl;
		outStream << "=============================================================" <<
			endl;
	}

	const SIMCNodeList *children = subNode->GetListOfChildNodes();
	p = children->GetHeadPosition();
	const SIMCOidTreeNode *next;
	while(p)
	{
		next = children->GetNext(p);
		WriteSubTree(outStream, next, realValue);
	}
	realValue.RemoveTail();
}

void SIMCOidTree::WriteTree(ostream& outStream) const
{
	const SIMCNodeList *children = _root.GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();
	SIMCCleanOidValue realValue;
	outStream << "==============================================================" <<
		endl;
	outStream << "BEGINNING OF OID TREE" << endl;
	const SIMCOidTreeNode *next;
	while(p)
	{
		next = children->GetNext(p);
		WriteSubTree(outStream, next, realValue);
	}
	outStream << "=============================================================" <<
		endl;
}

const SIMCSymbolList *SIMCOidTree::GetSymbolList(const SIMCCleanOidValue& val)
{
	POSITION pOid = val.GetHeadPosition();
	if(!pOid)
		return NULL;

	SIMCOidTreeNode *current = &_root;
	const SIMCNodeList *children;
	POSITION pChildren;
	SIMCOidTreeNode *nextChild;
	int nextCleanVal;
	while(pOid)
	{
		nextCleanVal = val.GetNext(pOid);
		children = current->GetListOfChildNodes();
		current = NULL;
		pChildren = children->GetHeadPosition();
		while(pChildren)
		{
			nextChild = children->GetNext(pChildren);
			if(nextChild->GetValue() == nextCleanVal)
			{
				current = nextChild;
				break;
			}
		}
		if(current == NULL)
			return NULL;
	}
	return current->GetSymbolList();
}


BOOL SIMCOidTreeNode::GetOidValue(const char * const symbolName,
									const char * const moduleName,
									SIMCCleanOidValue& val) const
{

	val.AddTail(GetValue());
	POSITION p = _listOfSymbols.GetHeadPosition();
	const SIMCSymbol **s;
	while(p)
	{
		s = _listOfSymbols.GetNext(p);
		if( strcmp((*s)->GetSymbolName(), symbolName) == 0 &&
			strcmp((*s)->GetModule()->GetModuleName(), moduleName) == 0 	)
			return TRUE;
	}


	p = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *nextNode;
	while(p)
	{
		nextNode = _listOfChildNodes.GetNext(p);
		if(nextNode->GetOidValue(symbolName, moduleName, val))
			return TRUE;
	}

	val.RemoveTail();
	return FALSE;
}

BOOL SIMCOidTree::GetOidValue(const char * const symbolName, 
								const char * const moduleName,
								SIMCCleanOidValue& val) const
{
	const SIMCNodeList *children = _root.GetListOfChildNodes();

	POSITION p = children->GetHeadPosition();
	SIMCOidTreeNode *nextNode;
	while(p)
	{
		nextNode = children->GetNext(p);
		if(nextNode->GetOidValue(symbolName, moduleName, val))
			return TRUE;
	}
	return FALSE;
}

SIMCOidTreeNode *SIMCOidTree::GetParentOf(const SIMCOidTreeNode * node)
{
	
	const SIMCNodeList *children = _root.GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode, *retVal;		
	while(p)
	{
		nextNode = children->GetNext(p);
		if(nextNode == node)
			return &_root;
		if(retVal = nextNode->GetParentOf(node))
			return retVal;
	}
	return NULL;
}

SIMCOidTreeNode *SIMCOidTree::GetParentOf(SIMCSymbol *symbol)
{
	const SIMCNodeList *children = _root.GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode, *retVal;		
	while(p)
	{
		nextNode = children->GetNext(p);
		if(nextNode->HasSymbol(symbol))
			return &_root;
		if(retVal = nextNode->GetParentOf(symbol))
			return retVal;
	}
	return NULL;
}

SIMCOidTreeNode *SIMCOidTreeNode::GetParentOf(const SIMCOidTreeNode * node)
{
	const SIMCNodeList *children = GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode, *retVal;		
	while(p)
	{
		nextNode = children->GetNext(p);
		if(nextNode == node)
			return (SIMCOidTreeNode *)this;
		if(retVal = nextNode->GetParentOf(node))
			return retVal;
	}
	return NULL;
}	

SIMCOidTreeNode *SIMCOidTreeNode::GetParentOf(SIMCSymbol *symbol)
{
	
	const SIMCNodeList *children = GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode, *retVal;		
	while(p)
	{
		nextNode = children->GetNext(p);
		// Check if it has the symbol
		if(nextNode->HasSymbol(symbol))
			return (SIMCOidTreeNode *)this;
		if(retVal = nextNode->GetParentOf(symbol))
			return retVal;
	}
	return NULL;
}



BOOL SIMCOidTree::CheckOidTree(BOOL local, SIMCParseTree * const parseTree)
{
	BOOL retVal = TRUE;

	const SIMCNodeList *children = _root.GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode;
	while(p)
	{
		nextNode = children->GetNext(p);
		if(!nextNode->CheckNode(local, parseTree, NULL, NULL, NULL))
			retVal = FALSE;
	}
	return retVal;
}

BOOL SIMCOidTreeNode::CheckNode(BOOL local, SIMCParseTree *const parseTree, 
								SIMCSymbol *parentSequence,
								SIMCSymbol *parentSequenceOf, 
								SIMCSymbol *ancestor)
{

	BOOL retVal = TRUE;

	// Check if there are more than one object-types
	SIMCSymbol *objectTypeSymbol = NULL;
	SIMCObjectTypeType *objectType;

	POSITION p = _listOfSymbols.GetHeadPosition();
	SIMCSymbol ** nextSymbol;
	while(p)
	{
		nextSymbol = (SIMCSymbol **)_listOfSymbols.GetNext(p);
		SIMCObjectTypeType *dummy;
		switch(SIMCModule::IsObjectType(nextSymbol, dummy))
		{
			case RESOLVE_CORRECT:
				if(objectTypeSymbol)
				{
					SIMCModule *temp = (*nextSymbol)->GetModule();
					parseTree->SemanticError(temp->GetInputFileName(),
						OBJ_TYPE_DUPLICATE_OID,
						(*nextSymbol)->GetLineNumber(), 
						(*nextSymbol)->GetColumnNumber(),
						objectTypeSymbol->GetSymbolName(), 
						(objectTypeSymbol->GetModule())->GetModuleName(),
						(*nextSymbol)->GetSymbolName(),
						temp->GetModuleName());
					retVal = TRUE;
				}
				else
				{
					objectTypeSymbol = *nextSymbol;
					objectType = dummy;
				}
		}
	}

	SIMCModule *module;
	SIMCSymbol **syntaxSymbol;
	SIMCTypeReference *btRef;
	SIMCModule::TypeClass objectTypeClass;
	SIMCType *type;
	long line, column;
	if(objectTypeSymbol)
	{
		syntaxSymbol = objectType->GetSyntax();
		module = objectTypeSymbol->GetModule();
		line = objectTypeSymbol->GetLineNumber();
		column = objectTypeSymbol->GetColumnNumber();
		const char * const inputFileName = module->GetInputFileName();
		const char * const symbolName = objectTypeSymbol->GetSymbolName();
		
		if(ancestor && !parentSequence && !parentSequenceOf)
		{
			parseTree->SemanticError(inputFileName, OBJ_TYPE_PRIMITIVE_CHILD,
				line, column, 
				symbolName, 
				ancestor->GetSymbolName(),
				(ancestor->GetModule())->GetModuleName());
			retVal = FALSE;
		}
		ancestor = objectTypeSymbol;

		if(SIMCModule::IsTypeReference(syntaxSymbol, btRef) == RESOLVE_CORRECT)
		{
			switch(SIMCModule::GetSymbolClass((SIMCSymbol**)&btRef))
			{
				case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
				{
					switch(objectTypeClass = SIMCModule::GetTypeClass(type = 
										((SIMCBuiltInTypeReference *)btRef)->GetType()))
					{
						case SIMCModule::TYPE_SEQUENCE:

							// It better not have a SEQUENCE  or Scalar parent,
							// And it better have a SEQUENCE_OF parent
							if(parentSequence)
							{
								parseTree->SemanticError(inputFileName, OBJ_TYPE_SEQUENCE_CHILD,
									line, column, 
									symbolName,
									parentSequence->GetSymbolName(),
									(parentSequence->GetModule())->GetModuleName());
								retVal = FALSE;
							}
							if(!parentSequenceOf)
							{
								parseTree->SemanticError(inputFileName, OBJ_TYPE_SEQUENCE_NO_PARENT,
									line, column, 
									symbolName);
								retVal = FALSE;
							}
							if(!CheckSequenceProperty(local, parseTree, objectTypeSymbol, objectType, (SIMCBuiltInTypeReference *)btRef))
							{
								//cout << "CheckSequenceProperty returned FALSE" << endl;
								retVal = FALSE;
							}
							// Set the arguments for a recursive call
							parentSequence = objectTypeSymbol;
							parentSequenceOf = NULL;
							break;

						case SIMCModule::TYPE_SEQUENCE_OF:
							if(!CheckSequenceOfProperty(local, parseTree, objectTypeSymbol, (SIMCBuiltInTypeReference *)btRef))
							{
								//cout << "CheckSequenceOfProperty returned FALSE" << endl;
								retVal = FALSE;
							}
							parentSequence = NULL;
							parentSequenceOf = objectTypeSymbol;
							break;
						default:
							parentSequence = NULL;
							parentSequenceOf = NULL;
							break;
					}
				}
				break;
				default:
					parentSequence = NULL;
					parentSequenceOf = NULL;
					break;
			}
		}
	}

	SIMCOidTreeNode *nextChildNode;
	p = _listOfChildNodes.GetHeadPosition();
	while(p)
	{
		nextChildNode = _listOfChildNodes.GetNext(p);
		retVal = nextChildNode->CheckNode(local, parseTree, parentSequence, 
								parentSequenceOf, ancestor) && retVal;
	}
	return retVal;
}


BOOL SIMCOidTreeNode::CheckSequenceProperty(BOOL local, SIMCParseTree *const parseTree, 
						SIMCSymbol *objectTypeSymbol, 
						SIMCObjectTypeType *objectType, 
						SIMCBuiltInTypeReference *seqTypeRef)
{
	BOOL retVal = TRUE;
	SIMCSequenceType *seqType = (SIMCSequenceType *)seqTypeRef->GetType();
	
	// Make a list of OBJECT-TYPES below this node, and belong to the same module as
	// this node
	SIMCSymbolList listOfObjects;
	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	const SIMCSymbolList *symbolList;
	POSITION pSymbols;
	SIMCSymbol **symbol;
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		symbolList = childNode->GetSymbolList();
		pSymbols = symbolList->GetHeadPosition();

		SIMCObjectTypeType *dummy;
		while(pSymbols)
		{
			symbol = (SIMCSymbol **)symbolList->GetNext(pSymbols);
			if(SIMCModule::IsObjectType(symbol, dummy) == RESOLVE_CORRECT &&
				(*symbol)->GetModule() == objectTypeSymbol->GetModule())
				listOfObjects.AddTail((const SIMCSymbol **)symbol);
		}
	}

	// Now check if the members of the SEQUENCE are present in the list of OBJECTS
	// And also that the list does not have any ther objects.

	const char * const objectName = objectTypeSymbol->GetSymbolName();
	const char * const objectModuleName = (objectTypeSymbol->GetModule())->GetModuleName();

	SIMCSequenceList *list = seqType->GetListOfSequences();
	if(list)
	{
		POSITION pSeq = list->GetHeadPosition();
		SIMCSequenceItem *item;
		POSITION pObjects, temp;
		const SIMCSymbol ** nextSymbol;
		BOOL found;
		while(pSeq)
		{
			item = list->GetNext(pSeq);
			// See if the symbol is present in the list of objects collected above
			pObjects = listOfObjects.GetHeadPosition();
			found = FALSE;
			while(pObjects)
			{
				temp = pObjects;
				nextSymbol = listOfObjects.GetNext(pObjects);
				if( (**nextSymbol) == (**item->_value) )
				{
					found = TRUE;
					listOfObjects.RemoveAt(temp);
				}
			}
			if(!found)
			{
				parseTree->SemanticError((seqTypeRef->GetModule())->GetInputFileName(),
					SEQUENCE_WRONG_CHILD,
					item->_valueLine, item->_valueColumn,
					(*item->_value)->GetSymbolName(),
					objectName, objectModuleName);
				retVal = FALSE;
			}
		}
	}

	pSymbols = listOfObjects.GetHeadPosition();
	while(pSymbols)
	{
		symbol = (SIMCSymbol **)listOfObjects.GetNext(pSymbols);
		parseTree->SemanticError(((*symbol)->GetModule())->GetInputFileName(),
			OBJ_TYPE_SEQUENCE_EXTRA_CHILD,
			(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
			(*symbol)->GetSymbolName(),
			objectName, objectModuleName);
		retVal = FALSE;
	}

	return retVal;
}



BOOL SIMCOidTreeNode::CheckSequenceOfProperty(BOOL local, 
						SIMCParseTree * const parseTree, 
						SIMCSymbol *objectTypeSymbol, 
						SIMCBuiltInTypeReference *seqOfTypeRef)
{
	BOOL retVal = TRUE;

	// Store the names for error reporting
	const char * const objectName = objectTypeSymbol->GetSymbolName();
	const char * const objectModuleName = (objectTypeSymbol->GetModule())->GetModuleName();


	SIMCSequenceOfType *seqOfType = (SIMCSequenceOfType *)seqOfTypeRef->GetType();
	SIMCSymbol **seqSymbol = seqOfType->GetType();
	SIMCBuiltInTypeReference *seqTypeRef;
	SIMCSequenceType *seqType;
	if(SIMCModule::IsSequenceTypeReference(seqSymbol, seqTypeRef, seqType)
		!= RESOLVE_CORRECT)
		return FALSE;

	// Check if the node has exactly one OBJECT-TYPE as child, 
	// and that this OBJECT-TYPE has a syntax which is the same as seqType
	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	const SIMCSymbolList *symbolList;
	POSITION pSymbols;
	SIMCSymbol **symbol;
	BOOL found = FALSE;
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		symbolList = childNode->GetSymbolList();
		pSymbols = symbolList->GetHeadPosition();

		SIMCObjectTypeType *childObjType;
		while(pSymbols)
		{
			symbol = (SIMCSymbol **)symbolList->GetNext(pSymbols);
			if(SIMCModule::IsObjectType(symbol, childObjType) == RESOLVE_CORRECT &&
				(*symbol)->GetModule() == objectTypeSymbol->GetModule())
			{
				if(found)
				{
					parseTree->SemanticError(((*symbol)->GetModule())->GetInputFileName(),
						OBJ_TYPE_SEQUENCE_OF_EXTRA_CHILD,
						(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
						(*symbol)->GetSymbolName(),
						objectName, objectModuleName);
					retVal = FALSE;
				}
				else
				{
					// Check its syntax clause
					SIMCSymbol **childSyntaxSymbol = childObjType->GetSyntax();
					SIMCBuiltInTypeReference *childTypeRef;
					SIMCSequenceType *childSeqType;
					switch(SIMCModule::IsSequenceTypeReference(childSyntaxSymbol,
							childTypeRef, childSeqType) )
					{
						case RESOLVE_UNDEFINED:
						case RESOLVE_UNSET:
							parseTree->SemanticError(((*symbol)->GetModule())->GetInputFileName(),
								OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD,
								(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
								(*symbol)->GetSymbolName(),
								objectName, objectModuleName);
							retVal = FALSE;
							break;
						case RESOLVE_IMPORT:
							if(!local)
							{
								parseTree->SemanticError(((*symbol)->GetModule())->GetInputFileName(),
									OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD,
									(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
									(*symbol)->GetSymbolName(),
									objectName, objectModuleName);
								retVal = FALSE;
							}
							break;
						case RESOLVE_CORRECT:
							if( seqType != childSeqType)
							{
								parseTree->SemanticError((objectTypeSymbol->GetModule())->GetInputFileName(),
									OBJ_TYPE_SEQUENCE_OF_SYNTAX_MISMATCH,
									objectTypeSymbol->GetLineNumber(), objectTypeSymbol->GetColumnNumber(),
									objectName,
									(*symbol)->GetSymbolName(),
									((*symbol)->GetModule())->GetModuleName());
								retVal = FALSE;
							}

							found = TRUE;
							break;
					}
				}
			}
		} // while(pSymbols)
	}
	return retVal;
}


BOOL SIMCOidTree::GetObjectGroups(SIMCGroupList *groupList)
{
	BOOL retVal = TRUE;

	const SIMCNodeList *children = _root.GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode;
	while(p)
	{
		nextNode = children->GetNext(p);
		if(!nextNode->GetObjectGroups(this, groupList))
			retVal = FALSE;
	}

	// Now set the AUGMENTed tables of all these groups
	SIMCObjectGroup *nextGroup;
	SIMCTableMembers *tables;
	p = groupList->GetHeadPosition();
	while(p)	// For each OBJECT-GROUP
	{
		nextGroup = groupList->GetNext(p);
		tables = nextGroup->GetTableMembers();
		if(!tables)
			continue;
		POSITION pInner = tables->GetHeadPosition();
		SIMCTable *nextTable;
		SIMCSymbol * rowSymbol; 
		SIMCObjectTypeV2 *rowObjectType;
		while(pInner)	// For each table in the OBJECT-GROUP
		{
			nextTable = tables->GetNext(pInner);
			rowSymbol = nextTable->GetRowSymbol();
			SIMCSymbol **rowSymbolP = &rowSymbol;
			if(SIMCModule::IsObjectTypeV2(rowSymbolP, rowObjectType) != RESOLVE_CORRECT)
				continue;
			SIMCSymbol **augmentsSymbol = rowObjectType->GetAugments();
			if(!augmentsSymbol)
				continue;
			SetAugmentedTable(nextTable, *augmentsSymbol, groupList);
		}
	}
	return retVal;
}
	
void SIMCOidTree::SetAugmentedTable(SIMCTable *table, SIMCSymbol *augmentsSymbol,
									SIMCGroupList *groupList)
{
	SIMCObjectGroup *nextGroup;
	SIMCTableMembers *tables;
	POSITION p = groupList->GetHeadPosition();
	while(p)	// For each OBJECT-GROUP
	{
		nextGroup = groupList->GetNext(p);
		tables = nextGroup->GetTableMembers();
		if(!tables)
			continue;
		POSITION pInner = tables->GetHeadPosition();
		SIMCTable *nextTable;
		while(pInner)	// For each table in the OBJECT-GROUP
		{
			nextTable = tables->GetNext(pInner);
			if(augmentsSymbol == nextTable->GetRowSymbol())
				table->SetAugmentedTable(nextTable);
		}
	}

}

BOOL SIMCOidTreeNode::GetObjectGroups(SIMCOidTree *tree,
									  SIMCGroupList *groupList)
{
	BOOL retVal = TRUE;
	// The list of "named" nodes at this node
	SIMCSymbolList	namedNodes;
	SIMCSymbol **nextSymbol;
	const char * nextSymbolName;
	POSITION pSymbols = _listOfSymbols.GetHeadPosition();
	while(pSymbols)
	{
		nextSymbol = (SIMCSymbol **) _listOfSymbols.GetNext(pSymbols);
		nextSymbolName = (*nextSymbol)->GetSymbolName();
		if(*nextSymbolName == '*')
			continue;
		if(SIMCModule::IsNamedNode(nextSymbol) != RESOLVE_CORRECT)
			continue;

		// So it's a named node
		namedNodes.AddHead((const SIMCSymbol **)nextSymbol);
	}

	// Were there any named nodes collected above
	// TODO: WHY AM I ASSUMING ONLY ONE NAMED NODE????

	if( !namedNodes.IsEmpty())
		retVal = FabricateGroup(tree, (SIMCSymbol *)*namedNodes.GetHead(), groupList) 
								&& retVal;

	// Recurse on all the children
	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		retVal = childNode->GetObjectGroups(tree, groupList) && retVal;
	}
	return retVal;
}


BOOL SIMCOidTreeNode::FabricateGroup(SIMCOidTree *tree,
								  SIMCSymbol *namedNode, 
								  SIMCGroupList *groupList)
{
	SIMCObjectGroup *theGroup = new SIMCObjectGroup;

	theGroup->SetNamedNode (namedNode);
	SIMCCleanOidValue *namedNodeValue = new SIMCCleanOidValue;
	wmilib::auto_ptr < SIMCCleanOidValue > namedNodeValue_Guard ( namedNodeValue ) ;

	if( !tree->GetOidValue(namedNode->GetSymbolName(), namedNode->GetModule()->GetModuleName(),*namedNodeValue))
	{
		delete theGroup;
		return FALSE;
	}

	theGroup->SetGroupValue(namedNodeValue);
	namedNodeValue_Guard.release () ;

	theGroup->SetReference("");
	theGroup->SetDescription("");
	theGroup->SetStatus(SIMCObjectGroup::STATUS_CURRENT);

	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	POSITION pSymbols;
	SIMCSymbol **nextSymbol;
	const SIMCSymbolList *symbolList;
	SIMCCleanOidValue *oidValue;
	SIMCScalar *scalar;
	SIMCTable *table;
	SIMCScalarMembers *scalars = new SIMCScalarMembers;
	SIMCTableMembers *tables= new SIMCTableMembers;
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		symbolList = childNode->GetSymbolList();
		pSymbols = symbolList->GetHeadPosition();
		while(pSymbols)
		{
			nextSymbol = (SIMCSymbol **)symbolList->GetNext(pSymbols);
			if(SIMCModule::IsScalar(nextSymbol) == RESOLVE_CORRECT)
			{
				scalar = new SIMCScalar;
				wmilib::auto_ptr < SIMCScalar > scalar_Guard ( scalar ) ;

				oidValue = new SIMCCleanOidValue;
				wmilib::auto_ptr < SIMCCleanOidValue > oidValue_Guard ( oidValue ) ;

				scalar->SetSymbol(*nextSymbol);
				if(tree->GetOidValue((*nextSymbol)->GetSymbolName(), (*nextSymbol)->GetModule()->GetModuleName(), *oidValue))
				{
					scalar->SetOidValue(oidValue);
					oidValue_Guard.release () ;

					theGroup->AddScalar(scalar);
					scalar_Guard.release () ;
					break;
				}
			}
			else if (SIMCModule::IsTable(nextSymbol) == RESOLVE_CORRECT)
			{
				table = new SIMCTable;
				wmilib::auto_ptr < SIMCTable > table_Guard ( table ) ;

				oidValue = new SIMCCleanOidValue;
				wmilib::auto_ptr < SIMCCleanOidValue > oidValue_Guard ( oidValue ) ;

				table->SetTableSymbol(*nextSymbol);
				if(!tree->GetOidValue((*nextSymbol)->GetSymbolName(), (*nextSymbol)->GetModule()->GetModuleName(),*oidValue))
				{
				}
				else
				{
					table->SetTableOidValue(oidValue);
					if(childNode->FabricateTable(tree, table))
					{
						oidValue_Guard.release () ;
						theGroup->AddTable(table);
						table_Guard.release () ;

						break;
					}
				}
			}
		}
	}

	if(theGroup->GetScalarCount()==0 && theGroup->GetTableCount()==0 )
	{
		delete theGroup;
		return TRUE;
	}
	else
	{
		groupList->AddTail(theGroup);
		return TRUE;
	}

}


BOOL SIMCOidTreeNode::FabricateTable(SIMCOidTree *tree, SIMCTable *table)
{
	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	POSITION pSymbols;
	SIMCSymbol **nextSymbol;
	const SIMCSymbolList *symbolList;

	table->SetRowSymbol(NULL);
	// Search for a row OBJECT-TYPE
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		symbolList = childNode->GetSymbolList();
		pSymbols = symbolList->GetHeadPosition();
		while(pSymbols)
		{
			nextSymbol = (SIMCSymbol **)symbolList->GetNext(pSymbols);
			if(SIMCModule::IsRow(nextSymbol) == RESOLVE_CORRECT)
			{
				table->SetRowSymbol(*nextSymbol);
				break;
			}
		}
		if(table->GetRowSymbol())
			break;
	}

	if(!table->GetRowSymbol())
		return FALSE;

	SIMCCleanOidValue *oidValue = new SIMCCleanOidValue;
	wmilib::auto_ptr < SIMCCleanOidValue > oidValue_Guard ( oidValue ) ;

	if(!tree->GetOidValue((*nextSymbol)->GetSymbolName(), (*nextSymbol)->GetModule()->GetModuleName(),*oidValue) )
	{
		return FALSE;
	}

	table->SetRowOidValue(oidValue);

	if(childNode->FabricateRow(tree, table))
	{
		oidValue_Guard.release () ;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL SIMCOidTreeNode::FabricateRow(SIMCOidTree *tree, SIMCTable *table)
{
	BOOL retVal = TRUE;
	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	POSITION pSymbols;
	SIMCSymbol **nextSymbol;
	const SIMCSymbolList *symbolList;
	SIMCObjectTypeType *objType;
	SIMCScalar *column;
	SIMCCleanOidValue *oidValue;

	// Add all columns to the list
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		symbolList = childNode->GetSymbolList();
		pSymbols = symbolList->GetHeadPosition();
		while(pSymbols)
		{
			nextSymbol = (SIMCSymbol **)symbolList->GetNext(pSymbols);
			if(SIMCModule::IsObjectType(nextSymbol, objType) == RESOLVE_CORRECT)
			{
				column = new SIMCScalar;
				wmilib::auto_ptr < SIMCScalar > column_Guard ( column ) ;

				oidValue = new SIMCCleanOidValue;
				wmilib::auto_ptr < SIMCCleanOidValue > oidValue_Guard ( oidValue ) ;

				column->SetSymbol(*nextSymbol);
				if(!tree->GetOidValue((*nextSymbol)->GetSymbolName(), (*nextSymbol)->GetModule()->GetModuleName(),*oidValue) )
				{
					retVal = FALSE;
					break;
				}
				else
				{
					column->SetOidValue(oidValue);
					oidValue_Guard.release () ;
					table->AddColumnMember(column);
					column_Guard.release () ;
					break;
				}
			}
		}
	}
	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\parser.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <stdarg.h>
#include <iostream.h>
#include <fstream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "smierrsy.hpp"
#include "smierrsm.hpp"


#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "parser.hpp"


const int SIMCParser::MESSAGE_SIZE = 1024;
const int SIMCParser::SYNTAX_ERROR_BASE = 200;
const int SIMCParser::SEMANTIC_ERROR_BASE = 1000;
HINSTANCE SIMCParser::semanticErrorsDll = NULL ;

const char *const SIMCParser::severityLevels[] =
{
    "Fatal",
    "Warning",
    "Information"
};

const char * const SIMCParser::semanticErrorsDllFile = "smierrsm.dll";
const char * const SIMCParser::syntaxErrorsDllFile = "smierrsy.dll";

HINSTANCE SIMCParser::syntaxErrorsDll = NULL ;

SIMCParser::SIMCParser(SIMCErrorContainer * errorContainer,
            SIMCScanner * scanner)
    : _errorContainer(errorContainer), _snmpVersion(0), 
        _theScanner(scanner), _module(NULL)
{

    if ( syntaxErrorsDll == NULL )
            syntaxErrorsDll = LoadLibrary(syntaxErrorsDllFile);

    
    if ( semanticErrorsDll == NULL )
        semanticErrorsDll = LoadLibrary(semanticErrorsDllFile);

}

void SIMCParser::CreateReservedModules()
{
    rfc1155 = rfc1212 = rfc1213 = rfc1215 = rfc1230 = 
        rfc1902 = rfc1903 = rfc1904 = other = NULL;

    // These sets of symbols are "known" by the parser

    // --------------------- 1. Modules ------------------------------------
    
    switch(_snmpVersion)
    {
        case 1:
        {
                // V1 "well-known" modules
            rfc1155 = new SIMCModule("RFC1155-SMI", "INBUILT",  NULL, NULL, NULL, 1, 0, 0, 0);
            rfc1212 = new SIMCModule("RFC-1212",    "INBUILT",  NULL, NULL, NULL, 1, 0, 0, 0);
            rfc1213 = new SIMCModule("RFC1213-MIB", "INBUILT",  NULL, NULL, NULL, 1, 0, 0, 0);
            rfc1215 = new SIMCModule("RFC-1215",    "INBUILT",  NULL, NULL, NULL, 1, 0, 0, 0);
            rfc1230 = new SIMCModule("RFC1230-MIB", "INBUILT",  NULL, NULL, NULL, 1, 0, 0, 0);
            rfc1155->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1212->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1213->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1215->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1230->SetSymbolType(SIMCSymbol::PRIMITIVE);
        }
        break;
        case 2:
        {
                // V2 "well-known" modules
            rfc1902 = new SIMCModule("SNMPv2-SMI",  "INBUILT",  NULL, NULL, NULL, 2, 0, 0, 0);
            rfc1903 = new SIMCModule("SNMPv2-TC",   "INBUILT",  NULL, NULL, NULL, 2, 0, 0, 0);
            rfc1904 = new SIMCModule("SNMPv2-CONF", "INBUILT",  NULL, NULL, NULL, 2, 0, 0, 0);
            rfc1906 = new SIMCModule("SNMPv2-TM",   "INBUILT",  NULL, NULL, NULL, 2, 0, 0, 0);
            rfc1902->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1903->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1904->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1906->SetSymbolType(SIMCSymbol::PRIMITIVE);
        }
        break;
        default:
                // V1 "well-known" modules
            rfc1155 = new SIMCModule("RFC1155-SMI", "INBUILT",  NULL, NULL, NULL, 1, 0, 0, 0);
            rfc1212 = new SIMCModule("RFC-1212",    "INBUILT",  NULL, NULL, NULL, 1, 0, 0, 0);
            rfc1213 = new SIMCModule("RFC1213-MIB", "INBUILT",  NULL, NULL, NULL, 1, 0, 0, 0);
            rfc1215 = new SIMCModule("RFC-1215",    "INBUILT",  NULL, NULL, NULL, 1, 0, 0, 0);
            rfc1230 = new SIMCModule("RFC1230-MIB", "INBUILT",  NULL, NULL, NULL, 1, 0, 0, 0);
            rfc1155->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1212->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1213->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1215->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1230->SetSymbolType(SIMCSymbol::PRIMITIVE);
                // V2 "well-known" modules
            rfc1902 = new SIMCModule("SNMPv2-SMI",  "INBUILT",  NULL, NULL, NULL, 2, 0, 0, 0);
            rfc1903 = new SIMCModule("SNMPv2-TC",   "INBUILT",  NULL, NULL, NULL, 2, 0, 0, 0);
            rfc1904 = new SIMCModule("SNMPv2-CONF", "INBUILT",  NULL, NULL, NULL, 2, 0, 0, 0);
            rfc1906 = new SIMCModule("SNMPv2-TM",   "INBUILT",  NULL, NULL, NULL, 2, 0, 0, 0);
            rfc1902->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1903->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1904->SetSymbolType(SIMCSymbol::PRIMITIVE);
            rfc1906->SetSymbolType(SIMCSymbol::PRIMITIVE);
    }
            // Basic ASN.1 types are here. Common to V1 and V2
    other   = new SIMCModule("BUILTIN",     "INBUILT",  NULL, NULL, NULL, 1, 0, 0, 0);
    other->SetSymbolType(SIMCSymbol::PRIMITIVE);


    // ------------------ 2. TYPES -----------------------------------------
            
            // Common to V1 and V2
    SIMCPrimitiveType *integerPType             = new SIMCPrimitiveType;
    SIMCPrimitiveType *objectIdentifierPType    = new SIMCPrimitiveType;
    SIMCPrimitiveType *octetStringPType         = new SIMCPrimitiveType;
    SIMCPrimitiveType *nullV1PType              = new SIMCPrimitiveType;
    SIMCPrimitiveType *bitsV2PType              = new SIMCPrimitiveType;
    SIMCPrimitiveType *booleanPType             = new SIMCPrimitiveType;
    other->AddSymbol(new SIMCBuiltInTypeReference( objectIdentifierPType,
                                    "OBJECT IDENTIFIER", 
                                    SIMCSymbol::PRIMITIVE,
                                    other, 0, 0, 0 ));
    other->AddSymbol(new SIMCBuiltInTypeReference( integerPType,
                                    "INTEGER",
                                    SIMCSymbol::PRIMITIVE,
                                    other, 0, 0, 0 ));
    other->AddSymbol(new SIMCBuiltInTypeReference(octetStringPType,
                                    "OCTET STRING",
                                    SIMCSymbol::PRIMITIVE,
                                    other, 0, 0, 0 ));
    other->AddSymbol(new SIMCBuiltInTypeReference( nullV1PType,
                                    "NULL",
                                    SIMCSymbol::PRIMITIVE,
                                    other, 0, 0, 0 ));
    other->AddSymbol(new SIMCBuiltInTypeReference( bitsV2PType,
                                    "BITS",
                                    SIMCSymbol::PRIMITIVE,
                                    other, 0, 0, 0 ));
    other->AddSymbol(new SIMCBuiltInTypeReference( booleanPType,
                                    "BOOLEAN",
                                    SIMCSymbol::PRIMITIVE,
                                    other, 0, 0, 0 ));

    objectIdentifierType =  other->GetSymbol("OBJECT IDENTIFIER");
    integerType =           other->GetSymbol("INTEGER");
    octetStringType =       other->GetSymbol("OCTET STRING");
    nullType =              other->GetSymbol("NULL");
    bitsType =              other->GetSymbol("BITS");
    booleanType =           other->GetSymbol("BOOLEAN");

            // V1
    if(_snmpVersion != 2 )
    {
        SIMCPrimitiveType *displayStringV1PType     = new SIMCPrimitiveType;
        SIMCPrimitiveType *macAddressV1PType        = new SIMCPrimitiveType;
        SIMCPrimitiveType *physAddressV1PType       = new SIMCPrimitiveType;
        SIMCPrimitiveType *networkAddressV1PType    = new SIMCPrimitiveType;
        SIMCPrimitiveType *ipAddressV1PType         = new SIMCPrimitiveType;
        SIMCPrimitiveType *counterV1PType           = new SIMCPrimitiveType;
        SIMCPrimitiveType *gaugeV1PType             = new SIMCPrimitiveType;
        SIMCPrimitiveType *timeTicksV1PType         = new SIMCPrimitiveType;
        SIMCPrimitiveType *opaqueV1PType            = new SIMCPrimitiveType;
        SIMCPrimitiveType *trapTypeV1PType          = new SIMCPrimitiveType;
        SIMCPrimitiveType *objectTypeV1PType        = new SIMCPrimitiveType;

        rfc1213->AddSymbol(new SIMCBuiltInTypeReference( displayStringV1PType,
                                        "DisplayString",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1213, 0, 0, 0 ));

        rfc1213->AddSymbol(new SIMCBuiltInTypeReference( physAddressV1PType,
                                        "PhysAddress",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1213, 0, 0, 0 ));

        rfc1230->AddSymbol(new SIMCBuiltInTypeReference( macAddressV1PType,
                                        "MacAddress",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1230, 0, 0, 0 ));

        rfc1155->AddSymbol(new SIMCBuiltInTypeReference( networkAddressV1PType,
                                        "NetworkAddress",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1155, 0, 0, 0 ));

        rfc1155->AddSymbol(new SIMCBuiltInTypeReference( ipAddressV1PType,
                                        "IpAddress",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1155, 0, 0, 0 ));

        rfc1155->AddSymbol(new SIMCBuiltInTypeReference( counterV1PType,
                                        "Counter",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1155, 0, 0, 0 ));

        rfc1155->AddSymbol(new SIMCBuiltInTypeReference( gaugeV1PType,
                                        "Gauge",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1155, 0, 0, 0 ));

        rfc1155->AddSymbol(new SIMCBuiltInTypeReference( opaqueV1PType,
                                        "Opaque",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1155, 0, 0, 0 ));

        rfc1155->AddSymbol(new SIMCBuiltInTypeReference( timeTicksV1PType,
                                        "TimeTicks",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1155, 0, 0, 0 ));

        rfc1212->AddSymbol(new SIMCBuiltInTypeReference( objectTypeV1PType,
                                        "OBJECT-TYPE",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1212, 0, 0, 0 ));

        rfc1215->AddSymbol(new SIMCBuiltInTypeReference( trapTypeV1PType,
                                        "TRAP-TYPE",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1215, 0, 0, 0 ));

    }

    if(_snmpVersion != 1)
    {
        SIMCBuiltInTypeReference * tempBTRef = NULL;
        SIMCTextualConvention *tempTC = NULL;
        SIMCSubType *tempSubType = NULL;
            // V2
        SIMCPrimitiveType *integer32V2PType         = new SIMCPrimitiveType;
        SIMCPrimitiveType *counter32V2PType         = new SIMCPrimitiveType;
        SIMCPrimitiveType *counter64V2PType         = new SIMCPrimitiveType;
        SIMCPrimitiveType *gauge32V2PType           = new SIMCPrimitiveType;
        SIMCPrimitiveType *unsigned32V2PType        = new SIMCPrimitiveType;
        SIMCPrimitiveType *ipAddressV2PType         = new SIMCPrimitiveType;
        SIMCPrimitiveType *timeTicksV2PType         = new SIMCPrimitiveType;
        SIMCPrimitiveType *opaqueV2PType            = new SIMCPrimitiveType;

        rfc1902->AddSymbol(new SIMCBuiltInTypeReference( integer32V2PType,
                                        "Integer32",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1902, 0, 0, 0 ));

        rfc1902->AddSymbol(new SIMCBuiltInTypeReference( ipAddressV2PType,
                                        "IpAddress",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1902, 0, 0, 0 ));

        rfc1902->AddSymbol(new SIMCBuiltInTypeReference( counter32V2PType,
                                        "Counter32",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1902, 0, 0, 0 ));

        rfc1902->AddSymbol(new SIMCBuiltInTypeReference( timeTicksV2PType,
                                        "TimeTicks",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1902, 0, 0, 0 ));

        rfc1902->AddSymbol(new SIMCBuiltInTypeReference( opaqueV2PType,
                                        "Opaque",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1902, 0, 0, 0 ));

        rfc1902->AddSymbol(new SIMCBuiltInTypeReference( counter64V2PType,
                                        "Counter64",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1902, 0, 0, 0 ));

        rfc1902->AddSymbol(new SIMCBuiltInTypeReference( unsigned32V2PType,
                                        "Unsigned32",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1902, 0, 0, 0 ));

        rfc1902->AddSymbol(new SIMCBuiltInTypeReference( gauge32V2PType,
                                        "Gauge32",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1902, 0, 0, 0 ));

        // And the V2 textual conventions
        
        // DisplayString
        SIMCSizeList * displayStringSizeList = new SIMCSizeList;
        displayStringSizeList->AddTail(new SIMCRangeOrSizeItem (
                            0, TRUE, 0, 0,
                            255, TRUE, 0, 0 ));
        char *badNameDisplayString = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInTypeReference (
                tempSubType = new SIMCSizeType(octetStringType, 0, 0,  displayStringSizeList),
                badNameDisplayString, 
                SIMCSymbol::PRIMITIVE,
                rfc1903));
        tempSubType->SetStatus(RESOLVE_CORRECT);
        tempSubType->SetRootType((SIMCTypeReference *)(*octetStringType));

        rfc1903->AddSymbol(tempTC = new SIMCTextualConvention("255a",
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        rfc1903->GetSymbol(badNameDisplayString),
                                        0, 0,
                                        "DisplayString",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1903) );
        delete  badNameDisplayString;
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType(tempTC);
                                        
        // PhysAddress
        rfc1903->AddSymbol(tempTC = new SIMCTextualConvention("1x:",
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        octetStringType,
                                        0, 0,
                                        "PhysAddress",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1903) );
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType(tempTC);
        
        // MacAddress
        SIMCSizeList * macAddressSizeList = new SIMCSizeList;
        macAddressSizeList->AddTail(new SIMCRangeOrSizeItem (
                            6, TRUE, 0, 0,
                            6, TRUE, 0, 0 ));
        char *badNameMacAddress = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInTypeReference (
                tempSubType = new SIMCSizeType(octetStringType, 0, 0,  macAddressSizeList),
                badNameMacAddress, 
                SIMCSymbol::PRIMITIVE,
                rfc1903));
        tempSubType->SetStatus(RESOLVE_CORRECT);
        tempSubType->SetRootType((SIMCTypeReference *)(*octetStringType));
        rfc1903->AddSymbol(tempTC = new SIMCTextualConvention("1x:",
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        rfc1903->GetSymbol(badNameMacAddress),
                                        0, 0,
                                        "MacAddress",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1903) );
        delete  badNameMacAddress;
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType(tempTC);
        
        // TruthValue
        char * badNameTruthValueOne = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(1, FALSE),
                                    badNameTruthValueOne,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        char * badNameTruthValueTwo = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(2, FALSE),
                                    badNameTruthValueTwo,
                                    SIMCSymbol::LOCAL,
                                    rfc1903) );
        SIMCNamedNumberList *truthValueList = new SIMCNamedNumberList;
        truthValueList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameTruthValueOne),
                                0, 0,
                                "true", 0, 0) );
        truthValueList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameTruthValueTwo),
                                0, 0,
                                "false", 0, 0) );
        char *badNameTruthValue = GenerateSymbolName();
        rfc1903->AddSymbol(tempBTRef = new SIMCBuiltInTypeReference( 
                                    tempSubType = new SIMCEnumOrBitsType(integerType, 0, 0, 
                                    truthValueList, SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM),
                                    badNameTruthValue, 
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903));
        tempSubType->SetStatus(RESOLVE_CORRECT);
        tempSubType->SetRootType((SIMCTypeReference *)(*integerType));

        rfc1903->AddSymbol( tempTC = new SIMCTextualConvention (NULL,
                                    SIMCTextualConvention::TC_CURRENT,
                                    0, 0,
                                    "", NULL,
                                    rfc1903->GetSymbol(badNameTruthValue),
                                    0, 0,
                                    "TruthValue",
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType(tempBTRef);
        delete badNameTruthValue;
        delete badNameTruthValueOne;
        delete badNameTruthValueTwo;
                
        // TestAndIncr
        SIMCRangeList * testAndIncrList = new SIMCRangeList;
        testAndIncrList->AddTail(new SIMCRangeOrSizeItem (
                            0, TRUE, 0, 0,
                            2147483647, TRUE, 0, 0 ));
        char *badNameTestAndIncr = GenerateSymbolName();
        rfc1903->AddSymbol( tempBTRef = new SIMCBuiltInTypeReference (
                tempSubType = new SIMCRangeType(integerType, 0, 0,  testAndIncrList),
                badNameTestAndIncr, 
                SIMCSymbol::PRIMITIVE,
                rfc1903));
        tempSubType->SetStatus(RESOLVE_CORRECT);
        tempSubType->SetRootType((SIMCTypeReference *)(*integerType));
        rfc1903->AddSymbol( tempTC = new SIMCTextualConvention(NULL,
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        rfc1903->GetSymbol(badNameTestAndIncr),
                                        0, 0,
                                        "TestAndIncr",
                                        SIMCSymbol::LOCAL,
                                        rfc1903) );
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType(tempBTRef);
        delete  badNameTestAndIncr;
    
        // AutonomousType
        rfc1903->AddSymbol( tempTC = new SIMCTextualConvention(NULL,
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        objectIdentifierType,
                                        0, 0,
                                        "AutonomousType",
                                        SIMCSymbol::LOCAL,
                                        rfc1903) );
        
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType((SIMCTypeReference *)(*objectIdentifierType));

        // InstancePointer
        rfc1903->AddSymbol( tempTC = new SIMCTextualConvention(NULL,
                                        SIMCTextualConvention::TC_OBSOLETE,
                                        0, 0,
                                        "", NULL, 
                                        objectIdentifierType,
                                        0, 0,
                                        "InstancePointer",
                                        SIMCSymbol::LOCAL,
                                        rfc1903) );
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType((SIMCTypeReference *)(*objectIdentifierType));
        
        // RowPointer
        rfc1903->AddSymbol( tempTC = new SIMCTextualConvention(NULL,
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        objectIdentifierType,
                                        0, 0,
                                        "RowPointer",
                                        SIMCSymbol::LOCAL,
                                        rfc1903) );
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType((SIMCTypeReference *)(*objectIdentifierType));

        // VariablePointer
        rfc1903->AddSymbol( tempTC = new SIMCTextualConvention(NULL,
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        objectIdentifierType,
                                        0, 0,
                                        "VariablePointer",
                                        SIMCSymbol::LOCAL,
                                        rfc1903) );
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType((SIMCTypeReference *)(*objectIdentifierType));
                    
        // RowStatus. Wish me luck.
        char * badNameRowStatusOne = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(1, FALSE),
                                    badNameRowStatusOne,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        char * badNameRowStatusTwo = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(2, FALSE),
                                    badNameRowStatusTwo,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        char * badNameRowStatusThree = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(3, FALSE),
                                    badNameRowStatusThree,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        char * badNameRowStatusFour = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(4, FALSE),
                                    badNameRowStatusFour,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        char * badNameRowStatusFive = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(5, FALSE),
                                    badNameRowStatusFive,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        char * badNameRowStatusSix = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(6, FALSE),
                                    badNameRowStatusSix,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        
        SIMCNamedNumberList *rowStatusList = new SIMCNamedNumberList;
        rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusOne),
                                0, 0,
                                "active", 0, 0) );
        rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusTwo),
                                0, 0,
                                "notInService", 0, 0) );
        rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusThree),
                                0, 0,
                                "notReady", 0, 0) );
        rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusFour),
                                0, 0,
                                "createAndGo", 0, 0) );
        rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusFive),
                                0, 0,
                                "createAndWait", 0, 0) );
        rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusSix),
                                0, 0,
                                "destroy", 0, 0) );
        char *badNameRowStatus = GenerateSymbolName();
        rfc1903->AddSymbol(tempBTRef = new SIMCBuiltInTypeReference( 
                                    tempSubType = new SIMCEnumOrBitsType(integerType, 0, 0, 
                                        rowStatusList, SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM),
                                    badNameRowStatus, 
                                    SIMCSymbol::LOCAL,
                                    rfc1903));
        tempSubType->SetStatus(RESOLVE_CORRECT);
        tempSubType->SetRootType((SIMCTypeReference *)(*integerType));

        rfc1903->AddSymbol( tempTC = new SIMCTextualConvention (NULL,
                                    SIMCTextualConvention::TC_CURRENT,
                                    0, 0,
                                    "", NULL,
                                    rfc1903->GetSymbol(badNameRowStatus),
                                    0, 0,
                                    "RowStatus",
                                    SIMCSymbol::LOCAL,
                                    rfc1903) );
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType(tempBTRef);
        delete badNameRowStatus;
        delete badNameRowStatusOne;
        delete badNameRowStatusTwo;
        delete badNameRowStatusThree;
        delete badNameRowStatusFour;
        delete badNameRowStatusFive;
        delete badNameRowStatusSix;


        // TimeStamp
        rfc1903->AddSymbol(tempTC = new SIMCTextualConvention( NULL,
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        rfc1902->GetSymbol("TimeTicks"),
                                        0, 0,
                                        "TimeStamp",
                                        SIMCSymbol::LOCAL,
                                        rfc1903) );
                                        
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType((SIMCTypeReference *)(*rfc1902->GetSymbol("TimeTicks")));

        // TimeInterval
        SIMCRangeList * timeIntervalList = new SIMCRangeList;
        timeIntervalList->AddTail(new SIMCRangeOrSizeItem (
                            0, TRUE, 0, 0,
                            2147483647, TRUE, 0, 0 ));
        char *badNameTimeInterval = GenerateSymbolName();
        rfc1903->AddSymbol( tempBTRef = new SIMCBuiltInTypeReference (
                tempSubType = new SIMCRangeType(integerType, 0, 0,  timeIntervalList),
                badNameTimeInterval, 
                SIMCSymbol::LOCAL,
                rfc1903));
        tempSubType->SetStatus(RESOLVE_CORRECT);
        tempSubType->SetRootType((SIMCTypeReference *)(*integerType));
        rfc1903->AddSymbol(tempTC = new SIMCTextualConvention(NULL,
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        rfc1903->GetSymbol(badNameTimeInterval),
                                        0, 0,
                                        "TimeInterval",
                                        SIMCSymbol::LOCAL,
                                        rfc1903) );
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType(tempBTRef);
        delete  badNameTimeInterval;


        // DateAndTime
        SIMCSizeList * dateAndTimeList = new SIMCSizeList;
        dateAndTimeList->AddTail(new SIMCRangeOrSizeItem (
                            8, TRUE, 0, 0,
                            8, TRUE, 0, 0 ));
        dateAndTimeList->AddTail(new SIMCRangeOrSizeItem (
                            11, TRUE, 0, 0,
                            11, TRUE, 0, 0 ));
        char *badNameDateAndTime = GenerateSymbolName();
        rfc1903->AddSymbol( tempBTRef = new SIMCBuiltInTypeReference (
                tempSubType = new SIMCSizeType(octetStringType, 0, 0,  dateAndTimeList),
                badNameDateAndTime, 
                SIMCSymbol::PRIMITIVE,
                rfc1903));
        tempSubType->SetStatus(RESOLVE_CORRECT);
        tempSubType->SetRootType((SIMCTypeReference *)(*octetStringType));
        SIMCTextualConvention *dateAndTimeTC;
        rfc1903->AddSymbol(dateAndTimeTC = new SIMCTextualConvention("2d-1d-1d,1d:1d:1d.1d,1a1d:1d",
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        rfc1903->GetSymbol(badNameDateAndTime),
                                        0, 0,
                                        "DateAndTime",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1903) );
        delete  badNameDateAndTime;
        dateAndTimeTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        dateAndTimeTC->SetRealType(dateAndTimeTC);

        // StorageType
        char * badNameStorageTypeOne = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(1, FALSE),
                                    badNameStorageTypeOne,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        char * badNameStorageTypeTwo = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(2, FALSE),
                                    badNameStorageTypeTwo,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        char * badNameStorageTypeThree = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(3, FALSE),
                                    badNameStorageTypeThree,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        char * badNameStorageTypeFour = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(4, FALSE),
                                    badNameStorageTypeFour,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        char * badNameStorageTypeFive = GenerateSymbolName();
        rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
                                    0, 0,
                                    new SIMCIntegerValue(5, FALSE),
                                    badNameStorageTypeFive,
                                    SIMCSymbol::PRIMITIVE,
                                    rfc1903) );
        
        SIMCNamedNumberList *storageTypeList = new SIMCNamedNumberList;
        storageTypeList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameStorageTypeOne),
                                0, 0,
                                "other", 0, 0) );
        storageTypeList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameStorageTypeTwo),
                                0, 0,
                                "volatile", 0, 0) );
        storageTypeList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameStorageTypeThree),
                                0, 0,
                                "nonVolatile", 0, 0) );
        storageTypeList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameStorageTypeFour),
                                0, 0,
                                "permanent", 0, 0) );
        storageTypeList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameStorageTypeFive),
                                0, 0,
                                "readOnly", 0, 0) );

        char *badNameStorageType = GenerateSymbolName();
        rfc1903->AddSymbol(tempBTRef = new SIMCBuiltInTypeReference( 
                                    tempSubType = new SIMCEnumOrBitsType(integerType, 0, 0, 
                                        storageTypeList, SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM),
                                    badNameStorageType, 
                                    SIMCSymbol::LOCAL,
                                    rfc1903));
        tempSubType->SetStatus(RESOLVE_CORRECT);
        tempSubType->SetRootType((SIMCTypeReference *)(*integerType));

        rfc1903->AddSymbol( tempTC = new SIMCTextualConvention (NULL,
                                    SIMCTextualConvention::TC_CURRENT,
                                    0, 0,
                                    "", NULL,
                                    rfc1903->GetSymbol(badNameStorageType),
                                    0, 0,
                                    "StorageType",
                                    SIMCSymbol::LOCAL,
                                    rfc1903) );
        delete badNameStorageType;
        delete badNameStorageTypeOne;
        delete badNameStorageTypeTwo;
        delete badNameStorageTypeThree;
        delete badNameStorageTypeFour;
        delete badNameStorageTypeFive;
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType(tempBTRef);

        // TDomain
        rfc1903->AddSymbol(tempTC = new SIMCTextualConvention( NULL,
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        objectIdentifierType,
                                        0, 0,
                                        "TDomain",
                                        SIMCSymbol::LOCAL,
                                        rfc1903) );
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType((SIMCTypeReference *)(*objectIdentifierType));
        
        // TAddress
        SIMCSizeList * tAddressSizeList = new SIMCSizeList;
        tAddressSizeList->AddTail(new SIMCRangeOrSizeItem (
                            1, TRUE, 0, 0,
                            255, TRUE, 0, 0 ));
        char *badNameTAddress = GenerateSymbolName();
        rfc1903->AddSymbol( tempBTRef = new SIMCBuiltInTypeReference (
                tempSubType = new SIMCSizeType(octetStringType, 0, 0,  tAddressSizeList),
                badNameTAddress, 
                SIMCSymbol::LOCAL,
                rfc1903));
        tempSubType->SetStatus(RESOLVE_CORRECT);
        tempSubType->SetRootType((SIMCTypeReference *)(*octetStringType));
        rfc1903->AddSymbol(tempTC = new SIMCTextualConvention(NULL,
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        rfc1903->GetSymbol(badNameTAddress),
                                        0, 0,
                                        "TAddress",
                                        SIMCSymbol::LOCAL,
                                        rfc1903) );    
        delete  badNameTAddress;
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType(tempBTRef);

        // SnmpUDPAddress
        SIMCTextualConvention *SnmpUDPAddressTC;
        rfc1906->AddSymbol(SnmpUDPAddressTC = new SIMCTextualConvention("1d.1d.1d.1d/2d",
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        octetStringType,
                                        0, 0,
                                        "SnmpUDPAddress",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1906) );
        SnmpUDPAddressTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        SnmpUDPAddressTC->SetRealType(SnmpUDPAddressTC);
                                        
        // SnmpOSIAddress
        SIMCTextualConvention *SnmpOSIAddressTC;
        rfc1906->AddSymbol(SnmpOSIAddressTC = new SIMCTextualConvention("*1x:/1x:",
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        octetStringType,
                                        0, 0,
                                        "SnmpOSIAddress",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1906) );
        SnmpOSIAddressTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        SnmpOSIAddressTC->SetRealType(SnmpOSIAddressTC);
                                        
        // SnmpNBPAddress
        rfc1906->AddSymbol(tempTC = new SIMCTextualConvention(NULL,
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        octetStringType,
                                        0, 0,
                                        "SnmpNBPAddress",
                                        SIMCSymbol::LOCAL,
                                        rfc1906) );
        tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        tempTC->SetRealType((SIMCTypeReference *)(*octetStringType));
                                        
        // SnmpIPXAddress
        SIMCTextualConvention *SnmpIPXAddressTC;
        rfc1906->AddSymbol(SnmpIPXAddressTC = new SIMCTextualConvention("4x.1x:1x:1x:1x:1x:1x.2d",
                                        SIMCTextualConvention::TC_CURRENT,
                                        0, 0,
                                        "", NULL, 
                                        octetStringType,
                                        0, 0,
                                        "SnmpIPXAddress",
                                        SIMCSymbol::PRIMITIVE,
                                        rfc1906) );
        SnmpIPXAddressTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
        SnmpIPXAddressTC->SetRealType(SnmpIPXAddressTC);
                                        
    }

                                    
    //--------------- 3. OBJECT IDENTIFIERS --------------------------------

    // V1 OIDs
    if(_snmpVersion != 2 )
    {
        SIMCIntegerValue    *one    = new SIMCIntegerValue(1, TRUE),
                            *two    = new SIMCIntegerValue(2, TRUE),
                            *three  = new SIMCIntegerValue(3, TRUE),
                            *four   = new SIMCIntegerValue(4, TRUE),
                            *six    = new SIMCIntegerValue(6, TRUE),
                            *ten    = new SIMCIntegerValue(10, TRUE);
        char    *badNameOne,
                *badNameTwo, 
                *badNameThree, 
                *badNameFour,
                *badNameSix, 
                *badNameTen;

        rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, one,
            badNameOne = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, two,
            badNameTwo = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, three,
            badNameThree = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, four,
            badNameFour = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, six,
            badNameSix = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, ten,
            badNameTen = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));

        SIMCSymbol **oneVal     = rfc1155->GetSymbol(badNameOne);
        SIMCSymbol **twoVal     = rfc1155->GetSymbol(badNameTwo);
        SIMCSymbol **threeVal   = rfc1155->GetSymbol(badNameThree);
        SIMCSymbol **fourVal    = rfc1155->GetSymbol(badNameFour);
        SIMCSymbol **sixVal     = rfc1155->GetSymbol(badNameSix);
        SIMCSymbol **tenVal     = rfc1155->GetSymbol(badNameTen);

        delete badNameOne;
        delete badNameTwo;
        delete badNameThree;
        delete badNameFour;
        delete badNameSix;
        delete badNameTen;

        SIMCOidComponent 
            *isoCom             = new SIMCOidComponent(oneVal,  0, 0, "iso",            0, 0),
            *ccittCom           = new SIMCOidComponent(twoVal,  0, 0, "ccitt",          0, 0),
            *jointIsoCcittCom   = new SIMCOidComponent(threeVal,0, 0, "joint-iso-ccitt",0, 0), 
            *internetCom        = new SIMCOidComponent(oneVal,  0, 0, "internet",       0, 0),
            *orgCom             = new SIMCOidComponent(threeVal,0, 0, "org",            0, 0), 
            *dodCom             = new SIMCOidComponent(sixVal,  0, 0, "dod",            0, 0),
            *directoryCom       = new SIMCOidComponent(oneVal,  0, 0, "directory",      0, 0),
            *mgmtCom            = new SIMCOidComponent(twoVal,  0, 0, "mgmt",           0, 0),
            *experimentalCom    = new SIMCOidComponent(threeVal,0, 0, "experimental",   0, 0),
            *privateRCom        = new SIMCOidComponent(fourVal, 0, 0, "private",        0, 0),
            *enterprisesCom     = new SIMCOidComponent(oneVal,  0, 0, "enterprises",    0, 0),
            *mib2Com            = new SIMCOidComponent(oneVal,  0, 0, "mib-2",          0, 0),
            *interfacesCom      = new SIMCOidComponent(twoVal,  0, 0, "interfaces",     0, 0),
            *ipCom              = new SIMCOidComponent(fourVal, 0, 0, "ip",             0, 0),
            *transmissionCom    = new SIMCOidComponent(tenVal,  0, 0, "transmission",   0, 0);

        // The lists of components  for V1
        // iso
        SIMCOidComponentList *listForIso = new SIMCOidComponentList;
        listForIso->AddTail(isoCom);
        // ccitt
        SIMCOidComponentList *listForCcitt = new SIMCOidComponentList;
        listForCcitt->AddTail(ccittCom);
        // joint-iso-ccitt
        SIMCOidComponentList *listForJointIsoCcitt = new SIMCOidComponentList;
        listForJointIsoCcitt->AddTail(jointIsoCcittCom);
        // internet
        SIMCOidComponentList *listForInternet = new SIMCOidComponentList;
        listForInternet->AddTail(internetCom);
        // directory
        SIMCOidComponentList *listForDirectory = new SIMCOidComponentList;
        listForDirectory->AddTail(directoryCom);
        // mgmt
        SIMCOidComponentList *listForMgmt           = new SIMCOidComponentList;
        listForMgmt->AddTail(mgmtCom);
        // experimental
        SIMCOidComponentList *listForExperimental   = new SIMCOidComponentList;
        listForExperimental->AddTail(experimentalCom);
        // private
        SIMCOidComponentList *listForPrivate        = new SIMCOidComponentList;
        listForPrivate->AddTail(privateRCom);
        // enterprises
        SIMCOidComponentList *listForEnterprises    = new SIMCOidComponentList;
        listForEnterprises->AddTail(enterprisesCom);
        // mib-2
        SIMCOidComponentList *listForMib2           = new SIMCOidComponentList;
        listForMib2->AddTail(mib2Com);
        // interfaces
        SIMCOidComponentList *listForInterfaces     = new SIMCOidComponentList;
        listForInterfaces->AddTail(interfacesCom);
        // ip
        SIMCOidComponentList *listForIp             = new SIMCOidComponentList;
        listForIp->AddTail(ipCom);
        // transmission
        SIMCOidComponentList *listForTransmission   = new SIMCOidComponentList;
        listForTransmission->AddTail(transmissionCom);

        // And finally, the values
        rfc1155->AddSymbol( new SIMCBuiltInValueReference
                                (objectIdentifierType, 0, 0,
                                new SIMCOidValue(listForIso),
                                "iso", SIMCSymbol::PRIMITIVE, rfc1155) );
        isoV1 = rfc1155->GetSymbol("iso");
        listForInternet->AddHead(dodCom);
        listForInternet->AddHead(orgCom);
        listForInternet->AddHead(new SIMCOidComponent ( isoV1, 0, 0, "iso", 0, 0));
        rfc1155->AddSymbol( new SIMCBuiltInValueReference
                                (objectIdentifierType, 0, 0,
                                new SIMCOidValue(listForCcitt),
                                "ccitt", SIMCSymbol::PRIMITIVE, rfc1155) );
        ccittV1 = rfc1155->GetSymbol("ccitt");
        rfc1155->AddSymbol( new SIMCBuiltInValueReference
                                (objectIdentifierType, 0, 0,
                                new SIMCOidValue(listForJointIsoCcitt),
                                "joint-iso-ccitt", SIMCSymbol::PRIMITIVE, rfc1155) );
        jointIsoCcittV1 = rfc1155->GetSymbol("joint-iso-ccitt");
        rfc1155->AddSymbol( new SIMCBuiltInValueReference
                                (objectIdentifierType, 0, 0,
                                new SIMCOidValue(listForInternet),
                                "internet", SIMCSymbol::PRIMITIVE, rfc1155) );
        internetV1 = rfc1155->GetSymbol("internet");

        listForDirectory->AddHead   (new SIMCOidComponent ( internetV1, 0, 0, "internet", 0, 0));
        listForMgmt->AddHead        (new SIMCOidComponent ( internetV1, 0, 0, "internet", 0, 0));
        listForExperimental->AddHead(new SIMCOidComponent ( internetV1, 0, 0, "internet", 0, 0));
        listForPrivate->AddHead     (new SIMCOidComponent ( internetV1, 0, 0, "internet", 0, 0));

        rfc1155->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType, 
                            0, 0,
                            new SIMCOidValue(listForDirectory),
                            "directory", 
                            SIMCSymbol::PRIMITIVE, rfc1155) );
        directoryV1 = rfc1155->GetSymbol("directory");

        rfc1155->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType, 
                            0, 0,
                            new SIMCOidValue(listForMgmt),
                            "mgmt", 
                            SIMCSymbol::PRIMITIVE, rfc1155) );
        mgmtV1 = rfc1155->GetSymbol("mgmt");
        listForMib2->AddHead(new SIMCOidComponent(mgmtV1, 0, 0, "mgmt", 0, 0));


        rfc1155->AddSymbol(new SIMCBuiltInValueReference (
                                objectIdentifierType,
                                0, 0,
                                new SIMCOidValue(listForExperimental),
                                "experimental", 
                                SIMCSymbol::PRIMITIVE, rfc1155) 
                            );
        experimentalV1 = rfc1155->GetSymbol("experimental");


        rfc1155->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType, 
                            0, 0,
                            new SIMCOidValue(listForPrivate),
                            "private", 
                            SIMCSymbol::PRIMITIVE, rfc1155) 
                            );  
        privateV1 = rfc1155->GetSymbol("private");
        listForEnterprises->AddHead(new SIMCOidComponent(privateV1, 0, 0, "private", 0, 0));

        rfc1155->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForEnterprises),
                            "enterprises", 
                            SIMCSymbol::PRIMITIVE, rfc1155) 
                            );
        enterprisesV1 = rfc1155->GetSymbol("enterprises");

        rfc1213->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForMib2),
                            "mib-2", 
                            SIMCSymbol::PRIMITIVE, rfc1213) 
                            );  
        mib2V1 = rfc1213->GetSymbol("mib-2");

        listForIp->AddHead( new SIMCOidComponent (mib2V1, 0, 0, "mib-2", 0, 0));
        listForInterfaces->AddHead( new SIMCOidComponent (mib2V1, 0, 0, "mib-2", 0, 0));
        listForTransmission->AddHead(new SIMCOidComponent (mib2V1, 0, 0, "mib-2", 0, 0));

        rfc1213->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForIp),
                            "ip", 
                            SIMCSymbol::PRIMITIVE, rfc1213) 
                            );  
        ipV1 = rfc1213->GetSymbol("ip");

        rfc1213->AddSymbol(new SIMCBuiltInValueReference ( 
                            objectIdentifierType, 
                            0, 0,
                            new SIMCOidValue(listForInterfaces),
                            "interfaces", 
                            SIMCSymbol::PRIMITIVE, rfc1213) 
                            );  
        interfacesV1 = rfc1213->GetSymbol("interfaces");

        rfc1213->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForTransmission),
                            "transmission", 
                            SIMCSymbol::PRIMITIVE, rfc1213) 
                            );  
        transmissionV1 = rfc1213->GetSymbol("transmission");
    }
    if (_snmpVersion != 1)
    {
        // V2 OIDs
        SIMCIntegerValue    *zeroV2     = new SIMCIntegerValue(0, TRUE),
                            *oneV2      = new SIMCIntegerValue(1, TRUE),
                            *twoV2      = new SIMCIntegerValue(2, TRUE),
                            *threeV2    = new SIMCIntegerValue(3, TRUE),
                            *fourV2     = new SIMCIntegerValue(4, TRUE),
                            *fiveV2     = new SIMCIntegerValue(5, TRUE),
                            *sixV2      = new SIMCIntegerValue(6, TRUE),
                            *tenV2      = new SIMCIntegerValue(10, TRUE);
        char    *badNameZeroV2,
                *badNameOneV2,
                *badNameTwoV2, 
                *badNameThreeV2, 
                *badNameFourV2,
                *badNameFiveV2,
                *badNameSixV2, 
                *badNameTenV2;

        rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, zeroV2,
            badNameZeroV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, oneV2,
            badNameOneV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, twoV2,
            badNameTwoV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, threeV2,
            badNameThreeV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, fourV2,
            badNameFourV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, fiveV2,
            badNameFiveV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, sixV2,
            badNameSixV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
        rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, tenV2,
            badNameTenV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));

        SIMCSymbol **zeroValV2      = rfc1902->GetSymbol(badNameZeroV2);
        SIMCSymbol **oneValV2       = rfc1902->GetSymbol(badNameOneV2);
        SIMCSymbol **twoValV2       = rfc1902->GetSymbol(badNameTwoV2);
        SIMCSymbol **threeValV2     = rfc1902->GetSymbol(badNameThreeV2);
        SIMCSymbol **fourValV2      = rfc1902->GetSymbol(badNameFourV2);
        SIMCSymbol **fiveValV2      = rfc1902->GetSymbol(badNameFiveV2);
        SIMCSymbol **sixValV2       = rfc1902->GetSymbol(badNameSixV2);
        SIMCSymbol **tenValV2       = rfc1902->GetSymbol(badNameTenV2);

        delete badNameZeroV2;
        delete badNameOneV2;
        delete badNameTwoV2;
        delete badNameThreeV2;
        delete badNameFourV2;
        delete badNameFiveV2;
        delete badNameSixV2;
        delete badNameTenV2;

        SIMCOidComponent
            *zero1ComV2         = new SIMCOidComponent(zeroValV2, 0, 0, "zero",         0, 0),
            *zero2ComV2         = new SIMCOidComponent(zeroValV2, 0, 0, "zero",         0, 0),
            *isoComV2           = new SIMCOidComponent(oneValV2,  0, 0, "iso",          0, 0),
            *orgComV2           = new SIMCOidComponent(threeValV2,0, 0, "org",          0, 0), 
            *dodComV2           = new SIMCOidComponent(sixValV2,  0, 0, "dod",          0, 0),
            *internetComV2      = new SIMCOidComponent(oneValV2,  0, 0, "internet",     0, 0),
            *directoryComV2     = new SIMCOidComponent(oneValV2,  0, 0, "directory",    0, 0),
            *mgmtComV2          = new SIMCOidComponent(twoValV2,  0, 0, "mgmt",         0, 0),
            *mib2ComV2          = new SIMCOidComponent(oneValV2,  0, 0, "mib-2",        0, 0),
            *interfacesComV2    = new SIMCOidComponent(twoValV2,  0, 0, "interfaces",       0, 0),
            *ipComV2            = new SIMCOidComponent(fourValV2, 0, 0, "ip",               0, 0),
            *transmissionComV2  = new SIMCOidComponent(tenValV2,  0, 0, "transmission", 0, 0),
            *experimentalComV2  = new SIMCOidComponent(threeValV2,0, 0, "experimental", 0, 0),
            *privateComV2       = new SIMCOidComponent(fourValV2, 0, 0, "private",      0, 0),
            *enterprisesComV2   = new SIMCOidComponent(oneValV2,  0, 0, "enterprises",  0, 0),
            *securityComV2      = new SIMCOidComponent(fiveValV2, 0, 0, "security",     0, 0),
            *snmpV2ComV2        = new SIMCOidComponent(sixValV2,  0, 0, "snmpV2",       0, 0),
            *snmpDomainsComV2   = new SIMCOidComponent(oneValV2,  0, 0, "snmpDomains",  0, 0),
            *snmpProxysComV2    = new SIMCOidComponent(twoValV2,  0, 0, "snmpProxys",   0, 0),
            *snmpModulesComV2   = new SIMCOidComponent(threeValV2,0, 0, "snmpModules",  0, 0),
            *rfc1157ProxyComV2  = new SIMCOidComponent(oneValV2,  0, 0, "rfc1157Proxy", 0, 0),
            *snmpUDPDomainComV2 = new SIMCOidComponent(oneValV2,  0, 0, "snmpUDPDomain",0, 0),
            *snmpCLNSDomainComV2= new SIMCOidComponent(twoValV2,  0, 0, "snmpCLNSDomain",0, 0),
            *snmpCONSDomainComV2= new SIMCOidComponent(threeValV2,0, 0, "snmpCONSDomain",0, 0),
            *snmpDDPDomainComV2 = new SIMCOidComponent(fourValV2, 0, 0, "snmpDDPDomain",0, 0),
            *snmpIPXDomainComV2 = new SIMCOidComponent(fiveValV2, 0, 0, "snmpIPXDomain",0, 0),
            *rfc1157DomainComV2 = new SIMCOidComponent(sixValV2,  0, 0, "rfc1157Domain",0, 0);

        SIMCOidComponentList * listForZeroDotZeroV2     = new SIMCOidComponentList;
        SIMCOidComponentList * listForOrgV2             = new SIMCOidComponentList;
        SIMCOidComponentList * listForDodV2             = new SIMCOidComponentList;
        SIMCOidComponentList * listForInternetV2        = new SIMCOidComponentList;
        SIMCOidComponentList * listForDirectoryV2       = new SIMCOidComponentList;
        SIMCOidComponentList * listForMgmtV2            = new SIMCOidComponentList;
        SIMCOidComponentList * listForMib2V2            = new SIMCOidComponentList;
        SIMCOidComponentList * listForIpV2              = new SIMCOidComponentList;
        SIMCOidComponentList * listForInterfacesV2      = new SIMCOidComponentList;
        SIMCOidComponentList * listForTransmissionV2    = new SIMCOidComponentList;
        SIMCOidComponentList * listForExperimentalV2    = new SIMCOidComponentList;
        SIMCOidComponentList * listForPrivateV2         = new SIMCOidComponentList;
        SIMCOidComponentList * listForEnterprisesV2     = new SIMCOidComponentList;
        SIMCOidComponentList * listForSecurityV2        = new SIMCOidComponentList;
        SIMCOidComponentList * listForSnmpV2V2          = new SIMCOidComponentList;
        SIMCOidComponentList * listForSnmpDomainsV2     = new SIMCOidComponentList;
        SIMCOidComponentList * listForSnmpProxysV2      = new SIMCOidComponentList;
        SIMCOidComponentList * listForSnmpModulesV2     = new SIMCOidComponentList;
        SIMCOidComponentList * listForRfc1157ProxyV2    = new SIMCOidComponentList;
        SIMCOidComponentList * listForSnmpUDPDomainV2   = new SIMCOidComponentList;
        SIMCOidComponentList * listForSnmpCLNSDomainV2  = new SIMCOidComponentList;
        SIMCOidComponentList * listForSnmpCONSDomainV2  = new SIMCOidComponentList;
        SIMCOidComponentList * listForSnmpDDPDomainV2   = new SIMCOidComponentList;
        SIMCOidComponentList * listForSnmpIPXDomainV2   = new SIMCOidComponentList;
        SIMCOidComponentList * listForRfc1157DomainV2   = new SIMCOidComponentList;
        
        // zeroDotZero
        listForZeroDotZeroV2->AddTail(zero1ComV2);
        listForZeroDotZeroV2->AddTail(zero2ComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForZeroDotZeroV2),
                            "zeroDotZero", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        zeroDotZeroV2 = rfc1902->GetSymbol("zeroDotZero");


        // org
        listForOrgV2->AddTail(isoComV2);
        listForOrgV2->AddTail(orgComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForOrgV2),
                            "org", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        orgV2 = rfc1902->GetSymbol("org");

        // dod
        listForDodV2->AddTail(new SIMCOidComponent(orgV2, 0, 0, "org", 0, 0));
        listForDodV2->AddTail(dodComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForDodV2),
                            "dod", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        dodV2 = rfc1902->GetSymbol("dod");

        // internet
        listForInternetV2->AddTail(new SIMCOidComponent(dodV2, 0, 0, "dod", 0, 0));
        listForInternetV2->AddTail(internetComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForInternetV2),
                            "internet", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        internetV2 = rfc1902->GetSymbol("internet");

        // directory
        listForDirectoryV2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
        listForDirectoryV2->AddTail(directoryComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForDirectoryV2),
                            "directory", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        directoryV2 = rfc1902->GetSymbol("directory");

        // mgmt
        listForMgmtV2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
        listForMgmtV2->AddTail(mgmtComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForMgmtV2),
                            "mgmt", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        mgmtV2 = rfc1902->GetSymbol("mgmt");

        // mib-2
        listForMib2V2->AddTail(new SIMCOidComponent(mgmtV2, 0, 0, "mgmt", 0, 0));
        listForMib2V2->AddTail(mib2ComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForMib2V2),
                            "mib-2", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        mib2V2 = rfc1902->GetSymbol("mib-2");

        // ip
        listForIpV2->AddTail(new SIMCOidComponent(mib2V2, 0, 0, "mib-2", 0, 0));
        listForIpV2->AddTail(ipComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForIpV2),
                            "ip", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        ipV2 = rfc1902->GetSymbol("ip");

        // interfaces
        listForInterfacesV2->AddTail(new SIMCOidComponent(mib2V2, 0, 0, "mib-2", 0, 0));
        listForInterfacesV2->AddTail(interfacesComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForInterfacesV2),
                            "interfaces", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        interfacesV2 = rfc1902->GetSymbol("interfaces");


        // transmission
        listForTransmissionV2->AddTail(new SIMCOidComponent(mib2V2, 0, 0, "mib-2", 0, 0));
        listForTransmissionV2->AddTail(transmissionComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForTransmissionV2),
                            "transmission", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        transmissionV2 = rfc1902->GetSymbol("transmission");

        // experimental
        listForExperimentalV2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
        listForExperimentalV2->AddTail(experimentalComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForExperimentalV2),
                            "experimental", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        experimentalV2 = rfc1902->GetSymbol("experimental");

        // private
        listForPrivateV2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
        listForPrivateV2->AddTail(privateComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForPrivateV2),
                            "private", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        privateV2 = rfc1902->GetSymbol("private");

        // enterprises
        listForEnterprisesV2->AddTail(new SIMCOidComponent(privateV2, 0, 0, "private", 0, 0));
        listForEnterprisesV2->AddTail(enterprisesComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForEnterprisesV2),
                            "enterprises", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        enterprisesV2 = rfc1902->GetSymbol("enterprises");

        // security
        listForSecurityV2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
        listForSecurityV2->AddTail(securityComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForSecurityV2),
                            "security", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        securityV2 = rfc1902->GetSymbol("security");

        // snmpV2
        listForSnmpV2V2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
        listForSnmpV2V2->AddTail(snmpV2ComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForSnmpV2V2),
                            "snmpV2", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        snmpV2V2 = rfc1902->GetSymbol("snmpV2");

        // snmpDomains
        listForSnmpDomainsV2->AddTail(new SIMCOidComponent(snmpV2V2, 0, 0, "snmpV2", 0, 0));
        listForSnmpDomainsV2->AddTail(snmpDomainsComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForSnmpDomainsV2),
                            "snmpDomains", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        snmpDomainsV2 = rfc1902->GetSymbol("snmpDomains");

        // snmpProxys
        listForSnmpProxysV2->AddTail(new SIMCOidComponent(snmpV2V2, 0, 0, "snmpV2", 0, 0));
        listForSnmpProxysV2->AddTail(snmpProxysComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForSnmpProxysV2),
                            "snmpProxys", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        snmpProxysV2 = rfc1902->GetSymbol("snmpProxys");

        // snmpModules
        listForSnmpModulesV2->AddTail(new SIMCOidComponent(snmpV2V2, 0, 0, "snmpV2", 0, 0));
        listForSnmpModulesV2->AddTail(snmpModulesComV2);
        rfc1902->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForSnmpModulesV2),
                            "snmpModules", 
                            SIMCSymbol::PRIMITIVE, rfc1902) 
                            );  
        snmpModulesV2 = rfc1902->GetSymbol("snmpModules");

        // snmpUDPDomain
        listForSnmpUDPDomainV2->AddTail(new SIMCOidComponent(snmpDomainsV2, 0, 0, "snmpDomains", 0, 0));
        listForSnmpUDPDomainV2->AddTail(snmpUDPDomainComV2);
        rfc1906->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForSnmpUDPDomainV2),
                            "snmpUDPDomain", 
                            SIMCSymbol::PRIMITIVE, rfc1906) 
                            );  
        snmpUDPDomainV2 = rfc1906->GetSymbol("snmpUDPDomain");

        // snmpCLNSDomain
        listForSnmpCLNSDomainV2->AddTail(new SIMCOidComponent(snmpDomainsV2, 0, 0, "snmpDomains", 0, 0));
        listForSnmpCLNSDomainV2->AddTail(snmpCLNSDomainComV2);
        rfc1906->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForSnmpCLNSDomainV2),
                            "snmpCLNSDomain", 
                            SIMCSymbol::PRIMITIVE, rfc1906) 
                            );  
        snmpCLNSDomainV2 = rfc1906->GetSymbol("snmpCLNSDomain");

        // snmpCONSDomain
        listForSnmpCONSDomainV2->AddTail(new SIMCOidComponent(snmpDomainsV2, 0, 0, "snmpDomains", 0, 0));
        listForSnmpCONSDomainV2->AddTail(snmpCONSDomainComV2);
        rfc1906->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForSnmpCONSDomainV2),
                            "snmpCONSDomain", 
                            SIMCSymbol::PRIMITIVE, rfc1906) 
                            );  
        snmpCONSDomainV2 = rfc1906->GetSymbol("snmpCONSDomain");

        // snmpDDPDomain
        listForSnmpDDPDomainV2->AddTail(new SIMCOidComponent(snmpDomainsV2, 0, 0, "snmpDomains", 0, 0));
        listForSnmpDDPDomainV2->AddTail(snmpDDPDomainComV2);
        rfc1906->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForSnmpDDPDomainV2),
                            "snmpDDPDomain", 
                            SIMCSymbol::PRIMITIVE, rfc1906) 
                            );  
        snmpDDPDomainV2 = rfc1906->GetSymbol("snmpDDPDomain");

        // snmpIPXDomain
        listForSnmpIPXDomainV2->AddTail(new SIMCOidComponent(snmpDomainsV2, 0, 0, "snmpDomains", 0, 0));
        listForSnmpIPXDomainV2->AddTail(snmpIPXDomainComV2);
        rfc1906->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForSnmpIPXDomainV2),
                            "snmpIPXDomain", 
                            SIMCSymbol::PRIMITIVE, rfc1906) 
                            );  
        snmpIPXDomainV2 = rfc1906->GetSymbol("snmpIPXDomain");

        // rfc1157Proxy
        listForRfc1157ProxyV2->AddTail(new SIMCOidComponent(snmpProxysV2, 0, 0, "snmpProxys", 0, 0));
        listForRfc1157ProxyV2->AddTail(rfc1157ProxyComV2);
        rfc1906->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForRfc1157ProxyV2),
                            "rfc1157Proxy", 
                            SIMCSymbol::PRIMITIVE, rfc1906) 
                            );  
        rfc1157ProxyV2 = rfc1906->GetSymbol("rfc1157Proxy");

        // rfc1157Domain
        listForRfc1157DomainV2->AddTail(new SIMCOidComponent(rfc1157ProxyV2, 0, 0, "rfc1157Domain", 0, 0));
        listForRfc1157DomainV2->AddTail(rfc1157DomainComV2);
        rfc1906->AddSymbol(new SIMCBuiltInValueReference (
                            objectIdentifierType,
                            0, 0,
                            new SIMCOidValue(listForRfc1157DomainV2),
                            "rfc1157Domain", 
                            SIMCSymbol::PRIMITIVE, rfc1906) 
                            );  
        rfc1157DomainV2 = rfc1906->GetSymbol("rfc1157Domain");

    }

    /*------------------------- 4. Other Values --------------------- */    
    char    *trueBadName = GenerateSymbolName(), 
            *falseBadName = GenerateSymbolName(), 
            *nullBadName = GenerateSymbolName(); 
    SIMCValue *trueValue = new SIMCBooleanValue(TRUE);
    SIMCValue *falseValue = new SIMCBooleanValue(FALSE);
    SIMCValue *nullValue = new SIMCNullValue();

    other->AddSymbol( new SIMCBuiltInValueReference(booleanType,
                        0, 0,
                        trueValue,
                        trueBadName) );
    other->AddSymbol( new SIMCBuiltInValueReference(booleanType,
                        0, 0,
                        falseValue,
                        falseBadName) );
    other->AddSymbol( new SIMCBuiltInValueReference(nullType,
                        0, 0,
                        nullValue,
                        nullBadName) );
    trueValueReference = other->GetSymbol(trueBadName);
    falseValueReference = other->GetSymbol(falseBadName);
    nullValueReference = other->GetSymbol(nullBadName);
}


SIMCParser::~SIMCParser()
{}

// Handles all syntax errors
void SIMCParser::SyntaxError(int errorType, int lineNo, int columnNo,
                 char *lastToken, char *infoString)
{   
    if( lineNo == -1 )
        lineNo = _theScanner->yylineno;
    if ( columnNo == -1 )
        columnNo = _theScanner->columnNo;
    if(!lastToken)
        lastToken = _theScanner->yytext;

    if (syntaxErrorsDll == NULL)
        cerr << "SIMCParser::SyntaxError(): Panic, NULL syntaxErrorsDll" << endl;

    if( errorType<=0 )
    {
        cerr << "Panic: Unknown Syntax error number:" << errorType << endl;
        return;
    }

    // Create and fill up the fields of an SIMCErrorMessage object
    SIMCErrorMessage errorMessage;
    errorMessage.SetInputStreamName(_theScanner->GetInputStreamName());
    errorMessage.SetLineNumber(lineNo);
    errorMessage.SetColumnNumber(columnNo);
    errorMessage.SetErrorId(SYNTAX_ERROR_BASE + errorType);
    
    char message[MESSAGE_SIZE];
    char errorText[MESSAGE_SIZE];

    if(!LoadString(syntaxErrorsDll, errorType, errorText, MESSAGE_SIZE))
        cerr << "SIMCParser::SyntaxError(): Panic, unable to load error "
        << "string" << endl;

    switch(errorType)
    {
        case SKIPPING_OBJECT_TYPE:  
        case SKIPPING_TRAP_TYPE:
            errorMessage.SetSeverityLevel(INFORMATION);
            errorMessage.SetSeverityString("Information");
            sprintf(message, "%s %s", errorText, infoString);
            errorMessage.SetMessage(message);
            _informationCount++;
            break;
        case TOO_BIG_NUM:
            errorMessage.SetSeverityLevel(FATAL);
            errorMessage.SetSeverityString("Fatal");
            sprintf(message, "%s %s", errorText, infoString);
            errorMessage.SetMessage(message);
            _fatalCount++;
            break;
        case NOTIFICATION_TYPE_DISALLOWED:  
        case MODULE_IDENTITY_DISALLOWED:
        case OBJECT_IDENTITY_DISALLOWED:
        case TEXTUAL_CONVENTION_DISALLOWED:
        case OBJECT_GROUP_DISALLOWED:
        case NOTIFICATION_GROUP_DISALLOWED:
        case MODULE_COMPLIANCE_DISALLOWED:
        case AGENT_CAPABILITIES_DISALLOWED:
        case ERROR_OBJECT_TYPE:
        case V1_OBJECT_TYPE_DISALLOWED:
        case V2_OBJECT_TYPE_DISALLOWED:
        case UNTERMINATED_STRING:
        case NAME_INSTEAD_OF_ID:
            errorMessage.SetSeverityLevel(FATAL);
            errorMessage.SetSeverityString("Fatal");
            errorMessage.SetMessage(errorText);
            _fatalCount++;
            break;
        case MODULE_IDENTITY_ONLY_AFTER_IMPORTS:
            errorMessage.SetSeverityLevel(WARNING);
            errorMessage.SetSeverityString("Warning");
            errorMessage.SetMessage(errorText);
            _warningCount++;
            break;
        case INSTEAD_OF_CCE:
            sprintf( message, "Unknown token \"%s\" %s", infoString, 
                errorText);
            errorMessage.SetSeverityLevel(WARNING);
            errorMessage.SetSeverityString("Warning");
            errorMessage.SetMessage(message);
            _warningCount++;
            break;

        case UNRECOGNIZED_CHARACTER:
            sprintf( message, "%s \"%s\"", errorText, 
                infoString);
            errorMessage.SetSeverityLevel(WARNING);
            errorMessage.SetSeverityString("Warning");
            errorMessage.SetMessage(message);
            _warningCount++;
            break;

        default:
            sprintf(message, "Syntax error in %s", errorText);
            if (lastToken)
            {
                strcat(message, ". Last token read is \"");
                strcat(message, lastToken);
                strcat(message, "\"");
            }
            errorMessage.SetMessage(message);
            errorMessage.SetSeverityLevel(FATAL);
            errorMessage.SetSeverityString("Fatal");
            _fatalCount++;
    }

    if( _errorContainer)
        _errorContainer->InsertMessage(errorMessage);
}

SIMCModule * SIMCParser::GetModule() const
{
    return _module;
}


BOOL SIMCParser::SetImportSymbols()
{
    BOOL retVal = TRUE;
    SIMCSymbolTable *symbolTable = _module->GetSymbolTable();
    POSITION p = symbolTable->GetStartPosition();
    SIMCSymbol **next, **import1, **import2;
    CString nextName;
    while(p)
    {
        symbolTable->GetNextAssoc(p, nextName, next);
        if( SIMCModule::GetSymbolClass(next) != SIMCModule::SYMBOL_UNKNOWN)
            continue;
        SIMCSymbol **ref;
        const SIMCModule *reservedModule;
        switch( _module->GetImportedSymbol(nextName, import1, import2))
        {
            case AMBIGUOUS:
                if(reservedModule = IsReservedSymbol(nextName))
                {
                    SIMCSymbol *old = *next;
                    ref = _module->GetSymbol(nextName);
                    import1 = reservedModule->GetSymbol(nextName);
                    (*import1)->SetReferenceCount (
                        (*import1)->GetReferenceCount() +
                        (*ref)->GetReferenceCount() );
                    *ref = *import1;
                    SemanticError(_module->GetInputFileName(),
                        STANDARD_AMBIGUOUS_REFERENCE,
                        old->GetLineNumber(),
                        old->GetColumnNumber(),
                        (const char *)nextName,
                        reservedModule->GetModuleName());
                    delete old;
                }
                else
                {
                    SemanticError(_module->GetInputFileName(),
                        IMPORT_AMBIGUOUS_REFERENCE, 
                        (*next)->GetLineNumber(),
                        (*next)->GetColumnNumber(),
                        (const char *)nextName);
                    retVal = FALSE;
                }
                break;
            case UNAMBIGUOUS:
                ref = _module->GetSymbol(nextName);
                (*import1)->SetReferenceCount (
                    (*import1)->GetReferenceCount() +
                    (*ref)->GetReferenceCount() );
                delete *ref;
                *ref = *import1;
                break;
            case NOT_FOUND:
                SemanticError(_module->GetInputFileName(),
                    SYMBOL_UNDEFINED, 
                    (*next)->GetLineNumber(),
                    (*next)->GetColumnNumber(),
                    (const char *)nextName);
                retVal = FALSE;
        }
    }
    return retVal;
}

BOOL SIMCParser::IsReservedModuleV1(const char * const name)
{

    if( strcmp(name, "RFC1155-SMI") == 0 ||
        strcmp(name, "RFC1213-MIB") == 0 ||
        strcmp(name, "RFC-1212")    == 0 ||
        strcmp(name, "RFC-1215")    == 0 ||
        strcmp(name, "RFC1230-MIB") == 0 ||
        strcmp(name, "BUILTIN")     == 0 )

        return TRUE;
    else
        return FALSE;
}

BOOL SIMCParser::IsReservedModuleV2(const char * const name)
{

    if( strcmp(name, "SNMPv2-SMI")  == 0 ||
        strcmp(name, "SNMPv2-CONF") == 0 ||
        strcmp(name, "SNMPv2-TC")   == 0 ||
        strcmp(name, "SNMPv2-TM")   == 0 ||
        strcmp(name, "BUILTIN")     == 0 )

        return TRUE;
    else
        return FALSE;
}

const SIMCModule* SIMCParser::IsReservedSymbolV1(const char * const name)
{
    if( strcmp(name, "internet")        == 0 ||
        strcmp(name, "directory")       == 0 ||
        strcmp(name, "mgmt")            == 0 ||
        strcmp(name, "experimental")    == 0 ||
        strcmp(name, "private")         == 0 ||
        strcmp(name, "enterprises")     == 0 ||
        strcmp(name, "NetworkAddress")  == 0 ||
        strcmp(name, "IpAddress")       == 0 ||
        strcmp(name, "Counter")         == 0 ||
        strcmp(name, "Gauge")           == 0 ||
        strcmp(name, "TimeTicks")       == 0 ||
        strcmp(name, "Opaque")          == 0 )
    
        return rfc1155; 
    else if (   strcmp(name, "mib-2")           == 0 ||
                strcmp(name, "ip")              == 0 ||
                strcmp(name, "interfaces")      == 0 ||
                strcmp(name, "transmission")    == 0 ||
                strcmp(name, "DisplayString")   == 0 ||
                strcmp(name, "PhysAddress")     == 0 )
    
        return rfc1213; 
    else if (   strcmp(name, "OBJECT-TYPE")     == 0 )
    
        return rfc1212; 
    else if (   strcmp(name, "TRAP-TYPE")       == 0 )
    
        return rfc1215; 
    else if (   strcmp(name, "MacAddress")  == 0 )
    
        return rfc1230; 
    else
        return NULL;

}

const SIMCModule* SIMCParser::IsReservedSymbolV2(const char * const name)
{
    if( strcmp(name, "zeroDotZero")     == 0 ||
        strcmp(name, "org")             == 0 ||
        strcmp(name, "dod")             == 0 ||
        strcmp(name, "internet")        == 0 ||
        strcmp(name, "directory")       == 0 ||
        strcmp(name, "mgmt")            == 0 ||
        strcmp(name, "mib-2")           == 0 ||
        strcmp(name, "transmission")    == 0 ||
        strcmp(name, "experimental")    == 0 ||
        strcmp(name, "private")         == 0 ||
        strcmp(name, "enterprises")     == 0 ||
        strcmp(name, "security")        == 0 ||
        strcmp(name, "snmpV2")          == 0 ||
        strcmp(name, "snmpDomains")     == 0 ||
        strcmp(name, "snmpProxys")      == 0 ||
        strcmp(name, "snmpModules")     == 0 ||
        strcmp(name, "Integer32")       == 0 ||
        strcmp(name, "IpAddress")       == 0 ||
        strcmp(name, "Counter32")       == 0 ||
        strcmp(name, "TimeTicks")       == 0 ||
        strcmp(name, "Unsigned32")      == 0 ||
        strcmp(name, "Counter64")       == 0 ||
        strcmp(name, "Gauge32")         == 0 ||
        strcmp(name, "Opaque")          == 0 ||
        strcmp(name, "MODULE-IDENTITY") == 0 ||
        strcmp(name, "OBJECT-IDENTITY") == 0 ||
        strcmp(name, "OBJECT-TYPE")     == 0 ||
        strcmp(name, "NOTIFICATION-TYPE")== 0)
    
        return rfc1902;
    
    else if (   strcmp(name, "DisplayString")       == 0 ||
                strcmp(name, "PhysAddress"      )   == 0 ||
                strcmp(name, "MacAddress")          == 0 ||
                strcmp(name, "TruthValue")          == 0 ||
                strcmp(name, "TestAndIncr")         == 0 ||
                strcmp(name, "AutonomousType")      == 0 ||
                strcmp(name, "InstancePointer")     == 0 ||
                strcmp(name, "VariablePointer")     == 0 ||
                strcmp(name, "RowPointer"       )   == 0 ||
                strcmp(name, "RowStatus")           == 0 ||
                strcmp(name, "TimeStamp"        )   == 0 ||
                strcmp(name, "TimeInterval")        == 0 ||
                strcmp(name, "DateAndTime")         == 0 ||
                strcmp(name, "StorageType")         == 0 ||
                strcmp(name, "TDomain")             == 0 ||
                strcmp(name, "TAddress")            == 0 )
    
        return rfc1903; 

    else if (   strcmp(name, "OBJECT-GROUP")        == 0 ||
                strcmp(name, "NOTIFICATION-GROUP")  == 0 ||
                strcmp(name, "MODULE-COMPLIANCE")   == 0 ||
                strcmp(name, "AGENT-CAPABILITIES")  == 0 )
    
        return rfc1904; 
    
    else if (   strcmp(name, "snmpUDPDomain")       == 0 ||
                strcmp(name, "SnmpUDPAddress")      == 0 ||
                strcmp(name, "snmpCLNSDomain")      == 0 ||
                strcmp(name, "snmpCONSDomain")      == 0 ||
                strcmp(name, "SnmpOSIAddress")      == 0 ||
                strcmp(name, "snmpDDPDomain")       == 0 ||
                strcmp(name, "SnmpNBPAddress")      == 0 ||
                strcmp(name, "snmpIPXDomain")       == 0 ||
                strcmp(name, "SnmpIPXAddress")      == 0 ||
                strcmp(name, "rfc1157Proxy")        == 0 ||
                strcmp(name, "rfc1157Domain")       == 0 )
        return rfc1906; 
    
    else
        return NULL;

}

BOOL  SIMCParser::IsReservedSymbolV1(const char * const name, 
    const char * const moduleName)
{
    if( strcmp(name, "internet")        == 0 ||
        strcmp(name, "directory")       == 0 ||
        strcmp(name, "mgmt")            == 0 ||
        strcmp(name, "experimental")    == 0 ||
        strcmp(name, "private")         == 0 ||
        strcmp(name, "enterprises")     == 0 ||
        strcmp(name, "NetworkAddress")  == 0 ||
        strcmp(name, "IpAddress")       == 0 ||
        strcmp(name, "Counter")         == 0 ||
        strcmp(name, "Gauge")           == 0 ||
        strcmp(name, "TimeTicks")       == 0 ||
        strcmp(name, "Opaque")          == 0 )
    {
        if(strcmp(moduleName, "RFC1155-SMI") == 0 )
            return TRUE;
        else
            return FALSE;
    }
    else if (   strcmp(name, "mib-2")           == 0 ||
                strcmp(name, "ip")              == 0 ||
                strcmp(name, "interfaces")      == 0 ||
                strcmp(name, "transmission")    == 0 ||
                strcmp(name, "DisplayString")   == 0 ||
                strcmp(name, "PhysAddress")     == 0 )
    {
        if(     strcmp(moduleName, "RFC1213-MIB") == 0 )
            return TRUE;
        else
            return FALSE;
    }
    else if (   strcmp(name, "OBJECT-TYPE")     == 0 )
    {
        if(strcmp(moduleName, "RFC-1212") == 0 )
            return TRUE;
        else
            return FALSE;
    }
    else if (   strcmp(name, "TRAP-TYPE")       == 0 )
    {
        if(strcmp(moduleName, "RFC-1215") == 0 )
            return TRUE;
        else
            return FALSE;
    }
    else if (       strcmp(name, "MacAddress")  == 0 )
    {
        if(strcmp(moduleName, "RFC1230-MIB") == 0 )
            return TRUE;
        else
            return FALSE;
    }
    return FALSE;
}

BOOL  SIMCParser::IsReservedSymbolV2(const char * const name, 
    const char * const moduleName)
{
    if( strcmp(name, "zeroDotZero")     == 0 ||
        strcmp(name, "org")             == 0 ||
        strcmp(name, "dod")             == 0 ||
        strcmp(name, "internet")        == 0 ||
        strcmp(name, "directory")       == 0 ||
        strcmp(name, "mgmt")            == 0 ||
        strcmp(name, "mib-2")           == 0 ||
        strcmp(name, "transmission")    == 0 ||
        strcmp(name, "experimental")    == 0 ||
        strcmp(name, "private")         == 0 ||
        strcmp(name, "enterprises")     == 0 ||
        strcmp(name, "security")        == 0 ||
        strcmp(name, "snmpV2")          == 0 ||
        strcmp(name, "snmpDomains")     == 0 ||
        strcmp(name, "snmpProxys")      == 0 ||
        strcmp(name, "snmpModules")     == 0 ||
        strcmp(name, "Integer32")       == 0 ||
        strcmp(name, "IpAddress")       == 0 ||
        strcmp(name, "Counter32")       == 0 ||
        strcmp(name, "TimeTicks")       == 0 ||
        strcmp(name, "Unsigned32")      == 0 ||
        strcmp(name, "Counter64")       == 0 ||
        strcmp(name, "Gauge32")         == 0 ||
        strcmp(name, "Opaque")          == 0 ||
        strcmp(name, "MODULE-IDENTITY") == 0 ||
        strcmp(name, "OBJECT-IDENTITY") == 0 ||
        strcmp(name, "OBJECT-TYPE")     == 0 ||
        strcmp(name, "NOTIFICATION-TYPE")== 0)
    
    {
        if( strcmp(moduleName, "SNMPv2-SMI") == 0)
            return TRUE;
        else
            return FALSE;
    }
    
    else if (   strcmp(name, "DisplayString")       == 0 ||
                strcmp(name, "PhysAddress"      )   == 0 ||
                strcmp(name, "MacAddress")          == 0 ||
                strcmp(name, "TruthValue")          == 0 ||
                strcmp(name, "TestAndIncr")         == 0 ||
                strcmp(name, "AutonomousType")      == 0 ||
                strcmp(name, "InstancePointer")     == 0 ||
                strcmp(name, "VariablePointer")     == 0 ||
                strcmp(name, "RowPointer"       )   == 0 ||
                strcmp(name, "RowStatus")           == 0 ||
                strcmp(name, "TimeStamp"        )   == 0 ||
                strcmp(name, "TimeInterval")        == 0 ||
                strcmp(name, "DateAndTime")         == 0 ||
                strcmp(name, "StorageType")         == 0 ||
                strcmp(name, "TDomain")             == 0 ||
                strcmp(name, "TAddress")            == 0 )
    
    {
        if( strcmp(moduleName, "SNMPv2-TC") == 0)
            return TRUE;
        else
            return FALSE;
    }

    else if (   strcmp(name, "OBJECT-GROUP")        == 0 ||
                strcmp(name, "NOTIFICATION-GROUP")  == 0 ||
                strcmp(name, "MODULE-COMPLIANCE")   == 0 ||
                strcmp(name, "AGENT-CAPABILITIES")  == 0 )
    
    {
        if( strcmp(moduleName, "SNMPv2-CONF") == 0)
            return TRUE;
        else
            return FALSE;
    }

    else if (   strcmp(name, "snmpUDPDomain")       == 0 ||
                strcmp(name, "SnmpUDPAddress")      == 0 ||
                strcmp(name, "snmpCLNSDomain")      == 0 ||
                strcmp(name, "snmpCONSDomain")      == 0 ||
                strcmp(name, "SnmpOSIAddress")      == 0 ||
                strcmp(name, "snmpDDPDomain")       == 0 ||
                strcmp(name, "SnmpNBPAddress")      == 0 ||
                strcmp(name, "snmpIPXDomain")       == 0 ||
                strcmp(name, "SnmpIPXAddress")      == 0 ||
                strcmp(name, "rfc1157Proxy")        == 0 ||
                strcmp(name, "rfc1157Domain")       == 0 )
    {
        if( strcmp(moduleName, "SNMPv2-TM") == 0)
            return TRUE;
        else
            return FALSE;
    }
    return FALSE;

}

BOOL SIMCParser::IsReservedSymbol(long snmpVersion, const char *const name,
                const char * const moduleName)
{
    switch(snmpVersion)
    {
        case 1:
            return IsReservedSymbolV1(name, moduleName);
        case 2:
            return IsReservedSymbolV2(name, moduleName);
        default:
            return IsReservedSymbolV1(name, moduleName) ||
                IsReservedSymbolV2(name, moduleName);
    }
}

BOOL SIMCParser::IsReservedModule(long snmpVersion, const char *const name)
{
    switch(snmpVersion)
    {
        case 1:
            return IsReservedModuleV1(name);
        case 2:
            return IsReservedModuleV2(name);
        default:
            return IsReservedModuleV1(name) ||
                IsReservedModuleV2(name);
    }
}

const SIMCModule* SIMCParser::IsReservedSymbol(const char * const symbolName)
{
    const SIMCModule *retVal;
    switch(_snmpVersion)
    {
        case 1:
            return IsReservedSymbolV1(symbolName);
        case 2:
            return IsReservedSymbolV2(symbolName);
        default:
            return (retVal = IsReservedSymbolV2(symbolName))? retVal : IsReservedSymbolV1(symbolName);
    }
}

BOOL SIMCParser::IsReservedSymbol(const char *const name, const char * const moduleName)
{
    return IsReservedSymbol(_snmpVersion, name, moduleName);
}

const char * SIMCParser::GetCorrectModuleNames(const char * const name)
{

    if( strcmp(name, "internet")        == 0 ||
        strcmp(name, "directory")       == 0 ||
        strcmp(name, "mgmt")            == 0 ||
        strcmp(name, "experimental")    == 0 ||
        strcmp(name, "private")         == 0 ||
        strcmp(name, "enterprises")     == 0 ||
        strcmp(name, "IpAddress")       == 0 ||
        strcmp(name, "TimeTicks")       == 0 ||
        strcmp(name, "Opaque")          == 0 )
    {
        return "RFC1155-SMI\" or \"SNMPv2-SMI";
    }

    else if(strcmp(name, "NetworkAddress")  == 0 ||
            strcmp(name, "Counter")         == 0 ||
            strcmp(name, "Gauge")           == 0 )
        return "RFC1155-SMI";
    
    else if (strcmp(name, "mib-2")          == 0 ||
            strcmp(name, "transmission")    == 0 )
        return "RFC1213-MIB\" or \"SNMPv2-SMI";
    
    else if (strcmp(name, "ip")             == 0 ||
            strcmp(name, "interfaces")      == 0 )
        return "RFC1213-MIB";

    else if (strcmp(name, "DisplayString")  == 0 ||
            strcmp(name, "PhysAddress")     == 0 )
        return "RFC1213-MIB\" or \"SNMPv2-TC";
    
    else if (   strcmp(name, "OBJECT-TYPE")     == 0 )
        return "RFC-1212 or SNMPv2-SMI";

    else if (   strcmp(name, "TRAP-TYPE")       == 0 )
        return "RFC-1215";

    else if (strcmp(name, "MacAddress") == 0 )
        return "RFC1230-MIB\" or \"SNMPv2-TC";

    else if(    strcmp(name, "zeroDotZero")     == 0 ||
        strcmp(name, "org")             == 0 ||
        strcmp(name, "dod")             == 0 ||
        strcmp(name, "security")        == 0 ||
        strcmp(name, "snmpV2")          == 0 ||
        strcmp(name, "snmpDomains")     == 0 ||
        strcmp(name, "snmpProxys")      == 0 ||
        strcmp(name, "snmpModules")     == 0 ||
        strcmp(name, "Integer32")       == 0 ||
        strcmp(name, "Counter32")       == 0 ||
        strcmp(name, "Unsigned32")      == 0 ||
        strcmp(name, "Counter64")       == 0 ||
        strcmp(name, "Gauge32")         == 0 ||
        strcmp(name, "MODULE-IDENTITY") == 0 ||
        strcmp(name, "OBJECT-IDENTITY") == 0 ||
        strcmp(name, "NOTIFICATION-TYPE")== 0)
        return "SNMPv2-SMI";
    
    else if (   strcmp(name, "TruthValue")          == 0 ||
                strcmp(name, "TestAndIncr")         == 0 ||
                strcmp(name, "AutonomousType")      == 0 ||
                strcmp(name, "InstancePointer")     == 0 ||
                strcmp(name, "VariablePointer")     == 0 ||
                strcmp(name, "RowPointer"       )   == 0 ||
                strcmp(name, "RowStatus")           == 0 ||
                strcmp(name, "TimeStamp"        )   == 0 ||
                strcmp(name, "TimeInterval")        == 0 ||
                strcmp(name, "DateAndTime")         == 0 ||
                strcmp(name, "StorageType")         == 0 ||
                strcmp(name, "TDomain")             == 0 ||
                strcmp(name, "TAddress")            == 0 )
        return "SNMPv2-TC";

    else if (   strcmp(name, "OBJECT-GROUP")        == 0 ||
                strcmp(name, "NOTIFICATION-GROUP")  == 0 ||
                strcmp(name, "MODULE-COMPLIANCE")   == 0 ||
                strcmp(name, "AGENT-CAPABILITIES")  == 0 )
        return "SNMPv2-CONF";

    else if (   strcmp(name, "snmpUDPDomain")       == 0 ||
                strcmp(name, "SnmpUDPAddress")      == 0 ||
                strcmp(name, "snmpCLNSDomain")      == 0 ||
                strcmp(name, "snmpCONSDomain")      == 0 ||
                strcmp(name, "SnmpOSIAddress")      == 0 ||
                strcmp(name, "snmpDDPDomain")       == 0 ||
                strcmp(name, "SnmpNBPAddress")      == 0 ||
                strcmp(name, "snmpIPXDomain")       == 0 ||
                strcmp(name, "SnmpIPXAddress")      == 0 ||
                strcmp(name, "rfc1157Proxy")        == 0 ||
                strcmp(name, "rfc1157Domain")       == 0 )
        return "SNMPv2-TM";

    return NULL;
}

void SIMCParser::DoImportModule( SIMCModule *mainModule, SIMCModule *importModule)
{
    SIMCSymbolTable *importTable = importModule->GetSymbolTable();
    const char * const importModuleName = importModule->GetModuleName();
    POSITION p = importTable->GetStartPosition();
    SIMCSymbol **s;
    CString n;
    
    if(IsReservedModule(_snmpVersion, importModuleName))     // For well known import modules
    {
        SIMCModule *wellKnownModule = mainModule->GetImportModule(importModuleName);
        // Remove all "known" symbols from the symbol table of the import table
        while(p)
        {
            importTable->GetNextAssoc(p, n, s);
            // The symbol is either well-known (reserved) or not
            if(IsReservedSymbol(_snmpVersion, n, importModuleName))
            {
                // Just delete the whole thing
                importTable->RemoveKey(n);
                delete *s;
                delete s;
            }
            else
            {
                wellKnownModule->AddSymbol(*s);
                importTable->RemoveKey(n);
                delete s;
            }
        }
        wellKnownModule->SetInputFileName(importModule->GetInputFileName());
        wellKnownModule->SetLineNumber(importModule->GetLineNumber());
        wellKnownModule->SetColumnNumber(importModule->GetLineNumber());
        delete importModule;
    }
    else // Not a well-known module
    {
        // Go ahead and add the whole module to the imports list
        mainModule->AddImportModule(importModule);
        // And provide a warning for well-known symbol
        while(p)
        {
            importTable->GetNextAssoc(p, n, s);
            // The symbol is either well-known (reserved) or not
            if(IsReservedSymbol(n))
            {
                SemanticError(mainModule->GetInputFileName(),
                    IMPORT_KNOWN_WRONG_MODULE,
                    (*s)->GetLineNumber(),
                    (*s)->GetColumnNumber(),
                    n,
                    GetCorrectModuleNames(n));
            }
        }
    }

}


void SIMCParser::RemoveExtraneousReservedModule(SIMCModule *importModule)
{
    SIMCSymbolTable *importTable = importModule->GetSymbolTable();

    SIMCSymbol **s;
    CString n;
    POSITION p = importTable->GetStartPosition();
    while(p)
    {
        importTable->GetNextAssoc(p, n, s);
        if( (*s)->GetReferenceCount() )
            return;
    }
     _module->RemoveImportModule(importModule);
     delete importModule;
}

BOOL SIMCParser::Parse()
{
    if( syntaxErrorsDll == NULL)
    {
        cerr << "Parse(): FATAL ERROR smierrsy.dll not found" <<
            endl;
        return FALSE;
    }
    if( semanticErrorsDll == NULL)
    {
        cerr << "Parse(): FATAL ERROR smierrsm.dll not found" <<
            endl;
        return FALSE;
    }

    _fatalCount = _warningCount = _informationCount = 0;

    _module = new SIMCModule;
    _module->SetInputFileName(_theScanner->GetInputStreamName());
    if(!_module->SetSnmpVersion(_snmpVersion))
        return FALSE;

    // Create and add the well-known modules
    CreateReservedModules();
    if(_snmpVersion != 2 )
    {
        _module->AddImportModule(rfc1155);
        _module->AddImportModule(rfc1213);
        _module->AddImportModule(rfc1212);
        _module->AddImportModule(rfc1215);
        _module->AddImportModule(rfc1230);
    }
    if(_snmpVersion != 1 )
    {
        _module->AddImportModule(rfc1902);
        _module->AddImportModule(rfc1903);
        _module->AddImportModule(rfc1904);
        _module->AddImportModule(rfc1906);
    }

    _module->AddImportModule(other);

    //yydebug = 1;
    int parseRetVal = yyparse(_theScanner);

    if(_snmpVersion == 2 && !_module->GetModuleIdentityName())
    {
        SemanticError(_module->GetInputFileName(),
            MODULE_IDENTITY_MISSING,
            _module->GetLineNumber(), _module->GetColumnNumber());
        parseRetVal = 1;
    }

    // Clean up
    if(!SetImportSymbols())
        parseRetVal = 1;

    if(_snmpVersion != 2 )
    {
        RemoveExtraneousReservedModule(rfc1155);
        RemoveExtraneousReservedModule(rfc1213);
        RemoveExtraneousReservedModule(rfc1212);
        RemoveExtraneousReservedModule(rfc1215);
        RemoveExtraneousReservedModule(rfc1230);
    }
    if(_snmpVersion != 1 )
    {
        RemoveExtraneousReservedModule(rfc1902);
        RemoveExtraneousReservedModule(rfc1903);
        RemoveExtraneousReservedModule(rfc1904);
        RemoveExtraneousReservedModule(rfc1906);
    }

    RemoveExtraneousReservedModule(other);

    if(_fatalCount == 0   && parseRetVal == 0)
        return TRUE;

    delete _module;
    _module = NULL;
    return FALSE;
}   

void SIMCParser::SemanticError(const char * const inputStreamName,
                                int errorType, int lineNo,
                                int columnNo, ...)
{
    va_list argList;
    va_start(argList, columnNo);
    SIMCErrorMessage e;
    e.SetInputStreamName(inputStreamName);
    e.SetLineNumber(lineNo);
    e.SetColumnNumber(columnNo);
    e.SetErrorId(SEMANTIC_ERROR_BASE + errorType);

    char message[MESSAGE_SIZE];
    char errorText[MESSAGE_SIZE];
    const char *temp1, *temp2, *temp3, *temp4;

    if(!LoadString(semanticErrorsDll, errorType, errorText, MESSAGE_SIZE))
        cerr << "SIMCParser::SemanticError(): Panic, unable to load error "
        << "string" << endl;
    switch(errorType)
    {
        case OBJ_TYPE_SINGULAR_COUNTER:
        case OBJ_TYPE_INDEX_UNNECESSARY:
        case ZERO_IN_OID:
        case IMPORT_UNUSED:
        case ENUM_ZERO_VALUE:
        case KNOWN_REDEFINITION:
        case KNOWN_UNDEFINED:
        case TYPE_UNREFERENCED:
        case VALUE_UNREFERENCED:
        case OBJ_TYPE_DEFVAL_NET_ADDR:
        case OBJ_TYPE_ACCESSIBLE_TABLE:
        case OBJ_TYPE_ACCESSIBLE_ROW:
        case IMPORT_KNOWN_WRONG_MODULE:
        case IR_MODULE_MISSING_WARNING:
        case IR_SYMBOL_MISSING_WARNING:
        case STANDARD_AMBIGUOUS_REFERENCE:
        case MODULE_NO_GROUPS_V1:
        case MODULE_NO_GROUPS_V2:
        case IMPLIED_USELESS:
        case OBJ_TYPE_DUPLICATE_OID:            
        {
                e.SetSeverityLevel(WARNING);
                e.SetSeverityString("Warning");
                _warningCount++;
        }
        break;
        default:
        {
            e.SetSeverityLevel(FATAL);
            e.SetSeverityString("Fatal");
            _fatalCount++;
        }
        break;
    }

    switch(errorType)
    {
        case OBJ_TYPE_INDEX_UNNECESSARY: 
        case OBJ_TYPE_INVALID_DEFVAL: 
        case OBJ_TYPE_SYNTAX_RESOLUTION:
        case OBJ_TYPE_ACCESSIBLE_TABLE: 
        case OBJ_TYPE_ACCESSIBLE_ROW:
        case OBJ_TYPE_DEFVAL_NET_ADDR:
        case OBJ_TYPE_DEFVAL_DISALLOWED:
        case OBJ_TYPE_DEFVAL_RESOLUTION:
        case ZERO_IN_OID:
        case OID_NEGATIVE_INTEGER: 
        case ENUM_ZERO_VALUE: 
        case SIZE_INVALID_VALUE: 
        case SIZE_INVALID_BOUNDS:
        case RANGE_INVALID_BOUNDS:
        case RANGE_NEGATIVE_GAUGE:
        case SUBTYPE_ROOT_RESOLUTION:
        case INTEGER_TOO_BIG:
        case VALUE_ASSIGN_ENUM_INVALID:
        case MODULE_IDENTITY_MISSING:
            sprintf(message, errorText);
            break;
        case OBJ_TYPE_SINGULAR_COUNTER: 
        case OBJ_TYPE_INVALID_ACCESS: 
        case OBJ_TYPE_INVALID_STATUS: 
        case OBJ_TYPE_SEQUENCE_NO_INDEX: 
        case OBJ_TYPE_SEQUENCE_MULTI_REFERENCE: 
        case OBJ_TYPE_SEQUENCE_UNUSED: 
        case OBJ_TYPE_INDEX_RESOLUTION:
        case OBJ_TYPE_INDEX_SYNTAX:
        case SEQUENCE_ITEM_NO_OBJECT:
        case SEQUENCE_TYPE_UNRESOLVED:
        case INVALID_SEQUENCE_OF: 
        case TRAP_TYPE_ENTERPRISE_RESOLUTION: 
        case TRAP_TYPE_VALUE_RESOLUTION: 
        case TRAP_TYPE_VARIABLES_RESOLUTION: 
        case OID_RESOLUTION: 
        case OID_HEAD_ERROR: 
        case IMPORT_UNUSED: 
        case IMPORT_MODULE_ABSENT: 
        case IMPORT_CURRENT: 
        case ENUM_DUPLICATE_VALUE: 
        case ENUM_DUPLICATE_NAME: 
        case ENUM_RESOLUTION: 
        case SIZE_TYPE_RESOLUTION: 
        case RANGE_TYPE_RESOLUTION: 
        case SIZE_VALUE_RESOLUTION: 
        case RANGE_VALUE_RESOLUTION: 
        case SYMBOL_REDEFINITION: 
        case KNOWN_UNDEFINED: 
        case TYPE_UNREFERENCED: 
        case VALUE_UNREFERENCED: 
        case VALUE_ASSIGN_MISMATCH:
        case VALUE_ASSIGN_INVALID:
        case VALUE_ASSIGN_NEGATIVE_INTEGER:
        case SYMBOL_UNDEFINED: 
        case IMPORT_AMBIGUOUS_REFERENCE:
        case TYPE_UNRESOLVED:
        case VALUE_UNRESOLVED:
        case OBJ_TYPE_SEQUENCE_NO_PARENT:
        case TC_INVALID_STATUS:
        case NOTIFICATION_TYPE_INVALID_STATUS: 
            temp1 = va_arg(argList, const char *);
            sprintf(message, errorText, temp1);
            break;
        case OBJ_TYPE_SEQUENCE_INVALID_SYNTAX: 
        case OBJ_TYPE_OID_RESOLUTION:
        case TRAP_TYPE_DUPLICATE_VALUES: 
        case VALUE_ASSIGN_RESOLUTION: 
        case IMPORT_SYMBOL_ABSENT: 
        case IMPORT_KNOWN_WRONG_MODULE: 
        case KNOWN_REDEFINITION:
        case IR_SYMBOL_MISSING_WARNING:
        case IR_SYMBOL_MISSING_FATAL:
        case STANDARD_AMBIGUOUS_REFERENCE:
        case IR_MODULE_MISSING_FATAL:
        case IR_MODULE_MISSING_WARNING:
            temp1 = va_arg(argList, const char *);
            temp2 = va_arg(argList, const char *);
            sprintf(message, errorText, temp1, temp2);
            break;
        case SEQUENCE_WRONG_CHILD:
        case OBJ_TYPE_PRIMITIVE_CHILD:
        case OBJ_TYPE_SEQUENCE_CHILD:
        case OBJ_TYPE_SEQUENCE_EXTRA_CHILD:
        case OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD:
        case OBJ_TYPE_SEQUENCE_OF_SYNTAX_MISMATCH:
        case OBJ_TYPE_SEQUENCE_OF_EXTRA_CHILD:
            temp1 = va_arg(argList, const char *);
            temp2 = va_arg(argList, const char *);
            temp3 = va_arg(argList, const char *);
            sprintf(message, errorText, temp1, temp2, temp3);
            break;
        case OBJ_TYPE_DUPLICATE_OID:            
            temp1 = va_arg(argList, const char *);
            temp2 = va_arg(argList, const char *);
            temp3 = va_arg(argList, const char *);
            temp4 = va_arg(argList, const char *);
            sprintf(message, errorText, temp1, temp2, temp3, temp4);
            break;
    }
    va_end(argList);

    e.SetMessage(message);
    if( _errorContainer  != NULL)
        _errorContainer->InsertMessage(e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\oidvalue.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "module.hpp"

ostream& operator << ( ostream& outStream, 
	const SIMCOidComponent& obj)
{
	outStream << ( (obj._name)? obj._name : "")  << "(";
	(*obj._value)->WriteBrief(outStream);
	outStream << ")";
	return outStream;
}

void SIMCOidValue::WriteValue( ostream& outStream) const
{
	outStream << "OID  ";

	SIMCValue::WriteValue(outStream);

	outStream << endl;
	if( _listOfComponents)
	{
		POSITION p = _listOfComponents->GetHeadPosition();
		SIMCOidComponent *c;
		while(p)
		{
			c = _listOfComponents->GetNext(p);
			outStream << (*c) << ",";
		}	
	}
	outStream << endl;
}


ostream& operator << (ostream& outStream, const SIMCCleanOidValue& obj)
{
	// outStream << "OID VALUE: ";
	POSITION p = obj.GetHeadPosition();
	int i = obj.GetCount();
	while(p)
	{
		outStream << obj.GetNext(p);
		if(i-- != 1)
			outStream << ".";
	}
	outStream << endl;
	return outStream;
}

char *CleanOidValueToString(const SIMCCleanOidValue& obj)
{
	ostrstream outStream ;
	long index = obj.GetCount();
	POSITION p = obj.GetHeadPosition();
	while(p)
	{
		outStream << obj.GetNext(p) ;
		if ( index-- != 1  )
			outStream << ".";
	}

	outStream << ends ;
	return outStream.str();
}

void AppendOid(SIMCCleanOidValue& to, const SIMCCleanOidValue& from)
{
	POSITION p = from.GetHeadPosition();
	while(p)
		to.AddTail(from.GetNext(p));
}


operator == (const SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs)
{
	if( lhs.GetCount() != rhs.GetCount() )
		return FALSE;

	POSITION pLhs = lhs.GetHeadPosition();
	POSITION pRhs = rhs.GetHeadPosition();
	while( pLhs && pRhs )
		if( lhs.GetNext(pLhs) != rhs.GetNext(pRhs) )
			return FALSE;
	if( pRhs || pLhs )
		return FALSE;
	return TRUE;
}	
		
		
operator < (const SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs)
{

	POSITION pLhs = lhs.GetHeadPosition();
	POSITION pRhs = rhs.GetHeadPosition();
	while( pLhs && pRhs )
		if( lhs.GetNext(pLhs) >=  rhs.GetNext(pRhs) )
			return FALSE;
	if( pRhs )
		return TRUE;
	
	if( pLhs )
		return FALSE;

	return TRUE;
}	

SIMCCleanOidValue& CleanOidValueCopy(SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs)
{

	lhs.RemoveAll();
	POSITION pRhs = rhs.GetHeadPosition();
	while( pRhs )
		lhs.AddTail(rhs.GetNext(pRhs));
	return lhs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\registry.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
/****************************************************************************
* This file contains the implementation of the SIMCRegistryCOntroller class
* which has functions that manipulate the information maintained
* in the registry by the mib compiler
*
*/


#include <stdio.h>

#include <iostream.h>
#include <strstrea.h>
#include <limits.h>

#include "precomp.h"
#include <snmptempl.h>

#include <winbase.h>
#include <winreg.h>

#include "infoLex.hpp"
#include "infoYacc.hpp"
#include "moduleInfo.hpp"
#include "ui.hpp"
#include "registry.hpp"

// Iniialize the static members of the class
const char * SIMCRegistryController::rootKeyName =
	"SOFTWARE\\Microsoft\\WBEM\\Providers\\SNMP\\Compiler";
const char * SIMCRegistryController::filePaths = "File Path";
const char *SIMCRegistryController::fileSuffixes = "File Suffixes";
const char *SIMCRegistryController::mibTable =
	"SOFTWARE\\Microsoft\\WBEM\\Providers\\SNMP\\Compiler\\MIB";


/* This returns the path to the MIB file that has the specified module name */
BOOL SIMCRegistryController::GetMibFileFromRegistry(const char * const moduleName, CString& retValue)
{
	HKEY mibTableKey;
	if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					mibTable,
					0,
					KEY_READ,
					&mibTableKey) != ERROR_SUCCESS)
		return FALSE;

	unsigned long dwIndex = 0;
	char lpData[BUFSIZ];
	unsigned long  dataSize = BUFSIZ, lpType;

	if(RegQueryValueEx(mibTableKey,
		moduleName,	
		0,	 
		&lpType,	 
		(unsigned char *)lpData,	
		&dataSize) == ERROR_SUCCESS)
	{
		retValue = lpData;
		RegCloseKey(mibTableKey);
		return TRUE;
	}
	else 
	{
		RegCloseKey(mibTableKey);
		return FALSE;
	}
}


/* This dumps the contents of the MIB table to the standard output */
BOOL SIMCRegistryController::ListMibTable()
{
	HKEY mibTableKey;
	if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					mibTable,
					0,
					KEY_READ,
					&mibTableKey) != ERROR_SUCCESS)
		return FALSE;

	unsigned long dwIndex = 0;
	char lpValueName[BUFSIZ], lpData[BUFSIZ];
	unsigned long  valueSize = BUFSIZ, dataSize = BUFSIZ, lpType;

	while( RegEnumValue(mibTableKey,	
				dwIndex ++,
				lpValueName,
				&valueSize,
				0,
				&lpType,
				(unsigned char *)lpData,
				&dataSize) == ERROR_SUCCESS )
		cout << lpValueName << ": " << lpData << endl;

	RegCloseKey(mibTableKey);
	return TRUE;

}

/* This returns the list of file suffixes in the registry that are possible
* for MIB files */
BOOL SIMCRegistryController::GetMibSuffixes(SIMCStringList & theList)
{
	HKEY rootKey;
	if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					rootKeyName,
					0,
					KEY_READ,
					&rootKey) != ERROR_SUCCESS)
		return FALSE;

	unsigned long dwIndex = 0;
	char lpData[BUFSIZ];
	unsigned long  dataSize = BUFSIZ, lpType;

	if(RegQueryValueEx(rootKey,
		fileSuffixes,	
		0,	 
		&lpType,	 
		(unsigned char *)lpData,	
		&dataSize) == ERROR_SUCCESS)
	// Break the char string into a list of CStrings
	{
		unsigned long start = 0;
		while(start < dataSize-1)
		{
			theList.AddHead(CString(lpData + start));
			start += strlen(lpData + start);
			start++;
		}
		RegCloseKey(rootKey);
		return TRUE;
	}
	else 
	{
		RegCloseKey(rootKey);
		return FALSE;
	}
}


/* This returns the list of directories in the registry that are possible
* locations for MIB files */
BOOL SIMCRegistryController::GetMibPaths(SIMCStringList & theList)
{
	HKEY rootKey;
	if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					rootKeyName,
					0,
					KEY_READ,
					&rootKey) != ERROR_SUCCESS)
		return FALSE;

	unsigned long dwIndex = 0;
	char *lpData = NULL ;
	unsigned long  dataSize = 0, lpType;

	if(RegQueryValueEx(rootKey,
		filePaths,	
		0,	 
		&lpType,	 
		NULL,	
		&dataSize) == ERROR_SUCCESS)
	{
		if(lpData = new char[dataSize + 1])
		{
			if(RegQueryValueEx(rootKey,
				filePaths,	
				0,	 
				&lpType,	 
				(unsigned char *)lpData,	
				&dataSize) == ERROR_SUCCESS)
			// Break the char string into a list of CStrings
			{
				unsigned long start = 0;
				CString nextPath;
				if(dataSize != 0 ) 
				{
					while(start < dataSize-1)
					{
						nextPath = lpData + start;
						if(IsAbsolutePath(nextPath))
							theList.AddHead(nextPath);
						start += nextPath.GetLength();
						start++;
					}
				}
				RegCloseKey(rootKey);
				return TRUE;
			}
			delete [] lpData;
		}
	}
	else
	{
		RegCloseKey(rootKey);
		return FALSE;
	}
	return FALSE;
}

/* This deletes the entire MIB lookup table from the registry */
BOOL SIMCRegistryController::DeleteMibTable()
{
	// Delete the MIB key, thereby removing all its values.
	// And then create the key again.

	HKEY temp1;
	if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
				mibTable,
				0,
				KEY_ALL_ACCESS,
				&temp1) == ERROR_SUCCESS)
	{
		RegCloseKey(temp1);
		if(RegDeleteKey(HKEY_LOCAL_MACHINE, mibTable) 
			!= ERROR_SUCCESS)
			return FALSE;
	}

	unsigned long temp2;
	if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		mibTable, 0, "REG_MULTI_SZ", REG_OPTION_NON_VOLATILE,	KEY_ALL_ACCESS,
		NULL, &temp1, &temp2) != ERROR_SUCCESS)
		return FALSE;

	RegCloseKey(temp1);

	return TRUE;
}


long SIMCRegistryController::GetFileMap(SIMCFileMapList& theList)
{
	SIMCStringList pathList;
	SIMCStringList suffixList;

	if(!GetMibPaths(pathList))
		return 0;

	if(!GetMibSuffixes(suffixList))
		return 0;

	POSITION p = pathList.GetHeadPosition();
	CString nextPath;
	long totalEntries = 0;
	while(p)
	{
		nextPath = pathList.GetNext(p);
		totalEntries += RebuildDirectory(nextPath, suffixList, theList);
	}

	return totalEntries;
}

// Deletes the lookup table and rebuilds it.
long SIMCRegistryController::RebuildMibTable()
{
	if(!DeleteMibTable())
		return 0;

	// DeleteMibTable() guarantees that the key exists. Just open it.
	HKEY mibTableKey;
	if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
				mibTable,
				0,
				KEY_ALL_ACCESS,
				&mibTableKey) != ERROR_SUCCESS)
		return 0;

	SIMCFileMapList theList;
	GetFileMap(theList);
	POSITION p = theList.GetHeadPosition();
	SIMCFileMapElement nextElement;
	while(p)
	{
		nextElement = theList.GetNext(p);
		if(RegSetValueEx(mibTableKey, 
				nextElement.moduleName,
				NULL,REG_SZ, (unsigned char *)(const char * )nextElement.fileName,
				nextElement.fileName.GetLength()+1) 
				!= ERROR_SUCCESS)
			return 0;
	}
	return theList.GetCount();
}


BOOL SIMCRegistryController::IsAbsolutePath(CString pathName)
{
	if(pathName[1] == ':' && pathName[2] == '\\')
		return TRUE;
	return FALSE;
}

/* THis adds the MIB files in a specific drectory to the lookup table */
long SIMCRegistryController::RebuildDirectory(const CString& directory, 
											  const SIMCStringList& suffixList,
											  SIMCFileMapList &theList)
{

	// Save the current directory of the process
	char savedDirectory[BUFSIZ];
	long directoryLength = BUFSIZ;
	if(!GetCurrentDirectory(directoryLength, savedDirectory))
		return 0;

	// Cheange to the specified directory
	if(!SetCurrentDirectory(directory))
		return 0;

	// For all the suffixes
	POSITION p = suffixList.GetHeadPosition();
	long totalEntries = 0;
	CString regExp;
	char fullPathName[BUFSIZ], *dummy;
	long fullSize = BUFSIZ;
	HANDLE fp;
	WIN32_FIND_DATA fileData;
	while(p)
	{
		regExp = "*.";
		regExp += suffixList.GetNext(p);
		// For all the files in this directory, that match the suffix
		if( (fp = FindFirstFile(regExp, &fileData)) == INVALID_HANDLE_VALUE)
			continue;

		// Get the full path name of the file
		if(GetFullPathName(fileData.cFileName, fullSize, fullPathName, &dummy))		
		{
			if(ProcessFile(fullPathName, theList)) 
				totalEntries++;
		}

		while(FindNextFile(fp, &fileData))
		{
			if(GetFullPathName(fileData.cFileName, fullSize = BUFSIZ, fullPathName, &dummy))		
			{
				if(ProcessFile(fullPathName, theList))
					totalEntries++;
			}
		}
		FindClose(fp);
	}

	// Change back to the current directory
	SetCurrentDirectory(savedDirectory);

	return totalEntries;

}

/* This adds a specific MIB file to the lookup table */
BOOL SIMCRegistryController::ProcessFile(const char * const fileName, 
										 SIMCFileMapList &theList)
{
	FILE *fp = fopen(fileName, "r");
	if(fp)
	{
		SIMCModuleInfoScanner smallScanner;
		smallScanner.setinput(fp);
		SIMCModuleInfoParser smallParser;
		if(smallParser.GetModuleInfo(&smallScanner))
		{
			// Add the mapping to the list
			fclose(fp);
			theList.AddTail(SIMCFileMapElement(smallParser.GetModuleName(),
							fileName));
			return TRUE;
		}
		else
		{
			fclose(fp);
			return FALSE;
		}
	}
	return FALSE;
}

BOOL SIMCRegistryController::GetMibFileFromMap(const SIMCFileMapList& theList, 
	const CString& module, 
	CString &file)
{
	POSITION p = theList.GetHeadPosition();
	SIMCFileMapElement nextElement;
	while(p)
	{
		nextElement = theList.GetNext(p);
		if(nextElement.moduleName == module)
		{
			file = nextElement.fileName;
			return TRUE;
		}
	}
	return FALSE;

}

/* Adds the file corresponding to dependentModule to dependencyList, if 
* it isnt already there.*/
BOOL SIMCRegistryController::ShouldAddDependentFile(SIMCFileMapList& dependencyList,
											  const CString& dependentModule,
											  CString& dependentFile,
											  const SIMCFileMapList& priorityList)
{
	if(IsModulePresent(dependencyList, dependentModule))
		return FALSE;

	// First look in the priority list, for the file
	// And then in the registry lookup table
	if(GetMibFileFromMap(priorityList, dependentModule, dependentFile))
	{
		if(IsFilePresent(dependencyList, dependentFile))
			return FALSE;
		else
			return TRUE;
	}

	if(GetMibFileFromRegistry(dependentModule, dependentFile))
	{
		if(IsFilePresent(dependencyList, dependentFile))
			return FALSE;
		else
			return TRUE;
	}

	// The module is neither in the subsidiary files, nor in the
	// include directories, nor in the registry.
	return FALSE;
}

BOOL SIMCRegistryController::GetDependentModules(const char * const fileName,
					SIMCFileMapList& dependencyList,
					const SIMCFileMapList& priorityList)
{
	// All the subsidiary files and files in include directories are assumed
	// to be in priorityList

	FILE * fp = fopen(fileName, "r");
	if(fp)
	{
 		SIMCModuleInfoScanner smallScanner;
		smallScanner.setinput(fp);
		SIMCModuleInfoParser smallParser;
		CString dependentFile, dependentModule;
		if(smallParser.GetModuleInfo(&smallScanner))
		{
			fclose(fp); // Better close it rightnow, because of the recursion below

			// Add the current file to the dependency list
			// dependencyList.AddTail(SIMCFileMapElement(smallParser.GetModuleName(), fileName));

			// Look at the import modules
			const SIMCStringList * importList = smallParser.GetImportModuleList();
			POSITION p = importList->GetHeadPosition();
			while(p)
			{
				dependentModule = importList->GetNext(p);
				if(ShouldAddDependentFile(dependencyList,  dependentModule, dependentFile, priorityList))
				{
					FILE * Innerfp = fopen(dependentFile, "r");
					if(Innerfp)
					{
 						SIMCModuleInfoScanner smallInnerScanner;
						smallInnerScanner.setinput(Innerfp);
						SIMCModuleInfoParser smallInnerParser;
						if(smallInnerParser.GetModuleInfo(&smallInnerScanner))
						{
							fclose(Innerfp); // Better close it rightnow, because of the recursion below

							// Add the current file to the dependency list
							dependencyList.AddTail(SIMCFileMapElement(smallInnerParser.GetModuleName(), dependentFile));
							GetDependentModules(dependentFile, dependencyList, priorityList);
						}
					}
				}
			}
			return TRUE;
		}
		else
		{
			fclose(fp);
			return FALSE;
		}
	}
	else
		return FALSE;
	return FALSE;
}

BOOL SIMCRegistryController::DeleteRegistryDirectory(const CString& directoryName)
{
	// First Get the fully qualified path name from 'directoryName'
	char fullPathName[BUFSIZ], *dummy;
	long fullSize = 0;
	SIMCStringList theList;
	if(GetFullPathName(directoryName, BUFSIZ, fullPathName, &dummy))		
	{
		fullSize = strlen(fullPathName);
		HKEY rootKey;
		if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
						rootKeyName,
						0,
						KEY_ALL_ACCESS,
						&rootKey) != ERROR_SUCCESS)
			return FALSE;

		unsigned long dwIndex = 0;
		char *lpData = NULL;
		unsigned long  dataSize = BUFSIZ, lpType;

		BOOL found = FALSE;
		long length = 0;
		if(RegQueryValueEx(rootKey,
			filePaths,	
			0,	 
			&lpType,	 
			NULL,	
			&dataSize) == ERROR_SUCCESS)
		{
			if(lpData = new char[dataSize+1])
			{
				if(RegQueryValueEx(rootKey,
					filePaths,	
					0,	 
					&lpType,	 
					(unsigned char *)lpData,	
					&dataSize) == ERROR_SUCCESS)
				// Break the char string into a list of CStrings
				{
					unsigned long start = 0, resultLength = 0;
					while(start+1 < dataSize)
					{	
						CString nextPath(lpData + start);
						if(_strcmpi(nextPath, fullPathName) )
						{
							theList.AddTail(nextPath);
							resultLength += (nextPath.GetLength() + 1 );
						}
						else
							found = TRUE;
						start += strlen(lpData + start);
						start++;
					}

					if(!found)
					{
						RegCloseKey(rootKey);
						delete [] lpData;
						return FALSE;
					}

					char *temp = lpData;
					POSITION p = theList.GetHeadPosition();
					CString nextPath;
					while(p)
					{
						strcpy(temp, nextPath = theList.GetNext(p));
						temp += (nextPath.GetLength() + 1);
					}
					*temp = NULL;

					if(RegSetValueEx(rootKey, filePaths,
							NULL,REG_MULTI_SZ, 
							(unsigned char * )lpData,
							resultLength) 
							!= ERROR_SUCCESS)
					{
						RegCloseKey(rootKey);
						delete [] lpData;
						return FALSE;
					}
					else
					{
						delete [] lpData;
						RegCloseKey(rootKey);
						return TRUE;
					}
				}
				delete [] lpData;
			}
			else
			{
				RegCloseKey(rootKey);
				return FALSE;
			}
		}
		else
		{
			RegCloseKey(rootKey);
			return FALSE;
		}
	}
	else
		return FALSE;

	return FALSE;
}

BOOL SIMCRegistryController::AddRegistryDirectory(const CString& directoryName)
{
	// First Get the fully qualified path name from 'directoryName'
	char fullPathName[BUFSIZ], *dummy;
	long fullSize = 0;
	SIMCStringList theList;
	if(GetFullPathName(directoryName, BUFSIZ, fullPathName, &dummy))		
	{
		// Check whether the directory exists
		fullSize = strlen(fullPathName);
		HANDLE hDir = CreateFile (
			fullPathName,
			GENERIC_READ,
			FILE_SHARE_READ|FILE_SHARE_DELETE,
			NULL,
			OPEN_EXISTING,
			FILE_FLAG_BACKUP_SEMANTICS,
			NULL
		);

		if(hDir == INVALID_HANDLE_VALUE)
			return FALSE;
		else
			CloseHandle(hDir);

		// Check that the path is not a UNC name
		if(fullPathName[0] == '\\' && fullPathName[1] == '\\')
			return FALSE;

		// Open the root key. Create it if doesn't exist
		HKEY rootKey;
		unsigned long temp2;
		if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,
			rootKeyName, 0, 
			"REG_SZ", 
			REG_OPTION_NON_VOLATILE,	
			KEY_ALL_ACCESS,
			NULL, &rootKey, &temp2) != ERROR_SUCCESS)
				return FALSE;

		unsigned long dwIndex = 0;
		char *lpData = NULL;
		unsigned long  dataSize = BUFSIZ, lpType;

		long length = 0;
		unsigned long resultLength = 0;
 		// If a directory list already exists, retrieve it
		if(RegQueryValueEx(rootKey,
			filePaths,	
			0,	 
			&lpType,	 
			NULL,	
			&dataSize) == ERROR_SUCCESS)
		{
			if(lpData = new char[dataSize + strlen(fullPathName) + 2])
			{
				if(RegQueryValueEx(rootKey,
					filePaths,	
					0,	 
					&lpType,	 
					(unsigned char *)lpData,	
					&dataSize) == ERROR_SUCCESS)
				{
					// Break the char string into a list of CStrings
					unsigned long start = 0;
					CString nextPath;
					while(start+1 < dataSize)
					{	
						nextPath = lpData + start;
						theList.AddTail(nextPath);
						resultLength += (nextPath.GetLength() + 1 );
						start += strlen(lpData + start);
						start++;
					}
				}
			}
			else
			{
				RegCloseKey(rootKey);
				return FALSE;
			}
		}
		else
		{
			// This is the first entry
			if(!(lpData = new char[strlen(fullPathName) + 2]))
			{
				RegCloseKey(rootKey);
				return FALSE;
			}
		}

		// Append the new directory to the existing list of directories
		char *temp = lpData;
		POSITION p = theList.GetHeadPosition();
		CString nextPath = "";
		while(p)
		{
			nextPath= theList.GetNext(p);
			if(nextPath.CompareNoCase(fullPathName) != 0) 
			{
				strcpy(temp, nextPath );
				temp += (nextPath.GetLength()+1);
			}
		}
		strcpy(temp, fullPathName);
		temp += fullSize;
		*(temp++) = NULL;
		resultLength = (unsigned long)(temp - lpData) + 1; 
		if(RegSetValueEx(rootKey, filePaths,
				NULL,REG_MULTI_SZ, 
				(unsigned char * )lpData,
				resultLength) 
				!= ERROR_SUCCESS)
		{
			RegCloseKey(rootKey);
			return FALSE;
		}
		else
			RegCloseKey(rootKey);
	}
	else
		return FALSE;

	return TRUE;
}

BOOL SIMCRegistryController::IsModulePresent(SIMCFileMapList& dependencyList,
											  const CString& dependentModule)
{
	POSITION p = dependencyList.GetHeadPosition();
	SIMCFileMapElement element;

	// See if the dependentModule isn't already there
	while(p)
	{
		element = dependencyList.GetNext(p);
		if( element.moduleName == dependentModule)
			return TRUE;
	}
	return FALSE;
}

BOOL SIMCRegistryController::IsFilePresent(SIMCFileMapList& dependencyList,
											  const CString& dependentFile)
{
	POSITION p = dependencyList.GetHeadPosition();
	SIMCFileMapElement element;

	// See if the dependentModule isn't already there
	while(p)
	{
		element = dependencyList.GetNext(p);
		if( element.fileName == dependentFile)
			return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\symbol.cpp ===
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//

#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "oidValue.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "module.hpp"

SIMCSymbol::SIMCSymbol(const char * const symbolName, 
					SymbolType symbolType,
					SIMCModule *module,
					long lineNumber, long columnNumber,
					long referenceCount)
					:	_symbolType(symbolType),
						_module(module), _lineNumber(lineNumber),
						_columnNumber(columnNumber),
						_referenceCount(referenceCount),
						_useReferenceCount(FALSE)
{
	if( symbolName )
	{
		if( !(_symbolName = NewString(symbolName)) )
			cerr << "SIMCSymbol(): Fatal Error" << endl;
	}
	else
		_symbolName = NULL;

}


SIMCSymbol::~SIMCSymbol()
{
	if( _symbolName )
		delete []_symbolName;
}

SIMCSymbol::SIMCSymbol(const SIMCSymbol& rhs)
					:	_symbolType(rhs._symbolType),
						_lineNumber(rhs._lineNumber),
						_columnNumber(rhs._columnNumber),
						_referenceCount(rhs._referenceCount)
{
	if( rhs._symbolName )
	{
		if( !(_symbolName = NewString(rhs._symbolName)) )
			cerr << "SIMCSymbol(): Fatal Error" << endl;
	}
	else
		_symbolName = NULL;
	_module = rhs._module;
	_useReferenceCount = rhs._useReferenceCount;
}


BOOL SIMCSymbol::operator == (const SIMCSymbol& rhs) const
{
	if( strcmp(_symbolName, rhs._symbolName) == 0 &&
		strcmp(_module->GetModuleName(), (rhs._module)->GetModuleName()) == 0)
		return TRUE;
	return FALSE;
}

void SIMCSymbol::WriteSymbol(ostream& outStream) const
{
	outStream << "SYMBOL(" << _symbolName << 
		"), TYPE(" << int(_symbolType) <<
		"), MODULE(" << ((_module)? _module->GetModuleName() : "NONE") <<
		"), LINE(" << _lineNumber << 
		"), COLUMN(" << _columnNumber <<
		"), REF_COUNT(" << _referenceCount << ")" << endl;
}


void SIMCSymbol::WriteBrief(ostream& outStream) const
{
	outStream << _symbolName << "(";
	if(_module)
		outStream << _module->GetModuleName() ;
	else
		outStream << "<NONE>";
	outStream << ")" << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\parsetree.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "smierrsy.hpp"
#include "smierrsm.hpp"


#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "parser.hpp"
#include "abstractParseTree.hpp"
#include "oidTree.hpp"
#include "parseTree.hpp"

HINSTANCE SIMCParseTree::semanticErrorsDll = NULL ;
const int SIMCParseTree::SEMANTIC_ERROR_BASE = 1000;
const int SIMCParseTree::MESSAGE_SIZE = 1024;

// Just a static function to remove underscores from a fabricated module identitiy name
static void RemoveUnderscores(CString &moduleIdentityName);

void SIMCParseTree::SemanticError(const char * const inputStreamName,
									int errorType, int lineNo,
									int columnNo, ...)
{
	va_list argList;
	va_start(argList, columnNo);
	SIMCErrorMessage e;
	e.SetInputStreamName(inputStreamName);
	e.SetLineNumber(lineNo);
 	e.SetColumnNumber(columnNo);
	e.SetErrorId(SEMANTIC_ERROR_BASE + errorType);

	char message[MESSAGE_SIZE];
	char errorText[MESSAGE_SIZE];
	const char *temp1, *temp2, *temp3, *temp4;

	if(!LoadString(semanticErrorsDll, errorType, errorText, MESSAGE_SIZE))
		cerr << "SIMCParseTree::SemantixError(): Panic, unable to load error "
		<< "string" << endl;

	// Set the severity level as warning for these
	switch(errorType)
	{
		case OBJ_TYPE_SINGULAR_COUNTER:
		case OBJ_TYPE_INDEX_UNNECESSARY:
		case ZERO_IN_OID:
		case IMPORT_UNUSED:
		case ENUM_ZERO_VALUE:
		case KNOWN_REDEFINITION:
		case KNOWN_UNDEFINED:
		case TYPE_UNREFERENCED:
		case VALUE_UNREFERENCED:
		case OBJ_TYPE_DEFVAL_NET_ADDR:
		case OBJ_TYPE_ACCESSIBLE_TABLE:
		case OBJ_TYPE_ACCESSIBLE_ROW:
		case IMPORT_KNOWN_WRONG_MODULE:
		case IR_MODULE_MISSING_WARNING:
		case IR_SYMBOL_MISSING_WARNING:
		case STANDARD_AMBIGUOUS_REFERENCE:
		case MODULE_NO_GROUPS_V1:
		case MODULE_NO_GROUPS_V2:
		case IMPLIED_USELESS:
		case OBJ_TYPE_DUPLICATE_OID: 			
		{
				e.SetSeverityLevel(WARNING);
				e.SetSeverityString("Warning");
				_warningCount++;
		}
		break;
		default:
		{
			e.SetSeverityLevel(FATAL);
			e.SetSeverityString("Fatal");
			_fatalCount++;
		}
		break;
	}

	switch(errorType)
	{
		case OBJ_TYPE_INDEX_UNNECESSARY: 
		case OBJ_TYPE_INVALID_DEFVAL: 
		case OBJ_TYPE_SYNTAX_RESOLUTION:
		case OBJ_TYPE_ACCESSIBLE_TABLE: 
		case OBJ_TYPE_ACCESSIBLE_ROW:
		case OBJ_TYPE_DEFVAL_NET_ADDR:
		case OBJ_TYPE_DEFVAL_DISALLOWED:
		case OBJ_TYPE_DEFVAL_RESOLUTION:
		case ZERO_IN_OID:
		case OID_NEGATIVE_INTEGER: 
		case ENUM_ZERO_VALUE: 
		case SIZE_INVALID_VALUE: 
		case SIZE_INVALID_BOUNDS:
		case RANGE_INVALID_BOUNDS:
		case RANGE_NEGATIVE_GAUGE:
		case SUBTYPE_ROOT_RESOLUTION:
		case INTEGER_TOO_BIG:
		case VALUE_ASSIGN_ENUM_INVALID:
		case IMPLIED_USELESS:
		case IMPLIED_FIXED_SIZE:
		case IMPLIED_POSSIBLE_ZERO_SIZE:
		case V1_ENUM_ONLY_INTEGER:
		case V2_ENUM_ROOT_RESOLUTION:
		case V2_ENUM_CLOSURE:
		case V2_BITS_ROOT_RESOLUTION:
		case ENUM_OR_BITS_RESOLUTION:
		case RANGE_BIG_RANGE:
			sprintf(message, errorText);
			break;
		case OBJ_TYPE_SINGULAR_COUNTER: 
		case OBJ_TYPE_INVALID_ACCESS: 
		case OBJ_TYPE_INVALID_STATUS: 
		case OBJ_TYPE_SEQUENCE_NO_INDEX: 
		case OBJ_TYPE_SEQUENCE_MULTI_REFERENCE: 
		case OBJ_TYPE_SEQUENCE_UNUSED: 
		case OBJ_TYPE_INDEX_RESOLUTION:
		case OBJ_TYPE_INDEX_SYNTAX:
		case SEQUENCE_ITEM_NO_OBJECT:
		case SEQUENCE_TYPE_UNRESOLVED:
		case INVALID_SEQUENCE_OF: 
		case TRAP_TYPE_ENTERPRISE_RESOLUTION: 
		case TRAP_TYPE_VALUE_RESOLUTION: 
		case TRAP_TYPE_VARIABLES_RESOLUTION: 
		case OID_RESOLUTION: 
		case OID_HEAD_ERROR: 
		case IMPORT_UNUSED: 
		case IMPORT_MODULE_ABSENT: 
		case IMPORT_CURRENT: 
		case ENUM_DUPLICATE_VALUE: 
		case ENUM_DUPLICATE_NAME: 
		case ENUM_RESOLUTION: 
		case SIZE_TYPE_RESOLUTION: 
		case RANGE_TYPE_RESOLUTION: 
		case SIZE_VALUE_RESOLUTION: 
		case RANGE_VALUE_RESOLUTION: 
		case SYMBOL_REDEFINITION: 
		case KNOWN_UNDEFINED: 
		case VALUE_ASSIGN_MISMATCH:
		case VALUE_ASSIGN_INVALID:
		case VALUE_ASSIGN_NEGATIVE_INTEGER:
		case SYMBOL_UNDEFINED: 
		case IMPORT_AMBIGUOUS_REFERENCE:
		case TYPE_UNRESOLVED:
		case VALUE_UNRESOLVED:
		case OBJ_TYPE_SEQUENCE_NO_PARENT:
		case MODULE_NO_GROUPS_V1:
		case MODULE_NO_GROUPS_V2:
		case INVALID_BIT_VALUE:
		case AUGMENTS_CLAUSE_RESOLUTION:
		case BITS_VALUE_RESOLUTION:
		case BITS_DUPLICATE_VALUE:
		case BITS_DUPLICATE_NAME:
		case NOTIFICATION_TYPE_INVALID_STATUS: 
		case OBJECT_IDENTITY_VALUE_RESOLUTION:
		case NOTIFICATION_TYPE_VALUE_RESOLUTION:
		case NOTIFICATION_TYPE_OBJECTS_RESOLUTION: 
		case NOTIFICATION_TYPE_UNACCESSIBLE_OBJECT:
			temp1 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1);
			break;
		case TYPE_UNREFERENCED: 	   // Special cases, since the type/value name may be
		case VALUE_UNREFERENCED:		// a compiler generated name
			temp1 = va_arg(argList, const char *);
			if(*temp1 == '*')
				temp1 = "";
			else
				sprintf(message, errorText, temp1);
			break;
		case OBJ_TYPE_SEQUENCE_INVALID_SYNTAX: 
		case OBJ_TYPE_OID_RESOLUTION:
		case TRAP_TYPE_DUPLICATE_VALUES: 
		case VALUE_ASSIGN_RESOLUTION: 
		case IMPORT_SYMBOL_ABSENT: 
		case IMPORT_KNOWN_WRONG_MODULE: 
		case KNOWN_REDEFINITION:
		case IR_SYMBOL_MISSING_FATAL:
		case IR_SYMBOL_MISSING_WARNING:
		case STANDARD_AMBIGUOUS_REFERENCE:
		case IR_MODULE_MISSING_FATAL:
		case IR_MODULE_MISSING_WARNING:
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1, temp2);
			break;
		case SEQUENCE_WRONG_CHILD:
		case OBJ_TYPE_PRIMITIVE_CHILD:
		case OBJ_TYPE_SEQUENCE_CHILD:
		case OBJ_TYPE_SEQUENCE_EXTRA_CHILD:
		case OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD:
		case OBJ_TYPE_SEQUENCE_OF_SYNTAX_MISMATCH:
		case OBJ_TYPE_SEQUENCE_OF_EXTRA_CHILD:
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			temp3 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1, temp2, temp3);
			break;
		case OBJ_TYPE_DUPLICATE_OID: 			
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			temp3 = va_arg(argList, const char *);
			temp4 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1, temp2, temp3, temp4);
			break;
	}
	va_end(argList);

	e.SetMessage(message);
	if(_errorContainer)
		_errorContainer->InsertMessage(e);
}

BOOL SIMCParseTree::ResolveSymbol(SIMCSymbol **symbol, BOOL local)
{
	if(local)
		return TRUE;

	SIMCModule *temp = (*symbol)->GetModule();
	SIMCModule * importedModule = GetModule(temp->GetModuleName());
	if(!importedModule )
	{
		if((*symbol)->GetReferenceCount())
		{
			SemanticError(temp->GetInputFileName(), IR_MODULE_MISSING_FATAL,
				(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(), 
				temp->GetModuleName(),
				(*symbol)->GetSymbolName());
			return FALSE;
		}
		else
		{
			SemanticError(temp->GetInputFileName(), IR_MODULE_MISSING_WARNING,
				(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(), 
				temp->GetModuleName(),
				(*symbol)->GetSymbolName());
			return TRUE;
		}
	}
	
	SIMCSymbol **newRef = importedModule->GetSymbol(
									(*symbol)->GetSymbolName());

	if(!newRef)
	{
		if( (*symbol)->GetReferenceCount())
		{
			SemanticError(temp->GetInputFileName(), IR_SYMBOL_MISSING_FATAL,
				(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
				(*symbol)->GetSymbolName(), temp->GetModuleName());
			return FALSE;
		}
		else
		{
			SemanticError(temp->GetInputFileName(), IR_SYMBOL_MISSING_WARNING,
				(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
				(*symbol)->GetSymbolName(), temp->GetModuleName());
			return TRUE;
		}
	}
	(*newRef)->SetReferenceCount(
					(*newRef)->GetReferenceCount() +
					(*symbol)->GetReferenceCount() ); 
	//delete *symbol;
	(*symbol) = (*newRef);

	return TRUE;
}


BOOL SIMCParseTree::ResolveImportModule(SIMCModule *m, BOOL local)
{

	/* This commented statement is STATEMENT1 */
	if( m->GetSymbolType() == SIMCSymbol::PRIMITIVE)
		return TRUE;
	
	/* This statement is STATEMENT2 for Bug 28014*/
	/*
	if(!GetModule(m->GetModuleName()))
		return TRUE;
		*/

	const char *const moduleName = m->GetModuleName();
	SIMCSymbolTable * table = m->GetSymbolTable();
	POSITION p = table->GetStartPosition();
	SIMCSymbol **s;
	CString name;
	BOOL retVal = TRUE;
	while(p)
	{
		table->GetNextAssoc(p, name, s);
		if( !SIMCParser::IsReservedSymbol(_snmpVersion, (*s)->GetSymbolName(), moduleName ))
			retVal = ResolveSymbol(s, local) && retVal;
	}
	return retVal;
}

BOOL SIMCParseTree::ResolveModule(SIMCModule *m, BOOL local)
{
	SIMCSymbolTable * table = m->GetSymbolTable();
	POSITION p = table->GetStartPosition();
	SIMCSymbol **s;
	CString name;
	BOOL retVal = TRUE;
	while(p)
	{
		table->GetNextAssoc(p, name, s);
		if((*s)->GetSymbolType() == SIMCSymbol::IMPORTED)
			retVal	= ResolveSymbol(s, local) && retVal ;
	}


	// Now, on to the import modules
	SIMCModuleList * importModules = m->GetListOfImportModules();
	p = importModules->GetHeadPosition();
	SIMCModule *nextModule;
	while(p)
	{
		nextModule = importModules->GetNext(p);
		retVal = ResolveImportModule(nextModule, local) && retVal;
	}
	return retVal;
}

BOOL SIMCParseTree::SetResolutionStatus()
{
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	BOOL retVal = TRUE;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		if(!m->SetResolutionStatus())
			retVal = FALSE;
	}
	return retVal;
}

BOOL SIMCParseTree::SetRootAll()
{
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	BOOL retVal = TRUE;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		if(!m->SetRootAll())
			retVal = FALSE;
	}
	return retVal;
}

BOOL SIMCParseTree::SetDefVal()
{
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	BOOL retVal = TRUE;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		if(!m->SetDefVal())
			retVal = FALSE;
	}
	return retVal;
}


BOOL SIMCParseTree::Resolve(BOOL local)
{
	// This function can be called from any state of the parse tree
	if( _parseTreeState == EMPTY)
		return TRUE;
	
	// If you can't report semantic errors, what's the point?
	if(!semanticErrorsDll)
	{
		cerr << "Resolve(): FATAL ERROR smierrsm.dll not found" <<
			endl;
		return FALSE;
	}

	// Do for all modules in the list
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	BOOL retVal = TRUE;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		retVal= ResolveModule(m, local) && retVal;
	}

	SetResolutionStatus();
	SetRootAll();
	SetDefVal();


	// The state of the parse tree has to be set
	if(retVal)
	{
		if (_parseTreeState == UNRESOLVED)
			_parseTreeState = UNCHECKED;
	}
	return retVal;
}

BOOL SIMCParseTree::CheckRangeTypeV1( const char *const fileName,
			SIMCRangeType *rangeType, BOOL local)
{

	switch(rangeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*rangeType->GetType())->GetSymbolName()
				); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
					rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
					(*rangeType->GetType())->GetSymbolName()
					); 
				return FALSE;
			}
		case RESOLVE_CORRECT:
			break;
	}

	// Come here on RESOLVE_CORRECT in above switch
	BOOL isGauge = FALSE;
	BOOL retVal = TRUE;
	SIMCTypeReference *rootTypeRef = rangeType->GetRootType();
	SIMCSymbol **tempRootTypeRef = 	(SIMCSymbol **) &rootTypeRef;
	if(SIMCModule::GetSymbolClass(tempRootTypeRef) != 
		SIMCModule::SYMBOL_BUILTIN_TYPE_REF)
	{
		SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
			rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
			(*rangeType->GetType())->GetSymbolName()
			); 
		return FALSE;
	}

	SIMCModule::PrimitiveType x = 
		SIMCModule::GetPrimitiveType(rootTypeRef);

	if(	x != SIMCModule::PRIMITIVE_INTEGER	&&
		x != SIMCModule::PRIMITIVE_GAUGE )
	{
		SIMCSymbol **baseSymbol = rangeType->GetType();
		SemanticError( fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName());
		retVal = FALSE;
	}

	if( x == SIMCModule::PRIMITIVE_GAUGE)
		isGauge = TRUE;

	// Now to check the list of ranges
	const SIMCRangeList * baseList = rangeType->GetListOfRanges();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, RANGE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(isGauge)
		{
			if( item->_upperBound<0 && !item->_isUnsignedU)
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_ubLine, item->_ubColumn);
				retVal = FALSE;
			}
			if( item->_lowerBound<0 && !item->_isUnsignedL)
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_lbLine, item->_lbColumn);
				retVal = FALSE;
			}
		}
	}
	// See if the range fits into 4 bytes
	if(retVal && !CheckRangeRange(baseList))
	{
		retVal = FALSE;
		SemanticError(fileName, RANGE_BIG_RANGE,
				rangeType->GetTypeLine(), rangeType->GetTypeColumn());
	}

	return retVal;
}

BOOL SIMCParseTree::CheckRangeTypeV2( const char *const fileName,
			SIMCRangeType *rangeType, BOOL local)
{

	switch(rangeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*rangeType->GetType())->GetSymbolName()
				); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
					rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
					(*rangeType->GetType())->GetSymbolName()
					); 
				return FALSE;
			}
			break;
		case RESOLVE_CORRECT:
			break;
	}

	// Come here on RESOLVE_CORRECT in above switch
	BOOL isGauge = FALSE;
	BOOL retVal = TRUE;
	SIMCTypeReference *rootTypeRef = rangeType->GetRootType();


	SIMCModule::PrimitiveType x = SIMCModule::GetPrimitiveType(rootTypeRef);
	if(	x != SIMCModule::PRIMITIVE_INTEGER		&&
		x != SIMCModule::PRIMITIVE_INTEGER_32	&&
		x != SIMCModule::PRIMITIVE_UNSIGNED_32	&&
		x != SIMCModule::PRIMITIVE_GAUGE_32		)
	{
		SIMCSymbol **baseSymbol = rangeType->GetType();
		SemanticError( fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName());
		retVal = FALSE;
	}

	if( x == SIMCModule::PRIMITIVE_GAUGE_32)
		isGauge = TRUE;

	// Now to check the list of ranges
	const SIMCRangeList * baseList = rangeType->GetListOfRanges();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, RANGE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(isGauge)
		{
			if( item->_upperBound<0 && !item->_isUnsignedU )
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_ubLine, item->_ubColumn);
				retVal = FALSE;
			}
			if( item->_lowerBound<0 && !item->_isUnsignedL)
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_lbLine, item->_lbColumn);
				retVal = FALSE;
			}
		}
	}
	// See if the range fits into 4 bytes
	if(retVal && !CheckRangeRange(baseList))
	{
		retVal = FALSE;
		SemanticError(fileName, RANGE_BIG_RANGE,
				rangeType->GetTypeLine(), rangeType->GetTypeColumn());
	}


	return retVal;
}

BOOL SIMCParseTree::CheckRangeTypeV0( const char *const fileName,
			SIMCRangeType *rangeType, BOOL local)
{

	switch(rangeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*rangeType->GetType())->GetSymbolName()
				); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
					rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
					(*rangeType->GetType())->GetSymbolName()
					); 
				return FALSE;
			}
			break;
		case RESOLVE_CORRECT:
			break;
	}

	// Come here on RESOLVE_CORRECT in above switch
	BOOL isGauge = FALSE;
	BOOL retVal = TRUE;
	SIMCTypeReference *rootTypeRef = rangeType->GetRootType();


	SIMCModule::PrimitiveType x = SIMCModule::GetPrimitiveType(rootTypeRef);
	if(	x != SIMCModule::PRIMITIVE_INTEGER		&&
		x != SIMCModule::PRIMITIVE_INTEGER_32	&&
		x != SIMCModule::PRIMITIVE_UNSIGNED_32	&&
		x != SIMCModule::PRIMITIVE_GAUGE		&&
		x != SIMCModule::PRIMITIVE_GAUGE_32		)
	{
		SIMCSymbol **baseSymbol = rangeType->GetType();
		SemanticError( fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName());
		retVal = FALSE;
	}

	if( x == SIMCModule::PRIMITIVE_GAUGE_32 ||
		x == SIMCModule::PRIMITIVE_GAUGE	)
		isGauge = TRUE;

	// Now to check the list of ranges
	const SIMCRangeList * baseList = rangeType->GetListOfRanges();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, RANGE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(isGauge)
		{
			if( item->_upperBound<0 && !item->_isUnsignedU )
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_ubLine, item->_ubColumn);
				retVal = FALSE;
			}
			if( item->_lowerBound<0 && !item->_isUnsignedL)
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_lbLine, item->_lbColumn);
				retVal = FALSE;
			}
		}
	}
	// See if the range fits into 4 bytes
	if(retVal && !CheckRangeRange(baseList))
	{
		retVal = FALSE;
		SemanticError(fileName, RANGE_BIG_RANGE,
				rangeType->GetTypeLine(), rangeType->GetTypeColumn());
	}


	return retVal;
}

BOOL SIMCParseTree::CheckRangeRange(const SIMCRangeList *baseList)
{
	// Find the lowest and the highest of all the items
	if(!baseList)
		return TRUE;
	POSITION p = baseList->GetHeadPosition();
	if(!p)
		return TRUE;

	SIMCRangeOrSizeItem *nextItem = baseList->GetNext(p);
	long highest = nextItem->_upperBound, lowest = nextItem->_lowerBound;
	BOOL isUnsignedH = nextItem->_isUnsignedU, isUnsignedL = nextItem->_isUnsignedL;

	while(p)
	{
		nextItem = baseList->GetNext(p);
		if(IsLessThan( nextItem->_lowerBound, nextItem->_isUnsignedL, lowest, isUnsignedL))
		{
			lowest = nextItem->_lowerBound;
			isUnsignedL	= nextItem->_isUnsignedL;
		}

		if(IsLessThan(highest, isUnsignedH, nextItem->_upperBound, nextItem->_isUnsignedU))
		{
			highest = nextItem->_upperBound;
			isUnsignedH = nextItem->_isUnsignedU;
		}
	}

	if(isUnsignedH && (unsigned long)(highest) > (unsigned long)LONG_MAX)
	{
		if(lowest != 0 && !isUnsignedL)
			return FALSE;
	}
	else
		return TRUE;

	return TRUE;
}

BOOL SIMCParseTree::CheckSizeTypeV1(const char *const fileName,
			 SIMCSizeType *sizeType, BOOL local)
{
	switch(sizeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*sizeType->GetType())->GetSymbolName()); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
					sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
					(*sizeType->GetType())->GetSymbolName()); 
				return FALSE;
			}
		case RESOLVE_CORRECT:
			break;
	}

	BOOL retVal = TRUE;

	SIMCTypeReference *root = sizeType->GetRootType();
	SIMCModule::PrimitiveType x = 
		SIMCModule::GetPrimitiveType(root);
	if(	x != SIMCModule::PRIMITIVE_OCTET_STRING		&&
		x != SIMCModule::PRIMITIVE_DISPLAY_STRING	&&
		x != SIMCModule::PRIMITIVE_PHYS_ADDRESS		&&
		x != SIMCModule::PRIMITIVE_OPAQUE )
	{
		SIMCSymbol **baseSymbol = sizeType->GetType();
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName()); 
		retVal = FALSE;
	}

	// Now to check the list of sizes
	const SIMCSizeList * baseList = sizeType->GetListOfSizes();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, SIZE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(item->_upperBound<0  && !item->_isUnsignedU)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if( item->_lowerBound<0 && !item->_isUnsignedU)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_lbLine, item->_lbColumn);
			retVal = FALSE;
		}

	}
	return retVal;
}

BOOL SIMCParseTree::CheckSizeTypeV2(const char *const fileName,
			 SIMCSizeType *sizeType, BOOL local)
{
	switch(sizeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*sizeType->GetType())->GetSymbolName()); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
					sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
					(*sizeType->GetType())->GetSymbolName()); 
				return FALSE;
			}
		case RESOLVE_CORRECT:
			break;
	}

	BOOL retVal = TRUE;

	SIMCTypeReference *root = sizeType->GetRootType();
	SIMCModule::PrimitiveType x = 
		SIMCModule::GetPrimitiveType(root);
	if(	x != SIMCModule::PRIMITIVE_OCTET_STRING		&&
		x != SIMCModule::PRIMITIVE_DISPLAY_STRING	&&
		x != SIMCModule::PRIMITIVE_PHYS_ADDRESS		&&
		x != SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_OPAQUE			&&
		x != SIMCModule::PRIMITIVE_DATE_AND_TIME)
	{
		SIMCSymbol **baseSymbol = sizeType->GetType();
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName()); 
		retVal = FALSE;
	}

	// Now to check the list of sizes
	const SIMCSizeList * baseList = sizeType->GetListOfSizes();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, SIZE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(item->_upperBound<0  && !item->_isUnsignedU)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if( item->_lowerBound<0 && !item->_isUnsignedL)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_lbLine, item->_lbColumn);
			retVal = FALSE;
		}

	}
	return retVal;
}


BOOL SIMCParseTree::CheckSizeTypeV0(const char *const fileName,
			 SIMCSizeType *sizeType, BOOL local)
{
	switch(sizeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*sizeType->GetType())->GetSymbolName()); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
					sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
					(*sizeType->GetType())->GetSymbolName()); 
				return FALSE;
			}
		case RESOLVE_CORRECT:
			break;
	}

	BOOL retVal = TRUE;

	SIMCTypeReference *root = sizeType->GetRootType();
	SIMCModule::PrimitiveType x = 
		SIMCModule::GetPrimitiveType(root);
	if(	x != SIMCModule::PRIMITIVE_OCTET_STRING		&&
		x != SIMCModule::PRIMITIVE_DISPLAY_STRING	&&
		x != SIMCModule::PRIMITIVE_PHYS_ADDRESS		&&
		x != SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_OPAQUE			&&
		x != SIMCModule::PRIMITIVE_DATE_AND_TIME)
	{
		SIMCSymbol **baseSymbol = sizeType->GetType();
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName()); 
		retVal = FALSE;
	}

	// Now to check the list of sizes
	const SIMCSizeList * baseList = sizeType->GetListOfSizes();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, SIZE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(item->_upperBound<0 && !item->_isUnsignedU)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if( item->_lowerBound<0 && !item->_isUnsignedL)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_lbLine, item->_lbColumn);
			retVal = FALSE;
		}

	}
	return retVal;
}


BOOL SIMCParseTree::CheckEnumTypeV1(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL local)
{
	BOOL retVal = TRUE;	
	SIMCNamedNumberList *list = enumType->GetListOfItems();
	if(!list)
		return TRUE;

	switch(enumType->GetStatus())
	{
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			SemanticError(fileName, 
				V1_ENUM_ONLY_INTEGER,
				enumType->GetTypeLine(), enumType->GetTypeColumn());
			return FALSE;
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, 
					V1_ENUM_ONLY_INTEGER,
					enumType->GetTypeLine(), enumType->GetTypeColumn());
				return FALSE;
			}
			else
				return TRUE;

	}

	POSITION pOuter = list->GetHeadPosition(), pInner;
	SIMCNamedNumberItem *current, *later;
	BOOL currentValid;

	while(pOuter)
	{
		current = list->GetNext(pOuter);
		int currentValue, laterValue;
		currentValid = TRUE;
		switch(SIMCModule::IsIntegerValue(current->_value, currentValue))
		{
			case RESOLVE_IMPORT:
				if(local)
					currentValid = FALSE;
				else
				{
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						(*current->_value)->GetSymbolName());
					retVal = FALSE;
					currentValid = FALSE;
				}
				break;
			case RESOLVE_CORRECT:
				if(currentValue == 0 )
				{
					SemanticError(fileName, ENUM_ZERO_VALUE, 
						current->_valueLine, current->_valueColumn);
					retVal = FALSE;
				}
				else if (currentValue < 0 )
				{
					SemanticError(fileName, ENUM_RESOLUTION,
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
				}
				break;
			default:
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
					currentValid = FALSE;
		}

		// Check for duplicate names, duplicate values
		pInner = pOuter;
		while(pInner)
		{
			later = list->GetNext(pInner);
			if(strcmp(current->_name, later->_name) == 0 )
			{
				retVal = FALSE;
				SemanticError(fileName, ENUM_DUPLICATE_NAME, 
					current->_nameLine, current->_nameColumn,
					current->_name);
			}
			if(currentValid)
			{
				switch(SIMCModule::IsIntegerValue(later->_value, laterValue))
				{
					case RESOLVE_CORRECT:
						if( laterValue == currentValue)
						{
							char buffer[20];
							retVal = FALSE;
							SemanticError(fileName, ENUM_DUPLICATE_VALUE,
								later->_valueLine, later->_valueColumn,
								_itoa(laterValue, buffer, 10));
						}
						break;
					default:
						break;
				}
			}
		}
		
	}
	return retVal;
}

BOOL SIMCParseTree::CheckEnumTypeV2(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL local)
{
	BOOL retVal = TRUE;	
	SIMCNamedNumberList *list = enumType->GetListOfItems();
	if(!list)
		return TRUE;

	switch(enumType->GetStatus())
	{
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			SemanticError(fileName, 
				V2_ENUM_ROOT_RESOLUTION,
				enumType->GetTypeLine(), enumType->GetTypeColumn());
			return FALSE;
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, 
					V2_ENUM_ROOT_RESOLUTION,
					enumType->GetTypeLine(), enumType->GetTypeColumn());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_CORRECT:
		// See if it resolves to an allowed type for enumeration
		{
			SIMCTypeReference *tRef = enumType->GetRootType();
			SIMCSymbol **tempTRef = (SIMCSymbol**)&tRef;
			switch(SIMCModule::GetSymbolClass(tempTRef))
			{
				case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
				{
					SIMCType *type = ((SIMCBuiltInTypeReference *)tRef)->GetType();
					switch(SIMCModule::GetTypeClass(type))
					{
						case SIMCModule::TYPE_PRIMITIVE:
							if(SIMCModule::GetPrimitiveType(tRef->GetSymbolName()) != SIMCModule::PRIMITIVE_INTEGER)
							{
								SemanticError(fileName, 
									V2_ENUM_ROOT_RESOLUTION,
									enumType->GetTypeLine(), enumType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						case SIMCModule::TYPE_ENUM_OR_BITS:
							if(!enumType->CheckClosure((SIMCEnumOrBitsType *)type))
							{
								SemanticError(fileName, 
									V2_ENUM_CLOSURE,
									enumType->GetTypeLine(), enumType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						default:
							SemanticError(fileName, 
								V2_ENUM_ROOT_RESOLUTION,
								enumType->GetTypeLine(), enumType->GetTypeColumn());
							return FALSE;
					}
				}
				break;
				default:
					SemanticError(fileName, 
						V2_ENUM_ROOT_RESOLUTION,
						enumType->GetTypeLine(), enumType->GetTypeColumn());
					return FALSE;
			}

		}
	}


	POSITION pOuter = list->GetHeadPosition(), pInner;
	SIMCNamedNumberItem *current, *later;
	BOOL currentValid;

	while(pOuter)
	{
		current = list->GetNext(pOuter);
		int currentValue, laterValue;
		currentValid = TRUE;
		switch(SIMCModule::IsIntegerValue(current->_value, currentValue))
		{
			case RESOLVE_IMPORT:
				if(local)
					currentValid = FALSE;
				else
				{
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						(*current->_value)->GetSymbolName());
					retVal = FALSE;
					currentValid = FALSE;
				}
				break;
			case RESOLVE_CORRECT:
				if(currentValue == 0 )
				{
					SemanticError(fileName, ENUM_ZERO_VALUE, 
						current->_valueLine, current->_valueColumn);
					retVal = FALSE;
				}
				else if (currentValue < 0 )
				{
					SemanticError(fileName, ENUM_RESOLUTION,
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
				}
				break;
			default:
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
					currentValid = FALSE;
		}

		// Check for duplicate names, duplicate values
		pInner = pOuter;
		while(pInner)
		{
			later = list->GetNext(pInner);
			if(strcmp(current->_name, later->_name) == 0 )
			{
				retVal = FALSE;
				SemanticError(fileName, ENUM_DUPLICATE_NAME, 
					current->_nameLine, current->_nameColumn,
					current->_name);
			}
			if(currentValid)
			{
				switch(SIMCModule::IsIntegerValue(later->_value, laterValue))
				{
					case RESOLVE_CORRECT:
						if( laterValue == currentValue)
						{
							char buffer[20];
							retVal = FALSE;
							SemanticError(fileName, ENUM_DUPLICATE_VALUE,
								later->_valueLine, later->_valueColumn,
								_itoa(laterValue, buffer, 10));
						}
						break;
					default:
						break;
				}
			}
		}
		
	}
	return retVal;
}

BOOL SIMCParseTree::CheckEnumTypeV0(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL local)
{
	BOOL retVal = TRUE;	
	SIMCNamedNumberList *list = enumType->GetListOfItems();
	if(!list)
		return TRUE;

	switch(enumType->GetStatus())
	{
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			SemanticError(fileName, 
				V2_ENUM_ROOT_RESOLUTION,
				enumType->GetTypeLine(), enumType->GetTypeColumn());
			return FALSE;
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, 
					V2_ENUM_ROOT_RESOLUTION,
					enumType->GetTypeLine(), enumType->GetTypeColumn());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_CORRECT:
		// See if it resolves to an allowed type for enumeration
		{
			SIMCTypeReference *tRef = enumType->GetRootType();
			SIMCSymbol **tempTRef = (SIMCSymbol**)&tRef;
			switch(SIMCModule::GetSymbolClass(tempTRef))
			{
				case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
				{
					SIMCType *type = ((SIMCBuiltInTypeReference *)tRef)->GetType();
					switch(SIMCModule::GetTypeClass(type))
					{
						case SIMCModule::TYPE_PRIMITIVE:
							if(SIMCModule::GetPrimitiveType(tRef->GetSymbolName()) != SIMCModule::PRIMITIVE_INTEGER)
							{
								SemanticError(fileName, 
									V2_ENUM_ROOT_RESOLUTION,
									enumType->GetTypeLine(), enumType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						case SIMCModule::TYPE_ENUM_OR_BITS:
							if(!enumType->CheckClosure((SIMCEnumOrBitsType *)type))
							{
								SemanticError(fileName, 
									V2_ENUM_CLOSURE,
									enumType->GetTypeLine(), enumType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						default:
							SemanticError(fileName, 
								V2_ENUM_ROOT_RESOLUTION,
								enumType->GetTypeLine(), enumType->GetTypeColumn());
							return FALSE;
					}
				}
				break;
				default:
					SemanticError(fileName, 
						V2_ENUM_ROOT_RESOLUTION,
						enumType->GetTypeLine(), enumType->GetTypeColumn());
					return FALSE;
			}

		}
	}


	POSITION pOuter = list->GetHeadPosition(), pInner;
	SIMCNamedNumberItem *current, *later;
	BOOL currentValid;

	while(pOuter)
	{
		current = list->GetNext(pOuter);
		int currentValue, laterValue;
		currentValid = TRUE;
		switch(SIMCModule::IsIntegerValue(current->_value, currentValue))
		{
			case RESOLVE_IMPORT:
				if(local)
					currentValid = FALSE;
				else
				{
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						(*current->_value)->GetSymbolName());
					retVal = FALSE;
					currentValid = FALSE;
				}
				break;
			case RESOLVE_CORRECT:
				if(currentValue == 0 )
				{
					SemanticError(fileName, ENUM_ZERO_VALUE, 
						current->_valueLine, current->_valueColumn);
					retVal = FALSE;
				}
				else if (currentValue < 0 )
				{
					SemanticError(fileName, ENUM_RESOLUTION,
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
				}
				break;
			default:
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
					currentValid = FALSE;
		}

		// Check for duplicate names, duplicate values
		pInner = pOuter;
		while(pInner)
		{
			later = list->GetNext(pInner);
			if(strcmp(current->_name, later->_name) == 0 )
			{
				retVal = FALSE;
				SemanticError(fileName, ENUM_DUPLICATE_NAME, 
					current->_nameLine, current->_nameColumn,
					current->_name);
			}
			if(currentValid)
			{
				switch(SIMCModule::IsIntegerValue(later->_value, laterValue))
				{
					case RESOLVE_CORRECT:
						if( laterValue == currentValue)
						{
							char buffer[20];
							retVal = FALSE;
							SemanticError(fileName, ENUM_DUPLICATE_VALUE,
								later->_valueLine, later->_valueColumn,
								_itoa(laterValue, buffer, 10));
						}
						break;
					default:
						break;
				}
			}
		}
		
	}
	return retVal;
}

BOOL SIMCParseTree::CheckBitsTypeV2(const char *const fileName,
			SIMCEnumOrBitsType *bitsType, BOOL local)
{
	BOOL retVal = TRUE;	
	SIMCNamedNumberList *list = bitsType->GetListOfItems();
	if(!list)
		return TRUE;

	switch(bitsType->GetStatus())
	{
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			SemanticError(fileName, 
				V2_BITS_ROOT_RESOLUTION,
				bitsType->GetTypeLine(), bitsType->GetTypeColumn());
			return FALSE;
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, 
					V2_BITS_ROOT_RESOLUTION,
					bitsType->GetTypeLine(), bitsType->GetTypeColumn());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_CORRECT:
		// See if it resolves to an allowed type for enumeration
		{
			SIMCTypeReference *tRef = bitsType->GetRootType();
			SIMCSymbol **tempTRef = (SIMCSymbol**)&tRef;
			switch(SIMCModule::GetSymbolClass(tempTRef))
			{
				case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
				{
					SIMCType *type = ((SIMCBuiltInTypeReference *)tRef)->GetType();
					switch(SIMCModule::GetTypeClass(type))
					{
						case SIMCModule::TYPE_PRIMITIVE:
							if(SIMCModule::GetPrimitiveType(tRef->GetSymbolName()) != SIMCModule::PRIMITIVE_BITS)
							{
								SemanticError(fileName, 
									V2_BITS_ROOT_RESOLUTION,
									bitsType->GetTypeLine(), bitsType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						case SIMCModule::TYPE_ENUM_OR_BITS:
							if(!bitsType->CheckClosure((SIMCEnumOrBitsType *)type))
							{
								SemanticError(fileName, 
									V2_BITS_ROOT_RESOLUTION,
									bitsType->GetTypeLine(), bitsType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						default:
							SemanticError(fileName, 
								V2_BITS_ROOT_RESOLUTION,
								bitsType->GetTypeLine(), bitsType->GetTypeColumn());
							return FALSE;
					}
				}
				break;
				default:
					SemanticError(fileName, 
						V2_BITS_ROOT_RESOLUTION,
						bitsType->GetTypeLine(), bitsType->GetTypeColumn());
					return FALSE;
			}
		}
	}


	POSITION pOuter = list->GetHeadPosition(), pInner;
	SIMCNamedNumberItem *current, *later;
	BOOL currentValid;

	while(pOuter)
	{
		current = list->GetNext(pOuter);
		int currentValue, laterValue;
		currentValid = TRUE;
		switch(SIMCModule::IsIntegerValue(current->_value, currentValue))
		{
			case RESOLVE_IMPORT:
				if(local)
					currentValid = FALSE;
				else
				{
					SemanticError(fileName, BITS_VALUE_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						(*current->_value)->GetSymbolName());
					retVal = FALSE;
					currentValid = FALSE;
				}
				break;
			case RESOLVE_CORRECT:
				if (currentValue < 0 )
				{
					SemanticError(fileName, BITS_VALUE_RESOLUTION,
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
				}
				break;
			default:
				SemanticError(fileName, BITS_VALUE_RESOLUTION, 
					current->_valueLine, current->_valueColumn, 
					current->_name);
				retVal = FALSE;
				currentValid = FALSE;
		}

		// Check for duplicate names, duplicate values
		pInner = pOuter;
		while(pInner)
		{
			later = list->GetNext(pInner);
			if(strcmp(current->_name, later->_name) == 0 )
			{
				retVal = FALSE;
				SemanticError(fileName, BITS_DUPLICATE_NAME, 
					current->_nameLine, current->_nameColumn,
					current->_name);
			}
			if(currentValid)
			{
				switch(SIMCModule::IsIntegerValue(later->_value, laterValue))
				{
					case RESOLVE_CORRECT:
						if( laterValue == currentValue)
						{
							char buffer[20];
							retVal = FALSE;
							SemanticError(fileName, BITS_DUPLICATE_VALUE,
								later->_valueLine, later->_valueColumn,
								_itoa(laterValue, buffer, 10));
						}
						break;
					default:
						break;
				}
			}
		}
		
	}
	return retVal;
}

BOOL SIMCParseTree::CheckSequenceOfType(const char *const fileName,
			SIMCSequenceOfType *sequenceOfType, BOOL local)
{
	return TRUE;
}

BOOL SIMCParseTree::CheckSequenceType(const char *const fileName,
			SIMCSequenceType *sequenceOfType, BOOL local)
{
	return TRUE;
}


BOOL SIMCParseTree::CheckObjectSequenceOfTypeV1(const char *const fileName,
			SIMCObjectTypeV1 *objType,
			SIMCSequenceOfType *sequenceOfType, 
			BOOL local)
{
	SIMCIndexList *indexList = objType->GetIndexTypes();
	if(indexList && !indexList->IsEmpty())
			SemanticError(fileName, OBJ_TYPE_INDEX_UNNECESSARY,
				objType->GetIndexLine(), objType->GetIndexColumn());

	if( objType->GetAccess() != SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE)
		SemanticError(fileName, OBJ_TYPE_ACCESSIBLE_TABLE,
			objType->GetAccessLine(), objType->GetAccessColumn());

	SIMCSymbol **sequenceSymbol = sequenceOfType->GetType();
	SIMCTypeReference *btRef;
	switch(SIMCModule::IsTypeReference(sequenceSymbol, btRef))
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, INVALID_SEQUENCE_OF,
					sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
					(*sequenceSymbol)->GetSymbolName());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
				SemanticError(fileName, INVALID_SEQUENCE_OF,
					sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
					(*sequenceSymbol)->GetSymbolName());
			return FALSE;
	}

	SIMCSymbol **tempBtRef = (SIMCSymbol **)&btRef;
	switch(SIMCModule::GetSymbolClass(tempBtRef) )
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(SIMCModule::GetTypeClass(((SIMCBuiltInTypeReference*)btRef)->GetType()))
			{
				case SIMCModule::TYPE_SEQUENCE:
					return TRUE;
				default:
					SemanticError(fileName, INVALID_SEQUENCE_OF,
						sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
						(*sequenceSymbol)->GetSymbolName());
					return FALSE;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			SemanticError(fileName, INVALID_SEQUENCE_OF,
				sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
				(*sequenceSymbol)->GetSymbolName());
			return FALSE;
		}
		break;
	}
	return FALSE;
}

BOOL SIMCParseTree::CheckObjectSequenceOfTypeV2(const char *const fileName,
			SIMCObjectTypeV2 *objType,
			SIMCSequenceOfType *sequenceOfType, 
			BOOL local)
{
	SIMCIndexListV2 *indexList = objType->GetIndexTypes();
	if((indexList && !indexList->IsEmpty()) || objType->GetAugments())
			SemanticError(fileName, OBJ_TYPE_INDEX_UNNECESSARY,
				objType->GetIndexLine(), objType->GetIndexColumn());

	if( objType->GetAccess() != SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE)
		SemanticError(fileName, OBJ_TYPE_ACCESSIBLE_TABLE,
			objType->GetAccessLine(), objType->GetAccessColumn());

	SIMCSymbol **sequenceSymbol = sequenceOfType->GetType();
	SIMCTypeReference *typeRef;
	switch(SIMCModule::IsTypeReference(sequenceSymbol, typeRef))
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, INVALID_SEQUENCE_OF,
					sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
					(*sequenceSymbol)->GetSymbolName());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
				SemanticError(fileName, INVALID_SEQUENCE_OF,
					sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
					(*sequenceSymbol)->GetSymbolName());
			return FALSE;
	}
	SIMCSymbol **tempTypeRef = (SIMCSymbol **)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(SIMCModule::GetTypeClass(((SIMCBuiltInTypeReference*)typeRef)->GetType()))
			{
				case SIMCModule::TYPE_SEQUENCE:
					return TRUE;
				default:
					SemanticError(fileName, INVALID_SEQUENCE_OF,
						sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
						(*sequenceSymbol)->GetSymbolName());
					return FALSE;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			SemanticError(fileName, INVALID_SEQUENCE_OF,
				sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
				(*sequenceSymbol)->GetSymbolName());
			return FALSE;
		}
		break;
	}
	return FALSE;
}

BOOL SIMCParseTree::CheckObjectSequenceTypeV1(const char *const fileName,
			SIMCObjectTypeV1 *objType,
			SIMCSequenceType *sequenceType, 
			BOOL local)
{
	if( objType->GetAccess() != SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE)
		SemanticError(fileName, OBJ_TYPE_ACCESSIBLE_ROW,
			objType->GetAccessLine(), objType->GetAccessColumn());
	return TRUE;
}

BOOL SIMCParseTree::CheckObjectSequenceTypeV2(const char *const fileName,
			SIMCObjectTypeV2 *objType,
			SIMCSequenceType *sequenceType, 
			BOOL local)
{
	if( objType->GetAccess() != SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE)
		SemanticError(fileName, OBJ_TYPE_ACCESSIBLE_ROW,
			objType->GetAccessLine(), objType->GetAccessColumn());
	return TRUE;
}

BOOL SIMCParseTree::CheckObjectTypeDefVal(const char *const fileName,
			SIMCObjectTypeType *objectType, BOOL local)
{

	switch(objectType->GetDefValStatus())
	{
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
					objectType->GetDefValLine(), objectType->GetDefValColumn());
				return FALSE;
			}
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
				SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
					objectType->GetDefValLine(), objectType->GetDefValColumn());
			return FALSE;
	}
	
	SIMCSymbol **defVal = objectType->GetDefVal();

	// First Get the type in the Syntax clause
	SIMCSymbol **syntax = objectType->GetSyntax();
	SIMCTypeReference *typeRef;

	switch(SIMCModule::IsTypeReference(syntax, typeRef))
	{
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
				return FALSE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			return FALSE;
	}

	SIMCModule::TypeClass syntaxType = SIMCModule::TYPE_INVALID;
	SIMCModule::PrimitiveType syntaxRootType = SIMCModule::PRIMITIVE_INVALID;
	SIMCType *type = NULL;
	SIMCEnumOrBitsType *enumType = NULL;
	SIMCRangeType *rangeType = NULL;
	SIMCSizeType *sizeType = NULL;
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol **)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			syntaxRootType = SIMCModule::GetPrimitiveType(typeRef->GetSymbolName());
			syntaxType = SIMCModule::TYPE_PRIMITIVE;
			break;
	}
	 

	if(type)
	{
		switch(syntaxType = SIMCModule::GetTypeClass(type))
		{
			case SIMCModule::TYPE_PRIMITIVE:
			{
				syntaxRootType = SIMCModule::GetPrimitiveType(typeRef->GetSymbolName());
				switch(syntaxRootType)
				{
					case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
						if(defVal)
							SemanticError(fileName, OBJ_TYPE_DEFVAL_NET_ADDR,
								objectType->GetDefValLine(), objectType->GetDefValColumn()
								);
						return TRUE;
					case SIMCModule::PRIMITIVE_INVALID:
						return FALSE;
				}
			}
			break;
			case SIMCModule::TYPE_SIZE:
			case SIMCModule::TYPE_RANGE:
			{
				switch( ((SIMCSubType*)type)->GetStatus())
				{
					case RESOLVE_IMPORT:
						if(local)
							return TRUE;
						else
							return FALSE;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						return FALSE;
					case RESOLVE_CORRECT:
					{
						SIMCTypeReference * subTypeRoot = 
							((SIMCSubType*)type)->GetRootType();
						syntaxRootType = SIMCModule::GetPrimitiveType(subTypeRoot);
					}
					break;
				}
			}
			break;
			case SIMCModule::TYPE_ENUM_OR_BITS:
				switch(((SIMCEnumOrBitsType *)type)->GetEnumOrBitsType())
				{
					case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
						syntaxRootType = SIMCModule::PRIMITIVE_INTEGER;
						break;
					case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
						syntaxRootType = SIMCModule::PRIMITIVE_BITS;
						break;
					case SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT:
						if(local)
							return TRUE;
						else
							return FALSE;
					default:
						return FALSE;
				}
				break;
			case SIMCModule::TYPE_INVALID:
			case SIMCModule::TYPE_TRAP_TYPE:
			case SIMCModule::TYPE_NOTIFICATION_TYPE:
			case SIMCModule::TYPE_OBJECT_TYPE_V1:
			case SIMCModule::TYPE_OBJECT_TYPE_V2:
			case SIMCModule::TYPE_OBJECT_IDENTITY:
				return FALSE;
			case SIMCModule::TYPE_SEQUENCE:
			case SIMCModule::TYPE_SEQUENCE_OF:
				if(defVal)
				{
					SemanticError(fileName, OBJ_TYPE_DEFVAL_DISALLOWED,
						objectType->GetDefValLine(), objectType->GetDefValColumn());
					return FALSE;
				}
				break;
		}

		switch(syntaxType)
		{
			case SIMCModule::TYPE_ENUM_OR_BITS:
				enumType = (SIMCEnumOrBitsType *)type;
				break;
			case SIMCModule::TYPE_RANGE:
				rangeType = (SIMCRangeType *)type;
				break;
			case SIMCModule::TYPE_SIZE:
				sizeType = (SIMCSizeType *)type;
				break;
		}
	}
	
	// Now you have the root type of syntax clause in syntaxRootType

	if(defVal) // This should have been set at the latest by SIMCParseTree::SetDefVal()
	{
		SIMCBuiltInValueReference *bValueRef;
		SIMCSymbol **defValueType;
		switch(SIMCModule::IsValueReference(defVal, defValueType, bValueRef ))
		{
			case RESOLVE_IMPORT:
				if(!local)
				{
					SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
						objectType->GetDefValLine(), objectType->GetDefValColumn());
					return FALSE;
				}
				else
					return TRUE;
				break;
			case RESOLVE_UNDEFINED:
			case RESOLVE_UNSET:
				SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
					objectType->GetDefValLine(), objectType->GetDefValColumn());
				return FALSE;
		}

		SIMCValue *value = bValueRef->GetValue(); 

		switch(SIMCModule::GetValueClass(value))
		{
			case SIMCModule::VALUE_INVALID:
			case SIMCModule::VALUE_BOOLEAN:
				SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
					objectType->GetDefValLine(), objectType->GetDefValColumn());
				return FALSE;

			case SIMCModule::VALUE_NULL:
				if(syntaxRootType != SIMCModule::PRIMITIVE_NULL)
				{
					SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
						objectType->GetDefValLine(), objectType->GetDefValColumn());
					return FALSE;
				}
				return TRUE;

			case SIMCModule::VALUE_OID:
				if(syntaxRootType != SIMCModule::PRIMITIVE_OID)
				{
					SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
						objectType->GetDefValLine(), objectType->GetDefValColumn());
					return FALSE;
				}
				return TRUE;
	
			case SIMCModule::VALUE_OCTET_STRING:
				switch(syntaxType)
				{
					case SIMCModule::TYPE_PRIMITIVE:
						switch(syntaxRootType)
						{
							case SIMCModule::PRIMITIVE_OCTET_STRING:
							case SIMCModule::PRIMITIVE_DISPLAY_STRING:
							case SIMCModule::PRIMITIVE_OPAQUE:
							case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
							case SIMCModule::PRIMITIVE_MAC_ADDRESS:
							case SIMCModule::PRIMITIVE_DATE_AND_TIME:
							case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
							case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:
							case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:
								return TRUE;

							case SIMCModule::PRIMITIVE_INTEGER:
							case SIMCModule::PRIMITIVE_UNSIGNED_32:
							case SIMCModule::PRIMITIVE_INTEGER_32:
							case SIMCModule::PRIMITIVE_IP_ADDRESS:
							case SIMCModule::PRIMITIVE_COUNTER:
							case SIMCModule::PRIMITIVE_GAUGE:
							case SIMCModule::PRIMITIVE_TIME_TICKS:
							case SIMCModule::PRIMITIVE_COUNTER_32:
							case SIMCModule::PRIMITIVE_COUNTER_64:
							case SIMCModule::PRIMITIVE_GAUGE_32:
							{
								SIMCOctetStringValue *octetValue = (SIMCOctetStringValue *)value;
								if(octetValue->GetNumberOfOctets() > 4)
								{
									SemanticError(fileName, INTEGER_TOO_BIG,
										value->GetLine(), value->GetColumn());
									return FALSE;
								}
							}

							return TRUE;
							default:
								SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
									objectType->GetDefValLine(), objectType->GetDefValColumn());
								return FALSE;
						}
					case SIMCModule::TYPE_RANGE:
					case SIMCModule::TYPE_ENUM_OR_BITS:
						SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
							objectType->GetDefValLine(), objectType->GetDefValColumn());
						return FALSE;
					case SIMCModule::TYPE_SIZE:
						return TRUE;
				}
			break;
			case SIMCModule::VALUE_BITS:
				switch(syntaxType)
				{
					case SIMCModule::TYPE_ENUM_OR_BITS:
					{
						// Check whether all the bit identifiers are valid
						SIMCBitValue *bitValue;
						const SIMCBitValueList * valueList = ((SIMCBitsValue *)value)->GetValueList();
						POSITION p = valueList->GetHeadPosition();
						SIMCEnumOrBitsType *bitsType = (SIMCEnumOrBitsType *)type;
						while(p)
						{
							bitValue = valueList->GetNext(p);
							if(! bitsType->GetValue(bitValue->_name) )
							{
								SemanticError(fileName, INVALID_BIT_VALUE,
									bitValue->_line, bitValue->_column,
									bitValue->_name);
								return FALSE;
							}
						}
						return TRUE;
					}
					default:
						SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
							objectType->GetDefValLine(), objectType->GetDefValColumn());
						return FALSE;
				}
				break;

			case SIMCModule::VALUE_INTEGER:
				switch(syntaxType)
				{
					case SIMCModule::TYPE_PRIMITIVE:
						switch(syntaxRootType)
						{
							case SIMCModule::PRIMITIVE_INTEGER:
							case SIMCModule::PRIMITIVE_INTEGER_32:
								return TRUE;
							case SIMCModule::PRIMITIVE_COUNTER:
							case SIMCModule::PRIMITIVE_GAUGE:
							case SIMCModule::PRIMITIVE_TIME_TICKS:
							case SIMCModule::PRIMITIVE_GAUGE_32:
							case SIMCModule::PRIMITIVE_UNSIGNED_32:
							case SIMCModule::PRIMITIVE_COUNTER_32:
							case SIMCModule::PRIMITIVE_COUNTER_64:
								if( ((SIMCIntegerValue*)value)->GetIntegerValue() < 0 )
								{
									if(!((SIMCIntegerValue*)value)->IsUnsigned())
										/*
 									{
										SemanticError(fileName, INTEGER_TOO_BIG,
											objectType->GetDefValLine(), objectType->GetDefValColumn());
										return FALSE;
									}
									else
									*/
									{
										SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
											objectType->GetDefValLine(), objectType->GetDefValColumn());
										return FALSE;
									}
								}
								return TRUE;
							default:
								SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
									objectType->GetDefValLine(), objectType->GetDefValColumn());
								return FALSE;
						}
					case SIMCModule::TYPE_ENUM_OR_BITS:
					{
						char *dummy;
						switch(enumType->GetIdentifier( ((SIMCIntegerValue*)value)->GetIntegerValue(), dummy))
						{
							case RESOLVE_IMPORT:
								if(local)
									return TRUE;
								else
								{
									SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
										objectType->GetDefValLine(), objectType->GetDefValColumn());
									return FALSE;
								}
							case RESOLVE_UNSET:
							case RESOLVE_UNDEFINED:
								SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
									objectType->GetDefValLine(), objectType->GetDefValColumn());
								return FALSE;
						}
						return TRUE;
					}
					case SIMCModule::TYPE_RANGE:
						return TRUE;
					case SIMCModule::TYPE_SIZE:
						SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
							objectType->GetDefValLine(), objectType->GetDefValColumn());
						return FALSE;
				}
		}
	}
	return TRUE;
}
					
	
BOOL SIMCParseTree::CheckObjectTypeV1Index(const char *const fileName,
			SIMCSymbol *objectTypeSymbol,
			SIMCObjectTypeV1 *objectType, BOOL local)
{
	BOOL retVal = TRUE;
	SIMCIndexList * indexList = objectType->GetIndexTypes();
	if(!indexList )
		return TRUE;

	SIMCSymbol **symbol;
	POSITION p = indexList->GetHeadPosition();
	
	SIMCIndexItem *indexItem;
	SIMCTypeReference *typeRef = NULL;
	while(p)
	{
		indexItem = indexList->GetNext(p);
		symbol = indexItem->_item;
		switch(SIMCModule::GetSymbolClass(symbol))
		{
			case SIMCModule::SYMBOL_IMPORT:
				if(local)
					return TRUE;
				else
				{
					SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
						indexItem->_line, indexItem->_column,
						(*symbol)->GetSymbolName()); 
					return FALSE;
				}
			case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
				typeRef = (SIMCTypeReference *)(*symbol); 
				break;			
			case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
			case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
				switch( ((SIMCDefinedTypeReference*)(*symbol))->GetStatus() )
				{
					case RESOLVE_IMPORT:
						if(!local)
						{
							SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
								indexItem->_line, indexItem->_column,
								(*symbol)->GetSymbolName()); 
							return FALSE;
						}
						else
							return TRUE;
						break;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
						return FALSE;
					case RESOLVE_CORRECT:
					{
						typeRef = ((SIMCDefinedTypeReference*)(symbol))->GetRealType();
						break;
					}
				}
				break;
			case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
			case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
			{
				// See if it is an OBJECT-TYPE
				SIMCObjectTypeType *indexObject;
				switch(SIMCModule::IsObjectType(symbol, indexObject))
				{
					case RESOLVE_IMPORT:
						if(!local)
						{
							SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
								indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
							return FALSE;
						}
						else
							return TRUE;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
						return FALSE;
				}
				// Add the current object to the list of objects indexed by "indexObject"
				indexObject->AddIndexedObjectType(objectTypeSymbol);
				SIMCSymbol **objectSyntax = indexObject->GetSyntax();
				switch( SIMCModule::IsTypeReference(objectSyntax, typeRef))
				{
					case RESOLVE_IMPORT:
						if(!local)
						{
							SemanticError(fileName, OBJ_TYPE_INDEX_SYNTAX,
								indexItem->_line, indexItem->_column,
								(*symbol)->GetSymbolName());
							return FALSE;
						}
						else
							return TRUE;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						SemanticError(fileName, OBJ_TYPE_INDEX_SYNTAX,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName());
						return FALSE;
				}
			}
			break;
			default:
				SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
					indexItem->_line, indexItem->_column,
					(*symbol)->GetSymbolName()); 
				return FALSE;
		}


		SIMCSymbol **tempTypeRef = (SIMCSymbol **)&typeRef;
		switch(SIMCModule::GetSymbolClass(tempTypeRef))
		{
			case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			{
				SIMCType *type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
				switch(SIMCModule::GetTypeClass(type))
				{
					case SIMCModule::TYPE_PRIMITIVE:
						if(SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_NULL)
						{
							retVal = FALSE;
							SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
								indexItem->_line, indexItem->_column,
								(*symbol)->GetSymbolName()); 
						}
						break;
					case SIMCModule::TYPE_SIZE:
					case SIMCModule::TYPE_RANGE:
					case SIMCModule::TYPE_ENUM_OR_BITS:
						break;
					case SIMCModule::TYPE_INVALID:
					case SIMCModule::TYPE_TRAP_TYPE:
					case SIMCModule::TYPE_NOTIFICATION_TYPE:
					case SIMCModule::TYPE_OBJECT_TYPE_V1:
					case SIMCModule::TYPE_OBJECT_TYPE_V2:
					case SIMCModule::TYPE_OBJECT_IDENTITY:
					case SIMCModule::TYPE_SEQUENCE:
					case SIMCModule::TYPE_SEQUENCE_OF:
						retVal = FALSE;
						SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
						break;
				}
			}
			break;
			case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			{
				return TRUE;
			}
			break;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckObjectTypeV2Index(const char *const fileName,
			SIMCSymbol *objectTypeSymbol,
			SIMCObjectTypeV2 *objectType, BOOL local)
{
	BOOL retVal = TRUE;
	SIMCSymbol ** augmentsSymbol = objectType->GetAugments();
	if(augmentsSymbol)
	{
		// Check to see if the thing that is augmented is really a table.
		switch(SIMCModule::IsRow(augmentsSymbol))
		{
			case RESOLVE_UNSET:
			case RESOLVE_UNDEFINED:
			{
				SemanticError(fileName, AUGMENTS_CLAUSE_RESOLUTION,
						objectType->GetAugmentsLine(), objectType->GetAugmentsColumn(),
						(*augmentsSymbol)->GetSymbolName());
				return FALSE;
			}
			break;

			case RESOLVE_IMPORT:
				if(local)
					return TRUE;
				else
				{
					SemanticError(fileName, AUGMENTS_CLAUSE_RESOLUTION,
							objectType->GetAugmentsLine(), objectType->GetAugmentsColumn(),
						(*augmentsSymbol)->GetSymbolName());
					return FALSE;
				}
			break;
			case RESOLVE_CORRECT:
				return TRUE;
		}
	}

	SIMCIndexListV2 * indexList = objectType->GetIndexTypes();
	if(!indexList )
		return TRUE;

	SIMCSymbol **symbol;
	POSITION p = indexList->GetHeadPosition();
	
	SIMCIndexItemV2 *indexItem;
	SIMCTypeReference *typeRef = NULL;

	while(p)
	{
		indexItem = indexList->GetNext(p);
		symbol = indexItem->_item;

		switch(SIMCModule::GetSymbolClass(symbol))
		{
			case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
			case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
			{
				// See if it is an OBJECT-TYPE
				SIMCObjectTypeType *indexObject;
				switch(SIMCModule::IsObjectType(symbol, indexObject))
				{
					case RESOLVE_IMPORT:
						if(!local)
						{
							SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
								indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
							return FALSE;
						}
						else
							return TRUE;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
						return FALSE;
				}

				// If it is the IMPLIED object, check its semantics
				if(indexItem->_implied)
				{
					// See if it is the last item in  the list
					if(indexItem != indexList->GetTail())
					{
						SemanticError(fileName, IMPLIED_USELESS,
							indexItem->_line, indexItem->_column);
					}
					else
					{
						// See if it is of fixed size
						switch(SIMCModule::IsFixedSizeObject(indexObject))
						{
							case RESOLVE_UNDEFINED:
							case RESOLVE_UNSET:
							case RESOLVE_CORRECT:
								SemanticError(fileName, IMPLIED_FIXED_SIZE,
									indexItem->_line, indexItem->_column);
								return FALSE;
								break;
							case RESOLVE_IMPORT:
								if(!local)
								{
									SemanticError(fileName, IMPLIED_FIXED_SIZE,
										indexItem->_line, indexItem->_column);
									return FALSE;
								}
								break;
						}

						// See if it's length can be zero
						switch(SIMCModule::IsNotZeroSizeObject(indexObject))
						{
							case RESOLVE_UNDEFINED:
							case RESOLVE_UNSET:
							case RESOLVE_FALSE:
								SemanticError(fileName, IMPLIED_POSSIBLE_ZERO_SIZE,
									indexItem->_line, indexItem->_column);
								return FALSE;
								break;
							case RESOLVE_IMPORT:
								if(!local)
								{
									SemanticError(fileName, IMPLIED_POSSIBLE_ZERO_SIZE,
										indexItem->_line, indexItem->_column);
									return FALSE;
								}
								break;
						}
					}				
				}
				
				// Add the current object to the list of objects indexed by "indexObject"
				indexObject->AddIndexedObjectType(objectTypeSymbol);
				SIMCSymbol **objectSyntax = indexObject->GetSyntax();
				switch( SIMCModule::IsTypeReference(objectSyntax, typeRef))
				{
					case RESOLVE_IMPORT:
						if(!local)
						{
							SemanticError(fileName, OBJ_TYPE_INDEX_SYNTAX,
								indexItem->_line, indexItem->_column,
								(*symbol)->GetSymbolName());
							return FALSE;
						}
						else
							return TRUE;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						SemanticError(fileName, OBJ_TYPE_INDEX_SYNTAX,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName());
						return FALSE;
				}
			}
			break;
			case SIMCModule::SYMBOL_IMPORT:
				if(local)
					return TRUE;
				else
				{
					SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
						indexItem->_line, indexItem->_column,
						(*symbol)->GetSymbolName()); 
					return FALSE;
				}
			default:
				SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
					indexItem->_line, indexItem->_column,
					(*symbol)->GetSymbolName()); 
				return FALSE;
		}


		SIMCSymbol ** tempTypeRef =  (SIMCSymbol **)&typeRef;
		switch(SIMCModule::GetSymbolClass(tempTypeRef))
		{
			case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			{
				SIMCType *type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
				switch(SIMCModule::GetTypeClass(type))
				{
					case SIMCModule::TYPE_PRIMITIVE:
						if(SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_NULL)
						{
							retVal = FALSE;
							SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
								indexItem->_line, indexItem->_column,
								(*symbol)->GetSymbolName()); 
						}
						break;
					case SIMCModule::TYPE_SIZE:
					case SIMCModule::TYPE_RANGE:
					case SIMCModule::TYPE_ENUM_OR_BITS:
						break;
					case SIMCModule::TYPE_INVALID:
					case SIMCModule::TYPE_TRAP_TYPE:
					case SIMCModule::TYPE_NOTIFICATION_TYPE:
					case SIMCModule::TYPE_OBJECT_TYPE_V1:
					case SIMCModule::TYPE_OBJECT_TYPE_V2:
					case SIMCModule::TYPE_OBJECT_IDENTITY:
					case SIMCModule::TYPE_SEQUENCE:
					case SIMCModule::TYPE_SEQUENCE_OF:
						retVal = FALSE;
						SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
						break;
				}
			}
			break;
			case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			{
				return TRUE;
			}
			break;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckObjectTypeV1Syntax(const char *const fileName,
			SIMCObjectTypeV1 *objectType, BOOL local)
{
	SIMCSymbol **syntax = objectType->GetSyntax();
	SIMCTypeReference *typeRef  = NULL;
	SIMCIndexList* indexList = objectType->GetIndexTypes();
	BOOL indexPresent = FALSE;
	if(indexList && !indexList->IsEmpty())
		indexPresent = TRUE;

	switch(SIMCModule::GetSymbolClass(syntax))
	{
		case SIMCModule::SYMBOL_IMPORT:

			if(!local)
			{
				SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
				return FALSE;
			}
			return TRUE;

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF: 
			typeRef = (SIMCBuiltInTypeReference *)(*syntax);
			break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			SIMCDefinedTypeReference * defTypeRef = (SIMCDefinedTypeReference*)(*syntax);
			switch(defTypeRef->GetStatus())
			{
				case RESOLVE_IMPORT:
					if(!local)
					{
						SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
						return FALSE;
					}
					else
						return TRUE;
					break;
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
					return FALSE;
					break;
				case RESOLVE_CORRECT:
					typeRef = defTypeRef->GetRealType();
			}
			break;
		}
		default:
			SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
				objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
			return FALSE;
	}
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol**)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{

			SIMCType *type = ((SIMCBuiltInTypeReference*)typeRef)->GetType();
			switch(SIMCModule::GetTypeClass(type))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					if(SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_BOOLEAN )
					{
						SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
						return FALSE;
					}

				case SIMCModule::TYPE_SIZE:
				case SIMCModule::TYPE_RANGE:
				case SIMCModule::TYPE_ENUM_OR_BITS:
					if(indexPresent)
						SemanticError(fileName, OBJ_TYPE_INDEX_UNNECESSARY,
							objectType->GetIndexLine(), objectType->GetIndexColumn());
					return TRUE;
				case SIMCModule::TYPE_INVALID:
				case SIMCModule::TYPE_TRAP_TYPE:
				case SIMCModule::TYPE_NOTIFICATION_TYPE:
				case SIMCModule::TYPE_OBJECT_TYPE_V1:
				case SIMCModule::TYPE_OBJECT_IDENTITY:
					SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
					return FALSE;
				case SIMCModule::TYPE_SEQUENCE:
					return CheckObjectSequenceTypeV1(fileName, objectType, (SIMCSequenceType *)type, local);
				case SIMCModule::TYPE_SEQUENCE_OF:
					return CheckObjectSequenceOfTypeV1(fileName, objectType, (SIMCSequenceOfType *)type, local);
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			return TRUE;
	}
	return FALSE;
}


BOOL SIMCParseTree::CheckObjectTypeV2Syntax(const char *const fileName,
			SIMCObjectTypeV2 *objectType, BOOL local)
{
	SIMCSymbol **syntax = objectType->GetSyntax();
	SIMCTypeReference *typeRef  = NULL;
	SIMCIndexListV2 * indexList = objectType->GetIndexTypes();
	BOOL indexPresent = FALSE;
	if(indexList && !indexList->IsEmpty())
		indexPresent = TRUE;

	switch(SIMCModule::GetSymbolClass(syntax))
	{
		case SIMCModule::SYMBOL_IMPORT:

			if(!local)
			{
				SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
				return FALSE;
			}
			return TRUE;

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF: 
			typeRef = (SIMCBuiltInTypeReference *)(*syntax);
			break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			SIMCDefinedTypeReference * defTypeRef = (SIMCDefinedTypeReference*)(*syntax);
			switch(defTypeRef->GetStatus())
			{
				case RESOLVE_IMPORT:
					if(!local)
					{
						SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
						return FALSE;
					}
					else
						return TRUE;
					break;
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
						objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
					return FALSE;
					break;
				case RESOLVE_CORRECT:
					typeRef = defTypeRef->GetRealType();
			}
			break;
		}
		default:
			SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
				objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
			return FALSE;
	}

	SIMCSymbol **tempTypeRef = (SIMCSymbol**)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{

			SIMCType *type = ((SIMCBuiltInTypeReference*)typeRef)->GetType();
			switch(SIMCModule::GetTypeClass(type))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					if(SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_BOOLEAN )
					{
						SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
						return FALSE;
					}

				case SIMCModule::TYPE_SIZE:
				case SIMCModule::TYPE_RANGE:
				case SIMCModule::TYPE_ENUM_OR_BITS:
					if(indexPresent)
						SemanticError(fileName, OBJ_TYPE_INDEX_UNNECESSARY,
							objectType->GetIndexLine(), objectType->GetIndexColumn());
					return TRUE;
				case SIMCModule::TYPE_INVALID:
				case SIMCModule::TYPE_TRAP_TYPE:
				case SIMCModule::TYPE_NOTIFICATION_TYPE:
				case SIMCModule::TYPE_OBJECT_TYPE_V1:
				case SIMCModule::TYPE_OBJECT_IDENTITY:
					SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
						objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
					return FALSE;
				case SIMCModule::TYPE_SEQUENCE:
					return CheckObjectSequenceTypeV2(fileName, objectType, (SIMCSequenceType *)type, local);
				case SIMCModule::TYPE_SEQUENCE_OF:
					return CheckObjectSequenceOfTypeV2(fileName, objectType, (SIMCSequenceOfType *)type, local);
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			return TRUE;
	}
	return FALSE;
}


BOOL SIMCParseTree::CheckObjectTypeV1(const char *const fileName,
			SIMCObjectTypeV1 *objectType, BOOL local)
{
	BOOL retVal = TRUE;
	retVal = CheckObjectTypeV1Syntax(fileName, objectType, local) && retVal;
	// Index clause is checked from a call in CheckObjectTypeValueAssignment()
	// retVal = CheckObjectTypeV1Index(fileName, objectType, local) && retVal;
	retVal = CheckObjectTypeDefVal(fileName, objectType, local) && retVal;
	return retVal;
}

BOOL SIMCParseTree::CheckObjectTypeV2(const char *const fileName,
			SIMCObjectTypeV2 *objectType, BOOL local)
{
	BOOL retVal = TRUE;
	retVal = CheckObjectTypeV2Syntax(fileName, objectType, local) && retVal;
	// Index clause is checked from a call in CheckObjectTypeValueAssignment()
	// retVal = CheckObjectTypeV1Index(fileName, objectType, local) && retVal;

	retVal = CheckObjectTypeDefVal(fileName, objectType, local) && retVal;
	return retVal;
}

BOOL SIMCParseTree::CheckObjectIdentityType(const char *const fileName, 
			SIMCObjectIdentityType *rhs, BOOL local)
{
	return TRUE;
}

BOOL SIMCParseTree::CheckTrapType(const char *const fileName,
			SIMCTrapTypeType *trapType, BOOL local)
{
	BOOL retVal = TRUE;
	
	SIMCSymbol **enterprise = trapType->GetEnterprise();
	SIMCOidValue *oidValue;
	switch(SIMCModule::IsObjectIdentifierValue(enterprise, oidValue))
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, TRAP_TYPE_ENTERPRISE_RESOLUTION,
					(*enterprise)->GetLineNumber(), (*enterprise)->GetColumnNumber(),
					(*enterprise)->GetSymbolName());
				retVal = FALSE;
			}
			break;
		case RESOLVE_CORRECT:
			break;
		default:
			SemanticError(fileName, TRAP_TYPE_ENTERPRISE_RESOLUTION,
				(*enterprise)->GetLineNumber(), (*enterprise)->GetColumnNumber(),
				(*enterprise)->GetSymbolName());
				retVal = FALSE;
	}
	
	SIMCVariablesList *variables = trapType->GetVariables();
	POSITION p = variables->GetHeadPosition();
	SIMCSymbol **variable;
	SIMCVariablesItem *variablesItem;
	SIMCObjectTypeType *objType;
	while(p)
	{
		variablesItem = variables->GetNext(p);
		variable = variablesItem->_item;
		switch(SIMCModule::IsObjectType(variable, objType))
		{
			case RESOLVE_IMPORT:
				if(!local)
					SemanticError(fileName, TRAP_TYPE_VARIABLES_RESOLUTION,
						variablesItem->_line, variablesItem->_column,
						(*variable)->GetSymbolName());
				break;
			case RESOLVE_UNDEFINED:
			case RESOLVE_UNSET:
				SemanticError(fileName, TRAP_TYPE_VARIABLES_RESOLUTION,
					variablesItem->_line, variablesItem->_column,
					(*variable)->GetSymbolName());
				break;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckNotificationType(const char *const fileName,
			SIMCNotificationTypeType *notificationType, BOOL local)
{
	BOOL retVal = TRUE;
	
	SIMCObjectsList *objects = notificationType->GetObjects();
	POSITION p = objects->GetHeadPosition();
	SIMCSymbol **object;
	SIMCObjectsItem *objectsItem;
	SIMCObjectTypeType *objType;
	BOOL isImportSymbol = FALSE;
	while(p)
	{
		isImportSymbol = FALSE;
		objectsItem = objects->GetNext(p);
		object = objectsItem->_item;
		switch(SIMCModule::IsObjectType(object, objType))
		{
			case RESOLVE_IMPORT:
				if(!local)
				{
					SemanticError(fileName, NOTIFICATION_TYPE_OBJECTS_RESOLUTION,
						objectsItem->_line, objectsItem->_column,
						(*object)->GetSymbolName());
					retVal = FALSE;
				}
				isImportSymbol = TRUE;
				break;
			case RESOLVE_UNDEFINED:
			case RESOLVE_UNSET:
				SemanticError(fileName, NOTIFICATION_TYPE_OBJECTS_RESOLUTION,
					objectsItem->_line, objectsItem->_column,
					(*object)->GetSymbolName());
				retVal = FALSE;
				break;
		}

		// Skip further checking since we dont know anything about this imported symbol
		if(isImportSymbol)
			continue;

		SIMCModule::TypeClass typeClass = SIMCModule::GetTypeClass(objType);
		switch(typeClass)
		{
			case SIMCModule::TYPE_OBJECT_TYPE_V1:
				if( ((SIMCObjectTypeV1*)objType)->GetAccess() == SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE)
				{
					SemanticError(fileName, NOTIFICATION_TYPE_UNACCESSIBLE_OBJECT,
						(*object)->GetLineNumber(), (*object)->GetColumnNumber(),
						(*object)->GetSymbolName());
					
					retVal = FALSE;
				}
				break;
			case SIMCModule::TYPE_OBJECT_TYPE_V2:
				if( ((SIMCObjectTypeV2*)objType)->GetAccess() == SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE)
				{
					SemanticError(fileName, NOTIFICATION_TYPE_UNACCESSIBLE_OBJECT,
						(*object)->GetLineNumber(), (*object)->GetColumnNumber(),
						(*object)->GetSymbolName());
					
					retVal = FALSE;
				}
				break;
			default:
				retVal = FALSE;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckBuiltInTypeRef(SIMCBuiltInTypeReference *symbol, BOOL local)
{
	const char *const fileName = (symbol->GetModule())->GetInputFileName();

	SIMCType *rhs = symbol->GetType();
	SIMCModule *module = symbol->GetModule();
	if(symbol->GetReferenceCount() == 0)
	{
		if(!SIMCParser::IsReservedSymbol(_snmpVersion, symbol->GetSymbolName(), module->GetModuleName()))
			SemanticError(fileName, TYPE_UNREFERENCED,
				symbol->GetLineNumber(), symbol->GetColumnNumber(),
				symbol->GetSymbolName());
	}
	
	switch(SIMCModule::GetTypeClass(rhs))
	{
		case SIMCModule::TYPE_INVALID:
			return FALSE;
		case SIMCModule::TYPE_PRIMITIVE:
			return TRUE;
		case SIMCModule::TYPE_RANGE:
			switch(_snmpVersion)
			{
				case 1:
					return CheckRangeTypeV1( fileName, (SIMCRangeType *)rhs, local );
				case 2:
					return CheckRangeTypeV2( fileName, (SIMCRangeType *)rhs, local );
				default:
					return CheckRangeTypeV0( fileName, (SIMCRangeType *)rhs, local );

			}
		case SIMCModule::TYPE_SIZE:
			switch(_snmpVersion)
			{
				case 1:
					return CheckSizeTypeV1( fileName, (SIMCSizeType *)rhs, local );
				case 2:
					return CheckSizeTypeV2( fileName, (SIMCSizeType *)rhs, local );
				default:
					return CheckSizeTypeV0( fileName, (SIMCSizeType *)rhs, local );
			}
		case SIMCModule::TYPE_ENUM_OR_BITS:
			switch(((SIMCEnumOrBitsType *)rhs)->GetEnumOrBitsType())
			{
				case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
					{
						switch(_snmpVersion)
						{
							case 1:
								return CheckEnumTypeV1( fileName, (SIMCEnumOrBitsType *)rhs, local );
							case 2:
								return CheckEnumTypeV2( fileName, (SIMCEnumOrBitsType *)rhs, local );
							default:
								return CheckEnumTypeV0( fileName, (SIMCEnumOrBitsType *)rhs, local );
						}
					}
				case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
					return CheckBitsTypeV2( fileName, (SIMCEnumOrBitsType *)rhs, local );
				case SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT:
					if(local)
						return TRUE;
					else
					{
						SemanticError( fileName,
							ENUM_OR_BITS_RESOLUTION,
							((SIMCSubType *)rhs)->GetTypeLine(),
							((SIMCSubType *)rhs)->GetTypeColumn());
						return FALSE;
					}
				default:
					if(local)
						return TRUE;
					else
					{
						SemanticError( fileName,
							ENUM_OR_BITS_RESOLUTION,
							((SIMCSubType *)rhs)->GetTypeLine(),
							((SIMCSubType *)rhs)->GetTypeColumn());
						return FALSE;
					}
			}
			break;
		case SIMCModule::TYPE_SEQUENCE_OF:
			return CheckSequenceOfType( fileName, (SIMCSequenceOfType *)rhs, local );
		case SIMCModule::TYPE_SEQUENCE:
			return CheckSequenceType( fileName, (SIMCSequenceType *)rhs, local );
		case SIMCModule::TYPE_TRAP_TYPE:
			return CheckTrapType(fileName, (SIMCTrapTypeType *)rhs, local);
		case SIMCModule::TYPE_NOTIFICATION_TYPE:
			return CheckNotificationType(fileName, (SIMCNotificationTypeType *)rhs, local);
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			return CheckObjectTypeV1(fileName, (SIMCObjectTypeV1 *)rhs, local);
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			return CheckObjectTypeV2(fileName, (SIMCObjectTypeV2 *)rhs, local);
		case SIMCModule::TYPE_OBJECT_IDENTITY:
			return CheckObjectIdentityType(fileName, (SIMCObjectIdentityType *)rhs, local);
	}
	return FALSE;
}

BOOL SIMCParseTree::CheckDefinedTypeRef(SIMCDefinedTypeReference *symbol, BOOL local)
{
	const SIMCModule *module = symbol->GetModule();
	const char *const fileName = module->GetInputFileName();
	
	if(symbol->GetReferenceCount() == 0)
	{
		if(!SIMCParser::IsReservedSymbol(_snmpVersion, symbol->GetSymbolName(), module->GetModuleName()))
			SemanticError(fileName, TYPE_UNREFERENCED,
				symbol->GetLineNumber(), symbol->GetColumnNumber(),
				symbol->GetSymbolName());
	}

	switch(symbol->GetStatus())
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, TYPE_UNRESOLVED,
					symbol->GetLineNumber(), symbol->GetColumnNumber(),
					symbol->GetSymbolName());
				return FALSE;
			}
			return TRUE;
		case RESOLVE_CORRECT:
			return TRUE;
		default:
			SemanticError(fileName, TYPE_UNRESOLVED,
				symbol->GetLineNumber(), symbol->GetColumnNumber(),
				symbol->GetSymbolName());
				return FALSE;
	}
	return FALSE;
}

BOOL SIMCParseTree::CheckTextualConvention(SIMCTextualConvention *symbol, BOOL local)
{
	return TRUE;
}


BOOL SIMCParseTree::MatchSequenceObjectTypeSyntax(const char *const fileName,
			SIMCObjectTypeType *objectType, 
			SIMCTypeReference *typeRef,
			SIMCSequenceItem *item,
			BOOL local)
{

	SIMCModule::PrimitiveType type = SIMCModule::PRIMITIVE_INVALID;
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol**)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(SIMCModule::GetTypeClass(((SIMCBuiltInTypeReference*)typeRef)->GetType()))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					type = SIMCModule::GetPrimitiveType(typeRef->GetSymbolName());
					break;
				
				case SIMCModule::TYPE_ENUM_OR_BITS:
				{
					SIMCEnumOrBitsType *enumType = 
							(SIMCEnumOrBitsType *) ((SIMCBuiltInTypeReference*)typeRef)->GetType();
					switch( enumType->GetEnumOrBitsType())
					{
						case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
							type = SIMCModule::PRIMITIVE_INTEGER;
							break;
						case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
							type = SIMCModule::PRIMITIVE_BITS;
							break;
						case SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT:
							if(local)
								return TRUE;
							else
							{
								SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
									item->_typeLine, item->_typeColumn,
									(*item->_type)->GetSymbolName());
								return FALSE;
							}
						default:
								SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
									item->_typeLine, item->_typeColumn,
									(*item->_type)->GetSymbolName());
								return FALSE;
					}


				}
				case SIMCModule::TYPE_RANGE:
				case SIMCModule::TYPE_SIZE:
				{
					SIMCSubType *subType = (SIMCSubType *)(((SIMCBuiltInTypeReference *)typeRef)->GetType());
					switch(subType->GetStatus())
					{
						case RESOLVE_IMPORT:
							if(!local)
							{
								SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
									item->_typeLine, item->_typeColumn,
									(*item->_type)->GetSymbolName());
								return FALSE;
							}
						case RESOLVE_UNSET:
						case RESOLVE_UNDEFINED:
							SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
								item->_typeLine, item->_typeColumn,
								(*item->_type)->GetSymbolName());
							return FALSE;
						case RESOLVE_CORRECT:
						{
							SIMCTypeReference *rootTypeRef = subType->GetRootType();
							type = SIMCModule::GetPrimitiveType(rootTypeRef);
						}
						break;
					}	
				}
				break;
				case SIMCModule::TYPE_SEQUENCE_OF:
				case SIMCModule::TYPE_SEQUENCE:
				case SIMCModule::TYPE_TRAP_TYPE:
				case SIMCModule::TYPE_NOTIFICATION_TYPE:
				case SIMCModule::TYPE_OBJECT_TYPE_V1:
				case SIMCModule::TYPE_OBJECT_TYPE_V2:
				case SIMCModule::TYPE_OBJECT_IDENTITY:
				case SIMCModule::TYPE_INVALID:
					SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
						item->_typeLine, item->_typeColumn,
						(*item->_type)->GetSymbolName());
					return FALSE;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{	
			type = SIMCModule::GetPrimitiveType(typeRef->GetSymbolName());
		}
		break;
	}
	// Now see if the root of the syntax of the object type matches  "type"
	SIMCSymbol ** syntaxSymbol = objectType->GetSyntax();
	SIMCTypeReference *syntaxTypeRef;
	switch(SIMCModule::IsTypeReference(syntaxSymbol, syntaxTypeRef))
	{
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
				return FALSE;
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return FALSE;
	}

	SIMCSymbol** tempSyntaxTypeRef = (SIMCSymbol**) (&syntaxTypeRef) ;
	//switch(SIMCModule::GetSymbolClass( (SIMCSymbol**)(&syntaxTypeRef) )	)
	switch(SIMCModule::GetSymbolClass( tempSyntaxTypeRef ))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCBuiltInTypeReference *syntaxBTRef = (SIMCBuiltInTypeReference*)syntaxTypeRef;
			switch(SIMCModule::GetTypeClass(syntaxBTRef->GetType()))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					switch(SIMCModule::GetPrimitiveType(syntaxBTRef->GetSymbolName()))
					{
						case SIMCModule::PRIMITIVE_INVALID:
							SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
								item->_valueLine, item->_valueColumn,
								(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
							return FALSE;
						case SIMCModule::PRIMITIVE_INTEGER:
						case SIMCModule::PRIMITIVE_COUNTER:
						case SIMCModule::PRIMITIVE_GAUGE:
						case SIMCModule::PRIMITIVE_TIME_TICKS:
						case SIMCModule::PRIMITIVE_INTEGER_32:
						case SIMCModule::PRIMITIVE_UNSIGNED_32:
						case SIMCModule::PRIMITIVE_GAUGE_32:
						case SIMCModule::PRIMITIVE_COUNTER_32:
						case SIMCModule::PRIMITIVE_COUNTER_64:
							if(	type == SIMCModule::PRIMITIVE_INTEGER	||
								type == SIMCModule::PRIMITIVE_COUNTER	||
								type == SIMCModule::PRIMITIVE_GAUGE		||
								type == SIMCModule::PRIMITIVE_TIME_TICKS||
								type == SIMCModule::PRIMITIVE_INTEGER_32||
								type == SIMCModule::PRIMITIVE_UNSIGNED_32||
								type == SIMCModule::PRIMITIVE_GAUGE_32	||
								type == SIMCModule::PRIMITIVE_COUNTER_32||
								type == SIMCModule::PRIMITIVE_COUNTER_64)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}

						case SIMCModule::PRIMITIVE_OCTET_STRING:
						case SIMCModule::PRIMITIVE_DISPLAY_STRING:
						case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
						case SIMCModule::PRIMITIVE_OPAQUE:
						case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
						case SIMCModule::PRIMITIVE_MAC_ADDRESS:
						case SIMCModule::PRIMITIVE_IP_ADDRESS:
						case SIMCModule::PRIMITIVE_DATE_AND_TIME:
						case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
						case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:	
						case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:	
							if(	type == SIMCModule::PRIMITIVE_OCTET_STRING		||
								type == SIMCModule::PRIMITIVE_DISPLAY_STRING	||
								type == SIMCModule::PRIMITIVE_PHYS_ADDRESS		||
								type == SIMCModule::PRIMITIVE_OPAQUE			||
								type == SIMCModule::PRIMITIVE_NETWORK_ADDRESS	||
								type == SIMCModule::PRIMITIVE_MAC_ADDRESS		||
								type == SIMCModule::PRIMITIVE_IP_ADDRESS		||
								type == SIMCModule::PRIMITIVE_DATE_AND_TIME		||
								type == SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS	||
								type == SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS	||
								type == SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS	)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						case SIMCModule::PRIMITIVE_OID:
							if(type == SIMCModule::PRIMITIVE_OID)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}

						case SIMCModule::PRIMITIVE_BOOLEAN:
							if(type == SIMCModule::PRIMITIVE_BOOLEAN)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						case SIMCModule::PRIMITIVE_NULL:
							if(type == SIMCModule::PRIMITIVE_NULL)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
					}
					break;
				case SIMCModule::TYPE_RANGE:
				case SIMCModule::TYPE_SIZE:
				{
					SIMCSubType *subType = (SIMCSubType *)(syntaxBTRef->GetType());
					switch(subType->GetStatus())
					{
						case RESOLVE_IMPORT:
							if(local)
								return TRUE;
							else
								return FALSE;
						case RESOLVE_UNSET:
						case RESOLVE_UNDEFINED:
							return FALSE;
					}
					SIMCTypeReference *rootTypeRef = subType->GetRootType();
					switch(SIMCModule::GetPrimitiveType(rootTypeRef))
					{
						case SIMCModule::PRIMITIVE_INVALID:
							SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
								item->_valueLine, item->_valueColumn,
								(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
							return FALSE;
						case SIMCModule::PRIMITIVE_INTEGER:
						case SIMCModule::PRIMITIVE_COUNTER:
						case SIMCModule::PRIMITIVE_GAUGE:
						case SIMCModule::PRIMITIVE_TIME_TICKS:
						case SIMCModule::PRIMITIVE_INTEGER_32:
						case SIMCModule::PRIMITIVE_UNSIGNED_32:
						case SIMCModule::PRIMITIVE_GAUGE_32:
						case SIMCModule::PRIMITIVE_COUNTER_32:
						case SIMCModule::PRIMITIVE_COUNTER_64:
							if(	type == SIMCModule::PRIMITIVE_INTEGER	||
								type == SIMCModule::PRIMITIVE_COUNTER	||
								type == SIMCModule::PRIMITIVE_GAUGE		||
								type == SIMCModule::PRIMITIVE_TIME_TICKS||
								type == SIMCModule::PRIMITIVE_INTEGER_32||
								type == SIMCModule::PRIMITIVE_UNSIGNED_32||
								type == SIMCModule::PRIMITIVE_GAUGE_32	||
								type == SIMCModule::PRIMITIVE_COUNTER_32||
								type == SIMCModule::PRIMITIVE_COUNTER_64)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}

						case SIMCModule::PRIMITIVE_OCTET_STRING:
						case SIMCModule::PRIMITIVE_DISPLAY_STRING:
						case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
						case SIMCModule::PRIMITIVE_OPAQUE:
						case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
						case SIMCModule::PRIMITIVE_MAC_ADDRESS:
						case SIMCModule::PRIMITIVE_IP_ADDRESS:
						case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
						case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:	
						case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:	
						case SIMCModule::PRIMITIVE_DATE_AND_TIME:
							if(	type == SIMCModule::PRIMITIVE_OCTET_STRING		||
								type == SIMCModule::PRIMITIVE_DISPLAY_STRING	||
								type == SIMCModule::PRIMITIVE_PHYS_ADDRESS		||
								type == SIMCModule::PRIMITIVE_OPAQUE			||
								type == SIMCModule::PRIMITIVE_NETWORK_ADDRESS	||
								type == SIMCModule::PRIMITIVE_MAC_ADDRESS		||
								type == SIMCModule::PRIMITIVE_IP_ADDRESS		||
								type == SIMCModule::PRIMITIVE_DATE_AND_TIME		||
								type == SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS	||
								type == SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS	||
								type == SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS	)
							return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						break;
						case SIMCModule::PRIMITIVE_OID:
							if(type == SIMCModule::PRIMITIVE_OID)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
							break;
						case SIMCModule::PRIMITIVE_BOOLEAN:
							if(type == SIMCModule::PRIMITIVE_BOOLEAN)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
							break;
						case SIMCModule::PRIMITIVE_NULL:
							if(type == SIMCModule::PRIMITIVE_NULL)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
							break;
						default:
							return FALSE;
					}
				}
				break;
				case SIMCModule::TYPE_ENUM_OR_BITS:
				{
					SIMCEnumOrBitsType *enumOrBits = (SIMCEnumOrBitsType *) syntaxBTRef->GetType(); 
					switch( enumOrBits->GetEnumOrBitsType())
					{
						case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
							if(type == SIMCModule::PRIMITIVE_INTEGER)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
							if(type == SIMCModule::PRIMITIVE_BITS)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						case SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT:
							if(local)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						default:
							SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
								item->_valueLine, item->_valueColumn,
								(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
							return FALSE;
					}
				}
				break;
				case SIMCModule::TYPE_SEQUENCE_OF:
				case SIMCModule::TYPE_SEQUENCE:
				case SIMCModule::TYPE_TRAP_TYPE:
				case SIMCModule::TYPE_NOTIFICATION_TYPE:
				case SIMCModule::TYPE_OBJECT_TYPE_V1:
				case SIMCModule::TYPE_OBJECT_IDENTITY:
				case SIMCModule::TYPE_INVALID:
					SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
						item->_valueLine, item->_valueColumn,
						(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
					return FALSE;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			switch(SIMCModule::GetPrimitiveType(syntaxTypeRef->GetSymbolName()) )
			{
				case SIMCModule::PRIMITIVE_DISPLAY_STRING:
				case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
				case SIMCModule::PRIMITIVE_MAC_ADDRESS:
				case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
				case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:	
				case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:	
					if(type == SIMCModule::PRIMITIVE_DISPLAY_STRING ||
						type == SIMCModule::PRIMITIVE_PHYS_ADDRESS	||
						type == SIMCModule::PRIMITIVE_MAC_ADDRESS	||
						type == SIMCModule::PRIMITIVE_OCTET_STRING	||
						type == SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS	||
						type == SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS	||
						type == SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS	)
						return TRUE;
					else
					{
						SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
							item->_valueLine, item->_valueColumn,
							(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
						return FALSE;
					}
					break;
				case SIMCModule::PRIMITIVE_DATE_AND_TIME:
					if(type == SIMCModule::PRIMITIVE_DATE_AND_TIME ||
						type == SIMCModule::PRIMITIVE_OCTET_STRING)
						return TRUE;
					else
					{
						SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
							item->_valueLine, item->_valueColumn,
							(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
						return FALSE;
					}
					break;
				default:
					SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
						item->_valueLine, item->_valueColumn,
						(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
					return FALSE;
			}
		}
	}
	return TRUE;
}


BOOL SIMCParseTree::CheckObjectSequenceItem( const char *const fileName,
			SIMCSequenceItem * item, 
			SIMCValueReference *parentObjectType,
			BOOL local)
{
	SIMCSymbol **type = item->_type;
	SIMCSymbol **value = item->_value;

	BOOL retVal = TRUE;

	SIMCObjectTypeType *objectType;
	switch(SIMCModule::IsObjectType(value, objectType))
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				retVal = FALSE;
				SemanticError(fileName, SEQUENCE_ITEM_NO_OBJECT,
					item->_valueLine, item->_valueColumn, (*value)->GetSymbolName());
			}
			break;
		case RESOLVE_UNDEFINED:
			retVal = FALSE;
			SemanticError(fileName, SEQUENCE_ITEM_NO_OBJECT,
				item->_valueLine, item->_valueColumn, (*value)->GetSymbolName());
			break;
		case RESOLVE_CORRECT:
			break;
	}

	SIMCTypeReference *typeRef = NULL;
	// Now check the type of the Sequence Item
	switch(SIMCModule::IsTypeReference(type, typeRef))
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				retVal = FALSE;
				SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
					item->_typeLine, item->_typeColumn,
					(*type)->GetSymbolName());
			}
			break;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			retVal = FALSE;
			SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
				item->_typeLine, item->_typeColumn,
				(*type)->GetSymbolName());
			break;
	}

	// Check if the types loosely match
	if(objectType && typeRef)
	{
		if(!MatchSequenceObjectTypeSyntax(fileName, objectType, typeRef, item, local))
			retVal = FALSE;
	}


	return retVal;
}

BOOL SIMCParseTree::CheckPrimitiveValueAssignment(const char * const fileName, 
												SIMCBuiltInValueReference *bvRef, 
												SIMCTypeReference *btRef,
												SIMCValue *value, 
												BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);

	switch(SIMCModule::GetPrimitiveType(btRef))
	{
		case SIMCModule::PRIMITIVE_INVALID:
			SemanticError(fileName, TYPE_UNRESOLVED,
				bvRef->GetTypeLine(), bvRef->GetTypeColumn(),
				bvRef->GetSymbolName());
			return FALSE;
		case SIMCModule::PRIMITIVE_INTEGER:
		case SIMCModule::PRIMITIVE_UNSIGNED_32:
		case SIMCModule::PRIMITIVE_INTEGER_32:
		case SIMCModule::PRIMITIVE_COUNTER:
		case SIMCModule::PRIMITIVE_GAUGE:
		case SIMCModule::PRIMITIVE_TIME_TICKS:
		case SIMCModule::PRIMITIVE_COUNTER_32:
		case SIMCModule::PRIMITIVE_COUNTER_64:
		case SIMCModule::PRIMITIVE_GAUGE_32:
			switch(valueClass)
			{
				case SIMCModule::VALUE_INTEGER:
					if(SIMCModule::GetPrimitiveType(btRef->GetSymbolName()) != SIMCModule::VALUE_INTEGER)
					{
						if( ((SIMCIntegerValue*)value)->GetIntegerValue() < 0 )
						{
							SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
									value->GetLine(), value->GetColumn(),
									btRef->GetSymbolName());
							return FALSE;
						}
					}
					return TRUE;
				case SIMCModule::VALUE_OCTET_STRING:
				{
					// Check the bounds
					SIMCOctetStringValue *octetValue = (SIMCOctetStringValue*)value;
					if(octetValue->GetNumberOfOctets() > 4)
					{
						SemanticError(fileName, INTEGER_TOO_BIG,
							value->GetLine(), value->GetColumn());
						return FALSE;
					}
					return TRUE;
				}
				default:
					SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
						value->GetLine(), value->GetColumn(), "INTEGER");
					return FALSE;
			}
		case SIMCModule::PRIMITIVE_OID:
			if(valueClass != SIMCModule::VALUE_OID)
			{
				SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
					value->GetLine(), value->GetColumn(), "OBJECT IDENTIFIER");
				return FALSE;
			}
			else
				return TRUE;
		case SIMCModule::PRIMITIVE_OCTET_STRING:
		case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
		case SIMCModule::PRIMITIVE_IP_ADDRESS:
		case SIMCModule::PRIMITIVE_OPAQUE:
		case SIMCModule::PRIMITIVE_DISPLAY_STRING:
		case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
		case SIMCModule::PRIMITIVE_MAC_ADDRESS:
		case SIMCModule::PRIMITIVE_DATE_AND_TIME:
		case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
		case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:	
		case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:	
			if(valueClass != SIMCModule::VALUE_OCTET_STRING)
			{
				SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
					value->GetLine(), value->GetColumn(), "OCTET STRING");
				return FALSE;
			}
			else
				return TRUE;
		case SIMCModule::PRIMITIVE_BOOLEAN:
			if(valueClass != SIMCModule::VALUE_BOOLEAN)
			{
				SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
					value->GetLine(), value->GetColumn(), "BOOLEAN");
				return FALSE;
			}
			else
				return TRUE;
		case SIMCModule::PRIMITIVE_NULL:
			if(valueClass != SIMCModule::VALUE_NULL)
			{
				SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
					value->GetLine(), value->GetColumn(), "NULL");
				return FALSE;
			}
			else
				return TRUE;
		case SIMCModule::PRIMITIVE_BITS:
			return TRUE;
	}
	return FALSE;

}

BOOL SIMCParseTree::CheckSubTypeValueAssignment(const char *const fileName,
												SIMCBuiltInValueReference *bvRef,
												SIMCBuiltInTypeReference *btRef,
												SIMCSubType *subType,
												SIMCValue *value, 
												BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);

	switch(subType->GetStatus())
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, SUBTYPE_ROOT_RESOLUTION,
					subType->GetTypeLine(), subType->GetTypeColumn());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			SemanticError(fileName, SUBTYPE_ROOT_RESOLUTION,
				subType->GetTypeLine(), subType->GetTypeColumn());
			return FALSE;
	}

	SIMCTypeReference *rootTypeRef = subType->GetRootType();
	SIMCSymbol **tempRootTypeRef = (SIMCSymbol**)&rootTypeRef;
	switch(SIMCModule::GetSymbolClass(tempRootTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			switch(SIMCModule::GetPrimitiveType(rootTypeRef))
			{
				case SIMCModule::PRIMITIVE_INVALID:
				case SIMCModule::PRIMITIVE_BOOLEAN:
				case SIMCModule::PRIMITIVE_NULL:
				case SIMCModule::PRIMITIVE_OID:
					return FALSE;
				case SIMCModule::PRIMITIVE_INTEGER:
				case SIMCModule::PRIMITIVE_COUNTER:
				case SIMCModule::PRIMITIVE_GAUGE:
				case SIMCModule::PRIMITIVE_TIME_TICKS:
				case SIMCModule::PRIMITIVE_INTEGER_32:
				case SIMCModule::PRIMITIVE_UNSIGNED_32:
				case SIMCModule::PRIMITIVE_GAUGE_32:
				case SIMCModule::PRIMITIVE_COUNTER_32:
				case SIMCModule::PRIMITIVE_COUNTER_64:
					switch(valueClass)
					{
						case SIMCModule::VALUE_INTEGER:
							if(SIMCModule::GetPrimitiveType(rootTypeRef->GetSymbolName()) != SIMCModule::PRIMITIVE_INTEGER)
							{
								if( ( (SIMCIntegerValue*)value)->GetIntegerValue() < 0 )
								{
									SemanticError(fileName, VALUE_ASSIGN_NEGATIVE_INTEGER,
										value->GetLine(), value->GetColumn(), 
										rootTypeRef->GetSymbolName());
									return FALSE;
								}
							}
							return TRUE;
						case SIMCModule::VALUE_OCTET_STRING:
						{
							SIMCOctetStringValue *octetValue = (SIMCOctetStringValue *)value;
							if(octetValue->GetNumberOfOctets() > 4)
							{
								SemanticError(fileName, INTEGER_TOO_BIG,
									value->GetLine(), value->GetColumn());
								return FALSE;
							}
						}
						default:
							SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
								value->GetLine(), value->GetColumn(), "INTEGER");
							return FALSE;
					}
					break;
				case SIMCModule::PRIMITIVE_OCTET_STRING:
				case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
				case SIMCModule::PRIMITIVE_IP_ADDRESS:
				case SIMCModule::PRIMITIVE_OPAQUE:
				case SIMCModule::PRIMITIVE_DISPLAY_STRING:
				case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
				case SIMCModule::PRIMITIVE_MAC_ADDRESS:
				case SIMCModule::PRIMITIVE_DATE_AND_TIME:
				case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
				case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:	
				case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:	
					if(valueClass != SIMCModule::VALUE_OCTET_STRING)
					{
						SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
							value->GetLine(), value->GetColumn(), "OCTET STRING");
						return FALSE;
					}
					else
					{
						if(SIMCModule::GetPrimitiveType(rootTypeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_IP_ADDRESS)
						{
							if( ( (SIMCOctetStringValue*)value)->GetNumberOfOctets() > 4 )
							{
								SemanticError(fileName, VALUE_ASSIGN_NEGATIVE_INTEGER,
									value->GetLine(), value->GetColumn(), 
									rootTypeRef->GetSymbolName());
								return FALSE;
							}
						}
						return TRUE;
					}
			}
			break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			switch(SIMCModule::GetPrimitiveType(rootTypeRef->GetSymbolName()))
			{
				case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
				case SIMCModule::PRIMITIVE_MAC_ADDRESS:
				case SIMCModule::PRIMITIVE_DISPLAY_STRING:
				case SIMCModule::PRIMITIVE_DATE_AND_TIME:
					if(valueClass != SIMCModule::VALUE_OCTET_STRING)
					{
						SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
							value->GetLine(), value->GetColumn(), "OCTET STRING");
						return FALSE;
					}
					return TRUE;
				default:
						SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
							value->GetLine(), value->GetColumn(), "OCTET STRING");
						return FALSE;
			}
		}
	}
	return TRUE;
}

BOOL SIMCParseTree::CheckEnumValueAssignment(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCEnumOrBitsType *enumType,
								SIMCValue *value, 
								BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);

	if(valueClass != SIMCModule::VALUE_INTEGER)
	{
		SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
			value->GetLine(), value->GetColumn(), "INTEGER");
		return FALSE;
	}
	char *dummy;
	switch(enumType->GetIdentifier( ((SIMCIntegerValue*)value)->GetIntegerValue(), dummy))
	{
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, VALUE_ASSIGN_ENUM_INVALID,
					value->GetLine(), value->GetColumn());
				return FALSE;
			}
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, VALUE_ASSIGN_ENUM_INVALID,
				value->GetLine(), value->GetColumn());
			return FALSE;
	}
	return TRUE;
}

BOOL SIMCParseTree::CheckObjectTypeValueAssignmentV1(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCObjectTypeV1 *objectType,
								SIMCValue *value, 
								BOOL local)
{
	BOOL retVal = TRUE;

	retVal = CheckObjectTypeV1Index(fileName, bvRef, objectType, local) && retVal;
	const char *const name = bvRef->GetSymbolName();

	// Get the Syntax Clause
	SIMCSymbol **syntax = objectType->GetSyntax();
	SIMCTypeReference *typeRef;

	switch(SIMCModule::IsTypeReference(syntax, typeRef))
	{
		case RESOLVE_IMPORT:
			if(local)
				return retVal;
			else
				return FALSE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			return FALSE;
	}
	
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol **)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType *syntaxType = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			switch(SIMCModule::GetTypeClass(syntaxType))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					if( SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_COUNTER &&
						name[strlen(name)-1] != 's' )
					{
						SemanticError(fileName, OBJ_TYPE_SINGULAR_COUNTER,
							bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
							name);
					}
					break;
				case SIMCModule::TYPE_SEQUENCE:
				{
					SIMCSequenceType *sequenceType = (SIMCSequenceType *)syntaxType;
					SIMCSequenceList *sequenceList = sequenceType->GetListOfSequences();
					if(sequenceList)
					{
						POSITION p = sequenceList->GetHeadPosition();
						while(p)
						{
							if(!CheckObjectSequenceItem(fileName, 
									sequenceList->GetNext(p), bvRef, local))
								retVal = FALSE;
						}
					}

					SIMCIndexList * indexList = objectType->GetIndexTypes();
					if(!indexList || indexList->IsEmpty())
					{
						SemanticError(fileName, OBJ_TYPE_SEQUENCE_NO_INDEX,
							bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
							name);
						retVal = FALSE;
					}
				}
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			return TRUE;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckObjectTypeValueAssignmentV2(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCObjectTypeV2 *objectType,
								SIMCValue *value, 
								BOOL local)
{
	BOOL retVal = TRUE;

	retVal = CheckObjectTypeV2Index(fileName, bvRef, objectType, local) && retVal;
	const char *const name = bvRef->GetSymbolName();

	// Get the Syntax Clause
	SIMCSymbol **syntax = objectType->GetSyntax();
	SIMCTypeReference *typeRef;

	switch(SIMCModule::IsTypeReference(syntax, typeRef))
	{
		case RESOLVE_IMPORT:
			if(local)
				return retVal;
			else
				return FALSE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			return FALSE;
	}
	
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol **)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType *syntaxType = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			switch(SIMCModule::GetTypeClass(syntaxType))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					if( (SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_COUNTER_32 ||
						SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_COUNTER_64  ||
						SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_COUNTER)
						&&
						name[strlen(name)-1] != 's' )
					{
						SemanticError(fileName, OBJ_TYPE_SINGULAR_COUNTER,
							bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
							name);
					}
					break;
				case SIMCModule::TYPE_SEQUENCE:
				{
					SIMCSequenceType *sequenceType = (SIMCSequenceType *)syntaxType;
					SIMCSequenceList *sequenceList = sequenceType->GetListOfSequences();
					if(sequenceList)
					{
						POSITION p = sequenceList->GetHeadPosition();
						while(p)
						{
							if(!CheckObjectSequenceItem(fileName, 
									sequenceList->GetNext(p), bvRef, local))
								retVal = FALSE;
						}
					}

					SIMCIndexListV2 * indexList = objectType->GetIndexTypes();
					if(!objectType->GetAugments() && (!indexList || indexList->IsEmpty()))
					{
						SemanticError(fileName, OBJ_TYPE_SEQUENCE_NO_INDEX,
							bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
							name);
						retVal = FALSE;
					}
				}
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			return TRUE;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckObjectIdentityValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef, 
										SIMCBuiltInTypeReference *btRef,
										SIMCObjectIdentityType *type, 
										SIMCValue *value, 
										BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);
	const char *const name = bvRef->GetSymbolName();
	if(valueClass != SIMCModule::VALUE_OID)
	{
		SemanticError(fileName, OBJECT_IDENTITY_VALUE_RESOLUTION,
			value->GetLine(), value->GetColumn(),
			name);
		return FALSE;
	}

	return TRUE;
}

BOOL SIMCParseTree::CheckTrapTypeValueAssignment(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCTrapTypeType *trapType,
								SIMCValue *value, 
								BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);
	const char *const name = bvRef->GetSymbolName();
	if(valueClass != SIMCModule::VALUE_INTEGER)
	{
		SemanticError(fileName, TRAP_TYPE_VALUE_RESOLUTION,
			value->GetLine(), value->GetColumn(),
			name);
		return FALSE;
	}
	if( ((SIMCIntegerValue*)value)->GetIntegerValue() < 0 )
	{
		SemanticError(fileName, TRAP_TYPE_VALUE_RESOLUTION,
			value->GetLine(), value->GetColumn(),
			name);
		return FALSE;
	}
	return TRUE;
}

BOOL SIMCParseTree::CheckNotificationTypeValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef, 
										SIMCBuiltInTypeReference *btRef,
										SIMCNotificationTypeType *type, 
										SIMCValue *value, 
										BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);
	const char *const name = bvRef->GetSymbolName();
	if(valueClass != SIMCModule::VALUE_OID)
	{
		SemanticError(fileName, NOTIFICATION_TYPE_VALUE_RESOLUTION,
			value->GetLine(), value->GetColumn(),
			name);
		return FALSE;
	}

	return TRUE;
}

BOOL SIMCParseTree::CheckBitsTypeValueAssignment(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCEnumOrBitsType *bitsType,
								SIMCValue *value, 
								BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);

	if( valueClass != SIMCModule::VALUE_BITS )
	{
		SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
			value->GetLine(), value->GetColumn(), "BITS");
		return FALSE;
	}

	// Check whether all the bit identifiers are valid
	SIMCBitValue *bitValue;
	const SIMCBitValueList * valueList = ((SIMCBitsValue *)value)->GetValueList();
	POSITION p = valueList->GetHeadPosition();
	while(p)
	{
		bitValue = valueList->GetNext(p);
		if(! bitsType->GetValue(bitValue->_name) )
		{
			SemanticError(fileName, INVALID_BIT_VALUE,
				bitValue->_line, bitValue->_column,
				bitValue->_name);
			return FALSE;
		}
	}
	return TRUE;
}

BOOL SIMCParseTree::CheckBuiltInValueRef(SIMCBuiltInValueReference *bvRef, BOOL local)
{
	const char *const fileName = (bvRef->GetModule())->GetInputFileName();
	// Get the type in the value assignment
	SIMCSymbol **typeSymbol = bvRef->GetTypeReference();
	const char *name = bvRef->GetSymbolName();
	SIMCTypeReference *btRef;
	switch( SIMCModule::IsTypeReference(typeSymbol, btRef))
	{
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, TYPE_UNRESOLVED,
					bvRef->GetTypeLine(), bvRef->GetTypeColumn(),
					bvRef->GetSymbolName());
				return FALSE;
			}
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
				SemanticError(fileName, TYPE_UNRESOLVED,
					bvRef->GetTypeLine(), bvRef->GetTypeColumn(),
					bvRef->GetSymbolName());
			return FALSE;
	}
	// Get the value
	SIMCValue *value = bvRef->GetValue();
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);
	if( valueClass == SIMCModule::VALUE_INVALID )
	{
		SemanticError(fileName, VALUE_UNRESOLVED,
			bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
			bvRef->GetSymbolName());
		return FALSE;
	}

	// Get the type
	SIMCType *type;
	SIMCModule::TypeClass typeClass;
	SIMCSymbol **tempBtRef = (SIMCSymbol**)&btRef;
	switch(SIMCModule::GetSymbolClass(tempBtRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			type = ((SIMCBuiltInTypeReference *)btRef)->GetType();
			typeClass = SIMCModule::GetTypeClass(type);
			break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			typeClass = SIMCModule::TYPE_PRIMITIVE;
			break;
	}


	
	if(typeClass != SIMCModule::TYPE_OBJECT_TYPE_V1 &&
		typeClass != SIMCModule::TYPE_OBJECT_TYPE_V2 &&
		typeClass != SIMCModule::TYPE_TRAP_TYPE &&
		typeClass != SIMCModule::TYPE_NOTIFICATION_TYPE)
	{
		if(bvRef->GetReferenceCount() == 0)
		{
			const SIMCModule *module = bvRef->GetModule();
			if(!SIMCParser::IsReservedSymbol(_snmpVersion, bvRef->GetSymbolName(), module->GetModuleName()))
				SemanticError(fileName, VALUE_UNREFERENCED,
					bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
					name);
		}
	}

	// See if the value matches the type
	switch(typeClass)
	{
		case SIMCModule::TYPE_INVALID:
			SemanticError(fileName, TYPE_UNRESOLVED,
				bvRef->GetTypeLine(), bvRef->GetTypeColumn(),
				bvRef->GetSymbolName());
			return FALSE;

		case SIMCModule::TYPE_PRIMITIVE:
			return CheckPrimitiveValueAssignment(fileName, bvRef, btRef, value, local);
		case SIMCModule::TYPE_RANGE:
		case SIMCModule::TYPE_SIZE:
			return CheckSubTypeValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
							(SIMCSubType *)type, value, local);
		case SIMCModule::TYPE_SEQUENCE_OF:
			SemanticError(fileName, VALUE_ASSIGN_INVALID,
				value->GetLine(), value->GetColumn(), "SEQUENCE OF");
			return FALSE;
		case SIMCModule::TYPE_SEQUENCE:
			SemanticError(fileName, VALUE_ASSIGN_INVALID,
				value->GetLine(), value->GetColumn(), "SEQUENCE");
			return FALSE;
		case SIMCModule::TYPE_TRAP_TYPE:
			return CheckTrapTypeValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
					(SIMCTrapTypeType *)type, value, local);
		case SIMCModule::TYPE_NOTIFICATION_TYPE:
			return CheckNotificationTypeValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
					(SIMCNotificationTypeType *)type, value, local);
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			return CheckObjectTypeValueAssignmentV1(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
						(SIMCObjectTypeV1 *)type, value, local);
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			return CheckObjectTypeValueAssignmentV2(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
						(SIMCObjectTypeV2 *)type, value, local);
		case SIMCModule::TYPE_OBJECT_IDENTITY:
			return CheckObjectIdentityValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
						(SIMCObjectIdentityType *)type, value, local);
		case SIMCModule::TYPE_ENUM_OR_BITS:
			switch( ((SIMCEnumOrBitsType *)type)->GetEnumOrBitsType())
			{
				case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
					return CheckEnumValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
										(SIMCEnumOrBitsType *)type, value, local);
				case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
					return CheckBitsTypeValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
								(SIMCEnumOrBitsType *)type, value, local);
				case SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT:
					if(local)
						return TRUE;
					else
						return FALSE;
				default:
					return FALSE;
			}
	}

	return TRUE;
}

BOOL SIMCParseTree::CheckDefinedValueRef(SIMCDefinedValueReference *symbol, BOOL local)
{
	const char *const fileName = (symbol->GetModule())->GetInputFileName();

	switch(symbol->GetStatus())
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, VALUE_UNRESOLVED,
					symbol->GetLineNumber(), symbol->GetColumnNumber(),
					symbol->GetSymbolName());
				return FALSE;
			}
			if(symbol->GetReferenceCount() == 0)
			{
				const SIMCModule *module = symbol->GetModule();
				if(!SIMCParser::IsReservedSymbol(_snmpVersion, symbol->GetSymbolName(), module->GetModuleName()))
					SemanticError(fileName, VALUE_UNREFERENCED,
						symbol->GetLineNumber(), symbol->GetColumnNumber(),
						symbol->GetSymbolName());
			}
			return TRUE;
		case RESOLVE_CORRECT:
		{
			SIMCBuiltInValueReference bvRef(symbol, symbol->GetRealValue());
			return CheckBuiltInValueRef(&bvRef, local);
		}
		default:
			SemanticError(fileName, VALUE_UNRESOLVED,
				symbol->GetLineNumber(), symbol->GetColumnNumber(),
				symbol->GetSymbolName());
			return FALSE;
	}
	return FALSE;
}


BOOL SIMCParseTree::CheckSymbol(SIMCSymbol **symbol, BOOL local)
{
	if((*symbol)->GetSymbolType() == SIMCSymbol::PRIMITIVE)
		return TRUE;

	BOOL temp = FALSE;
	const char *const fileName = ((*symbol)->GetModule())->GetInputFileName();
	SIMCModule::SymbolClass x = SIMCModule::GetSymbolClass(symbol);
	switch(x)
	{
		case SIMCModule::SYMBOL_INVALID:
		case SIMCModule::SYMBOL_UNKNOWN:
		case SIMCModule::SYMBOL_MODULE:
			SemanticError(fileName, SYMBOL_UNDEFINED, 
				(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
				(*symbol)->GetSymbolName());
			return FALSE;

		case SIMCModule::SYMBOL_IMPORT:

			if(!local)
			{
				SemanticError(fileName, SYMBOL_UNDEFINED, 
					(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
					(*symbol)->GetSymbolName());
				return FALSE;
			}
			return TRUE;

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			temp = CheckBuiltInTypeRef((SIMCBuiltInTypeReference *)(*symbol),
										local);

			return temp;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
			temp = CheckDefinedTypeRef((SIMCDefinedTypeReference *)(*symbol),
										local);
			return temp;
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
			temp = CheckBuiltInValueRef((SIMCBuiltInValueReference *)(*symbol),
										local);
			return temp;
		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
			temp = CheckDefinedValueRef((SIMCDefinedValueReference *)(*symbol),
										local);
			return temp;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			temp = CheckTextualConvention((SIMCTextualConvention *)(*symbol),
										local);
			return temp;
		}		

	return FALSE;
}

BOOL SIMCParseTree::CheckModule(SIMCModule *m, BOOL local)
{
	// See whether the reference counts of all imports is atleast 1
	SIMCModuleList * importModuleList = m->GetListOfImportModules();
	if(importModuleList)
	{
		SIMCModule *importModule;
		POSITION p = importModuleList->GetHeadPosition();
		while(p)
		{
			importModule = importModuleList->GetNext(p);
			if(SIMCParser::IsReservedModule(_snmpVersion, importModule->GetModuleName()))
				continue;
			SIMCSymbolTable *table = importModule->GetSymbolTable();
			POSITION pImport = table->GetStartPosition();
			SIMCSymbol **s;
			CString name;
			while(pImport)
			{
				table->GetNextAssoc(pImport, name, s);
				if( (*s)->GetReferenceCount() == 0 && name[0] != '*'  )
					SemanticError(m->GetInputFileName(), IMPORT_UNUSED,
						(*s)->GetLineNumber(), (*s)->GetColumnNumber(),
						(*s)->GetSymbolName());
			}
		}
	}

	SIMCSymbolTable * table = m->GetSymbolTable();
	POSITION p = table->GetStartPosition();
	SIMCSymbol **s;
	CString name;
	BOOL retVal = TRUE;
	while(p)
	{
		table->GetNextAssoc(p, name, s);
		retVal	= CheckSymbol(s, local) && retVal;
	}
	return retVal;
}


BOOL SIMCParseTree::CheckSemantics(BOOL local)
{
	// Check the current state of the parse tree
	if( _parseTreeState == EMPTY)
		return TRUE;
	if( _parseTreeState == UNRESOLVED && !local)
		return FALSE;
	
	if(!semanticErrorsDll)
	{
		cerr << "CheckSemantics(): FATAL ERROR smierrsm.dll not found" <<
			endl;
		return FALSE;
	}

	// Build the OID tree
 	BOOL retVal = BuildOidTree(local);

	// Check the semantics of all modules in the list
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		retVal= CheckModule(m, local) && retVal;
	}

	// Check the semantics of the OID tree
	retVal = CheckOidTree(local) && retVal;


	// Fabricate the groups
	SIMCGroupList groupList;
	if(retVal)
	{
		retVal = _theTree.GetObjectGroups(&groupList);

		// Add these to the owning modules. The owning module is decided as follows
		// The "Main Module" is defined as the module that is being input to the parse tree.
		// If the named node belongs to the Main Module, then add the group to the Main Module
		// else
		//		{
		//			if any of the scalars or table roots are in the Main Module 
		//				Add the group to the Main Module
		//			else
		//				Add the group to the module of the named node
		//		}
		// Not that this results in fabricated OBJECT-GROUPs being added to the
		// Main Module only.
	
		// The main module is always at the head of the list of modules in the parese tree
		SIMCModule *mainModule = _listOfModules->GetHead();
		SIMCObjectGroup *nextGroup = NULL;
		SIMCSymbol *namedNode = NULL;
		SIMCModule *namedNodeModule = NULL;

		p = groupList.GetHeadPosition();
		while(p)
		{
			nextGroup = groupList.GetNext(p);
			namedNode = nextGroup->GetNamedNode();
			namedNodeModule = namedNode->GetModule();

			if(namedNodeModule == mainModule)
				mainModule->AddObjectGroup(nextGroup);
			else
			{
				if( nextGroup->ObjectsInModule(mainModule) )
					mainModule->AddObjectGroup(nextGroup);
				else
					(namedNode->GetModule())->AddObjectGroup(nextGroup);

			}
		}
			
	}

	// Fabricate NOTIFICATION-TYPEs from TRAP-TYPEs, for each module
	// And then fabricate NOTIFICATION-GROUPs from NOTIFICATION-TYPEs, for each module
	if(retVal)
	{
		retVal = FabricateNotificationGroups();
	}
	
	// Set the MODULE-IDENTITY Oid values for V2c modules, and fabricate MODULE-IDENTITY
	// for V1 modules 
	if(retVal)
	{
		p = _listOfModules->GetHeadPosition();
		SIMCModule *m;
		while(p)
		{
			m = _listOfModules->GetNext(p);
			switch( m->GetSnmpVersion())
			{
				// V2c module. No need to fabricate MODULE-IDENTITY
				case 2:
				{
					SIMCGroupList *listOfObjectGroups = m->GetObjectGroupList();
					if( !listOfObjectGroups || listOfObjectGroups->IsEmpty())
							SemanticError(m->GetInputFileName(), 
								MODULE_NO_GROUPS_V2, 
								m->GetLineNumber(),	m->GetColumnNumber(),
								m->GetModuleName());
					// Just fill in the clean oid value
					SIMCCleanOidValue *value = new SIMCCleanOidValue;
					if(_theTree.GetOidValue(m->GetModuleIdentityName(), 
						m->GetModuleName(), *value))
						m->SetModuleIdentityValue(value);
				}
				break;
				
				// For the case where the version of the module has not been specified on the 
				// command-line, check whether a MODULE-IDENTITY is present. If no,
				// do what was done for case 2. If not, fabricate one, just like the V1 case.
				case 0:
					if(m->GetModuleIdentityName())
					{
						// Set its version to 2
						m->SetSnmpVersion(2);

						SIMCGroupList *listOfObjectGroups = m->GetObjectGroupList();
						if( !listOfObjectGroups || listOfObjectGroups->IsEmpty())
								SemanticError(m->GetInputFileName(), 
									MODULE_NO_GROUPS_V2, 
									m->GetLineNumber(),	m->GetColumnNumber(),
									m->GetModuleName());
						// Just fill in the clean oid value
						SIMCCleanOidValue *value = new SIMCCleanOidValue;
						if(_theTree.GetOidValue(m->GetModuleIdentityName(), 
							m->GetModuleName(), *value))
							m->SetModuleIdentityValue(value);
						break;
					}
					// else fall thru to fabricate the clause

				// For an SNMPv1 module, Fabricate all the clauses of the MODULE-IDENTITY 
				case 1:
				{
					// Set its version to 1
					m->SetSnmpVersion(1);

					const char *const moduleName = m->GetModuleName();
					m->SetLastUpdated("0000000000Z");
					m->SetOrganization("");
					m->SetContactInfo("");
					m->SetDescription(moduleName);
					CString moduleIdentityName(moduleName);
					moduleIdentityName.MakeLower();
					RemoveUnderscores(moduleIdentityName);
					moduleIdentityName += CString("V1ModuleIdentity");
					m->SetModuleIdentityName(moduleIdentityName);


					// And finally, the OID value of the Module Identity macro
					SIMCGroupList *listOfObjectGroups = m->GetObjectGroupList();
					if( !listOfObjectGroups || listOfObjectGroups->IsEmpty())
						SemanticError(m->GetInputFileName(), 
							MODULE_NO_GROUPS_V1, 
							m->GetLineNumber(),	m->GetColumnNumber(),
							moduleName);
					else
					{
						POSITION p = listOfObjectGroups->GetHeadPosition();
						SIMCObjectGroup *nextGroup = listOfObjectGroups->GetNext(p);
						SIMCCleanOidValue * leastValue = nextGroup->GetGroupValue();
						SIMCCleanOidValue * nextValue = NULL;
						while(p)
						{
							nextGroup = listOfObjectGroups->GetNext(p);
							nextValue = nextGroup->GetGroupValue();
							if( (*nextValue) < (*leastValue) )
								leastValue = nextValue;
						}
						SIMCCleanOidValue *value = new SIMCCleanOidValue;
						CleanOidValueCopy(*value, *leastValue);
						m->SetModuleIdentityValue(value);
					}
				}
			}
		}
	}

	if(retVal)
	{
		if (_parseTreeState == UNCHECKED)
			_parseTreeState = FINAL;
	}

	return retVal;
}

BOOL SIMCParseTree::BuildModuleOidTree(SIMCModule *m, BOOL local)
{
	SIMCSymbolTable * table = m->GetSymbolTable();
	POSITION p = table->GetStartPosition();
	SIMCSymbol **s;
	const char * const moduleName = m->GetModuleName();
	CString name;
	SIMCValue *val;
	SIMCBuiltInValueReference *valRef;
	SIMCCleanOidValue cleanVal;
	BOOL retVal = TRUE;
	while(p)
	{
		cleanVal.RemoveAll();
		table->GetNextAssoc(p, name, s);
		if( (*((*s)->GetSymbolName()) == '*') || 
				(*s)->GetModule() != m)
			continue;
		switch(SIMCModule::GetSymbolClass(s))
		{
			case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
				val = ((SIMCBuiltInValueReference *)(*s))->GetValue();
				if( SIMCModule::GetValueClass(val) == SIMCModule::VALUE_OID )
				{
					switch( GetCleanOidValue(moduleName, (SIMCOidValue *)val, cleanVal, local) )
					{
						case RESOLVE_CORRECT:
							_theTree.AddSymbol((const SIMCSymbol **)s, cleanVal);
							break;
						case RESOLVE_IMPORT:
							if(local)
								break;
							else
							{
								retVal = FALSE;
								break;
							}
						default:
							retVal = FALSE;
							break;
					}

				}
				break;
			case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
				if(((SIMCDefinedValueReference *)(*s))->GetStatus() == RESOLVE_IMPORT)
				{
					if(local)
						break;
					else
					{
							SemanticError(m->GetInputFileName(), VALUE_UNRESOLVED,
								(*s)->GetLineNumber(), (*s)->GetColumnNumber(),
								(*s)->GetSymbolName());
							retVal = FALSE;
							break;
					}
				}
				valRef = ((SIMCDefinedValueReference *)(*s))->GetRealValue();
				val = valRef->GetValue();
				if(!val)
				{
						retVal = FALSE;
				}
				if( SIMCModule::GetValueClass(val) == SIMCModule::VALUE_OID )
				{
					switch( GetCleanOidValue(moduleName, (SIMCOidValue *)val, cleanVal, local) )
					{
						case RESOLVE_CORRECT:
							_theTree.AddSymbol((const SIMCSymbol **)s, cleanVal);
							break;
						case RESOLVE_IMPORT:
							if(local)
								break;
							else
							{
								retVal = FALSE;
								break;
							}
						default:
							retVal = FALSE;
							break;
					}

				}
				break;
			default:
				continue;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::BuildOidTree(BOOL local)
{

	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	BOOL retVal = TRUE;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		retVal= BuildModuleOidTree(m, local) && retVal;
	}

	// cout << _theTree;
	return retVal;
}

SIMCResolutionStatus SIMCParseTree::GetCleanOidValue( const char * const fileName,
													SIMCOidValue * input,
													SIMCCleanOidValue& result,
													BOOL local)
{
	SIMCSymbolList checkedList;
	return GetCleanOidValueRec(fileName, input, result, local, checkedList);
}
 
SIMCResolutionStatus SIMCParseTree::GetCleanOidValueRec( const char *const fileName,
						SIMCOidValue * input,
						SIMCCleanOidValue& result,
						BOOL local,
						SIMCSymbolList& checkedList) 
{
	SIMCOidComponentList *listOfComponents = input->GetListOfComponents();
	if( listOfComponents)
	{
		POSITION p = listOfComponents->GetHeadPosition();
		SIMCOidComponent *c;
		SIMCSymbol **s;
		SIMCValue *v;
		SIMCBuiltInValueReference *vref;
		int val;
		// Special Treatment for the first component. Can be an OID itself
		if(p)
		{
			c = listOfComponents->GetNext(p);
			s = c->GetValue();

			// See whether it is in the checked list. If so, it is self-referential value
			POSITION pChecked = checkedList.GetHeadPosition();
			const SIMCSymbol **checkedSymbol;
			while(pChecked)
			{
				checkedSymbol = checkedList.GetNext(pChecked);
				if( checkedSymbol == (const SIMCSymbol **)s)
				{
					SemanticError(fileName, OID_HEAD_ERROR,
						c->GetValueLine(), c->GetValueColumn(),
						(*s)->GetSymbolName());
					return RESOLVE_UNDEFINED;
				}
			}
			checkedList.AddTail((const SIMCSymbol **)s);

			
			switch(SIMCModule::GetSymbolClass(s))
			{
				case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
				{
					switch( ((SIMCDefinedValueReference*)(*s))->GetStatus())
					{
						case RESOLVE_IMPORT:
							if(local)
								return RESOLVE_IMPORT;
							else
							{
								SemanticError(fileName, OID_HEAD_ERROR,
									c->GetValueLine(), c->GetValueColumn(),
									(*s)->GetSymbolName());
								return RESOLVE_UNDEFINED;
							}
							break;
						case RESOLVE_UNDEFINED:
						case RESOLVE_UNSET:
							SemanticError(fileName, OID_HEAD_ERROR,
								c->GetValueLine(), c->GetValueColumn(),
								(*s)->GetSymbolName());
							return RESOLVE_UNDEFINED;
					}

					vref = ((SIMCDefinedValueReference*)(*s))->GetRealValue();
					v = vref->GetValue();
					switch( SIMCModule::GetValueClass(v))
					{
						case SIMCModule::VALUE_INTEGER:
						{
							val = ((SIMCIntegerValue *)(v))->GetIntegerValue();
							if(val == 0 )
								SemanticError(fileName, ZERO_IN_OID,
								c->GetValueLine(), c->GetValueColumn());
							if(val < 0)
							{
								SemanticError(fileName, OID_NEGATIVE_INTEGER,
									c->GetValueLine(), c->GetValueColumn());
								return RESOLVE_UNDEFINED;
							}
							result.AddTail(val);
						}
						break;
						case SIMCModule::VALUE_OID:
						{
							SIMCCleanOidValue head;
							switch(GetCleanOidValueRec(fileName, (SIMCOidValue*)v, head, local, checkedList))
							{
								case RESOLVE_IMPORT:
									if(local)
										return RESOLVE_IMPORT;
									else
										return RESOLVE_UNDEFINED;
									break;
								case RESOLVE_CORRECT:
									AppendOid(result, head);
									break;
								default:
									return RESOLVE_UNDEFINED;
							}
						}
						break;
						default:
							SemanticError(fileName, OID_HEAD_ERROR,
								c->GetValueLine(), c->GetValueColumn(),
								(*s)->GetSymbolName());
							return RESOLVE_UNDEFINED;
					}
				}
				break;
				case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
				{
					v = ((SIMCBuiltInValueReference*)(*s))->GetValue();
					switch( SIMCModule::GetValueClass(v) )
					{
						case SIMCModule::VALUE_INTEGER:
							val = ((SIMCIntegerValue *)(v))->GetIntegerValue();
							if(val == 0 )
								SemanticError(fileName, ZERO_IN_OID,
									c->GetValueLine(), c->GetValueColumn());
							if(val < 0)
							{
								SemanticError(fileName, OID_NEGATIVE_INTEGER,
									c->GetValueLine(), c->GetValueColumn());
								return RESOLVE_UNDEFINED;
							}
							result.AddTail(val);
							break;
						case SIMCModule::VALUE_OID:
						{
							SIMCCleanOidValue head;
							switch(GetCleanOidValueRec(fileName, (SIMCOidValue*)v, head, local, checkedList))
							{
								case RESOLVE_IMPORT:
									if(local)
										return RESOLVE_IMPORT;
									else
										return RESOLVE_UNDEFINED;
									break;
								case RESOLVE_CORRECT:
									AppendOid(result, head);
									break;
								default:
									return RESOLVE_UNDEFINED;
							}
						}
						break;
						default:
						{
							SemanticError(fileName, OID_HEAD_ERROR,
								c->GetValueLine(), c->GetValueColumn(),
								(*s)->GetSymbolName());
							return RESOLVE_UNDEFINED;
						}
					}
				}
				break;

				case SIMCModule::SYMBOL_IMPORT:
					if(!local)
					{
						SemanticError(fileName, OID_HEAD_ERROR,
						c->GetValueLine(), c->GetValueColumn(),
						(*s)->GetSymbolName());
						return RESOLVE_UNDEFINED;
					}
					else
						return RESOLVE_IMPORT;

				default:
					{
						SemanticError(fileName, OID_HEAD_ERROR,
							c->GetValueLine(), c->GetValueColumn(),
							(*s)->GetSymbolName());
						return RESOLVE_UNDEFINED;
					}
			}
		}
		while(p) // A list of integer value references
		{
			c = listOfComponents->GetNext(p);
			s = c->GetValue();
			SIMCSymbol **typeRef;
			switch(SIMCModule::IsValueReference(s, typeRef, vref))
			{
				case RESOLVE_IMPORT:
					if(local)
						return RESOLVE_IMPORT;
					else
					{
						SemanticError(fileName, OID_RESOLUTION,
							c->GetValueLine(), c->GetValueColumn(),
							(*s)->GetSymbolName());
						return RESOLVE_UNDEFINED;
					}
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
						SemanticError(fileName, OID_RESOLUTION,
							c->GetValueLine(), c->GetValueColumn(),
							(*s)->GetSymbolName());
						return RESOLVE_UNDEFINED;
			}

			v = vref->GetValue();
			if( SIMCModule::GetValueClass(v) != SIMCModule::VALUE_INTEGER)
			{
				SemanticError(fileName, OID_RESOLUTION,
					c->GetValueLine(), c->GetValueColumn(),
					(*s)->GetSymbolName());
				return RESOLVE_UNDEFINED;
			}
			val = ((SIMCIntegerValue *)(v))->GetIntegerValue();
			if(val == 0 )
				SemanticError(fileName, ZERO_IN_OID,
					c->GetValueLine(), c->GetValueColumn());
			if(val < 0)
			{
				SemanticError(fileName, OID_NEGATIVE_INTEGER,
					c->GetValueLine(), c->GetValueColumn());
				return RESOLVE_UNDEFINED;
			}
			result.AddTail(val);
		}
	}

	return RESOLVE_CORRECT;
}


BOOL SIMCParseTree::CheckOidTree(BOOL local)
{
	return _theTree.CheckOidTree(local, this);
}

// Fabricates all the NOTIFICATION-TYPEs resulting from TRAP-TYPE invocations
// An  then fabricates NOTIFICATION-GROUPs resulting from NOTIFICATION-TYPE invocations
BOOL SIMCParseTree::FabricateNotificationGroups()
{
	BOOL retVal = TRUE;
	//Fabricate for all modules in the list
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		retVal= m->FabricateNotificationGroups(*this, _theTree) && retVal;
	}
	return retVal;
}
  
  
// Just a static function to remove underscores from a fabricated module identitiy name
static void RemoveUnderscores(CString& moduleIdentityName)
{
	char *temp = new char[moduleIdentityName.GetLength()];
	int j = 0;
	for(int i=0; i < moduleIdentityName.GetLength();  i++)
	{
		if(moduleIdentityName[i] != '-')
			temp[j++] = moduleIdentityName[i];
	}
	temp[j] = NULL;
	moduleIdentityName = temp;
	delete temp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\scanner.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "parser.hpp"


SIMCScanner::SIMCScanner(SIMCParser *parser)
	:	columnNo(0), _theParser(parser) 
{}


SIMCScanner::~SIMCScanner()
{
	if(yyin)
		fclose(yyin);
}

BOOL SIMCScanner::SetInput(ifstream& inputStream)
{
	_inputStreamName = "<ifstream>";
	if(_dup2(inputStream.fd(), _fileno(yyin)) == -1)
		return FALSE;
	return TRUE;
}
	
BOOL SIMCScanner::SetInput(const CString& inputFile)
{
	 _inputStreamName = inputFile;
	if(!freopen(inputFile, "r", yyin))
		return FALSE;
	return TRUE;
}

BOOL SIMCScanner::SetInput(const int fileDescriptor)
{
	_inputStreamName = "<file descriptor>";
	if(_dup2(fileDescriptor, _fileno(yyin)) == -1)
		return FALSE;
	return TRUE;
}

BOOL SIMCScanner::SetInput(FILE * fileStream)
{
	_inputStreamName = "<FILE stream>";
	yyin = fileStream;
	return TRUE;
}

void SIMCScanner::output(int character)
{
	cerr << "<1212, Fatal>: \"" <<  _inputStreamName << "\" (line " << yylineno <<
		", col " << columnNo << ": Unrecognized character \'" << char(character) << "\'" << 
		endl;
}

void SIMCScanner::yyerror(char *fmt, ...)
{
	if(!_theParser)
	{
		return;
	}

	if (_theParser->YYRECOVERING())
		cerr << "Recovering from Error" << endl;
	else
	{
		if( yyleng )
		{
			if( yyleng == 1 )
			{
				switch (yytext[0])
				{
					case '\n' : cerr << _inputStreamName << "(line " << yylineno << 
									") SYNTAX ERROR. " << 
									"Last character read is \\n" << 
									endl; 
								return;
					case '\t' : cerr << _inputStreamName << "(line " << yylineno << 
									") SYNTAX ERROR. " << 
									"Last character read is \\t" << 
									endl; 
								return;
				}
			}
			yytext[yyleng] = NULL;
			cerr << "SYNTAX ERROR on line: " << yylineno << 
				", Last token read is \"" << yytext << "\"" << endl;
		}
		else
			cerr << "SYNTAX ERROR: EOF reached before end of module" <<
			endl;
	}
}

void SIMCScanner::SetInputStreamName( const CString& streamName)
{
	_inputStreamName = streamName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\traptype.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "trapType.hpp"


SIMCTrapTypeType::SIMCTrapTypeType( SIMCSymbol **enterprise,
					long enterpriseLine, long enterpriseColumn,
					SIMCVariablesList *variables,
					char * description,
					long descriptionLine, long descriptionColumn,
					char *reference,
					long referenceLine, long referenceColumn)
					:	_enterprise(enterprise),
						_enterpriseLine(enterpriseLine), _enterpriseColumn(enterpriseColumn),
						_variables(variables),
						_descriptionLine(descriptionLine), _descriptionColumn(descriptionColumn),
						_reference(reference),
						_referenceLine(referenceLine), _referenceColumn(referenceColumn)

{
	if(enterprise)
		(*enterprise)->IncrementReferenceCount();

	_description = NewString(description);
	_reference = NewString(reference);

	if (variables)
	{
		POSITION p = variables->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (variables->GetNext(p))->_item;
			(*s)->IncrementReferenceCount();
		}
	}
}

SIMCTrapTypeType::~SIMCTrapTypeType()
{
	if(UseReferenceCount() && _enterprise)
		(*_enterprise)->DecrementReferenceCount();

	if (UseReferenceCount() && _variables)
	{
		POSITION p = _variables->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (_variables->GetNext(p))->_item;
			(*s)->DecrementReferenceCount();
		}
	}
}

void SIMCTrapTypeType::WriteType(ostream& outStream) const
{
	outStream << "SIMCTrapTypeType::WriteType() : NOT YET IMPLEMENTED" << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\value.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>
#include <strstrea.h>
#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "newString.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "value.hpp"

BOOL IsLessThan(long a, BOOL aUnsigned, long b, BOOL bUnsigned)
{
	if(aUnsigned)
	{
		if(bUnsigned)
			// a and b are unsigned
			return (unsigned long)a < (unsigned long)b;
		else
			// a is unsigned, b is signed
			return FALSE;
	}
	else // a is signed
	{
		if(bUnsigned)
			// a is signed, b is unsigned
			return (a == 0)? b != 0 : TRUE; 
		else
			// a and b a re signed
			return a < b;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\ui.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include <winbase.h>

#include "bool.hpp"
#include "newString.hpp"
#include "ui.hpp"

CString SIMCUI::commandArgumentStrings[SIMCUI::COMMAND_MAX] =
{
	"",
	"/lc",
	"/ec",
	"/a",
	"/sa",
	"/g",
	"/gc",
	"/d",
	"/p",
	"/l",
	"/h",
	"/?",
	"/n",
	"/ni",
	"/r",
	"/pa",
	"/pd",
	"/pl"
};

CString SIMCUI::diagnosticLevelSwitch		= "/m";
CString SIMCUI::maxDiagnosticCountSwitch	= "/c";
CString SIMCUI::snmpV1VersionSwitch			= "/v1";
CString SIMCUI::snmpV2VersionSwitch			= "/v2c";
CString SIMCUI::suppressTextSwitch			= "/s";
CString SIMCUI::undocumentedDebugSwitch		= "/z";
CString SIMCUI::autoSwitch					= "/auto";
CString SIMCUI::includePathSwitch			= "/i";
CString SIMCUI::contextInfoSwitch			= "/ch";
CString SIMCUI::notificationsSwitch			= "/t";
CString SIMCUI::extendedNotificationsSwitch	= "/ext";
CString SIMCUI::notificationsOnlySwitch		= "/o";
CString SIMCUI::yesSwitch					= "/y";
 
const char * const SIMCUI::commandLineErrors[] =
	{
		"",


"================================================================================\n"
"           COMMAND-LINE SYNTAX FOR smi2smir, the MIB compiler\n"
"================================================================================\n"
"Usage:\n"
"\n"
   "\tsmi2smir [<DiagnosticArgs>] [<VersionArgs>] [<IncludeDirs>] \n"
		"\t\t<CommandArgs> <MIB file> [<Import Files>]\n"
   "\tsmi2smir [<DiagnosticArgs>] <RegistryArgs> [<Directory>]\n"
   "\tsmi2smir <ModuleInfoArgs> <MIB file>\n"
   "\tsmi2smir <HelpArgs>\n"
"\n"
"DiagnosticArgs:\n"
"---------------	 \n"
       "\t/m <diagnostic level> - Specifies the kind of diagnostics to display: \n"
              "\t\t0 (silent), 1 (fatal), 2 (fatal and warning), or 3 (fatal, \n"
              "\t\twarning, and information messages).\n"
       "\t/c <count> - Specifies the maximum number of fatal and warning \n"
              "\t\tmessages to display.\n"
"\n"
"VersionArgs:\n"
"------------\n"
       "\t/v1  - Specifies strict conformance to the SNMPv1 SMI.\n"
       "\t/v2c - Specifies strict conformance to the SNMPv2 SMI.\n"
"\n"
"CommandArgs:\n"
"------------\n"
       "\t/d  -  Deletes the specified module from the SMIR.\n"
       "\t/p  -  Deletes all modules in the SMIR.\n"
       "\t/l  -  Lists all modules in the SMIR.\n"
       "\t/lc -  Performs a local syntax check on the module.\n"
       "\t/ec [<CommandModifier>] - Performs local and external checks on the \n"
              "\t\tmodule.\n"
       "\t/a  [<CommandModifier>] - Performs  local and  external checks and \n"
              "\t\tloads the module into the SMIR.\n"
       "\t/sa [<CommandModifier>] - Same as /a, but works silently.\n"
       "\t/g  [<CommandModifier>] - Generates a SMIR MOF file that can be \n"
              "\t\tloaded later into CIMOM (using the MOF compiler). Used by\n"
			  "\t\tthe SNMP class provider to dynamically provide classes to \n"
			  "\t\tone or more namespaces\n"
       "\t/gc [<CommandModifier>] - Generates a static MOF file that can be \n"
              "\t\tloaded later into CIMOM as static classes for a particular\n"
			  "\t\tnamespace.\n"
"\n"
"CommandModifiers:\n"
"------------------\n"
       "\t/ch   -  Generates context information (date, time, host, user, etc.)\n"
              "\t\tin the MOF file header. \n"
			  "\t\tUse with /g and /gc.\n"
       "\t/t    -  Also generates SnmpNotification classes. \n"
			  "\t\tUse with /a, /sa and /g.\n"
       "\t/ext  - Also generates SnmpExtendedNotification classes. \n"
			  "\t\tUse with /a, /sa and /g.\n"
       "\t/t /o - Generates only SnmpNotification classes. \n"
			  "\t\tUse with /a, /sa and /g.\n"
       "\t/ext /o - Generates only SnmpExtendedNotification classes. \n"
              "\t\tUse with /a, /sa and /g.\n"
       "\t/s    -  Does not map the text of the DESCRIPTION clause.\n"
              "\t\tUse with /a, /sa, /g, and /gc.    \n"
       "\t/auto - Rebuilds the MIB lookup table before completing \n"
			  "\t\t<CommandArg> switch. \n"
              "\t\tUse with /ec, /a, /g, and /gc.\n"
"\n"
"IncludeDirs:\n"
"-------------\n"
       "\t/i <directory> - Specifies a directory to be searched for dependent \n"
              "\t\tMIB modules. \n"
              "\t\tUse with /ec, /a, /sa, /g, and /gc.\n"
"RegistryArgs:\n"
"-------------\n"
       "\t/pa -  Adds the specified directory to the registry.\n"
              "\t\t(Default is current directory.)\n"
       "\t/pd -  Deletes the specified directory from the registry.\n"
              "\t\t(Default is current directory.)\n"
       "\t/pl -  Lists the MIB lookup directories in the registry.\n"
       "\t/r  -  Rebuilds the entire MIB lookup table.\n"
"\n"
"ModuleInfoArgs:\n"
"---------------\n"
       "\t/n  -  Returns the ASN.1 name of the specified module.\n"
       "\t/ni -  Returns the ASN.1 names of all imports modules \n"
			"\t\treferenced by the input module.\n"
"\n"
"HelpArgs:\n"
"---------\n"
       "\t/h  -  Displays this usage information.\n"
       "\t/?  -  Displays this usage information.\n"
"\n"
"For auto-detection of dependent MIBs, the following values of type REG_MULTI_SZ\n"
"must be set under the root key HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WBEM\\Providers\\SNMP\\Compiler:\n"
"\n"
      "\t\"File Path\" : An ordered list of directory names where MIBs are located.\n"
      "\t\"File Suffixes\" : An ordered list of file extensions for MIB files.\n"
"\n"
"For additional information, see the WBEM SDK documentation.\n",



		"Invalid argument(s) on command-line after ",
		"Diagnostic Level not specified for the /m switch",
		"Diagnostic Level must be 0, 1, 2 or 3 for the /m switch",
		"Maximum diagnostic count missing after the /c switch",
		// 106
		" is not a valid diagnostic count",
		" Filename(s) missing",
		"No command argument specified, or unknown command argument",
		"Module name missing",
		"No include path specified after the /i switch",
		"/o switch is useful only with the /t and /ext switches",
		"Invalid combination of command-line switches",
		"Invalid switch "
	};


// Handles all command-line errors


void SIMCUI::Usage(ErrorMessageSymbol errorSymbol, const char *infoString, 
				   BOOL shouldAbort)
{
	if( errorSymbol<ERROR_NONE || errorSymbol>MAX_COMMAND_LINE_ERROR)
	{
		cerr << "Panic: Unknown command-line error: " << int(errorSymbol) << endl;
 		return;
	}

	int errorIndex = errorSymbol - ERROR_NONE;
	
	switch(errorSymbol)
	{

		case ERROR_NONE:
		case USAGE:
					cout << commandLineErrors[USAGE] << endl; 
					break;

		case INVALID_ARGS: 
		case INVALID_SWITCH:
					cerr << _applicationName << ": " <<
							   commandLineErrors[errorIndex] << infoString << endl;
					break;

		case WRONG_DIAG_COUNT: 
				cerr << _applicationName << ": " <<
					infoString << commandLineErrors[errorIndex] << endl;
					break;

		default:
				cerr << _applicationName << ": " <<
					commandLineErrors[errorIndex] << endl;
	}
	
	if(shouldAbort) 
		exit(1);
}


SIMCUI::SIMCUI()
:	 _snmpVersion(0), _diagnosticLevel(2), _commandArgument(COMMAND_HELP1),
	_inputFileOrModuleName(""), _suppressText(FALSE), _diagnosticMaximumCount(INT_MAX),
	_autoRefresh(FALSE), _classDefinitionsOnly(FALSE), _contextInfo(FALSE)
{
}

void SIMCUI::CheckIncludePaths(int& nextArg, int argc, const char *argv[])
{
	BOOL done = FALSE;
	CString lowerCaseArgValue = "";
	while(1)
	{
		if(nextArg == argc)
			return;
		lowerCaseArgValue = argv[nextArg];
		lowerCaseArgValue.MakeLower();
		if(lowerCaseArgValue == includePathSwitch)
		{
			nextArg++;
			if(nextArg == argc)
			{
				Usage(MISSING_INCLUDE_PATH, FALSE);
				return;
			}
			else
				_includePaths.AddTail(argv[nextArg++]);
		}
		else
			return;
	}
}

BOOL SIMCUI::ProcessCommandLine(int argc,  const char *argv[]) 
{
	// Initialize default values as specified in the requirements spec.
	_snmpVersion = 0;
	_diagnosticLevel = 3; 
	_commandArgument = COMMAND_HELP1;
	_inputFileOrModuleName = "";
	_suppressText = FALSE;
	_diagnosticMaximumCount = INT_MAX;
	_simcDebug = FALSE;
	_autoRefresh = FALSE;
	_classDefinitionsOnly = FALSE;
	_contextInfo = FALSE;
	_notifications = FALSE;
	_extendedNotifications = FALSE;
	_notificationsOnly = FALSE;
	_confirmedPurge = FALSE;

	if (argc == 0 )
		return FALSE;
	
	_applicationName = argv[0];

	if (argc == 1)	// Nothing specified on the command-line 
	{
		_commandArgument = COMMAND_HELP1;
		return TRUE;
	}

	int nextArg = 0;
	CString nextLowerCaseArg = "";

	// Collect the commandline string
	for(nextArg=0; nextArg<argc; nextArg++)
	{
		_commandLine += argv[nextArg];
		_commandLine += " ";
	}

	char nameBuffer[BUFSIZ];
	DWORD nameSize = BUFSIZ;
	//	Set _dateAndTime
	SYSTEMTIME timeInfo;
	GetLocalTime(&timeInfo);
	sprintf(nameBuffer, "%02d/%02d/%02d:%02d:%02d:%02d",
		 timeInfo.wDay, timeInfo.wMonth, timeInfo.wYear,
		 timeInfo.wHour, timeInfo.wMinute, timeInfo.wSecond);
	_dateAndTime = nameBuffer;

	//	Set _currentDirectory
	nameSize = BUFSIZ;
	if(GetCurrentDirectory(nameSize, nameBuffer))
		_currentDirectory = nameBuffer;

	//	Set _hostName
	nameSize = BUFSIZ;
	if(GetComputerName(nameBuffer, &nameSize))
		_hostName = nameBuffer;

	//	Set _userName
	nameSize = BUFSIZ;
	if(::GetUserName(nameBuffer, &nameSize))
		_userName = nameBuffer;


	
	nextArg = 1;
	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
	// Check for the undocumented /z switch
	if( undocumentedDebugSwitch == nextLowerCaseArg )
	{
		_simcDebug = TRUE;
		if(++nextArg == argc)
		{
			_commandArgument = COMMAND_HELP1;
			return TRUE;
		}
	}

	CheckIncludePaths(nextArg, argc, argv);
	if(nextArg == argc)
	{
		_commandArgument = COMMAND_HELP1;
		return TRUE;
	}

	// Check for /h or /? switches
	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
	if (commandArgumentStrings[COMMAND_HELP1] == nextLowerCaseArg ||
			 commandArgumentStrings[COMMAND_HELP2] == nextLowerCaseArg )
	{
		_commandArgument = COMMAND_HELP1;
		if( ++nextArg != argc)
		{
			Usage(INVALID_ARGS, argv[nextArg-1], FALSE);
			return FALSE;
		}

		return TRUE;
	}


	CheckIncludePaths(nextArg, argc, argv);
	if( nextArg == argc)
	{
		Usage(INVALID_ARGS, argv[nextArg-1], FALSE);
		return FALSE;
	}

	// Check for diagnostic arguments
 	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
  	if (diagnosticLevelSwitch == nextLowerCaseArg)
	{
		if (++nextArg == argc)
			Usage(MISSING_DIAG_LEVEL);
	
		if (strcmp(argv[nextArg], "0") == 0 )
			_diagnosticLevel = 0;
		else if (strcmp(argv[nextArg], "1") == 0 )
			_diagnosticLevel = 1;
		else if (strcmp(argv[nextArg], "2") == 0 )
			_diagnosticLevel = 2;
		else if (strcmp(argv[nextArg], "3") == 0 )
			_diagnosticLevel = 3;
		else
			Usage(WRONG_DIAG_LEVEL);
		nextArg++;
	}

	CheckIncludePaths(nextArg, argc, argv);

	if( nextArg == argc  )
		return TRUE;

 	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
	if (maxDiagnosticCountSwitch == nextLowerCaseArg)
	{
		if (++nextArg == argc)
			Usage(MISSING_DIAG_COUNT);
		
		char *invalidChars = NULL;
		_diagnosticMaximumCount=int(strtol(argv[nextArg], &invalidChars, 10));
	
		// Check if the diagnostic count is within bounds
		// And all character in the argument have been used by strtol()
		if( _diagnosticMaximumCount < 0 ||
			_diagnosticMaximumCount >= INT_MAX ||
			*invalidChars)
			Usage(WRONG_DIAG_COUNT, argv[nextArg]);
	
		nextArg++;
	}


	CheckIncludePaths(nextArg, argc, argv);

	if( nextArg == argc  )
		return TRUE;

	// Check for SNMPVersionArguments
 	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
	BOOL foundVersionArgs = false;
	if ( snmpV2VersionSwitch == nextLowerCaseArg )
	{
		_snmpVersion = 2;
		nextArg++;
		foundVersionArgs = true;
	}
	else if ( snmpV1VersionSwitch == nextLowerCaseArg )
	{
		_snmpVersion = 1;
		nextArg++; 
		foundVersionArgs = true;
	}

	CheckIncludePaths(nextArg, argc, argv);

	if( nextArg == argc ) 
	{
		// Nothing specified on the command-line
		Usage(MISSING_FILE_NAME, FALSE);
		return FALSE;
	}

	// A flag to check if there were any command arguments.
	BOOL commandArgumentsFound = FALSE;

 	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
	if (commandArgumentStrings[COMMAND_LOCAL_CHECK] == nextLowerCaseArg)
	{
		commandArgumentsFound = _commandArgument = COMMAND_LOCAL_CHECK;

		if (++nextArg == argc)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}

		// The next argument should be the file name
		_inputFileOrModuleName = argv[nextArg++];
	}
	else if (	commandArgumentStrings[COMMAND_EXTERNAL_CHECK] == nextLowerCaseArg	)
	{
		commandArgumentsFound = _commandArgument = COMMAND_EXTERNAL_CHECK;
		if (++nextArg == argc)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}


		CheckIncludePaths(nextArg, argc, argv);
		if (nextArg == argc)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}

		nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == autoSwitch )
		{
			_autoRefresh = TRUE;
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

 		nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == includePathSwitch)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}

		_inputFileOrModuleName = argv[nextArg++];

		while(nextArg != argc && argv[nextArg] != includePathSwitch)
			AddSubsidiaryFile(argv[nextArg++]);
	}
	else if(commandArgumentStrings[COMMAND_ADD] == nextLowerCaseArg				||
		commandArgumentStrings[COMMAND_GENERATE] == nextLowerCaseArg				||
		commandArgumentStrings[COMMAND_GENERATE_CLASSES_ONLY] == nextLowerCaseArg	||
		commandArgumentStrings[COMMAND_SILENT_ADD] == nextLowerCaseArg)
	{
		if (commandArgumentStrings[COMMAND_ADD] == nextLowerCaseArg)
			commandArgumentsFound = _commandArgument = COMMAND_ADD;	
		else if (commandArgumentStrings[COMMAND_SILENT_ADD] == nextLowerCaseArg)
 			commandArgumentsFound = _commandArgument = COMMAND_SILENT_ADD;
		else if (commandArgumentStrings[COMMAND_GENERATE] == nextLowerCaseArg)
			commandArgumentsFound = _commandArgument = COMMAND_GENERATE;
		else if (commandArgumentStrings[COMMAND_GENERATE_CLASSES_ONLY] == nextLowerCaseArg)
		{
			commandArgumentsFound = _commandArgument = COMMAND_GENERATE_CLASSES_ONLY;
			_classDefinitionsOnly = TRUE;
		}
		
		if (++nextArg == argc)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}
	
		CheckIncludePaths(nextArg, argc, argv);
		if (nextArg == argc)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}

		// "/t" or "/ext"
 	  	nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == notificationsSwitch ||
		   nextLowerCaseArg == extendedNotificationsSwitch)
		{
			// /gc switch is useless with /ext and /t
			if(_commandArgument == COMMAND_GENERATE_CLASSES_ONLY)
			{
				Usage(INVALID_COMBINATION_OF_SWITCHES, FALSE);
				return FALSE;
			}

			if(nextLowerCaseArg == notificationsSwitch )
				_notifications = TRUE;
			else if	(nextLowerCaseArg == extendedNotificationsSwitch )
				_extendedNotifications = TRUE;
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

		// "/ext" or "/t"
 	  	nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == notificationsSwitch ||
		   nextLowerCaseArg == extendedNotificationsSwitch)
		{
			if(nextLowerCaseArg == notificationsSwitch )
			{
				if(_notifications)
				{
					Usage(INVALID_COMBINATION_OF_SWITCHES, FALSE);
					return FALSE;
				}
				else
					_notifications = TRUE;
			}
			else if	(nextLowerCaseArg == extendedNotificationsSwitch )
			{
				if(_extendedNotifications)
				{
					Usage(INVALID_COMBINATION_OF_SWITCHES, FALSE);
					return FALSE;
				}
				else
					_extendedNotifications = TRUE;
			}
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

		// "/o"
 	  	nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == notificationsOnlySwitch)
		{
			if(_commandArgument == COMMAND_GENERATE_CLASSES_ONLY)
			{
				Usage(INVALID_COMBINATION_OF_SWITCHES, FALSE);
				return FALSE;
			}

			if(!_notifications && !_extendedNotifications)
			{
				Usage(NOTIFICATIONS_ONLY_USELESS, FALSE);
				return FALSE;
			}

			_notificationsOnly = true;
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

		nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == autoSwitch )
		{
			_autoRefresh = TRUE;
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

		nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == suppressTextSwitch )
		{
			_suppressText = TRUE;
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

		// Check for the /c switch in case of /g or /gc
		if (commandArgumentsFound == COMMAND_GENERATE ||
			commandArgumentsFound == COMMAND_GENERATE_CLASSES_ONLY)
		{
 			nextLowerCaseArg = argv[nextArg];
			nextLowerCaseArg.MakeLower();
			if(nextLowerCaseArg == contextInfoSwitch)
			{
				_contextInfo = TRUE;
				nextArg++;
			}

		}


 		nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == includePathSwitch)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}
		
		_inputFileOrModuleName = argv[nextArg++];

		while(nextArg != argc )
		{
			nextLowerCaseArg = argv[nextArg];
			nextLowerCaseArg.MakeLower();
			if(nextLowerCaseArg != includePathSwitch)
				AddSubsidiaryFile(argv[nextArg++]);
			else
				break;
		}
	}

	else if (commandArgumentStrings[COMMAND_DELETE] == nextLowerCaseArg)
	{
		commandArgumentsFound = _commandArgument = COMMAND_DELETE;
		if (++nextArg == argc)
			Usage(MISSING_MODULE_NAME); 		
		// The next argument should be the module name
		_inputFileOrModuleName = argv[nextArg++];
	}
	else if (commandArgumentStrings[COMMAND_PURGE] == nextLowerCaseArg)
	{
		commandArgumentsFound = _commandArgument = COMMAND_PURGE;
		nextArg++;

		if(nextArg != argc)
		{
			// Check for the /y switch
			nextLowerCaseArg = argv[nextArg];
			nextLowerCaseArg.MakeLower();
			if(yesSwitch == nextLowerCaseArg)
			{
				_confirmedPurge = TRUE;
				nextArg++;
			}
		}

	}
	else if (commandArgumentStrings[COMMAND_LIST] == nextLowerCaseArg )
	{
		commandArgumentsFound = _commandArgument = COMMAND_LIST;
		nextArg++;
	}
	else if (commandArgumentStrings[COMMAND_MODULE_NAME] == nextLowerCaseArg )
	{
		// Check for any invalid combination of switches
		if (foundVersionArgs )
			Usage(INVALID_COMBINATION_OF_SWITCHES);

		commandArgumentsFound = _commandArgument = COMMAND_MODULE_NAME;
		if (++nextArg == argc)
			Usage(MISSING_FILE_NAME); 		
		// The next argument should be the file name
		_inputFileOrModuleName = argv[nextArg++];
	}
	else if (commandArgumentStrings[COMMAND_IMPORTS_INFO] == nextLowerCaseArg )
	{
		if (foundVersionArgs )
			Usage(INVALID_COMBINATION_OF_SWITCHES);

		commandArgumentsFound = _commandArgument = COMMAND_IMPORTS_INFO;
		if (++nextArg == argc)
			Usage(MISSING_FILE_NAME); 		
		// The next argument should be the file name
		_inputFileOrModuleName = argv[nextArg++];
	}
	else if (commandArgumentStrings[COMMAND_REBUILD_TABLE] == nextLowerCaseArg)
	{
		if (foundVersionArgs )
			Usage(INVALID_COMBINATION_OF_SWITCHES);

		commandArgumentsFound = _commandArgument = COMMAND_REBUILD_TABLE;
		nextArg++;
	}
	else if (commandArgumentStrings[COMMAND_ADD_DIRECTORY] == nextLowerCaseArg)
	{
		commandArgumentsFound = _commandArgument = COMMAND_ADD_DIRECTORY;
		nextArg++;
		CheckIncludePaths(nextArg, argc, argv);
		
		if (nextArg == argc)
		{
			// Current directory is default for /pa switch
			char currentDirectory[BUFSIZ];
			long directoryLength = BUFSIZ;
			GetCurrentDirectory(directoryLength, currentDirectory);
			_inputFileOrModuleName = currentDirectory;
		}
		else
			// The next argument should be the file name
			_inputFileOrModuleName = argv[nextArg++];
	}
	else if (commandArgumentStrings[COMMAND_DELETE_DIRECTORY_ENTRY] == nextLowerCaseArg)
	{
		commandArgumentsFound = _commandArgument = COMMAND_DELETE_DIRECTORY_ENTRY;
		nextArg++;
		CheckIncludePaths(nextArg, argc, argv);
		if (nextArg == argc)
		{
			// Current directory is default for the /pd switch
			char currentDirectory[BUFSIZ];
			long directoryLength = BUFSIZ;
			GetCurrentDirectory(directoryLength, currentDirectory);
			_inputFileOrModuleName = currentDirectory;
		}
		else
			// The next argument should be the file name
			_inputFileOrModuleName = argv[nextArg++];
	}
	else if (commandArgumentStrings[COMMAND_LIST_MIB_PATHS] == nextLowerCaseArg)
	{
		if (foundVersionArgs )
			Usage(INVALID_COMBINATION_OF_SWITCHES);

		commandArgumentsFound = _commandArgument = COMMAND_LIST_MIB_PATHS;
		nextArg++;
	}


	CheckIncludePaths(nextArg, argc, argv);
	
	// Check for any residual args
	if (nextArg != argc )
		Usage((commandArgumentsFound)?INVALID_ARGS:MISSING_COMMAND_ARG, 
			argv[nextArg-1]);
	
	if(_inputFileOrModuleName[0] == '/')
	{
		Usage(INVALID_SWITCH, _inputFileOrModuleName);
		return FALSE;
	}

	return TRUE;
}

// This gets the FileVersion resource from the resource of the exe
CString SIMCUI::GetVersionNumber()
{
	CString executableName = _applicationName;
	if(_applicationName.Right(4) != ".exe")
		executableName += ".exe";

	unsigned long versionSize;
	// Get the size of the block required for the version information
	if(!(versionSize = GetFileVersionInfoSize((LPSTR)(LPCTSTR)executableName, &versionSize)))
		return CString("<UnknownVersion>");

	char *versionInfo = new char[versionSize];
	// Get the version block 
	if(GetFileVersionInfo((LPSTR)(LPCTSTR)executableName, NULL, versionSize, (LPVOID)versionInfo))
	{
		UINT length = 0;
		LPSTR lpBuffer = NULL;
		char *theFileVersion;

		if(VerQueryValue((LPVOID)versionInfo, 
              "\\StringFileInfo\\040904E4\\ProductVersion", 
			  (LPVOID *)&theFileVersion, 
              &length))
			return CString(theFileVersion);
		else
			return CString("<UnknownVersion>");
	}
	else
		return CString("<UnknownVersion>");
}

ostream& operator << ( ostream& outStream, const SIMCUI& obj)
{
	outStream << "APPLICATION: " << obj._applicationName << ", VERSION: " << obj._snmpVersion <<
		endl;
	outStream << "DIAGNOSTIC_LEVEL: " << obj._diagnosticLevel << ", DIAG_COUNT" << obj._diagnosticMaximumCount <<
		endl;

	switch(obj._commandArgument)
	{
		case SIMCUI::COMMAND_NONE:
			outStream << "COMMAND:  NONE" << endl; break;
		case SIMCUI::COMMAND_LOCAL_CHECK:
		case SIMCUI::COMMAND_EXTERNAL_CHECK:
		case SIMCUI::COMMAND_ADD:
		case SIMCUI::COMMAND_SILENT_ADD:
		case SIMCUI::COMMAND_GENERATE:
		case SIMCUI::COMMAND_DELETE:
			{
				outStream << "COMMAND: " << (int)obj._commandArgument << endl; 
				outStream << "Files: " << obj._inputFileOrModuleName << endl;
				outStream << endl;
				break;
			}
		case SIMCUI::COMMAND_PURGE:
			outStream << "COMMAND: PURGE" << endl; break; 
		case SIMCUI::COMMAND_LIST:
			outStream << "COMMAND: LIST" << endl;  break;
		case SIMCUI::COMMAND_HELP1:
		case SIMCUI::COMMAND_HELP2:
			outStream << "COMMAND: HELP" << endl;  break;
		case SIMCUI::COMMAND_MODULE_NAME:
			outStream << "COMMAND_MODULE_NAME" << endl;  break;
		case SIMCUI::COMMAND_IMPORTS_INFO:
			outStream << "COMMAND_IMPORTS_INFO: HELP" << endl;  break;
		case SIMCUI::COMMAND_REBUILD_TABLE:
			outStream << "COMMAND_REBUILD_TABLE" << endl;  break;
		default:
			outStream << "COMMAND: UNKNOWN" << endl;  break;
	}
	outStream << "END OF UI" << endl;
	return outStream;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\type.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <limits.h>
#include <iostream.h>
#include <strstrea.h>
#include "precomp.h"
#include <snmptempl.h>

#include "newString.hpp"
#include "bool.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "oidValue.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "module.hpp"

SIMCSizeType::~SIMCSizeType()
{
	if(_listOfSizes)
	{
		SIMCRangeOrSizeItem * item;
		while(_listOfSizes->IsEmpty())
		{
			item = _listOfSizes->RemoveHead();
			delete item;
		}
	}
}

void SIMCSizeType::WriteType(ostream& outStream) const
{
	outStream << "SIMCSizeType of type " ; 
		(*GetType())->WriteBrief(outStream);
	outStream << endl;
}

SIMCRangeType::~SIMCRangeType()
{
	if(_listOfRanges)
	{
		SIMCRangeOrSizeItem * item;
		while(!_listOfRanges->IsEmpty())
		{
			item = _listOfRanges->RemoveHead();
			delete item;
		}
		delete _listOfRanges;	
	}
}

void SIMCRangeType::WriteType(ostream& outStream) const
{
	outStream << "SIMCRangeType of type " ; 
	(*GetType())->WriteBrief(outStream);
	outStream << endl;
}

ostream& operator << (ostream& outStream, const SIMCRangeOrSizeItem& obj)
{
	if(obj._lowerBound == obj._upperBound)
	{
		if(obj._isUnsignedU)
			outStream << (unsigned long)obj._upperBound;
		else
			outStream << obj._upperBound;
	}
	else
	{
		if(obj._isUnsignedL)
			outStream << (unsigned long)obj._lowerBound;
		else
			outStream << obj._lowerBound;
		outStream << "..";
		if(obj._isUnsignedU)
			outStream << (unsigned long)obj._upperBound;
		else
			outStream << obj._upperBound;
	}
	return outStream;
}
char *SIMCSizeType::ConvertSizeListToString() const
{
	ostrstream outStream ;
	long index = _listOfSizes->GetCount();
	POSITION p = _listOfSizes->GetHeadPosition();
	SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = _listOfSizes->GetNext(p);
		outStream << *item;
		if ( index != 1 )
			outStream << ",";
		index -- ;
	}

	outStream << ends ;
	return outStream.str();
}

long SIMCSizeType::GetFixedSize() const
{
	 SIMCRangeOrSizeItem *item = _listOfSizes->GetHead();
	 return item->_lowerBound;
}

char *SIMCRangeType::ConvertRangeListToString() const
{
	ostrstream outStream ;
	long index = _listOfRanges->GetCount();
	POSITION p = _listOfRanges->GetHeadPosition();
	SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = _listOfRanges->GetNext(p);
		outStream << *item;
		if ( index != 1 )
			outStream << ",";
		index -- ;
	}

	outStream << ends ;
	return outStream.str();
}

BOOL SIMCSizeType::IsFixedSize() const
{
	if(_listOfSizes->GetCount() != 1)
		return FALSE;
	SIMCRangeOrSizeItem * item = _listOfSizes->GetHead();
	if(item->_lowerBound != item->_upperBound)
		return FALSE;
	return TRUE;
}


BOOL SIMCSizeType::IsNotZeroSizeObject() const
{
	SIMCRangeOrSizeItem * item;
	POSITION p = _listOfSizes->GetHeadPosition();
	while(p)
	{
		item = _listOfSizes->GetNext(p);
		if(item->_lowerBound == 0 || item->_upperBound == 0)
			return FALSE;
	}
	return TRUE;
}

long SIMCSizeType::GetMaximumSize() const
{
	SIMCRangeOrSizeItem * item;
	POSITION p = _listOfSizes->GetHeadPosition();
	long maxSize = 0;
	while(p)
	{
		item = _listOfSizes->GetNext(p);
		if(item->_upperBound > maxSize)
			maxSize = item->_upperBound;
	}
	return maxSize;
}

char * SIMCEnumOrBitsType::ConvertToString() const
{
	SIMCNamedNumberItem *item;
	POSITION p = _listOfItems->GetHeadPosition();
	long index = _listOfItems->GetCount();
	ostrstream outStream ;
	int value;
	while(p)
	{
		item = _listOfItems->GetNext(p);
	
		outStream << item->_name << "(";
		switch(SIMCModule::IsIntegerValue(item->_value, value))
		{
			case RESOLVE_CORRECT:
				outStream << value << ")";
				break;
			default:
				return NULL;
		}	

		if(index != 1)
			outStream << ",";
		index --;
	}
	outStream << ends ;
	return outStream.str();
			
}


SIMCEnumOrBitsType::SIMCEnumOrBitsType (SIMCSymbol **type, long typeLine, long typeColumn,
							SIMCNamedNumberList * listOfItems, EnumOrBitsType enumOrBitsType)
	: _listOfItems(listOfItems),
		_enumOrBitsType(enumOrBitsType),
		SIMCSubType(type, typeLine, typeColumn)
{
	if(listOfItems)
	{
		POSITION p = listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *e;
		while(p)
		{
			e = listOfItems->GetNext(p);
			(*e->_value)->IncrementReferenceCount();
		}
	}	
}

SIMCEnumOrBitsType::~SIMCEnumOrBitsType ()
{
	if(_listOfItems)
	{
		POSITION p = _listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *e;
		while(!_listOfItems->IsEmpty())
		{
			e = _listOfItems->RemoveHead();
			if( UseReferenceCount() && e->_value)
				(*e->_value)->DecrementReferenceCount();
			delete e;
		}
		delete _listOfItems;
	}	
}

SIMCSymbol **SIMCEnumOrBitsType::GetValue(const char * const name)	const
{
	if(_listOfItems)
	{
		POSITION p = _listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *e;
		while(p)
		{
			e = _listOfItems->GetNext(p);
			if(strcmp(e->_name, name) == 0)
				return e->_value;
		}
	}
	return NULL;
}

SIMCResolutionStatus SIMCEnumOrBitsType::GetIdentifier(int x, const char * &retVal) const
{
	if(_listOfItems)
	{
		POSITION p = _listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *e;
		int val;
		while(p)
		{
			e = _listOfItems->GetNext(p);
			switch (SIMCModule::IsIntegerValue(e->_value, val))
			{
				case RESOLVE_IMPORT:
					return RESOLVE_IMPORT;
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					return RESOLVE_UNDEFINED;
			}
			if(val == x)
			{
				retVal = e->_name;
				return RESOLVE_CORRECT;
			}
		}
	}
	return RESOLVE_UNDEFINED;
}

long SIMCEnumOrBitsType::GetLengthOfLongestName() const
{
	long maxLength = 0, temp;
	if(_listOfItems)
	{
		POSITION p = _listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *e;
		while(p)
		{
			e = _listOfItems->GetNext(p);
			if( (temp = strlen(e->_name)) > maxLength )
				maxLength = temp;
		}
	}
	return maxLength;
}

// Check whether the enum type in the argument is a superset of the
// "this" enum type
BOOL SIMCEnumOrBitsType::CheckClosure(const SIMCEnumOrBitsType *universalType) const
{
	if(_listOfItems)
	{
		POSITION p = _listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *nextItem;
		SIMCSymbol **rhsSymbol;
		int rhsValue, lhsValue;

		while(p)
		{
			nextItem = _listOfItems->GetNext(p);
			if(!(rhsSymbol = universalType->GetValue(nextItem->_name)))
				return FALSE;
			if(SIMCModule::IsIntegerValue(rhsSymbol, rhsValue) != RESOLVE_CORRECT)
				return FALSE;
			if(SIMCModule::IsIntegerValue(nextItem->_value, lhsValue) != RESOLVE_CORRECT)
				return FALSE;

			if( lhsValue != rhsValue)
				return FALSE;
		}
	}
	return TRUE;
}


SIMCSequenceType::SIMCSequenceType (SIMCSequenceList * listOfSequences)
	: _listOfSequences(listOfSequences)
{
	if(listOfSequences)
	{
		POSITION p = listOfSequences->GetHeadPosition();
		SIMCSequenceItem *e;
		while(p)
		{
			e = listOfSequences->GetNext(p);
			(*(e->_type))->IncrementReferenceCount();
			(*(e->_value))->IncrementReferenceCount();
		}
	}	
}

SIMCSequenceType::~SIMCSequenceType ()
{
	if(_listOfSequences)
	{
		SIMCSequenceItem *e;
		while(!_listOfSequences->IsEmpty())
		{
			e = _listOfSequences->RemoveHead();
			if(UseReferenceCount() &&  e->_type)
				(*(e->_type))->DecrementReferenceCount();
			if(UseReferenceCount() && e->_value)
				(*(e->_value))->DecrementReferenceCount();
			delete e;
		}
		delete _listOfSequences;
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsm\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsm\resource.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by smierrsm.rc
//
#define OBJ_TYPE_SYNTAX_RESOLUTION      1
#define OBJ_TYPE_INVALID_ACCESS         2
#define OBJ_TYPE_INVALID_STATUS         3
#define OBJ_TYPE_SINGULAR_COUNTER       4
#define OBJ_TYPE_ACCESSIBLE_TABLE       5
#define OBJ_TYPE_SEQUENCE_NO_INDEX      6
#define OBJ_TYPE_SEQUENCE_MULTI_REFERENCE 7
#define OBJ_TYPE_SEQUENCE_UNUSED        8
#define SEQUENCE_WRONG_CHILD            9
#define OBJ_TYPE_WRONG_CHILD            10
#define OBJ_TYPE_SEQUENCE_INVALID_SYNTAX 11
#define OBJ_TYPE_INDEX_UNNECESSARY      12
#define INVALID_SEQUENCE_OF             13
#define OBJ_TYPE_ZERO_IN_OID            14
#define ZERO_IN_OID                     14
#define OBJ_TYPE_DUPLICATE_OID          15
#define OBJ_TYPE_INVALID_DEFVAL         16
#define OBJ_TYPE_OID_RESOLUTION         17
#define TRAP_TYPE_ENTERPRISE_RESOLUTION 18
#define TRAP_TYPE_DUPLICATE_VALUES      19
#define TRAP_TYPE_VALUE_RESOLUTION      20
#define TRAP_TYPE_VARIABLES_RESOLUTION  21
#define VALUE_ASSIGN_MISMATCH           22
#define VALUE_ASSIGN_RESOLUTION         23
#define OID_NEGATIVE_INTEGER            24
#define OID_RESOLUTION                  25
#define OID_HEAD_ERROR                  26
#define IMPORT_UNUSED                   27
#define IMPORT_MODULE_ABSENT            28
#define IMPORT_CURRENT                  29
#define IMPORT_SYMBOL_ABSENT            30
#define IMPORT_KNOWN_WRONG_MODULE       31
#define ENUM_DUPLICATE_VALUE            32
#define ENUM_DUPLICATE_NAME             33
#define ENUM_ZERO_VALUE                 34
#define ENUM_NEGATIVE_VALUE             35
#define ENUM_RESOLUTION                 36
#define SIZE_TYPE_RESOLUTION            37
#define RANGE_TYPE_RESOLUTION           38
#define SIZE_INVALID_VALUE              39
#define SIZE_VALUE_RESOLUTION           40
#define RANGE_VALUE_RESOLUTION          41
#define RANGE_INVALID_BOUNDS            42
#define OBJ_TYPE_ACCESSIBLE_ROW         43
#define SYMBOL_REDEFINITION             44
#define KNOWN_REDEFINITION              45
#define KNOWN_UNDEFINED                 46
#define TYPE_UNREFERENCED               47
#define VALUE_UNREFERENCED              48
#define OBJ_TYPE_DEFVAL_NET_ADDR        49
#define SYMBOL_UNDEFINED                50
#define IMPORT_AMBIGUOUS_REFERENCE      51
#define OBJ_TYPE_DEFVAL_DISALLOWED      52
#define OBJ_TYPE_DEFVAL_RESOLUTION      53
#define OBJ_TYPE_INDEX_RESOLUTION       54
#define OBJ_TYPE_INDEX_SYNTAX           55
#define TYPE_UNRESOLVED                 56
#define VALUE_UNRESOLVED                57
#define SUBTYPE_ROOT_RESOLUTION         58
#define VALUE_ASSIGN_INVALID            60
#define RANGE_NEGATIVE_GAUGE            62
#define SIZE_INVALID_BOUNDS             63
#define SEQUENCE_ITEM_NO_OBJECT         64
#define SEQUENCE_TYPE_UNRESOLVED        65
#define INTEGER_TOO_BIG                 66
#define VALUE_ASSIGN_ENUM_INVALID       68
#define VALUE_ASSIGN_NEGATIVE_INTEGER   69
#define IR_MODULE_MISSING               70
#define IR_MODULE_MISSING_FATAL         70
#define IR_SYMBOL_MISSING               71
#define IR_SYMBOL_MISSING_FATAL         71
#define OBJ_TYPE_PRIMITIVE_CHILD        72
#define OBJ_TYPE_SEQUENCE_CHILD         73
#define OBJ_TYPE_SEQUENCE_NO_PARENT     74
#define OBJ_TYPE_SEQUENCE_EXTRA_CHILD   75
#define OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD 76
#define OBJ_TYPE_SEQUENCE_OF_SYNTAX_MISMATCH 77
#define OBJ_TYPE_SEQUENCE_OF_EXTRA_CHILD 78
#define STANDARD_AMBIGUOUS_REFERENCE    79
#define IR_MODULE_MISSING_WARNING       80
#define IR_SYMBOL_MISSING_WARNING       81
#define OBJ_IDENTITY_INVALID_STATUS     82
#define MODULE_NO_GROUPS                83
#define MODULE_IDENTITY_MISSING         84
#define MODULE_NO_GROUPS_V1             85
#define MODULE_NO_GROUPS_V2             86
#define TC_INVALID_STATUS               87
#define INVALID_BIT_VALUE               88
#define AUGMENTS_CLAUSE_RESOLUTION      89
#define IMPLIED_USELESS                 90
#define IMPLIED_FIXED_SIZE              91
#define IMPLIED_POSSIBLE_ZERO_SIZE      92
#define V1_ENUM_ONLY_INTEGER            93
#define V2_ENUM_ROOT_RESOLUTION         94
#define V2_ENUM_CLOSURE                 95
#define V2_BITS_ROOT_RESOLUTION         96
#define BITS_VALUE_RESOLUTION           97
#define BITS_DUPLICATE_VALUE            98
#define BITS_DUPLICATE_NAME             99
#define ENUM_OR_BITS_RESOLUTION         100
#define RANGE_BIG_RANGE                 101
#define NOTIFICATION_TYPE_INVALID_STATUS 102
#define OBJECT_IDENTITY_VALUE_RESOLUTION 103
#define NOTIFICATION_TYPE_VALUE_RESOLUTION 104
#define NOTIFICATION_TYPE_OBJECTS_RESOLUTION 105
#define NOTIFICATION_TYPE_UNACCESSIBLE_OBJECT 106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsy\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\yyparse.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifdef YYTRACE
#define YYDEBUG 1
#else
#ifndef YYDEBUG
#define YYDEBUG $Y
#endif
#endif
$@
$H
// C++ YACC parser header
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// $p_parse => class defining a parsing object
//	$p_parse needs a class yy_scan, which defines the scanner.
// %prefix or option -p xx determines name of this class; if not used,
// defaults to 'yy_scan'
//
// constructor fills in the tables for this grammar; give it a size
//    to determine size of state and value stacks. Default is 150 entries.
// destructor discards those state and value stacks
//
// int yy_parse::yyparse(yy_scan *) invokes parse; if this returns,
//	it can be recalled to continue parsing at last point.
// void yy_parse::yyreset() can be called to reset the parse;
//	call yyreset() before $p_parse::yyparse(yy_scan *)
#include <stdio.h>		// uses printf(), et cetera
#include <stdlib.h>		// uses exit()

const YYERRCODE = 256;		// YACC 'error' value

// You can use these macros in your action code
#define YYERROR		goto yyerrlabel
#define YYACCEPT	YYRETURN(0)
#define YYABORT		YYRETURN(1)
#define YYRETURN(val)	return(val)

#if YYDEBUG
typedef struct yyNamedType_tag {	/* Tokens */
	char	* name;		/* printable name */
	short	token;		/* token # */
	short	type;		/* token type */
} yyNamedType;
typedef struct yyTypedRules_tag {	/* Typed rule table */
	char	* name;		/* compressed rule string */
	short	type;		/* rule result type */
} yyTypedRules;
#endif

#ifdef YACC_WINDOWS

// include all windows prototypes, macros, constants, etc.

#include "precomp.h"

// the following is the handle to the current
// instance of a windows program. The user
// program calling yyparse must supply this!

extern HANDLE hInst;	

#endif	/* YACC_WINDOWS */


class $p_parse {
protected:

#ifdef YACC_WINDOWS

	// protected member function for actual scanning 

	int	win_yyparse($p_scan * ps);	// parse with given scanner

#endif	/* YACC_WINDOWS */

	int	mustfree;	// set if tables should be deleted
	int	size;		// size of state and value stacks
	int	reset;		// if set, reset state
	short	yyi;		// table index
	short	yystate;	// current state

	short	* stateStack;	// states stack
	YYSTYPE	* valueStack;	// values stack
	short	* yyps;		// top of state stack
	YYSTYPE * yypv;		// top of value stack

	YYSTYPE yylval;		// saved yylval
	YYSTYPE	yyval;		// $$
	YYSTYPE * yypvt;	// $n
	int	yychar;		// current token
	int	yyerrflag;	// error flag
	int	yynerrs;	// error count
#if YYDEBUG
	int	done;		// set from trace to stop parse
	int	rule, npop;	// reduction rule # and length
	short	* typeStack;	// type stack to mirror valueStack[]
	short	* yytp;		// top of type stack
	char	* yygetState(int);	// read 'states.out'
#endif
public:
#if YYDEBUG
	// C++ has trouble with initialized arrays inside classes
	static long * States;		// pointer to yyStates[]
	static yyTypedRules * Rules;	// pointer to yyRules[]
	static yyNamedType * TokenTypes; // pointer to yyTokenTypes[]
	static int	yyntoken;	// number of tokens
	static int	yynvar;		// number of variables (nonterminals)
	static int	yynstate;	// number of YACC-generated states
	static int	yynrule;	// number of rules in grammar

	char*	yyptok(int);		// printable token string
	int	yyExpandName(int, int, char *, int);
						// expand encoded string
	virtual int	yyGetType(int);		// return type of token
	virtual void	yyShowRead();		// see newly read token
	virtual void	yyShowState();		// see state, value stacks
	virtual void	yyShowReduce();		// see reduction
	virtual void	yyShowGoto();		// see goto
	virtual void	yyShowShift();		// see shift
	virtual void	yyShowErrRecovery();	// see error recovery
	virtual void	yyShowErrDiscard();	// see token discard in error
#endif
	$p_scan* scan;			// pointer to scanner
	int	yydebug;	// if set, tracing if compiled with YYDEBUG=1

	$p_parse(int = 150);	// constructor for this grammar
	$p_parse(int, short *, YYSTYPE *);	// another constructor

	~$p_parse();		// destructor

	int	yyparse($p_scan * ps);	// parse with given scanner

	void	yyreset() { reset = 1; } // restore state for next yyparse()

	void	setdebug(int y) { yydebug = y; }

// The following are useful in user actions:

	void	yyerrok() { yyerrflag = 0; }	// clear error
	void	yyclearin() { yychar = -1; }	// clear input
	int	YYRECOVERING() { return yyerrflag != 0; }
};
// end of .hpp header
$E

$L#line 2 "$P"
// C++ YACC parser code
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// If YYDEBUG is defined as 1 and yy_parse::yydebug is set to 1,
// yyparse() will print a travelogue of its actions as it reads
// and parses input.
//
// YYSYNC can be defined to cause yyparse() to attempt to always
// hold a lookahead token

const YY_MIN_STATE_NUM = 20;	// not useful to be too small!

#if YYDEBUG
#ifdef YYTRACE
long	* $p_parse::States	= yyStates;
#endif
yyTypedRules * $p_parse::Rules	= yyRules;
yyNamedType * $p_parse::TokenTypes = yyTokenTypes;

#define YY_TRACE(fn) { done = 0; fn(); if (done) YYRETURN(-1); }
#endif

// Constructor for $p_parse: user-provided tables
$p_parse::$p_parse(int sz, short * states, YYSTYPE * stack)
{
	mustfree = 0;
	if ((size = sz) < YY_MIN_STATE_NUM
	 || (stateStack = states) == (short *) 0
	 || (valueStack = stack) == (YYSTYPE *) 0) {
		fprintf(stderr,"Bad state/stack given");
		exit(1);
	}
	reset = 1;		// force reset
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
	if (typeStack == (short *) 0) {
		fprintf(stderr,"Cannot allocate typeStack");
		exit(1);
	}
#endif
}
// Constructor for $p_parse: allocate tables with new
$p_parse::$p_parse(int sz)
{
	size = sz;
	reset = 1;		// force reset
	mustfree = 1;		// delete space in deconstructor
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
#endif
	stateStack = new short[size+1];
	valueStack = new YYSTYPE[size+1];

	if (stateStack == (short *) 0 || valueStack == (YYSTYPE *) 0
#if YYDEBUG
		|| typeStack == (short *) 0
#endif
	    ) {
		fprintf(stderr,"Not enough space for parser stacks");
		exit(1);
	}
}
// Destructor for class $p_parse
//	Free up space
$p_parse::~$p_parse()
{
	if (mustfree) {
		delete stateStack;
		delete valueStack;
	}
	stateStack = (short *) 0;
#if YYDEBUG
	delete typeStack;
#endif
}

#ifdef YACC_WINDOWS

// The initial portion of the yacc parser.
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_yyparse() to acutally begin the
// parsing. When complete, win_yyparse() will return a
// value back to our new yyparse() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of yyparse().

int
$p_parse::yyparse($p_scan* ps)
{
	int wReturnValue;
	HANDLE hRes_table;
	short *old_yydef;		// the following are used for saving
	short *old_yyex;		// the current pointers
	short *old_yyact;
	short *old_yypact;
	short *old_yygo;
	short *old_yypgo;
	short *old_yyrlen;

	// the following code will load the required
	// resources for a Windows based parser.

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_yyYACC", "yyYACCTBL"));
	
	// return an error code if any
	// of the resources did not load

	if (hRes_table == (HANDLE)NULL)
		return (1);
	
	// the following code will lock the resources
	// into fixed memory locations for the parser
	// (also, save away the old pointer values)

	old_yydef = yydef;
	old_yyex = yyex;
	old_yyact = yyact;
	old_yypact = yypact;
	old_yygo = yygo;
	old_yypgo = yypgo;
	old_yyrlen = yyrlen;

	yydef = (short *)LockResource (hRes_table);
	yyex = (short *)(yydef + Sizeof_yydef);
	yyact = (short *)(yyex + Sizeof_yyex);
	yypact = (short *)(yyact + Sizeof_yyact);
	yygo = (short *)(yypact + Sizeof_yypact);
	yypgo = (short *)(yygo + Sizeof_yygo);
	yyrlen = (short *)(yypgo + Sizeof_yypgo);

	// call the official yyparse() function

	wReturnValue = win_yyparse (ps);

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previous pointer values
	//

	yydef = old_yydef;
	yyex = old_yyex;
	yyact = old_yyact;
	yypact = old_yypact;
	yygo = old_yygo;
	yypgo = old_yypgo;
	yyrlen = old_yyrlen;

	return (wReturnValue);
}	// end yyparse()


// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling yyparse().
//	Call yyreset() before yyparse() if you want a fresh start

int
$p_parse::win_yyparse($p_scan* ps)

#else /* YACC_WINDOWS */

// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling yyparse().
//	Call yyreset() before yyparse() if you want a fresh start
int
$p_parse::yyparse($p_scan* ps)

#endif /* YACC_WINDOWS */

{
	short	* yyp, * yyq;		// table lookup
	int	yyj;
#if YYDEBUG
	int	yyruletype = 0;
#endif
$A
	if ((scan = ps) == ($p_scan *) 0) {	// scanner
		fprintf(stderr,"No scanner");
		exit(1);
	}

	if (reset) {			// start new parse
		yynerrs = 0;
		yyerrflag = 0;
		yyps = stateStack;
		yypv = valueStack;
#if YYDEBUG
		yytp = typeStack;
#endif
		yystate = YYS0;
		yyclearin();
		reset = 0;
	} else			// continue saved parse
		goto yyNext;			// after action

yyStack:
	if (++yyps > &stateStack[size]) {
		scan->yyerror("Parser stack overflow");
		YYABORT;
	}
	*yyps = yystate;	/* stack current state */
	*++yypv = yyval;	/* ... and value */
#if YYDEBUG
	if (yydebug) {
		*++yytp = yyruletype;	/* ... and type */
		YY_TRACE(yyShowState)
	}
#endif

	/*
	 * Look up next action in action table.
	 */
yyEncore:
#ifdef YYSYNC
	if (yychar < 0) {
		if ((yychar = scan->yylex()) < 0) {
			if (yychar == -2) YYABORT;
			yychar = 0;
		}	/* endif */
		yylval = ::yylval;
#if YYDEBUG
		if (yydebug)
			yyShowRead();	// show new input token
#endif
	}
#endif
#ifdef YACC_WINDOWS
	if (yystate >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
	if (yystate >= sizeof yypact/sizeof yypact[0]) 	/* simple state */
#endif /* YACC_WINDOWS */
		yyi = yystate - YYDELTA;	/* reduce in any case */
	else {
		if(*(yyp = &yyact[yypact[yystate]]) >= 0) {
			/* Look for a shift on yychar */
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			yyq = yyp;
			yyi = yychar;
			while (yyi < *yyp++)
				;
			if (yyi == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
#if YYDEBUG
				if (yydebug) {
					yyruletype = yyGetType(yychar);
					YY_TRACE(yyShowShift)
				}
#endif
				yyval = yylval;		/* stack value */
				yyclearin();		/* clear token */
				if (yyerrflag)
					yyerrflag--;	/* successful shift */
				goto yyStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

#ifdef YACC_WINDOWS
		if (yystate >= Sizeof_yydef) 	/* simple state */
#else /* YACC_WINDOWS */
		if (yystate >= sizeof yydef /sizeof yydef[0])
#endif /* YACC_WINDOWS */
			goto yyError;
		if ((yyi = yydef[yystate]) < 0)	 { /* default == reduce? */

			/* Search exception table */
			yyp = &yyex[~yyi];
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			while((yyi = *yyp) >= 0 && yyi != yychar)
				yyp += 2;
			yyi = yyp[1];
		}
	}

	yyj = yyrlen[yyi];

#if YYDEBUG
	if (yydebug) {
		npop = yyj; rule = yyi;
		YY_TRACE(yyShowReduce)
		yytp -= yyj;
	}
#endif
	yyps -= yyj;		/* pop stacks */
	yypvt = yypv;		/* save top */
	yypv -= yyj;
	yyval = yypv[1];	/* default action $$ = $1 */
#if YYDEBUG
	if (yydebug)
		yyruletype = yyRules[yyrmap[yyi]].type;
#endif
	switch (yyi) {		/* perform semantic action */
		$A
$L#line 343 "$P"
	case YYrACCEPT:
		YYACCEPT;
	case YYrERROR:
		goto yyError;
	}
yyNext:
	/*
	 *	Look up next state in goto table.
	 */

	yyp = &yygo[yypgo[yyi]];
	yyq = yyp++;
	yyi = *yyps;
	while (yyi < *yyp++)		/* busy little loop */
		;
	yystate = ~(yyi == *--yyp? yyq[yyq-yyp]: *yyq);
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowGoto)
#endif
	goto yyStack;

yyerrlabel:	;		/* come here from YYERROR	*/
	yyerrflag = 1;
	if (yyi == YYrERROR) {
		yyps--, yypv--;
#if YYDEBUG
		if (yydebug) yytp--;
#endif
	}
	
yyError:
	switch (yyerrflag) {

	case 0:		/* new error */
		yynerrs++;
		yyi = yychar;
		scan->yyerror("Syntax error");
		if (yyi != yychar) {
			/* user has changed the current token */
			/* try again */
			yyerrflag++;	/* avoid loops */
			goto yyEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		yyerrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; yyps > stateStack; yyps--, yypv--
#if YYDEBUG
					, yytp--
#endif
		) {
#ifdef YACC_WINDOWS
			if (*yyps >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
			if (*yyps >= sizeof yypact/sizeof yypact[0])
#endif /* YACC_WINDOWS */
				continue;
			yyp = &yyact[yypact[*yyps]];
			yyq = yyp;
			do
				;
			while (YYERRCODE < *yyp++);
			if (YYERRCODE == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
				goto yyStack;
			}
				
			/* no shift in this state */
#if YYDEBUG
			if (yydebug && yyps > stateStack+1)
				YY_TRACE(yyShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (yychar == 0)  /* but not EOF */
			break;
#if YYDEBUG
		if (yydebug)
			YY_TRACE(yyShowErrDiscard)
#endif
		yyclearin();
		goto yyEncore;	/* try again in same state */
	}
	YYABORT;

}
#if YYDEBUG
/*
 * Return type of token
 */
int
$p_parse::yyGetType(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}

	
// Print a token legibly.
char *
$p_parse::yyptok(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}
/*
 * Read state 'num' from YYStatesFile
 */
#ifdef YYTRACE

char *
yy_parse::yygetState(int num)
{
	int	size;
	char	*cp;
	static FILE *yyStatesFile = (FILE *) 0;
	static char yyReadBuf[YYMAX_READ+1];

	if (yyStatesFile == (FILE *) 0
	 && (yyStatesFile = fopen(YYStatesFile, "r")) == (FILE *) 0)
		return "yyExpandName: cannot open states file";

	if (num < yynstate - 1)
		size = (int)(States[num+1] - States[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(yyStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(yyStatesFile) - States[num]);
	}
	if (size < 0 || size > YYMAX_READ)
		return "yyExpandName: bad read size";
	if (fseek(yyStatesFile, States[num], 0) < 0) {
	cannot_seek:
		return "yyExpandName: cannot seek in states file";
	}

	(void) fread(yyReadBuf, 1, size, yyStatesFile);
	yyReadBuf[size] = '\0';
	return yyReadBuf;
}
#endif /* YYTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode yyStates and yyRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
$p_parse::yyExpandName(int num, int isrule, char * buf, int len)
{
	int	i, n, cnt, type;
	char	* endp, * cp, * s;

	if (isrule)
		s = yyRules[num].name;
	else
#ifdef YYTRACE
		s = yygetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = yynvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = yyntoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= yynvar)
					goto too_big;
				cp = yysvar[n];
			} else if (n >= yyntoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = yyTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef YYTRACE
/*
 * Show current state of yyparse
 */
void
$p_parse::yyShowState()
{
	(void) printf("state %d (%d), char %s (%d)\n%d stateStack entries\n",
		yysmap[yystate],yystate,yyptok(yychar),yychar,
		yypv - valueStack);
}
// show results of reduction: yyi is rule number
void
$p_parse::yyShowReduce()
{
	(void) printf("Reduce by rule %d (pop#=%d)\n", yyrmap[rule], npop);
}
// show read token
void
$p_parse::yyShowRead()
{
	(void) printf("read %s (%d)\n", yyptok(yychar), yychar);
}
// show Goto
void
$p_parse::yyShowGoto()
{
	(void) printf("goto %d (%d)\n", yysmap[yystate], yystate);
}
// show Shift
void
$p_parse::yyShowShift()
{
	(void) printf("shift %d (%d)\n", yysmap[yystate], yystate);
}
// show error recovery
void
$p_parse::yyShowErrRecovery()
{
	(void) printf("Error recovery pops state %d (%d), uncovers %d (%d)\n",
		yysmap[*(yyps-1)], *(yyps-1), yysmap[yystate], yystate);
}
// show token discards in error processing
void
$p_parse::yyShowErrDiscard()
{
	(void) printf("Error recovery discards %s (%d), ",
		yyptok(yychar), yychar);
}
#endif	/* ! YYTRACE */
#endif	/* YYDEBUG */
$T
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\typeref.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "typeRef.hpp"




void SIMCDefinedTypeReference::WriteSymbol( ostream& outStream ) const
{
	outStream << "DefinedTypeReference " ;
	SIMCSymbol::WriteSymbol(outStream);

	outStream << "TYPE DETAILS "  ;
	(*_type)->WriteBrief(outStream);
	outStream << endl;

	switch(_status)
	{
		case RESOLVE_UNSET:
			outStream << "UNSET RESOLUTION" << endl;
			break;
		case RESOLVE_UNDEFINED:
			outStream << "UNDEFINED RESOLUTION" << endl;
			break;
		case RESOLVE_IMPORT:
			outStream << "RESOLVES TO IMPORT" << endl;
			break;
		case RESOLVE_CORRECT:
			outStream << "RESOLVES TO " << _realType->GetSymbolName()
				<< endl;
			break;
	}
}


SIMCTextualConvention::SIMCTextualConvention(const char * const displayHint,
	SIMCTCStatusType status,
	long statusLine, long statusColumn,
	const char * const description,
	const char * const reference,
	SIMCSymbol **type,
	long typeLine,
	long typeColumn,
	const char * const symbolName,
	SymbolType symbolType,
	SIMCModule *module,
	long lineNumber, long columnNumber,
	long referenceCount)
	: _statusLine(statusLine), _statusColumn(statusColumn),
		SIMCDefinedTypeReference( type, typeLine, typeColumn,
			symbolName, symbolType, module, lineNumber, columnNumber,
			referenceCount)
{
   _displayHint = NewString(displayHint);
   _status = status;
   _description = NewString(description);
   _reference = NewString(reference);
}

SIMCTextualConvention::SIMCTCStatusType SIMCTextualConvention::StringToStatusType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "current") == 0)
			return TC_CURRENT;
		else if (strcmp(s, "deprecated") == 0)
			return TC_DEPRECATED;
		else if (strcmp(s, "obsolete") == 0)
			return TC_OBSOLETE;
		else
			return TC_INVALID;
	}
	return TC_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsy\resource.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by smierrsy.rc
//
#define SYNTAX_CLAUSE                   1
#define ACCESS_CLAUSE                   2
#define STATUS_CLAUSE                   3
#define DESCRIPTION_CLAUSE              4
#define REFERENCE_CLAUSE                5
#define INDEX_CLAUSE                    6
#define DEFVAL_CLAUSE                   7
#define SKIPPING_OBJECT_TYPE            8
#define ENTERPRISE_CLAUSE               9
#define VARIABLES_CLAUSE                10
#define SKIPPING_TRAP_TYPE              11
#define SEQUENCE_DEFINITION             12
#define OBJECT_IDENTIFIER_VALUE         13
#define LIST_IN_IMPORTS                 14
#define MISSING_MODULE_NAME             15
#define IMPORTS_SECTION                 16
#define INTEGER_ENUMERATION             17
#define SUB_TYPE_SPECIFICATION          18
#define SIZE_SPECIFICATION              19
#define V2_OBJECT_TYPE_DISALLOWED       20
#define NOTIFICATION_TYPE_DISALLOWED    22
#define MODULE_IDENTITY_DISALLOWED      23
#define OBJECT_IDENTITY_DISALLOWED      24
#define TEXTUAL_CONVENTION_DISALLOWED   25
#define OBJECT_GROUP_DISALLOWED         26
#define NOTIFICATION_GROUP_DISALLOWED   27
#define MODULE_COMPLIANCE_DISALLOWED    28
#define AGENT_CAPABILITIES_DISALLOWED   29
#define INSTEAD_OF_CCE                  30
#define SYNTAX_ERROR_MAX                31
#define ERROR_OBJECT_TYPE               31
#define SYNTAX_ERROR_MAX1               32
#define MAX_SYNTAX_ERROR                32
#define V1_OBJECT_TYPE_DISALLOWED       32
#define V1_TRAP_TYPE_DISALLOWED         33
#define MODULE_IDENTITY_ONLY_AFTER_IMPORTS 34
#define UNRECOGNIZED_CHARACTER          35
#define TOO_BIG_NUM                     36
#define UNTERMINATED_STRING             37
#define OBJECTS_CLAUSE                  38
#define NAME_INSTEAD_OF_ID              39

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\yylex.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <stdio.h>		// uses printf(), et cetera
#include <stdarg.h>		// uses va_list
#include <stdlib.h>		// uses exit()
#include <string.h>		// uses memmove()

#ifdef LEX_WINDOWS

// define, if not already defined
// the flag YYEXIT, which will allow
// graceful exits from yylex()
// without resorting to calling exit();

#ifndef YYEXIT
#define YYEXIT	1
#endif // YYEXIT

// include the windows specific prototypes, macros, etc

#include "precomp.h"

// the following is the handle to the current
// instance of a windows program. The user
// program calling yylex must supply this!

extern HANDLE hInst;	

#endif /* LEX_WINDOWS */

class yy_scan {
protected:

#ifdef LEX_WINDOWS

	// protected member function for actual scanning 

	int win_yylex();

#endif /* LEX_WINDOWS */

	yy_state_t * state;		// state buffer
	int	size;			// length of state buffer
	int	mustfree;		// set if space is allocated
	int	yy_end;			// end of pushback
	int	yy_start;		// start state
	int	yy_lastc;		// previous char
#ifdef YYEXIT
	int yyLexFatal;		// Lex Fatal Error Flag
#endif // YYEXIT
#ifndef YY_PRESERVE	// efficient default push-back scheme
	char save;		// saved yytext[yyleng]
#else			// slower push-back for yytext mungers
	char *save;		// saved yytext[]
	char *push;
#endif

public:
	char   *yytext;		// yytext text buffer
	FILE   *yyin;			// input stream
	FILE   *yyout;			// output stream
	int	yylineno;		// line number
	int	yyleng;			// yytext token length

	yy_scan(int = 100);	// constructor for this scanner
			// default token & pushback size is 100 bytes
	yy_scan(int, char*, char*, yy_state_t*);
				// constructor when tables are given

	~yy_scan();		// destructor

	int	yylex();		// begin a scan

	virtual int	yygetc() {	// scanner source of input characters
		return getc(yyin);
	}

	virtual int	yywrap() { return 1; }	// EOF processing

	virtual void	yyerror(char *,...);	// print error message

	virtual void	output(int c) { putc(c, yyout); }

#ifdef YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and set error flag
		yyerror(msg); yyLexFatal = 1;
	}
#else // YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and stop
		yyerror(msg); exit(1);
	}
#endif // YYEXIT
	virtual void	ECHO() {		// print matched input
		fputs((const char *) yytext, yyout);
	}
	int	input();		// user-callable get-input
	int	unput(int c);		// user-callable unput character
	void	yy_reset();		// reset scanner
	void	setinput(FILE * in) {		// switch input streams
		yyin = in;
	}
	void	setoutput(FILE * out) {	// switch output
		yyout = out;
	}
	void	NLSTATE() { yy_lastc = YYNEWLINE; }
	void	YY_INIT() {
		yy_start = 0;
		yyleng = yy_end = 0;
		yy_lastc = YYNEWLINE;
	}
	void	YY_USER() {		// set up yytext for user
#ifndef YY_PRESERVE
		save = yytext[yyleng];
#else
		size_t n = yy_end - yyleng;
		push = save+size - n;
		if (n > 0)
			memmove(push, yytext+yyleng, n);
#endif
		yytext[yyleng] = 0;
	}
	void YY_SCANNER() {		// set up yytext for scanner
#ifndef YY_PRESERVE
		yytext[yyleng] = save;
#else
		size_t n = save+size - push;
		if (n > 0)
			memmove(yytext+yyleng, push, n);
		yy_end = yyleng + n;
#endif
	}
	void	yyless(int n) {		// trim input to 'n' bytes
		if (n >= 0 && n <= yy_end) {
			YY_SCANNER();
			yyleng = n;
			YY_USER();
		}
	}
	void	yycomment(char *const mat); // skip comment input
	int	yymapch(int delim, int escape);	// map C escapes
} ;
@ END OF HEADER @
// MKS LEX prototype scanner code
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can redefine YY_INTERACTIVE to be 0 to get a very slightly
// faster scanner:
#ifndef YY_INTERACTIVE
#define	YY_INTERACTIVE	1
#endif

// You can compile with -DYY_DEBUG to get a print trace of the scanner
#ifdef YY_DEBUG
#undef YY_DEBUG
#define YY_DEBUG(fmt,a1,a2)	fprintf(stderr,fmt,a1,a2)
#else
#define YY_DEBUG(fmt,a1,a2)
#endif

const MIN_NUM_STATES = 20;

// Do *NOT* redefine the following:
#define	BEGIN		yy_start =
#define	REJECT		goto yy_reject
#define	yymore()	goto yy_more

@ GLOBAL DECLARATIONS @

// Constructor for yy_scan. Set up tables
#pragma argsused
yy_scan::yy_scan(int sz, char* buf, char* sv, yy_state_t* states)
{
	mustfree = 0;
	if ((size = sz) < MIN_NUM_STATES
	  || (yytext = buf) == 0
	  || (state = states) == 0) {
		yyerror("Bad space for scanner!");
		exit(1);
	}
#ifdef YY_PRESERVE
	save = sv;
#endif
}
// Constructor for yy_scan. Set up tables
yy_scan::yy_scan(int sz)
{
	size = sz;
	yytext = new char[sz+1];	// text buffer
	state = new yy_state_t[sz+1];	// state buffer
#ifdef YY_PRESERVE
	save = new char[sz];	// saved yytext[]
	push = save + sz;
#endif
	if (yytext == NULL
#ifdef YY_PRESERVE
	  || save == NULL
#endif
	  || state == NULL) {
		yyerror("No space for scanner!");
		exit(1);
	}
	mustfree = 1;
	yy_end = 0;
	yy_start = 0;
	yy_lastc = YYNEWLINE;
	yyin = stdin;
	yyout = stdout;
	yylineno = 1;
	yyleng = 0;
}

// Descructor for yy_scan
yy_scan::~yy_scan()
{
	if (mustfree) {
		mustfree = 0;
		delete(yytext);
		delete(state);
#ifdef YY_PRESERVE
		delete(save);
#endif
	}
}

// Print error message, showing current line number
void
yy_scan::yyerror(char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
#ifdef LEX_WINDOWS
	// Windows has no concept of a standard error output!
	// send output to yyout as a simple solution
	if (yylineno)
		fprintf(yyout, "%d: ", yylineno);
	(void) vfprintf(yyout, fmt, va);
	fputc('\n', yyout);
#else /* LEX_WINDOWS */
	if (yylineno)
		fprintf(stderr, "%d: ", yylineno);
	(void) vfprintf(stderr, fmt, va);
	fputc('\n', stderr);
#endif /* LEX_WINDOWS */
	va_end(va);
}


#ifdef LEX_WINDOWS

// The initial portion of the lex scanner
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_yylex() to acutally begin the
// scanning. When complete, win_yylex() will return a
// value back to our new yylex() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of yylex().

int
yy_scan::yylex()
{
	int wReturnValue;
	HANDLE hRes_table;
	unsigned short *old_yy_la_act;	// remember previous pointer values
	short *old_yy_final;
	yy_state_t *old_yy_begin;
	yy_state_t *old_yy_next;
	yy_state_t *old_yy_check;
	yy_state_t *old_yy_default;
	short *old_yy_base;

	// the following code will load the required
	// resources for a Windows based parser. 

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_yyLEX", "yyLEXTBL"));
	
	// return an error code if any
	// of the resources did not load 

	if (hRes_table == (HANDLE)NULL) 
		return (0);
	
	// the following code will lock the resources
	// into fixed memory locations for the scanner
	// (remember previous pointer locations)

	old_yy_la_act = yy_la_act;
	old_yy_final = yy_final;
	old_yy_begin = yy_begin;
	old_yy_next = yy_next;
	old_yy_check = yy_check;
	old_yy_default = yy_default;
	old_yy_base = yy_base;

	yy_la_act = (unsigned short *)LockResource (hRes_table);
	yy_final = (short *)(yy_la_act + Sizeof_yy_la_act);
	yy_begin = (yy_state_t *)(yy_final + Sizeof_yy_final);
	yy_next = (yy_state_t *)(yy_begin + Sizeof_yy_begin);
	yy_check = (yy_state_t *)(yy_next + Sizeof_yy_next);
	yy_default = (yy_state_t *)(yy_check + Sizeof_yy_check);
	yy_base = (short *)(yy_default + Sizeof_yy_default);


	// call the standard yylex() code

	wReturnValue = win_yylex();

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previously saved pointers
	//

	yy_la_act = old_yy_la_act;
	yy_final = old_yy_final;
	yy_begin = old_yy_begin;
	yy_next = old_yy_next;
	yy_check = old_yy_check;
	yy_default = old_yy_default;
	yy_base = old_yy_base;

	return (wReturnValue);
}	// end yylex()

// The actual lex scanner
// yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
// yytext[0:yyleng-1] contains the current token.
// yytext[yyleng:yy_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains yytext[yyleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 

int 
yy_scan::win_yylex()

#else /* LEX_WINDOWS */

// The actual lex scanner
// yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
// yytext[0:yyleng-1] contains the current token.
// yytext[yyleng:yy_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains yytext[yyleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 
int
yy_scan::yylex()
#endif /* LEX_WINDOWS */

{
	int c, i, yybase;
	unsigned  yyst;		/* state */
	int yyfmin, yyfmax;	/* yy_la_act indices of final states */
	int yyoldi, yyoleng;	/* base i, yyleng before look-ahead */
	int yyeof;		/* 1 if eof has already been read */
@ LOCAL DECLARATIONS @

#ifdef YYEXIT
	yyLexFatal = 0;
#endif
	yyeof = 0;
	i = yyleng;
	YY_SCANNER();

  yy_again:
	if ((yyleng = i) > 0) {
		yy_lastc = yytext[i-1];	// determine previous char
		while (i > 0)	//	// scan previously token
			if (yytext[--i] == YYNEWLINE)	// fix yylineno
				yylineno++;
	}
	yy_end -= yyleng;		// adjust pushback
	memmove(yytext, yytext+yyleng, (size_t) yy_end);
	i = 0;

  yy_contin:
	yyoldi = i;

	/* run the state machine until it jams */
	yyst = yy_begin[yy_start + (yy_lastc == YYNEWLINE)];
	state[i] = (yy_state_t) yyst;
	do {
		YY_DEBUG("<state %d, i = %d>\n", yyst, i);
		if (i >= size) {
			YY_FATAL("Token buffer overflow");
#ifdef YYEXIT
			if (yyLexFatal)
				return -2;
#endif
		}	/* endif */

		/* get input char */
		if (i < yy_end)
			c = yytext[i];		/* get pushback char */
		else if (!yyeof && (c = yygetc()) != EOF) {
			yy_end = i+1;
			yytext[i] = c;
		} else /* c == EOF */ {
			c = EOF;		/* just to make sure... */
			if (i == yyoldi) {	/* no token */
				yyeof = 0;
				if (yywrap())
					return 0;
				else
					goto yy_again;
			} else {
				yyeof = 1;	/* don't re-read EOF */
				break;
			}
		}
		YY_DEBUG("<input %d = 0x%02x>\n", c, c);

		/* look up next state */
		while ((yybase = yy_base[yyst]+(unsigned char)c) > yy_nxtmax
		    || yy_check[yybase] != (yy_state_t) yyst) {
			if (yyst == yy_endst)
				goto yy_jammed;
			yyst = yy_default[yyst];
		}
		yyst = yy_next[yybase];
	  yy_jammed: ;
	     state[++i] = (yy_state_t) yyst;
	} while (!(yyst == yy_endst || YY_INTERACTIVE &&
		yy_base[yyst] > yy_nxtmax && yy_default[yyst] == yy_endst));

	YY_DEBUG("<stopped %d, i = %d>\n", yyst, i);
	if (yyst != yy_endst)
		++i;

  yy_search:
	/* search backward for a final state */
	while (--i > yyoldi) {
		yyst = state[i];
		if ((yyfmin = yy_final[yyst]) < (yyfmax = yy_final[yyst+1]))
			goto yy_found;	/* found final state(s) */
	}
	/* no match, default action */
	i = yyoldi + 1;
	output(yytext[yyoldi]);
	goto yy_again;

  yy_found:
	YY_DEBUG("<final state %d, i = %d>\n", yyst, i);
	yyoleng = i;		/* save length for REJECT */
	
	// pushback look-ahead RHS, handling trailing context
	if ((c = (int)(yy_la_act[yyfmin]>>9) - 1) >= 0) {
		unsigned char *bv = yy_look + c*YY_LA_SIZE;
		static unsigned char bits [8] = {
			1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7
		};
		while (1) {
			if (--i < yyoldi) {	/* no / */
				i = yyoleng;
				break;
			}
			yyst = state[i];
			if (bv[(unsigned)yyst/8] & bits[(unsigned)yyst%8])
				break;
		}
	}

	/* perform action */
	yyleng = i;
	YY_USER();
	switch (yy_la_act[yyfmin] & 0777) {
@ ACTION CODE @
	}
	YY_SCANNER();
	i = yyleng;
	goto yy_again;			/* action fell though */

  yy_reject:
	YY_SCANNER();
	i = yyoleng;			/* restore original yytext */
	if (++yyfmin < yyfmax)
		goto yy_found;		/* another final state, same length */
	else
		goto yy_search;		/* try shorter yytext */

  yy_more:
	YY_SCANNER();
	i = yyleng;
	if (i > 0)
		yy_lastc = yytext[i-1];
	goto yy_contin;
}

/*
 * user callable input/unput functions.
 */
void
yy_scan::yy_reset()
{
	YY_INIT();
	yylineno = 1;
}
/* get input char with pushback */
int
yy_scan::input()
{
	int c;
#ifndef YY_PRESERVE
	if (yy_end > yyleng) {
		yy_end--;
		memmove(yytext+yyleng, yytext+yyleng+1,
			(size_t) (yy_end-yyleng));
		c = save;
		YY_USER();
#else
	if (push < save+size) {
		c = *push++;
#endif
	} else
		c = yygetc();
	yy_lastc = c;
	if (c == YYNEWLINE)
		yylineno++;
	return c;
}

/* pushback char */
int
yy_scan::unput(int c)
{
#ifndef YY_PRESERVE
	if (yy_end >= size) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		if (yy_end > yyleng) {
			yytext[yyleng] = save;
			memmove(yytext+yyleng+1, yytext+yyleng,
				(size_t) (yy_end-yyleng));
			yytext[yyleng] = 0;
		}
		yy_end++;
		save = c;
#else
	if (push <= save) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		*--push = c;
#endif
		if (c == YYNEWLINE)
			yylineno--;
	}	/* endif */
	return c;
}

@ end of yylex.cpp @
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smimsgif\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\ytab.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifdef YYTRACE
#define YYDEBUG 1
#else
#ifndef YYDEBUG
#define YYDEBUG 1
#endif
#endif


#include <iostream.h>
#include <fstream.h>

#include <typeinfo.h>

#include "precomp.h"
#include <snmptempl.h>


#include "smierrsy.hpp"
#include "smierrsm.hpp"

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>

#include "scanner.hpp"
#include "parser.hpp"


#define theScanner  (((SIMCParser *) this)->_theScanner)
#define theParser	((SIMCParser *) this)
#define theModule	(theParser->GetModule())

static SIMCModule * newImportModule = new SIMCModule;
static SIMCOidComponentList * newOidComponentList = new SIMCOidComponentList;
static SIMCBitValueList * newNameList = new SIMCBitValueList;
static SIMCIndexList *newIndexList = new SIMCIndexList;
static SIMCIndexListV2 *newIndexListV2 = new SIMCIndexListV2;
static SIMCVariablesList *newVariablesList = new SIMCVariablesList;
static SIMCObjectsList *newObjectsList = new SIMCObjectsList;
static SIMCRangeList *newRangeList = new SIMCRangeList;
static SIMCNamedNumberList *newNamedNumberList = new SIMCNamedNumberList;
static SIMCSequenceList *newSequenceList = new SIMCSequenceList;
static BOOL firstAssignment = TRUE;

static long HexCharToDecimal(char x)
{
	switch(x)
	{
		case '0':
			return 0;
		case '1':
			return 1;
		case '2':
			return 2;
		case '3':
			return 3;
		case '4':
			return 4;
		case '5':
			return 5;
		case '6':
			return 6;
		case '7':
			return 7;
		case '8':
			return 8;
		case '9':
			return 9;
		case 'a':
		case 'A':
			return 10;
		case 'b':
		case 'B':
			return 11;
		case 'c':
		case 'C':
			return 12;
		case 'd':
		case 'D':
			return 13;
		case 'e':
		case 'E':
			return 14;
		case 'f':
		case 'F':
			return 15;
	}
	return -1;
}

extern YYSTYPE yylval;
#if YYDEBUG
enum YY_Types { YY_t_NoneDefined, YY_t_yy_name, YY_t_yy_hex_string, YY_t_yy_binary_string, YY_t_yy_module, YY_t_yy_number, YY_t_yy_object_type, YY_t_yy_access, YY_t_yy_accessV2, YY_t_yy_status, YY_t_yy_statusV2, YY_t_yy_index, YY_t_yy_indexV2, YY_t_yy_variables_list, YY_t_yy_objects_list, YY_t_yy_symbol_ref, YY_t_yy_range_or_size_item, YY_t_yy_range_list, YY_t_yy_named_number_list, YY_t_yy_def_val, YY_t_yy_object_identity_status, YY_t_yy_notification_type_status
};
#endif
#if YYDEBUG
yyTypedRules yyRules[] = {
	{ "&000: %001 &000",  0},
	{ "%044:",  0},
	{ "%001: %005 %044 &021 %045 &006 %046 %047 &027",  0},
	{ "%005: &033",  1},
	{ "%005: &033 %025",  1},
	{ "%005: &049",  1},
	{ "%046: &036 %048 &065",  0},
	{ "%046: &036 &001 &065",  0},
	{ "%046: &036 %049 &065",  0},
	{ "%046: %050",  0},
	{ "%049: %051",  0},
	{ "%049: %050",  0},
	{ "%051: %051 %012",  0},
	{ "%051: %012",  0},
	{ "%012: %048 &032 %002",  4},
	{ "%012: &001 &032 %002",  4},
	{ "%002: &033 &040 %052 &060",  1},
	{ "%002: &033 &040 &001 &060",  1},
	{ "%002: &033",  1},
	{ "%048: %048 &013 %053",  0},
	{ "%048: %053",  0},
	{ "%053: &033",  0},
	{ "%053: &049",  0},
	{ "%053: %011",  0},
	{ "%011: &086",  1},
	{ "%011: &098",  1},
	{ "%011: &077",  1},
	{ "%011: &083",  1},
	{ "%011: &096",  1},
	{ "%011: &104",  1},
	{ "%011: &101",  1},
	{ "%011: &106",  1},
	{ "%011: &112",  1},
	{ "%011: &103",  1},
	{ "%047: %047 %054",  0},
	{ "%047: %050",  0},
	{ "%054: %055",  0},
	{ "%054: %013",  0},
	{ "%054: %056",  0},
	{ "%054: %057",  0},
	{ "%054: %058",  0},
	{ "%054: %059",  0},
	{ "%054: %060",  0},
	{ "%054: %061",  0},
	{ "%054: %062",  0},
	{ "%054: %063",  0},
	{ "%054: %064",  0},
	{ "%054: %065",  0},
	{ "%054: %066",  0},
	{ "%054: %067",  0},
	{ "%054: %068",  0},
	{ "%055: &049 &051 &034 %045 %025",  0},
	{ "%055: &049 &051 &034 %045 &001",  0},
	{ "%025: %022",  15},
	{ "%025: &040 %052 &060",  15},
	{ "%025: &040 &001 &060",  15},
	{ "%052: %069 %052",  0},
	{ "%052: %069",  0},
	{ "%069: %022",  0},
	{ "%069: &049 &046 &042 &063",  0},
	{ "%069: &049 &046 %022 &063",  0},
	{ "%069: &042",  0},
	{ "%013: &049 &086 %026 %014 %016 %007 %008 %018 %040 %045 %025",  6},
	{ "%013: &049 &086 %026 %014 %016 %007 %008 %018 %040 %045 &001",  6},
	{ "%013: &049 &086 &001 %045 %025",  6},
	{ "%026: &087 %027",  15},
	{ "%026: &087 &001",  15},
	{ "%014: &091 &049",  7},
	{ "%014: &091 &001",  7},
	{ "%016: &084 &049",  9},
	{ "%016: &084 &001",  9},
	{ "%007: &081 &045",  1},
	{ "%007: %050",  1},
	{ "%007: &081 &001",  1},
	{ "%008: &085 &045",  1},
	{ "%008: %050",  1},
	{ "%008: &085 &001",  1},
	{ "%018: &092 &040 %070 &060",  11},
	{ "%018: %050",  11},
	{ "%018: &092 &001",  11},
	{ "%070: %071",  0},
	{ "%070: %070 &013 %071",  0},
	{ "%071: %027",  0},
	{ "%071: %022",  0},
	{ "%040: &095 &040 %041 &060",  19},
	{ "%040: %050",  19},
	{ "%040: &095 &001",  19},
	{ "%041: &072",  19},
	{ "%041: &031",  19},
	{ "%041: &042",  19},
	{ "%041: &040 %052 &060",  19},
	{ "%041: &045",  19},
	{ "%041: &043",  19},
	{ "%041: &044",  19},
	{ "%041: &050",  19},
	{ "%041: &049",  19},
	{ "%041: &033 &022 &049",  19},
	{ "%058: &049 &086 %026 %010 %015 %017 %007 %008 %019 %040 %045 %025",  0},
	{ "%015: &090 &049",  8},
	{ "%015: &090 &001",  8},
	{ "%017: &084 &049",  10},
	{ "%017: &084 &001",  10},
	{ "%010: &089 &045",  1},
	{ "%010: %050",  1},
	{ "%019: &092 &040 %072 &060",  12},
	{ "%019: &094 &040 %022 &060",  12},
	{ "%019: %050",  12},
	{ "%019: &092 &001",  12},
	{ "%072: %073",  0},
	{ "%072: %072 &013 %073",  0},
	{ "%073: &093 %022",  0},
	{ "%073: %022",  0},
	{ "%056: &049 &098 %029 %020 %007 %008 %045 %034",  0},
	{ "%056: &049 &098 &001 %045 %034",  0},
	{ "%056: &049 &098 &001 %045 &001",  0},
	{ "%029: &099 %025",  15},
	{ "%029: &099 &001",  15},
	{ "%020: &100 &040 %074 &060",  13},
	{ "%020: %050",  13},
	{ "%020: &100 &001",  13},
	{ "%074: %075",  0},
	{ "%075: %076",  0},
	{ "%075: %075 &013 %076",  0},
	{ "%076: %022",  0},
	{ "%077: %078",  0},
	{ "%078: %079",  0},
	{ "%078: %078 &013 %079",  0},
	{ "%079: %080",  0},
	{ "%080: &049",  0},
	{ "%080: &033 &022 &049",  0},
	{ "%066: &033 %045 %027",  0},
	{ "%027: %028",  15},
	{ "%027: %030",  15},
	{ "%028: &009",  15},
	{ "%028: &051 &034",  15},
	{ "%028: %003",  15},
	{ "%028: &050",  15},
	{ "%028: %024 %039",  15},
	{ "%028: %004 %027",  15},
	{ "%028: &066 &040 %081 &060",  15},
	{ "%028: &066 &040 &001 &060",  15},
	{ "%024: &038",  15},
	{ "%024: &088",  15},
	{ "%024: %023",  15},
	{ "%039: &040 %082 &060",  18},
	{ "%039: %050",  18},
	{ "%039: &040 &001 &060",  18},
	{ "%082: %083",  0},
	{ "%082: %082 &013 %083",  0},
	{ "%083: &049 &046 %035 &063",  0},
	{ "%035: %034",  15},
	{ "%035: %033",  15},
	{ "%034: &042",  15},
	{ "%034: &043",  15},
	{ "%034: &044",  15},
	{ "%081: %081 &013 %084",  0},
	{ "%081: %084",  0},
	{ "%084: &049 %027",  0},
	{ "%067: &049 %045 %025",  0},
	{ "%068: &049 %027 %045 %031",  0},
	{ "%031: %032",  15},
	{ "%031: %033",  15},
	{ "%032: &072",  15},
	{ "%032: &031",  15},
	{ "%032: &042",  15},
	{ "%032: &043",  15},
	{ "%032: &044",  15},
	{ "%032: &040 %052 &060",  15},
	{ "%032: &040 %085 &060",  15},
	{ "%032: &045",  15},
	{ "%032: &050",  15},
	{ "%085: %086",  0},
	{ "%085: %085 &013 %086",  0},
	{ "%086: &049",  0},
	{ "%033: %022",  15},
	{ "%050:",  0},
	{ "%003: &052 &070",  1},
	{ "%003: &053",  1},
	{ "%004: &067",  1},
	{ "%004: &066 &054",  1},
	{ "%030: %027 %037",  15},
	{ "%030: %027 %038",  15},
	{ "%030: %027 &001",  15},
	{ "%037: &046 %087 %088 &063",  17},
	{ "%037: &046 &001 &063",  17},
	{ "%087: %036",  0},
	{ "%088: &005 %087 %088",  0},
	{ "%088: %050",  0},
	{ "%036: %034",  16},
	{ "%036: %034 &023 %034",  16},
	{ "%038: &046 &069 %037 &063",  17},
	{ "%038: &046 &069 &001 &063",  17},
	{ "%022: &033 &022 &049",  15},
	{ "%022: &049",  15},
	{ "%023: &033 &022 &033",  15},
	{ "%023: &033",  15},
	{ "%045: %006",  0},
	{ "%045: &011",  0},
	{ "%006: &118 &118",  1},
	{ "%006: &118 &119",  1},
	{ "%006: &119",  1},
	{ "%060: &049 &096 %021 %043 &081 &045 %008 %045 %025",  0},
	{ "%043: &084 &049",  21},
	{ "%021: &097 &040 %089 &060",  14},
	{ "%021: %050",  14},
	{ "%021: &097 &001",  14},
	{ "%089: %090",  0},
	{ "%090: %091",  0},
	{ "%090: %090 &013 %091",  0},
	{ "%091: %022",  0},
	{ "%057: &049 &077 &078 &045 &079 &045 &080 &045 &081 &045 %092 %045 %025",  0},
	{ "%092: %093",  0},
	{ "%092: %050",  0},
	{ "%093: %093 %094",  0},
	{ "%093: %094",  0},
	{ "%094: &082 &045 &081 &045",  0},
	{ "%059: &049 &083 %042 %007 %008 %045 %025",  0},
	{ "%042: &084 &049",  20},
	{ "%061: &033 %045 &101 %009 &084 &049 &081 &045 %008 &087 %027",  0},
	{ "%009: &102 &045",  1},
	{ "%009: %050",  1},
	{ "%062: &049 &103 &097 &040 %077 &060 &084 &049 &081 &045 %008 %045 %025",  0},
	{ "%063: &049 &104 &105 &040 %077 &060 &084 &049 &081 &045 %008 %045 %025",  0},
	{ "%064: &049 &106 &084 &049 &081 &045 %008 %095 %045 %025",  0},
	{ "%095: %096",  0},
	{ "%095: %050",  0},
	{ "%096: %096 %097",  0},
	{ "%096: %097",  0},
	{ "%097: &107 %098 %099 %100",  0},
	{ "%097: &107 %099 %100",  0},
	{ "%098: &033",  0},
	{ "%098: &033 %025",  0},
	{ "%099: &108 &040 %077 &060",  0},
	{ "%099: %050",  0},
	{ "%100: %101",  0},
	{ "%100: %050",  0},
	{ "%101: %101 %102",  0},
	{ "%101: %102",  0},
	{ "%102: &109 &049 &081 &045",  0},
	{ "%102: &051 &049 %103 %104 %105 &081 &045",  0},
	{ "%103: &087 %027",  0},
	{ "%103: %050",  0},
	{ "%104: &110 %027",  0},
	{ "%104: %050",  0},
	{ "%105: &111 &049",  0},
	{ "%105: %050",  0},
	{ "%065: &049 &112 &113 &045 &084 &049 &081 &045 %008 %106 %045 %025",  0},
	{ "%106: %107",  0},
	{ "%106: %050",  0},
	{ "%107: %107 %108",  0},
	{ "%107: %108",  0},
	{ "%108: &114 %109 &115 &040 %077 &060 %110",  0},
	{ "%109: &033 &040 %052 &060",  0},
	{ "%109: &033",  0},
	{ "%110: %111",  0},
	{ "%110: %050",  0},
	{ "%111: %111 %112",  0},
	{ "%111: %112",  0},
	{ "%112: &116 &049 %103 %104 %014 %113 %040 &081 &045",  0},
	{ "%113: &117 &040 %114 &060",  0},
	{ "%113: %050",  0},
	{ "%114: %077",  0},
	{ "%114: %050",  0},
{ "$accept",  0},{ "error",  0}
};
yyNamedType yyTokenTypes[] = {
	{ "$end",  0,  0},
	{ "error",  256,  0},
	{ "ABSENT",  257,  0},
	{ "ANY",  258,  0},
	{ "APPLICATION",  259,  0},
	{ "BAR",  260,  0},
	{ "BGIN",  261,  1},
	{ "BIT",  262,  0},
	{ "BITSTRING",  263,  0},
	{ "_BOOLEAN",  264,  1},
	{ "BY",  265,  0},
	{ "CCE",  266,  0},
	{ "CHOICE",  267,  0},
	{ "COMMA",  268,  0},
	{ "COMPONENT",  269,  0},
	{ "COMPONENTS",  270,  0},
	{ "COMPONENTSOF",  271,  0},
	{ "CONTROL",  272,  0},
	{ "DECODER",  273,  0},
	{ "DEFAULT",  274,  0},
	{ "DEFINED",  275,  0},
	{ "DEFINITIONS",  276,  1},
	{ "DOT",  277,  0},
	{ "DOTDOT",  278,  0},
	{ "DOTDOTDOT",  279,  0},
	{ "ENCODER",  280,  0},
	{ "ENCRYPTED",  281,  0},
	{ "END",  282,  1},
	{ "ENUMERATED",  283,  0},
	{ "EXPORTS",  284,  0},
	{ "EXPLICIT",  285,  0},
	{ "FALSE_VAL",  286,  1},
	{ "FROM",  287,  1},
	{ "ID",  288,  1},
	{ "IDENTIFIER",  289,  1},
	{ "IMPLICIT",  290,  0},
	{ "IMPORTS",  291,  1},
	{ "INCLUDES",  292,  0},
	{ "INTEGER",  293,  1},
	{ "LANGLE",  294,  0},
	{ "LBRACE",  295,  1},
	{ "LBRACKET",  296,  0},
	{ "LITNUMBER",  297,  5},
	{ "LIT_HEX_STRING",  298,  2},
	{ "LIT_BINARY_STRING",  299,  3},
	{ "LITSTRING",  300,  1},
	{ "LPAREN",  301,  0},
	{ "MIN",  302,  0},
	{ "MAX",  303,  0},
	{ "NAME",  304,  1},
	{ "NIL",  305,  1},
	{ "OBJECT",  306,  1},
	{ "OCTET",  307,  1},
	{ "OCTETSTRING",  308,  1},
	{ "OF",  309,  1},
	{ "PARAMETERTYPE",  310,  0},
	{ "PREFIXES",  311,  0},
	{ "PRESENT",  312,  0},
	{ "PRINTER",  313,  0},
	{ "PRIVATE",  314,  0},
	{ "RBRACE",  315,  0},
	{ "RBRACKET",  316,  0},
	{ "REAL",  317,  0},
	{ "RPAREN",  318,  0},
	{ "SECTIONS",  319,  0},
	{ "SEMICOLON",  320,  0},
	{ "SEQUENCE",  321,  1},
	{ "SEQUENCEOF",  322,  1},
	{ "SET",  323,  0},
	{ "_SIZE",  324,  1},
	{ "STRING",  325,  1},
	{ "TAGS",  326,  0},
	{ "TRUE_VAL",  327,  1},
	{ "UNIVERSAL",  328,  0},
	{ "WITH",  329,  0},
	{ "PLUSINFINITY",  330,  0},
	{ "MINUSINFINITY",  331,  0},
	{ "MODULEID",  332,  1},
	{ "LASTUPDATE",  333,  1},
	{ "ORGANIZATION",  334,  1},
	{ "CONTACTINFO",  335,  1},
	{ "DESCRIPTION",  336,  1},
	{ "REVISION",  337,  1},
	{ "OBJECTIDENT",  338,  1},
	{ "STATUS",  339,  1},
	{ "REFERENCE",  340,  1},
	{ "OBJECTYPE",  341,  1},
	{ "SYNTAX",  342,  1},
	{ "BITSXX",  343,  1},
	{ "UNITS",  344,  1},
	{ "MAXACCESS",  345,  1},
	{ "ACCESS",  346,  1},
	{ "INDEX",  347,  1},
	{ "IMPLIED",  348,  1},
	{ "AUGMENTS",  349,  1},
	{ "DEFVAL",  350,  1},
	{ "NOTIFY",  351,  1},
	{ "OBJECTS",  352,  1},
	{ "TRAPTYPE",  353,  1},
	{ "ENTERPRISE",  354,  1},
	{ "VARIABLES",  355,  1},
	{ "TEXTCONV",  356,  1},
	{ "DISPLAYHINT",  357,  1},
	{ "OBJECTGROUP",  358,  1},
	{ "NOTIFYGROUP",  359,  1},
	{ "NOTIFICATIONS",  360,  1},
	{ "MODCOMP",  361,  1},
	{ "MODULE",  362,  1},
	{ "MANDATORY",  363,  1},
	{ "GROUP",  364,  1},
	{ "WSYNTAX",  365,  1},
	{ "MINACCESS",  366,  1},
	{ "AGENTCAP",  367,  1},
	{ "PRELEASE",  368,  1},
	{ "SUPPORTS",  369,  1},
	{ "INCLUDING",  370,  1},
	{ "VARIATION",  371,  1},
	{ "CREATION",  372,  1},
	{ "':'",  58,  0},
	{ "'='",  61,  0}

};
#endif
#if YYDEBUG
static char *	YYStatesFile = "states.out";
long yyStates[] = {
0L, 17L, 30L, 69L, 124L, 141L, 154L, 176L, 220L, 233L, 251L, 298L, 320L, 
333L, 424L, 437L, 476L, 498L, 520L, 567L, 590L, 644L, 662L, 685L, 708L, 
721L, 755L, 768L, 781L, 828L, 855L, 882L, 900L, 918L, 992L, 1020L, 1048L, 
1061L, 1144L, 1199L, 1212L, 1225L, 1238L, 1251L, 1264L, 1277L, 1290L, 
1303L, 1316L, 1329L, 1342L, 1355L, 1368L, 1381L, 1394L, 1407L, 1446L, 
1468L, 1512L, 1578L, 1591L, 1655L, 1677L, 1721L, 1739L, 1762L, 1784L, 
1807L, 1829L, 1851L, 1874L, 1958L, 2839L, 2852L, 2865L, 2878L, 2891L, 
2904L, 2917L, 2930L, 2943L, 2956L, 2969L, 2982L, 2995L, 3008L, 3021L, 
3034L, 3052L, 3100L, 3241L, 3264L, 3287L, 3310L, 3394L, 3461L, 3518L, 
3590L, 3662L, 3704L, 3776L, 3845L, 3969L, 3982L, 3995L, 4012L, 4090L, 
4112L, 4125L, 4138L, 4151L, 4222L, 4239L, 4348L, 4361L, 4374L, 4387L, 
4400L, 4413L, 4524L, 4747L, 4828L, 4882L, 4961L, 4978L, 5071L, 5138L, 
5195L, 5267L, 5339L, 5356L, 5430L, 5502L, 5515L, 5559L, 5611L, 5633L, 
5651L, 5754L, 5772L, 5790L, 5808L, 5835L, 5858L, 5876L, 5930L, 6083L, 
6096L, 6140L, 6158L, 6192L, 6256L, 6340L, 6374L, 6406L, 6614L, 6725L, 
6752L, 6779L, 6792L, 6809L, 6871L, 6889L, 6956L, 7013L, 7085L, 7157L, 
7175L, 7244L, 7257L, 7291L, 7363L, 7381L, 7408L, 7425L, 7477L, 7500L, 
7554L, 7603L, 7616L, 7638L, 7682L, 7695L, 7708L, 7721L, 7734L, 7747L, 
7760L, 7804L, 7817L, 7830L, 7843L, 7856L, 7869L, 7882L, 7895L, 7923L, 
7940L, 7953L, 7980L, 8029L, 8056L, 8069L, 8091L, 8135L, 8153L, 8171L, 
8235L, 8248L, 8292L, 8371L, 8389L, 8477L, 8509L, 8522L, 8539L, 8606L, 
8640L, 8764L, 8828L, 8856L, 8884L, 8902L, 8964L, 9031L, 9088L, 9160L, 
9182L, 9195L, 9208L, 9221L, 9265L, 9337L, 9379L, 9392L, 9426L, 9444L, 
9462L, 9534L, 9547L, 9560L, 9604L, 9631L, 9649L, 9701L, 9728L, 9755L, 
9804L, 9826L, 9849L, 9862L, 9884L, 9911L, 9924L, 9968L, 9990L, 10108L, 
10191L, 10219L, 10241L, 10269L, 10296L, 10319L, 10341L, 10364L, 10397L, 
10430L, 10448L, 10475L, 10549L, 10582L, 10600L, 10634L, 10701L, 10719L, 
10737L, 10771L, 10937L, 10970L, 11003L, 11065L, 11132L, 11221L, 11293L, 
11315L, 11337L, 11409L, 11451L, 11469L, 11487L, 11559L, 11581L, 11609L, 
11688L, 11716L, 11744L, 11767L, 11806L, 11834L, 11856L, 11879L, 11902L, 
11925L, 11938L, 11951L, 11978L, 12001L, 12014L, 12027L, 12071L, 12098L, 
12145L, 12163L, 12181L, 12215L, 12329L, 12347L, 12365L, 12526L, 12588L, 
12655L, 12739L, 12811L, 12834L, 12857L, 12929L, 12972L, 13044L, 13067L, 
13119L, 13142L, 13155L, 13178L, 13206L, 13228L, 13256L, 13303L, 13321L, 
13339L, 13448L, 13604L, 13683L, 13782L, 13873L, 13886L, 13899L, 13948L, 
14005L, 14077L, 14149L, 14221L, 14273L, 14296L, 14344L, 14443L, 14456L, 
14500L, 14651L, 14713L, 14807L, 14820L, 14847L, 14916L, 14970L, 15039L, 
15057L, 15114L, 15186L, 15258L, 15330L, 15383L, 15396L, 15423L, 15467L, 
15561L, 15579L, 15606L, 15619L, 15663L, 15787L, 15849L, 15891L, 15904L, 
15917L, 15966L, 16033L, 16060L, 16078L, 16120L, 16147L, 16160L, 16173L, 
16227L, 16250L, 16309L, 16367L, 16466L, 16565L, 16664L, 16691L, 16709L, 
16736L, 16803L, 16889L, 16902L, 16980L, 16993L, 17042L, 17060L, 17087L, 
17211L, 17344L, 17393L, 17435L, 17453L, 17520L, 17547L, 17616L, 17643L, 
17661L, 17689L, 17761L, 17833L, 17860L, 17873L, 17886L, 17935L, 18007L, 
18034L, 18047L, 18064L, 18077L, 18126L, 18193L, 18237L, 18259L, 18287L, 
18309L, 18322L, 18335L, 18348L, 18361L, 18374L, 18396L, 18409L, 18422L, 
18435L, 18462L, 18525L, 18588L, 18615L, 18657L, 18725L, 18753L, 18766L, 
18783L, 18847L, 18874L, 18946L, 19018L, 19045L, 19063L, 19135L, 19163L, 
19181L, 19203L, 19231L, 19299L, 19322L, 19344L, 19366L, 19394L, 19421L, 
19463L, 19556L, 19569L, 19586L, 19645L, 19673L, 19746L, 19819L, 19846L, 
19919L, 19942L, 19965L, 19988L, 20016L, 20058L, 20146L, 20159L, 20176L, 
20218L, 20246L, 20320L, 20338L, 20380L, 20432L, 20445L, 20458L, 20512L, 
20555L, 20598L, 20672L, 20690L, 20759L, 20811L, 20885L, 20898L, 20925L, 
20994L, 21038L, 21090L, 21103L, 21116L, 21143L, 21195L, 21223L
};
const YYMAX_READ = 881;
#endif
static short yydef[] = {

	 264,   -1,   48,  262,   -5,  -13,  -17,    3,  -21,   10, 
	 224,  -25,  -29,  224,  -37,  224,  -67,   87,  -71,    9, 
	 -79,  224,  -83,  260,  259,  -91, -103, -109,  224,  224, 
	-117, -125,  261,  224,  224, -129,  224,  224, -137,  224, 
	 224,  257,  224, -141, -149,   12,  224,  224, -157,  255, 
	 256,  224, -165, -173, -181,   10, -189, -195,   15, -203, 
	 258, -211, -217, -227, -231,  224,  254, -239, -245, -249, 
	-255, -259
};
static short yyex[] = {

	   0,    0,   -1,    1,  282,  224,  288,  224,  304,  224, 
	  -1,    1,  320,  224,   -1,    1,  320,  263,   -1,    1, 
	 339,  224,   -1,    1,  339,  224,   -1,    1,  282,    6, 
	 288,    6,  304,    6,   -1,    1,  266,    7,  268,    7, 
	 282,    7,  288,    7,  304,    7,  315,    7,  336,    7, 
	 344,    7,  345,    7,  346,    7,  365,    7,  366,    7, 
	  58,    7,   61,    7,   -1,    1,  345,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  318,  224, 
	  -1,    1,  344,    4,  345,    4,  346,    4,   -1,    1, 
	 268,   61,  288,   48,  297,   48,  304,   48,  315,   61, 
	  -1,    1,  268,    8,  315,    8,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  266,  224,   58,  224, 
	  61,  224,   -1,    1,  318,  224,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  342,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  266,  224,   58,  224, 
	  61,  224,   -1,    1,  266,  224,   58,  224,   61,  224, 
	  -1,    1,  266,  224,   58,  224,   61,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  268,    5, 
	 315,    5,   -1,    1,  282,   11,  288,   11,  304,   11, 
	  -1,    1,  336,  224,  365,  224,  366,  224,   -1,    1, 
	 336,  224,  366,  224,   -1,    1,  336,   13,  346,   13, 
	 365,   13,  366,   13,   -1,    1,  336,  224,   -1,    1, 
	 336,   14,  346,   14,  366,   14,   -1,    1,  346,  224, 
	 365,  224,   -1,    1,  346,  224,   -1,    1,  336,  224, 
	 350,  224,   -1,    1,  336,  224,   -1,    1,  315,  224, 
	  -1,    1
};
static short yyact[] = {

	  -1, -443,  304,  288, -278, -277, -312,  304,  295,  288, 
	-275,  277, -274, -278, -408,   -3,  304,  297,  288,  256, 
	-272,  276, -313,  304, -271,  301, -278, -408,   -3,  304, 
	 297,  288, -412,  315, -413,  315, -270, -307, -493,  266, 
	  61,   58, -278, -267, -312,  304,  297,  288, -309, -308, 
	  61,   58,   -5,  261, -409,  318, -410,  318,   -6,  291, 
	-265, -433, -432, -453, -454, -451, -455, -452, -457, -460, 
	-456, -458, -459,  367,  361,  359,  358,  356,  353,  351, 
	 341,  338,  332,  304,  288,  256, -262, -433, -432, -453, 
	-454, -451, -455, -452, -457, -460, -456, -458, -459,  367, 
	 361,  359,  358,  356,  353,  351,  341,  338,  332,  304, 
	 288,  256, -440,  320, -260, -441,  320,  287, -259, -258, 
	-442,  320,  287,  268, -445, -257, -256,  304,  288,  282, 
	-260,  287, -259, -258,  287,  268,   -8,  288, -433, -432, 
	-453, -454, -451, -455, -452, -457, -460, -456, -458, -459, 
	 367,  361,  359,  358,  356,  353,  351,  341,  338,  332, 
	 304,  288, -270, -307, -352, -493,  -10, -345, -349, -241, 
	-248, -489, -245, -490, -249, -250, -242, -344,   -9, -243, 
	-251, -252, -253, -254,  367,  361,  359,  358,  353,  351, 
	 343,  341,  338,  332,  322,  321,  308,  307,  306,  305, 
	 293,  288,  266,  264,   61,   58, -240,  295, -352,  -10, 
	-345, -349, -239, -248, -489, -245, -490, -344,  -12,  356, 
	 343,  322,  321,  308,  307,  306,  305,  293,  288,  264, 
	-238,  368, -237,  339, -236,  360, -235,  352, -234,  339, 
	-233,  333, -232,  352, -230,  277, -324,  325, -270, -307, 
	-320, -493, -229,  301,  266,  256,   61,   58, -227, -323, 
	 309,  295, -352,  -10, -345, -349, -239, -248, -489, -245, 
	-490, -344,  343,  322,  321,  308,  307,  306,  305,  293, 
	 288,  264, -226,  295, -224, -225,  354,  256, -222, -223, 
	 342,  256,  -18,  289, -221, -278, -408,   -3,  304,  297, 
	 288,  256, -219,  357, -351,  289, -320, -229,  301,  256, 
	-217,  300, -216,  304, -215,  295, -214,  295, -297,  304, 
	-213,  336, -212,  300, -302, -211,  295,  256, -210,  339, 
	-311,  288, -207, -339, -338, -337, -208,  324,  299,  298, 
	 297,  256, -333, -278, -206, -332, -331, -330, -327, -312, 
	-326, -334,  327,  305,  304,  300,  299,  298,  297,  295, 
	 288,  286, -204, -205,  304,  256, -201, -202,  304,  256, 
	-359, -278, -277, -312,  304,  295,  288,  256, -198,  355, 
	-404, -352,  -10, -345, -349, -239, -248, -489, -245, -490, 
	-344,  343,  322,  321,  308,  307,  306,  305,  293,  288, 
	 264,  256, -196, -194,  346,  344, -434,  315, -435,  315, 
	-296,  300, -191,  339, -190,  339, -189,  336, -187, -354, 
	 304,  288, -184,  340, -397, -399,  300,  256, -183,  334, 
	-278, -312,  304,  288, -305,  304, -181,  336, -180, -178, 
	 301,  256, -177,  278, -318,  318, -176,  260, -278, -408, 
	 -26,  304,  297,  288, -346,  315, -172, -347,  315,  268, 
	-171,  301, -341,  315, -170, -343,  315,  268, -361, -339, 
	-338, -337,  299,  298,  297,  256, -356, -169,  295,  256, 
	-371,  300, -168,  345, -402, -403,  304,  256, -166,  339, 
	-414, -278, -277, -312,  304,  295,  288,  256, -165,  304, 
	-164,  304,  -30,  300, -163,  315, -162,  277, -161,  268, 
	-160,  315, -394, -396,  300,  256, -158,  300, -157,  268, 
	-304,  315,  -31,  300, -314,  318, -315,  318, -207, -339, 
	-338, -337,  299,  298,  297,  256, -339, -338, -337,  299, 
	 298,  297, -319,  318, -156, -328,  315,  268, -329,  315, 
	-205,  304, -278, -339, -338, -337, -312,  304,  299,  298, 
	 297,  288, -202,  304, -374, -375,  304,  256, -152,  339, 
	-400, -401,  304,  256, -151,  336, -150,  336, -149,  339, 
	-353,  304, -148,  339, -147,  335, -325,  304, -340,  318, 
	-145,  268, -358,  315, -372, -373,  304,  256,  -39,  300, 
	 -40,  300,  -41,  362, -142,  304, -141,  304, -140,  300, 
	-138,  347,  -46, -136,  363,  288, -134,  336, -133,  336, 
	-132,  336, -130, -131,  349,  347, -391, -129,  295,  256, 
	-128,  350, -126,  342, -125,  369, -123,  295, -122, -121, 
	 364,  306, -136,  363,  -53,  300,  -54,  300,  -55,  300, 
	-120,  295, -366, -119,  295,  256, -352,  -56, -345, -312, 
	-349, -239, -248, -489, -245, -490, -344,  343,  322,  321, 
	 308,  307,  306,  305,  304,  293,  288,  264, -387, -116, 
	 295,  256,  -59,  288,  -60,  304, -111,  304, -108,  337, 
	-278, -312, -105,  348,  304,  288, -102,  277, -101, -393, 
	 315,  268, -385, -100,  -99, -384, -381, -380, -382, -378, 
	-379, -386,  327,  305,  304,  300,  299,  298,  297,  295, 
	 288,  286, -406, -278, -277, -312,  304,  295,  288,  256, 
	 -97,  295,  -96,  370, -288,  315,  -95,  342,  -94,  336, 
	 -91,  300, -368,  315,  -89, -369,  315,  268, -311, -313, 
	 304,  288,  -88,  277, -389,  315,  -85,  295,  -84,  365, 
	-287,  300,  -83,  336, -377,  304, -383,  315, -282,  315, 
	 -81,  366, -299,  300,  -66,  315, -285,  304,  -79,  336, 
	 -78,  371, -286,  300,  -68,  304, -194,  346,  -76,  372, 
	 -72,  295,  -73,  336, -280,  315, -281,  300,   -1
};
static short yypact[] = {

	   7,   10,   25,   29,   59,   73,   99,  207,  243,  245, 
	 283,  303,  308,  321,  308,  379,  404,   39,  423,  443, 
	 447,  321,  308,  509,  519,   25,  308,  423,  321,  423, 
	 423,  447,  591,  321,  423,  603,  423,  611,  423,  423, 
	 614,  603,  624,  631,  635,    7,  640,  643,  631,  635, 
	 640,  640,  423,  423,  689,  697,  308,  308,  731,  737, 
	 689,  759,  308,  771,  308,  781,  781,  737,  759,  789, 
	 631,  420,  797,  795,  793,  791,  787,  785,  783,  779, 
	 777,  775,  773,  272,  420,  769,  767,  765,  693,    7, 
	 763,    7,    7,  761,  272,  757,   29,  755,   29,  753, 
	 667,  750,    7,  746,  432,  743,   39,  741,   39,   39, 
	 739,  735,    7,  733,  726,  712,  700,   39,  693,  432, 
	 687,  685,  420,   39,  683,  272,   39,  680,  667,  654, 
	 651,  649,  647,  645,    7,  637,  633,  628,    7,  621, 
	 619,  617,   39,  539,  432,   39,  609,  607,  605,  601, 
	 599,  596,   39,  593,  589,  587,  432,  585,    7,  583, 
	 420,  581,  579,  577,  575,  572,  569,  566,  432,  563, 
	 557,  551,  549,  546,  543,  539,  539,  532,  527,  525, 
	 523,  521,  517,  514,   39,  511,  507,  505,  503,  501, 
	 499,  494,  489,  486,  483,  481,    7,  478,  472,  466, 
	 463,  461,  458,  455,  272,  451,  445,  440,  437,  435, 
	 432,  429,  426,  420,  420,  417,  415,  413,  411,  409, 
	 407,   39,  391,   39,  374,  368,  364,  352,  337,  331, 
	 329,  326,  323,  319,  317,  315,  313,  311,  305,  298, 
	 293,  290,  286,  272,  260,    7,  253,  247,  241,  239, 
	 237,  235,  233,  231,  219,  184,   39,  137,  150,  137, 
	 134,  131,  127,  121,  116,  113,   57,   55,   53,   50, 
	  45,   39,   35,   33,   23,   21,   16,   11,    2
};
static short yygo[] = {

	  -2, -437, -436,  257, -350, -244, -446, -310,  -28,  -35, 
	 -37,  -19,   33,   28,   21, -153,  -36, -146,  -38,  -43, 
	-137,  -45, -110, -109, -185,   53,   52,   39,   38,   36, 
	  34,   30,   29,   27, -218, -195, -431, -439, -438,    6, 
	-429,  -70, -193,   76, -167,  -29,  -34,  -44,  -49,  -22, 
	-231, -411, -364, -411, -411, -390, -365, -364, -106, -390, 
	-355, -301, -355, -487, -411, -301, -487, -411, -268, -411, 
	-463,  276,  270,  239,  227,  210,  205,  170,  168,  156, 
	 144,  128,  119,  118,  104,  100,   98,   96,   88,    3, 
	-476,  -11, -289, -300, -294, -293, -376, -284, -407, -292, 
	-306, -298, -415, -405, -360, -336, -444,  245,  224,  196, 
	 191,  158,  138,  134,  114,  112,  102,   92,   91,   89, 
	  45,  -17,  -65,  -63,  -58,  -27,  -23,  -15,  -13, -247, 
	 -57,  255,  254,  243,  222,  204,  125,   94,   83, -474, 
	 -16, -475, -335, -483, -480, -484,  170, -363, -479, -316, 
	-362,  -20,  198,  176,  170,  143, -155, -317, -179, -322, 
	 207, -321, -348, -118,  -75, -127,   70,   48,  -98,  -14, 
	-209, -276, -192,  -90,  -92,  -93, -103, -113, -115, -135, 
	-139, -144, -159, -197, -199, -228, -246, -255, -269,  256, 
	 255,  246,  223,  221,  184,  152,  145,  142,  126,  123, 
	 117,  109,  108,  106,   17, -488, -263, -261, -264,    6, 
	-266, -447, -448, -303, -342, -295, -398, -357, -370, -492, 
	-398, -398, -492, -398, -499, -392, -502, -367, -388, -509, 
	-503, -502, -388, -503, -496, -506, -507, -508, -512, -506, 
	-507, -515, -388, -517, -462, -395,  487,   71,   70,   69, 
	  68,   67,   65,   63,   61,   59,   54,   51,   48,   47, 
	  46,   44,   43,   42,   40,   37,   35,   33,   31,   28, 
	  21,   20,   16,   15,   13,   11,   10,    8,    5,    4, 
	  -7, -464,  -86,  -87, -173, -220, -273,  239,  205,   98, 
	  96,    3, -449, -450,  258, -461, -430, -428, -427, -426, 
	-425, -424, -423, -422, -421, -420, -419, -418, -417, -416, 
	  -4, -117, -466, -465,  100, -104, -468, -467,   88, -154, 
	 -33, -470, -469,  144, -516,  -82, -112, -186, -188,  213, 
	 122,   84,   71,  -24, -472, -471,  160, -473, -203, -200, 
	-478, -477,  169, -481, -482,  171, -174, -486, -485,  155, 
	 -32,  -21,  175, -491, -175,   31, -182,  -25, -495, -494, 
	 156, -107,  -61, -497, -498,   60, -143,  -42, -500, -501, 
	  41,  -48,  -52,  -47,   47, -291, -290,   51,  -51, -504, 
	-505,   50,  -69,  -62,   67,  -77,  -64,   68,  -80, -124, 
	 -50, -510, -511,   49, -114, -283,  -67, -513, -514,   66, 
	 -71,  -74,   -1
};
static short yypgo[] = {

	   0,    0,    0,    2,  121,  313,  307,  139,  344,  157, 
	  90,  302,  371,  383,  386,  394,  400,  398,  394,  392, 
	 306,  388,  380,  380,  373,  371,  369,  369,  305,  304, 
	 303,   34,   34,  169,  300,  364,  298,  359,   50,   50, 
	  50,  170,  301,    7,    7,    7,  188,   90,   70,   70, 
	 161,  161,  157,  351,  159,  159,  141,  141,  141,    5, 
	   4,  348,  143,  143,  143,  143,  143,  143,  143,  143, 
	 143,  309,  308,  151,  151,  151,  341,  162,  162,  162, 
	  91,   91,  139,  139,  139,  139,  139,  139,  139,  337, 
	 337,  322,   49,   49,   49,  140,  140,  297,  297,  297, 
	 317,  317,   48,   48,   48,   48,   35,   35,   46,   46, 
	  44,   44,  299,  168,  168,  168,  168,  168,  168,  168, 
	 168,  168,  168,  165,  165,  165,  313,   47,   47,   47, 
	  24,   24,   24,   11,   11,   11,   45,   45,   42,   42, 
	 121,   40,   40,   40,  310,  310,  310,  310,  106,  106, 
	 296,  296,  295,  295,  295,  295,  295,  295,  295,  295, 
	 295,  295,  295,  295,  295,  295,  295,  293,  293,  293, 
	   2,    2,   38,   38,  280,  280,  205,  205,  205,    6, 
	   6,    0,  171,  205,  210,  208,  208,   36,   36,   36, 
	  36,   36,   36,   36,   36,   36,   36,  206,  206,  106, 
	 286,  311,  311,  315,  315,  320,  320,  333,  333,  335, 
	 130,  130,   91,  339,  339,  156,  156,  338,  338,  142, 
	 142,  346,  346,  145,  245,    4,    5,  354,  354,  188, 
	 357,  357,  361,  362,  362,  366,  367,  367,  373,  376, 
	 378,  378,  383,  386,  388,  389,  390,  390,  395,  396, 
	 396,  400,  401,  401,  395,  389,  376,  366,  361,  356, 
	 328,  319,  286,  210,    6,    0
};
static short yyrlen[] = {

	   0,    0,    0,    1,    2,    1,    3,    2,    2,    1, 
	   1,   11,    1,    2,    2,    1,    4,    9,    4,    7, 
	  12,    2,    7,    4,    4,    2,    3,    4,   10,   13, 
	  13,    1,    2,    2,    7,    4,   13,    1,    2,    1, 
	   4,    2,    9,    1,    2,    2,    1,    3,    1,    3, 
	   4,    4,    3,    1,    3,    4,    2,    2,    2,    2, 
	   2,    1,    1,    1,    3,    3,    1,    1,    1,    1, 
	   1,    4,    3,    1,    1,    1,    4,    3,    1,    3, 
	   1,    1,    4,    4,    2,    1,    1,    2,    1,    3, 
	   1,    1,    2,    1,    4,    2,    2,    5,    5,    8, 
	   1,    2,    2,    1,    4,    4,    1,    2,    2,    2, 
	   2,    2,   12,    3,    1,    1,    1,    1,    1,    3, 
	   1,    1,    1,    2,    1,    4,    1,    2,    1,    4, 
	   2,    1,    2,    2,    1,    2,    2,    2,    2,    2, 
	   2,    5,   11,   11,    1,    4,    4,    1,    3,    3, 
	   5,    5,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   4,    4,    3,    3,    1,    2,    3,    3,    3,    1, 
	   2,    8,    0,    1,    1,    3,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    2,    1,    1, 
	   2,    1,    3,    1,    3,    1,    3,    1,    3,    1, 
	   1,    1,    1,    1,    3,    1,    1,    3,    1,    1, 
	   1,    1,    3,    1,    0,    1,    1,    3,    1,    1, 
	   1,    3,    1,    2,    1,    1,    2,    1,    1,    1, 
	   2,    1,    1,    1,    1,    1,    2,    1,    1,    2, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    2
};
#define YYS0	278
#define YYDELTA	263
#define YYNPACT	279
#define YYNDEF	72

#define YYr263	0
#define YYr264	1
#define YYr265	2
#define YYr18	3
#define YYr65	4
#define YYr82	5
#define YYr130	6
#define YYr138	7
#define YYr157	8
#define YYr188	9
#define YYr195	10
#define YYr218	11
#define YYr230	12
#define YYr240	13
#define YYr242	14
#define YYr253	15
#define YYr259	16
#define YYr258	17
#define YYr252	18
#define YYr251	19
#define YYr246	20
#define YYr244	21
#define YYr239	22
#define YYr238	23
#define YYr232	24
#define YYr231	25
#define YYr229	26
#define YYr228	27
#define YYr223	28
#define YYr222	29
#define YYr221	30
#define YYr220	31
#define YYr219	32
#define YYr217	33
#define YYr216	34
#define YYr215	35
#define YYr210	36
#define YYr209	37
#define YYr205	38
#define YYr204	39
#define YYr203	40
#define YYr202	41
#define YYr201	42
#define YYr200	43
#define YYr199	44
#define YYr198	45
#define YYr196	46
#define YYr194	47
#define YYr193	48
#define YYr192	49
#define YYr191	50
#define YYr190	51
#define YYr189	52
#define YYr185	53
#define YYr184	54
#define YYr183	55
#define YYr182	56
#define YYr181	57
#define YYr180	58
#define YYr179	59
#define YYr176	60
#define YYr173	61
#define YYr170	62
#define YYr169	63
#define YYr168	64
#define YYr167	65
#define YYr166	66
#define YYr165	67
#define YYr164	68
#define YYr163	69
#define YYr162	70
#define YYr159	71
#define YYr158	72
#define YYr154	73
#define YYr153	74
#define YYr152	75
#define YYr149	76
#define YYr146	77
#define YYr145	78
#define YYr144	79
#define YYr142	80
#define YYr141	81
#define YYr140	82
#define YYr139	83
#define YYr137	84
#define YYr136	85
#define YYr135	86
#define YYr134	87
#define YYr133	88
#define YYr129	89
#define YYr128	90
#define YYr123	91
#define YYr119	92
#define YYr118	93
#define YYr117	94
#define YYr116	95
#define YYr115	96
#define YYr114	97
#define YYr113	98
#define YYr112	99
#define YYr111	100
#define YYr110	101
#define YYr107	102
#define YYr106	103
#define YYr105	104
#define YYr104	105
#define YYr103	106
#define YYr102	107
#define YYr101	108
#define YYr100	109
#define YYr99	110
#define YYr98	111
#define YYr97	112
#define YYr96	113
#define YYr95	114
#define YYr94	115
#define YYr93	116
#define YYr92	117
#define YYr91	118
#define YYr90	119
#define YYr89	120
#define YYr88	121
#define YYr87	122
#define YYr86	123
#define YYr85	124
#define YYr84	125
#define YYr83	126
#define YYr79	127
#define YYr78	128
#define YYr77	129
#define YYr76	130
#define YYr75	131
#define YYr74	132
#define YYr73	133
#define YYr72	134
#define YYr71	135
#define YYr70	136
#define YYr69	137
#define YYr68	138
#define YYr67	139
#define YYr66	140
#define YYr64	141
#define YYr63	142
#define YYr62	143
#define YYr61	144
#define YYr60	145
#define YYr59	146
#define YYr58	147
#define YYr55	148
#define YYr54	149
#define YYr52	150
#define YYr51	151
#define YYr50	152
#define YYr49	153
#define YYr48	154
#define YYr47	155
#define YYr46	156
#define YYr45	157
#define YYr44	158
#define YYr43	159
#define YYr42	160
#define YYr41	161
#define YYr40	162
#define YYr39	163
#define YYr38	164
#define YYr37	165
#define YYr36	166
#define YYr23	167
#define YYr22	168
#define YYr21	169
#define YYr17	170
#define YYr16	171
#define YYr15	172
#define YYr14	173
#define YYr13	174
#define YYr12	175
#define YYr8	176
#define YYr7	177
#define YYr6	178
#define YYr5	179
#define YYr4	180
#define YYr2	181
#define YYr1	182
#define YYrACCEPT	YYr263
#define YYrERROR	YYr264
#define YYrLR2	YYr265
#if YYDEBUG
char * yysvar[] = {
	"$accept",
	"ModuleDefinition",
	"ImportModuleIdentifier",
	"Octetstring",
	"SequenceOf",
	"MainModuleIdentifier",
	"InsteadOfCCE",
	"DescrPart",
	"ReferPart",
	"DisplayPart",
	"UnitsPart",
	"MacroName",
	"SymbolsFromModule",
	"ObjectTypeV1Definition",
	"AccessPart",
	"MaxAccessPartV2",
	"StatusPart",
	"StatusPartV2",
	"IndexPart",
	"IndexPartV2",
	"VarPart",
	"ObjectsPart",
	"QualifiedName",
	"QualifiedId",
	"QualifiedIdOrIntegerOrBits",
	"ObjectID",
	"SyntaxPart",
	"Type",
	"BuiltinType",
	"EnterprisePart",
	"SubType",
	"Value",
	"BuiltinValue",
	"DefinedValue",
	"NumericValue",
	"NamedNumberValue",
	"SubtypeValueSet",
	"SubtypeRangeSpec",
	"SubtypeSizeSpec",
	"NNlist",
	"DefValPart",
	"DefValValue",
	"ObjectIdentityStatusPart",
	"NotificationTypeStatusPart",
	"$1",
	"AllowedCCE",
	"Imports",
	"AssignmentList",
	"SymbolList",
	"SymbolsImported",
	"empty",
	"SymbolsFromModuleList",
	"ObjectIDComponentList",
	"Symbol",
	"Assignment",
	"ObjectIDefinition",
	"TrapTypeDefinition",
	"ModuleIDefinition",
	"ObjectTypeV2Definition",
	"ObjectDefinition",
	"NotifyDefinition",
	"TextualConventionDefinition",
	"ObjectGroupDefinition",
	"NotifyGroupDefinition",
	"ModComplianceDefinition",
	"AgentCapabilitiesDefinition",
	"Typeassignment",
	"ToleratedOIDAssignment",
	"Valueassignment",
	"ObjectSubID",
	"IndexTypes",
	"IndexType",
	"IndexTypesV2",
	"IndexTypeV2",
	"VarTypeListForTrap",
	"VarTypesForTrap",
	"VarTypeForTrap",
	"VarTypeList",
	"VarTypes",
	"VarType",
	"UncheckedQualifiedName",
	"ElementTypes",
	"NamedNumberList",
	"NamedNumber",
	"NamedType",
	"NameList",
	"Name",
	"SubtypeRangeAlternative",
	"SubtypeRangeAlternativeList",
	"ObjectTypeListForNotification",
	"ObjectTypesForNotification",
	"ObjectTypeForNotification",
	"RevisionPart",
	"Revisions",
	"Revision",
	"MibPart",
	"Mibs",
	"Mib",
	"ModuleIdentifierUnused",
	"MandatoryPart",
	"CompliancePart",
	"Compliances",
	"Compliance",
	"Syntax",
	"WriteSyntax",
	"MinAccessPart",
	"ModulePart",
	"Modules",
	"Module",
	"ModuleReference",
	"VariationPart",
	"Variations",
	"Variation",
	"CreationPart",
	"Creation",
	0
};
short yyrmap[] = {

	 263,  264,  265,   18,   65,   82,  130,  138,  157,  188, 
	 195,  218,  230,  240,  242,  253,  259,  258,  252,  251, 
	 246,  244,  239,  238,  232,  231,  229,  228,  223,  222, 
	 221,  220,  219,  217,  216,  215,  210,  209,  205,  204, 
	 203,  202,  201,  200,  199,  198,  196,  194,  193,  192, 
	 191,  190,  189,  185,  184,  183,  182,  181,  180,  179, 
	 176,  173,  170,  169,  168,  167,  166,  165,  164,  163, 
	 162,  159,  158,  154,  153,  152,  149,  146,  145,  144, 
	 142,  141,  140,  139,  137,  136,  135,  134,  133,  129, 
	 128,  123,  119,  118,  117,  116,  115,  114,  113,  112, 
	 111,  110,  107,  106,  105,  104,  103,  102,  101,  100, 
	  99,   98,   97,   96,   95,   94,   93,   92,   91,   90, 
	  89,   88,   87,   86,   85,   84,   83,   79,   78,   77, 
	  76,   75,   74,   73,   72,   71,   70,   69,   68,   67, 
	  66,   64,   63,   62,   61,   60,   59,   58,   55,   54, 
	  52,   51,   50,   49,   48,   47,   46,   45,   44,   43, 
	  42,   41,   40,   39,   38,   37,   36,   23,   22,   21, 
	  17,   16,   15,   14,   13,   12,    8,    7,    6,    5, 
	   4,    2,    1,    9,   11,   19,   20,   24,   25,   26, 
	  27,   28,   29,   30,   31,   32,   33,   34,   35,   53, 
	  56,   80,   81,  108,  109,  121,  122,  125,  126,  127, 
	 131,  132,  143,  147,  148,  150,  151,  155,  156,  160, 
	 161,  171,  172,  174,  175,  177,  178,  186,  187,  197, 
	 207,  208,  212,  213,  214,  225,  226,  227,  233,  235, 
	 236,  237,  241,  243,  245,  248,  249,  250,  255,  256, 
	 257,  260,  261,  262,  254,  247,  234,  224,  211,  206, 
	 124,  120,   57,   10,    3,    0
};
short yysmap[] = {

	   2,    4,   13,   15,   33,   37,   55,   89,  100,  101, 
	 112,  122,  124,  130,  145,  151,  154,  155,  167,  177, 
	 180,  209,  211,  230,  240,  255,  256,  268,  276,  281, 
	 292,  296,  308,  314,  317,  320,  338,  339,  340,  341, 
	 342,  345,  353,  356,  358,  361,  362,  363,  373,  383, 
	 391,  393,  395,  396,  397,  402,  404,  410,  411,  416, 
	 425,  455,  473,  476,  487,  492,  498,  501,  503,  505, 
	 508,  509,  514,  513,  510,  507,  504,  495,  494,  490, 
	 489,  486,  480,  475,  472,  471,  469,  468,  464,  461, 
	 459,  458,  457,  456,  454,  450,  449,  446,  442,  436, 
	 434,  433,  432,  431,  429,  427,  426,  422,  421,  420, 
	 417,  415,  414,  412,  409,  408,  406,  401,  400,  398, 
	 388,  387,  385,  384,  380,  379,  378,  377,  375,  372, 
	 371,  368,  367,  366,  365,  360,  357,  355,  350,  349, 
	 348,  347,  346,  335,  333,  328,  326,  324,  321,  319, 
	 318,  313,  310,  309,  304,  298,  290,  289,  286,  285, 
	 284,  283,  282,  280,  279,  275,  272,  271,  267,  262, 
	 260,  258,  254,  253,  251,  250,  247,  246,  245,  244, 
	 243,  241,  237,  234,  232,  231,  226,  225,  224,  223, 
	 222,  218,  217,  216,  215,  214,  212,  208,  206,  203, 
	 202,  200,  199,  198,  196,  187,  179,  176,  174,  173, 
	 172,  170,  169,  165,  164,  163,  162,  160,  159,  157, 
	 156,  153,  152,  150,  149,  147,  144,  141,  137,  135, 
	 134,  133,  131,  129,  128,  127,  126,  125,  123,  121, 
	 120,  119,  118,  111,  110,  106,  105,  104,   99,   98, 
	  97,   96,   95,   94,   93,   71,   70,   68,   67,   65, 
	  62,   61,   60,   58,   57,   56,   30,   29,   28,   25, 
	  20,   18,   17,   16,   11,   10,    7,    6,    0,  515, 
	 516,  485,  499,  451,  493,  500,  477,  452,  386,  392, 
	 419,  394,  478,  479,  158,  221,  166,  325,  491,  481, 
	 238,  171,  132,  291,  242,  369,   24,   31,   32,   27, 
	 175,    5,   19,  293,  294,  295,  178,  248,  297,  138, 
	 139,  140,  143,  136,  330,  185,  186,  299,  300,  188, 
	 189,  190,  191,  192,  195,  142,  181,  182,  183,  332, 
	 261,  146,  263,  108,  109,  257,  259,  148,  113,  114, 
	 161,  115,  322,  227,  306,  266,  207,  334,  204,  205, 
	 264,  265,  352,  428,  463,  399,  370,  462,  465,  213, 
	 270,  336,  337,  311,  312,  466,  483,  437,  438,  439, 
	 440,  441,  484,  443,  444,  445,  407,  376,  470,  403, 
	 374,  354,  435,  287,  233,  288,  235,  168,  236,  315, 
	 316,  273,  274,  210,  269,  447,  448,   12,   34,   35, 
	  14,   22,   23,  277,  278,   72,   73,   74,   75,   76, 
	  77,   78,   79,   80,   81,   82,   83,   84,   85,   86, 
	  49,   50,   51,  219,  220,   90,   92,   53,   63,   64, 
	  66,   69,    1,    9,   88,    3,   36,   54,   91,   52, 
	  48,   47,   46,   45,   44,   43,   42,   41,   40,   39, 
	  87,   59,    8,   21,  405,  467,  430,  482,  307,  351, 
	 229,  323,  228,  117,  116,  107,  201,  305,  303,  302, 
	 301,  197,  194,  193,  252,  331,  184,   38,  103,  102, 
	 329,  249,   26,  239,  327,  424,  460,  423,  344,  364, 
	 343,  359,  390,  418,  389,  453,  474,  488,  382,  413, 
	 381,  497,  502,  496,  506,  512,  511
};
int yy_parse::yyntoken = 120;
int yy_parse::yynvar = 115;
int yy_parse::yynstate = 517;
int yy_parse::yynrule = 266;
#endif



// C++ YACC parser code
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// If YYDEBUG is defined as 1 and yy_parse::yydebug is set to 1,
// yyparse() will print a travelogue of its actions as it reads
// and parses input.
//
// YYSYNC can be defined to cause yyparse() to attempt to always
// hold a lookahead token

const YY_MIN_STATE_NUM = 20;	// not useful to be too small!

#if YYDEBUG
#ifdef YYTRACE
long	* yy_parse::States	= yyStates;
#endif
yyTypedRules * yy_parse::Rules	= yyRules;
yyNamedType * yy_parse::TokenTypes = yyTokenTypes;

#define YY_TRACE(fn) { done = 0; fn(); if (done) YYRETURN(-1); }
#endif

// Constructor for yy_parse: user-provided tables
yy_parse::yy_parse(int sz, short * states, YYSTYPE * stack)
{
	mustfree = 0;
	if ((size = sz) < YY_MIN_STATE_NUM
	 || (stateStack = states) == (short *) 0
	 || (valueStack = stack) == (YYSTYPE *) 0) {
		fprintf(stderr,"Bad state/stack given");
		exit(1);
	}
	reset = 1;		// force reset
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
	if (typeStack == (short *) 0) {
		fprintf(stderr,"Cannot allocate typeStack");
		exit(1);
	}
#endif
}
// Constructor for yy_parse: allocate tables with new
yy_parse::yy_parse(int sz)
{
	size = sz;
	reset = 1;		// force reset
	mustfree = 1;		// delete space in deconstructor
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
#endif
	stateStack = new short[size+1];
	valueStack = new YYSTYPE[size+1];

	if (stateStack == (short *) 0 || valueStack == (YYSTYPE *) 0
#if YYDEBUG
		|| typeStack == (short *) 0
#endif
	    ) {
		fprintf(stderr,"Not enough space for parser stacks");
		exit(1);
	}
}
// Destructor for class yy_parse
//	Free up space
yy_parse::~yy_parse()
{
	if (mustfree) {
		delete stateStack;
		delete valueStack;
	}
	stateStack = (short *) 0;
#if YYDEBUG
	delete typeStack;
#endif
}

#ifdef YACC_WINDOWS

// The initial portion of the yacc parser.
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_yyparse() to acutally begin the
// parsing. When complete, win_yyparse() will return a
// value back to our new yyparse() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of yyparse().

int
yy_parse::yyparse(yy_scan* ps)
{
	int wReturnValue;
	HANDLE hRes_table;
	short *old_yydef;		// the following are used for saving
	short *old_yyex;		// the current pointers
	short *old_yyact;
	short *old_yypact;
	short *old_yygo;
	short *old_yypgo;
	short *old_yyrlen;

	// the following code will load the required
	// resources for a Windows based parser.

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_yyYACC", "yyYACCTBL"));
	
	// return an error code if any
	// of the resources did not load

	if (hRes_table == (HANDLE)NULL)
		return (1);
	
	// the following code will lock the resources
	// into fixed memory locations for the parser
	// (also, save away the old pointer values)

	old_yydef = yydef;
	old_yyex = yyex;
	old_yyact = yyact;
	old_yypact = yypact;
	old_yygo = yygo;
	old_yypgo = yypgo;
	old_yyrlen = yyrlen;

	yydef = (short *)LockResource (hRes_table);
	yyex = (short *)(yydef + Sizeof_yydef);
	yyact = (short *)(yyex + Sizeof_yyex);
	yypact = (short *)(yyact + Sizeof_yyact);
	yygo = (short *)(yypact + Sizeof_yypact);
	yypgo = (short *)(yygo + Sizeof_yygo);
	yyrlen = (short *)(yypgo + Sizeof_yypgo);

	// call the official yyparse() function

	wReturnValue = win_yyparse (ps);

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previous pointer values
	//

	yydef = old_yydef;
	yyex = old_yyex;
	yyact = old_yyact;
	yypact = old_yypact;
	yygo = old_yygo;
	yypgo = old_yypgo;
	yyrlen = old_yyrlen;

	return (wReturnValue);
}	// end yyparse()


// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling yyparse().
//	Call yyreset() before yyparse() if you want a fresh start

int
yy_parse::win_yyparse(yy_scan* ps)

#else /* YACC_WINDOWS */

// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling yyparse().
//	Call yyreset() before yyparse() if you want a fresh start
int
yy_parse::yyparse(yy_scan* ps)

#endif /* YACC_WINDOWS */

{
	short	* yyp, * yyq;		// table lookup
	int	yyj;
#if YYDEBUG
	int	yyruletype = 0;
#endif

	if ((scan = ps) == (yy_scan *) 0) {	// scanner
		fprintf(stderr,"No scanner");
		exit(1);
	}

	if (reset) {			// start new parse
		yynerrs = 0;
		yyerrflag = 0;
		yyps = stateStack;
		yypv = valueStack;
#if YYDEBUG
		yytp = typeStack;
#endif
		yystate = YYS0;
		yyclearin();
		reset = 0;
	} else			// continue saved parse
		goto yyNext;			// after action

yyStack:
	if (++yyps > &stateStack[size]) {
		scan->yyerror("Parser stack overflow");
		YYABORT;
	}
	*yyps = yystate;	/* stack current state */
	*++yypv = yyval;	/* ... and value */
#if YYDEBUG
	if (yydebug) {
		*++yytp = (short)yyruletype;	/* ... and type */
		YY_TRACE(yyShowState)
	}
#endif

	/*
	 * Look up next action in action table.
	 */
yyEncore:
#ifdef YYSYNC
	if (yychar < 0) {
		if ((yychar = scan->yylex()) < 0) {
			if (yychar == -2) YYABORT;
			yychar = 0;
		}	/* endif */
		yylval = ::yylval;
#if YYDEBUG
		if (yydebug)
			yyShowRead();	// show new input token
#endif
	}
#endif
#ifdef YACC_WINDOWS
	if (yystate >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
	if (yystate >= sizeof yypact/sizeof yypact[0]) 	/* simple state */
#endif /* YACC_WINDOWS */
		yyi = yystate - YYDELTA;	/* reduce in any case */
	else {
		if(*(yyp = &yyact[yypact[yystate]]) >= 0) {
			/* Look for a shift on yychar */
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			yyq = yyp;
			yyi = (short)yychar;
			while (yyi < *yyp++)
				;
			if (yyi == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
#if YYDEBUG
				if (yydebug) {
					yyruletype = yyGetType(yychar);
					YY_TRACE(yyShowShift)
				}
#endif
				yyval = yylval;		/* stack value */
				yyclearin();		/* clear token */
				if (yyerrflag)
					yyerrflag--;	/* successful shift */
				goto yyStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

#ifdef YACC_WINDOWS
		if (yystate >= Sizeof_yydef) 	/* simple state */
#else /* YACC_WINDOWS */
		if (yystate >= sizeof yydef /sizeof yydef[0])
#endif /* YACC_WINDOWS */
			goto yyError;
		if ((yyi = yydef[yystate]) < 0)	 { /* default == reduce? */

			/* Search exception table */
			yyp = &yyex[~yyi];
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			while((yyi = *yyp) >= 0 && yyi != yychar)
				yyp += 2;
			yyi = yyp[1];
		}
	}

	yyj = yyrlen[yyi];

#if YYDEBUG
	if (yydebug) {
		npop = yyj; rule = yyi;
		YY_TRACE(yyShowReduce)
		yytp -= yyj;
	}
#endif
	yyps -= yyj;		/* pop stacks */
	yypvt = yypv;		/* save top */
	yypv -= yyj;
	yyval = yypv[1];	/* default action $ = $1 */
#if YYDEBUG
	if (yydebug)
		yyruletype = yyRules[yyrmap[yyi]].type;
#endif
	switch (yyi) {		/* perform semantic action */
		
case YYr1: {	/* ModuleDefinition :  MainModuleIdentifier */

						SIMCParser *myParser = (SIMCParser *)this;
						myParser ++;
						myParser --;
						SIMCModule *myModule = myParser->GetModule();
						theModule->SetModuleName(yypvt[0].yy_name->name);
						theModule->SetLineNumber(yypvt[0].yy_name->line);
						theModule->SetColumnNumber(yypvt[0].yy_name->column);
						theModule->SetInputFileName(theScanner->GetInputStreamName());
						delete yypvt[0].yy_name;
					
} break;

case YYr2: {	/* ModuleDefinition :  MainModuleIdentifier $1 DEFINITIONS AllowedCCE BGIN Imports AssignmentList END */

						delete yypvt[-5].yy_name;
						delete yypvt[-3].yy_name;
						delete yypvt[0].yy_name;
					
} break;

case YYr4: {	/* MainModuleIdentifier :  ID ObjectID */

					if(yypvt[0].yy_symbol_ref)
						delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr5: {	/* MainModuleIdentifier :  NAME */

					theParser->SyntaxError(NAME_INSTEAD_OF_ID);
				
} break;

case YYr6: {	/* Imports :  IMPORTS SymbolList SEMICOLON */

			theParser->SyntaxError(MISSING_MODULE_NAME);
			delete newImportModule;
			newImportModule = new SIMCModule;
			delete yypvt[-2].yy_name;
		
} break;

case YYr7: {	/* Imports :  IMPORTS error SEMICOLON */

			theParser->SyntaxError(IMPORTS_SECTION);
			delete yypvt[-2].yy_name;
		
} break;

case YYr8: {	/* Imports :  IMPORTS SymbolsImported SEMICOLON */

			delete yypvt[-2].yy_name;
		
} break;

case YYr12: {	/* SymbolsFromModuleList :  SymbolsFromModuleList SymbolsFromModule */
			
			newImportModule->SetParentModule(theModule);
			if(yypvt[0].yy_module)
			{
				theModule->AddImportModuleName(newImportModule);
				theParser->DoImportModule(theModule, yypvt[0].yy_module);
			}
			else
				delete newImportModule;
			newImportModule = new SIMCModule;
		
} break;

case YYr13: {	/* SymbolsFromModuleList :  SymbolsFromModule */

			newImportModule->SetParentModule(theModule);
			if(yypvt[0].yy_module)
			{
				theModule->AddImportModuleName(newImportModule);
				theParser->DoImportModule(theModule, yypvt[0].yy_module);
			}
			else
				delete newImportModule;
			newImportModule = new SIMCModule;
		
} break;

case YYr14: {	/* SymbolsFromModule :  SymbolList FROM ImportModuleIdentifier */

			if(strcmp(yypvt[0].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				theParser->SemanticError(theModule->GetInputFileName(),
							IMPORT_CURRENT,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column,
							yypvt[0].yy_name->name);
				yyval.yy_module = NULL;
			}
			else
			{
				newImportModule->SetModuleName(yypvt[0].yy_name->name);
				newImportModule->SetLineNumber(yypvt[0].yy_name->line);
				newImportModule->SetColumnNumber(yypvt[0].yy_name->column);
				newImportModule->SetSymbolType(SIMCSymbol::MODULE_NAME);
				newImportModule->SetInputFileName(theScanner->GetInputStreamName());
				yyval.yy_module = newImportModule;
			}
			delete yypvt[0].yy_name;
		
} break;

case YYr15: {	/* SymbolsFromModule :  error FROM ImportModuleIdentifier */

			theParser->SyntaxError(LIST_IN_IMPORTS);
			delete yypvt[-1].yy_name;
			delete yypvt[0].yy_name;
			yyval.yy_module = NULL;
		
} break;

case YYr16: {	/* ImportModuleIdentifier :  ID LBRACE ObjectIDComponentList RBRACE */

			yyval.yy_name = yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
		
} break;

case YYr17: {	/* ImportModuleIdentifier :  ID LBRACE error RBRACE */

			yyval.yy_name = yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
			theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
		
} break;

case YYr18: {	/* ImportModuleIdentifier :  ID */

			yyval.yy_name = yypvt[0].yy_name;
		
} break;

case YYr21: {	/* Symbol :  ID */

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr22: {	/* Symbol :  NAME */

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr23: {	/* Symbol :  MacroName */

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr36: {	/* Assignment :  ObjectIDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr37: {	/* Assignment :  ObjectTypeV1Definition */

				firstAssignment = FALSE;
			
} break;

case YYr38: {	/* Assignment :  TrapTypeDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr39: {	/* Assignment :  ModuleIDefinition */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_IDENTITY_DISALLOWED);
					}
					break;
					case 2:
					{
						if(!firstAssignment)
						{
							theParser->SyntaxError(MODULE_IDENTITY_ONLY_AFTER_IMPORTS);
						}
						else
							firstAssignment = FALSE;
					}
					break;
					default:
					{
						firstAssignment = FALSE;
					}
					break;
				}
			
} break;

case YYr40: {	/* Assignment :  ObjectTypeV2Definition */

				firstAssignment = FALSE;
			
} break;

case YYr41: {	/* Assignment :  ObjectDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr42: {	/* Assignment :  NotifyDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr43: {	/* Assignment :  TextualConventionDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr44: {	/* Assignment :  ObjectGroupDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr45: {	/* Assignment :  NotifyGroupDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr46: {	/* Assignment :  ModComplianceDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr47: {	/* Assignment :  AgentCapabilitiesDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr48: {	/* Assignment :  Typeassignment */

				firstAssignment = FALSE;
			
} break;

case YYr49: {	/* Assignment :  ToleratedOIDAssignment */

				firstAssignment = FALSE;
			
} break;

case YYr50: {	/* Assignment :  Valueassignment */

				firstAssignment = FALSE;
			
} break;

case YYr51: {	/* ObjectIDefinition :  NAME OBJECT IDENTIFIER AllowedCCE ObjectID */

				if(yypvt[0].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-4].yy_name->name);
					if(s) // Symbol exists in symbol table
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-4].yy_name->name,
							new SIMCDefinedValueReference (
								theParser->objectIdentifierType,
								0, 0,
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, 	
								yypvt[-4].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
								(*s)->GetReferenceCount()) );
							// delete (*s);
						}
						else
						{
							theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-4].yy_name->line,
														yypvt[-4].yy_name->column,
														yypvt[-4].yy_name->name);
						}
					}
					else
					{
						theModule->AddSymbol( new SIMCDefinedValueReference (
								theParser->objectIdentifierType,
								0, 0,
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, 
								yypvt[-4].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 0) );
					}
				}
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr52: {	/* ObjectIDefinition :  NAME OBJECT IDENTIFIER AllowedCCE error */

				// Add a syntax error statement here
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr54: {	/* ObjectID :  LBRACE ObjectIDComponentList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType,
							0, 0, 
							new SIMCOidValue(newOidComponentList),
							badName, SIMCSymbol::LOCAL, theModule,
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column);
				delete badName;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr55: {	/* ObjectID :  LBRACE error RBRACE */

				yyval.yy_symbol_ref = NULL;
				delete newOidComponentList;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
				theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
				// Cascade the error, for example to the ObjectIDefinition
				// production
				YYERROR;  

			
} break;

case YYr58: {	/* ObjectSubID :  QualifiedName */

				if(yypvt[0].yy_symbol_ref) 
				{
					newOidComponentList->AddTail(new SIMCOidComponent (
						yypvt[0].yy_symbol_ref->s,yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
					NULL, 0, 0));
				}
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr59: {	/* ObjectSubID :  NAME LPAREN LITNUMBER RPAREN */

				char *badName = theParser->GenerateSymbolName();
				SIMCBuiltInValueReference *val = 
					new SIMCBuiltInValueReference(
						theParser->integerType, 
						0, 0,
						new SIMCIntegerValue(yypvt[-1].yy_number->number, yypvt[-1].yy_number->isUnsigned,
							yypvt[-1].yy_number->line, yypvt[-1].yy_number->column),
						badName,
						SIMCSymbol::LOCAL,
						theModule,
						yypvt[-1].yy_number->line, yypvt[-1].yy_number->column);
				theModule->AddSymbol( val);
				SIMCOidComponent *comp = new SIMCOidComponent (
										theModule->GetSymbol(badName),
										yypvt[-1].yy_number->line, yypvt[-1].yy_number->column,
										yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column );
				delete badName;
				newOidComponentList->AddTail(comp);
				delete yypvt[-3].yy_name;
				delete yypvt[-1].yy_number;
			
} break;

case YYr60: {	/* ObjectSubID :  NAME LPAREN QualifiedName RPAREN */

				if(yypvt[-1].yy_symbol_ref)
					newOidComponentList->AddTail( new SIMCOidComponent(
						yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, 
						yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column));
				delete yypvt[-3].yy_name;
				delete yypvt[-1].yy_symbol_ref;
			
} break;

case YYr61: {	/* ObjectSubID :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				SIMCBuiltInValueReference *val = 
					new SIMCBuiltInValueReference(
						theParser->integerType, 
						0, 0,
						new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned, yypvt[0].yy_number->line, yypvt[0].yy_number->column),
						badName,
						SIMCSymbol::LOCAL,
						theModule,
						yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				theModule->AddSymbol( val);
				SIMCOidComponent *comp = new SIMCOidComponent (
										theModule->GetSymbol(badName),
										yypvt[0].yy_number->line, yypvt[0].yy_number->column,
										NULL, 0, 0);
				delete badName;
				newOidComponentList->AddTail(comp);
				delete yypvt[0].yy_number;
			
} break;

case YYr62: {	/* ObjectTypeV1Definition :  NAME OBJECTYPE SyntaxPart AccessPart StatusPart DescrPart ReferPart IndexPart DefValPart AllowedCCE ObjectID */
				
			
				switch(theParser->GetSnmpVersion())
				{
					case 2:
					{
						theParser->SyntaxError(V1_OBJECT_TYPE_DISALLOWED);
					}
					break;
					default:
					{
						if(yypvt[-8].yy_symbol_ref)
						{
							SIMCObjectTypeV1 * type = new SIMCObjectTypeV1(
								yypvt[-8].yy_symbol_ref->s, yypvt[-8].yy_symbol_ref->line, yypvt[-8].yy_symbol_ref->column,
								yypvt[-7].yy_access->a, yypvt[-7].yy_access->line, yypvt[-7].yy_access->column,
								yypvt[-6].yy_status->a, yypvt[-6].yy_status->line, yypvt[-6].yy_status->column,
								yypvt[-3].yy_index->indexList, yypvt[-3].yy_index->line, yypvt[-3].yy_index->column, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->name : NULL, (yypvt[-5].yy_name)? yypvt[-5].yy_name->line : 0, (yypvt[-5].yy_name)? yypvt[-5].yy_name->column : 0,
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->name : NULL, (yypvt[-4].yy_name)? yypvt[-4].yy_name->line : 0, (yypvt[-4].yy_name)? yypvt[-4].yy_name->column : 0,
								yypvt[-2].yy_def_val->name, yypvt[-2].yy_def_val->symbol, yypvt[-2].yy_def_val->line, yypvt[-2].yy_def_val->column );

							char *badName = theParser->GenerateSymbolName();
							SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
									type, badName, SIMCSymbol::LOCAL, theModule,
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column );
							theModule->AddSymbol(typeRef);
							
							
							SIMCSymbol ** s = theModule->GetSymbol(yypvt[-10].yy_name->name);	
							if(s) // Symbol exists in symbol table
							{
								if(  typeid(**s) == typeid(SIMCUnknown) )
								{
									theModule->ReplaceSymbol( yypvt[-10].yy_name->name,
										new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
										(*s)->GetReferenceCount()) );
									// delete (*s);
								}
								else
								{
									theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
														yypvt[-10].yy_name->name);
									// Remove the symbol for the type reference from the module
									// And delete it
									theModule->RemoveSymbol(badName);
									delete type;
									delete typeRef;
									delete newIndexList;
								}
							}
							else
								theModule->AddSymbol( new SIMCDefinedValueReference (
										theModule->GetSymbol(badName), 
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column) );

							newIndexList = new SIMCIndexList;
							delete badName; 
						}
					}
					break;
				}
				delete yypvt[-10].yy_name; 
				delete yypvt[-9].yy_name; 
				delete yypvt[-8].yy_symbol_ref; 
				delete yypvt[-7].yy_access; 
				delete yypvt[-6].yy_status; 
				delete yypvt[-5].yy_name; 
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_index;
				delete yypvt[-2].yy_def_val;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr63: {	/* ObjectTypeV1Definition :  NAME OBJECTYPE SyntaxPart AccessPart StatusPart DescrPart ReferPart IndexPart DefValPart AllowedCCE error */

				theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
				delete yypvt[-10].yy_name; delete yypvt[-9].yy_name; delete yypvt[-8].yy_symbol_ref; delete yypvt[-7].yy_access;
				delete yypvt[-6].yy_status; if(yypvt[-5].yy_name) delete yypvt[-5].yy_name; if(yypvt[-4].yy_name) delete yypvt[-4].yy_name; delete yypvt[-3].yy_index; delete yypvt[-2].yy_def_val;
				delete newIndexList;
				newIndexList = new SIMCIndexList;

			
} break;

case YYr64: {	/* ObjectTypeV1Definition :  NAME OBJECTYPE error AllowedCCE ObjectID */

				theParser->SyntaxError(ERROR_OBJECT_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, NULL, yypvt[-4].yy_name->name);
				theParser->SyntaxError( SKIPPING_OBJECT_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, NULL, yypvt[-4].yy_name->name);
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
				delete newIndexList;
				newIndexList = new SIMCIndexList;
			
} break;

case YYr65: {	/* SyntaxPart :  SYNTAX Type */

				delete yypvt[-1].yy_name;
				if(yypvt[0].yy_symbol_ref)
					yyval.yy_symbol_ref = yypvt[0].yy_symbol_ref;
				else
				{	
					yyval.yy_symbol_ref = NULL;
					theParser->SyntaxError(SYNTAX_CLAUSE);
					YYERROR;
				}
			
} break;

case YYr66: {	/* SyntaxPart :  SYNTAX error */

					delete yypvt[-1].yy_name;
					yyval.yy_symbol_ref = NULL;
					theParser->SyntaxError(SYNTAX_CLAUSE);
					YYERROR;
				
} break;

case YYr67: {	/* AccessPart :  ACCESS NAME */

				SIMCObjectTypeV1::AccessType a;
				if ((a=SIMCObjectTypeV1::StringToAccessType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::ACCESS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_ACCESS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_access = NULL;
					YYERROR;
				}
				else
					yyval.yy_access = new SIMCAccessInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr68: {	/* AccessPart :  ACCESS error */

				yyval.yy_access = new SIMCAccessInfo(SIMCObjectTypeV1::ACCESS_INVALID,
						yypvt[-1].yy_name->line, yypvt[-1].yy_name->column)	;
				theParser->SyntaxError(ACCESS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr69: {	/* StatusPart :  STATUS NAME */

				SIMCObjectTypeV1::StatusType a;
				if ((a=SIMCObjectTypeV1::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_status = new SIMCStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr70: {	/* StatusPart :  STATUS error */

					yyval.yy_status = new SIMCStatusInfo(SIMCObjectTypeV1::STATUS_INVALID,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					theParser->SyntaxError(STATUS_CLAUSE);
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr71: {	/* DescrPart :  DESCRIPTION LITSTRING */

				yyval.yy_name = yypvt[0].yy_name;
				delete yypvt[-1].yy_name;
			
} break;

case YYr72: {	/* DescrPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr73: {	/* DescrPart :  DESCRIPTION error */

					theParser->SyntaxError(DESCRIPTION_CLAUSE);
					yyval.yy_name = NULL;
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr74: {	/* ReferPart :  REFERENCE LITSTRING */

				yyval.yy_name = yypvt[0].yy_name;
				delete yypvt[-1].yy_name;
			
} break;

case YYr75: {	/* ReferPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr76: {	/* ReferPart :  REFERENCE error */

				theParser->SyntaxError(REFERENCE_CLAUSE);
				yyval.yy_name = NULL;
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr77: {	/* IndexPart :  INDEX LBRACE IndexTypes RBRACE */

				yyval.yy_index = new SIMCIndexInfo(newIndexList, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
				newIndexList = new SIMCIndexList;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr78: {	/* IndexPart :  empty */

				yyval.yy_index = new SIMCIndexInfo(newIndexList, 0, 0);
			
} break;

case YYr79: {	/* IndexPart :  INDEX error */

				yyval.yy_index = NULL;
				delete newIndexList;
				newIndexList = new SIMCIndexList;
				theParser->SyntaxError(INDEX_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr82: {	/* IndexType :  Type */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexList->AddTail(new SIMCIndexItem(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr83: {	/* IndexType :  QualifiedName */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexList->AddTail(new SIMCIndexItem(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr84: {	/* DefValPart :  DEFVAL LBRACE DefValValue RBRACE */

				yyval.yy_def_val = yypvt[-1].yy_def_val;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr85: {	/* DefValPart :  empty */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, NULL, 0, 0);
			
} break;

case YYr86: {	/* DefValPart :  DEFVAL error */

				delete yypvt[-1].yy_name;
				yyval.yy_def_val = new SIMCDefValInfo(NULL, NULL, 0, 0);
				theParser->SyntaxError(DEFVAL_CLAUSE);
				YYERROR;
			
} break;

case YYr87: {	/* DefValValue :  TRUE_VAL */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->trueValueReference,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr88: {	/* DefValValue :  FALSE_VAL */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->falseValueReference,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr89: {	/* DefValValue :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned,
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column) ;
				delete yypvt[0].yy_number;
				delete badName;
			
} break;

case YYr90: {	/* DefValValue :  LBRACE ObjectIDComponentList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType,
							0, 0,
							new SIMCOidValue(newOidComponentList),
							badName, 
							SIMCSymbol::LOCAL, theModule,
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column
							));
				yyval.yy_def_val = new SIMCDefValInfo(NULL, theModule->GetSymbol(badName),
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) ;
				delete badName;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr91: {	/* DefValValue :  LITSTRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
				delete badName;
			
} break;

case YYr92: {	/* DefValValue :  LIT_HEX_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_hex_string->value, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete yypvt[0].yy_hex_string;
				delete badName;
			
} break;

case YYr93: {	/* DefValValue :  LIT_BINARY_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(TRUE, yypvt[0].yy_binary_string->value, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete yypvt[0].yy_binary_string;
				delete badName;
			
} break;

case YYr94: {	/* DefValValue :  NIL */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->nullValueReference,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr95: {	/* DefValValue :  NAME */

				yyval.yy_def_val = new SIMCDefValInfo(NewString(yypvt[0].yy_name->name), NULL, yypvt[0].yy_name->line,
						yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr96: {	/* DefValValue :  ID DOT NAME */

				SIMCSymbol **s;
				if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
				{
					if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) ))		
						theModule->AddSymbol(
							new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, 
											theModule, yypvt[0].yy_name->line,
											yypvt[0].yy_name->column, 0) );
					yyval.yy_def_val = new SIMCDefValInfo( NULL,
						theModule->GetSymbol(yypvt[0].yy_name->name), yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else
				{			
					SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
					if(m) 
					{
						if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ) )
						{
							theParser->SemanticError(theModule->GetInputFileName(),
										IMPORT_SYMBOL_ABSENT,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
							yyval.yy_def_val = new SIMCDefValInfo( NULL, NULL, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
						}
						else
					yyval.yy_def_val = new SIMCDefValInfo( NULL, s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
					}
					else // Module is not mentioned in imports
					{
						theParser->SemanticError(theModule->GetInputFileName(),
										IMPORT_MODULE_ABSENT,
										yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
										yypvt[-2].yy_name->name);
						yyval.yy_def_val = new SIMCDefValInfo( NULL, NULL, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
					}
				}
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_name;	
			
} break;

case YYr97: {	/* ObjectTypeV2Definition :  NAME OBJECTYPE SyntaxPart UnitsPart MaxAccessPartV2 StatusPartV2 DescrPart ReferPart IndexPartV2 DefValPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(V2_OBJECT_TYPE_DISALLOWED);
					}
					break;

					default:
					{
						if (yypvt[-9].yy_symbol_ref)
						{
							SIMCObjectTypeV2 * type = new SIMCObjectTypeV2(
								yypvt[-9].yy_symbol_ref->s, 
								yypvt[-9].yy_symbol_ref->line, 
								yypvt[-9].yy_symbol_ref->column,
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->name : NULL, 
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->line:0, 
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->column:0,
								( SIMCObjectTypeV2::AccessType ) (yypvt[-7].yy_accessV2->a), 
								yypvt[-7].yy_accessV2->line, 
								yypvt[-7].yy_accessV2->column,
								( SIMCObjectTypeV2::StatusType ) (yypvt[-6].yy_statusV2->a) , 
								(yypvt[-6].yy_statusV2)? yypvt[-6].yy_statusV2->line : 0, 
								(yypvt[-6].yy_statusV2)? yypvt[-6].yy_statusV2->column : 0,
								yypvt[-3].yy_indexV2->indexList, 
								yypvt[-3].yy_indexV2->line, 
								yypvt[-3].yy_indexV2->column,
								yypvt[-3].yy_indexV2->augmentsClause,
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->name : NULL, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->line : 0, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->column : 0,
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->name : NULL, 
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->line : 0, 
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->column : 0,
								yypvt[-2].yy_def_val->name, 
								yypvt[-2].yy_def_val->symbol, 
								yypvt[-2].yy_def_val->line, 
								yypvt[-2].yy_def_val->column );

							char *badName = theParser->GenerateSymbolName();
							SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
									type, badName, SIMCSymbol::LOCAL, theModule,
									yypvt[-10].yy_name->line, yypvt[-10].yy_name->column );
							theModule->AddSymbol(typeRef);
							
							
							SIMCSymbol ** s = theModule->GetSymbol(yypvt[-11].yy_name->name);	
							if(s) // Symbol exists in symbol table
							{
								if(  typeid(**s) == typeid(SIMCUnknown) )
								{
									theModule->ReplaceSymbol( yypvt[-11].yy_name->name,
										new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
										(*s)->GetReferenceCount()) );
									// delete (*s);
								}
								else
								{
									theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
														yypvt[-11].yy_name->name);
									// Remove the symbol for the type reference from the module
									// And delete it
									theModule->RemoveSymbol(badName);
									delete type;
									delete typeRef;
									delete newIndexListV2;
								}
							}
							else
								theModule->AddSymbol( new SIMCDefinedValueReference (
										theModule->GetSymbol(badName), 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column) );

							newIndexList = new SIMCIndexList;
							delete badName; 
						}
					}
					break;
				}
				delete yypvt[-11].yy_name; 
				delete yypvt[-10].yy_name; 
				if(yypvt[-9].yy_symbol_ref) delete yypvt[-9].yy_symbol_ref; 
				delete yypvt[-8].yy_name; 
				delete yypvt[-7].yy_accessV2; 
				delete yypvt[-6].yy_statusV2; 
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_indexV2;
				delete yypvt[-2].yy_def_val;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr98: {	/* MaxAccessPartV2 :  MAXACCESS NAME */

				SIMCObjectTypeV2::AccessType a;
				if ((a=SIMCObjectTypeV2::StringToAccessType(yypvt[0].yy_name->name)) == SIMCObjectTypeV2::ACCESS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_ACCESS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_accessV2 = NULL;
					YYERROR;
				}
				else
					yyval.yy_accessV2 = new SIMCAccessInfoV2(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr99: {	/* MaxAccessPartV2 :  MAXACCESS error */

				yyval.yy_accessV2 = new SIMCAccessInfoV2(SIMCObjectTypeV2::ACCESS_INVALID,
						yypvt[-1].yy_name->line, yypvt[-1].yy_name->column)	;
				theParser->SyntaxError(ACCESS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr100: {	/* StatusPartV2 :  STATUS NAME */

				SIMCObjectTypeV2::StatusType a;
				if ((a=SIMCObjectTypeV2::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV2::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_statusV2 = NULL;
					YYERROR;
				}
				else
					yyval.yy_statusV2 = new SIMCStatusInfoV2(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr101: {	/* StatusPartV2 :  STATUS error */

					yyval.yy_statusV2 = new SIMCStatusInfoV2(SIMCObjectTypeV2::STATUS_INVALID,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					theParser->SyntaxError(STATUS_CLAUSE);
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr102: {	/* UnitsPart :  UNITS LITSTRING */

				delete yypvt[-1].yy_name;
				yyval.yy_name = yypvt[0].yy_name;
			
} break;

case YYr103: {	/* UnitsPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr104: {	/* IndexPartV2 :  INDEX LBRACE IndexTypesV2 RBRACE */

				yyval.yy_indexV2 = new SIMCIndexInfoV2(newIndexListV2, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
				newIndexListV2 = new SIMCIndexListV2;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr105: {	/* IndexPartV2 :  AUGMENTS LBRACE QualifiedName RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;

				yyval.yy_indexV2 = new SIMCIndexInfoV2(NULL, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, yypvt[-1].yy_symbol_ref->s);
			
} break;

case YYr106: {	/* IndexPartV2 :  empty */

				yyval.yy_indexV2 = new SIMCIndexInfoV2(NULL, 0, 0);
			
} break;

case YYr107: {	/* IndexPartV2 :  INDEX error */

				yyval.yy_indexV2 = NULL;
				delete newIndexListV2;
				newIndexListV2 = new SIMCIndexListV2;
				theParser->SyntaxError(INDEX_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr110: {	/* IndexTypeV2 :  IMPLIED QualifiedName */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexListV2->AddTail(new SIMCIndexItemV2(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, TRUE));
				}
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr111: {	/* IndexTypeV2 :  QualifiedName */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexListV2->AddTail(new SIMCIndexItemV2(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr112: {	/* TrapTypeDefinition :  NAME TRAPTYPE EnterprisePart VarPart DescrPart ReferPart AllowedCCE NumericValue */

				SIMCTrapTypeType * type = new SIMCTrapTypeType(
					yypvt[-5].yy_symbol_ref->s, yypvt[-5].yy_symbol_ref->line, yypvt[-5].yy_symbol_ref->column,
					yypvt[-4].yy_variables_list, 
					(yypvt[-3].yy_name)?yypvt[-3].yy_name->name: NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line: 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column:0,
					(yypvt[-2].yy_name)?yypvt[-2].yy_name->name:NULL, (yypvt[-2].yy_name)?yypvt[-2].yy_name->line:0, (yypvt[-2].yy_name)?yypvt[-2].yy_name->column:0);

				char *badName1 = theParser->GenerateSymbolName();

				SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
						type, badName1, SIMCSymbol::LOCAL, theModule,
						yypvt[-6].yy_name->line, yypvt[-6].yy_name->column);

				theModule->AddSymbol(typeRef);
				
				SIMCSymbol ** s = theModule->GetSymbol(yypvt[-7].yy_name->name);	
				if(s) // Symbol exists in symbol table
				{
					if(  typeid(**s) == typeid(SIMCUnknown) )
					{
						theModule->ReplaceSymbol( yypvt[-7].yy_name->name,
							new SIMCDefinedValueReference (
							theModule->GetSymbol(badName1),
							yypvt[-6].yy_name->line, yypvt[-6].yy_name->column, 
							yypvt[0].yy_symbol_ref->s,
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							yypvt[-7].yy_name->name, SIMCSymbol::LOCAL, theModule, 
							yypvt[-7].yy_name->line, yypvt[-7].yy_name->column,
							(*s)->GetReferenceCount()) );
						// delete (*s);
					}
					else
					{
						theParser->SemanticError(theModule->GetInputFileName(),
											SYMBOL_REDEFINITION,
											yypvt[-7].yy_name->line, yypvt[-7].yy_name->column,
											yypvt[-7].yy_name->name);
						// Remove the symbol for the type reference from the module
						// And delete it
						theModule->RemoveSymbol(badName1);
						delete type;
						delete typeRef;
						delete newVariablesList;
					}
				}
				else
					theModule->AddSymbol( new SIMCDefinedValueReference (
							theModule->GetSymbol(badName1), 
							yypvt[-6].yy_name->line, yypvt[-6].yy_name->column, 
							yypvt[0].yy_symbol_ref->s,
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							yypvt[-7].yy_name->name, SIMCSymbol::LOCAL, theModule, 
							yypvt[-7].yy_name->line, yypvt[-7].yy_name->column) );

				newVariablesList = new SIMCVariablesList;
				delete badName1; 
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_symbol_ref; 
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name; 
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr113: {	/* TrapTypeDefinition :  NAME TRAPTYPE error AllowedCCE NumericValue */

				theParser->SyntaxError( SKIPPING_TRAP_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
					NULL, yypvt[-4].yy_name->name);
				delete newVariablesList;
				newVariablesList = new SIMCVariablesList;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr114: {	/* TrapTypeDefinition :  NAME TRAPTYPE error AllowedCCE error */

				theParser->SyntaxError( SKIPPING_TRAP_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
					NULL, yypvt[-4].yy_name->name);
				delete newVariablesList;
				newVariablesList = new SIMCVariablesList;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
			
} break;

case YYr115: {	/* EnterprisePart :  ENTERPRISE ObjectID */

				yyval.yy_symbol_ref = yypvt[0].yy_symbol_ref;
				delete yypvt[-1].yy_name;
			
} break;

case YYr116: {	/* EnterprisePart :  ENTERPRISE error */

				delete yypvt[-1].yy_name;
				theParser->SyntaxError(ENTERPRISE_CLAUSE);
				YYERROR;
			
} break;

case YYr117: {	/* VarPart :  VARIABLES LBRACE VarTypeListForTrap RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				yyval.yy_variables_list = newVariablesList;
			
} break;

case YYr118: {	/* VarPart :  empty */

				yyval.yy_variables_list = newVariablesList;
			
} break;

case YYr119: {	/* VarPart :  VARIABLES error */

				yyval.yy_variables_list = newVariablesList;
				theParser->SyntaxError(VARIABLES_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr123: {	/* VarTypeForTrap :  QualifiedName */

					if(yypvt[0].yy_symbol_ref)
					{
						newVariablesList->AddTail(
							new SIMCVariablesItem(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
						delete yypvt[0].yy_symbol_ref;
					}
				
} break;

case YYr128: {	/* UncheckedQualifiedName :  NAME */

					delete yypvt[0].yy_name;
				
} break;

case YYr129: {	/* UncheckedQualifiedName :  ID DOT NAME */

					delete yypvt[-2].yy_name;
					delete yypvt[0].yy_name;
				
} break;

case YYr130: {	/* Typeassignment :  ID AllowedCCE Type */

				if (yypvt[0].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-2].yy_name->name);	
					if(s) // Symbol exists in symbol table
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-2].yy_name->name,
								new SIMCDefinedTypeReference (
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									(*s)->GetReferenceCount()) 
													);
							// delete (*s);
						}
						else
							theParser->SemanticError(theModule->GetInputFileName(),
											SYMBOL_REDEFINITION,
											yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
											yypvt[-2].yy_name->name);
					}
					else
						theModule->AddSymbol( new SIMCDefinedTypeReference (
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
								yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) );

				}
				delete yypvt[-2].yy_name;
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr133: {	/* BuiltinType :  _BOOLEAN */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->booleanType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr134: {	/* BuiltinType :  OBJECT IDENTIFIER */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->objectIdentifierType,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr135: {	/* BuiltinType :  Octetstring */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->octetStringType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr136: {	/* BuiltinType :  NIL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->nullType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr137: {	/* BuiltinType :  QualifiedIdOrIntegerOrBits NNlist */

				if( yypvt[0].yy_named_number_list && yypvt[-1].yy_symbol_ref )
				{
					char *badName = theParser->GenerateSymbolName();
					if(yypvt[-1].yy_symbol_ref->s == theParser->integerType)
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}
					else if (yypvt[-1].yy_symbol_ref->s == theParser->bitsType)
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_BITS),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}
					else
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_UNKNOWN),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}

					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
								yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
					delete badName;
					delete yypvt[-1].yy_symbol_ref;
				}
				else  if(yypvt[-1].yy_symbol_ref)
					yyval.yy_symbol_ref = yypvt[-1].yy_symbol_ref;
				else
					yyval.yy_symbol_ref = NULL;
			
} break;

case YYr138: {	/* BuiltinType :  SequenceOf Type */

				if(yypvt[0].yy_symbol_ref)
				{
					char *badName = theParser->GenerateSymbolName();
					theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCSequenceOfType(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column),
								badName,
								SIMCSymbol::LOCAL,
								theModule,
								yypvt[-1].yy_name->line, yypvt[-1].yy_name->column) );
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
								yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					delete badName;
				}
				else
					yyval.yy_symbol_ref = NULL;
				delete yypvt[-1].yy_name;
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr139: {	/* BuiltinType :  SEQUENCE LBRACE ElementTypes RBRACE */

				delete yypvt[-3].yy_name;
				if(newSequenceList)
				{
					char *badName = theParser->GenerateSymbolName();
					theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCSequenceType(newSequenceList),
								badName,
								SIMCSymbol::LOCAL,
								theModule) );
					yyval.yy_symbol_ref = new SIMCSymbolReference (
						theModule->GetSymbol(badName), yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
					delete badName;
					newSequenceList = new SIMCSequenceList;
				}
				else
				{
					theParser->SyntaxError(SEQUENCE_DEFINITION);
					newSequenceList = new SIMCSequenceList;
					yyval.yy_symbol_ref = NULL;
				}
			
} break;

case YYr140: {	/* BuiltinType :  SEQUENCE LBRACE error RBRACE */

				theParser->SyntaxError(SEQUENCE_DEFINITION);
				yyval.yy_symbol_ref = NULL;
				delete yypvt[-3].yy_name;
			
} break;

case YYr141: {	/* QualifiedIdOrIntegerOrBits :  INTEGER */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->integerType, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr142: {	/* QualifiedIdOrIntegerOrBits :  BITSXX */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->bitsType, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr144: {	/* NNlist :  LBRACE NamedNumberList RBRACE */

				yyval.yy_named_number_list = newNamedNumberList;
				newNamedNumberList = new SIMCNamedNumberList;
			
} break;

case YYr145: {	/* NNlist :  empty */

				yyval.yy_named_number_list = NULL;
			
} break;

case YYr146: {	/* NNlist :  LBRACE error RBRACE */

				yyval.yy_named_number_list = NULL;
				delete newNamedNumberList;
				newNamedNumberList = new SIMCNamedNumberList;
				theParser->SyntaxError(INTEGER_ENUMERATION);
			
} break;

case YYr149: {	/* NamedNumber :  NAME LPAREN NamedNumberValue RPAREN */

				newNamedNumberList->AddTail(new SIMCNamedNumberItem(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, 
					yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column));
				delete yypvt[-3].yy_name; 
				delete yypvt[-1].yy_symbol_ref;
			
} break;

case YYr152: {	/* NumericValue :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned, 
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				delete badName;
				delete yypvt[0].yy_number;
			
} break;

case YYr153: {	/* NumericValue :  LIT_HEX_STRING */

				// attempt to convert it to a signed long
				register char *cp = yypvt[0].yy_hex_string->value;
				if(strlen(cp) > 8)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
											INTEGER_TOO_BIG,
											yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				}
		
				for (long i = 0; *cp; cp++ ) 
				{
				    i *= 16;
					i += HexCharToDecimal(*cp);
                }
				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(i, TRUE, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete badName;
				delete yypvt[0].yy_hex_string;

			
} break;

case YYr154: {	/* NumericValue :  LIT_BINARY_STRING */

				register char *cp = yypvt[0].yy_binary_string->value;
				if(strlen(cp) > 32)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
											INTEGER_TOO_BIG,
											yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				}
				for (long i = 0; *cp; cp++ ) 
				{
				    i <<= 1;
					i += *cp - '0';
                }
				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(i, TRUE, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete badName;
				delete yypvt[0].yy_binary_string;

			
} break;

case YYr157: {	/* NamedType :  NAME Type */

				if(!theModule->GetSymbol(yypvt[-1].yy_name->name) )  
					theModule->AddSymbol( new SIMCUnknown(yypvt[-1].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[-1].yy_name->line,
										yypvt[-1].yy_name->column, 0));

				if (yypvt[0].yy_symbol_ref)
					newSequenceList->AddTail(new SIMCSequenceItem(
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										theModule->GetSymbol(yypvt[-1].yy_name->name),
										yypvt[-1].yy_name->line, yypvt[-1].yy_name->column));
				else
					theParser->SyntaxError(SEQUENCE_DEFINITION);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;

			
} break;

case YYr158: {	/* ToleratedOIDAssignment :  NAME AllowedCCE ObjectID */

		SIMCSymbol ** s = theModule->GetSymbol(yypvt[-2].yy_name->name);	
		if(s) // Symbol exists in symbol table
		{
			if(  typeid(**s) == typeid(SIMCUnknown) )
			{
				theModule->ReplaceSymbol( yypvt[-2].yy_name->name,
					new SIMCDefinedValueReference (
						theParser->objectIdentifierType,
						yypvt[-2].yy_name->line, yypvt[-2].yy_name->column, 
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
						yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
						yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
						(*s)->GetReferenceCount()) );
				// delete (*s);
			}
			else
			{
				theParser->SemanticError(theModule->GetInputFileName(),
									SYMBOL_REDEFINITION,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
			}
		}
		else
			theModule->AddSymbol( new SIMCDefinedValueReference (
					theParser->objectIdentifierType,
					yypvt[-2].yy_name->line, yypvt[-2].yy_name->column, 
					yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
					yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
					yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) );

		delete yypvt[-2].yy_name;
		delete yypvt[0].yy_symbol_ref;

	
} break;

case YYr159: {	/* Valueassignment :  NAME Type AllowedCCE Value */

				if(yypvt[0].yy_symbol_ref && yypvt[-2].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-3].yy_name->name);	
					if(s) // Symbol exists in symbol table
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-3].yy_name->name,
								new SIMCDefinedValueReference (
									yypvt[-2].yy_symbol_ref->s, yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-3].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-3].yy_name->line, yypvt[-3].yy_name->column,
									(*s)->GetReferenceCount()) );
							// delete (*s);
						}
						else
						{
							theParser->SemanticError(theModule->GetInputFileName(),
												SYMBOL_REDEFINITION,
												yypvt[-3].yy_name->line, yypvt[-3].yy_name->column,
												yypvt[-3].yy_name->name);
						}
					}
					else
					{
						theModule->AddSymbol( new SIMCDefinedValueReference (
								yypvt[-2].yy_symbol_ref->s, yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column, 
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
								yypvt[-3].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-3].yy_name->line, yypvt[-3].yy_name->column) );
					}

				}
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
				if(yypvt[-2].yy_symbol_ref)
					delete yypvt[-2].yy_symbol_ref;
				delete yypvt[-3].yy_name;
			
} break;

case YYr162: {	/* BuiltinValue :  TRUE_VAL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->trueValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;

			
} break;

case YYr163: {	/* BuiltinValue :  FALSE_VAL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->falseValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr164: {	/* BuiltinValue :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (theParser->integerType,
							0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned,
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				delete badName;
				delete yypvt[0].yy_number;
			
} break;

case YYr165: {	/* BuiltinValue :  LIT_HEX_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_hex_string->value, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete yypvt[0].yy_hex_string;
				delete badName;
			
} break;

case YYr166: {	/* BuiltinValue :  LIT_BINARY_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(TRUE, yypvt[0].yy_binary_string->value, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete yypvt[0].yy_binary_string;
				delete badName;
			
} break;

case YYr167: {	/* BuiltinValue :  LBRACE ObjectIDComponentList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType, 0, 0, 
							new SIMCOidValue(newOidComponentList),
							badName, SIMCSymbol::LOCAL, theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName), 0, 0);
				delete badName;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr168: {	/* BuiltinValue :  LBRACE NameList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->bitsType, 0, 0, 
							new SIMCBitsValue(newNameList),
							badName, SIMCSymbol::LOCAL, theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName), 0, 0);
				delete badName;
				newNameList = new SIMCBitValueList;
			
} break;

case YYr169: {	/* BuiltinValue :  LITSTRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType, 0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete badName;
				delete yypvt[0].yy_name;
			
} break;

case YYr170: {	/* BuiltinValue :  NIL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->nullValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr173: {	/* Name :  NAME */

				newNameList->AddTail(new SIMCBitValue(yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column) );
			
} break;

case YYr176: {	/* Octetstring :  OCTET STRING */

				yyval.yy_name = yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr179: {	/* SequenceOf :  SEQUENCE OF */

				yyval.yy_name = yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr180: {	/* SubType :  Type SubtypeRangeSpec */

					if(yypvt[-1].yy_symbol_ref && yypvt[0].yy_range_list)
					{
						// Create a range sub type
						SIMCRangeType *type = new SIMCRangeType (yypvt[-1].yy_symbol_ref->s, 
								yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, yypvt[0].yy_range_list);
						char *badName = theParser->GenerateSymbolName();
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
							type,
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
						yyval.yy_symbol_ref = new SIMCSymbolReference( theModule->GetSymbol(badName),
									yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
						delete badName;
					}
					else
					{
						yyval.yy_symbol_ref = NULL;
					}
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr181: {	/* SubType :  Type SubtypeSizeSpec */

					if(yypvt[-1].yy_symbol_ref && yypvt[0].yy_range_list)
					{
						// Create a range sub type
						SIMCSizeType *type = new SIMCSizeType (yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line,
								yypvt[-1].yy_symbol_ref->column, yypvt[0].yy_range_list);
						char *badName = theParser->GenerateSymbolName();
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
							type,
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
						yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
									yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
						delete badName;
					}
					else
					{
						yyval.yy_symbol_ref = NULL;
					}
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr182: {	/* SubType :  Type error */

					yyval.yy_symbol_ref = NULL;
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr183: {	/* SubtypeRangeSpec :  LPAREN SubtypeRangeAlternative SubtypeRangeAlternativeList RPAREN */

					yyval.yy_range_list = newRangeList;
					newRangeList = new SIMCRangeList;
				
} break;

case YYr184: {	/* SubtypeRangeSpec :  LPAREN error RPAREN */

						delete newRangeList;
						newRangeList = new SIMCRangeList;
						yyval.yy_range_list = NULL;
						theParser->SyntaxError(SUB_TYPE_SPECIFICATION);
						YYERROR;
					
} break;

case YYr185: {	/* SubtypeRangeAlternative :  SubtypeValueSet */

						newRangeList->AddTail(yypvt[0].yy_range_or_size_item);
					
} break;

case YYr188: {	/* SubtypeValueSet :  NumericValue */

				SIMCBuiltInValueReference *bvRef = 
					(SIMCBuiltInValueReference *)(*yypvt[0].yy_symbol_ref->s);
				SIMCIntegerValue *intValue = (SIMCIntegerValue*)bvRef->GetValue();
				yyval.yy_range_or_size_item = new SIMCRangeOrSizeItem(
							intValue->GetIntegerValue(), intValue->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							intValue->GetIntegerValue(), intValue->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column);
				theModule->RemoveSymbol((*yypvt[0].yy_symbol_ref->s)->GetSymbolName());
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr189: {	/* SubtypeValueSet :  NumericValue DOTDOT NumericValue */

				SIMCBuiltInValueReference *bvRef1 = 
					(SIMCBuiltInValueReference *)(*yypvt[-2].yy_symbol_ref->s);
				SIMCIntegerValue *intValue1 = (SIMCIntegerValue*)bvRef1->GetValue();
				SIMCBuiltInValueReference *bvRef3 = 
					(SIMCBuiltInValueReference *)(*yypvt[0].yy_symbol_ref->s);
				SIMCIntegerValue *intValue3 = (SIMCIntegerValue*)bvRef3->GetValue();
				
					yyval.yy_range_or_size_item = new SIMCRangeOrSizeItem(
							intValue1->GetIntegerValue(), intValue1->IsUnsigned(),
							yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column,
							intValue3->GetIntegerValue(), intValue3->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column);
					theModule->RemoveSymbol((*yypvt[-2].yy_symbol_ref->s)->GetSymbolName());
					theModule->RemoveSymbol((*yypvt[0].yy_symbol_ref->s)->GetSymbolName());
					delete yypvt[-2].yy_symbol_ref;
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr190: {	/* SubtypeSizeSpec :  LPAREN _SIZE SubtypeRangeSpec RPAREN */

						yyval.yy_range_list = yypvt[-1].yy_range_list;
						delete yypvt[-2].yy_name;
					
} break;

case YYr191: {	/* SubtypeSizeSpec :  LPAREN _SIZE error RPAREN */

						yyval.yy_range_list = NULL;
						delete yypvt[-2].yy_name;
						theParser->SyntaxError(SIZE_SPECIFICATION);
					
} break;

case YYr192: {	/* QualifiedName :  ID DOT NAME */

			SIMCSymbol **s;
			if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) ))		
					theModule->AddSymbol(
						new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, 
										theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0) );
				yyval.yy_symbol_ref = new SIMCSymbolReference (theModule->GetSymbol(yypvt[0].yy_name->name),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
			}
			else
			{			
				SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
				if(m) 
				{
					if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ) )
					{
						theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_SYMBOL_ABSENT,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column,
									yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
						yyval.yy_symbol_ref = NULL;
					}
					else
						yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else // Module is not mentioned in imports
				{
					theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_MODULE_ABSENT,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
					yyval.yy_symbol_ref = NULL;
				}
			}
			delete yypvt[-2].yy_name;
			delete yypvt[0].yy_name;				
	
} break;

case YYr193: {	/* QualifiedName :  NAME */

				SIMCSymbol **s;
				const SIMCModule *reservedModule;

				// Reserved Symbol
				if(reservedModule = theParser->IsReservedSymbol(yypvt[0].yy_name->name))
				{
					// If Symbol exists in the current module too,
					//		dont use that definition since this is a reserved symbol.
					//		Instead issue a warning.
					// else cool.
					if( s = theModule->GetSymbol(yypvt[0].yy_name->name) )  
					{
						if( ! theParser->IsReservedSymbol(yypvt[0].yy_name->name, theModule->GetModuleName()) ) 
							theParser->SemanticError(theModule->GetInputFileName(),
										KNOWN_REDEFINITION,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, reservedModule->GetModuleName());
					}
					yyval.yy_symbol_ref = new SIMCSymbolReference(reservedModule->GetSymbol(yypvt[0].yy_name->name),
													yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}  
				// Not a reserved symbol, but defined in this module
				else if ( s = theModule->GetSymbol(yypvt[0].yy_name->name))
					yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column) ;
				// Not a reserved symbol, not defined in this module so far.
				// Create a new entry, hoping that it will be defined later, or is imported
				else
				{		
					theModule->AddSymbol( new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0));
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(yypvt[0].yy_name->name),
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				delete yypvt[0].yy_name;
	
} break;

case YYr194: {	/* QualifiedId :  ID DOT ID */


			SIMCSymbol **s;
			if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) )  ) 		
					theModule->AddSymbol(
						new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0) );
				yyval.yy_symbol_ref = new SIMCSymbolReference (theModule->GetSymbol(yypvt[0].yy_name->name),
									yypvt[0].yy_name->line, yypvt[0].yy_name->column);
			}
			else
			{			
				SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
				if(m) 
				{
					if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ))
					{
						theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_SYMBOL_ABSENT,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column,
									yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
						yyval.yy_symbol_ref = NULL;
					}
					else
						yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else // Module is mentioned in imports
				{
					theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_MODULE_ABSENT,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
					yyval.yy_symbol_ref = NULL;
				}
			}
			delete yypvt[-2].yy_name;
			delete yypvt[0].yy_name;				
	
} break;

case YYr195: {	/* QualifiedId :  ID */

				SIMCSymbol **s;
				const SIMCModule *reservedModule;

				// Reserved Symbol
				if(reservedModule = theParser->IsReservedSymbol(yypvt[0].yy_name->name))
				{
					// If Symbol exists in the current module too,
					//		dont use that definition since this is a reserved symbol.
					//		Instead issue a warning.
					// else cool.
					if( s = theModule->GetSymbol(yypvt[0].yy_name->name) ) 
					{
						if( ! theParser->IsReservedSymbol(yypvt[0].yy_name->name,  theModule->GetModuleName()) ) 
							theParser->SemanticError(theModule->GetInputFileName(),
										KNOWN_REDEFINITION,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, reservedModule->GetModuleName());
					}
					yyval.yy_symbol_ref = new SIMCSymbolReference(reservedModule->GetSymbol(yypvt[0].yy_name->name),
													yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				// Not a reserved symbol, but defined in this module
				else if ( s = theModule->GetSymbol(yypvt[0].yy_name->name))
					yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column) ;
				// Not a reserved symbol, not defined in this module so far.
				// Create a new entry, hoping that it will be defined later, or is imported
				else
				{		
					theModule->AddSymbol( new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0));
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(yypvt[0].yy_name->name),
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				delete yypvt[0].yy_name;
	
} break;

case YYr196: {	/* AllowedCCE :  InsteadOfCCE */

			theParser->SyntaxError(INSTEAD_OF_CCE, yypvt[0].yy_name->line, yypvt[0].yy_name->column, NULL, yypvt[0].yy_name->name);
			delete yypvt[0].yy_name;
		
} break;

case YYr198: {	/* InsteadOfCCE :  ':' ':' */

			yyval.yy_name = new SIMCNameInfo("::", theScanner->yylineno, theScanner->columnNo - 2);
		
} break;

case YYr199: {	/* InsteadOfCCE :  ':' '=' */

			yyval.yy_name = new SIMCNameInfo(":=", theScanner->yylineno, theScanner->columnNo - 2);
		
} break;

case YYr200: {	/* InsteadOfCCE :  '=' */

			yyval.yy_name = new SIMCNameInfo("=", theScanner->yylineno, theScanner->columnNo - 1);
		
} break;

case YYr201: {	/* NotifyDefinition :  NAME NOTIFY ObjectsPart NotificationTypeStatusPart DESCRIPTION LITSTRING ReferPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(NOTIFICATION_TYPE_DISALLOWED);
					}
					break;
					default:
					{
						SIMCNotificationTypeType * type = new SIMCNotificationTypeType(
							yypvt[-6].yy_objects_list,
							(yypvt[-3].yy_name)?yypvt[-3].yy_name->name: NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line: 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column:0,
							(yypvt[-2].yy_name)?yypvt[-2].yy_name->name:NULL, (yypvt[-2].yy_name)?yypvt[-2].yy_name->line:0, (yypvt[-2].yy_name)?yypvt[-2].yy_name->column:0,
							yypvt[-5].yy_notification_type_status->a, yypvt[-5].yy_notification_type_status->line, yypvt[-5].yy_notification_type_status->column);

						char *badName1 = theParser->GenerateSymbolName();

						SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
								type, badName1, SIMCSymbol::LOCAL, theModule,
								yypvt[-7].yy_name->line, yypvt[-7].yy_name->column);

						theModule->AddSymbol(typeRef);
						
						// Add an OID value reference
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-8].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-8].yy_name->name,
									new SIMCDefinedValueReference (
										theModule->GetSymbol(badName1), 
										yypvt[-8].yy_name->line, yypvt[-8].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-8].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-8].yy_name->line, yypvt[-8].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-8].yy_name->line, yypvt[-8].yy_name->column,
													yypvt[-8].yy_name->name);
								// Remove the symbol for the type reference from the module
								// And delete it
								theModule->RemoveSymbol(badName1);
								delete type;
								delete typeRef;
								delete newObjectsList;
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theModule->GetSymbol(badName1), 
									yypvt[-8].yy_name->line, yypvt[-8].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-8].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-8].yy_name->line, yypvt[-8].yy_name->column) );


						delete badName1; 
					}
				}
				newObjectsList = new SIMCObjectsList;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-5].yy_notification_type_status; 
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr202: {	/* NotificationTypeStatusPart :  STATUS NAME */

				SIMCNotificationTypeType::StatusType a;
				if ((a=SIMCNotificationTypeType::StringToStatusType(yypvt[0].yy_name->name)) == SIMCNotificationTypeType::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								NOTIFICATION_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_notification_type_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_notification_type_status = new SIMCNotificationTypeStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr203: {	/* ObjectsPart :  OBJECTS LBRACE ObjectTypeListForNotification RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				yyval.yy_objects_list = newObjectsList;
			
} break;

case YYr204: {	/* ObjectsPart :  empty */

				yyval.yy_objects_list = newObjectsList;
			
} break;

case YYr205: {	/* ObjectsPart :  OBJECTS error */

				yyval.yy_objects_list = newObjectsList;
				theParser->SyntaxError(OBJECTS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr209: {	/* ObjectTypeForNotification :  QualifiedName */

					if(yypvt[0].yy_symbol_ref)
					{
						newObjectsList->AddTail(
							new SIMCObjectsItem(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
						delete yypvt[0].yy_symbol_ref;
					}
				
} break;

case YYr210: {	/* ModuleIDefinition :  NAME MODULEID LASTUPDATE LITSTRING ORGANIZATION LITSTRING CONTACTINFO LITSTRING DESCRIPTION LITSTRING RevisionPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_IDENTITY_DISALLOWED);
					}
					break;
					default:
					{
						theModule->SetModuleIdentityName(yypvt[-12].yy_name->name);
						theModule->SetLastUpdated(yypvt[-9].yy_name->name);
						theModule->SetOrganization(yypvt[-7].yy_name->name);
						theModule->SetContactInfo(yypvt[-5].yy_name->name);
						theModule->SetDescription(yypvt[-3].yy_name->name);

						// Create a value reference in the symbol table,
						// since the symbol can be used as an OID value
					
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
									(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType, 
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );

					}
					break;
				}
					
				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr215: {	/* Revision :  REVISION LITSTRING DESCRIPTION LITSTRING */

				theModule->AddRevisionClause( new SIMCRevisionElement (
									yypvt[-2].yy_name->name, yypvt[0].yy_name->name) );
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr216: {	/* ObjectDefinition :  NAME OBJECTIDENT ObjectIdentityStatusPart DescrPart ReferPart AllowedCCE ObjectID */

				switch( theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(OBJECT_IDENTITY_DISALLOWED);
					}
					break;
					default:
					{
						// Form an SIMCObjectIdentity type
						SIMCObjectIdentityType * type = new SIMCObjectIdentityType(
							yypvt[-4].yy_object_identity_status->a, yypvt[-4].yy_object_identity_status->line, yypvt[-4].yy_object_identity_status->column,
							(yypvt[-3].yy_name)? yypvt[-3].yy_name->name : NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line : 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column : 0,
							(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL, (yypvt[-2].yy_name)? yypvt[-2].yy_name->line : 0, (yypvt[-2].yy_name)? yypvt[-2].yy_name->column : 0);

						char *badName = theParser->GenerateSymbolName();
						SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
								type, badName, SIMCSymbol::LOCAL, theModule,
								yypvt[-5].yy_name->line, yypvt[-5].yy_name->column );
						theModule->AddSymbol(typeRef);
						
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-6].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-6].yy_name->name,
									new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-5].yy_name->line, yypvt[-5].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-6].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-6].yy_name->line, yypvt[-6].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-6].yy_name->line, yypvt[-6].yy_name->column,
													yypvt[-6].yy_name->name);
								// Remove the symbol for the type reference from the module
								// And delete it
								theModule->RemoveSymbol(badName);
								delete type;
								delete typeRef;
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theModule->GetSymbol(badName), 
									yypvt[-5].yy_name->line, yypvt[-5].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-6].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-6].yy_name->line, yypvt[-6].yy_name->column) );
						}
					}

					delete yypvt[-6].yy_name;
					delete yypvt[-5].yy_name;
					if(yypvt[-4].yy_object_identity_status) delete yypvt[-4].yy_object_identity_status;
					if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
					if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
					if(yypvt[0].yy_symbol_ref) delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr217: {	/* ObjectIdentityStatusPart :  STATUS NAME */

				SIMCObjectIdentityType::StatusType a;
				if ((a=SIMCObjectIdentityType::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_IDENTITY_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_object_identity_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_object_identity_status = new SIMCObjectIdentityStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr218: {	/* TextualConventionDefinition :  ID AllowedCCE TEXTCONV DisplayPart STATUS NAME DESCRIPTION LITSTRING ReferPart SYNTAX Type */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(TEXTUAL_CONVENTION_DISALLOWED);
					}
					break;
					default:
					{
						// See if the status clause is valid
						SIMCTextualConvention::SIMCTCStatusType status =
									 SIMCTextualConvention::StringToStatusType(yypvt[-5].yy_name->name);
						if(SIMCTextualConvention::TC_INVALID == status)
							theParser->SemanticError(theModule->GetInputFileName(),
								TC_INVALID_STATUS,
								yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
								yypvt[-5].yy_name->name);
						else
						{	 
							if (yypvt[0].yy_symbol_ref)
							{
								SIMCSymbol ** s = theModule->GetSymbol(yypvt[-10].yy_name->name);	
								if(s) // Symbol exists in symbol table
								{
									if(  typeid(**s) == typeid(SIMCUnknown) )
									{
										theModule->ReplaceSymbol( yypvt[-10].yy_name->name,
											new SIMCTextualConvention (
												(yypvt[-7].yy_name)? yypvt[-7].yy_name->name : NULL,
												status, yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
												yypvt[-3].yy_name->name, 
												(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL,
												yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
												yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
												yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
												(*s)->GetReferenceCount()) 
																);
										// delete (*s);
									}
									else
										theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
														yypvt[-10].yy_name->name);
								}
								else
									theModule->AddSymbol( new SIMCTextualConvention (
												(yypvt[-7].yy_name)? yypvt[-7].yy_name->name : NULL,
												status, yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
												yypvt[-3].yy_name->name, 
												(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL,
												yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
												yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
												yypvt[-10].yy_name->line, yypvt[-10].yy_name->column) );

							}
						}
					}
					break;
				}
					
				delete yypvt[-10].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr219: {	/* DisplayPart :  DISPLAYHINT LITSTRING */

				delete yypvt[-1].yy_name;
				yyval.yy_name = yypvt[0].yy_name;
			
} break;

case YYr220: {	/* DisplayPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr221: {	/* ObjectGroupDefinition :  NAME OBJECTGROUP OBJECTS LBRACE VarTypeList RBRACE STATUS NAME DESCRIPTION LITSTRING ReferPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(OBJECT_GROUP_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );
					}
					break;
				}

				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr222: {	/* NotifyGroupDefinition :  NAME NOTIFYGROUP NOTIFICATIONS LBRACE VarTypeList RBRACE STATUS NAME DESCRIPTION LITSTRING ReferPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(NOTIFICATION_GROUP_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );
					}
					break;
				}
				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr223: {	/* ModComplianceDefinition :  NAME MODCOMP STATUS NAME DESCRIPTION LITSTRING ReferPart MibPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_COMPLIANCE_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-9].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-9].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-9].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-9].yy_name->line, yypvt[-9].yy_name->column,
													yypvt[-9].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-9].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column) );
					}
				}
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr228: {	/* Mib :  MODULE ModuleIdentifierUnused MandatoryPart CompliancePart */

				delete yypvt[-3].yy_name;
			
} break;

case YYr229: {	/* Mib :  MODULE MandatoryPart CompliancePart */

				delete yypvt[-2].yy_name;
			
} break;

case YYr230: {	/* ModuleIdentifierUnused :  ID */

				if(yypvt[0].yy_name)
					delete (yypvt[0].yy_name);

			
} break;

case YYr231: {	/* ModuleIdentifierUnused :  ID ObjectID */

					if(yypvt[-1].yy_name)
						delete (yypvt[-1].yy_name);
					if(yypvt[0].yy_symbol_ref)
						delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr232: {	/* MandatoryPart :  MANDATORY LBRACE VarTypeList RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr238: {	/* Compliance :  GROUP NAME DESCRIPTION LITSTRING */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr239: {	/* Compliance :  OBJECT NAME Syntax WriteSyntax MinAccessPart DESCRIPTION LITSTRING */

				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr240: {	/* Syntax :  SYNTAX Type */

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr242: {	/* WriteSyntax :  WSYNTAX Type */

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr244: {	/* MinAccessPart :  MINACCESS NAME */

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr246: {	/* AgentCapabilitiesDefinition :  NAME AGENTCAP PRELEASE LITSTRING STATUS NAME DESCRIPTION LITSTRING ReferPart ModulePart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(AGENT_CAPABILITIES_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-11].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-11].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
													yypvt[-11].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column) );
					}
				}
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr251: {	/* Module :  SUPPORTS ModuleReference INCLUDING LBRACE VarTypeList RBRACE VariationPart */

				delete yypvt[-6].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
			
} break;

case YYr252: {	/* ModuleReference :  ID LBRACE ObjectIDComponentList RBRACE */

			delete yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
		
} break;

case YYr253: {	/* ModuleReference :  ID */

			delete yypvt[0].yy_name;
		
} break;

case YYr258: {	/* Variation :  VARIATION NAME Syntax WriteSyntax AccessPart CreationPart DefValPart DESCRIPTION LITSTRING */

				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-2].yy_def_val;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr259: {	/* CreationPart :  CREATION LBRACE Creation RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;
	case YYrACCEPT:
		YYACCEPT;
	case YYrERROR:
		goto yyError;
	}
yyNext:
	/*
	 *	Look up next state in goto table.
	 */

	yyp = &yygo[yypgo[yyi]];
	yyq = yyp++;
	yyi = *yyps;
	while (yyi < *yyp++)		/* busy little loop */
		;
	yystate = ~(yyi == *--yyp? yyq[yyq-yyp]: *yyq);
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowGoto)
#endif
	goto yyStack;

yyerrlabel:	;		/* come here from YYERROR	*/
	yyerrflag = 1;
	if (yyi == YYrERROR) {
		yyps--, yypv--;
#if YYDEBUG
		if (yydebug) yytp--;
#endif
	}
	
yyError:
	switch (yyerrflag) {

	case 0:		/* new error */
		yynerrs++;
		yyi = (short)yychar;
		scan->yyerror("Syntax error");
		if (yyi != yychar) {
			/* user has changed the current token */
			/* try again */
			yyerrflag++;	/* avoid loops */
			goto yyEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		yyerrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; yyps > stateStack; yyps--, yypv--
#if YYDEBUG
					, yytp--
#endif
		) {
#ifdef YACC_WINDOWS
			if (*yyps >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
			if (*yyps >= sizeof yypact/sizeof yypact[0])
#endif /* YACC_WINDOWS */
				continue;
			yyp = &yyact[yypact[*yyps]];
			yyq = yyp;
			do
				;
			while (YYERRCODE < *yyp++);
			if (YYERRCODE == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
				goto yyStack;
			}
				
			/* no shift in this state */
#if YYDEBUG
			if (yydebug && yyps > stateStack+1)
				YY_TRACE(yyShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (yychar == 0)  /* but not EOF */
			break;
#if YYDEBUG
		if (yydebug)
			YY_TRACE(yyShowErrDiscard)
#endif
		yyclearin();
		goto yyEncore;	/* try again in same state */
	}
	YYABORT;

}
#if YYDEBUG
/*
 * Return type of token
 */
int
yy_parse::yyGetType(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}

	
// Print a token legibly.
char *
yy_parse::yyptok(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}
/*
 * Read state 'num' from YYStatesFile
 */
#ifdef YYTRACE

char *
yy_parse::yygetState(int num)
{
	int	size;
	char	*cp;
	static FILE *yyStatesFile = (FILE *) 0;
	static char yyReadBuf[YYMAX_READ+1];

	if (yyStatesFile == (FILE *) 0
	 && (yyStatesFile = fopen(YYStatesFile, "r")) == (FILE *) 0)
		return "yyExpandName: cannot open states file";

	if (num < yynstate - 1)
		size = (int)(States[num+1] - States[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(yyStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(yyStatesFile) - States[num]);
	}
	if (size < 0 || size > YYMAX_READ)
		return "yyExpandName: bad read size";
	if (fseek(yyStatesFile, States[num], 0) < 0) {
	cannot_seek:
		return "yyExpandName: cannot seek in states file";
	}

	(void) fread(yyReadBuf, 1, size, yyStatesFile);
	yyReadBuf[size] = '\0';
	return yyReadBuf;
}
#endif /* YYTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode yyStates and yyRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
yy_parse::yyExpandName(int num, int isrule, char * buf, int len)
{
	int	i, n, cnt, type;
	char	* endp, * cp, * s;

	if (isrule)
		s = yyRules[num].name;
	else
#ifdef YYTRACE
		s = yygetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = yynvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = yyntoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= yynvar)
					goto too_big;
				cp = yysvar[n];
			} else if (n >= yyntoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = yyTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef YYTRACE
/*
 * Show current state of yyparse
 */
void
yy_parse::yyShowState()
{
	(void) printf("state %d (%d), char %s (%d)\n%d stateStack entries\n",
		yysmap[yystate],yystate,yyptok(yychar),yychar,
		yypv - valueStack);
}
// show results of reduction: yyi is rule number
void
yy_parse::yyShowReduce()
{
	(void) printf("Reduce by rule %d (pop#=%d)\n", yyrmap[rule], npop);
}
// show read token
void
yy_parse::yyShowRead()
{
	(void) printf("read %s (%d)\n", yyptok(yychar), yychar);
}
// show Goto
void
yy_parse::yyShowGoto()
{
	(void) printf("goto %d (%d)\n", yysmap[yystate], yystate);
}
// show Shift
void
yy_parse::yyShowShift()
{
	(void) printf("shift %d (%d)\n", yysmap[yystate], yystate);
}
// show error recovery
void
yy_parse::yyShowErrRecovery()
{
	(void) printf("Error recovery pops state %d (%d), uncovers %d (%d)\n",
		yysmap[*(yyps-1)], *(yyps-1), yysmap[yystate], yystate);
}
// show token discards in error processing
void
yy_parse::yyShowErrDiscard()
{
	(void) printf("Error recovery discards %s (%d), ",
		yyptok(yychar), yychar);
}
#endif	/* ! YYTRACE */
#endif	/* YYDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsm\main.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <windows.h>

BOOL   WINAPI   DllMain (HANDLE hInst, 
                        ULONG ul_reason_for_call,
                        LPVOID lpReserved)
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsy\main.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <windows.h>

BOOL   WINAPI   DllMain (HANDLE hInst, 
                        ULONG ul_reason_for_call,
                        LPVOID lpReserved)
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smimsgif\main.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <windows.h>

BOOL   WINAPI   DllMain (HANDLE hInst, 
                        ULONG ul_reason_for_call,
                        LPVOID lpReserved)
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smimsgif\resource.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by D:\opal\pandoraNg\snmpProvider\compilers\smi2smir\lib\smimsgif\smimsgif.rc
//
#define COMPILED_FILE                   1
#define SYNTAX_CHECK_FAILED             2
#define SEMANTIC_CHECK_FAILED           3
#define SMIR_LOAD_FAILED                4
#define SMIR_LOAD_SUCCEEDED             5
#define SYNTAX_CHECK_SUCCEEDED          6
#define SEMANTIC_CHECK_SUCCEEDED        7
#define SYMBOL_RESOLUTION_FAILED        8
#define SMIR_CONNECT_FAILED             9
#define LISTING_MODULES                 10
#define LISTING_FAILED                  11
#define DELETE_SUCCEEDED                12
#define DELETE_FAILED                   13
#define PURGE_SUCCEEDED                 14
#define PURGE_FAILED                    15
#define DELETE_MODULE_NOT_FOUND         16
#define SMI2SMIR_INFO                   17
#define FILE_NOT_FOUND                  18
#define MODULE_LISTING                  19
#define MOF_GENERATION_SUCCEEDED        20
#define MOF_GENERATION_FAILED           21
#define MODULE_NAME_SUCCEEDED           22
#define MODULE_INFO_FAILED              23
#define NUMBER_OF_ENTRIES               24
#define DUPLICATE_MODULES               25
#define DIRECTORY_ADDITION_SUCCEEDED    26
#define DIRECTORY_ADDITION_FAILED       27
#define DIRECTORY_DELETION_SUCCEEDED    28
#define DIRECTORY_DELETION_FAILED       29
#define INVALID_MIB_FILE                30
#define PURGE_CONFIRMATION              31

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\cormap.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <cormap.h>
#include <cordefs.h>


void CCorrelatorMap::Register(CCorrelator *key)
{
	m_MapLock.Lock();
	SetAt((DWORD_PTR)key,key);
	m_MapLock.Unlock();
}


void CCorrelatorMap::UnRegister(CCorrelator *key)
{
	m_MapLock.Lock();
	RemoveKey((DWORD_PTR)key);
	m_MapLock.Unlock();
}


CCorrelatorMap::~CCorrelatorMap()
{
	m_MapLock.Lock();

	if (!IsEmpty())
	{
		POSITION pos = GetStartPosition();

		while(NULL != pos)
		{
			CCorrelator* ccorr;
			DWORD_PTR key;
			GetNextAssoc(pos, key, ccorr);
			ccorr->CancelRequest();
		}

		RemoveAll();
	}

	m_MapLock.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\clasprov.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the CImpClasProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>
#include <typeinfo.h>
#include <wbemidl.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include <correlat.h>
#include <genlex.h>
#include <objpath.h>
#include <cominit.h>

#include "classfac.h"
#include "clasprov.h"
#include "creclass.h"
#include "guids.h"

extern void ProviderStartup () ;
extern void ProviderClosedown () ;

BOOL CImpClasProv :: s_Initialised = FALSE ;

void SnmpClassDefaultThreadObject::Initialise ()
{
	InitializeCom () ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpClasProv::CImpClasProv
// CImpClasProv::~CImpClasProv
//
//***************************************************************************

CImpClasProv::CImpClasProv ()
:	ipAddressString ( NULL ) ,	
	parentServer ( NULL ) ,
	server ( NULL ) ,
	m_InitSink ( NULL ) ,
	propertyProvider ( NULL ) ,
	m_notificationClassObject ( NULL ) ,
	m_snmpNotificationClassObject ( NULL ) ,
	thisNamespace ( NULL )
{
	m_referenceCount = 0 ; 

/* 
 * Place code in critical section
 */

    InterlockedIncrement ( & CClasProvClassFactory :: objectsInProgress ) ;

/*
 * Implementation
 */

	initialised = FALSE ;
	ipAddressValue = NULL ;	
	m_getNotifyCalled = FALSE ;
	m_getSnmpNotifyCalled = FALSE ;
}

CImpClasProv::~CImpClasProv(void)
{

/*
 * Implementation
 */

	delete [] ipAddressString ;
	free ( ipAddressValue ) ;
 
	if ( parentServer )
		parentServer->Release () ;

	if ( server )
		server->Release () ;

	if ( m_InitSink )
		m_InitSink->Release () ;

	if ( propertyProvider )
		propertyProvider->Release () ;

	if ( m_notificationClassObject )
		m_notificationClassObject->Release () ;

	if ( m_snmpNotificationClassObject )
		m_snmpNotificationClassObject->Release () ;

	delete [] thisNamespace ;
/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CClasProvClassFactory :: objectsInProgress ) ;

}


//***************************************************************************
//
// CImpClasProv::QueryInterface
// CImpClasProv::AddRef
// CImpClasProv::Release
//
// Purpose: IUnknown members for CImpClasProv object.
//***************************************************************************

STDMETHODIMP CImpClasProv::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
		}	
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
		}

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}	
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

STDMETHODIMP_(ULONG) CImpClasProv::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement ( & m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}	
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CImpClasProv::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}	
	catch(...)
	{
		return 0;
	}
}

HRESULT CImpClasProv :: SetServer ( IWbemServices *serverArg ) 
{
	server = serverArg ;
	server->AddRef () ;
	
	//don't change anything but the cloaking...
	return WbemSetProxyBlanket(server,
					RPC_C_AUTHN_DEFAULT,
					RPC_C_AUTHZ_DEFAULT,
					COLE_DEFAULT_PRINCIPAL,
					RPC_C_AUTHN_LEVEL_DEFAULT,
					RPC_C_IMP_LEVEL_DEFAULT,
					NULL,
					EOAC_DYNAMIC_CLOAKING);
}

HRESULT CImpClasProv :: SetParentServer ( IWbemServices *parentServerArg ) 
{
	parentServer = parentServerArg ; 
	parentServer->AddRef () ;
	
	//don't change anything but the cloaking...
	return WbemSetProxyBlanket(parentServer,
					RPC_C_AUTHN_DEFAULT,
					RPC_C_AUTHZ_DEFAULT,
					COLE_DEFAULT_PRINCIPAL,
					RPC_C_AUTHN_LEVEL_DEFAULT,
					RPC_C_IMP_LEVEL_DEFAULT,
					NULL,
					EOAC_DYNAMIC_CLOAKING);
}

void CImpClasProv :: SetProvider ( IWbemServices *provider ) 
{ 
	propertyProvider = provider ; 
}

IWbemServices *CImpClasProv :: GetParentServer () 
{ 
	return ( IWbemServices * ) parentServer ; 
}

IWbemServices *CImpClasProv :: GetServer () 
{ 
	return ( IWbemServices * ) server ; 
}

WbemNamespacePath *CImpClasProv :: GetNamespacePath () 
{ 
	return & namespacePath ; 
}

IWbemClassObject *CImpClasProv :: GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_notificationClassObject )
	{
		m_notificationClassObject->AddRef () ;
	}

	return m_notificationClassObject ; 
}

IWbemClassObject *CImpClasProv :: GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_snmpNotificationClassObject )
	{
		m_snmpNotificationClassObject->AddRef () ;
	}

	return m_snmpNotificationClassObject ; 
}

wchar_t *CImpClasProv :: GetThisNamespace () 
{
	return thisNamespace ; 
}

void CImpClasProv :: SetThisNamespace ( wchar_t *thisNamespaceArg ) 
{
	thisNamespace = UnicodeStringDuplicate ( thisNamespaceArg ) ; 
}

BOOL CImpClasProv:: FetchSnmpNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx 
	
)
{
	m_snmpNotificationLock.Lock();
	BOOL status = TRUE ;

	if ( m_getSnmpNotifyCalled )
	{
		if ( ! m_snmpNotificationClassObject )
			status = FALSE ;
	}
	else
	{
		m_getSnmpNotifyCalled = TRUE ;
		IWbemClassObject *classObject = NULL ;
		ISmirInterrogator *smirInterrogator = NULL ;

		HRESULT result = CoCreateInstance (
 
			CLSID_SMIR_Database ,
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
			IID_ISMIR_Interrogative ,
			( void ** ) &smirInterrogator 
		);

		if ( SUCCEEDED ( result ) )
		{
			ISMIRWbemConfiguration *smirConfiguration = NULL ;
			result = smirInterrogator->QueryInterface ( IID_ISMIRWbemConfiguration , ( void ** ) & smirConfiguration ) ;
			if ( SUCCEEDED ( result ) )
			{
				smirConfiguration->SetContext ( a_Ctx) ;
				smirConfiguration->Release () ;

				result = smirInterrogator->GetWBEMClass ( &m_snmpNotificationClassObject , WBEM_CLASS_SNMPNOTIFYSTATUS ) ;	
				if ( ! SUCCEEDED ( result ) )
				{
					status = FALSE ;

					m_snmpNotificationClassObject = NULL ;
				}
			}
			else
			{		
				status = FALSE ;

				m_snmpNotificationClassObject = NULL ;
			}

			smirInterrogator->Release () ;
		}
	}

	m_snmpNotificationLock.Unlock();
	return status ;
}

BOOL CImpClasProv:: FetchNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx 
)
{
	m_notificationLock.Lock();
	BOOL status = TRUE ;

	if ( m_getNotifyCalled )
	{
		if ( ! m_notificationClassObject )
			status = FALSE ;
	}
	else
	{
		m_getNotifyCalled = TRUE ;

		BSTR t_Class = SysAllocString ( WBEM_CLASS_EXTENDEDSTATUS ) ;

		HRESULT result = server->GetObject (

			t_Class ,
			0 ,
			a_Ctx ,
			& m_notificationClassObject ,
			NULL
		) ;

		SysFreeString ( t_Class ) ;

		if ( ! SUCCEEDED ( result ) )
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;
		}
	}

	m_notificationLock.Unlock();
	return status ;
}

BOOL CImpClasProv::AttachParentServer ( 

	WbemSnmpErrorObject &a_errorObject , 
	BSTR ObjectPath, 
	IWbemContext *pCtx
)
{
DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpClasProv::AttachParentServer ( (%s) )" ,
		ObjectPath
	) ;
)

	BOOL status = TRUE ;

	IWbemLocator *locator = NULL ;
	IWbemServices *t_server = NULL ;

// Get Parent Namespace Path

	WbemNamespacePath *namespacePath = GetNamespacePath () ;

	ULONG count = namespacePath->GetCount () ;
	wchar_t *path = NULL ;

	if ( namespacePath->GetServer () )
	{
		path = UnicodeStringDuplicate ( L"\\\\" ) ;
		wchar_t *concatPath = UnicodeStringAppend ( path , namespacePath->GetServer () ) ;
		delete [] path ;
		path = concatPath ;
	}

	if ( ! namespacePath->Relative () )
	{
		wchar_t *concatPath = UnicodeStringAppend ( path , L"\\" ) ;
		delete [] path ;
		path = concatPath ;
	}

	ULONG pathIndex = 0 ;		
	wchar_t *pathComponent ;
	namespacePath->Reset () ;
	while ( ( pathIndex < count - 1 ) && ( pathComponent = namespacePath->Next () ) ) 
	{
		wchar_t *concatPath = UnicodeStringAppend ( path , pathComponent ) ;
		delete [] path ;
		path = concatPath ;
		if ( pathIndex < count - 2 )
		{
			concatPath = UnicodeStringAppend ( path , L"\\" ) ;
			delete [] path ;
			path = concatPath ;
		}

		pathIndex ++ ;
	}

	if ( pathComponent = namespacePath->Next () )
	{
		SetThisNamespace ( pathComponent ) ; 
	}

DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Calling ConnectServer ( (%s) )" ,
		path
	) ;
)

// Connect to parent namespace
	
	HRESULT result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemLocator ,
		( void ** )  & locator
	);
	if ( SUCCEEDED ( result ) )
	{
		result = locator->ConnectServer (

			path ,
			NULL ,
			NULL ,
			NULL  ,
			0 ,
			NULL,
			pCtx,
			( IWbemServices ** ) & t_server 
		) ;

		if ( SUCCEEDED ( result ) )
		{
			result = SetParentServer ( t_server ) ;
			t_server->Release();

			if ( FAILED ( result ) && result != E_NOINTERFACE ) //implies there is no prxy security - inproc.
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
				a_errorObject.SetMessage ( L"Failed to secure proxy to this namespace's parent namespace" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
			a_errorObject.SetMessage ( L"Failed to connect to this namespace's parent namespace" ) ;
		}

		locator->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
		a_errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemLocator" ) ;
	}

	delete [] path ;

DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpClasProv::AttachParentServer ( (%s) ) with result" ,
		ObjectPath ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

BOOL CImpClasProv::ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpClasProv::ObtainCachedIpAddress ()"
	) ;
)

	BOOL status = TRUE ;

	IWbemClassObject *namespaceObject = NULL ;

	wchar_t *objectPathPrefix = UnicodeStringAppend ( WBEM_NAMESPACE_EQUALS , GetThisNamespace () ) ;
	wchar_t *objectPath = UnicodeStringAppend ( objectPathPrefix , WBEM_NAMESPACE_QUOTE ) ;

	delete [] objectPathPrefix ;

	BSTR t_Path = SysAllocString ( objectPath ) ;

	HRESULT result = parentServer->GetObject ( 

		t_Path ,		
		0 ,
		NULL ,
		&namespaceObject ,
		NULL
	) ;

	SysFreeString(t_Path);

	delete [] objectPath ;

	if ( SUCCEEDED ( result ) )
	{
		IWbemQualifierSet *classQualifierObject ;
		result = namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
		if ( SUCCEEDED ( result ) )
		{

			VARIANT variant ;
			VariantInit ( & variant ) ;

			LONG attributeType ;
			result = classQualifierObject->Get ( 

				WBEM_QUALIFIER_AGENTTRANSPORT , 
				0,	
				&variant ,
				& attributeType 
			) ;

			if ( SUCCEEDED ( result ) )
			{
				if ( variant.vt == VT_BSTR ) 
				{
					if ( _wcsicmp ( variant.bstrVal , L"IP" ) == 0 )
					{
						VARIANT variant ;
						VariantInit ( & variant ) ;

						LONG attributeType ;
						result = classQualifierObject->Get ( 

							WBEM_QUALIFIER_AGENTADDRESS , 
							0,	
							&variant ,
							& attributeType 
						) ;

						if ( SUCCEEDED ( result ) )
						{
							if ( variant.vt == VT_BSTR ) 
							{
								ipAddressString = UnicodeToDbcsString ( variant.bstrVal ) ;
								if ( ipAddressString )
								{						

									SnmpTransportIpAddress transportAddress ( 
			
										ipAddressString , 
										SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE 
									) ;

									if ( transportAddress () )
									{	
										ipAddressValue = _strdup ( transportAddress.GetAddress () ) ;
									}
									else
									{
										delete [] ipAddressString ;
										ipAddressString = NULL ;

	/*
	 *	Invalid Transport Address.
	 */

										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
									}
 								}
								else
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
							}
						}
						else
						{
/*
 *	Transport Address not specified, ignore it
 */
						}

						VariantClear ( &variant ) ;
					}
					else if ( _wcsicmp ( variant.bstrVal , L"IPX" ) == 0 )
					{
					}
					else
					{
// Unknown transport type

						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}
				}
				else
				{
/*
 *	Transport qualifier was not a string value
 */

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
				}
			}
			else
			{
				LONG attributeType ;
				result = classQualifierObject->Get ( 

					WBEM_QUALIFIER_AGENTADDRESS , 
					0,	
					&variant ,
					& attributeType
				) ;

				if ( SUCCEEDED ( result ) )
				{
					if ( variant.vt == VT_BSTR ) 
					{
						ipAddressString = UnicodeToDbcsString ( variant.bstrVal ) ;
						if ( ipAddressString )
						{
							SnmpTransportIpAddress transportAddress ( 

								ipAddressString , 
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE 
							) ;

							if ( transportAddress () )
							{	
								ipAddressValue = _strdup ( transportAddress.GetAddress () ) ;
							}
							else
							{
								delete [] ipAddressString ;
								ipAddressString = NULL ;

	/*
	 *	Invalid Transport Address.
	 */

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;

						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
					}
				}
				else
				{
/*
 *	Transport Address not specified, ignore it
 */
				}

				VariantClear ( &variant ) ;
			}

			VariantClear ( & variant );
		}

		namespaceObject->Release () ;
	}

DebugMacro0( 

	wchar_t *t_UnicodeString = ipAddressValue ? DbcsToUnicodeString ( ipAddressValue ) : NULL ;

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from CImpClasProv::ObtainCachedIpAddress () with IP Address (%s)",
		t_UnicodeString ? t_UnicodeString : L"NULL"
	) ;

	delete [] t_UnicodeString ;
)

	return status ;
}


HRESULT STDMETHODCALLTYPE CImpClasProv::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro0( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpClasProv::GetObjectAsync ( (%s) )" ,
			ObjectPath
		) ;
)

		if (SUCCEEDED(result))
		{
			WbemSnmpErrorObject errorObject ;

			ParsedObjectPath *t_ParsedObjectPath = NULL ;
			CObjectPathParser t_ObjectPathParser ;

			BOOL status = t_ObjectPathParser.Parse ( ObjectPath , &t_ParsedObjectPath ) ;
			if ( status == 0 )
			{
			// Class requested

				wchar_t *Class = t_ParsedObjectPath->m_pClass ;

	/*
	 * Create Asynchronous Class object
	 */

				SnmpClassGetAsyncEventObject aSyncEvent ( this , Class, pHandler , pCtx ) ;

				aSyncEvent.Process () ;

				aSyncEvent.Wait ( TRUE ) ;

				status = TRUE ;

				errorObject.SetStatus ( WBEM_SNMP_NO_ERROR ) ;
				errorObject.SetWbemStatus ( WBEM_NO_ERROR ) ;
				errorObject.SetMessage ( L"" ) ;

				delete t_ParsedObjectPath ;
			}
				else
			{
	// Parse Failure

				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATH ) ;
				errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				errorObject.SetMessage ( L"Failed to parse object path" ) ;
			}

	// Check validity of server/namespace path and validity of request

			result = errorObject.GetWbemStatus () ;
			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro0( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning from CImpClasProv::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
			ObjectPath ,
			result 
		) ;
)

 
		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpClasProv :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

 HRESULT CImpClasProv :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

SCODE CImpClasProv :: CreateClassEnumAsync (

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro0( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpClasProv::CreateClassEnumAsync ( (%s) )" ,
			Superclass
		) ;
	)

		if (SUCCEEDED(result))
		{
		/*
		 * Create Synchronous Enum Instance object
		 */

			SnmpClassEnumAsyncEventObject aSyncEvent ( this , Superclass, lFlags , pHandler , pCtx ) ;

			aSyncEvent.Process () ;

		/*`
		 *	Wait for worker object to complete processing
		 */

			aSyncEvent.Wait ( TRUE ) ;


			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro0( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning From CImpClasProv::CreateClassEnumAsync ( (%s) ) with Result = (%lx)" ,
			Superclass ,
			result
		) ;
)

		return result ;
	
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpClasProv :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpClasProv :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CreateInstanceEnum ( 

	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CreateInstanceEnumAsync (

 	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: ExecQuery ( 

	const BSTR QueryLanguage, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: ExecQueryAsync ( 
		
	const BSTR QueryFormat, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: ExecNotificationQuery ( 

	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpClasProv :: ExecNotificationQueryAsync ( 
            
	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpClasProv :: ExecMethod( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpClasProv :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient(); //cimom is the client - LocalSystem

		if (SUCCEEDED(result))
		{
			BOOL bEnteredCritSec = FALSE;
			BOOL status = TRUE ;

			try
			{
				EnterCriticalSection ( & s_ProviderCriticalSection ) ;
				bEnteredCritSec = TRUE;

				namespacePath.SetNamespacePath ( pszNamespace ) ;

				if ( ! CImpClasProv :: s_Initialised )
				{
					ProviderStartup () ;

					SnmpThreadObject :: Startup () ;
					try
					{
						SnmpDebugLog :: Startup () ;
					}
					catch ( ... )
					{
						// we do not want to left s_Reference count up
						SnmpThreadObject :: Closedown () ;
						ProviderClosedown () ;

						throw;
					}

					try
					{
						status = SnmpClassLibrary :: Startup () ;
					}
					catch ( ... )
					{
						// we do not want to left s_Reference count up
						SnmpDebugLog :: Closedown () ;
						SnmpThreadObject :: Closedown () ;
						ProviderClosedown () ;

						throw;
					}

					if ( status == FALSE )
					{
						SnmpDebugLog :: Closedown () ;
						SnmpThreadObject :: Closedown () ;

						ProviderClosedown () ;
					}
					else
					{
						CImpClasProv :: s_Initialised = TRUE ;
					}
				}

				LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
				bEnteredCritSec = FALSE;
			}
			catch ( ... )
			{
				if ( bEnteredCritSec ) 
				{
					LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
					bEnteredCritSec = FALSE;
				}

				throw;
			}

			WbemSnmpErrorObject errorObject ;
			result = SetServer(pCIMOM) ;

			if ( FAILED ( result ) && result != E_NOINTERFACE ) //implies there is no prxy security - inproc.
			{
				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
				errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
				errorObject.SetMessage ( L"Failed to secure proxy to this namespace" ) ;
			}

			wchar_t *t_ObjectPath = namespacePath.GetNamespacePath () ;

			BSTR t_Path = SysAllocString ( t_ObjectPath ) ;

			status = AttachParentServer ( 

				errorObject , 
				t_Path ,
				pCtx 
			) ;

			SysFreeString ( t_Path ) ;

			delete [] t_ObjectPath ;

			if ( status )
			{
				ObtainCachedIpAddress ( errorObject ) ;
			}
			else
			{
				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
				errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
				errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemServices" ) ;
			}

			status = FetchSnmpNotificationObject ( errorObject , pCtx ) ;
			status = FetchNotificationObject ( errorObject , pCtx ) ;

			//doing this here hangs cimom so delay until classes are asked for
#ifdef CORRELATOR_INIT
			//prime the correlator....
			if (status)
			{
				ISmirInterrogator *t_Interrogator = NULL;
				HRESULT result = CoCreateInstance (
 
					CLSID_SMIR_Database ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_ISMIR_Interrogative ,
					( void ** ) &t_Interrogator 
				);

				if ( SUCCEEDED ( result ) )
				{
					ISMIRWbemConfiguration *smirConfiguration = NULL ;
					result = t_Interrogator->QueryInterface ( IID_ISMIRWbemConfiguration , ( void ** ) & smirConfiguration ) ;
					if ( SUCCEEDED ( result ) )
					{
						smirConfiguration->SetContext ( pCtx ) ;
						CCorrelator::StartUp(t_Interrogator);
						smirConfiguration->Release () ;
					}
					else
					{
						errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
						errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
						errorObject.SetMessage ( L"QueryInterface on ISmirInterrogator Failed" ) ;
					}

					t_Interrogator->Release();
				}
				else
				{
					errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
					errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
					errorObject.SetMessage ( L"CoCreateInstance on ISmirInterrogator Failed" ) ;
				}

			}
#endif //CORRELATOR_INIT

			result = errorObject.GetWbemStatus () ;

			pInitSink->SetStatus ( (result == WBEM_NO_ERROR) ? (LONG)WBEM_S_INITIALIZED : (LONG)WBEM_E_FAILED , 0 ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning From CImpClasProv::Initialize with Result = (%lx)" ,
			result
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\classfac.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemidl.h>
#include <snmpcont.h>
#include <instpath.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include <classfac.h>
#include "clasprov.h"
#include "propprov.h"
#include "guids.h"

#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>


LONG CClasProvClassFactory :: objectsInProgress = 0 ;
LONG CClasProvClassFactory :: locksInProgress = 0 ;

LONG CPropProvClassFactory :: objectsInProgress = 0 ;
LONG CPropProvClassFactory :: locksInProgress = 0 ;

LONG CSNMPEventProviderClassFactory :: objectsInProgress = 0 ;
LONG CSNMPEventProviderClassFactory :: locksInProgress = 0 ;

extern CEventProviderThread* g_pProvThrd;
extern CEventProviderWorkerThread* g_pWorkerThread;
extern CRITICAL_SECTION s_ProviderCriticalSection ;

extern void ProviderStartup () ;
extern void ProviderClosedown () ;

//***************************************************************************
//
// CClasProvClassFactory::CClasProvClassFactory
// CClasProvClassFactory::~CClasProvClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CClasProvClassFactory :: CClasProvClassFactory ()
{
	InterlockedIncrement ( & objectsInProgress ) ;
	m_referenceCount = 0 ;
}

CClasProvClassFactory::~CClasProvClassFactory ()
{
	InterlockedDecrement ( & objectsInProgress ) ;
}

//***************************************************************************
//
// CClasProvClassFactory::QueryInterface
// CClasProvClassFactory::AddRef
// CClasProvClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CClasProvClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IClassFactory )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


STDMETHODIMP_( ULONG ) CClasProvClassFactory :: AddRef ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement ( & m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CClasProvClassFactory :: Release ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

//***************************************************************************
//
// CClasProvClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CClasProvClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT status = S_OK ;

		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION ;
		}
		else
		{
			IWbemServices *lpunk = ( IWbemServices * ) new CImpClasProv ;
			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
				else
				{
				}
			}			
		}

		return status ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
}

//***************************************************************************
//
// CClasProvClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CClasProvClassFactory :: LockServer ( BOOL fLock )
{
	SetStructuredExceptionHandler seh;

	try
	{
	/* 
	 * Place code in critical section
	 */

		if ( fLock )
		{
			InterlockedIncrement ( & locksInProgress ) ;
		}
		else
		{
			InterlockedDecrement ( & locksInProgress ) ;
		}

		return S_OK	;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// CPropProvClassFactory::CPropProvClassFactory
// CPropProvClassFactory::~CPropProvClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CPropProvClassFactory :: CPropProvClassFactory ()
{
	InterlockedIncrement ( & objectsInProgress ) ;
	m_referenceCount = 0 ;
}

CPropProvClassFactory::~CPropProvClassFactory ()
{
	InterlockedDecrement ( & objectsInProgress ) ;
}

//***************************************************************************
//
// CPropProvClassFactory::QueryInterface
// CPropProvClassFactory::AddRef
// CPropProvClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CPropProvClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IClassFactory )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


STDMETHODIMP_( ULONG ) CPropProvClassFactory :: AddRef ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement ( & m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CPropProvClassFactory :: Release ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

//***************************************************************************
//
// CPropProvClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CPropProvClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT status = S_OK ;

		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION ;
		}
		else
		{
			IWbemServices *lpunk = ( IWbemServices * ) new CImpPropProv ;
			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
				else
				{
				}
			}			
		}

		return status ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// CPropProvClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CPropProvClassFactory :: LockServer ( BOOL fLock )
{
	SetStructuredExceptionHandler seh;

	try
	{
/* 
 * Place code in critical section
 */

		if ( fLock )
		{
			InterlockedIncrement ( & locksInProgress ) ;
		}
		else
		{
			InterlockedDecrement ( & locksInProgress ) ;
		}

		return S_OK	;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// CSNMPEventProviderClassFactory::CSNMPEventProviderClassFactory
// CSNMPEventProviderClassFactory::~CSNMPEventProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CSNMPEventProviderClassFactory :: CSNMPEventProviderClassFactory ()
{
	m_referenceCount = 0 ;
}

CSNMPEventProviderClassFactory::~CSNMPEventProviderClassFactory ()
{
}

//***************************************************************************
//
// CSNMPEventProviderClassFactory::QueryInterface
// CSNMPEventProviderClassFactory::AddRef
// CSNMPEventProviderClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CSNMPEventProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IClassFactory )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


STDMETHODIMP_( ULONG ) CSNMPEventProviderClassFactory :: AddRef ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		InterlockedIncrement(&objectsInProgress);
		return InterlockedIncrement ( &m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CSNMPEventProviderClassFactory :: Release ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;

		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			InterlockedDecrement(&objectsInProgress);
			return 0 ;
		}
		else
		{
			InterlockedDecrement(&objectsInProgress);
			return ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

//***************************************************************************
//
// CSNMPEventProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CSNMPEventProviderClassFactory :: LockServer ( BOOL fLock )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( fLock )
		{
			InterlockedIncrement ( & locksInProgress ) ;
		}
		else
		{
			InterlockedDecrement ( & locksInProgress ) ;
		}

		return S_OK	;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// CSNMPEncapEventProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CSNMPEncapEventProviderClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
																REFIID riid,
																LPVOID FAR * ppvObject
)
{
	SetStructuredExceptionHandler seh;

	BOOL bEnteredCritSec = FALSE;
	BOOL bContinue = FALSE;

	try
	{
		HRESULT status = E_FAIL;

		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION;
		}
		else 
		{
			EnterCriticalSection ( & s_ProviderCriticalSection ) ;
			bEnteredCritSec = TRUE;

			if (NULL == g_pProvThrd)
			{
				ProviderStartup () ;

				SnmpThreadObject :: Startup () ;
				try
				{
					SnmpDebugLog :: Startup () ;
				}
				catch ( ... )
				{
					// we do not want to left s_Reference count up
					SnmpThreadObject :: Closedown () ;
					ProviderClosedown () ;

					throw;
				}

				BOOL bStatus = FALSE;
				try
				{
					bStatus = SnmpClassLibrary :: Startup () ;
				}
				catch ( ... )
				{
					// we do not want to left s_Reference count up
					SnmpDebugLog :: Closedown () ;
					SnmpThreadObject :: Closedown () ;
					ProviderClosedown () ;

					throw;
				}

				if ( bStatus == FALSE )
				{
					SnmpDebugLog :: Closedown () ;
					SnmpThreadObject :: Closedown () ;

					ProviderClosedown () ;
				}
				else
				{
					try
					{
						g_pWorkerThread = new CEventProviderWorkerThread;
						g_pWorkerThread->BeginThread();
						g_pWorkerThread->WaitForStartup();
						g_pWorkerThread->CreateServerWrap () ;
						g_pProvThrd = new CEventProviderThread;

						bContinue = TRUE;
					}
					catch ( ... )
					{
						if ( g_pWorkerThread )
						{
							g_pWorkerThread->SignalThreadShutdown();
							g_pWorkerThread = NULL;
						}

						g_pProvThrd = NULL;

						SnmpClassLibrary :: Closedown () ;
						SnmpDebugLog :: Closedown () ;
						SnmpThreadObject :: Closedown () ;
						ProviderClosedown () ;

						throw;
					}
				}
			}
			else
			{
				bContinue = TRUE;
			}

			if ( bContinue )
			{
				CTrapEventProvider* prov =  new CTrapEventProvider(CMapToEvent::EMappingType::ENCAPSULATED_MAPPER, g_pProvThrd);

				LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
				bEnteredCritSec = FALSE;

				status = prov->QueryInterface (riid, ppvObject);

				if (NOERROR != status)
				{
					delete prov;
				}
			}

			if ( bEnteredCritSec )
			{
				LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
				bEnteredCritSec = FALSE;
			}
		}

		return status ;
	}
	catch(Structured_Exception e_SE)
	{
		if ( bEnteredCritSec )
		{
			LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
			bEnteredCritSec = FALSE;
		}

		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		if ( bEnteredCritSec )
		{
			LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
			bEnteredCritSec = FALSE;
		}

		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		if ( bEnteredCritSec )
		{
			LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
			bEnteredCritSec = FALSE;
		}

		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// CSNMPRefEventProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CSNMPRefEventProviderClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
																REFIID riid,
																LPVOID FAR * ppvObject
)
{
	SetStructuredExceptionHandler seh;

	BOOL bEnteredCritSec = FALSE;
	BOOL bContinue = FALSE;

	try
	{
		HRESULT status = E_FAIL;

		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION;
		}
		else 
		{
			EnterCriticalSection ( & s_ProviderCriticalSection ) ;
			bEnteredCritSec = TRUE;

			if (NULL == g_pProvThrd)
			{
				ProviderStartup () ;

				SnmpThreadObject :: Startup () ;
				try
				{
					SnmpDebugLog :: Startup () ;
				}
				catch ( ... )
				{
					// we do not want to left s_Reference count up
					SnmpThreadObject :: Closedown () ;
					ProviderClosedown () ;

					throw;
				}

				BOOL bStatus = FALSE;
				try
				{
					bStatus = SnmpClassLibrary :: Startup () ;
				}
				catch ( ... )
				{
					// we do not want to left s_Reference count up
					SnmpDebugLog :: Closedown () ;
					SnmpThreadObject :: Closedown () ;
					ProviderClosedown () ;

					throw;
				}

				if ( bStatus == FALSE )
				{
					SnmpDebugLog :: Closedown () ;
					SnmpThreadObject :: Closedown () ;

					ProviderClosedown () ;
				}
				else
				{
					try
					{
						g_pWorkerThread = new CEventProviderWorkerThread;
						g_pWorkerThread->BeginThread();
						g_pWorkerThread->WaitForStartup();
						g_pWorkerThread->CreateServerWrap () ;
						g_pProvThrd = new CEventProviderThread;

						bContinue = TRUE;
					}
					catch ( ... )
					{
						if ( g_pWorkerThread )
						{
							g_pWorkerThread->SignalThreadShutdown();
							g_pWorkerThread = NULL;
						}

						SnmpClassLibrary :: Closedown () ;
						SnmpDebugLog :: Closedown () ;
						SnmpThreadObject :: Closedown () ;

						ProviderClosedown () ;

						throw;
					}
				}
			}
			else
			{
				bContinue = TRUE;
			}

			if ( bContinue )
			{
				CTrapEventProvider* prov =  new CTrapEventProvider(CMapToEvent::EMappingType::REFERENT_MAPPER, g_pProvThrd);

				LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
				bEnteredCritSec = FALSE;

				status = prov->QueryInterface (riid, ppvObject);

				if (NOERROR != status)
				{
					delete prov;
				}
			}

			if ( bEnteredCritSec )
			{
				LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
				bEnteredCritSec = FALSE;
			}
		}

		return status ;
	}
	catch(Structured_Exception e_SE)
	{
		if ( bEnteredCritSec )
		{
			LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
			bEnteredCritSec = FALSE;
		}

		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		if ( bEnteredCritSec )
		{
			LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
			bEnteredCritSec = FALSE;
		}

		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		if ( bEnteredCritSec )
		{
			LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
			bEnteredCritSec = FALSE;
		}

		return E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\correlat.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <notify.h>
#include <cordefs.h>
#include <cormap.h>
#include <snmplog.h>

extern CCorrCacheWrapper*	g_CacheWrapper;
extern CCorrelatorMap*		g_Map;
extern ISmirDatabase*		g_pNotifyInt;
extern CCorrCacheNotify*	gp_notify;

static CCriticalSection gs_InitLock;

void CCorrelator::StartUp(IN ISmirInterrogator *a_ISmirInterrogator)
{
	if (gs_InitLock.Lock())
	{
		if (NULL == g_CacheWrapper)
		{
			g_CacheWrapper = new CCorrCacheWrapper();
		}

		if (NULL == g_Map)
		{
			g_Map = new CCorrelatorMap();
		}

		gs_InitLock.Unlock();
	}

	CCorrCache* cache = g_CacheWrapper->GetCache();

	if (NULL == cache)
	{
		cache = new CCorrCache(a_ISmirInterrogator);
		g_CacheWrapper->SetCache(cache);
	}

	g_CacheWrapper->ReleaseCache();

}

#ifdef CORRELATOR_INIT
CCorrelator::CCorrelator(IN SnmpSession &session) :
	CCorrNextId(session),
	m_Groups(NULL),
	m_group_OID(NULL),
	m_pCache(NULL)
{
#else //CORRELATOR_INIT
CCorrelator::CCorrelator(IN SnmpSession &session, IN ISmirInterrogator *a_ISmirInterrogator) :
	CCorrNextId(session),
	m_Groups(NULL),
	m_group_OID(NULL),
	m_pCache(NULL)
{
	StartUp(a_ISmirInterrogator);
#endif //CORRELATOR_INIT

	m_VarBindCnt = 0;
	m_inProg = FALSE;
	m_pItem = NULL;
	m_NoEntries = TRUE;
}


void CCorrelator::ReadRegistry()
{
	HKEY hkey;
	LONG res = RegOpenKey(HKEY_LOCAL_MACHINE, CORRELATOR_KEY, &hkey);
	UINT sessionVarBindCnt = session.GetVarbindsPerPdu();
	UINT maxVarBindCnt = ((VARBIND_COUNT < sessionVarBindCnt)
									? VARBIND_COUNT : sessionVarBindCnt);

	if (ERROR_SUCCESS != res)
	{
		m_VarBindCnt = maxVarBindCnt;
		return;
	}

	DWORD type;
	DWORD data;
	DWORD ldata=sizeof(DWORD);
	res = RegQueryValueEx(hkey, CORRELATOR_VALUE, NULL, &type,
							(unsigned char*) &data, &ldata);
	
	if ((ERROR_SUCCESS != res) || (REG_DWORD != type) ||
		(0 == data) || (maxVarBindCnt < data))
	{
		m_VarBindCnt = maxVarBindCnt;
	}
	else
	{
		m_VarBindCnt = data;
	}

	RegCloseKey(hkey);

}


void CCorrelator::Initialise()
{
	ReadRegistry();
	g_Map->Register(this);
	m_pCache = g_CacheWrapper->GetCache();
	g_CacheWrapper->ReleaseCache();

	if (NULL == m_pCache)
	{
		m_NoEntries = TRUE;
	}
	else
	{
		m_pCache->AddRef();
		m_rangePos = m_pCache->GetHeadRangeTable();
		
		if (m_rangePos)
		{
			m_NoEntries = FALSE;
			m_Groups = new CCorrGroupMask(m_pCache->GetSize());

		}
		else
		{
			m_NoEntries = TRUE;
		}
	}
}

CCorrelator::~CCorrelator()
{
	delete m_Groups;
	delete m_group_OID;

	if (m_pCache)
	{
		m_pCache->DecRef();
	}
}


void CCorrelator::DestroyCorrelator()
{
	Reset();
	DestroyOperation();
}

void CCorrelator::Reset()
{
	g_Map->UnRegister(this);

	if (m_pCache)
	{
		m_pCache->DecRef();
		m_pCache = NULL;
	}

	delete m_Groups;
	m_Groups = NULL;
	m_inProg = FALSE;
	delete m_group_OID;
	m_group_OID = NULL;
}

void CCorrelator::ReceiveNextId(IN const SnmpErrorReport &error,
								IN const CCorrObjectID &next_id)
{
	if (Snmp_Success == error.GetError())
	{
		BOOL nextNeeded = TRUE;

		switch(m_pItem->IsInRange(next_id))
		{
			case CCorrRangeTableItem::ECorrBeforeStart:
			{
				char* id = next_id.GetString();
				CCorrelator_Info i(CCorrelator_Info::ECorrGetNextError, error);
				Correlated(i, (ISmirGroupHandle*)NULL, id);
				delete [] id;
				Reset();
				Finished(TRUE);
				return;
			}
			break;

			case CCorrRangeTableItem::ECorrInRange:
			{
				CCorrelator_Info i(CCorrelator_Info::ECorrSuccess, error);

				//loop the group handle list and call correlated fro each...
				POSITION pos = m_pItem->GetGroupIdPtr()->m_groupHandles.GetHeadPosition();
				while (pos)
				{
					ISmirGroupHandle* gH = m_pItem->GetGroupIdPtr()->m_groupHandles.GetNext(pos);
					gH->AddRef();
					Correlated(i, gH);
				}
				
				m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());

				if (m_group_OID)
				{
					Reset();
					Finished(TRUE);
					return;
				}
			}
			break;

			case CCorrRangeTableItem::ECorrAfterEnd:
			{
				nextNeeded = ProcessOID(error, next_id);
			}
			break;

			case CCorrRangeTableItem::ECorrEqualToEnd:
			{
				char* id = next_id.GetString();
				CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup, error);
				Correlated(i, (ISmirGroupHandle*)NULL, id);
				delete [] id;
			}
			break;

			default:
			{
DebugMacro6( 
				SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
					L"CCorrelator::ReceiveNextId - Undefined case reached\n");
)
			}
			break;

		}
		
		if (!m_rangePos && nextNeeded)
		{
			Reset();
			Finished(TRUE);
			return;
		}

		if (nextNeeded)
		{
			m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
		}

		if (m_group_OID)
		{
			while (!IsItemFromGroup())
			{
				m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());
				
				if (m_rangePos)
				{
					//check result set and make sure we discard
					//any results for this range item
					ScanAndSkipResults();
					m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
				}
				else
				{
					Reset();
					Finished(TRUE);
					return;
				}
			}
		}

		while (m_Groups->IsBitSet(m_pItem->GetGroupIdPtr()->GetIndex()))
		{
			if (m_rangePos && !m_group_OID)
			{
				//check result set and make sure we discard
				//any results for this range item
				ScanAndSkipResults();
				m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
			}
			else
			{
				Reset();
				Finished(TRUE);
				return;
			}
		}

		// GetNextResult will have called ReceiveNextID if the result is
		// TRUE so at this point we have to make sure recursion is safe.
		// when all the results from the previous GetNext have been processed
		// GetNextResult will return FALSE and the program will do the
		// next GetNext operation and stop recursing.

		if (!GetNextResult())
		{
			GetNextOIDs();
		}

		return;
	}
	else
	{
		switch(error.GetStatus())
		{
			case Snmp_No_Such_Name:
			{
				Reset();
				Finished(TRUE);
				return;
			}
			break;

			case Snmp_Gen_Error:
			case Snmp_Local_Error:
			case Snmp_General_Abort:
			case Snmp_No_Response:
			break;

			default:
			{
DebugMacro6( 
				SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
					L"CCorrelator::ReceiveNextId - Unexpected SNMP Error returned\n");
)
			}
			break;
		}

		CCorrelator_Info i(CCorrelator_Info::ECorrSnmpError, error);
		Correlated(i, (ISmirGroupHandle*)NULL);
		Reset();
		Finished(FALSE);
	}
}

void CCorrelator::ScanAndSkipResults()
{
	if (m_NextResult >= m_ResultsCnt)
	{
		return;
	}

	UINT lastResult = m_NextResult - 1;
	BOOL bInvalidOIDReported = FALSE;
	
	while (m_NextResult < m_ResultsCnt)
	{
		if (m_Results[lastResult].m_Out != m_Results[m_NextResult].m_Out)
		{
			if (Snmp_Success == m_Results[m_NextResult].m_report.GetError())
			{
				switch(m_pItem->IsInRange(m_Results[m_NextResult].m_Out))
				{
					case CCorrRangeTableItem::ECorrBeforeStart:
					case CCorrRangeTableItem::ECorrInRange:
					{
						lastResult = m_NextResult;
						m_NextResult++;
					}
					break;

					case CCorrRangeTableItem::ECorrAfterEnd:
					{
						return;
					}
					break;

					case CCorrRangeTableItem::ECorrEqualToEnd:
					{
						if (!bInvalidOIDReported)
						{
							char* id = m_Results[m_NextResult].m_Out.GetString();
							CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup,
												m_Results[m_NextResult].m_report);
							Correlated(i, (ISmirGroupHandle*)NULL, id);
							delete [] id;
							bInvalidOIDReported = TRUE;
						}

						lastResult = m_NextResult;
						m_NextResult++;
					}
					break;

					default:
					{
DebugMacro6( 
						SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
							L"CCorrelator::ScanAndSkipResults - Undefined case reached\n");
)
					}
					break;

				}
			}
			else
			{
				break;
			}
		}
		else
		{
			m_NextResult++;
		}
	}
}

BOOL CCorrelator::ProcessOID(IN const SnmpErrorReport& error, IN const CCorrObjectID& OID)
{
	BOOL ret = TRUE;
	BOOL invalidOID = TRUE;

	while (m_rangePos)
	{
		invalidOID = FALSE;
		m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);

		switch(m_pItem->IsInRange(OID))
		{
			case CCorrRangeTableItem::ECorrInRange:
			{
				if (!m_group_OID || IsItemFromGroup())
				{
					CCorrelator_Info i(CCorrelator_Info::ECorrSuccess, error);

					//loop the group handle list and call correlated fro each...
					POSITION pos = m_pItem->GetGroupIdPtr()->m_groupHandles.GetHeadPosition();
					while (pos)
					{
						ISmirGroupHandle* gH = m_pItem->GetGroupIdPtr()->m_groupHandles.GetNext(pos);
						gH->AddRef();
						Correlated(i, gH);
					}
				}

				m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());
				return ret;
			}
			break;
			
			case CCorrRangeTableItem::ECorrAfterEnd:
			{
				invalidOID = TRUE;
			}
			continue;

			case CCorrRangeTableItem::ECorrBeforeStart:
			case CCorrRangeTableItem::ECorrEqualToStart:
			{
				ret = FALSE;
			}
			case CCorrRangeTableItem::ECorrEqualToEnd:
			{
				CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup, error);
				char* id = OID.GetString();
				Correlated(i, (ISmirGroupHandle*)NULL, id);
				delete [] id;
				return ret;
			}
			break;
		}
	}

	if (invalidOID)
	{
		CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup, error);
		char* id = OID.GetString();
		Correlated(i, (ISmirGroupHandle*)NULL, id);
		delete [] id;
	}

	return ret;
}


BOOL CCorrelator::Start(IN const char* groupId) 
{
	if(m_inProg)
	{
		return FALSE;
	}
	
	if (groupId)
	{
		m_group_OID = new CCorrObjectID(groupId);
	}

	Initialise();
	m_inProg = TRUE;

	if (m_NoEntries || !(*this)())
	{
		SnmpErrorReport snmpi(Snmp_Success, Snmp_No_Error);
		CCorrelator_Info i(CCorrelator_Info::ECorrBadSession, snmpi);

		if (m_NoEntries)
		{
			i.SetInfo(CCorrelator_Info::ECorrEmptySMIR);
		}
		
		Correlated(i, (ISmirGroupHandle*)NULL);
		Reset();
		Finished(FALSE);
		return FALSE;
	}

	m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);

	if (m_group_OID)
	{
		while (!IsItemFromGroup())
		{
			m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());
			
			if (m_rangePos)
			{
				m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
			}
			else
			{
				SnmpErrorReport snmpi(Snmp_Success, Snmp_No_Error);
				CCorrelator_Info i(CCorrelator_Info::ECorrNoSuchGroup, snmpi);
				Correlated(i, (ISmirGroupHandle*)NULL);
				Reset();
				Finished(FALSE);
				return FALSE;

			}
		}
	}

	GetNextOIDs();

	return TRUE;
}


void CCorrelator::GetNextOIDs()
{
	CCorrObjectID next_ids[VARBIND_COUNT];
	UINT count;
	POSITION tmpRangePos = m_rangePos;
	CCorrRangeTableItem* tmpItem = m_pItem;
	count = 0;
	tmpItem->GetStartRange(next_ids[count]);
	count++;

	if (NULL == m_group_OID)
	{
		while (tmpRangePos && (count < m_VarBindCnt))
		{
			tmpItem = m_pCache->GetNextRangeTable(&tmpRangePos);
			tmpItem->GetStartRange(next_ids[count]);
			count++;
		}
	}

	GetNextId(next_ids, count);
}


BOOL CCorrelator::IsItemFromGroup() const
{
	if (!m_group_OID || !m_pItem)
	{
		return FALSE;
	}

	CCorrObjectID tmp;
	m_pItem->GetGroupIdPtr()->GetGroupID(tmp);
	return(*m_group_OID == tmp);
}


void CCorrelator::TerminateCorrelator(ISmirDatabase** a_ppNotifyInt, CCorrCacheNotify** a_ppnotify)
{
	if (gs_InitLock.Lock())
	{
		delete g_Map;
		g_Map = NULL;

		if (g_pNotifyInt)
		{
			*a_ppNotifyInt = g_pNotifyInt;
			g_pNotifyInt = NULL;
		}

		if (gp_notify)
		{
			gp_notify->Detach();
			*a_ppnotify = gp_notify;
			gp_notify = NULL;
		}

		if (g_CacheWrapper)
		{
			CCorrCache* cache = g_CacheWrapper->GetCache();
			
			if (cache)
			{
				delete cache;
			}

			g_CacheWrapper->ReleaseCache();
			delete g_CacheWrapper;
			g_CacheWrapper = NULL;
		}
#if 0
		//matches the CoInitialize in startup
		CoUnintialize();
#endif
		gs_InitLock.Unlock();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\creclass.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>

#include <wbemidl.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include <correlat.h>
#include "classfac.h"
#include "clasprov.h"
#include "creclass.h"
#include "guids.h"

#ifdef CORRELATOR_INIT
SnmpCorrelation :: SnmpCorrelation ( 

	SnmpSession &session ,
	SnmpClassEventObject *eventObject

) : CCorrelator ( session ) ,
	m_session (  &session ) ,
	m_eventObject ( eventObject )
#else //CORRELATOR_INIT
SnmpCorrelation :: SnmpCorrelation ( 

	SnmpSession &session ,
	SnmpClassEventObject *eventObject,
	ISmirInterrogator *a_ISmirInterrogator

) : CCorrelator ( session, a_ISmirInterrogator ) ,
	m_session (  &session ) ,
	m_eventObject ( eventObject )

#endif //CORRELATOR_INIT
{
}

SnmpCorrelation :: ~SnmpCorrelation ()
{
	m_session->DestroySession () ;
}

void SnmpCorrelation :: Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phGroup , IN const char* objectId )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" SnmpCorrelation :: Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phGroup , IN const char* objectId )" 
	) ;
)

	switch ( info.GetInfo () )
	{
		case CCorrelator_Info :: ECorrSuccess:
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" Successful correlation" 
	) ;
)


			if ( phGroup )
			{
				phGroup->AddRef () ;
				m_eventObject->ReceiveGroup ( phGroup ) ;
			}
			else
			{
			}
		}
		break ;

		case CCorrelator_Info :: ECorrSnmpError:
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" Unsuccessful correlation" 
	) ;
)

			m_eventObject->ReceiveError ( info ) ;
		} 
		break ;

		default:
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" Unknown Correlation Status" 
	) ;
)

		}		
		break ;
	}

	if ( phGroup )
		phGroup->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" Returning from SnmpCorrelation :: Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phGroup , IN const char* objectId )" 
	) ;
)

}

void SnmpCorrelation :: Finished ( IN const BOOL Complete )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" SnmpCorrelation :: Finished ( IN const BOOL Complete )"
	) ;
)

	m_eventObject->ReceiveComplete () ;
	DestroyCorrelator () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" Returning from SnmpCorrelation :: Finished ( IN const BOOL Complete )"
	) ;
)

}

SnmpClassEventObject :: SnmpClassEventObject ( 

	CImpClasProv *provider ,
	IWbemContext *a_Context

) : m_provider ( provider ) , 
	m_correlate ( TRUE ) ,
	m_synchronousComplete ( FALSE ) ,
	m_correlator ( NULL ) ,
	m_namespaceObject ( NULL ) ,
	m_inCallstack ( FALSE ) ,
	m_Context ( a_Context ) ,
	m_GroupsReceived ( 0 ),
	m_Interrogator ( NULL )
{
	if ( m_provider )
		m_provider->AddRef () ;

	if ( m_Context )
	{
		m_Context->AddRef () ;

/*
 * Look for correlation flag in Context
 */

	
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		HRESULT result = m_Context->GetValue ( WBEM_CLASS_CORRELATE_CONTEXT_PROP , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BOOL ) 
				m_correlate = t_Variant.boolVal ;

			VariantClear ( & t_Variant ) ;
		}
	}

	HRESULT result = CoCreateInstance (
 
		CLSID_SMIR_Database ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_ISMIR_Interrogative ,
		( void ** ) &m_Interrogator 
	);

	if ( SUCCEEDED ( result ) )
	{
		ISMIRWbemConfiguration *smirConfiguration = NULL ;
		result = m_Interrogator->QueryInterface ( IID_ISMIRWbemConfiguration , ( void ** ) & smirConfiguration ) ;
		if ( SUCCEEDED ( result ) )
		{
			result = smirConfiguration->Authenticate (

					NULL,
					NULL,
					NULL,
					NULL,
					0 ,
					NULL,
					FALSE
			) ;

			if ( SUCCEEDED ( result ) )
			{			
				smirConfiguration->SetContext ( m_Context ) ;
				smirConfiguration->Release () ;
			}
		}
		else
		{
			m_Interrogator->Release () ;
			m_synchronousComplete = TRUE ;
			m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
			m_errorObject.SetMessage ( L"QueryInterface on ISmirInterrogator Failed" ) ;
		}
	}
	else
	{
		m_synchronousComplete = TRUE ;
		m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
		m_errorObject.SetMessage ( L"CoCreateInstance on ISmirInterrogator Failed" ) ;
	}
}

SnmpClassEventObject :: ~SnmpClassEventObject  ()
{
	if ( m_provider ) 
		m_provider->Release () ;

	if ( m_namespaceObject )
		m_namespaceObject->Release () ;

	if ( m_Context )
		m_Context->Release () ;

	if ( m_Interrogator )
		m_Interrogator->Release () ;
}

BOOL SnmpClassEventObject :: GetClass ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject **classObject , BSTR a_Class )
{
	HRESULT result = m_Interrogator->GetWBEMClass ( classObject , a_Class ) ;
	if ( SUCCEEDED ( result ) ) 
	{
	}
	else
	{
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
		a_errorObject.SetMessage ( L"Failed to get class definition from SMIR" ) ;
	}

	return result ;
}

BOOL SnmpClassEventObject :: GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;
	IWbemClassObject *errorObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = m_provider->GetSnmpNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			VariantClear ( &variant ) ;

			if ( SUCCEEDED ( result ) )
			{
				variant.vt = VT_I4 ;
				variant.lVal = m_errorObject.GetStatus () ;

				result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSCODE , 0 , & variant , 0 ) ;
				VariantClear ( &variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					if ( m_errorObject.GetMessage () ) 
					{
						variant.vt = VT_BSTR ;
						variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

						result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
						VariantClear ( &variant ) ;

						if ( ! SUCCEEDED ( result ) )
						{
							(*notifyObject)->Release () ;
							status = GetNotifyStatusObject ( notifyObject ) ;
						}
					}
				}
				else
				{
					(*notifyObject)->Release () ;
					status = GetNotifyStatusObject ( notifyObject ) ;
				}
			}
			else
			{
				(*notifyObject)->Release () ;
				status = GetNotifyStatusObject ( notifyObject ) ;
			}

			notificationClassObject->Release () ;
		}
		else
		{
			status = GetNotifyStatusObject ( notifyObject ) ;
		}
	}
	else
	{
		status = GetNotifyStatusObject ( notifyObject ) ;
	}

	return status ;
}

BOOL SnmpClassEventObject :: GetNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;
	IWbemClassObject *errorObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = m_provider->GetNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			if ( SUCCEEDED ( result ) )
			{
				if ( m_errorObject.GetMessage () ) 
				{
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

					result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
					VariantClear ( &variant ) ;

					if ( ! SUCCEEDED ( result ) )
					{
						status = FALSE ;
						(*notifyObject)->Release () ;
						(*notifyObject)=NULL ;
					}
				}
			}
			else
			{
				status = FALSE ;
				(*notifyObject)->Release () ;
				(*notifyObject)=NULL ;
			}

			VariantClear ( &variant ) ;

			notificationClassObject->Release () ;
		}
		else
		{
			status = FALSE ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentTransport ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentTransport 
)
{
	BOOL status = TRUE ;
	agentTransport = NULL ;
	BSTR t_Transport = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTTRANSPORT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
	}

	if ( status & ! t_Transport )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTTRANSPORT , 
			0,	
			&t_Variant ,
			& attributeType

		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
		else
		{
			t_Transport = WBEM_AGENTIPTRANSPORT ;
		}
	}

	if ( status )
	{
		if ( ( _wcsicmp ( t_Transport , WBEM_AGENTIPTRANSPORT ) == 0 ) || ( _wcsicmp ( t_Transport , WBEM_AGENTIPXTRANSPORT ) == 0 ) )
		{
			agentTransport = UnicodeStringDuplicate ( t_Transport ) ;
		}
		else
		{
/*
*	Transport type != IP || != IPX
*/
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
		}

	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentVersion ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentVersion 
)
{
	BOOL status = TRUE ;
	agentVersion = NULL ;
	BSTR t_Version = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTSNMPVERSION , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Version = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}
	}

	if ( status & ! t_Version )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTSNMPVERSION , 
			0,	
			&t_Variant ,
			& attributeType
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Version = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}
		else
		{
			t_Version = WBEM_AGENTSNMPVERSION_V1 ;
		}
	}

	if ( status )
	{
		if ( ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V1 ) == 0 ) || ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V2C ) == 0 ) )
		{
			agentVersion = UnicodeStringDuplicate ( t_Version ) ;
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentAddress ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentAddress 
)
{
	BOOL status = TRUE ;
	agentAddress = NULL ;
	BSTR t_Address = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTADDRESS , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
	}

	if ( status & ! t_Address )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTADDRESS , 
			0,	
			&t_Variant ,
			& attributeType
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Namespace must specify valid qualifier for: AgentAddress" ) ;
		}
	}

	if ( status )
	{
		agentAddress = UnicodeStringDuplicate ( t_Address ) ;
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentReadCommunityName ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentReadCommunityName 
)
{
	BOOL status = TRUE ;
	agentReadCommunityName = NULL ;
	BSTR t_Community = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
	}

	if ( status & ! t_Community )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
		else
		{
			t_Community = WBEM_AGENTCOMMUNITYNAME ;
		}
	}

	if ( status )
	{
		agentReadCommunityName = UnicodeStringDuplicate ( t_Community ) ;
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentRetryCount ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentRetryCount 
)
{
	BOOL status = TRUE ;
	agentRetryCount = 1 ;
	BOOL t_RetryCount = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYCOUNT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryCount = TRUE ;
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	if ( status & ! t_RetryCount )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYCOUNT , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentRetryTimeout( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentRetryTimeout 
)
{
	BOOL status = TRUE ;
	agentRetryTimeout = 0 ;
	BOOL t_RetryTimeout = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYTIMEOUT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryTimeout = TRUE ;
 
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	if ( status & ! t_RetryTimeout )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYTIMEOUT , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentMaxVarBindsPerPdu ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentVarBindsPerPdu 
)
{
	BOOL status = TRUE ;
	agentVarBindsPerPdu = 0 ;
	BOOL t_VarBinds = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTVARBINDSPERPDU , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_VarBinds = TRUE ;
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	if ( status & ! t_VarBinds )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTVARBINDSPERPDU , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{		
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentFlowControlWindowSize ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentFlowControlWindowSize 
)
{
	BOOL status = TRUE ;
	agentFlowControlWindowSize = 0 ;
	BOOL t_WindowSize = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_WindowSize = TRUE ;
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	if ( status & ! t_WindowSize )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject )
{
	BOOL status = TRUE ;

	if ( ! m_namespaceObject )
	{
		IWbemServices *parentServer = m_provider->GetParentServer () ;

		wchar_t *objectPathPrefix = UnicodeStringAppend ( WBEM_NAMESPACE_EQUALS , m_provider->GetThisNamespace () ) ;
		wchar_t *objectPath = UnicodeStringAppend ( objectPathPrefix , WBEM_NAMESPACE_QUOTE ) ;

		delete [] objectPathPrefix ;

		BSTR t_PathStr = SysAllocString ( objectPath ) ;

		HRESULT result = parentServer->GetObject ( 

			t_PathStr ,
			0  ,
			m_Context ,
			&m_namespaceObject ,
			NULL 
		) ;

		SysFreeString ( t_PathStr ) ;

		if ( SUCCEEDED ( result ) )
		{
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
			a_errorObject.SetMessage ( L"Failed to obtain namespace object" ) ;
		}

		delete [] objectPath ;
	}

	return status ;
}

BOOL SnmpClassEventObject :: GetTransportInformation ( 

	WbemSnmpErrorObject &a_errorObject ,
	SnmpSession *&session 
)
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" SnmpClassEventObject :: GetTransportInformation ()"
	) ;
)

	BOOL status = TRUE ;

	IWbemQualifierSet *namespaceQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &namespaceQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		wchar_t *agentVersion = NULL ;
		wchar_t *agentAddress = NULL ;
		wchar_t *agentTransport = NULL ;
		wchar_t *agentReadCommunityName = NULL ;
		ULONG agentRetryCount ;
		ULONG agentRetryTimeout ;
		ULONG agentMaxVarBindsPerPdu ;
		ULONG agentFlowControlWindowSize ;

		status = GetAgentVersion ( m_errorObject , namespaceQualifierObject , agentVersion ) ;
		if ( status ) status = GetAgentAddress ( m_errorObject , namespaceQualifierObject , agentAddress ) ;
		if ( status ) status = GetAgentTransport ( m_errorObject , namespaceQualifierObject , agentTransport ) ;
		if ( status ) status = GetAgentReadCommunityName ( m_errorObject , namespaceQualifierObject , agentReadCommunityName ) ;
		if ( status ) status = GetAgentRetryCount ( m_errorObject , namespaceQualifierObject , agentRetryCount ) ;
		if ( status ) status = GetAgentRetryTimeout ( m_errorObject , namespaceQualifierObject , agentRetryTimeout ) ;
		if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , namespaceQualifierObject , agentMaxVarBindsPerPdu ) ;
		if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , namespaceQualifierObject , agentFlowControlWindowSize ) ;

		if ( status )
		{
			char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
			if ( dbcsAgentAddress )
			{
				char *dbcsAgentReadCommunityName = UnicodeToDbcsString ( agentReadCommunityName ) ;
				if ( dbcsAgentReadCommunityName )
				{
					if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
					{
						char *t_Address ;
						if ( m_provider->GetIpAddressString () && m_provider->GetIpAddressValue () && _stricmp ( m_provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
						{
							t_Address = m_provider->GetIpAddressValue () ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else
							{
								if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
								{
									t_Address = dbcsAgentAddress ;
								}
								else							
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;
								}
							}
						}

						if ( status )
						{
							if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
							{
								session = new SnmpV1OverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! ( *session ) () ) 
								{
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
							{
								session = new SnmpV2COverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! ( *session ) () ) 
								{
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;
							}
						}
					}
					else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
					{
						if ( ! SnmpTransportIpxAddress :: ValidateAddress ( dbcsAgentAddress  ) )
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
						}

						if ( status )
						{
							if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
							{
								session = new SnmpV1OverIpx (

									dbcsAgentAddress ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! ( *session ) () ) 
								{
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}

							}
							else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
							{
								session = new SnmpV2COverIpx (

									dbcsAgentAddress  ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! ( *session ) () ) 
								{
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}

							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

							}
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}

					delete [] dbcsAgentReadCommunityName ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentReadCommunityName" ) ;
				}

				delete [] dbcsAgentAddress ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" TransportInformation settings invalid"
	) ;
)
		}

		delete [] agentTransport ;
		delete [] agentAddress ;
		delete [] agentVersion ;
		delete [] agentReadCommunityName ;

		namespaceQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
		a_errorObject.SetMessage ( L"Failed to get class qualifier set" ) ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" SnmpClassEventObject :: GetTransportInformation () with Result (%lx)" ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

SnmpClassGetEventObject :: SnmpClassGetEventObject ( 

	CImpClasProv *provider , 
	BSTR Class ,
	IWbemContext *a_Context

) : SnmpClassEventObject ( provider , a_Context ) , m_classObject ( NULL ) , m_Received ( FALSE ) , m_Class ( NULL )
{
	m_Class = UnicodeStringDuplicate ( Class ) ;
}

SnmpClassGetEventObject :: ~SnmpClassGetEventObject ()
{
	if ( m_classObject )
		m_classObject->Release () ;

	delete [] m_Class ;
}

BOOL SnmpClassGetEventObject :: GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	WbemSnmpErrorObject errorStatusObject ;

/*
 *	Don't ask for SnmpNotifyStatus if HMOM specifically asked for SnmpNotifyStatus, otherwise
 *	we'll end up in a deadlock situation.
 */
	BOOL status = TRUE ;

	if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPNOTIFYSTATUS ) == 0 )
	{
		status = GetNotifyStatusObject ( notifyObject ) ;	
	}
	else
	{
		IWbemClassObject *notificationClassObject = NULL ;
		IWbemClassObject *errorObject = NULL ;

		if ( notificationClassObject = m_provider->GetSnmpNotificationObject ( errorStatusObject ) )
		{
			HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
			if ( SUCCEEDED ( result ) )
			{
				VARIANT variant ;
				VariantInit ( &variant ) ;

				variant.vt = VT_I4 ;
				variant.lVal = m_errorObject.GetWbemStatus () ;

				result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
				VariantClear ( &variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					variant.vt = VT_I4 ;
					variant.lVal = m_errorObject.GetStatus () ;

					result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSCODE , 0 , & variant , 0 ) ;
					VariantClear ( &variant ) ;

					if ( SUCCEEDED ( result ) )
					{
						if ( m_errorObject.GetMessage () ) 
						{
							variant.vt = VT_BSTR ;
							variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

							result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
							VariantClear ( &variant ) ;

							if ( ! SUCCEEDED ( result ) )
							{
								(*notifyObject)->Release () ;
								status = GetNotifyStatusObject ( notifyObject ) ;
							}
						}
					}
					else
					{
						(*notifyObject)->Release () ;
						status = GetNotifyStatusObject ( notifyObject ) ;
					}
				}
				else
				{
					(*notifyObject)->Release () ;
					status = GetNotifyStatusObject ( notifyObject ) ;
				}

				notificationClassObject->Release () ;
			}
			else
			{
				status = GetNotifyStatusObject ( notifyObject ) ;
			}
		}
		else
		{
			status = GetNotifyStatusObject ( notifyObject ) ;
		}
	}

	return status ;
}

BOOL SnmpClassGetEventObject :: ProcessCorrelatedClass ( WbemSnmpErrorObject &a_errorObject )
{
	BOOL status = TRUE ;

	IWbemQualifierSet *namespaceQualifierObject = NULL ;
	HRESULT result = m_classObject->GetQualifierSet ( &namespaceQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		LONG attributeType ;

		VARIANT variant ;
		VariantInit ( & variant ) ;

		result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_GROUP_OBJECTID , 
			0,	
			&variant ,
			& attributeType 

		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( variant.vt == VT_BSTR ) 
			{
// Get Device Transport information

				SnmpObjectIdentifierType objectIdentifier ( variant.bstrVal ) ;						
				if ( objectIdentifier.IsValid () )
				{
					SnmpSession *session ;
					status = GetTransportInformation ( m_errorObject , session ) ;
					if ( status ) 
					{
#ifdef CORRELATOR_INIT
						m_correlator = new SnmpCorrelation ( *session , this ) ;
#else //CORRELATOR_INIT
						m_correlator = new SnmpCorrelation ( *session , this, m_Interrogator ) ;
#endif //CORRELATOR_INIT
						char *groupObjectId = UnicodeToDbcsString ( variant.bstrVal ) ;
						if ( groupObjectId )
						{
							m_inCallstack = TRUE ;
							m_correlator->Start ( groupObjectId ) ;	
							if ( m_inCallstack == FALSE )
								m_synchronousComplete = TRUE ;
							m_inCallstack = FALSE ;
							delete [] groupObjectId ;
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: group_objectid" ) ;
						}
					}

				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: group_objectid" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: group_objectid" ) ;
			}

			VariantClear ( & variant ) ;
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_errorObject.SetMessage ( L"Class must specify valid qualifier for: group_objectid" ) ;
		}

		namespaceQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get Class qualifier set, must specify valid qualifier for: group_objectid" ) ;
	}

	return status ;
}

BOOL SnmpClassGetEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

// Get Class definition from SMIR

	IWbemClassObject *classObject = NULL ;
	HRESULT result = GetClass ( m_errorObject , &m_classObject , m_Class ) ;
	if ( SUCCEEDED ( result ) ) 
	{
// Get Namespace object which contains Device Transport information/Also used for merge of class

		status = GetNamespaceObject ( a_errorObject ) ;
		if ( status ) 
		{
			if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPMACRO ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPOBJECTTYPE ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPNOTIFYSTATUS ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPNOTIFICATION ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPVARBIND ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else
			{
// Determine if I need to correlate

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				
				result = m_classObject->Get ( L"__SUPERCLASS" , 0 , & t_Variant , NULL , NULL ) ;

				BSTR t_Parent = t_Variant.bstrVal ;
				
				if ( SUCCEEDED ( result ) && (t_Variant.vt == VT_BSTR) && (t_Parent != NULL) && (*t_Parent != L'\0'))
				{
					if ( _wcsicmp ( t_Parent , WBEM_CLASS_SNMPNOTIFICATION ) == 0 || _wcsicmp ( t_Parent , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) == 0 )
					{
						ReceiveClass ( m_classObject ) ;
						m_synchronousComplete = TRUE ;
					}
					else if (_wcsicmp ( t_Parent , WBEM_CLASS_SNMPOBJECTTYPE ) == 0)
					{
						if ( m_correlate )
						{
							status = ProcessCorrelatedClass ( a_errorObject ) ;
							if ( !status )
							{
								m_synchronousComplete = TRUE ;
							}
						}
						else
						{
							ReceiveClass ( m_classObject ) ;
							m_synchronousComplete = TRUE ;
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
						a_errorObject.SetMessage ( L"This is not a supported SNMP class." ) ;
					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
					a_errorObject.SetMessage ( L"Failed to get __SUPERCLASS property. This is not an SNMP base class." ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
		}
	}
	else
	{
		//no need to set an error msg etc 'cos GetClass does it.
		status = FALSE;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject (%lx))" ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

void SnmpClassGetEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )" 
	) ;
)

	ReceiveClass ( m_classObject ) ;
	phGroup->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )" 
	) ;
)

}

SnmpClassGetAsyncEventObject :: SnmpClassGetAsyncEventObject ( 

	CImpClasProv *provider , 
	BSTR Class , 
	IWbemObjectSink *notify ,
	IWbemContext *a_Context

) : SnmpClassGetEventObject ( provider , Class , a_Context ) ,
	m_notificationHandler ( notify ) 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: SnmpClassGetAsyncEventObject ()" 
	) ;
)

	m_notificationHandler->AddRef () ;
}

SnmpClassGetAsyncEventObject :: ~SnmpClassGetAsyncEventObject ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: ~SnmpClassGetAsyncEventObject ()" 
	) ;
)
	IWbemClassObject *notifyStatus = NULL;

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
		// Get Status object
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

	HRESULT result = m_notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;

	if ( notifyStatus )
	{
		notifyStatus->Release () ;
	}

	m_notificationHandler->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetAsyncEventObject :: ~SnmpClassGetAsyncEventObject ()" 
	) ;
)

}

void SnmpClassGetAsyncEventObject :: Process ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: Process ()" 
	) ;
)

	if ( ! m_synchronousComplete )
	{
		BOOL status = ProcessClass ( m_errorObject ) ;
		if ( status )
		{
			if ( m_synchronousComplete )
				ReceiveComplete () ;
		}
		else
		{
			ReceiveComplete () ;	
		}
	}
	else
	{			
		ReceiveComplete () ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpClassGetAsyncEventObject :: ReceiveClass ( IWbemClassObject *classObject ) 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: ReceiveClass ( IWbemClassObject *classObject )" 
	) ;
)

	if ( ! m_Received )
	{
		m_Received = TRUE ;
		m_notificationHandler->Indicate ( 1 , & m_classObject ) ;
	}

}

void SnmpClassGetAsyncEventObject :: ReceiveComplete () 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
/*
 *	If no error specified yet then check for NOT_FOUND
 */

		if ( ! m_Received )
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			m_errorObject.SetMessage ( L"Class not defined" ) ;
		}
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	if ( ! m_inCallstack )
	{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

		Complete () ;
	}
	else
		m_inCallstack = FALSE ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetAsyncEventObject :: Receive4 ()" 
	) ;
)
}

void SnmpClassGetAsyncEventObject :: ReceiveError ( IN const SnmpErrorReport &a_errorReport )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: ReceiveError ( IN const SnmpErrorReport &a_errorReport )"
	) ;
)

	switch ( a_errorReport.GetError () )
	{
		case Snmp_Error:
		{
			switch ( a_errorReport.GetStatus () )
			{
				case Snmp_No_Response:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"No Response from device" ) ;
				}
				break; 

				default:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
		}
		break ;
	}
}

SnmpClassEnumEventObject :: SnmpClassEnumEventObject ( 

	CImpClasProv *provider , 
	BSTR Parent ,
	ULONG flags ,
	IWbemContext *a_Context

) : SnmpClassEventObject ( provider , a_Context ) , m_Flags ( flags ) 
{
	m_Parent = UnicodeStringDuplicate ( Parent ) ;
}

BOOL SnmpClassEnumEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class = (%s) )" ,
		a_Class
	) ;
)

	BOOL status = TRUE ;

// Get Class definition from SMIR

	IWbemClassObject *classObject = NULL ;
	HRESULT result = GetClass ( a_errorObject , &classObject , a_Class ) ;
	if ( SUCCEEDED ( result ) ) 
	{
// Get Namespace object which contains Device Transport information/Also used for merge of class

		status = GetNamespaceObject ( a_errorObject ) ;
		if ( status ) 
		{
			ReceiveClass ( classObject ) ;
		}

		classObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
		a_errorObject.SetMessage ( L"Class not defined" ) ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class = (%s) )" ,
		a_Class
	) ;
)

	return status ;
}

SnmpClassEnumEventObject :: ~SnmpClassEnumEventObject ()
{
	delete [] m_Parent ;
}

BOOL SnmpClassEnumEventObject :: GetEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: GetEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = GetNamespaceObject ( m_errorObject ) ;
	if ( status ) 
	{
// Determine if I need to correlate

		if ( m_correlate )
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Performing Class Correlation"
	) ;
)

// Get Device Transport information
					
			SnmpSession *session ;
			status = GetTransportInformation ( m_errorObject , session ) ;
			if ( status ) 
			{
				m_inCallstack = TRUE ;
#ifdef CORRELATOR_INIT
				m_correlator = new SnmpCorrelation ( *session , this ) ;
#else //CORRELATOR_INIT
				m_correlator = new SnmpCorrelation ( *session , this, m_Interrogator ) ;
#endif //CORRELATOR_INIT
				m_correlator->Start ( NULL ) ;	
				if ( m_inCallstack == FALSE )
					m_synchronousComplete = TRUE ;
				m_inCallstack = FALSE ;
			}
			else
			{
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Not Performing Class Correlation"
	) ;
)

			ReceiveGroup ( NULL ) ;
			m_synchronousComplete = TRUE ;
		}
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: GetEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	return status ;
}

BOOL SnmpClassEnumEventObject :: GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	HRESULT result = S_OK ;

	BOOL status = GetNamespaceObject ( m_errorObject ) ;
	if ( status ) 
	{
		IWbemClassObject *classObject = NULL ;
		IEnumNotificationClass *enumClass = NULL ;
		ISmirNotificationClassHandle *classHandle = NULL ;

		result = m_Interrogator->EnumAllNotificationClasses (

			&enumClass
		) ;

		if ( SUCCEEDED ( result ) )
		{
			ULONG fetched = 0 ;
			enumClass->Reset () ;
			while ( enumClass->Next ( 1 , & classHandle , &fetched ) == WBEM_NO_ERROR )
			{
				result = classHandle->GetWBEMNotificationClass ( & classObject ) ;
				if ( SUCCEEDED ( result ) ) 
				{
					ReceiveClass ( classObject ) ;
					classObject->Release () ;
				}

				classHandle->Release () ;
			}

			enumClass->Release () ;
		}
		else
		{
		}
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	return SUCCEEDED ( result ) ;
}

BOOL SnmpClassEnumEventObject :: GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	HRESULT result = S_OK ;

	BOOL status = GetNamespaceObject ( m_errorObject ) ;
	if ( status ) 
	{
		IWbemClassObject *classObject = NULL ;
		IEnumExtNotificationClass *enumClass = NULL ;
		ISmirExtNotificationClassHandle *classHandle = NULL ;

		result = m_Interrogator->EnumAllExtNotificationClasses (

			&enumClass
		) ;

		if ( SUCCEEDED ( result ) )
		{
			ULONG fetched = 0 ;
			enumClass->Reset () ;
			while ( enumClass->Next ( 1 , & classHandle , &fetched ) == WBEM_NO_ERROR )
			{
				result = classHandle->GetWBEMExtNotificationClass ( & classObject ) ;
				if ( SUCCEEDED ( result ) ) 
				{
					ReceiveClass ( classObject ) ;
					classObject->Release () ;
				}

				classHandle->Release () ;
			}

			enumClass->Release () ;
		}
		else
		{
		}
	}
	
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	return SUCCEEDED ( result ) ;
}

BOOL SnmpClassEnumEventObject :: ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject (%s) )" ,
		m_Parent
	) ;
)

	BOOL status = TRUE ;

// Get Namespace object which contains Device Transport information/Also used for merge of class

	if ( m_Flags & WBEM_FLAG_SHALLOW )
	{
		if ( ( ! m_Parent ) || _wcsicmp ( m_Parent , WBEM_CLASS_NULL ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPMACRO ) ;
			status = status && ProcessClass ( a_errorObject , WBEM_CLASS_SNMPVARBIND ) ;
			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPMACRO ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPOBJECTTYPE ) ;
			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPOBJECTTYPE ) == 0 )
		{
			status = GetEnumeration ( a_errorObject ) ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_NOTIFYSTATUS ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFYSTATUS ) ;
			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_EXTRINSICEVENT ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFICATION ) ;
			status = status & ProcessClass ( a_errorObject , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) ;

			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPNOTIFICATION ) == 0 )
		{
			status = GetNotificationEnumeration ( a_errorObject ) ;

			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) == 0 )
		{
			status = GetExtendedNotificationEnumeration ( a_errorObject ) ;

			m_synchronousComplete = TRUE ;
		}
		else
		{
// Get Class definition from SMIR

			IWbemClassObject *classObject = NULL ;
			HRESULT result = GetClass ( a_errorObject , &classObject , m_Parent ) ;
			if ( SUCCEEDED ( result ) ) 
			{
				classObject->Release () ;

				m_synchronousComplete = TRUE ;
				status = TRUE ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				a_errorObject.SetMessage ( L"Parent class not known" ) ;

				m_synchronousComplete = TRUE ;
			}
		}
	}
	else
	{
		if ( ( ! m_Parent ) || _wcsicmp ( m_Parent , WBEM_CLASS_NULL ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPMACRO ) ;
			if ( status )
			{
				status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPOBJECTTYPE ) ;
				if ( status ) 
				{
					status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFYSTATUS ) ;
					if ( status ) 
					{
						status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPVARBIND ) ;
						if ( status )
						{
							status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFICATION ) ;
							if ( status ) 
							{
								status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) ;
								if ( status )
								{
									status = GetNotificationEnumeration ( a_errorObject ) ;
									if ( status ) 
									{
										status = GetExtendedNotificationEnumeration ( a_errorObject ) ;
										if ( status ) 
										{
											status = GetEnumeration ( a_errorObject ) ;
										}
									}
								}
							}
						}
					}					
				}
			}
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPMACRO ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPOBJECTTYPE ) ;
			if ( status ) 
			{
				status = GetEnumeration ( a_errorObject ) ;
			}
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPOBJECTTYPE ) == 0 )
		{
			status = GetEnumeration ( a_errorObject ) ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_EXTRINSICEVENT ) == 0 )
		{
			status = GetNotificationEnumeration ( a_errorObject ) ;
			if ( status ) 
			{
				status = GetExtendedNotificationEnumeration ( a_errorObject ) ;
			}
			m_synchronousComplete = TRUE ;
		}
		else
		{
// Get Class definition from SMIR

			IWbemClassObject *classObject = NULL ;
			HRESULT result = GetClass ( a_errorObject , &classObject , m_Parent ) ;
			if ( SUCCEEDED ( result ) ) 
			{
				classObject->Release () ;
				m_synchronousComplete = TRUE ;
				status = TRUE ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				a_errorObject.SetMessage ( L"Parent class not known" ) ;

				m_synchronousComplete = TRUE ;
			}
		}
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject (%s))" ,
		m_Parent
	) ;
)

	return status ;
}

void SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )
{
DebugMacro1( 

	if ( phGroup )
	{
		BSTR t_ModuleName = NULL ;
		BSTR t_GroupOID = NULL ;

		phGroup->GetModuleName ( &t_ModuleName ) ;
		phGroup->GetGroupOID ( &t_GroupOID ) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup = ((%s),(%s)) )" ,
			t_ModuleName ,
			t_GroupOID
		) ;

		SysFreeString ( t_ModuleName ) ;
		SysFreeString ( t_GroupOID ) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup = NULL )"
		) ;
	}
)

	HRESULT result = S_OK ;

	m_GroupsReceived ++ ;

	IWbemClassObject *classObject = NULL ;
	IEnumClass *enumClass = NULL ;
	ISmirClassHandle *classHandle = NULL ;

	if ( phGroup )
	{
		result = m_Interrogator->EnumClassesInGroup (

			&enumClass ,
			phGroup 
		) ;
	}
	else
	{
		result = m_Interrogator->EnumAllClasses (

			&enumClass 
		) ;
	}

	if ( SUCCEEDED ( result ) )
	{
		ULONG fetched = 0 ;
		enumClass->Reset () ;
		while ( enumClass->Next ( 1 , & classHandle , &fetched ) == WBEM_NO_ERROR )
		{
			result = classHandle->GetWBEMClass ( & classObject ) ;
			if ( SUCCEEDED ( result ) ) 
			{
				ReceiveClass ( classObject ) ;
				classObject->Release () ;
			}

			classHandle->Release () ;
		}

		enumClass->Release () ;
	}
	else
	{
	}

	if ( phGroup )
	{
		phGroup->Release () ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )" 
	) ;
)

}

SnmpClassEnumAsyncEventObject :: SnmpClassEnumAsyncEventObject ( 

	CImpClasProv *provider , 
	BSTR Parent ,
	ULONG flags ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context

) : SnmpClassEnumEventObject ( provider , Parent , flags , a_Context ) ,
	m_notificationHandler ( notify )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: SnmpClassEnumAsyncEventObject ()" 
	) ;
)

	m_notificationHandler->AddRef () ;
}

SnmpClassEnumAsyncEventObject :: ~SnmpClassEnumAsyncEventObject ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ~SnmpClassEnumAsyncEventObject ()" 
	) ;
)

// Get Status object

	IWbemClassObject *notifyStatus = NULL;
	
	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)
	HRESULT result = m_notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;

	if ( notifyStatus )
	{
		notifyStatus->Release () ;
	}

	m_notificationHandler->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumAsyncEventObject :: ~SnmpClassEnumAsyncEventObject ()" 
	) ;
)

}

void SnmpClassEnumAsyncEventObject :: Process ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: Process ()" 
	) ;
)

	if ( ! m_synchronousComplete )
	{
		BOOL status = ProcessEnumeration ( m_errorObject ) ;
		if ( status )
		{
			if ( m_synchronousComplete )
				ReceiveComplete () ;
		}
		else
		{
			ReceiveComplete () ;	
		}
	}
	else
	{
		ReceiveComplete () ;	
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpClassEnumAsyncEventObject :: ReceiveClass ( IWbemClassObject *classObject ) 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ReceiveClass ()" 
	) ;
)

	m_notificationHandler->Indicate ( 1, & classObject ) ;
}

void SnmpClassEnumAsyncEventObject :: ReceiveError ( IN const SnmpErrorReport &errorReport )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ReceiveError ()" 
	) ;
)

	switch ( errorReport.GetError () )
	{
		case Snmp_Error:
		{
			switch ( errorReport.GetStatus () )
			{
				case Snmp_No_Response:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"No Response from device" ) ;
				}
				break; 

				default:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
		}
		break ;
	}
}

void SnmpClassEnumAsyncEventObject :: ReceiveComplete () 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
	}
	else
	{
		if ( m_GroupsReceived )
		{
			if ( FAILED ( m_errorObject.GetWbemStatus () ) ) 
			{
				if ( m_errorObject.GetStatus () == WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) 
				{
					m_errorObject.SetWbemStatus ( WBEM_S_TIMEDOUT ) ;
				}
			}
		}
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	if ( ! m_inCallstack )
	{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

		Complete () ;
	}
	else
		m_inCallstack = FALSE ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumAsyncEventObject :: ReceiveComplete ()" 
	) ;
)


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\corrsnmp.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>

#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <cordefs.h>
#include <snmplog.h>


CCorrResult::CCorrResult() : m_report(Snmp_Success, Snmp_No_Error),
							m_In(NULL, 0),
							m_Out()
{
}


CCorrResult::~CCorrResult()
{
}


void CCorrResult::DebugOutputSNMPResult() const
{
	CCorrObjectID in;
	in.Set((UINT*)m_In.GetValue(), m_In.GetValueLength());
	CString debugstr;
	in.GetString(debugstr);
	debugstr += L"\t\t:\t\t";

	if (Snmp_Success == m_report.GetError())
	{
		CString tmp;
		m_Out.GetString(tmp);
		debugstr += tmp;
	}
	else
	{
		switch(m_report.GetStatus())
		{
			case Snmp_Gen_Error:
			{
				debugstr += L"Snmp_Gen_Error";
			}
			break;

			case Snmp_Local_Error:
			{
				debugstr += L"Snmp_Local_Error";
			}
			break;

			case Snmp_General_Abort:
			{
				debugstr += L"Snmp_General_Abort";
			}
			break;

			case Snmp_No_Response:
			{
				debugstr += L"Snmp_No_Response";
			}
			break;

			case Snmp_Too_Big:
			{
				debugstr += L"Snmp_Too_Big";
			}
			break;

			case Snmp_Bad_Value:
			{
				debugstr += L"Snmp_Bad_Value";
			}
			break;

			case Snmp_Read_Only:
			{
				debugstr += L"Snmp_Read_Only";
			}
			break;

			case Snmp_No_Access:
			{
				debugstr += L"Snmp_No_Access";
			}
			break;

			case Snmp_Wrong_Type:
			{
				debugstr += L"Snmp_Wrong_Type";
			}
			break;

			case Snmp_Wrong_Length:
			{
				debugstr += L"Snmp_Wrong_Length";
			}
			break;

			case Snmp_Wrong_Encoding:
			{
				debugstr += L"Snmp_Wrong_Encoding";
			}
			break;

			case Snmp_Wrong_Value:
			{
				debugstr += L"Snmp_Wrong_Value";
			}
			break;

			case Snmp_No_Creation:
			{
				debugstr += L"Snmp_No_Creation";
			}
			break;

			case Snmp_Inconsistent_Value:
			{
				debugstr += L"Snmp_Inconsistent_Value";
			}
			break;

			case Snmp_Resource_Unavailable:
			{
				debugstr += L"Snmp_Resource_Unavailable";
			}
			break;

			case Snmp_Commit_Failed:
			{
				debugstr += L"Snmp_Commit_Failed";
			}
			break;

			case Snmp_Undo_Failed:
			{
				debugstr += L"Snmp_Undo_Failed";
			}
			break;

			case Snmp_Authorization_Error:
			{
				debugstr += L"Snmp_Authorization_Error";
			}
			break;

			case Snmp_Not_Writable:
			{
				debugstr += L"Snmp_Not_Writable";
			}
			break;

			case Snmp_Inconsistent_Name:
			{
				debugstr += L"Snmp_Inconsistent_Name";
			}
			break;

			case Snmp_No_Such_Name:
			{
				debugstr += L"Snmp_No_Such_Name - Finished successfully!!";
			}
			break;


			default:
			{
				debugstr += L"Unexpected SNMP Error returned";
			}
			break;
		}
	}
	debugstr += L'\n';
DebugMacro6( 
	SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
		debugstr);
)
}

char *CCorrNextId::GetString(IN const SnmpObjectIdentifier &id)
{
   UINT length = id.GetValueLength();

   if (0 == length)
	   return NULL;

   ULONG *value = id.GetValue();

   UINT allocated_bytes = length*BYTES_PER_FIELD;
   char *str = new char[allocated_bytes];

   ostrstream output_stream(str, allocated_bytes);

   if ( !output_stream.good() )
	  return NULL;

   output_stream << (ULONG)value[0];

   for(UINT index=1; 
	   (output_stream.good()) && (index < length); 
	   index++)
	   output_stream << FIELD_SEPARATOR << (ULONG)value[index];

   if ( !output_stream.good() )
      return NULL;

   // end of string
   output_stream << (char)EOS;

   return str;
}

void CCorrNextId::ReceiveResponse()
{
DebugMacro6(
	for (UINT x = 0; x < m_ResultsCnt; x++)
	{
		m_Results[x].DebugOutputSNMPResult();
	}
)
	// the operation is complete - hand the object id
	// and the error report to the user
	m_NextResult = 1;
	ReceiveNextId(m_Results[0].m_report, m_Results[0].m_Out);
}


BOOL CCorrNextId::GetNextResult()
{
	if (m_NextResult >= m_ResultsCnt)
	{
		if (m_Results)
		{
			delete [] m_Results;
			m_Results = NULL;
		}

		return FALSE;
	}

	UINT lastResult = m_NextResult - 1;
	
	while (m_NextResult < m_ResultsCnt)
	{
		if (m_Results[lastResult].m_Out != m_Results[m_NextResult++].m_Out)
		{
			ReceiveNextId(m_Results[m_NextResult - 1].m_report,
							m_Results[m_NextResult - 1].m_Out);
			return TRUE;
		}
	}

	if (m_Results)
	{
		delete [] m_Results;
		m_Results = NULL;
	}

	return FALSE;
}


void CCorrNextId::ReceiveVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind,
		IN const SnmpVarBind &replyVarBind,
		IN const SnmpErrorReport &error)
{	
	UINT x = 0;

	while (x < m_ResultsCnt) // have a test just in case
	{
		if (m_Results[x].m_In == requestVarBind.GetInstance())
		{
			break;
		}

		x++;
	}

	// currently uses the default "=" operator (bitwise copy)
	m_Results[x].m_report = error;
	m_Results[x].m_Out.Set((UINT*)replyVarBind.GetInstance().GetValue(),
							replyVarBind.GetInstance().GetValueLength());
}


void CCorrNextId::ReceiveErroredVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind,
		IN const SnmpErrorReport &error)
{
	UINT x = 0;

	while (x < m_ResultsCnt) // have a test just in case
	{
		if (m_Results[x].m_In == requestVarBind.GetInstance())
		{
			break;
		}

		x++;
	}

	// currently uses the default "=" operator (bitwise copy)
	m_Results[x].m_report = error;
}


// constructor - creates an operation and passes the snmp_session to it
CCorrNextId::CCorrNextId(IN SnmpSession &snmp_session)
		: SnmpGetNextOperation(snmp_session),
		  m_Results(NULL),
		  m_NextResult(0),
		  m_ResultsCnt(0)
{
}

// delete the m_object_id_string if required
CCorrNextId::~CCorrNextId()
{
	if ( m_Results != NULL )
	{
		delete [] m_Results;
	}
}

// in case of an error encountered while the method executes, 
// ReceiveNextId(LocalError, NULL) will be called synchronously
// otherwise, an asynchronous call to ReceiveNextId provides the next_id	
void CCorrNextId::GetNextId(IN const CCorrObjectID const *object_ids, IN UINT len)
{
	SnmpVarBindList var_bind_list;

	if (m_Results)
	{
		delete [] m_Results;
	}

	m_Results = new CCorrResult[len];
	m_NextResult = 0;
	m_ResultsCnt = len;

	for (UINT x = 0; x < len; x++)
	{
		m_Results[x].m_In.SetValue((ULONG*)object_ids[x].GetIds(),
										object_ids[x].GetLength());
		SnmpNull null_value;
		SnmpVarBind var_bind(m_Results[x].m_In, null_value);
		var_bind_list.Add(var_bind);
	}

	SendRequest(var_bind_list);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\evtencap.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <smir.h>

#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>
#include <evtencap.h>

extern CEventProviderWorkerThread* g_pWorkerThread ;

CEncapMapper::CEncapMapper() : m_WbemSnmpObj(NULL)
{
}


HRESULT CEncapMapper::GetSpecificPropertyValue(long lNumElements, MYWBEM_NAME_ELEMENT *aElements,
											long lFlags, VARIANT *pvValue)
{
	//all specific properties have one element, the property name...
	if ((lNumElements != 1) || (0 != aElements[0].m_nType))
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificPropertyValue invalid parameters\r\n");
)
		return WBEM_E_FAILED;
	}

	BOOL bContinue = TRUE;

	if (NULL == m_WbemSnmpObj)
	{
		m_WbemSnmpObj = new WbemSnmpClassObject;
		IWbemClassObject *pObj = NULL;
		GetClassInstance(&pObj);

		if (NULL != pObj)
		{
			WbemSnmpErrorObject errorObj;

			if (!m_WbemSnmpObj->Set(errorObj, pObj, FALSE))
			{
				bContinue = FALSE;
			}
		}
		else
		{
			bContinue = FALSE;
		}
	}

	if (bContinue)
	{
		WbemSnmpProperty *snmpProp = m_WbemSnmpObj->FindProperty(aElements[0].Element.m_wszPropertyName);

		if (NULL != snmpProp)
		{
			//set the property value using the snmp varbind
			//and get the property value and return TRUE...
			if (SetAndGetProperty(snmpProp, pvValue))
			{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificPropertyValue successful\r\n");
)
				return NOERROR;
			}
		}
	}
	else if (NULL != m_WbemSnmpObj)
	{
		delete m_WbemSnmpObj;
		m_WbemSnmpObj = NULL;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificPropertyValue failed\r\n");
)

	return WBEM_E_FAILED;
}


CEncapMapper::~CEncapMapper()
{
	if (NULL != m_WbemSnmpObj)
	{
		delete m_WbemSnmpObj;
	}
}


BOOL CEncapMapper::SetAndGetProperty(WbemSnmpProperty *wbemSnmpProp, VARIANT *pvValue)
{
	//Get the varbind qualifier value, set the keyvalues qualifier and set the
	//property value using the snmp varbind.
	//Get the property value and return TRUE;
	WbemSnmpQualifier *vbQual = wbemSnmpProp->FindQualifier(EVENT_VBINDEX_QUAL);

	if (NULL == vbQual)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty missing parameter's vbindex qualifier\r\n");
)
		return FALSE;
	}

	VARIANT v;
	VariantInit(&v);
	ULONG vbindex;

	//has to be at least 3, i.e. third vb, to be a specific property...
	if (!vbQual->GetValue(v) || (VT_I4 != v.vt) || (2 > v.lVal))
	{
		VariantClear(&v);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty invalid index qual\r\n");
)
		return FALSE;
	}

	if (v.lVal >= m_vbs.length)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty no value return TRUE\r\n");
)
		return TRUE;
	}

	vbindex = v.lVal - 1; //zero based in our array
	VariantClear(&v);

	if (m_vbs.vbs[vbindex].fDone)
	{
		//we've done this one already,
		//just get the property value and return it..
		CIMTYPE cimType;

		if (!wbemSnmpProp->GetValue(*pvValue, cimType))
		{
			pvValue->vt = VT_NULL;
		}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty return value\r\n");
)		
		return TRUE;
	}

	const SnmpObjectIdentifier& vb_OID = m_vbs.vbs[vbindex].pVarBind->GetInstance();
	WbemSnmpQualifier *oidQual = wbemSnmpProp->FindQualifier(WBEM_QUALIFIER_OBJECT_IDENTIFIER);
	BOOL bMatchedOID = FALSE;
	m_vbs.vbs[vbindex].fDone = TRUE;		

	if (NULL == oidQual)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty missing parameter's OID qualifier\r\n");
)
	}
	else
	{
		SnmpInstanceType *oid_valuetype = oidQual->GetValue () ;

		if ( typeid ( *oid_valuetype ) == typeid ( SnmpObjectIdentifierType ) )
		{
			SnmpObjectIdentifier oid_value = *(SnmpObjectIdentifier *) oid_valuetype->GetValueEncoding () ; 
			
			//compare without the instance info
			if (oid_value.GetValueLength() < vb_OID.GetValueLength())
			{
				SnmpObjectIdentifier* common = vb_OID.Cut(oid_value);

				if (NULL != common)
				{
					if ((*common) == oid_value)
					{
						bMatchedOID = TRUE;
					}

					delete common;
				}
			}
		}
		else
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty parameter's OID is of wrong type\r\n");
)
		}

	}

	if (wbemSnmpProp->SetValue(&(m_vbs.vbs[vbindex].pVarBind->GetValue())))
	{
		CIMTYPE cimType;

		if (wbemSnmpProp->GetValue(*pvValue, cimType))
		{
		}
	}
	else
	{
		bMatchedOID = FALSE;
	}

	if (!bMatchedOID)
	{
		WbemSnmpQualifier *qualifier = NULL ;
		wbemSnmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

		if ( qualifier = wbemSnmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
		{
			IWbemQualifierSet *t_QualifierSet = NULL;
			IWbemClassObject *pObj = NULL;
			GetClassInstance(&pObj);

			HRESULT result = pObj->GetPropertyQualifierSet ( wbemSnmpProp->GetName () , & t_QualifierSet ) ;

			if ( SUCCEEDED ( result ) )
			{
				SnmpIntegerType integer ( 1 , NULL ) ;
				qualifier->SetValue ( t_QualifierSet , integer ) ;
			}

			t_QualifierSet->Release () ;
		}
	}

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty returning TRUE\r\n");
)
	return TRUE;
}

void CEncapMapper::GenerateInstance(IWbemClassObject** ppInst)
{
	if (NULL == ppInst)
	{
		//invalid out parameter
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance invalid parameter\r\n");
)
		return;
	}

	//set out parameter to NULL;
	*ppInst = NULL;
	IWbemClassObject *pObj = NULL;
	GetClassInstance(&pObj);

	if (NULL == pObj)
	{
		//failed to get class instance
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to get class defn\r\n");
)
		return;
	}

#if 0
	HRESULT result = S_OK ;
#else

	//get all the property names and set their values...
	SAFEARRAY* pPropNames;
	HRESULT result = pObj->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &pPropNames);

	if (FAILED(result))
	{
		//failed to get the property names
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to get parameter list\r\n");
)

		return;
	}
	
	//time to <insert expletive> around with a safearray...
	//work out the size of the safearray and access the data
	if(SafeArrayGetDim(pPropNames) != 1)
	{
		//wrong dimensions in this array
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance parameter array is WRONG!\r\n");
)
		return;
	}


	LONG arraylen = pPropNames->rgsabound[0].cElements;
	BSTR *pbstr;
	result = SafeArrayAccessData(pPropNames, (void **)&pbstr);

	if(FAILED(result))
	{
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to access parameter array\r\n");
)
		return;
	}

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance setting properties\r\n");
)

	BOOL t_bSetProp = FALSE;

	//iterate through the names and set the properties...
	for (LONG i = 0; i < arraylen; i++)
	{
		VARIANT v;
		MYWBEM_NAME_ELEMENT property_struct;
		property_struct.m_nType = 0; //string value
		property_struct.Element.m_wszPropertyName = pbstr[i];
		result = GetPropertyValue(1, &property_struct, 0, &v);

		if (FAILED(result))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to get value for %s\r\n",
		pbstr[i]);
)
			continue;
		}
		else
		{
			t_bSetProp = TRUE;
		}
		
		if ((v.vt != VT_NULL) && (v.vt != VT_EMPTY))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance setting property %s\r\n",
		pbstr[i]);
)
			result = pObj->Put(pbstr[i], 0, &v, 0);
DebugMacro9( 
			if (FAILED(result))
			{
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance setting property %s\r\n",
		pbstr[i]);
			}
)
			
		}
		
		VariantClear(&v);
	}
	
	SafeArrayUnaccessData(pPropNames);
	SafeArrayDestroy(pPropNames);

#endif

	//if a single property has been put send it on....
	if (t_bSetProp)
	{
		pObj->AddRef();
		*ppInst = pObj;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance returning\r\n");
)
}


void CEncapMapper::ResetData()
{
	//do class specific stuff then call parent class's reset
	if (NULL != m_WbemSnmpObj)
	{
		delete m_WbemSnmpObj;
		m_WbemSnmpObj = NULL;
	}

	CMapToEvent::ResetData();
}


BOOL CEncapMapper::GetSpecificClass()
{
	//Build path of mapper instance...
	CString path(MAPPER_CLASS_PATH_PREFIX);
	path += m_oid;
	path += '\"';
	BSTR pathstr = path.AllocSysString();
	IWbemClassObject *pObj = NULL;

	HRESULT result = g_pWorkerThread->GetServerWrap ()->GetMapperObject(pathstr, NULL, & pObj );

	SysFreeString(pathstr);

	if (result == S_OK)
	{
		VARIANT v;
		VariantInit(&v);
		result = pObj->Get(MAPPER_CLASS_EVENTCLASSPROP, 0, &v, NULL, NULL);
		pObj->Release();
		
		if (SUCCEEDED(result) && (VT_BSTR == v.vt))
		{
			m_class = v.bstrVal;
			VariantClear(&v);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificClass got class defn\r\n");
)
			return TRUE;
		}
		else
		{
			VariantClear(&v);
		}
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificClass failed to get class defn\r\n");
)

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\evtprov.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <classfac.h>

#include <smir.h>
#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>

extern CRITICAL_SECTION g_CacheCriticalSection;
extern CEventProviderWorkerThread* g_pWorkerThread;

CWbemServerWrap::CWbemServerWrap(IWbemServices *pServ) : m_ref ( 0 ), m_Serv(NULL)
{
	m_Serv = pServ;

	if (m_Serv)
	{
		m_Serv->AddRef();
	}

	g_pWorkerThread->AddClassesToCache((DWORD_PTR)(&m_ClassMap), &m_ClassMap);
}

CWbemServerWrap::~CWbemServerWrap()
{
	if (m_Serv)
	{
		m_Serv->Release();
	}

	g_pWorkerThread->RemoveClassesFromCache((DWORD_PTR)(&m_ClassMap));
	m_ClassMap.RemoveAll();
}

ULONG CWbemServerWrap::AddRef()
{
	return (ULONG)(InterlockedIncrement(&m_ref));
}

ULONG CWbemServerWrap::Release()
{
	ULONG i = (ULONG)(InterlockedDecrement(&m_ref));

	if (i == 0)
	{
		delete this;
	}

	return i;
}

HRESULT CWbemServerWrap::GetMapperObject(BSTR a_path, IWbemContext *a_pCtx, IWbemClassObject **a_ppObj)
{
	if (a_ppObj == NULL)
	{
		return WBEM_E_FAILED;
	}

	*a_ppObj = NULL;
	HRESULT result = WBEM_NO_ERROR;
	SCacheEntry *t_CacheEntry = NULL;
	EnterCriticalSection ( & g_CacheCriticalSection ) ;

	if (!m_ClassMap.Lookup(a_path, t_CacheEntry))
	{
DebugMacro14( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"Cache Miss [%s]\r\n" , a_path
	);
)

		LPUNKNOWN pInterrogativeInt = NULL;

		result = CoCreateInstance (

			CLSID_SMIR_Database,
			NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
			IID_ISMIR_Interrogative, 
			(void**)&pInterrogativeInt
		);

		if ((result != S_OK) || (NULL == pInterrogativeInt))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificClass failed to connect to SMIR\r\n");
)
			return result ;
		}

		result = ((ISmirInterrogator*)pInterrogativeInt)->GetWBEMClass(a_ppObj, a_path);
		pInterrogativeInt->Release();

		if ( SUCCEEDED ( result ) )
		{
			t_CacheEntry = new SCacheEntry(*a_ppObj);
			m_ClassMap[a_path] = t_CacheEntry;
			(*a_ppObj)->AddRef();
		}
		else
		{
			t_CacheEntry = new SCacheEntry(NULL);
			m_ClassMap[a_path] = t_CacheEntry;
		}
	}
	else
	{
		if ( t_CacheEntry->m_Class )
		{
			*a_ppObj = t_CacheEntry->m_Class;
			(*a_ppObj)->AddRef();
		}
		else
		{
			result = WBEM_E_NOT_FOUND ;
		}
	}
	
	LeaveCriticalSection ( & g_CacheCriticalSection ) ;

	return result ;
}

HRESULT CWbemServerWrap::GetObject(BSTR a_path, IWbemContext *a_pCtx, IWbemClassObject **a_ppObj)
{
	if ((a_ppObj == NULL) || (m_Serv == NULL))
	{
		return WBEM_E_FAILED;
	}

	*a_ppObj = NULL;
	HRESULT result = WBEM_NO_ERROR;
	SCacheEntry *t_CacheEntry = NULL;
	EnterCriticalSection ( & g_CacheCriticalSection ) ;

	if (!m_ClassMap.Lookup(a_path, t_CacheEntry))
	{
DebugMacro14( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"Cache Miss [%s]\r\n" , a_path
	);
)

		result = m_Serv->GetObject(a_path, 0, a_pCtx, a_ppObj, NULL);

		if ( SUCCEEDED(result) )
		{
			t_CacheEntry = new SCacheEntry(*a_ppObj);
			m_ClassMap[a_path] = t_CacheEntry;
			(*a_ppObj)->AddRef();
		}
	}
	else
	{
		*a_ppObj = t_CacheEntry->m_Class;
		(*a_ppObj)->AddRef();
	}
	
	LeaveCriticalSection ( & g_CacheCriticalSection ) ;
	return result;
}


STDMETHODIMP CTrapEventProvider::Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
				)
{
	SetStructuredExceptionHandler seh;

	try
	{
DebugMacro9( 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
			L"Entering CTrapEventProvider::Initialize\n");
)

		m_pNamespace = new CWbemServerWrap(pCIMOM);
		m_pNamespace->AddRef();
		pInitSink->SetStatus ( WBEM_S_INITIALIZED , 0 );
	

DebugMacro9( 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
				L"Leaving CTrapEventProvider::Initialize with SUCCEEDED\n");
)

		return WBEM_NO_ERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}


STDMETHODIMP CTrapEventProvider::ProvideEvents(IWbemObjectSink* pSink, LONG lFlags)
{
	SetStructuredExceptionHandler seh;

	try
	{
DebugMacro9( 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
			L"Entering CTrapEventProvider::ProvideEvents\n");
)

		m_pEventSink = pSink;
		m_pEventSink->AddRef();
		
		if (!m_thrd->Register(this))
		{

DebugMacro9( 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
				L"Leaving CTrapEventProvider::ProvideEvents with FAILED\n");
)

			return WBEM_E_FAILED;
	}

DebugMacro9( 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
				L"Leaving CNTEventProvider::ProvideEvents with SUCCEEDED\n");
)

		return WBEM_NO_ERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}


CTrapEventProvider::~CTrapEventProvider()
{
	if (m_thrd)
	{
		m_thrd->UnRegister(this);
	}

	if ( m_pEventSink )
	{
		m_pEventSink->Release () ;
	}

	if ( m_pNamespace )
	{
		m_pNamespace->Release () ;
	}
}


CTrapEventProvider::CTrapEventProvider(DWORD mapperType, CEventProviderThread* thrd) 
:	m_thrd (NULL),
	m_pNamespace (NULL), 
	m_pEventSink (NULL)
{
	m_thrd = thrd;
	m_MapType = mapperType;
	m_ref = 0;
}


CWbemServerWrap* CTrapEventProvider::GetNamespace()
{
	m_pNamespace->AddRef();
	return m_pNamespace;
}

IWbemObjectSink* CTrapEventProvider::GetEventSink()
{
	m_pEventSink->AddRef();
	return m_pEventSink;
}
void CTrapEventProvider::ReleaseAll()
{
	//release dependencies
	m_pNamespace->Release();
	m_pEventSink->Release();

    if ( 0 != InterlockedDecrement(&m_ref) )
	{
		InterlockedDecrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
        return;
	}

	delete this;
	InterlockedDecrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
	return;
}

void  CTrapEventProvider::AddRefAll()
{
	//addref dependencies
	m_pNamespace->AddRef();
	m_pEventSink->AddRef();

	InterlockedIncrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
	InterlockedIncrement ( &m_ref ) ;
}

STDMETHODIMP_( ULONG ) CTrapEventProvider::AddRef()
{
	SetStructuredExceptionHandler seh;

	try
	{
		InterlockedIncrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
		return InterlockedIncrement ( &m_ref ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CTrapEventProvider::Release()
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;

		if ( 0 != (ret = InterlockedDecrement(&m_ref)) )
		{
			InterlockedDecrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
			return ret;
		}

		delete this;
		InterlockedDecrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP CTrapEventProvider::QueryInterface(REFIID riid, PVOID* ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		*ppv = NULL;

		if (IID_IUnknown == riid)
		{
			*ppv= (IWbemEventProvider*)this;
		}
		else if (IID_IWbemEventProvider == riid)
		{
			*ppv=(IWbemEventProvider*)this;
		}
		else if (IID_IWbemProviderInit == riid)
		{
			*ppv=(IWbemProviderInit*)this;
		}

		if (NULL==*ppv)
		{
			return E_NOINTERFACE;
		}

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();	
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\evtreft.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>

#include <smir.h>
#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>
#include <evtreft.h>

extern CEventProviderWorkerThread* g_pWorkerThread ;

CReferentMapper::CReferentMapper()
{
}


CReferentMapper::~CReferentMapper()
{
}

HRESULT CReferentMapper::GetTypeAndIndexQuals(const wchar_t* prop, CIMTypeStruct& type, ULONG& index)
{
	IWbemClassObject* propObj = NULL;
	GetClassInstance(&propObj);

	if (NULL == propObj)
	{
		return WBEM_E_FAILED;
	}

	IWbemQualifierSet* pQuals = NULL;
	HRESULT result = propObj->GetPropertyQualifierSet((wchar_t*)prop, &pQuals);

	if (FAILED(result))
	{
		return result;
	}

	VARIANT v;
	result = pQuals->Get(EVENT_VBINDEX_QUAL, 0, &v, NULL);

	if (FAILED(result))
	{
		pQuals->Release();
		return result;
	}

	if (VT_I4 != v.vt)
	{
		VariantClear(&v);
		return WBEM_E_FAILED;
	}

	index = v.lVal;
	VariantClear(&v);
	result = pQuals->Get(EVENT_CIMTYPE_QUAL, 0, &v, NULL);
	pQuals->Release();

	if (FAILED(result))
	{
		return result;
	}

	if (VT_BSTR != v.vt)
	{
		VariantClear(&v);
		return WBEM_E_FAILED;
	}

#ifdef WHITESPACE_IN_CIMTYPE
	//Get rid of whitespace...
	CString cimtype;
	wchar_t* tmp = wcstok(v.bstrVal, WHITE_SPACE_CHARS);

	while (NULL != tmp)
	{
		cimtype += tmp;
		tmp = wcstok(NULL, WHITE_SPACE_CHARS);
	}
#else //WHITESPACE_IN_CIMTYPE
	CString cimtype = v.bstrVal;
#endif //WHITESPACE_IN_CIMTYPE

	VariantClear(&v);

	//determine if we're an object. If so get the classname...
	CString temp = cimtype.Left(OBJECT_STR_LEN);
	temp.MakeLower();

	if (temp == OBJECT_STR)
	{
		type.strType = cimtype.Mid(OBJECT_STR_LEN, cimtype.GetLength());
		type.fObject = TRUE;
	}
	else
	{
		type.fObject = FALSE;
	}

	return WBEM_NO_ERROR;
}

HRESULT CReferentMapper::GetSpecificPropertyValue(long lNumElements, MYWBEM_NAME_ELEMENT *aElements,
											long lFlags, VARIANT *pvValue)
{
	if ((lNumElements <= 0) || (NULL == aElements) || (NULL == pvValue))
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue invalid parms\r\n");
)

		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT status = WBEM_E_FAILED;

	//specific properties after first two varbinds
	if ((0 == aElements[0].m_nType) && (m_vbs.length > 2))
	{
		//first check it has the correct VBIndex and CIMType qualifiers...
		CIMTypeStruct proptype;
		ULONG propvbindex;

		if (FAILED(GetTypeAndIndexQuals(aElements[0].Element.m_wszPropertyName,
																	proptype, propvbindex)))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue failed to get index quals\r\n");
)
			return status;
		}

		if (propvbindex >= m_vbs.length)
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue invalid index return TRUE\r\n");
)
			return WBEM_NO_ERROR;
		}

		//we're zero indexed in this world!
		propvbindex--;

		if (lNumElements == 1)
		{
			if (m_vbs.vbs[propvbindex].fDone)
			{
				//we've done this one already,
				//just get the property value and return it...
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue return value\r\n");
)
				return m_object->Get(aElements[0].Element.m_wszPropertyName, 0, pvValue, 0, 0);
			}

			if (proptype.fObject)
			{
				//get the embedded class object in full for the property asked for
				IWbemClassObject* pObj = NULL;
				if (SUCCEEDED(CreateEmbeddedProperty(&pObj, propvbindex,
								aElements[0].Element.m_wszPropertyName, proptype.strType)))
				{
					//created the property, set the variant value and return successfully
					//NOTE: as soon as the variant is cleared, the object will be released
					pvValue->vt = VT_UNKNOWN;
					pvValue->punkVal = pObj;
				}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue return value\r\n");
)
				return WBEM_NO_ERROR;
			}
			else
			{
				//MUST be an embedded property otherwise fail!
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue invlaid params\r\n");
)
				return WBEM_E_FAILED;
			}
		}
#ifdef FILTERING

will not compile as there are still a couple of TO DOs left undone...

		else if (0 == aElements[1].m_nType)
		{
			if (lNumElements == 2)
			{
//TO DO:
//======
				//get a single property value of the embedded object
			}
			else if ((lNumElements == 3) && (1 == aElements[1].m_nType))
			{
//TO DO:
//======
				//only if we're an array property of the embedded object
			}
		}
#endif //FILTERING

	}

	return status;
}


HRESULT CReferentMapper::CreateEmbeddedProperty(IWbemClassObject** ppObj,
											ULONG index,
											const wchar_t* propertyName,
											const wchar_t* className)
{
	if (NULL == ppObj)
	{
		//invalid out parameter
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::CreateEmbeddedProperty invalid parameter\r\n");
)
		return WBEM_E_INVALID_PARAMETER;
	}

	IWbemClassObject* pClass = NULL;

	//specify no correlation to the class provider
	IWbemContext *pCtx = NULL;

	HRESULT result = CoCreateInstance(CLSID_WbemContext, NULL,
						CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
						IID_IWbemContext, (void**)&pCtx);
	
	if (SUCCEEDED(result))
	{
		VARIANT vCtx;
		VariantInit (&vCtx);
		vCtx.vt = VT_BOOL;
		vCtx.boolVal = VARIANT_FALSE;
		result = pCtx->SetValue(WBEM_CLASS_CORRELATE_CONTEXT_PROP, 0, &vCtx);
		VariantClear(&vCtx);

		if (FAILED(result))
		{
			pCtx->Release();
			pCtx = NULL;
		}
	}
	else
	{
		pCtx = NULL;
	}

	BSTR t_className = SysAllocString(className);
	result = m_nspace->GetObject(t_className, pCtx, &pClass);
	SysFreeString(t_className);

	if (pCtx != NULL)
	{
		pCtx->Release();
	}

	if (FAILED(result))
	{
		return result;
	}

	result = pClass->SpawnInstance(0, ppObj);

	if (FAILED(result))
	{
		pClass->Release();
		return result;
	}

	//set the varbind as decoded and make sure the notification instance has been created...
	IWbemClassObject* ptmpObj = NULL;
	GetClassInstance(&ptmpObj);

	if (NULL == m_object)
	{
		pClass->Release();
		return WBEM_E_FAILED;
	}

	m_vbs.vbs[index].fDone = TRUE;
	WbemSnmpClassObject snmpObj;
	WbemSnmpErrorObject errorObj;

	if (!snmpObj.Set(errorObj, pClass, FALSE))
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	snmpObj.SetIsClass(FALSE);
	snmpObj.ResetProperty () ;
	WbemSnmpProperty *snmpProp = snmpObj.NextProperty ();

	//set all properties to NULL...
	while (snmpProp != NULL)
	{
		snmpProp->SetValue(*ppObj, (SnmpValue*)NULL);
		snmpProp = snmpObj.NextProperty ();
	}

	snmpProp = snmpObj.FindProperty((wchar_t*)propertyName);

	if (NULL == snmpProp)
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	BOOL bSetKeyValue = FALSE;

	if (!snmpProp->SetValue(&(m_vbs.vbs[index].pVarBind->GetValue())))
	{
		snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
		WbemSnmpQualifier *qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

		if ( qualifier )
		{
			VARIANT tmp_V;
			VariantInit(&tmp_V);
			tmp_V.vt = VT_BOOL;
			tmp_V.boolVal = VARIANT_TRUE;
			qualifier->SetValue(tmp_V);
			VariantClear(&tmp_V);
		}
	}
	else
	{
		WbemSnmpQualifier *qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_KEY ) ;

		if ( qualifier )
		{
			VARIANT tmp_V;
			VariantInit(&tmp_V);
			
			if (qualifier->GetValue(tmp_V))
			{
				if ((VT_BOOL == tmp_V.vt) && (VARIANT_TRUE == tmp_V.boolVal))
				{
					bSetKeyValue = TRUE;
				}
			}

			VariantClear(&tmp_V);
		}
	}

	//have set the property, now set the key properties...
	//first get the instance info...
	const SnmpObjectIdentifier& id = m_vbs.vbs[index].pVarBind->GetInstance();
	IWbemQualifierSet* pQuals = NULL;
	result = pClass->GetPropertyQualifierSet((wchar_t*)propertyName, &pQuals);

	if (FAILED(result))
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	VARIANT v;
	result = pQuals->Get(OID_ATTRIBUTE, 0, &v, NULL);
	pQuals->Release();

	if ((FAILED(result)) || (VT_BSTR != v.vt))
	{
		pClass->Release();
		VariantClear(&v);
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	SnmpObjectIdentifierType propoidtype(v.bstrVal); 
	VariantClear(&v);

	if (!propoidtype.IsValid())
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	SnmpObjectIdentifier propoid(propoidtype.GetValue(), propoidtype.GetValueLength());
	SnmpObjectIdentifier* prefix = id.Cut(propoid);
	BOOL fsuccess = FALSE;
	SnmpObjectIdentifier* instinfo = new SnmpObjectIdentifier ( NULL , 0 ) ;

	if ((prefix != NULL) && (*prefix == propoid))
	{
		fsuccess = id.Suffix(propoid.GetValueLength(),*instinfo);
		
		if (instinfo->GetValue() == NULL)
		{
			fsuccess = FALSE;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
			WbemSnmpQualifier *qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

			if ( qualifier )
			{
				VARIANT tmp_V;
				VariantInit(&tmp_V);
				tmp_V.vt = VT_BOOL;
				tmp_V.boolVal = VARIANT_TRUE;
				qualifier->SetValue(tmp_V);
				VariantClear(&tmp_V);
			}
		}
	}

	if (prefix != NULL)
	{
		delete prefix;
	}

	if ( fsuccess )
	{
		if (snmpObj.IsKeyed())
		{
			snmpObj.ResetKeyProperty() ;
			
			while ( fsuccess && (snmpProp = snmpObj.NextKeyProperty()) )
			{
				//set all the key properties using the instance info...
				SnmpInstanceType *decodeValue = snmpProp->GetValue()->Copy();
				SnmpObjectIdentifier t_DecodedValue = decodeValue->Decode(*instinfo) ;
				SnmpObjectIdentifier *decodedObject = new SnmpObjectIdentifier( t_DecodedValue ) ;
				
				if (*decodeValue)
				{
					if (!snmpProp->SetValue(decodeValue))
					{
						fsuccess = FALSE;
					}
				}
				else
				{
					fsuccess = FALSE;
				}

				delete decodeValue ;
				delete instinfo ;
				instinfo = decodedObject ;
				snmpProp = snmpObj.NextKeyProperty();
			}

			if (fsuccess && instinfo->GetValueLength())
			{
				//instance info left after keys have been set
				fsuccess = FALSE;
			}
		}
		else
		{
			if ( (0 != *(instinfo->GetValue())) || (1 != instinfo->GetValueLength()) )
			{
				//invalid instance info for scalar...
				fsuccess = FALSE;
			}
		}
	}

	delete instinfo;
	pClass->Release();

	if (!fsuccess)
	{
		snmpObj.ResetKeyProperty () ;
		VARIANT tmp_V;
		VariantInit(&tmp_V);
		tmp_V.vt = VT_BOOL;
		tmp_V.boolVal = VARIANT_TRUE;

		while ( snmpProp = snmpObj.NextKeyProperty () )
		{
			WbemSnmpQualifier *qualifier = NULL ;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

			if ( qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
			{
				qualifier->SetValue(tmp_V);
			}
			else
			{
				// Problem Here
			}
		}

		if (snmpProp = snmpObj.FindProperty((wchar_t*)propertyName))
		{
			WbemSnmpQualifier *qualifier = NULL ;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

			if ( qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
			{
				qualifier->SetValue(tmp_V);
			}
			else
			{
				// Problem Here
			}
		}

		VariantClear(&tmp_V);
	}

	//check that setting the key values hasn't altered our value, it may be a key
	if ( bSetKeyValue && (snmpProp = snmpObj.FindProperty((wchar_t*)propertyName)) )
	{
		if (*(snmpProp->GetValue()->GetValueEncoding()) != m_vbs.vbs[index].pVarBind->GetValue())
		{
			//set it back to the varbind value and set the error qualifier on the property
			snmpProp->SetValue(&(m_vbs.vbs[index].pVarBind->GetValue()));

			WbemSnmpQualifier *qualifier = NULL ;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_VALUE_MISMATCH ) ;

			if ( qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_VALUE_MISMATCH ) )
			{
				VARIANT tmp_V;
				VariantInit(&tmp_V);
				tmp_V.vt = VT_BOOL;
				tmp_V.boolVal = VARIANT_TRUE;
				qualifier->SetValue(tmp_V);
				VariantClear(&tmp_V);
			}
			else
			{
				// Problem Here
			}

		}
	}

	//generate class object from snmpObj and return success
	if (snmpObj.Get(errorObj, *ppObj))
	{
		//add the property to the notification object...
		VARIANT vObj;
		vObj.vt = VT_UNKNOWN;
		vObj.punkVal = *ppObj;
		(*ppObj)->AddRef();
		result = m_object->Put((wchar_t*)propertyName, 0, &vObj, 0);

		if (SUCCEEDED(result))
		{
			VariantClear(&vObj);
DebugMacro9( 
SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
	__FILE__,__LINE__,
	L"CReferentMapper::CreateEmbeddedProperty succeeded\r\n");
)
			return WBEM_NO_ERROR;
		}
		else
		{
			VariantClear(&vObj);
			(*ppObj)->Release();
			*ppObj = NULL;
			return WBEM_E_FAILED;
		}
		
	}

	return WBEM_E_FAILED;
}


void CReferentMapper::GenerateInstance(IWbemClassObject** ppInst)
{
	if (NULL == ppInst)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance invalid parameter\r\n");
)

		//invalid out parameter
		return;
	}

	//set out parameter to NULL;
	*ppInst = NULL;
	IWbemClassObject *pObj = NULL;
	GetClassInstance(&pObj);

	if (NULL == pObj)
	{
		//failed to get class instance
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to get class defn\r\n");
)
		return;
	}

	//get all the property names and set their values...
	SAFEARRAY* pPropNames;
	HRESULT result = pObj->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &pPropNames);

	if (FAILED(result))
	{
		//failed to get the property names
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to get property array\r\n");
)
		return;
	}
	
	//time to <insert expletive> around with a safearray...
	//work out the size of the safearray and access the data
	if(SafeArrayGetDim(pPropNames) != 1)
	{
		//wrong dimensions in this array
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance property array has wrong DIM\r\n");
)
		return;
	}


	LONG arraylen = pPropNames->rgsabound[0].cElements;
	BSTR *pbstr;
	result = SafeArrayAccessData(pPropNames, (void **)&pbstr);

	if(FAILED(result))
	{
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to access property array\r\n");
)
		return;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance set properties\r\n");
)

	BOOL t_bSetProp = FALSE;

	//iterate through the names and set the properties...
	for (LONG i = 0; i < arraylen; i++)
	{
		VARIANT v;
		MYWBEM_NAME_ELEMENT property_struct;
		property_struct.m_nType = 0; //string value
		property_struct.Element.m_wszPropertyName = pbstr[i];
		result = GetPropertyValue(1, &property_struct, 0, &v);

		if (FAILED(result))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to get value for %s\r\n",
		pbstr[i]);
)
			continue;
		}
		else
		{
			t_bSetProp = TRUE;
		}
		
		if ((v.vt != VT_NULL) && (v.vt != VT_EMPTY))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance setting value for %s\r\n",
		pbstr[i]);
)
			result = pObj->Put(pbstr[i], 0, &v, 0);
DebugMacro9( 
			if (FAILED(result))
			{
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed setting value for %s\r\n",
		pbstr[i]);
			}
)
		}
		
		VariantClear(&v);
	}
	
	SafeArrayUnaccessData(pPropNames);
	SafeArrayDestroy(pPropNames);

	//if a single property has been put send it on....
	if (t_bSetProp)
	{
		pObj->AddRef();
		*ppInst = pObj;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance finished\r\n");
)
}


void CReferentMapper::ResetData()
{
	//do class specific stuff then call parent class's reset

	CMapToEvent::ResetData();
}


BOOL CReferentMapper::GetSpecificClass()
{
	//Build path of mapper instance...
	CString path(EXTMAPPER_CLASS_PATH_PREFIX);
	path += m_oid;
	path += '\"';
	BSTR pathstr = path.AllocSysString();
	IWbemClassObject *pObj = NULL;

	HRESULT result = g_pWorkerThread->GetServerWrap ()->GetMapperObject(pathstr, NULL, & pObj );

	SysFreeString(pathstr);

	if (result == S_OK)
	{
		VARIANT v;
		VariantInit(&v);
		result = pObj->Get(MAPPER_CLASS_EVENTCLASSPROP, 0, &v, NULL, NULL);
		pObj->Release();
		
		if (SUCCEEDED(result) && (VT_BSTR == v.vt))
		{
			m_class = v.bstrVal;
			VariantClear(&v);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificClass got the specific class defn\r\n");
)
			return TRUE;
		}
		else
		{
			VariantClear(&v);
		}
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificClass failed to get specific class defn\r\n");
)
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\evtmap.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>

#include <smir.h>
#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>

#include <winsock2.h>

CMapToEvent::CMapToEvent() : m_vbdefn(NULL), m_vbs(NULL, 0)
{
	m_btriedGeneric = FALSE;
	m_btryGeneric = FALSE;
	m_bCheckedVersion = FALSE;
	m_object = NULL;
	m_nspace = NULL;
}

CMapToEvent::~CMapToEvent()
{
	if (m_vbs.vbs)
	{
		delete [] m_vbs.vbs;
	}

	if (m_vbdefn)
	{
		m_vbdefn->Release();
	}
}


void CMapToEvent::ResetData()
{
	m_btriedGeneric = FALSE;
	m_btryGeneric = FALSE;
	m_bCheckedVersion = FALSE;
	m_class.Empty();

	if(m_vbs.vbs)
	{
		delete [] m_vbs.vbs;
		m_vbs.vbs = NULL;
		m_vbs.length = 0;
	}

	if (m_object)
	{
		m_object->Release();
		m_object = NULL;
	}
}


void CMapToEvent::SetTryGeneric()
{
	m_btriedGeneric = TRUE;
	m_btryGeneric = TRUE;
}

BOOL CMapToEvent::IsSNMPv1()
{
	if (!m_bCheckedVersion)
	{
		m_bCheckedVersion = TRUE;
		m_bSNMPv1 = FALSE;

		//is v1 if the last varbind has objid = snmpTrapEnterprise.0
		//and the trapOID truncated by it last sub-id equals the last
		//varbind's value with a .0 appended.

		//Get the last varbind's oid and make sure it's the enterpriseOid
		const SnmpObjectIdentifier& id = m_vbs.vbs[m_vbs.length - 1].pVarBind->GetInstance();
		const SnmpValue& snmp_val = m_vbs.vbs[m_vbs.length - 1].pVarBind->GetValue();

		if ((id != SNMP_ENT_OID) || (typeid(SnmpObjectIdentifier) != typeid(snmp_val)))
		{
			return FALSE;
		}

		//create the trapoid and truncate the last subid
		SnmpObjectIdentifierType trapid(m_oid);
		SnmpObjectIdentifier trunctrapid(trapid.GetValue(), trapid.GetValueLength() - 1);
		
		//now add .0 to the value of the enterpriseOid
		ULONG val[1] = {0};
		SnmpObjectIdentifier zeroid(val, 1);
		SnmpObjectIdentifier extendoid((const SnmpObjectIdentifier&)snmp_val + zeroid);

		m_bSNMPv1 = (extendoid == trunctrapid);
	}

	return m_bSNMPv1;
}

void CMapToEvent::SetData(const char* sender_addr, const char* security_Context,
					const char* snmpTrapOid, const char* transport,
					SnmpVarBindList& vbList, CWbemServerWrap* nspace)
{
	m_nspace = nspace;
	m_addr = sender_addr;
	m_ctxt = security_Context;
	m_oid = snmpTrapOid;
	m_transport = transport;
	UINT length = vbList.GetLength();

	if (length >= 2) //must have at least two varbinds!
	{
		m_vbs.vbs = new VarBindObjectStruct[length];
		m_vbs.length = length;
		vbList.Reset();
		
		for (UINT i=0; i < length; i++)
		{
			vbList.Next () ;
			m_vbs.vbs[i].fDone = FALSE;
			m_vbs.vbs[i].pVarBind = (SnmpVarBind*) vbList.Get();
		}
	}
	else
	{
		m_vbs.vbs = NULL;
		m_vbs.length = 0;
	}
}

void CMapToEvent::GetClassInstance(IWbemClassObject **ppObj)
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClassInstance getting class object\r\n");
)

	if (m_object != NULL)
	{
		*ppObj = m_object;
		return;
	}

	if (m_class.IsEmpty())
	{
		if (!GetClass() || m_class.IsEmpty())
		{
			*ppObj = NULL;
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClassInstance failed to get class name\r\n");
)
			return;
		}
	}
	
	BSTR path = m_class.AllocSysString();

	if (SUCCEEDED(m_nspace->GetObject(path, NULL, ppObj )))
	{
		if (FAILED((*ppObj)->SpawnInstance(0, &m_object)))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClassInstance failed to spawn instance\r\n");
)
			m_object = NULL;
		}
		else
		{
DebugMacro9(
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
			L"CMapToEvent::GetClassInstance got instance\r\n");
)		
		}

		(*ppObj)->Release();
	}
	else
	{
DebugMacro9(
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
			L"CMapToEvent::GetClassInstance failed to get class definition\r\n");
)		
	}

	SysFreeString(path);
	*ppObj = m_object;
}

HRESULT CMapToEvent::GetPropertyValue(long lNumElements, MYWBEM_NAME_ELEMENT *aElements,
											long lFlags, VARIANT *pvValue)
{
	VariantInit(pvValue);

	if ((lNumElements == 0) || (NULL == aElements) || (NULL == pvValue) || (pvValue->vt != VT_EMPTY))
	{
		return E_INVALIDARG;
	}

	if (m_vbs.length == 0)
	{
		return WBEM_E_FAILED;
	}

	//try the standard properties first
	HRESULT result = GetStandardProperty(lNumElements, aElements, lFlags, pvValue);

	if (SUCCEEDED(result))
	{
		return result;
	}

	if (m_class.IsEmpty())
	{
		if (!GetClass() || m_class.IsEmpty())
		{
			return WBEM_E_FAILED;
		}
	}

	if (TriedGeneric())
	{
		//if we are generic, check the varbind properties
		return GetVBProperty(lNumElements, aElements, lFlags, pvValue);
	}
	else
	{
		//else check the specific properties...
		return GetSpecificPropertyValue(lNumElements, aElements, lFlags, pvValue);
	}
	
	return WBEM_E_FAILED;
}


HRESULT CMapToEvent::GetStandardProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue)
{
	if ((lNumElements == 1) && (0 == aElements[0].m_nType)) //the property name!
	{
		if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, WBEMS_CLASS_PROP))
		{
			if (m_class.IsEmpty())
			{
				if (!GetClass() || m_class.IsEmpty())
				{
					return E_FAIL;
				}
			}
			
			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_class.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_SOID_PROP))
		{
			if (m_oid.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_oid.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_ADDR_PROP))
		{
			if (m_addr.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_addr.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_TADDR_PROP))
		{
			if (m_addr.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_addr.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_TRANS_PROP))
		{
			if (m_transport.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_transport.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_COMM_PROP))
		{
			if (m_ctxt.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_ctxt.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_TIME_PROP))
		{
			const SnmpObjectIdentifier& id = m_vbs.vbs[0].pVarBind->GetInstance();

			if (id != SNMP_SYS_UP_OID)
			{
				return E_FAIL;
			}

			const SnmpValue& val = m_vbs.vbs[0].pVarBind->GetValue();

			if (typeid(SnmpTimeTicks) == typeid(val))
			{
				pvValue->vt = VT_I4;
				pvValue->lVal = ((const SnmpTimeTicks&)val).GetValue();
			}
			else
			{
				return E_FAIL;
			}
		}
		else
		{
			return E_FAIL;
		}
	}
	else
	{
		return E_FAIL; //no standard property has more than one element to its name
	}
				
	return S_OK; //got the property!
}

HRESULT CMapToEvent::GetVBProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue)
{
	if ((lNumElements <= 0) || (NULL == aElements) || (NULL == pvValue))
	{
		return E_INVALIDARG;
	}

	HRESULT status = E_FAIL;

	if ((0 == aElements[0].m_nType) && (m_vbs.length > 2) &&
		(0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_VBL_PROP)) ) 
	{
		//the property name is correct...

		if (lNumElements == 1)
		{
			//all the varbinds except 1 and 2...
			//create the classobjects stick 'em in a safearray and send 'em back!
			SAFEARRAYBOUND rgsabound[1];
			SAFEARRAY* psa;
			rgsabound[0].lLbound = 0;
			rgsabound[0].cElements = m_vbs.length - 2;
			psa = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
			LONG ix;
			BOOL berror = FALSE;

			for (UINT i = 2; i < m_vbs.length; i++)
			{
				IWbemClassObject* vbobj = GetVBClassObjectByIndex(i);

				if (NULL != vbobj)
				{
					 ix = i-2;

					if ( S_OK != SafeArrayPutElement(psa, &ix, (IUnknown *)vbobj))
					{
						vbobj->Release ();
						berror = TRUE;
						break;
					}

					vbobj->Release ();
				}
				else
				{
					berror = TRUE;
					break;
				}
			}

			if (berror)
			{
				SafeArrayDestroy(psa);
			}
			else
			{
				status = WBEM_NO_ERROR;
				pvValue->vt = VT_ARRAY | VT_UNKNOWN;
				pvValue->parray = psa;
			}
		}
		else if ((1 == aElements[1].m_nType) && (m_vbs.length  > (aElements[1].Element.m_lArrayIndex + 2)))
		{
			if (lNumElements == 2)
			{
				//get the n(= aElements[1].Element.m_lArrayIndex + 2)th varbind
				//create a classobject with it and send back the class object
				IWbemClassObject* vbobj = GetVBClassObjectByIndex(aElements[1].Element.m_lArrayIndex + 2);
				
				if (NULL != vbobj)
				{
					status = WBEM_NO_ERROR;
					pvValue->vt = VT_UNKNOWN;
					pvValue->punkVal = (IUnknown*) vbobj;
				}
			}
			else if (0 == aElements[2].m_nType)
			{
				if (lNumElements == 3)
				{
					//get the single property value
					int cmpval = _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_OBJID_PROP2);

					if (0 == cmpval)
					{
						//get the objectid
						if (GetVBPropOIDByIndex((aElements[1].Element.m_lArrayIndex + 2), *pvValue))
						{
							status = WBEM_NO_ERROR;
						}

					}
					else if ((cmpval > 0) &&
						(0 == _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_ENCODING_PROP1)))
					{
						//get the ASNType (Encoding < ObjectIdentifier)
						CString t;

						if (GetVBPropValueByIndex((aElements[1].Element.m_lArrayIndex + 2), t, *pvValue))
						{
							VariantClear(pvValue);
							status = WBEM_NO_ERROR;
							pvValue->vt = VT_BSTR;
							pvValue->bstrVal = t.AllocSysString();
						}
					}
					else if (0 == _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_VALUE_PROP3))
					{
						//get the Value (Value < ObjectID)
						CString t;

						if (GetVBPropValueByIndex((aElements[1].Element.m_lArrayIndex + 2), t, *pvValue))
						{
							status = WBEM_NO_ERROR;
						}
					}
				}
				else if ((lNumElements == 4) && (1 == aElements[3].m_nType) &&
					(0 == _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_VALUE_PROP3)) )
				{
					//get the byte value of Value[x]
					CString t;
					VARIANT v;

					if (GetVBPropValueByIndex((aElements[1].Element.m_lArrayIndex + 2), t, v))
					{
						if ((VT_ARRAY | VT_UI1) == v.vt)
						{
							LONG ix = aElements[3].Element.m_lArrayIndex;
							UCHAR datum;

							if (S_OK == SafeArrayGetElement(v.parray, &ix, (void*)&datum))
							{
								status = WBEM_NO_ERROR;
								pvValue->vt = VT_UI1;
								pvValue->bVal = datum;
							}
						}

						VariantClear(&v);
					}
				}
			}
		}
	}

	return status;
}

IWbemClassObject* CMapToEvent::GetVBClassDefn()
{
	if (NULL == m_vbdefn)
	{
		BSTR path = SysAllocString(VB_CLASS_PATH);
		m_nspace->GetObject(path, NULL, &m_vbdefn ) ;
		SysFreeString(path);
	}

	return m_vbdefn;
}

IWbemClassObject* CMapToEvent::GetVBClassObjectByIndex(UINT index)
{
	IWbemClassObject* ret = NULL;

	if (NULL != GetVBClassDefn())
	{
		if (SUCCEEDED(m_vbdefn->SpawnInstance(0, &ret)))
		{
			CString type;
			VARIANT vV;

			if (GetVBPropValueByIndex(index, type, vV))
			{
				BSTR asntypeprop = SysAllocString(VB_ENCODING_PROP1);
				VARIANT vT;
				vT.vt = VT_BSTR;
				vT.bstrVal = type.AllocSysString();

				//set the type and value.
				if (SUCCEEDED(ret->Put(asntypeprop, 0, &vT, 0)))
				{
					BSTR valueprop = SysAllocString(VB_VALUE_PROP3);
					VARIANT* pV = &vV;
					VARTYPE Vtype = 0;

					if ((VT_EMPTY == vV.vt) || (VT_EMPTY == vV.vt))
					{
						Vtype = VT_ARRAY|VT_UI1; //default type
						pV = NULL;
					}

					if (SUCCEEDED(ret->Put(valueprop, 0, pV, Vtype)))
					{
						VARIANT vID;

						//get the oid
						if(GetVBPropOIDByIndex(index, vID))
						{
							BSTR oidprop = SysAllocString(VB_OBJID_PROP2);

							//set the oid
							if (FAILED(ret->Put(oidprop, 0, &vID, 0)))
							{
								ret->Release();
								ret = NULL;
							}

							SysFreeString(oidprop);
							VariantClear(&vID);
						}
						else
						{
							ret->Release();
							ret = NULL;
						}
					}
					else
					{
						ret->Release();
						ret = NULL;
					}
					
					SysFreeString(valueprop);
				}
				else //failed to put the type property
				{
					ret->Release();
					ret = NULL;
				}

				VariantClear(&vT);
				SysFreeString(asntypeprop);
				VariantClear(&vV);
			}
			else //failed to SpawnInstance
			{
				ret->Release();
				ret = NULL;
			}
		}
	}

	return ret;
}


//index assumed to be in valid range
BOOL CMapToEvent::GetVBPropValueByIndex(UINT index, CString& type, VARIANT& vval)
{
	const SnmpValue& val = m_vbs.vbs[index].pVarBind->GetValue();
	
	//the data is an array of bytes...
	SAFEARRAYBOUND rgsabound[1];
	SAFEARRAY* psa;
	rgsabound[0].lLbound = 0;
	VariantInit(&vval);

	if (typeid(SnmpNull) == typeid(val))
	{
		type = ASN_NULL;
	}
	else if (typeid(SnmpNoSuchObject) == typeid(val))
	{
		type = ASN_NSO;
	}
	else if (typeid(SnmpNoSuchInstance) == typeid(val))
	{
		type = ASN_NSI;
	}
	else if (typeid(SnmpEndOfMibView) == typeid(val))
	{
		type = ASN_EOMV;
	}
	else if (typeid(SnmpInteger) == typeid(val))
	{
		type = ASN_INTEGER;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpInteger&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpGauge) == typeid(val))
	{
		type = ASN_GUAGE;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpGauge&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpCounter) == typeid(val))
	{
		type = ASN_COUNTER;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpCounter&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpTimeTicks) == typeid(val))
	{
		type = ASN_TIME;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpTimeTicks&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpOctetString) == typeid(val))
	{
		type = ASN_OCTET;
		UCHAR* pdata;
		UINT datalen = (((const SnmpOctetString&)val).GetValueLength()) * sizeof(UCHAR);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UCHAR* data = ((const SnmpOctetString&)val).GetValue();
		memcpy((void *)pdata, (void *)data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpOpaque) == typeid(val))
	{
		type = ASN_OPAQUE;
		UCHAR* pdata;
		UINT datalen = (((const SnmpOpaque&)val).GetValueLength()) * sizeof(UCHAR);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UCHAR* data = ((const SnmpOpaque&)val).GetValue();
		memcpy((void *)pdata, (void *)data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpObjectIdentifier) == typeid(val))
	{
		type = ASN_OID;
		UCHAR* pdata;
		UINT datalen = (((const SnmpObjectIdentifier&)val).GetValueLength()) * sizeof(ULONG);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		ULONG* data = ((const SnmpObjectIdentifier&)val).GetValue();
		memcpy((void *)pdata, (void *)data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpIpAddress) == typeid(val))
	{
		type = ASN_ADDR;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = htonl(((const SnmpIpAddress&)val).GetValue());
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpUInteger32) == typeid(val))
	{
		type = ASN_UINT32;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpUInteger32&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpCounter64) == typeid(val))
	{
		type = ASN_COUNTER64;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = (datalen * 2);
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpCounter64&)val).GetHighValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		pdata += datalen;
		data = ((const SnmpCounter64&)val).GetLowValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else
	{
		//should not get here!
		return FALSE;
	}

	return TRUE;
}


//index assumed to be in valid range
BOOL CMapToEvent::GetVBPropOIDByIndex(UINT index, VARIANT& vOid)
{
	const SnmpObjectIdentifier& id = m_vbs.vbs[index].pVarBind->GetInstance();
	char * oid = id.GetAllocatedString();

	if (NULL != oid)
	{
		VariantInit(&vOid);
		CString oidstr(oid);
		delete [] oid;
		vOid.vt = VT_BSTR;
		vOid.bstrVal = oidstr.AllocSysString();
		return TRUE;
	}

	return FALSE;
}


//sets the m_class variable. if btryGeneric is set gets the generic class.
//if m_btryGeneric is not set and a generic class is returned m_btriedGeneric
//must be set to true.
BOOL CMapToEvent::GetClass()
{
	if (!m_btryGeneric)
	{
		if (GetSpecificClass())
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClass got specific class\r\n");
)
			return TRUE;
		}
	}

	SetTryGeneric();

	if (IsSNMPv1())
	{
		m_class = GetV1Class();
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClass getting V1 class\r\n");
)
	}
	else
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClass getting V2 class\r\n");
)
		m_class = GetV2Class();
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\evtthrd.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <cominit.h>

#include <smir.h>
#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>
#include <evtencap.h>
#include <evtreft.h>

extern CEventProviderWorkerThread *g_pWorkerThread ;
extern CRITICAL_SECTION g_CacheCriticalSection;

CTrapListener::CTrapListener(CEventProviderThread* parentptr)
{
	m_pParent = parentptr;
	m_Ref = 1;
}


void CTrapListener::Destroy()
{
	if (InterlockedDecrement(&m_Ref) == 0)
	{
		DestroyReceiver();
	}
}


void CTrapListener::Receive (SnmpTransportAddress &sender_addr,
							SnmpSecurity &security_context,
							SnmpVarBindList &vbList)
{
	InterlockedIncrement(&m_Ref);
	MySnmpV1Security context((const SnmpV1Security&)security_context);
	const char *security = context.GetName();
	const char *addr = sender_addr.GetAddress();

	if ((NULL == security) || (NULL == addr))
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive invalid community or address\r\n");
)
		return;
	}

	const char *transport = NULL;

	if(typeid(SnmpTransportIpAddress) == typeid(sender_addr))
	{
		transport = "IP";
	}
	else if(typeid(SnmpTransportIpxAddress) == typeid(sender_addr))
	{
		transport = "IPX";
	}
	else
	{
		transport = "UNKNOWN";
	}

	char *oid = NULL;

	// reset the list
	vbList.Reset();
	UINT x = 0;

	// Get the SnmpTrapOid call process trap.
	vbList.Next(); //the timestamp
	vbList.Next(); //the snmpTrapOID
	const SnmpVarBind *var_bind = vbList.Get();
	const SnmpObjectIdentifier &id = var_bind->GetInstance();

	if (id != SNMP_TRAP_OID)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive invalid trap oid varbind\r\n");
)
		return;
	}

	const SnmpValue &val = var_bind->GetValue();

	if(typeid(SnmpObjectIdentifier) == typeid(val))
	{
		oid = ((const SnmpObjectIdentifier&)val).GetAllocatedString();
	}

	if (NULL == oid)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive invalid oid\r\n");
)
		return;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive trap to process\r\n");
)
	m_pParent->ProcessTrap(addr, security, oid, transport, vbList);
	delete [] oid;
	Destroy();
}

void CEventProviderThread::UnRegister(CTrapEventProvider* prov)
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderThread::UnRegister\r\n");
)

	if (m_ControlObjects.Lock())
	{
		if (m_ControlObjects.RemoveKey((UINT_PTR)prov) 
			&& m_ControlObjects.IsEmpty() && (NULL != m_Ear))
		{
			m_Ear->Destroy();
			m_Ear = NULL;
		}
		
		m_ControlObjects.Unlock();
	}
}

BOOL CEventProviderThread::Register(CTrapEventProvider* prov)
{
	if (m_ControlObjects.Lock())
	{
		m_ControlObjects.SetAt((UINT_PTR)prov, prov);
		m_ControlObjects.Unlock();

		if (NULL == m_Ear)
		{
			m_Ear = new CTrapListener(this);
		}
	
		if (m_Ear->IsRegistered())
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderThread::Register returning TRUE\r\n");
)
			return TRUE;
		}
		else
		{
			delete m_Ear;
			m_Ear = NULL;
		}
	}

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderThread::Register returning FALSE\r\n");
)
	
	return FALSE;
}

void CEventProviderThread::ProcessTrap(const char *sender_addr, const char *security_Context,
										const char *snmpTrapOid, const char *trnsp,
										SnmpVarBindList &vbList)
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"Entering CEventProviderThread::ProcessTrap\r\n");
)

	CList<CTrapEventProvider *, CTrapEventProvider *> controlObjects;

	if (m_ControlObjects.Lock())
	{
		POSITION pos = m_ControlObjects.GetStartPosition();

		while (NULL != pos)
		{
			CTrapEventProvider *pCntrl;
			UINT key;
			m_ControlObjects.GetNextAssoc(pos, key, pCntrl);
			pCntrl->AddRefAll();
			controlObjects.AddTail(pCntrl);
		}

		m_ControlObjects.Unlock();
	}
	else
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderThread::ProcessTrap Failed to lock Control objects\r\n");
)

		return;
	}

	//loop through the different control objects to see if an event class
	//should be sent. if yes, then generate the event class. if generating
	//the specific class fails try the generic case. 

	CTrapData TrapData (sender_addr,  security_Context, snmpTrapOid, trnsp, vbList);

	while (!controlObjects.IsEmpty())
	{
		CTrapEventProvider *pCntrl = controlObjects.RemoveTail();
		CTrapProcessTaskObject asyncTrapTask ( & TrapData, pCntrl);
		asyncTrapTask.Process();

		pCntrl->ReleaseAll();
	}

DebugMacro9(
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderThread::ProcessTrap done!\r\n");
)

}


CTrapData::CTrapData (

	const char *sender_addr,
	const char *security_Context,
	const char *snmpTrapOid,
	const char *trnsp,
	SnmpVarBindList &vbList

) : m_variable_bindings(vbList),
	m_Ref(0),
	m_sender_addr(NULL),
	m_security_context(NULL),
	m_trap_oid(NULL),
	m_transport(NULL)
{
	if (sender_addr)
	{
		int t_sender_len = strlen(sender_addr) + 1 ;
		if ( t_sender_len > 32 )
		{
			m_sender_addr = new char[strlen(sender_addr) + 1];
			strcpy(m_sender_addr, sender_addr);
		}
		else
		{
			m_sender_addr = NULL ;
			strcpy(m_static_sender_addr, sender_addr);
		}
	}

	if (security_Context)
	{
		int t_security_Context_len = strlen(security_Context) + 1 ;
		if ( t_security_Context_len > 32 )
		{
			m_security_context = new char[strlen(security_Context) + 1];
			strcpy(m_security_context, security_Context);
		}
		else
		{
			m_security_context = NULL ;
			strcpy(m_static_security_context, security_Context);
		}
	}

	if (snmpTrapOid)
	{
		int t_trap_oid_len = strlen(snmpTrapOid) + 1 ;
		if ( t_trap_oid_len > 32 )
		{
			m_trap_oid = new char[strlen(snmpTrapOid) + 1];
			strcpy(m_trap_oid, snmpTrapOid);
		}
		else
		{
			m_trap_oid = NULL ;
			strcpy(m_static_trap_oid, snmpTrapOid);
		}
	}

	if (trnsp)
	{
		int t_trnsp_len = strlen(trnsp) + 1 ;
		if ( t_trnsp_len > 32 )
		{
			m_transport = new char[strlen(trnsp) + 1];
			strcpy(m_transport, trnsp);
		}
		else
		{
			m_transport = NULL ;
			strcpy(m_static_transport, trnsp);
		}
	}
}

CTrapData::~CTrapData()
{
	if (m_sender_addr)
	{
		delete [] m_sender_addr;
	}

	if (m_security_context)
	{
		delete [] m_security_context;
	}

	if (m_trap_oid)
	{
		delete [] m_trap_oid;
	}

	if (m_transport)
	{
		delete [] m_transport;
	}
}

LONG CTrapData::AddRef()
{
	return InterlockedIncrement ( &m_Ref ) ;
}

LONG CTrapData::Release()
{
	long ret;

    if ( 0 != (ret = InterlockedDecrement(&m_Ref)) )
	{
        return ret;
	}

	delete this;
	return 0;
}

CTrapProcessTaskObject::CTrapProcessTaskObject (CTrapData *pTData, CTrapEventProvider* pCntrl) : m_Cntrl (NULL)
{
	if (pCntrl)
	{
		m_Cntrl = pCntrl;
		m_Cntrl->AddRefAll();
	}

	if (pTData)
	{
		m_trap_data = pTData;
	}
	else
	{
		m_trap_data = NULL;
	}
}

CTrapProcessTaskObject::~CTrapProcessTaskObject()
{
	if (m_Cntrl)
	{
		m_Cntrl->ReleaseAll();
	}

}

void CTrapProcessTaskObject::Process()
{
	if (m_Cntrl->m_MapType == CMapToEvent::EMappingType::ENCAPSULATED_MAPPER)
	{
		ProcessEncapsulated () ;
	}
	else //must be referent
	{
		ProcessReferent () ;
	}
}

void CTrapProcessTaskObject::ProcessReferent ()
{
	CWbemServerWrap *ns = m_Cntrl->GetNamespace();
	IWbemObjectSink *es = m_Cntrl->GetEventSink();

	CReferentMapper mapper ;

	mapper.SetData (
		
		m_trap_data->m_sender_addr ? m_trap_data->m_sender_addr : m_trap_data->m_static_sender_addr , 
		m_trap_data->m_security_context ? m_trap_data->m_security_context : m_trap_data->m_static_security_context ,
		m_trap_data->m_trap_oid ? m_trap_data->m_trap_oid : m_trap_data->m_static_trap_oid , 
		m_trap_data->m_transport ? m_trap_data->m_transport : m_trap_data->m_static_transport ,
		m_trap_data->m_variable_bindings, 
		ns
	);

#ifdef FILTERING
		//is the specific filter set?
	if (SUCCEEDED(es->CheckObject(mapper, NULL, NULL)))
#endif //FILTERING

	{
		IWbemClassObject *Evt = NULL;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating specific instance\r\n");
)
		mapper.GenerateInstance(&Evt);

		//only indicate if specific worked
		if (Evt != NULL) 
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process indicating specific instance\r\n");
)
			es->Indicate(1, &Evt);
			Evt->Release();
		}
		else if (!mapper.TriedGeneric()) //have we tried the generic filter
		{
			mapper.ResetData();
			mapper.SetTryGeneric();

			mapper.SetData (
				
				m_trap_data->m_sender_addr ? m_trap_data->m_sender_addr : m_trap_data->m_static_sender_addr , 
				m_trap_data->m_security_context ? m_trap_data->m_security_context : m_trap_data->m_static_security_context ,
				m_trap_data->m_trap_oid ? m_trap_data->m_trap_oid : m_trap_data->m_static_trap_oid , 
				m_trap_data->m_transport ? m_trap_data->m_transport : m_trap_data->m_static_transport ,
				m_trap_data->m_variable_bindings, 
				ns
			);

			//is the generic filter set?
#ifdef FILTERING
			if (SUCCEEDED(es->CheckObject(m_Map, NULL, NULL)))
#endif //FILTERING
			{
				IWbemClassObject *stdEvt = NULL;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating general instance\r\n");
)
				mapper.GenerateInstance(&stdEvt);
				
				//if we generated the class indicate
				if (NULL != stdEvt)
				{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process indicating general instance\r\n");
)
					es->Indicate(1, &stdEvt);
					stdEvt->Release();
				}
				else
				{
DebugMacro9(
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating generic instance failed\r\n");
)
				}
			}
		}
		else
		{
			//the specific case was the generic case
		}
	}
	
	mapper.ResetData();

	es->Release();
	ns->Release();
}

void CTrapProcessTaskObject::ProcessEncapsulated ()
{
	CWbemServerWrap *ns = m_Cntrl->GetNamespace();
	IWbemObjectSink *es = m_Cntrl->GetEventSink();

	CEncapMapper mapper ;

	mapper.SetData (
		
		m_trap_data->m_sender_addr ? m_trap_data->m_sender_addr : m_trap_data->m_static_sender_addr , 
		m_trap_data->m_security_context ? m_trap_data->m_security_context : m_trap_data->m_static_security_context ,
		m_trap_data->m_trap_oid ? m_trap_data->m_trap_oid : m_trap_data->m_static_trap_oid , 
		m_trap_data->m_transport ? m_trap_data->m_transport : m_trap_data->m_static_transport ,
		m_trap_data->m_variable_bindings, 
		ns
	);

#ifdef FILTERING
		//is the specific filter set?
	if (SUCCEEDED(es->CheckObject(mapper, NULL, NULL)))
#endif //FILTERING

	{
		IWbemClassObject *Evt = NULL;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating specific instance\r\n");
)
		mapper.GenerateInstance(&Evt);

		//only indicate if specific worked
		if (Evt != NULL) 
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process indicating specific instance\r\n");
)
			es->Indicate(1, &Evt);
			Evt->Release();
		}
		else if (!mapper.TriedGeneric()) //have we tried the generic filter
		{
			mapper.ResetData();
			mapper.SetTryGeneric();

			mapper.SetData (
				
				m_trap_data->m_sender_addr ? m_trap_data->m_sender_addr : m_trap_data->m_static_sender_addr , 
				m_trap_data->m_security_context ? m_trap_data->m_security_context : m_trap_data->m_static_security_context ,
				m_trap_data->m_trap_oid ? m_trap_data->m_trap_oid : m_trap_data->m_static_trap_oid , 
				m_trap_data->m_transport ? m_trap_data->m_transport : m_trap_data->m_static_transport ,
				m_trap_data->m_variable_bindings, 
				ns
			);

			//is the generic filter set?
#ifdef FILTERING
			if (SUCCEEDED(es->CheckObject(m_Map, NULL, NULL)))
#endif //FILTERING
			{
				IWbemClassObject* stdEvt = NULL;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating general instance\r\n");
)
				mapper.GenerateInstance(&stdEvt);
				
				//if we generated the class indicate
				if (NULL != stdEvt)
				{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process indicating general instance\r\n");
)
					es->Indicate(1, &stdEvt);
					stdEvt->Release();
				}
				else
				{
DebugMacro9(
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating generic instance failed\r\n");
)
				}
			}
		}
		else
		{
			//the specific case was the generic case
		}
	}
	
	mapper.ResetData();

	es->Release();
	ns->Release();
}

TimerRegistryTaskObject :: TimerRegistryTaskObject (CEventProviderWorkerThread *parent) : m_LogKey ( NULL )
{
	m_parent = parent;
	ReadRegistry();
}

TimerRegistryTaskObject :: ~TimerRegistryTaskObject ()
{
	if ( m_LogKey )
		RegCloseKey ( m_LogKey ) ;
}

void TimerRegistryTaskObject :: Process ()
{
	ReadRegistry();
	SetRegistryNotification () ;
}

void TimerRegistryTaskObject :: ReadRegistry ()
{
	if (m_LogKey == NULL)
	{
		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			THREAD_REG_KEY, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&m_LogKey, 
			NULL
		) ;

		if ( t_Status != ERROR_SUCCESS )
		{
			return;
		}
	}

	DWORD t_Count = 0;
	BOOL bWrite = TRUE;
	DWORD t_ValueType = REG_DWORD ;
	DWORD t_ValueLength = sizeof ( DWORD ) ;
	LONG t_Status = RegQueryValueEx ( 

		m_LogKey , 
		THREAD_MARKS_VAL , 
		0, 
		&t_ValueType ,
		( LPBYTE ) &t_Count , 
		&t_ValueLength 
	) ;

	if (t_Status == ERROR_SUCCESS)
	{
		if (t_Count == 0)
		{
			t_Count = 1;
		}
		else if (t_Count > THREAD_MARKS_MAX)
		{
			t_Count = THREAD_MARKS_MAX;
		}
		else
		{
			t_Count  = t_Count;
			bWrite = FALSE;
		}
	}
	else
	{
		t_Count = THREAD_MARKS_DEF;
	}

	if (bWrite)
	{
		t_ValueType = REG_DWORD ;

		RegSetValueEx ( 

			m_LogKey , 
			THREAD_MARKS_VAL , 
			0, 
			t_ValueType ,
			( LPBYTE ) &t_Count , 
			t_ValueLength 
		) ;
	}

	m_parent->SetMaxMarks(t_Count);
}

void TimerRegistryTaskObject :: SetRegistryNotification ()
{
	if ( m_LogKey )
		RegCloseKey ( m_LogKey ) ;

	LONG t_Status = RegCreateKeyEx (
	
		HKEY_LOCAL_MACHINE, 
		THREAD_REG_KEY, 
		0, 
		NULL, 
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
		NULL, 
		&m_LogKey, 
		NULL
	) ;
			
	if ( t_Status == ERROR_SUCCESS )
	{
		t_Status = RegNotifyChangeKeyValue ( 

			m_LogKey , 
			TRUE , 
			REG_NOTIFY_CHANGE_LAST_SET , 
			GetHandle () , 
			TRUE 
		) ; 
	}
}

CEventProviderWorkerThread::CEventProviderWorkerThread()
:	SnmpThreadObject (THREAD_NAME, THREAD_INTERVAL),
	m_pNotifyInt(NULL),
	m_notify(NULL),
	m_RegTaskObject(NULL)
{
	m_RegTaskObject = new TimerRegistryTaskObject(this) ;
	ScheduleTask ( *m_RegTaskObject ) ;

	HRESULT hr = CoCreateInstance (CLSID_SMIR_Database,
					NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
					IID_ISMIR_Database, (void**)&m_pNotifyInt);

	if(SUCCEEDED(hr))
	{
		m_notify = new CEventCacheNotify();
		m_notify->AddRef();
		DWORD dw = 0;
		hr = m_pNotifyInt->AddNotify(m_notify, &dw);

		if(SUCCEEDED(hr))
		{
			m_notify->SetCookie(dw);
		}
		else
		{
			m_notify->Release();
			m_notify = NULL;
		}
	}
	else
	{
		m_pNotifyInt = NULL;
	}
}

CEventProviderWorkerThread::~CEventProviderWorkerThread()
{
	if (m_RegTaskObject)
	{
		ReapTask ( *m_RegTaskObject ) ;
		delete m_RegTaskObject ;
	}
}

void CEventProviderWorkerThread::GetDeleteNotifyParams(ISmirDatabase** a_ppNotifyInt, CEventCacheNotify** a_ppNotify)
{
	if (m_notify != NULL)
	{
		m_notify->Detach();
		*a_ppNotify = m_notify;
		m_notify = NULL;
	}

	if (m_pNotifyInt != NULL)
	{
		*a_ppNotifyInt = m_pNotifyInt;
		m_pNotifyInt = NULL;
	}
}

void CEventProviderWorkerThread::CreateServerWrap ()
{
	m_pSmirNamespace = new CWbemServerWrap ( NULL ) ;
}

void CEventProviderWorkerThread::Initialise()
{
	InitializeCom();

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		L"\r\n");

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderWorkerThread::Initialise ()\r\n");
)

}

void CEventProviderWorkerThread::Uninitialise()
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderWorkerThread::Uninitialise ()\r\n");
)

	if ( m_pSmirNamespace )
	{
		m_pSmirNamespace->Release () ;
	}

	delete this;

	CoUninitialize();
}

void CEventProviderWorkerThread::SetMaxMarks(DWORD dwM)
{
	EnterCriticalSection(&g_CacheCriticalSection);
	m_MaxMarks = dwM;
	LeaveCriticalSection(&g_CacheCriticalSection);
}

void CEventProviderWorkerThread::TimedOut()
{
	EnterCriticalSection(&g_CacheCriticalSection);

	//loop cache elements delete old entries...
	POSITION pos = m_Classes.GetStartPosition();

	while (NULL != pos)
	{
		CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>* pClassMap;
		DWORD key;
		m_Classes.GetNextAssoc(pos, key, pClassMap);
		CList<CString, CString> delList;
		POSITION subpos = pClassMap->GetStartPosition();

		while (NULL != subpos)
		{
			SCacheEntry* pEntry;
			CString subkey;
			pClassMap->GetNextAssoc(subpos, subkey, pEntry);
			pEntry->m_Marker++;

			if (pEntry->m_Marker > m_MaxMarks)
			{
				delList.AddTail(subkey);
			}
		}

		if (!delList.IsEmpty())
		{
			if (delList.GetCount() == pClassMap->GetCount())
			{
				pClassMap->RemoveAll();
			}
			else
			{
				while (!delList.IsEmpty())
				{
					pClassMap->RemoveKey(delList.RemoveTail());
				}
			}
		}
	}

	LeaveCriticalSection(&g_CacheCriticalSection);
}

void CEventProviderWorkerThread::Clear()
{
	EnterCriticalSection(&g_CacheCriticalSection);

	//loop cache elements delete all entries...
	POSITION pos = m_Classes.GetStartPosition();

	while (NULL != pos)
	{
		CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>* pClassMap;
		DWORD key;
		m_Classes.GetNextAssoc(pos, key, pClassMap);
		pClassMap->RemoveAll();
	}

	LeaveCriticalSection(&g_CacheCriticalSection);
}

void CEventProviderWorkerThread::AddClassesToCache(DWORD_PTR key, CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>* item)
{
	EnterCriticalSection ( & g_CacheCriticalSection ) ;
	
	m_Classes.SetAt(key, item);

	LeaveCriticalSection ( & g_CacheCriticalSection ) ;
}

void CEventProviderWorkerThread::RemoveClassesFromCache(DWORD_PTR key)
{
	EnterCriticalSection ( & g_CacheCriticalSection ) ;
	
	g_pWorkerThread->m_Classes.RemoveKey(key);
	
	LeaveCriticalSection ( & g_CacheCriticalSection ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\main.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#define _WIN32_WINNT 0x0400
#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <guids.h>
#include <classfac.h>

DWORD g_InstanceRegister = 0 ;
DWORD g_ClassRegister = 0 ;
DWORD g_EventReferentRegister = 0 ;
DWORD g_EventEncapsulatedRegister = 0 ;

STDAPI DllRegisterServer () ;
STDAPI DllUnregisterServer () ;

BOOL s_Exiting = FALSE ;

LONG CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	long t_rc = 0 ;

	switch ( a_message )
	{
        case WM_CLOSE:
        {
            s_Exiting = TRUE ;
        }
        break ;

		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	static wchar_t *t_TemplateCode = L"TemplateCode" ;

	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	ShowWindow ( t_HWnd, SW_SHOW ) ;
//	ShowWindow ( t_HWnd, SW_HIDE ) ;

	return t_HWnd ;
}

void WindowsStop ( HWND a_HWnd )
{
	CoUninitialize () ;
	DestroyWindow ( a_HWnd ) ;
}

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = NULL ;
	if ( ! ( t_HWnd = WindowsInit ( a_Handle ) ) )
	{
    }

	return t_HWnd ;
}

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;

		if ( s_Exiting )
			return ;
	}
}

HRESULT UninitComServer ()
{
	if ( g_InstanceRegister )
		CoRevokeClassObject ( g_InstanceRegister );

	if ( g_ClassRegister )
		CoRevokeClassObject ( g_ClassRegister );

	if ( g_EventEncapsulatedRegister )
		CoRevokeClassObject ( g_EventEncapsulatedRegister );

	if ( g_EventReferentRegister )
		CoRevokeClassObject ( g_EventReferentRegister );

	CoUninitialize () ;

	return S_OK ;
}

HRESULT InitInstanceProvider ()
{
	IUnknown *t_ClassFactory = new CPropProvClassFactory ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	HRESULT t_Result = CoRegisterClassObject (

		CLSID_CPropProvClassFactory,
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_InstanceRegister
	);

	return t_Result ;
}

HRESULT InitClassProvider ()
{
	IUnknown *t_ClassFactory = new CClasProvClassFactory ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	HRESULT t_Result = CoRegisterClassObject (

		CLSID_CClasProvClassFactory,
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_ClassRegister
	);

	return t_Result ;
}

HRESULT InitEventEncapsulatedProvider ()
{
	IUnknown *t_ClassFactory = new CSNMPEncapEventProviderClassFactory ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	HRESULT t_Result = CoRegisterClassObject (

		CLSID_CSNMPEncapEventProviderClassFactory,
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_EventEncapsulatedRegister
	);

	return t_Result ;
}

HRESULT InitEventReferentProvider ()
{
	IUnknown *t_ClassFactory = new CSNMPRefEventProviderClassFactory ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	HRESULT t_Result = CoRegisterClassObject (

		CLSID_CSNMPReftEventProviderClassFactory,
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_EventReferentRegister
	);

	return t_Result ;
}

HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
	HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx (

		0, 
		COINIT_MULTITHREADED
	);

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			a_AuthenticationLevel,
			a_ImpersonationLevel, 
			NULL, 
			EOAC_NONE, 
			0
		);

		if ( FAILED ( t_Result ) ) 
		{
			CoUninitialize () ;
			return t_Result ;
		}

	}

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitInstanceProvider () ;

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitClassProvider () ;

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitEventReferentProvider () ;

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitEventEncapsulatedProvider () ;

	if ( FAILED ( t_Result ) )
	{
		UninitComServer () ;
	}

	return t_Result  ;
}

HRESULT Process ()
{
#if 1
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
#else
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTITY ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE ;
#endif

	HRESULT t_Result = InitComServer ( t_ImpersonationLevel , t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WindowsDispatch () ;
		UninitComServer () ;
	}

	return t_Result ;
}

BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;
		if ( t_Arg ) 
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllRegisterServer () ;
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllUnregisterServer () ;
			}
		}
	}

	return t_Exit ;
}

int WINAPI WinMain (
  
    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
	BOOL t_Status = DllMain (

		hInstance, 
		DLL_PROCESS_ATTACH , 
		NULL
	) ;

	BOOL t_Exit = ParseCommandLine () ;
	if ( ! t_Exit ) 
	{
		HWND hWnd = WindowsStart ( hInstance ) ;

		SnmpDebugLog :: Startup ();
		SnmpThreadObject :: Startup () ;

		HRESULT t_Result = Process () ;

		SnmpDebugLog :: Closedown () ;
		SnmpThreadObject :: Closedown () ;

		WindowsStop ( hWnd ) ;
	}

	t_Status = DllMain (

		hInstance, 
		DLL_PROCESS_DETACH , 
		NULL
	) ;

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//

#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\maindll.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>

#include <objbase.h>
#include <olectl.h>
#include <corafx.h>

#include <wbemidl.h>
#include "guids.h"

#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>

#include <instpath.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include "classfac.h"
#include "clasprov.h"
#include "propprov.h"
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <notify.h>
#include <cormap.h>
#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>

ISmirDatabase*		g_pNotifyInt = NULL;
CCorrCacheNotify*	gp_notify = NULL;
CCorrCacheWrapper*	g_CacheWrapper = NULL;
CCorrelatorMap*		g_Map = NULL;

//OK we need this one
HINSTANCE   g_hInst=NULL;

CEventProviderThread* g_pProvThrd = NULL;
CEventProviderWorkerThread* g_pWorkerThread = NULL;

CRITICAL_SECTION s_ProviderCriticalSection ;
CRITICAL_SECTION g_CacheCriticalSection ;

extern void ProviderStartup () ;
extern void ProviderClosedown () ;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		g_hInst=hInstance;

		BOOL status = TRUE ;

		if ( DLL_PROCESS_DETACH == ulReason )
		{
			DeleteCriticalSection ( & s_ProviderCriticalSection ) ;
			DeleteCriticalSection ( & g_CacheCriticalSection ) ;


			status = TRUE ;
		}
		else if ( DLL_PROCESS_ATTACH == ulReason )
		{
			DisableThreadLibraryCalls(hInstance);
			InitializeCriticalSection ( & s_ProviderCriticalSection ) ;
			InitializeCriticalSection ( & g_CacheCriticalSection ) ;
			status = TRUE ;
		}
		else if ( DLL_THREAD_DETACH == ulReason )
		{
			status = TRUE ;
		}
		else if ( DLL_THREAD_ATTACH == ulReason )
		{
			status = TRUE ;
		}


		return TRUE ;
	}
	catch(Structured_Exception e_SE)
	{
		return FALSE;
	}
	catch(Heap_Exception e_HE)
	{
		return FALSE;
	}
	catch(...)
	{
		return FALSE;
	}
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT status = S_OK ; 

		if ( rclsid == CLSID_CClasProvClassFactory ) 
		{
			CClasProvClassFactory *lpunk = new CClasProvClassFactory ;
			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else if ( rclsid == CLSID_CPropProvClassFactory ) 
		{
			CPropProvClassFactory *lpunk = new CPropProvClassFactory ;
			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else if ( rclsid == CLSID_CSNMPReftEventProviderClassFactory ) 
		{
			CSNMPRefEventProviderClassFactory *lpunk = new CSNMPRefEventProviderClassFactory;

			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppv ) ;

				if ( FAILED ( status ) )
				{
					delete lpunk ;				
				}
			}
		}
		else if ( rclsid == CLSID_CSNMPEncapEventProviderClassFactory ) 
		{
			CSNMPEncapEventProviderClassFactory *lpunk = new CSNMPEncapEventProviderClassFactory;

			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppv ) ;

				if ( FAILED ( status ) )
				{
					delete lpunk ;				
				}
			}
		}
		else	
		{
			status = CLASS_E_CLASSNOTAVAILABLE ;
		}
		
		return status ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	SetStructuredExceptionHandler seh;

	try
	{
	/* 
	 * Place code in critical section
	 */
		EnterCriticalSection ( & s_ProviderCriticalSection ) ;
		
		ISmirDatabase* t_pNotifyInt = NULL;
		CCorrCacheNotify* t_pnotify = NULL;
		CEventCacheNotify* t_notify = NULL;
		ISmirDatabase* t_pNotifyIntThread = NULL;

		BOOL unload = (
						CClasProvClassFactory :: locksInProgress ||
						CClasProvClassFactory :: objectsInProgress ||
						CPropProvClassFactory :: locksInProgress ||
						CPropProvClassFactory :: objectsInProgress ||
						CSNMPEventProviderClassFactory :: locksInProgress ||
						CSNMPEventProviderClassFactory :: objectsInProgress
						) ;

		unload = ! unload ;

		if ( unload )
		{
			if ( CImpClasProv :: s_Initialised )
			{
				CImpClasProv :: s_Initialised = FALSE ;

				CCorrelator :: TerminateCorrelator (&t_pNotifyInt, &t_pnotify) ;

				SnmpClassLibrary :: Closedown () ;
				SnmpDebugLog :: Closedown () ;
				SnmpThreadObject :: Closedown () ;

				ProviderClosedown () ;
			}

			if ( CImpPropProv :: s_Initialised )
			{
				CImpPropProv :: s_Initialised = FALSE ;

				SnmpClassLibrary :: Closedown () ;
				SnmpDebugLog :: Closedown () ;
				SnmpThreadObject :: Closedown () ;

				ProviderClosedown () ;

			}

			if ( g_pProvThrd )
			{
				delete g_pProvThrd;
				g_pProvThrd = NULL;
				g_pWorkerThread->GetDeleteNotifyParams(&t_pNotifyIntThread, &t_notify);
				g_pWorkerThread->SignalThreadShutdown();
				g_pWorkerThread = NULL;

				SnmpClassLibrary :: Closedown () ;
				SnmpDebugLog :: Closedown () ;
				SnmpThreadObject :: Closedown () ;

				ProviderClosedown () ;
			}

		}

		LeaveCriticalSection ( & s_ProviderCriticalSection ) ;

		if (unload)
		{
			if (t_pNotifyInt)
			{
				if (t_pnotify)
				{
					t_pNotifyInt->DeleteNotify(t_pnotify->GetCookie());
				}

				t_pNotifyInt->Release();
				t_pNotifyInt = NULL;
			}

			if (t_pnotify)
			{
				t_pnotify->Release();
				t_pnotify = NULL;
			}

			if (t_pNotifyIntThread)
			{
				if (t_notify)
				{
					t_pNotifyIntThread->DeleteNotify(t_notify->GetCookie());
				}

				t_pNotifyIntThread->Release();
				t_pNotifyIntThread = NULL;
			}

			if (t_notify)
			{
				t_notify->Release();
				t_notify = NULL;
			}
		}

		return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return S_FALSE;
	}
	catch(Heap_Exception e_HE)
	{
		return S_FALSE;
	}
	catch(...)
	{
		return S_FALSE;
	}
}

#define REG_FORMAT_STR			L"%s\\%s"
#define NOT_INSERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define LOCALSERVER32_STR		L"LocalServer32"
#define THREADING_MODULE_STR	L"ThreadingModel"
#define APARTMENT_STR			L"Both"
#define APPID_STR				L"Software\\Classes\\AppID\\"
#define CLSID_STR				L"Software\\Classes\\CLSID\\"

#define CLASS_PROVIDER_NAME_STR			L"Microsoft WBEM SNMP Class Provider"
#define INSTANCE_PROVIDER_NAME_STR		L"Microsoft WBEM SNMP Instance Provider"
#define EVENT_PROVIDER_NAME_STR			L"Microsoft WBEM SNMP Event Provider"

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey, wchar_t* pszValueName, wchar_t* pszValue)
{
    HKEY        hKey;
    wchar_t       szKey[256];

	wcscpy(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		wcscat(szKey, L"\\");
        wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (lstrlen(pszValue)+1)*sizeof(wchar_t)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI RegisterServer( GUID a_ProviderClassId , wchar_t *a_ProviderName )
{
	wchar_t szModule[512];
	GetModuleFileName(g_hInst,(wchar_t*)szModule, sizeof(szModule)/sizeof(wchar_t));

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId,szProviderClassID, 128);

#ifdef LOCALSERVER
	TCHAR szProviderCLSIDAppID[128];
	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;
#endif

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

#ifdef LOCALSERVER

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;
#else

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

#endif

	return S_OK;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI UnregisterServer( GUID a_ProviderClassId )
{
	wchar_t szTemp[128];

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId ,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

#ifdef LOCALSERVER

	TCHAR szProviderCLSIDAppID[128];
	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	//Delete entries under APPID

	DWORD t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDAppID);

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, LOCALSERVER32_STR);
	t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#else

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

#endif

	RegDeleteKey(HKEY_LOCAL_MACHINE, szProviderCLSIDClassID);

    return S_OK;
}

STDAPI DllRegisterServer()
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT t_Result ;

		t_Result = RegisterServer ( CLSID_CPropProvClassFactory , INSTANCE_PROVIDER_NAME_STR ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : RegisterServer ( CLSID_CClasProvClassFactory , CLASS_PROVIDER_NAME_STR  ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : RegisterServer ( CLSID_CSNMPReftEventProviderClassFactory , EVENT_PROVIDER_NAME_STR ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : RegisterServer ( CLSID_CSNMPEncapEventProviderClassFactory , EVENT_PROVIDER_NAME_STR ) ;

		return t_Result ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

STDAPI DllUnregisterServer(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT t_Result ;

		t_Result = UnregisterServer ( CLSID_CPropProvClassFactory ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : UnregisterServer ( CLSID_CClasProvClassFactory ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : UnregisterServer ( CLSID_CSNMPReftEventProviderClassFactory ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : UnregisterServer ( CLSID_CSNMPEncapEventProviderClassFactory ) ;


		return t_Result ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\notify.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>

#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <notify.h>

#include <corstore.h>

#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <cominit.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>

extern CCorrCacheWrapper*	g_CacheWrapper;
extern CEventProviderWorkerThread* g_pWorkerThread;


CBaseCorrCacheNotify::CBaseCorrCacheNotify()
{
    m_cRef=0;
    m_dwCookie=0;
	m_DoWork = TRUE;
	InitializeCriticalSection ( & m_CriticalSection ) ;
}

CBaseCorrCacheNotify::~CBaseCorrCacheNotify()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;
}

void CBaseCorrCacheNotify::Detach()
{
	EnterCriticalSection ( & m_CriticalSection ) ;
	m_DoWork = FALSE;
	LeaveCriticalSection ( & m_CriticalSection ) ;
}

/*
 * CBaseCorrCacheNotify::QueryInterface
 * CBaseCorrCacheNotify::AddRef
 * CBaseCorrCacheNotify::Release
 *
 * Purpose:
 *  Non-delegating IUnknown members for CBaseCorrCacheNotify.
 */

STDMETHODIMP CBaseCorrCacheNotify::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown == riid || IID_ISMIR_Notify == riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CBaseCorrCacheNotify::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CBaseCorrCacheNotify::Release()
{
    if (0!=--m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

STDMETHODIMP CCorrCacheNotify::ChangeNotify()
{
	EnterCriticalSection ( & m_CriticalSection ) ;
	BOOL bDoWork = m_DoWork;
	LeaveCriticalSection ( & m_CriticalSection ) ;

	if (bDoWork)
	{
		(g_CacheWrapper->GetCache())->InvalidateCache();
		CCorrCache* cache = new CCorrCache();
		g_CacheWrapper->SetCache(cache);
		g_CacheWrapper->ReleaseCache();
	}

	return NOERROR;
}

STDMETHODIMP CEventCacheNotify::ChangeNotify()
{
	EnterCriticalSection ( & m_CriticalSection ) ;
	BOOL bDoWork = m_DoWork;
	LeaveCriticalSection ( & m_CriticalSection ) ;

	if (bDoWork)
	{
		g_pWorkerThread->Clear();
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propdel.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "propdel.h"
#include "snmpget.h"
#include "snmpset.h"
#include "snmpqset.h"

void DeleteInstanceAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	BOOL t_Status = TRUE ;

	if ( m_SnmpTooBig )
	{
		m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SetComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Update Succeeded" 
	) ;
)
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	SetOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	Complete () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from DeleteInstanceAsyncEventObject :: ReceiveComplete ()" 
	) ;
)
}

void DeleteInstanceAsyncEventObject :: SnmpTooBig () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"DeleteInstanceAsyncEventObject :: SnmpTooBig ()" 
	) ;
)

	m_SnmpTooBig = TRUE ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from DeleteInstanceAsyncEventObject :: SnmpTooBig ()" 
	) ;
)
}

BOOL DeleteInstanceAsyncEventObject :: Delete ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"DeleteInstanceAsyncEventObject :: Delete ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;
	IWbemClassObject *t_ClassObject = NULL ;
	IWbemServices *t_Serv = provider->GetServer();
	HRESULT result = WBEM_E_FAILED;
	
	if (t_Serv)
	{
		VARIANT variant ;
		VariantInit ( & variant ) ;
		variant.bstrVal = SysAllocString ( m_ObjectPath ) ;

		result = t_Serv->GetObject (

			variant.bstrVal ,
			0 ,
			m_Context ,
			& t_ClassObject ,
			NULL 
		) ;

		VariantClear ( & variant ) ;
		t_Serv->Release () ;
	}

	if ( SUCCEEDED ( result ) )
	{
		if ( status = GetNamespaceObject ( a_errorObject ) )
		{
			status = snmpObject.Set ( a_errorObject , t_ClassObject ) ;
			if ( status )
			{
				status = snmpObject.Check ( a_errorObject ) ;
				if ( status )
				{
					if ( ! snmpObject.RowStatusSpecified () )
					{
						WbemSnmpProperty *t_Property ;

						snmpObject.ResetProperty () ;
						while ( t_Property = snmpObject.NextProperty () )
						{
							if ( typeid ( *t_Property->GetValue () ) == typeid ( SnmpRowStatusType ) )
							{
								t_Property->SetTag ( FALSE ) ;
								SnmpRowStatusType *t_RowStatus = new SnmpRowStatusType ( SnmpRowStatusType :: SnmpRowStatusEnum :: destroy  ) ;
								t_Property->SetValue ( t_RowStatus ) ;
							}
						}

						status = SendSnmp ( m_errorObject , 0 ) ;
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Deletion of an instance requires the specification of a RowStatus class definition" ) ;

					}
				}
				else
				{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Merge : Class definition did not conform to mapping"
) ;
)
				}
			}
			else
			{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
			}
		}

		t_ClassObject->Release () ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from DeleteInstanceAsyncEventObject :: Delete ( WbemSnmpErrorObject &a_errorObject ) with Result (%lx)" ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

BOOL DeleteInstanceAsyncEventObject :: DeleteInstance ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status;
    int iParseResult = m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;
	if ( CObjectPathParser::NoError == iParseResult )
	{
        t_Status = Delete ( a_ErrorObject ) ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

DeleteInstanceAsyncEventObject :: DeleteInstanceAsyncEventObject (

	CImpPropProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : SnmpSetResponseEventObject ( a_Provider , NULL , a_Ctx , 0 ) ,
	m_NotificationHandler ( a_NotificationHandler ) , 
	m_Class ( NULL ) ,
	m_State ( 0 ),
	m_ObjectPath ( NULL ) ,
#pragma warning (disable:4355)
	snmpObject ( this )
#pragma warning (default:4355)
{
	m_NotificationHandler->AddRef () ;
	m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
}

DeleteInstanceAsyncEventObject :: ~DeleteInstanceAsyncEventObject () 
{
// Get Status object

	delete [] m_ObjectPath ;

	if (m_NotificationHandler)
	{
		if ( FAILED ( m_errorObject.GetWbemStatus () ) )
		{
			IWbemClassObject *t_NotifyStatus = NULL ;
			BOOL t_Status = GetSnmpNotifyStatusObject ( &t_NotifyStatus ) ;
			if ( t_Status )
			{
				HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , t_NotifyStatus ) ;
				t_NotifyStatus->Release () ;
			}
			else
			{
				HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
			}
		}
		else
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
		}

		m_NotificationHandler->Release();
	}
}

void DeleteInstanceAsyncEventObject :: ProcessComplete () 
{
	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

	Complete () ;
}

void DeleteInstanceAsyncEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			BOOL t_Status = DeleteInstance ( m_errorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propget.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "snmpget.h"

SnmpGetClassObject :: SnmpGetClassObject ( SnmpResponseEventObject *parentOperation ) : SnmpClassObject ( parentOperation )
{
}

SnmpGetClassObject :: ~SnmpGetClassObject ()
{
}

BOOL SnmpGetClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{
// Check Class Object, used in a Get Request, for validity

	BOOL status = TRUE ;

	snmpVersion = m_parentOperation->SetAgentVersion ( a_errorObject ) ;

	if ( snmpVersion == 0 )
	{
		status = FALSE ;
	}

// Check all Properties for validity

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		status = CheckProperty ( a_errorObject , property ) ;
	}

// Check properties defined as keys have valid key order
 
	if ( status )
	{
		if ( ! m_accessible ) 
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_NOREADABLEPROPERTIES ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class must contain at least one property which is accessible" ) ;
		}
	}

	return status ;
}

BOOL SnmpGetClassObject :: CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property )
{
// Check property validity

	BOOL status = TRUE ;

	if ( ( snmpVersion == 1 ) && property->IsSNMPV1Type () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}
	else if ( ( snmpVersion == 2 ) && property->IsSNMPV2CType () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}

	return status ;
}

SnmpGetResponseEventObject :: SnmpGetResponseEventObject ( 

	CImpPropProv *providerArg , 
	IWbemClassObject *classObjectArg ,
	IWbemContext *a_Context 

) : SnmpResponseEventObject ( providerArg , a_Context ) , 
	classObject ( classObjectArg ) , 
	instanceObject ( NULL ) ,	
	session ( NULL ) , 
	operation ( NULL ) , 
	processComplete ( FALSE ) ,
#pragma warning( disable : 4355 )
	snmpObject ( this )
#pragma warning( default : 4355 )
{
	if ( classObject )
		classObject->AddRef () ;
}

SnmpGetResponseEventObject :: ~SnmpGetResponseEventObject ()
{
	if ( instanceObject )
		instanceObject->Release () ;

	if ( classObject ) 
		classObject->Release () ;
}

BOOL SnmpGetResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	IWbemQualifierSet *classQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		wchar_t *agentAddress = NULL ;
		wchar_t *agentTransport = NULL ;
		wchar_t *agentReadCommunityName = NULL ;
		ULONG agentRetryCount ;
		ULONG agentRetryTimeout ;
		ULONG agentMaxVarBindsPerPdu ;
		ULONG agentFlowControlWindowSize ;

		status = SetAgentVersion ( m_errorObject ) ;
		if ( status ) status = GetAgentAddress ( m_errorObject , classQualifierObject , agentAddress ) ;
		if ( status ) status = GetAgentTransport ( m_errorObject , classQualifierObject , agentTransport ) ;
		if ( status ) status = GetAgentReadCommunityName ( m_errorObject , classQualifierObject , agentReadCommunityName ) ;
		if ( status ) status = GetAgentRetryCount ( m_errorObject , classQualifierObject , agentRetryCount ) ;
		if ( status ) status = GetAgentRetryTimeout ( m_errorObject , classQualifierObject , agentRetryTimeout ) ;
		if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , agentMaxVarBindsPerPdu ) ;
		if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , classQualifierObject , agentFlowControlWindowSize ) ;

		if ( status )
		{
			char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
			if ( dbcsAgentAddress )
			{
				char *dbcsAgentReadCommunityName = UnicodeToDbcsString ( agentReadCommunityName ) ;
				if ( dbcsAgentReadCommunityName )
				{
					if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
					{
						char *t_Address ;
						if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
						{
							t_Address = provider->GetIpAddressValue () ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else
							{
								if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
								{
									t_Address = dbcsAgentAddress ;
								}
								else							
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;
								}
							}
						}

						if ( status )
						{
							if ( m_agentVersion == 1 )
							{
								session = new SnmpV1OverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else if ( m_agentVersion == 2 )
							{
								session = new SnmpV2COverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

							}
						}
					}
					else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
					{
						if ( m_agentVersion == 1 )
						{
							session = new SnmpV1OverIpx (

								dbcsAgentAddress ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)
								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else if ( m_agentVersion == 2 )
						{
							session = new SnmpV2COverIpx (

								dbcsAgentAddress  ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}

					delete [] dbcsAgentReadCommunityName ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentReadCommunityName" ) ;
				}

				delete [] dbcsAgentAddress ;

				if ( status )
				{
					operation = new GetOperation(*session,this);
					operation->Send () ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" TransportInformation settings invalid"
	) ;
)
		}

		delete [] agentTransport ;
		delete [] agentAddress ;
		delete [] agentReadCommunityName ;

		classQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get class qualifier set" ) ;
	}

	return status ;

}

SnmpGetEventObject :: SnmpGetEventObject (

	CImpPropProv *providerArg , 
	wchar_t *ObjectPathArg ,
	IWbemContext *a_Context 

) : SnmpGetResponseEventObject ( providerArg , NULL , a_Context ) , objectPath ( NULL )
{
	ULONG length = wcslen ( ObjectPathArg ) ;
	objectPath = new wchar_t [ length + 1 ] ;
	wcscpy ( objectPath , ObjectPathArg ) ;
}

SnmpGetEventObject :: ~SnmpGetEventObject ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: ~SnmpGetEventObject()"
	) ;
)

	delete [] objectPath ;
}

BOOL SnmpGetEventObject :: ParseObjectPath ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: ParseObjectPath ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

// Check Validity of instance path

	ParsedObjectPath *t_ParsedObjectPath = NULL ;
	CObjectPathParser t_ObjectPathParser ;

	BOOL status = t_ObjectPathParser.Parse ( objectPath , &t_ParsedObjectPath ) ;
	if ( status == 0 )
	{
// Check validity of path

		status = DispatchObjectPath ( a_errorObject , t_ParsedObjectPath ) ;
	}
	else
	{
// Parse Failure

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATH ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to parse object path" ) ;
	}

	delete t_ParsedObjectPath ;

	return status ;
}

BOOL SnmpGetEventObject :: DispatchObjectPath ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) 
{
// Check validity of server/namespace path and validity of request

	BOOL status = TRUE ;

	status = DispatchObjectReference ( a_errorObject , t_ParsedObjectPath ) ;

	return status ;
}

BOOL SnmpGetEventObject :: DispatchObjectReference ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: DispatchObjectReference ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath )"
	) ;
)

// Check validity of request

	BOOL status = TRUE ;

// Get type of request

	if ( t_ParsedObjectPath->m_bSingletonObj )
	{
// Class requested

		status = DispatchKeyLessClass ( a_errorObject , t_ParsedObjectPath->m_pClass ) ;
	}
	else if ( t_ParsedObjectPath->m_dwNumKeys == 0 )
	{
// Class requested

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_NOT_CAPABLE ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE ) ;
		a_errorObject.SetMessage ( L"Unexpected Path parameter" ) ;

	}
	else 
	{
// General instance requested

		status = DispatchInstanceSpec ( a_errorObject , t_ParsedObjectPath ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: GetInstanceClass ( WbemSnmpErrorObject &a_errorObject , BSTR Class )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: GetInstanceClass ( WbemSnmpErrorObject &a_errorObject , BSTR Class (%s) )" ,
		Class
	) ;
)

// Get OLE MS class definition

	BOOL status = TRUE ;
	IWbemServices *t_Serv = provider->GetServer();
	HRESULT result = WBEM_E_FAILED;
	
	if (t_Serv)
	{
		result = t_Serv->GetObject (

			Class ,
			0 ,
			m_Context ,
			& classObject ,
			NULL
		) ;

		t_Serv->Release () ;
	}

// Clone object

	if ( SUCCEEDED ( result ) )
	{
		result = classObject->SpawnInstance ( 0 , & instanceObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			if ( status = GetNamespaceObject ( a_errorObject ) )
			{
			}
		}
	}
	else
	{
// Class definition unknown

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Unexpected Path parameter" ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: DispatchKeyLessClass ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: DispatchKeyLessClass ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class (%s) )",
		a_Class
	) ;
)

	BOOL status = TRUE ;

	status = GetInstanceClass ( a_errorObject , a_Class ) ;
	if ( status )
	{
		status = snmpObject.Set ( a_errorObject , GetClassObject () , FALSE ) ;
		if ( status )
		{
			status = snmpObject.Check ( a_errorObject ) ;
			if ( status )
			{
				status = SendSnmp ( a_errorObject ) ;
			}
			else
			{
// Class definition syntactically incorrect
			}
		}
		else
		{
// Class definition syntactically incorrect
		}
	}
	else
	{
// Class definition unknown
	}

	return status ;
}

BOOL SnmpGetEventObject :: SetProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property , KeyRef *a_KeyReference )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: SetProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property (%s) , KeyRef *a_KeyReference )",
		property->GetName () 
	) ;
)

// Set keyed property value used for instance retrieval using path specification

	BOOL status = TRUE ;

	if ( a_KeyReference->m_vValue.vt == VT_I4 )
	{
// property value is an integer type

		if ( property->SetValue ( a_KeyReference->m_vValue , property->GetCimType () ) ) 
		{
		}
		else
		{
// Property value doesn't correspond with property syntax

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Path parameter is inconsistent with keyed property: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , property->GetName () ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}
	}
	else if ( a_KeyReference->m_vValue.vt == VT_BSTR )
	{
// property value is an string type

		if ( property->SetValue ( a_KeyReference->m_vValue , property->GetCimType () ) )
		{
		}
		else
		{
// Property value doesn't correspond with property syntax

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Path parameter is inconsistent with keyed property: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , property->GetName () ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 

		}
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Path parameter is inconsistent with keyed property" ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: SetInstanceSpecKeys ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: SetInstanceSpecKeys ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath )"
	) ;
)

// Get Instance based on general request

	BOOL status = TRUE ;

// Clear Tag for all keyed properties

	WbemSnmpProperty *property ;
	snmpObject.ResetKeyProperty () ;
	while ( property = snmpObject.NextKeyProperty () )
	{
		property->SetTag ( FALSE ) ;
	}

// Check request doesn't contain duplicate property names

	if ( snmpObject.GetKeyPropertyCount () == 1 )
	{
// Class contains exactly one keyed property

		WbemSnmpProperty *property ;
		snmpObject.ResetKeyProperty () ;
		if ( property = snmpObject.NextKeyProperty () )
		{
// Set Key property value

			KeyRef *t_PropertyReference = a_ParsedObjectPath->m_paKeys [ 0 ] ;
			status = SetProperty ( a_errorObject , property , t_PropertyReference ) ;
		}
	}
	else if ( snmpObject.GetKeyPropertyCount () != 0 )
	{
// Iterate through list of key assignments in request

		ULONG t_Index = 0 ;
		while ( t_Index < a_ParsedObjectPath->m_dwNumKeys )
		{
			KeyRef *t_PropertyReference = a_ParsedObjectPath->m_paKeys [ t_Index ] ;
			WbemSnmpProperty *property ;
			if ( property = snmpObject.FindKeyProperty ( t_PropertyReference->m_pName ) )
			{
				if ( property->GetTag () )
				{
// key value already specified in request

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_DUPLICATEPATHKEYPARAMETER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Path definition specified duplicate key parameter" ) ;

					break ;
				}
				else
				{
// Set property based on request value

					property->SetTag () ;
					status = SetProperty ( a_errorObject , property , t_PropertyReference ) ;
					if ( status )
					{
					}
					else
					{
// Illegal key value specified

						break ;
					}
				}
			}
			else
			{
// Property request is not a valid keyed property

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Path definition specified invalid key parameter name" ) ;

				break ;
			}

			t_Index ++ ;
		}

// Check all keyed properties values have been specified

		if ( status )
		{
			WbemSnmpProperty *property ;
			snmpObject.ResetKeyProperty () ;
			while ( status && ( property = snmpObject.NextKeyProperty () ) )
			{
				if ( property->GetTag () ) 
				{
				}
				else
				{
// One of the keyed properties has not been specified

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_MISSINGPATHKEYPARAMETER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Path definition did not specify all key parameter values" ) ;

					break ;
				}
			}
		}
	}
	else
	{
// Class contains zero keyed properties, has already have been checked

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Path definition specified key parameters for keyless class" ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: DispatchInstanceSpec ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: DispatchInstanceSpec ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath )"
	) ;
)

	BOOL status = TRUE ;

	status = GetInstanceClass ( a_errorObject , a_ParsedObjectPath->m_pClass ) ;
	if ( status )
	{
		status = snmpObject.Set ( a_errorObject , GetClassObject () , FALSE ) ;
		if ( status )
		{
			status = snmpObject.Check ( a_errorObject ) ;
			if ( status )
			{
				status = SetInstanceSpecKeys ( a_errorObject , a_ParsedObjectPath ) ;
				if ( status )
				{
					status = SendSnmp ( a_errorObject ) ;
				}
				else
				{
// Requested Property value definitions illegal

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Key Specification was illegal"
	) ;
)
				}
			}
			else
			{
// Class definition syntactically incorrect

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Failed During Check :Class definition did not conform to mapping"
	) ;
)

			}
		}
		else
		{
// Class definition syntactically incorrect

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Failed During Set : Class definition did not conform to mapping"
	) ;
)
		}
	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Class definition unknown"
	) ;

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Unknown Class" ) ;

)

// Class definition unknown
	}

	return status ;
}

SnmpGetAsyncEventObject :: SnmpGetAsyncEventObject (

	CImpPropProv *providerArg , 
	wchar_t *ObjectPathArg ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context 

) : SnmpGetEventObject ( providerArg , ObjectPathArg , a_Context ) , notificationHandler ( notify ) , state ( 0 )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: SnmpGetAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpGetAsyncEventObject :: ~SnmpGetAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: ~SnmpGetAsyncEventObject ()" 
	) ;
)

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{

// Get Status object

		IWbemClassObject *notifyStatus = NULL ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			notifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpGetAsyncEventObject :: ~SnmpGetAsyncEventObject ()" 
	) ;
)

}

void SnmpGetAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
		if ( notificationHandler )
		{

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Object" 
	) ;
)
			notificationHandler->Indicate ( 1 , & instanceObject ) ;
			if ( ! HasNonNullKeys ( instanceObject ) )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
			}
		}
		else
		{
		}
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	GetOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	Complete () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpGetAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

}

void SnmpGetAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			BOOL status = ParseObjectPath ( m_errorObject ) ;
			if ( status )
			{
				if ( processComplete )
				{
					ReceiveComplete () ;
				}
			}
			else
			{
				ReceiveComplete () ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpGetAsyncEventObject :: Process ()" 
	) ;
)

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propinst.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <provtree.h>
#include <provdnf.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "propdel.h"
#include "propinst.h"
#include "propquery.h"
#include "snmpget.h"
#include "snmpnext.h"

SnmpClassObject :: SnmpClassObject ( 

	const SnmpClassObject & snmpClassObject 

) : WbemSnmpClassObject ( snmpClassObject ) , 
	snmpVersion ( snmpClassObject.snmpVersion ) , 
	m_accessible ( snmpClassObject.m_accessible ) ,
	m_parentOperation ( snmpClassObject.m_parentOperation )
{
}

SnmpClassObject :: SnmpClassObject (
	SnmpResponseEventObject *parentOperation
	
) : snmpVersion ( 0 ) ,
	m_accessible ( FALSE ) ,
	m_parentOperation ( parentOperation )
{
}

SnmpClassObject :: ~SnmpClassObject ()
{
}

SnmpResponseEventObject :: SnmpResponseEventObject ( 

	CImpPropProv *providerArg ,
	IWbemContext *a_Context 

) : provider ( providerArg ) , m_namespaceObject ( NULL ) , m_Context ( a_Context ) , m_agentVersion ( 0 )
{
	if ( m_Context ) 
	{
		m_Context->AddRef () ;

		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		t_Variant.vt = VT_BOOL ;
		t_Variant.boolVal = VARIANT_FALSE ;
		m_Context->SetValue ( WBEM_CLASS_CORRELATE_CONTEXT_PROP , 0 , &t_Variant ) ;

		VariantClear ( &t_Variant ) ;
	}

	if ( provider )
		provider->AddRef () ;
}

SnmpResponseEventObject :: ~SnmpResponseEventObject ()
{
	if ( m_Context )
		m_Context->Release () ;

	if ( provider )
		provider->Release () ;

	if ( m_namespaceObject )
		m_namespaceObject->Release () ;
}


BOOL SnmpResponseEventObject :: HasNonNullKeys ( IWbemClassObject *a_Obj ) 
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	
	if ( a_Obj )
	{
		hr = a_Obj->BeginEnumeration ( WBEM_FLAG_KEYS_ONLY ) ;

		if ( SUCCEEDED ( hr ) )
		{
			VARIANT t_vVal ;
			VariantInit ( &t_vVal ) ;

			//returns WBEM_S_NO_ERROR or WBEM_S_NO_MORE_DATA on success
			hr = a_Obj->Next( 0, NULL, &t_vVal, NULL, NULL ) ;

			while ( hr == WBEM_S_NO_ERROR )
			{
				if ( t_vVal.vt == VT_NULL )
				{
					hr = WBEM_E_FAILED ;
				}

				VariantClear ( &t_vVal ) ;
				VariantInit ( &t_vVal ) ;
				
				if ( hr != WBEM_E_FAILED )
				{
					hr = a_Obj->Next( 0, NULL, &t_vVal, NULL, NULL ) ;
				}
			}

			VariantClear ( &t_vVal ) ;
			a_Obj->EndEnumeration () ;
		}
	}

	return SUCCEEDED ( hr ) ;
}


BOOL SnmpResponseEventObject :: GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject )
{
	BOOL status = TRUE ;

	IWbemServices *parentServer = provider->GetParentServer () ;

	wchar_t *objectPathPrefix = UnicodeStringAppend ( WBEM_NAMESPACE_EQUALS , provider->GetThisNamespace () ) ;
	wchar_t *objectPath = UnicodeStringAppend ( objectPathPrefix , WBEM_NAMESPACE_QUOTE ) ;

	delete [] objectPathPrefix ;

	BSTR t_Path = SysAllocString ( objectPath ) ;

	HRESULT result = parentServer->GetObject ( 

		t_Path ,
		0  ,
		m_Context ,
		&m_namespaceObject ,
		NULL
	) ;

	SysFreeString ( t_Path ) ;

	if ( SUCCEEDED ( result ) )
	{
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to obtain namespace object" ) ;
	}

	parentServer->Release () ;

	delete [] objectPath ;

	return status ;
}

BOOL SnmpResponseEventObject  :: GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;
	IWbemClassObject *errorObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = provider->GetSnmpNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			VariantClear ( &variant ) ;

			if ( SUCCEEDED ( result ) )
			{
				variant.vt = VT_I4 ;
				variant.lVal = m_errorObject.GetStatus () ;

				result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSCODE , 0 , & variant , 0 ) ;
				VariantClear ( &variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					if ( m_errorObject.GetMessage () ) 
					{
						variant.vt = VT_BSTR ;
						variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

						result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
						VariantClear ( &variant ) ;

						if ( ! SUCCEEDED ( result ) )
						{
							(*notifyObject)->Release () ;
							status = GetNotifyStatusObject ( notifyObject ) ;
						}
					}
				}
				else
				{
					(*notifyObject)->Release () ;
					status = GetNotifyStatusObject ( notifyObject ) ;
				}
			}
			else
			{
				(*notifyObject)->Release () ;
				status = GetNotifyStatusObject ( notifyObject ) ;
			}

			notificationClassObject->Release () ;
		}
		else
		{
			status = GetNotifyStatusObject ( notifyObject ) ;
		}
	}
	else
	{
		status = GetNotifyStatusObject ( notifyObject ) ;
	}

	return status ;
}

BOOL SnmpResponseEventObject  :: GetNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = provider->GetNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			if ( SUCCEEDED ( result ) )
			{
				if ( m_errorObject.GetMessage () ) 
				{
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

					result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
					VariantClear ( &variant ) ;

					if ( ! SUCCEEDED ( result ) )
					{
						status = FALSE ;
						(*notifyObject)->Release () ;
						(*notifyObject)=NULL ;
					}
				}
			}
			else
			{
				(*notifyObject)->Release () ;
				(*notifyObject)=NULL ;
				status = FALSE ;
			}

			VariantClear ( &variant ) ;

			notificationClassObject->Release () ;
		}
		else
		{
			status = FALSE ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentTransport ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentTransport 
)
{
	BOOL status = TRUE ;
	agentTransport = NULL ;
	BSTR t_Transport = NULL ;
	wchar_t *t_QualifierTransport = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTTRANSPORT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
	}

	if ( status & ! t_Transport )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTTRANSPORT ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
			{
				SnmpDisplayStringType *stringType = ( SnmpDisplayStringType * ) value ;
				t_Transport = t_QualifierTransport = stringType->GetValue () ;

				if ( t_QualifierTransport )
				{
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
	}

	if ( status & ! t_Transport )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTTRANSPORT , 
			0,	
			&t_Variant ,
			& attributeType

		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
		else
		{
			t_Transport = WBEM_AGENTIPTRANSPORT ;
		}
	}

	if ( status )
	{
		if ( ( _wcsicmp ( t_Transport , WBEM_AGENTIPTRANSPORT ) == 0 ) || ( _wcsicmp ( t_Transport , WBEM_AGENTIPXTRANSPORT ) == 0 ) )
		{
			agentTransport = UnicodeStringDuplicate ( t_Transport ) ;
		}
		else
		{
/*
*	Transport type != IP || != IPX
*/
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
		}

	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierTransport ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentTransport ( %s ) " , agentTransport 
	) ;
)

	}

	return status ;
}

ULONG SnmpResponseEventObject :: SetAgentVersion ( 

	WbemSnmpErrorObject &a_errorObject 
)
{
	BOOL status = TRUE ;

	if (m_agentVersion == 0)
	{
		BSTR t_Version = NULL ;
		wchar_t *t_QualifierVersion = NULL ;

		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		if ( m_Context )
		{
			HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTSNMPVERSION , 0 , & t_Variant ) ;
			if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
			{
				if ( t_Variant.vt == VT_BSTR ) 
				{
					t_Version = t_Variant.bstrVal ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
				}
			}
		}

		if ( status & ! t_Version )
		{
			WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTSNMPVERSION ) ;
			if ( qualifier )
			{
				SnmpInstanceType *value = qualifier->GetValue () ;
				if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
				{
					SnmpDisplayStringType *stringType = ( SnmpDisplayStringType * ) value ;
					t_Version = t_QualifierVersion = stringType->GetValue () ;

					if ( t_QualifierVersion )
					{
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
				}
			}
		}

		if ( status & ! t_Version )
		{
			if ( ! m_namespaceObject )
			{
				status = GetNamespaceObject ( a_errorObject ) ;
			}

			if ( status )
			{
				IWbemQualifierSet *namespaceQualifierObject = NULL ;
				HRESULT result = m_namespaceObject->GetQualifierSet ( &namespaceQualifierObject ) ;
				if ( SUCCEEDED ( result ) )
				{
					LONG attributeType ;
					HRESULT result = namespaceQualifierObject->Get ( 

						WBEM_QUALIFIER_AGENTSNMPVERSION , 
						0,	
						&t_Variant ,
						& attributeType
						
					) ;

					if ( SUCCEEDED ( result ) )
					{
						if ( t_Variant.vt == VT_BSTR ) 
						{
							t_Version = t_Variant.bstrVal ;
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
						}
					}
					else
					{
						t_Version = WBEM_AGENTSNMPVERSION_V1 ;
					}

					namespaceQualifierObject->Release();
				}
			}
		}

		if ( status )
		{
			if ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
			{
				m_agentVersion = 1 ;
			}
			else if ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
			{
				m_agentVersion = 2 ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type/Value mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}

		VariantClear ( & t_Variant );
		delete [] t_QualifierVersion ;
	}

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentVersion ( %d ) " , m_agentVersion 
	) ;
)
	}

	return m_agentVersion ;
}

BOOL SnmpResponseEventObject :: GetAgentAddress ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentAddress 
)
{
	BOOL status = TRUE ;
	agentAddress = NULL ;
	BSTR t_Address = NULL ;
	wchar_t *t_QualifierAddress = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTADDRESS , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
	}

	if ( status & ! t_Address )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTADDRESS ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
			{
				SnmpDisplayStringType *stringType = ( SnmpDisplayStringType * ) value ;
				t_Address = t_QualifierAddress = stringType->GetValue () ;

				if ( t_QualifierAddress )
				{
					if ( wcscmp ( t_Address , L"" ) == 0 ) 
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
	}

	if ( status & ! t_Address )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTADDRESS , 
			0,	
			&t_Variant ,
			& attributeType
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Namespace must specify valid qualifier for: AgentAddress" ) ;
		}
	}

	if ( status )
	{
		agentAddress = UnicodeStringDuplicate ( t_Address ) ;
	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierAddress ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentAddress ( %s ) " , agentAddress 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentReadCommunityName ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentReadCommunityName 
)
{
	BOOL status = TRUE ;
	agentReadCommunityName = NULL ;
	BSTR t_Community = NULL ;
	wchar_t *t_QualifierCommunity = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
	}

	if ( status & ! t_Community )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
			{
				SnmpDisplayStringType *stringType = ( SnmpDisplayStringType * ) value ;
				t_Community = t_QualifierCommunity = stringType->GetValue () ;

				if ( t_QualifierCommunity )
				{
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
	}

	if ( status & ! t_Community )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
		else
		{
			t_Community = WBEM_AGENTCOMMUNITYNAME ;
		}
	}

	if ( status )
	{
		agentReadCommunityName = UnicodeStringDuplicate ( t_Community ) ;
	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierCommunity ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentReadCommunityName ( %s ) " , agentReadCommunityName 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentWriteCommunityName ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentWriteCommunityName 
)
{
	BOOL status = TRUE ;
	agentWriteCommunityName = NULL ;
	BSTR t_Community = NULL ;
	wchar_t *t_QualifierCommunity = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentWriteCommunityName" ) ;
			}
		}
	}

	if ( status & ! t_Community )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
			{
				SnmpDisplayStringType *stringType = ( SnmpDisplayStringType * ) value ;
				t_Community = t_QualifierCommunity = stringType->GetValue () ;

				if ( t_QualifierCommunity )
				{
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentWriteCommunityName" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentWriteCommunityName" ) ;
			}

		}
	}

	if ( status & ! t_Community )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentWriteCommunityName" ) ;
			}
		}
		else
		{
			t_Community = WBEM_AGENTCOMMUNITYNAME ;
		}
	}

	if ( status )
	{
		agentWriteCommunityName = UnicodeStringDuplicate ( t_Community ) ;
	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierCommunity ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentWriteCommunityName ( %s ) " , agentWriteCommunityName 
	) ;
)
	}

	return status ;
}


BOOL SnmpResponseEventObject :: GetAgentRetryCount ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentRetryCount 
)
{
	BOOL status = TRUE ;
	agentRetryCount = 1 ;
	BOOL t_RetryCount = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYCOUNT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryCount = TRUE ;
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	if ( status & ! t_RetryCount )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTRETRYCOUNT ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
			{
				SnmpIntegerType *integerType = ( SnmpIntegerType * ) value ;
				agentRetryCount = integerType->GetValue () ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	if ( status & ! t_RetryCount )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYCOUNT , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentRetryCount ( %ld ) " , agentRetryCount 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentRetryTimeout( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentRetryTimeout 
)
{
	BOOL status = TRUE ;
	agentRetryTimeout = 0 ;
	BOOL t_RetryTimeout = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYTIMEOUT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryTimeout = TRUE ;
 
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	if ( status & ! t_RetryTimeout )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTRETRYTIMEOUT ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
			{
				SnmpIntegerType *integerType = ( SnmpIntegerType * ) value ;
				agentRetryTimeout = integerType->GetValue () ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	if ( status & ! t_RetryTimeout )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYTIMEOUT , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentRetryTimeout ( %ld ) " , agentRetryTimeout 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentMaxVarBindsPerPdu ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentVarBindsPerPdu 
)
{
	BOOL status = TRUE ;
	agentVarBindsPerPdu = 0 ;
	BOOL t_VarBinds = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTVARBINDSPERPDU , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_VarBinds = TRUE ;
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	if ( status & ! t_VarBinds )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTVARBINDSPERPDU ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
			{
				SnmpIntegerType *integerType = ( SnmpIntegerType * ) value ;
				agentVarBindsPerPdu = integerType->GetValue () ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	if ( status & ! t_VarBinds )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTVARBINDSPERPDU , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{		
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentVarBindsPerPdu ( %ld ) " , agentVarBindsPerPdu 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentFlowControlWindowSize ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentFlowControlWindowSize 
)
{
	BOOL status = TRUE ;
	agentFlowControlWindowSize = 0 ;
	BOOL t_WindowSize = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_WindowSize = TRUE ;
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	if ( status & ! t_WindowSize )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
			{
				SnmpIntegerType *integerType = ( SnmpIntegerType * ) value ;
				agentFlowControlWindowSize = integerType->GetValue () ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	if ( status & ! t_WindowSize )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentFlowControlWindowSize ( %ld ) " , agentFlowControlWindowSize 
	) ;
)
	}

	return status ;
}

SnmpInstanceClassObject :: SnmpInstanceClassObject ( 

	const SnmpInstanceClassObject & snmpInstanceClassObject 

) : SnmpClassObject ( snmpInstanceClassObject ) 
{
}

SnmpInstanceClassObject :: SnmpInstanceClassObject (
	SnmpResponseEventObject *parentOperation
) :	SnmpClassObject ( parentOperation )
{
}

SnmpInstanceClassObject :: ~SnmpInstanceClassObject ()
{
}

BOOL SnmpInstanceClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{
	BOOL status = TRUE ;

	snmpVersion = m_parentOperation->SetAgentVersion ( a_errorObject ) ;

	if ( snmpVersion == 0 )
	{
		status = FALSE ;
	}

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		status = CheckProperty ( a_errorObject , property ) ;
	}

	if ( ! m_accessible ) 
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOREADABLEPROPERTIES ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Class must contain at least one property which is accessible" ) ;
	}

	return status ;
}

BOOL SnmpInstanceClassObject :: CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property )
{
	BOOL status = TRUE ;

	if ( ( snmpVersion == 1 ) && property->IsSNMPV1Type () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}
	else if ( ( snmpVersion == 2 ) && property->IsSNMPV2CType () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}

	return status ;
}

SnmpInstanceResponseEventObject :: SnmpInstanceResponseEventObject ( 

	CImpPropProv *providerArg ,
	IWbemContext *a_Context 

) : SnmpResponseEventObject ( providerArg , a_Context ) ,
	classObject ( NULL ) ,
	instanceObject ( NULL ) ,
#if 0
	instanceAccessObject ( NULL ) ,
#endif
	session ( NULL ) ,
	operation ( NULL ) ,
	m_PartitionSet ( NULL ) ,
#pragma warning (disable:4355)
	snmpObject ( this )
#pragma warning (default:4355)
{
}

SnmpInstanceResponseEventObject :: ~SnmpInstanceResponseEventObject ()
{
#if 0
	if ( instanceAccessObject )
		instanceAccessObject->Release ();
#endif

	if ( instanceObject ) 
		instanceObject->Release () ;

	if ( classObject ) 
		classObject->Release () ;
}

BOOL SnmpInstanceResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	IWbemQualifierSet *namespaceQualifierObject = NULL ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &namespaceQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		wchar_t *agentAddress = NULL ;
		wchar_t *agentTransport = NULL ;
		wchar_t *agentReadCommunityName = NULL ;
		ULONG agentRetryCount ;
		ULONG agentRetryTimeout ;
		ULONG agentMaxVarBindsPerPdu ;
		ULONG agentFlowControlWindowSize ;

		status = SetAgentVersion ( m_errorObject ) ;
		if ( status ) status = GetAgentAddress ( m_errorObject , namespaceQualifierObject , agentAddress ) ;
		if ( status ) status = GetAgentTransport ( m_errorObject , namespaceQualifierObject , agentTransport ) ;
		if ( status ) status = GetAgentReadCommunityName ( m_errorObject , namespaceQualifierObject , agentReadCommunityName ) ;
		if ( status ) status = GetAgentRetryCount ( m_errorObject , namespaceQualifierObject , agentRetryCount ) ;
		if ( status ) status = GetAgentRetryTimeout ( m_errorObject , namespaceQualifierObject , agentRetryTimeout ) ;
		if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , namespaceQualifierObject , agentMaxVarBindsPerPdu ) ;
		if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , namespaceQualifierObject , agentFlowControlWindowSize ) ;

		if ( status )
		{
			char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
			if ( dbcsAgentAddress )
			{
				char *dbcsAgentReadCommunityName = UnicodeToDbcsString ( agentReadCommunityName ) ;
				if ( dbcsAgentReadCommunityName )
				{
					if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
					{
						char *t_Address ;
						if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
						{
							t_Address = provider->GetIpAddressValue () ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else
							{
								if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
								{
									t_Address = dbcsAgentAddress ;
								}
								else							
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;
								}
							}
						}

						if ( status )
						{
							if ( m_agentVersion == 1 )
							{
								session = new SnmpV1OverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else if ( m_agentVersion == 2 )
							{
								session = new SnmpV2COverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

							}
						}
					}
					else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
					{
						if ( ! SnmpTransportIpxAddress :: ValidateAddress ( dbcsAgentAddress  ) )
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
						}

						if ( status )
						{
							if ( m_agentVersion == 1 )
							{
								session = new SnmpV1OverIpx (

									dbcsAgentAddress ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else if ( m_agentVersion == 2 )
							{
								session = new SnmpV2COverIpx (

									dbcsAgentAddress  ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

							}
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}

					delete [] dbcsAgentReadCommunityName ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentReadCommunityName" ) ;
				}

				delete [] dbcsAgentAddress ;

				if ( status )
				{
					operation = new AutoRetrieveOperation(*session,this);
					operation->Send () ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" TransportInformation settings invalid"
	) ;
)
		}

		delete [] agentTransport ;
		delete [] agentAddress ;
		delete [] agentReadCommunityName ;

		namespaceQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get class qualifier set" ) ;
	}

	return status ;
}

SnmpInstanceEventObject :: SnmpInstanceEventObject ( 

	CImpPropProv *providerArg , 
	BSTR ClassArg ,
	IWbemContext *a_Context 

) : SnmpInstanceResponseEventObject ( providerArg , a_Context ) , Class ( NULL )
{
	Class = SysAllocString ( ClassArg ) ;
}

SnmpInstanceEventObject :: ~SnmpInstanceEventObject ()
{
	SysFreeString ( Class ) ;
}

BOOL SnmpInstanceEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;
	IWbemServices *t_Serv = provider->GetServer();

	HRESULT result = WBEM_E_FAILED;
	
	if (t_Serv)
	{
		result = t_Serv->GetObject (

			Class ,
			0  ,
			m_Context ,
			& classObject ,
			NULL 
		) ;

		t_Serv->Release();
	}

	if ( SUCCEEDED ( result ) )
	{
		result = classObject->SpawnInstance ( 0 , & instanceObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			if ( status = GetNamespaceObject ( a_errorObject ) )
			{
				if ( status = snmpObject.Set ( a_errorObject , classObject , FALSE ) )
				{
					if ( status = snmpObject.Check ( a_errorObject ) )
					{
						status = SendSnmp ( a_errorObject ) ;
					}
					else
					{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Check : Class definition did not conform to mapping"
) ;
)
					}
				}
				else
				{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
				}
			}
		}
	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Class definition unknown"
	) ;
)

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return status ;
}

SnmpInstanceAsyncEventObject :: SnmpInstanceAsyncEventObject (

	CImpPropProv *providerArg , 
	BSTR Class ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context 

) : SnmpInstanceEventObject ( providerArg , Class , a_Context ) , notificationHandler ( notify ) , state ( 0 )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: SnmpInstanceAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpInstanceAsyncEventObject :: ~SnmpInstanceAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: ~SnmpInstanceAsyncEventObject ()" 
	) ;
)

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{

// Get Status object

		IWbemClassObject *notifyStatus ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			notifyStatus->Release () ;
		}
		else
		{
			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
		}
	}
	else
	{
		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	ULONG t_Ref = notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpInstanceAsyncEventObject :: ~SnmpInstanceAsyncEventObject ()" 
	) ;
)

}

void SnmpInstanceAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Enumeration Succeeded" 
	) ;
)

	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Enumeration Failed" 
	) ;
)

	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	AutoRetrieveOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	Complete () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

}

void SnmpInstanceAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			BOOL status = Instantiate ( m_errorObject ) ;
			if ( status )
			{
			}
			else
			{
				ReceiveComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpInstanceAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpInstanceAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;
	BOOL status = TRUE ;

	notificationHandler->Indicate ( 1 , & snmpObject ) ;
	if ( ! HasNonNullKeys ( snmpObject ) )
	{
		if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
		}
	}
}

void SnmpInstanceAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject *snmpObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;

	IWbemClassObject *cloneObject ;
	if ( SUCCEEDED ( result = classObject->SpawnInstance ( 0 , & cloneObject ) ) ) 
	{
		WbemSnmpErrorObject errorObject ;
		if ( snmpObject->Get ( errorObject , cloneObject ) )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Object" 
	) ;
)

			notificationHandler->Indicate ( 1 , & cloneObject ) ;
			if ( ! HasNonNullKeys ( cloneObject ) )
			{
				if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
				}
			}			
		}
		else
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Failed to Convert WbemSnmpClassObject to IWbemClassObject" 
	) ;
)
		}
		cloneObject->Release () ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\provinit.cpp ===
#include "precomp.h"
#include <provexpt.h>

#include <provstd.h>
#include <provmt.h>
#include <provtempl.h>
#include <provcont.h>


void ProviderClosedown ()
{
}

void ProviderStartup ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propprov.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the CImpPropProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <cominit.h>
#include <provtree.h>
#include "classfac.h"
#include <provdnf.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "propdel.h"
#include "propinst.h"
#include "propquery.h"
#include "guids.h"

extern void ProviderStartup () ;
extern void ProviderClosedown () ;

void SnmpInstanceDefaultThreadObject::Initialise ()
{
	InitializeCom () ;
}


/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpPropProv::CImpPropProv
// CImpPropProv::~CImpPropProv
//
//***************************************************************************

BOOL CImpPropProv :: s_Initialised = FALSE ;

CImpPropProv::CImpPropProv ()
{
	m_referenceCount = 0 ;
	 
    InterlockedIncrement ( & CPropProvClassFactory :: objectsInProgress ) ;

/*
 * Implementation
 */

	initialised = FALSE ;
	m_InitSink = NULL ;
	parentServer = NULL ;
	server = NULL ;
	thisNamespace = NULL ;
	ipAddressString = NULL ;	
	ipAddressValue = NULL ;	
	m_notificationClassObject = NULL ;
	m_snmpNotificationClassObject = NULL ;
	m_getNotifyCalled = FALSE ;
	m_getSnmpNotifyCalled = FALSE ;
	m_localeId = NULL ;
}

CImpPropProv::~CImpPropProv(void)
{
	delete [] m_localeId ;
	delete [] thisNamespace ;
	delete [] ipAddressString ;

	free ( ipAddressValue ) ;

	if ( parentServer )
		parentServer->Release () ;

	if ( server ) 
		server->Release () ;

	if ( m_InitSink )
		m_InitSink->Release () ;

	if ( m_notificationClassObject )
		m_notificationClassObject->Release () ;

	if ( m_snmpNotificationClassObject )
		m_snmpNotificationClassObject->Release () ;

/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CPropProvClassFactory :: objectsInProgress ) ;

}

//***************************************************************************
//
// CImpPropProv::QueryInterface
// CImpPropProv::AddRef
// CImpPropProv::Release
//
// Purpose: IUnknown members for CImpPropProv object.
//***************************************************************************

STDMETHODIMP CImpPropProv::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
		}	
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
		}

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return S_OK ;
		}
		else
		{
			return E_NOINTERFACE ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}	
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CImpPropProv::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
	    return InterlockedIncrement ( & m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}	
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CImpPropProv::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}	
	catch(...)
	{
		return 0;
	}
}

HRESULT CImpPropProv :: SetServer ( IWbemServices *serverArg ) 
{
	server = serverArg ;
	server->AddRef () ;
	
	//don't change anything but the cloaking...
	return WbemSetProxyBlanket(server,
					RPC_C_AUTHN_DEFAULT,
					RPC_C_AUTHZ_DEFAULT,
					COLE_DEFAULT_PRINCIPAL,
					RPC_C_AUTHN_LEVEL_DEFAULT,
					RPC_C_IMP_LEVEL_DEFAULT,
					NULL,
					EOAC_DYNAMIC_CLOAKING);
}

HRESULT CImpPropProv :: SetParentServer ( IWbemServices *parentServerArg ) 
{
	parentServer = parentServerArg ; 
	parentServer->AddRef () ;
	
	//don't change anything but the cloaking...
	return WbemSetProxyBlanket(parentServer,
					RPC_C_AUTHN_DEFAULT,
					RPC_C_AUTHZ_DEFAULT,
					COLE_DEFAULT_PRINCIPAL,
					RPC_C_AUTHN_LEVEL_DEFAULT,
					RPC_C_IMP_LEVEL_DEFAULT,
					NULL,
					EOAC_DYNAMIC_CLOAKING);
}

IWbemServices *CImpPropProv :: GetServer () 
{ 
	if ( server )
		server->AddRef () ; 

	return server ; 
}

IWbemServices *CImpPropProv :: GetParentServer () 
{ 
	if ( parentServer )
		parentServer->AddRef () ;

	return ( IWbemServices * ) parentServer ; 
}

IWbemClassObject *CImpPropProv :: GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_notificationClassObject )
	{
		m_notificationClassObject->AddRef () ;
	}

	return m_notificationClassObject ; 
}

IWbemClassObject *CImpPropProv :: GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_snmpNotificationClassObject )
	{
		m_snmpNotificationClassObject->AddRef () ;
	}

	return m_snmpNotificationClassObject ; 
}

void CImpPropProv :: SetLocaleId ( wchar_t *localeId )
{
	m_localeId = UnicodeStringDuplicate ( localeId ) ;
}

wchar_t *CImpPropProv :: GetThisNamespace () 
{
	return thisNamespace ; 
}

void CImpPropProv :: SetThisNamespace ( wchar_t *thisNamespaceArg ) 
{
	thisNamespace = UnicodeStringDuplicate ( thisNamespaceArg ) ; 
}

BOOL CImpPropProv:: FetchSnmpNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx 
)
{
	m_snmpNotificationLock.Lock();
	BOOL status = TRUE ;

	if ( m_getSnmpNotifyCalled )
	{
		if ( ! m_snmpNotificationClassObject )
			status = FALSE ;
	}
	else
	{
		m_getSnmpNotifyCalled = TRUE ;
		BSTR t_Class = SysAllocString ( WBEM_CLASS_SNMPNOTIFYSTATUS ) ;

		HRESULT result = server->GetObject (

			t_Class ,
			0 ,
			a_Ctx,
			& m_snmpNotificationClassObject ,
			NULL 
		) ;

		SysFreeString ( t_Class ) ;

		if ( ! SUCCEEDED ( result ) )
		{
			status = FALSE ;
			m_snmpNotificationClassObject = NULL ;
		}
	}

	m_snmpNotificationLock.Unlock();
	return status ;
}

BOOL CImpPropProv:: FetchNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx
)
{
	m_notificationLock.Lock();
	BOOL status = TRUE ;

	if ( m_getNotifyCalled )
	{
		if ( ! m_notificationClassObject )
			status = FALSE ;
	}
	else
	{
		m_getNotifyCalled = TRUE ;

		BSTR t_Class = SysAllocString ( WBEM_CLASS_EXTENDEDSTATUS ) ;

		HRESULT result = server->GetObject (

			t_Class ,
			0 ,
			a_Ctx ,
			& m_notificationClassObject ,
			NULL 
		) ;

        SysFreeString ( t_Class ) ;

		if ( ! SUCCEEDED ( result ) )
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;
			m_notificationClassObject = NULL;
		}
	}

	m_notificationLock.Unlock();
	return status ;
}

BOOL CImpPropProv::AttachParentServer ( 

	WbemSnmpErrorObject &a_errorObject , 
	BSTR ObjectPath, 
	IWbemContext *pCtx
)
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpPropProv::AttachParentServer ( (%s) )" ,
		ObjectPath
	) ;
)

	BOOL status = TRUE ;

	IWbemLocator *locator = NULL ;
	IWbemServices *t_server = NULL ;

// Get Parent Namespace Path

	WbemNamespacePath *namespacePath = GetNamespacePath () ;

	ULONG count = namespacePath->GetCount () ;
	wchar_t *path = NULL ;

	if ( namespacePath->GetServer () )
	{
		path = UnicodeStringDuplicate ( L"\\\\" ) ;
		wchar_t *concatPath = UnicodeStringAppend ( path , namespacePath->GetServer () ) ;
		delete [] path ;
		path = concatPath ;
	}

	if ( ! namespacePath->Relative () )
	{
		wchar_t *concatPath = UnicodeStringAppend ( path , L"\\" ) ;
		delete [] path ;
		path = concatPath ;
	}

	ULONG pathIndex = 0 ;		
	wchar_t *pathComponent ;
	namespacePath->Reset () ;
	while ( ( pathIndex < count - 1 ) && ( pathComponent = namespacePath->Next () ) ) 
	{
		wchar_t *concatPath = UnicodeStringAppend ( path , pathComponent ) ;
		delete [] path ;
		path = concatPath ;
		if ( pathIndex < count - 2 )
		{
			concatPath = UnicodeStringAppend ( path , L"\\" ) ;
			delete [] path ;
			path = concatPath ;
		}

		pathIndex ++ ;
	}

	if ( pathComponent = namespacePath->Next () )
	{
		SetThisNamespace ( pathComponent ) ; 
	}

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Calling ConnectServer ( (%s) )" ,
		path
	) ;
)

// Connect to parent namespace
	HRESULT result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemLocator ,
		( void ** )  & locator
	);

	if ( SUCCEEDED ( result ) )
	{
		IWbemClassObject *errorObject = NULL ;

		result = locator->ConnectServer (

			path ,
			NULL,
			NULL,
			NULL ,
			0 ,
			NULL,
			pCtx,
			( IWbemServices ** ) & t_server 
		) ;

		if ( errorObject )
			errorObject->Release () ;

		if ( SUCCEEDED ( result ) )
		{
// Mark this interface pointer as "critical"

			result = SetParentServer ( t_server ) ;
			t_server->Release () ;

			if ( FAILED ( result ) && result != E_NOINTERFACE ) //implies there is no prxy security - inproc.
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
				a_errorObject.SetMessage ( L"Failed to secure proxy to this namespace's parent namespace" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetMessage ( L"Failed to connect to this namespace's parent namespace" ) ;
		}

		locator->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemLocator" ) ;
	}

	delete [] path ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpPropProv::AttachParentServer ( (%s) ) with result" ,
		ObjectPath ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

BOOL CImpPropProv::ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpPropProv::ObtainCachedIpAddress ()"
	) ;
)

	BOOL status = TRUE ;

	IWbemClassObject *namespaceObject = NULL ;

	wchar_t *objectPathPrefix = UnicodeStringAppend ( WBEM_NAMESPACE_EQUALS , GetThisNamespace () ) ;
	wchar_t *objectPath = UnicodeStringAppend ( objectPathPrefix , WBEM_NAMESPACE_QUOTE ) ;

	delete [] objectPathPrefix ;

	BSTR t_Path = SysAllocString ( objectPath ) ;

	HRESULT result = parentServer->GetObject ( 

		t_Path ,
		0 ,
		NULL,
		&namespaceObject ,
		NULL 
	) ;

	SysFreeString ( t_Path ) ;

	delete [] objectPath ;

	if ( SUCCEEDED ( result ) )
	{
		IWbemQualifierSet *classQualifierObject ;
		result = namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( & variant ) ;

			LONG attributeType ;
			result = classQualifierObject->Get ( 

				WBEM_QUALIFIER_AGENTTRANSPORT , 
				0,	
				&variant ,
				& attributeType
			) ;

			if ( SUCCEEDED ( result ) )
			{
				if ( variant.vt == VT_BSTR ) 
				{
					if ( _wcsicmp ( variant.bstrVal , L"IP" ) == 0 )
					{
						VARIANT variant ;
						VariantInit ( & variant ) ;

						LONG attributeType ;
						result = classQualifierObject->Get ( 

							WBEM_QUALIFIER_AGENTADDRESS , 
							0,	
							&variant ,
							&attributeType
						) ;

						if ( SUCCEEDED ( result ) )
						{
							if ( variant.vt == VT_BSTR ) 
							{
								ipAddressString = UnicodeToDbcsString ( variant.bstrVal ) ;
								if ( ipAddressString )
								{
								
									SnmpTransportIpAddress transportAddress ( 
			
										ipAddressString , 
										SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE 
									) ;

									if ( transportAddress () )
									{	
										ipAddressValue = _strdup ( transportAddress.GetAddress () ) ;
									}
									else
									{
										delete [] ipAddressString ;
										ipAddressString = NULL ;

	/*
	 *	Invalid Transport Address.
	 */

										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_errorObject.SetMessage ( L"Invalid value for qualifier: AgentAddress" ) ;
									}
								}
								else
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
								}
 							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Type Mismatch for qualifier: AgentAddress" ) ;
							}
						}

						VariantClear ( &variant ) ;
					}
					else if ( _wcsicmp ( variant.bstrVal , L"IPX" ) == 0 )
					{
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Invalid value for qualifier: AgentAddress" ) ;

					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type Mismatch for qualifier: AgentAddress" ) ;
				}

				VariantClear ( & variant );
			}
			else
			{
/*
 *	Don't need transport agent address
 */
			}

			
		}

		classQualifierObject->Release () ;

		namespaceObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to obtain namespace object" ) ;
	}

DebugMacro2( 

	wchar_t *t_UnicodeString = ipAddressValue ? DbcsToUnicodeString ( ipAddressValue ) : NULL ;

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from CImpPropProv::ObtainCachedIpAddress () with IP Address (%s)",
		t_UnicodeString ? t_UnicodeString : L"NULL"
	) ;

	delete [] t_UnicodeString ;
)

	return status ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CImpPropProv :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpPropProv::GetObjectAsync ( (%s) )" ,
			ObjectPath
		) ;
)

		if (SUCCEEDED(result))
		{
	/*
	 * Create Asynchronous GetObjectByPath object
	 */

			SnmpGetAsyncEventObject aSyncEvent ( this , ObjectPath , pHandler , pCtx ) ;

			aSyncEvent.Process () ;

			aSyncEvent.Wait ( TRUE ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning from CImpPropProv::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
			ObjectPath ,
			result 
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpPropProv :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

 HRESULT CImpPropProv :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

SCODE CImpPropProv :: CreateClassEnumAsync (

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpPropProv::PutInstanceAsync ()" 
		) ;
)

		if (SUCCEEDED(result))
		{
	/*
	 * Create Synchronous UpdateInstance object
	 */

			SnmpUpdateAsyncEventObject aSyncEvent ( this , pInst , pHandler , pCtx , lFlags ) ;

			aSyncEvent.Process () ;

			aSyncEvent.Wait ( TRUE ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning from CImpPropProv::PutInstanceAsync () with Result = (%lx)" ,
			result 
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpPropProv :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT CImpPropProv :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
		return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

#if 0
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT t_Result = WbemCoImpersonateClient();

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpPropProv::DeleteInstance ()" 
		) ;
) 

		if (SUCCEEDED(t_Result))
		{
	/*
	 * Create Asynchronous GetObjectByPath object
	 */

			DeleteInstanceAsyncEventObject t_AsyncEvent ( this , ObjectPath , lFlags , pHandler , pCtx ) ;

			t_AsyncEvent.Process () ;

			t_AsyncEvent.Wait ( TRUE ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning from CImpPropProv::DeleteInstanceAsync ( (%s) ) with Result = (%lx)" ,
			ObjectPath ,
			t_Result 
		) ;
)
		return t_Result ;

	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

#endif


HRESULT CImpPropProv :: CreateInstanceEnum ( 

	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: CreateInstanceEnumAsync (

 	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpPropProv::CreateInstanceEnumAsync ( (%s) )" ,
			Class
		) ;
)

		if (SUCCEEDED(result))
		{
	/*
	 * Create Synchronous Enum Instance object
	 */

			SnmpInstanceAsyncEventObject aSyncEvent ( this , Class , pHandler , pCtx ) ;

			aSyncEvent.Process () ;

			aSyncEvent.Wait ( TRUE ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"ReturningFrom CImpPropProv::CreateInstanceEnum ( (%s) ) with Result = (%lx)" ,
			Class ,
			result
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpPropProv :: ExecQuery ( 

	const BSTR QueryLanguage, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: ExecQueryAsync ( 
		
	const BSTR QueryFormat, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpPropProv::ExecQueryAsync ( this = ( %lx ) , (%s),(%s) )" ,
			this ,
			QueryFormat ,
			Query 
		) ;
)

		if (SUCCEEDED(result))
		{
	/*
	 * Create Synchronous Enum Instance object
	 */

			pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, 0, NULL, NULL);

			SnmpQueryAsyncEventObject aSyncEvent ( this , QueryFormat , Query , pHandler , pCtx ) ;

			aSyncEvent.Process () ;

			aSyncEvent.Wait ( TRUE ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning from CImpPropProv::ExecqQueryAsync ( (%s),(%s) ) with Result = (%lx)" ,
			QueryFormat,
			Query,
			result 
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpPropProv :: ExecNotificationQuery ( 

	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT CImpPropProv :: ExecNotificationQueryAsync ( 
            
	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpPropProv :: ExecMethod( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT STDMETHODCALLTYPE CImpPropProv :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
       
HRESULT CImpPropProv :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient(); //Impersomate cimom - LocalSystem!
		
		if (SUCCEEDED(result))
		{
			BOOL bEnteredCritSec = FALSE;
			BOOL status = TRUE ;

			try
			{
				EnterCriticalSection ( & s_ProviderCriticalSection ) ;
				bEnteredCritSec = TRUE;

				if ( ! CImpPropProv :: s_Initialised )
				{
					ProviderStartup () ;

					SnmpThreadObject :: Startup () ;
					try
					{
						SnmpDebugLog :: Startup () ;
					}
					catch ( ... )
					{
						// we do not want to left s_Reference count up
						SnmpThreadObject :: Closedown () ;
						ProviderClosedown () ;
						throw;
					}

					try
					{
						status = SnmpClassLibrary :: Startup () ;
					}
					catch ( ... )
					{
						// we do not want to left s_Reference count up
						SnmpDebugLog :: Closedown () ;
						SnmpThreadObject :: Closedown () ;

						ProviderClosedown () ;

						throw;
					}

					if ( status == FALSE )
					{
						SnmpDebugLog :: Closedown () ;
						SnmpThreadObject :: Closedown () ;
						
						ProviderClosedown () ;
					}
					else
					{
	 					CImpPropProv :: s_Initialised = TRUE ;
					}
				}

				LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
				bEnteredCritSec = FALSE;
			}
			catch ( ... )
			{
				if ( bEnteredCritSec ) 
				{
					LeaveCriticalSection ( & s_ProviderCriticalSection ) ;
					bEnteredCritSec = FALSE;
				}

				throw;
			}

			WbemSnmpErrorObject errorObject ;
			result = SetServer(pCIMOM) ;

			if ( FAILED ( result ) && result != E_NOINTERFACE ) //implies there is no prxy security - inproc.
			{
				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
				errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
				errorObject.SetMessage ( L"Failed to secure proxy to this namespace" ) ;
			}

			namespacePath.SetNamespacePath ( pszNamespace ) ;

			wchar_t *t_ObjectPath = namespacePath.GetNamespacePath () ;

			status = AttachParentServer ( 

				errorObject , 
				t_ObjectPath ,
				pCtx 
			) ;

			delete [] t_ObjectPath ;

			if ( status )
			{
				ObtainCachedIpAddress ( errorObject ) ;
			}
			else
			{
				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemServicesr" ) ;
			}

			status = FetchSnmpNotificationObject ( errorObject , pCtx ) ;
			status = FetchNotificationObject ( errorObject , pCtx ) ;

			result = errorObject.GetWbemStatus () ;

			pInitSink->SetStatus ( (result == WBEM_NO_ERROR) ? (LONG)WBEM_S_INITIALIZED : (LONG)WBEM_E_FAILED , 0 ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning From CImpPropProv::Initiliaze ( this = ( %lx ) ) with Result = (%lx)" , 
			this , result
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT STDMETHODCALLTYPE CImpPropProv::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpSetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "snmpget.h"
#include "snmpset.h"
#include "snmpqset.h"

SnmpSetClassObject :: SnmpSetClassObject ( SnmpResponseEventObject *parentOperation ) :
												SnmpClassObject ( parentOperation )	,
												m_WritableSetCount ( 0 ) , 
												m_WritableSet ( NULL ) , 
												m_RowStatusSpecified ( FALSE ) , 
												m_RowStatusPresent ( FALSE ) 
{
}

SnmpSetClassObject :: ~SnmpSetClassObject ()
{
	if ( m_WritableSetCount )
	{
		for ( DWORD t_Index = 0 ; t_Index < m_WritableSetCount ; t_Index ++ )
		{
			delete [] (m_WritableSet[t_Index]) ;
			m_WritableSet[t_Index] = NULL ;
		}

		delete [] m_WritableSet ;
		m_WritableSet = NULL ;
		m_WritableSetCount = 0 ;
	}
}

void SnmpSetClassObject :: SetWritableSet ( 

	wchar_t **a_WritableSet ,
	ULONG a_WritableSetCount 
) 
{
	if ( m_WritableSetCount )
	{
		for ( DWORD t_Index = 0 ; t_Index < m_WritableSetCount ; t_Index ++ )
		{
			delete [] (m_WritableSet[t_Index]) ;
			m_WritableSet[t_Index] = NULL ;
		}

		delete [] m_WritableSet;
		m_WritableSet = NULL ;
		m_WritableSetCount = 0 ;
	}

	m_WritableSet = a_WritableSet ;
	m_WritableSetCount = a_WritableSetCount ;
}

BOOL SnmpSetClassObject :: IsWritable ( WbemSnmpProperty *a_Property )
{
	if ( a_Property )
	{
		if ( ! a_Property->GetTag () )
		{
			BOOL t_Status = ( GetSnmpVersion () == 1 ) && ( a_Property->IsSNMPV1Type () ) ;
			t_Status = t_Status || ( ( GetSnmpVersion () == 2 ) && ( a_Property->IsSNMPV2CType () ) ) ;
			if ( t_Status )
			{
				if ( a_Property->IsVirtualKey () == FALSE )
				{
					if ( a_Property->IsWritable () )
					{
						if ( m_WritableSetCount )
						{
							for ( DWORD t_Index = 0 ; t_Index < m_WritableSetCount; t_Index ++ )
							{
								if ( _wcsicmp ( a_Property->GetName () , m_WritableSet [ t_Index ] ) == 0 )
								{
									return TRUE ;
								}
							}
						}
						else
						{
							return TRUE ;
						}
					}
				}
			}
		}
	}

	return FALSE ;
}

ULONG SnmpSetClassObject :: NumberOfWritable ()
{
	WbemSnmpProperty *t_CurrentProperty = GetCurrentProperty () ;

	ULONG t_NumberOfWritable = 0 ;

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( property = NextProperty () )
	{
		if ( ! property->GetTag () )
		{
			BOOL t_Status = ( GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
			t_Status = t_Status || ( ( GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;
			if ( t_Status )
			{
				if ( property->IsVirtualKey () == FALSE )
				{
					if ( property->IsWritable () )
					{
						if ( m_WritableSetCount )
						{
							for ( DWORD t_Index = 0 ; t_Index < m_WritableSetCount; t_Index ++ )
							{
								if ( _wcsicmp ( property->GetName () , m_WritableSet [ t_Index ] ) == 0 )
								{
									t_NumberOfWritable ++ ;
									break ;
								}
							}
						}
						else
						{
							t_NumberOfWritable ++ ;
						}
					}
				}
			}
		}
	}

	GotoProperty ( t_CurrentProperty ) ;

	return t_NumberOfWritable ;
}

BOOL SnmpSetClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{
// Check Class Object, used in a Get Request, for validity

	BOOL status = TRUE ;

	snmpVersion = m_parentOperation->SetAgentVersion ( a_errorObject ) ;

	if ( snmpVersion == 0 )
	{
		status = FALSE ;
	}

#if 0
	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ROWSTATUS ) ;
	if ( qualifier )
	{
		SnmpInstanceType *value = qualifier->GetValue () ;
		if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
		{
			SnmpIntegerType *integerType = ( SnmpIntegerType * ) value ;
			m_RowStatusSpecified = integerType->GetValue () ;
		}
		else
		{
// Problem Here

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Type mismatch for qualifier: RowStatus" ) ;
		}
	}
#endif

// Check all Properties for validity

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		status = CheckProperty ( a_errorObject , property ) ;
	}

	if ( ! m_accessible ) 
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOWRITABLEPROPERTIES ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Class must contain at least one property which is accessible" ) ;
	}

	if ( m_RowStatusSpecified && ! m_RowStatusPresent )
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Class must contain at least one property which is of type RowStatus" ) ;
	}

	return status ;
}

BOOL SnmpSetClassObject :: CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property )
{
// Check property validity

	BOOL status = TRUE ;

	if ( typeid ( *property->GetValue () ) == typeid ( SnmpObjectIdentifierType ) )
	{
		SnmpObjectIdentifierType *t_ObjectIdentifier = ( SnmpObjectIdentifierType * ) property->GetValue () ;
		if ( t_ObjectIdentifier->GetValueLength () < 2 ) 
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for property: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , property->GetName () ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}
	}

	if ( typeid ( *property->GetValue () ) == typeid ( SnmpRowStatusType ) )
	{
		if ( m_RowStatusPresent )
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class contains more than one property with RowStatus type definition" ) ;

		}
		else
		{
			m_RowStatusPresent = TRUE ;
		}
	}

	if ( ( snmpVersion == 1 ) && property->IsSNMPV1Type () && IsWritable ( property ) )
	{
		m_accessible = TRUE ;
	}
	else if ( ( snmpVersion == 2 ) && property->IsSNMPV2CType () && IsWritable  ( property ) )
	{
		m_accessible = TRUE ;
	}

	return status ;
}

SnmpSetResponseEventObject :: SnmpSetResponseEventObject ( 

	CImpPropProv *providerArg , 
	IWbemClassObject *classObjectArg ,
	IWbemContext *a_Context ,
	long lflags

) : SnmpResponseEventObject ( providerArg , a_Context ) , 
	classObject ( NULL ) , 
	session ( NULL ) , 
	operation ( NULL ) , 
	processComplete ( FALSE ) , 
	m_lflags ( lflags ) ,
	state ( 0 ) ,
	m_SnmpTooBig ( FALSE ) ,
	m_VarBindsLeftBeforeTooBig ( 0 ) ,
#pragma warning (disable:4355)
	snmpObject ( this )
#pragma warning (default:4355)
{
	if ( classObjectArg )
	{
		classObject = classObjectArg;
		classObject->AddRef () ;
	}

	if ( a_Context )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		HRESULT t_Result = a_Context->GetValue ( L"__PUT_EXTENSIONS" , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL && t_Variant.boolVal == VARIANT_TRUE ) 
			{
				VARIANT t_ArrayVariant ;
				VariantInit ( & t_ArrayVariant ) ;
				
				HRESULT t_Result = a_Context->GetValue ( L"__PUT_EXT_PROPERTIES" , 0 , & t_ArrayVariant ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_ArrayVariant.vt == ( VT_ARRAY | VT_BSTR ) ) 
					{
						if ( SafeArrayGetDim ( t_ArrayVariant.parray ) == 1 )
						{
							LONG t_Dimension = 1 ; 
							LONG t_Lower ;
							SafeArrayGetLBound ( t_ArrayVariant.parray , t_Dimension , & t_Lower ) ;
							LONG t_Upper ;
							SafeArrayGetUBound ( t_ArrayVariant.parray , t_Dimension , & t_Upper ) ;
							LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

							DWORD t_WritableSetCount = t_Count ;
							wchar_t **t_WritableSet = new wchar_t * [ t_Count ] ;

							for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
							{
								BSTR t_Element ;
								SafeArrayGetElement ( t_ArrayVariant.parray , &t_ElementIndex , & t_Element ) ;

								wchar_t *t_String = new wchar_t [ wcslen ( t_Element ) + 1 ] ;
								wcscpy ( t_String , t_Element ) ;

								t_WritableSet [ t_ElementIndex - t_Lower ] = t_String ;
							}

							snmpObject.SetWritableSet ( t_WritableSet , t_WritableSetCount ) ;
						}
					}

					VariantClear ( & t_ArrayVariant ) ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}
}

SnmpSetResponseEventObject :: ~SnmpSetResponseEventObject ()
{
	if ( classObject ) 
		classObject->Release () ;
}

BOOL SnmpSetResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject , const ULONG &a_NumberToSend )
{
	m_SnmpTooBig = FALSE ;

	BOOL status = TRUE ;

	IWbemQualifierSet *classQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		wchar_t *agentAddress = NULL ;
		wchar_t *agentTransport = NULL ;
		wchar_t *agentWriteCommunityName = NULL ;
		ULONG agentRetryCount ;
		ULONG agentRetryTimeout ;
		ULONG agentMaxVarBindsPerPdu ;
		ULONG agentFlowControlWindowSize ;

		status = SetAgentVersion ( m_errorObject  ) ;
		if ( status ) status = GetAgentAddress ( m_errorObject , classQualifierObject , agentAddress ) ;
		if ( status ) status = GetAgentTransport ( m_errorObject , classQualifierObject , agentTransport ) ;
		if ( status ) status = GetAgentWriteCommunityName ( m_errorObject , classQualifierObject , agentWriteCommunityName ) ;
		if ( status ) status = GetAgentRetryCount ( m_errorObject , classQualifierObject , agentRetryCount ) ;
		if ( status ) status = GetAgentRetryTimeout ( m_errorObject , classQualifierObject , agentRetryTimeout ) ;
		if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , agentMaxVarBindsPerPdu ) ;
		if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , classQualifierObject , agentFlowControlWindowSize ) ;

		if ( status )
		{
			char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
			if ( dbcsAgentAddress )
			{
				char *dbcsagentWriteCommunityName = UnicodeToDbcsString ( agentWriteCommunityName ) ;
				if ( dbcsagentWriteCommunityName )
				{
					if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
					{
						char *t_Address ;
						if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
						{
							t_Address = provider->GetIpAddressValue () ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else
							{
								if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
								{
									t_Address = dbcsAgentAddress ;
								}
								else							
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;
								}
							}
						}

						if ( status )
						{
							if ( m_agentVersion == 1 )
							{
								session = new SnmpV1OverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsagentWriteCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else if ( m_agentVersion == 2 )
							{
								session = new SnmpV2COverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsagentWriteCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

							}
						}
					}
					else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
					{
						if ( m_agentVersion == 1 )
						{
							session = new SnmpV1OverIpx (

								dbcsAgentAddress ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else if ( m_agentVersion == 2 )
						{
							session = new SnmpV2COverIpx (

								dbcsAgentAddress  ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}

					delete [] dbcsagentWriteCommunityName ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: agentWriteCommunityName" ) ;
				}

				delete [] dbcsAgentAddress ;

				if ( status )
				{
					operation = new SetOperation(*session,this);
					operation->Send ( a_NumberToSend ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" TransportInformation settings invalid"
	) ;
)
		}

		delete [] agentTransport ;
		delete [] agentAddress ;
		delete [] agentWriteCommunityName ;

		classQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get class qualifier set" ) ;
	}

	return status ;
}

SnmpUpdateEventObject :: SnmpUpdateEventObject (

	CImpPropProv *providerArg , 
	IWbemClassObject *classObject ,
	IWbemContext *a_Context ,
	long lflags 

) : SnmpSetResponseEventObject ( providerArg , classObject , a_Context , lflags ) 
{
}

SnmpUpdateEventObject :: ~SnmpUpdateEventObject ()
{
}

BOOL SnmpUpdateEventObject :: CheckForRowExistence ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateEventObject :: CheckForRowExistence ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)
	BOOL status = TRUE ;

	IWbemQualifierSet *classQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		wchar_t *agentAddress = NULL ;
		wchar_t *agentTransport = NULL ;
		wchar_t *agentWriteCommunityName = NULL ;
		ULONG agentRetryCount ;
		ULONG agentRetryTimeout ;
		ULONG agentMaxVarBindsPerPdu ;
		ULONG agentFlowControlWindowSize ;

		status = SetAgentVersion ( m_errorObject ) ;
		if ( status ) status = GetAgentAddress ( m_errorObject , classQualifierObject , agentAddress ) ;
		if ( status ) status = GetAgentTransport ( m_errorObject , classQualifierObject , agentTransport ) ;
		if ( status ) status = GetAgentWriteCommunityName ( m_errorObject , classQualifierObject , agentWriteCommunityName ) ;
		if ( status ) status = GetAgentRetryCount ( m_errorObject , classQualifierObject , agentRetryCount ) ;
		if ( status ) status = GetAgentRetryTimeout ( m_errorObject , classQualifierObject , agentRetryTimeout ) ;
		if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , agentMaxVarBindsPerPdu ) ;
		if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , classQualifierObject , agentFlowControlWindowSize ) ;

		if ( status )
		{
			char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
			if ( dbcsAgentAddress )
			{
				char *dbcsagentWriteCommunityName = UnicodeToDbcsString ( agentWriteCommunityName ) ;
				if ( dbcsagentWriteCommunityName )
				{
					if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
					{
						char *t_Address ;
						if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
						{
							t_Address = provider->GetIpAddressValue () ;
						}
						else
						{
							t_Address = dbcsAgentAddress ;
						}

						if ( m_agentVersion == 1 )
						{
							session = new SnmpV1OverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentFlowControlWindowSize ,
								agentMaxVarBindsPerPdu 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}

						}
						else if ( m_agentVersion == 2 )
						{
							session = new SnmpV2COverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentFlowControlWindowSize ,
								agentMaxVarBindsPerPdu 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}

						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
					else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
					{
						if ( m_agentVersion == 1 )
						{
							session = new SnmpV1OverIpx (

								dbcsAgentAddress ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentFlowControlWindowSize ,
								agentMaxVarBindsPerPdu 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else if ( m_agentVersion == 2 )
						{
							session = new SnmpV2COverIpx (

								dbcsAgentAddress  ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentFlowControlWindowSize ,
								agentMaxVarBindsPerPdu 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}

					delete [] dbcsagentWriteCommunityName ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: agentWriteCommunityName" ) ;
				}

				delete [] dbcsAgentAddress ;

				if ( status )
				{
					m_QueryOperation = new SetQueryOperation(*session,this);
					m_QueryOperation->Send () ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" TransportInformation settings invalid"
	) ;
)
		}

		delete [] agentTransport ;
		delete [] agentAddress ;
		delete [] agentWriteCommunityName ;

		classQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get class qualifier set" ) ;
	}

	return status ;
}

BOOL SnmpUpdateEventObject :: Update ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateEventObject :: Update ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	IWbemClassObject *t_ClassObject = NULL ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	t_WBEM_result = classObject->Get ( WBEM_PROPERTY_CLASS , 0 , &variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_WBEM_result ) )
	{
		IWbemServices *t_Serv = provider->GetServer();
		HRESULT result = WBEM_E_FAILED;

		if (t_Serv)
		{	
			result = t_Serv->GetObject (

				variant.bstrVal ,
				0 ,
				m_Context ,
				& t_ClassObject ,
				NULL
			) ;

			t_Serv->Release();
		}

		VariantClear ( & variant ) ;


		if ( SUCCEEDED ( result ) )
		{
			if ( status = GetNamespaceObject ( a_errorObject ) )
			{
				status = snmpObject.Set ( a_errorObject , t_ClassObject , FALSE ) ;
				if ( status )
				{
					status = snmpObject.Merge ( a_errorObject , GetClassObject () ) ;
					if ( status )
					{
						status = snmpObject.Check ( a_errorObject ) ;
						if ( status )
						{
							status = HandleSnmpVersion ( a_errorObject ) ;
						}
						else
						{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Check : Class definition did not conform to mapping"
) ;
)

						}
					}
					else
					{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Merge : Class definition did not conform to mapping"
) ;
)
					}
				}
				else
				{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
				}
			}

			t_ClassObject->Release () ;
		}
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateEventObject :: Update ( WbemSnmpErrorObject &a_errorObject ) with Result (%lx)" ,
		a_errorObject.GetWbemStatus () 
	) ;
)
	return status ;
}

SnmpUpdateAsyncEventObject :: SnmpUpdateAsyncEventObject (

	CImpPropProv *providerArg , 
	IWbemClassObject *classObject ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context ,
	long lflags 

) : SnmpUpdateEventObject ( providerArg , classObject , a_Context , lflags ) , notificationHandler ( notify ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SnmpUpdateAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpUpdateAsyncEventObject :: ~SnmpUpdateAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: ~SnmpUpdateAsyncEventObject ()" 
	) ;
)

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
	// Get Status object

		IWbemClassObject *notifyStatus ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			notifyStatus->Release () ;
		}
		else
		{
			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
		}
	}
	else
	{
		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: ~SnmpUpdateAsyncEventObject ()" 
	) ;
)

}

void SnmpUpdateAsyncEventObject :: SetComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SetComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Update Succeeded" 
	) ;
)

		WbemSnmpErrorObject errorObject ;
		IWbemClassObject *classObject = GetClassObject () ;
		BOOL status = snmpObject.Get ( errorObject , classObject ) ;
		if ( status )
		{
			if ( notificationHandler )
			{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Object" 
	) ;
)

				notificationHandler->Indicate ( 1 , & classObject ) ;
			}
		}
		else
		{
		}
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	SetOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	Complete () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: SetComplete ()" 
	) ;
)

}

void SnmpUpdateAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			BOOL status = Update ( m_errorObject ) ;
			if ( status )
			{
			}
			else
			{
				ReceiveComplete () ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: Process ()" 
	) ;
)

}

BOOL SnmpUpdateEventObject :: HandleSnmpVersion ( WbemSnmpErrorObject &a_ErrorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateEventObject :: HandleSnmpVersion ( WbemSnmpErrorObject &a_ErrorObject )" 
	) ;
)

	BOOL t_Status = FALSE ;

	if ( snmpObject.RowStatusSpecified () )
	{
		if ( snmpObject.GetSnmpVersion () == 1 )
		{
			if ( WBEM_FLAG_CREATE_OR_UPDATE == ( m_lflags & WBEM_FLAG_CREATE_OR_UPDATE ) )
			{
				t_Status = Create_Or_Update () ;
			}
			else if ( WBEM_FLAG_CREATE_ONLY == ( m_lflags & WBEM_FLAG_CREATE_ONLY ) )
			{
				t_Status = Create_Only () ;
			}
			else if ( WBEM_FLAG_UPDATE_ONLY == ( m_lflags & WBEM_FLAG_UPDATE_ONLY ) )
			{
				t_Status = Update_Only () ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			if ( WBEM_FLAG_CREATE_OR_UPDATE == ( m_lflags & WBEM_FLAG_CREATE_OR_UPDATE ) )
			{
				t_Status = Create_Or_Update () ;
			}
			else if ( WBEM_FLAG_CREATE_ONLY == ( m_lflags & WBEM_FLAG_CREATE_ONLY ) )
			{
				t_Status = Create_Only () ;
			}
			else if ( WBEM_FLAG_UPDATE_ONLY == ( m_lflags & WBEM_FLAG_UPDATE_ONLY ) )
			{
				t_Status = Update_Only () ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}	
	}
	else
	{
		if ( WBEM_FLAG_CREATE_OR_UPDATE == ( m_lflags & WBEM_FLAG_CREATE_OR_UPDATE ) )
		{
			state = 0 ;
			t_Status = SendSnmp ( a_ErrorObject ) ;
		}
		else if ( WBEM_FLAG_CREATE_ONLY == ( m_lflags & WBEM_FLAG_CREATE_ONLY ) )
		{
			state = 1 ;
			t_Status = CheckForRowExistence ( a_ErrorObject ) ;
		}
		else if ( WBEM_FLAG_UPDATE_ONLY == ( m_lflags & WBEM_FLAG_UPDATE_ONLY ) )
		{
			state = 2 ;
			t_Status = CheckForRowExistence ( a_ErrorObject ) ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}

	return t_Status ;
}

void SnmpUpdateAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	BOOL t_Status = TRUE ;

	switch ( state )
	{
		case 0:
		{
/*
 *	V1 SMI - CREATE_OR_UPDATE
 */

			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;
			}

			SetComplete () ;
			return ;
		}
		break ;

		case 1:
		{
/*
*	V1 SMI - CREATE_ONLY
*/

			if ( ! SUCCEEDED ( m_errorObject.GetStatus () ) )
			{
				SetComplete () ;
				return ;
			}

			state = 3 ;
			if ( m_QueryOperation->GetRowReceived () == 0 )
			{
				t_Status = SendSnmp ( m_errorObject ) ;
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_ALREADY_EXISTS  ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_ALREADY_EXISTS ) ;
				m_errorObject.SetMessage ( L"Instance already exists" ) ;

				t_Status = FALSE ;
			}

			if ( m_QueryOperation )
				m_QueryOperation->DestroyOperation () ;

		}
		break ;

		case 2:
		{
/*
*	V1 SMI - UPDATE_ONLY
*/
			if ( ! SUCCEEDED ( m_errorObject.GetStatus () ) )
			{
				SetComplete () ;
				return ;
			}

			state = 3 ;
			if ( m_QueryOperation->GetRowReceived () )
			{
				t_Status = SendSnmp ( m_errorObject ) ;
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				m_errorObject.SetMessage ( L"Instance does not exist" ) ;

				t_Status = FALSE ;
			}

			if ( m_QueryOperation )
				m_QueryOperation->DestroyOperation () ;

		}
		break ;

		case 3:
		{
			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;
			}
			
			t_Status = FALSE ;
		}
		break ;

		case 4:
		{
/*
*	V2C SMI ROWSTATUS - CREATE_OR_UPDATE
*/

			m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE  ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"UNKNOWN STATE TRANSITION" ) ;

			t_Status = FALSE ;

		}
		break ;

		case 10:
		{
/*
 *	V2C SMI ROWSTATUS - CREATE_ONLY
 */

			WbemSnmpProperty *t_Property ;
			snmpObject.ResetProperty () ;
			while ( t_Property = snmpObject.NextProperty () )
			{
				t_Property->SetTag ( FALSE ) ;
			}

			ULONG t_VarBindsPerPdu = 0 ;

			IWbemQualifierSet *classQualifierObject ;
			HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
			if ( SUCCEEDED ( result ) )
			{
				t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
				classQualifierObject->Release () ;
				if ( t_Status ) 
				{
					m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

					ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

	/*
	 * Check to see if we can fit all vbs in to one pdu
	 */
					if ( t_NumberOfWritable < t_VarBindsPerPdu )
					{

	// Does fit
						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							t_NumberOfWritable , 
							SnmpRowStatusType :: SnmpRowStatusEnum :: createAndGo 
						) ;

						state = 11 ;
					}
					else
					{
	// Does not fit, therefore decompose

						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							m_VarBindsLeftBeforeTooBig , 
							SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
						) ;

						state = 12 ;
					}
				}
				else
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"Internal Error" ) ;
					t_Status = FALSE ;
				}
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Internal Error" ) ;
				t_Status = FALSE ;
			}
		}
		break ;

		case 11:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */

/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

				m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					m_VarBindsLeftBeforeTooBig , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
				) ;

				state = 12 ;
			}
			else
			{
/*
 *	We've either succeeded or totally failed.
 */
				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
				}
				else
				{
				}
			}
		}
		break ;

		case 12:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

					m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
					) ;

					state = 12 ;
				}
			}
			else
			{
/*
 *	We've either succeeded or totally failed to set the row as createAndWait
 */

				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
/*
 *	Now send a non row status variable binding list
 */
					ULONG t_VarBindsPerPdu = 0 ;

					IWbemQualifierSet *classQualifierObject ;
					HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
					if ( SUCCEEDED ( result ) )
					{
						t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
						classQualifierObject->Release () ;
						if ( t_Status ) 
						{
							m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

							t_Status = Send_Variable_Binding_List ( 

								snmpObject , 
								m_VarBindsLeftBeforeTooBig
							) ;

							state = 13 ;
						}
						else
						{
							m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
							m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							m_errorObject.SetMessage ( L"Internal Error" ) ;
							t_Status = FALSE ;
						}
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
				else
				{
				}
			}
		}
		break ;

		case 13:
		{
/*
 * check to see if we succeeded in sending a non row status variable binding list
 */

			if ( m_SnmpTooBig )
			{
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
					m_VarBindsLeftBeforeTooBig -- ;

					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
					) ;

					state = 13 ;
				}
			}
			else
			{
				if ( snmpObject.NumberOfWritable () == 0 )
				{
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						0 , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: active 
					) ;

					state = 14 ;
				}
				else
				{
					ULONG t_VarBindsPerPdu = 0 ;

					IWbemQualifierSet *classQualifierObject ;
					HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
					if ( SUCCEEDED ( result ) )
					{
						t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
						classQualifierObject->Release () ;
						if ( t_Status ) 
						{
							m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

							t_Status = Send_Variable_Binding_List ( 

								snmpObject , 
								m_VarBindsLeftBeforeTooBig 
							) ;

							state = 13 ;
						}
						else
						{
							m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
							m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							m_errorObject.SetMessage ( L"Internal Error" ) ;
							t_Status = FALSE ;
						}
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
			}
		}
		break ;

		case 14:
		{
			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;

				t_Status = FALSE ;
			}
			else
			{
				SetComplete () ;
				return ;
			}
		}
		break ;

		case 20:
		{
/*
 *	V2C SMI ROWSTATUS - UPDATE_ONLY
 */

			WbemSnmpProperty *t_Property ;
			snmpObject.ResetProperty () ;
			while ( t_Property = snmpObject.NextProperty () )
			{
				t_Property->SetTag ( FALSE ) ;
			}

			ULONG t_VarBindsPerPdu = 0 ;

			IWbemQualifierSet *classQualifierObject ;
			HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
			if ( SUCCEEDED ( result ) )
			{
				t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
				classQualifierObject->Release () ;
				if ( t_Status ) 
				{
					m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

					ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

	/*
	 * Check to see if we can fit all vbs in to one pdu
	 */
					if ( t_NumberOfWritable < t_VarBindsPerPdu )
					{

	// Does fit
						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							t_NumberOfWritable , 
							SnmpRowStatusType :: SnmpRowStatusEnum :: active 
						) ;

						state = 21 ;
					}
					else
					{
	// Does not fit, therefore decompose

						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							m_VarBindsLeftBeforeTooBig , 
							SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
						) ;

						state = 22 ;
					}
				}
				else
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"Internal Error" ) ;
					t_Status = FALSE ;
				}
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Internal Error" ) ;
				t_Status = FALSE ;
			}
		}
		break ;

		case 21:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */

/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

				m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					m_VarBindsLeftBeforeTooBig , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
				) ;

				state = 22 ;
			}
			else
			{
/*
 *	We've either succeeded or totally failed.
 */
				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
				}
				else
				{
				}
			}
		}
		break ;

		case 22:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

					m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
					) ;

					state = 22 ;
				}
			}
			else
			{
/*
 *	We've either succeeded or totally failed to set the row as notInService
 */

				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
/*
 *	Now send a non row status variable binding list
 */
					ULONG t_VarBindsPerPdu = 0 ;

					IWbemQualifierSet *classQualifierObject ;
					HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
					if ( SUCCEEDED ( result ) )
					{
						t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
						classQualifierObject->Release () ;
						if ( t_Status ) 
						{
							m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

							t_Status = Send_Variable_Binding_List ( 

								snmpObject , 
								m_VarBindsLeftBeforeTooBig
							) ;

							state = 23 ;
						}
						else
						{
							m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
							m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							m_errorObject.SetMessage ( L"Internal Error" ) ;
							t_Status = FALSE ;
						}
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
				else
				{
				}
			}
		}
		break ;

		case 23:
		{
/*
 * check to see if we succeeded in sending a non row status variable binding list
 */

			if ( m_SnmpTooBig )
			{
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
					m_VarBindsLeftBeforeTooBig -- ;

					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
					) ;

					state = 23 ;
				}
			}
			else
			{
				ULONG t_VarBindsPerPdu = 0 ;

				if ( snmpObject.NumberOfWritable () == 0 )
				{
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						0 , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: active 
					) ;

					state = 24 ;
				}
				else
				{
					ULONG t_VarBindsPerPdu = 0 ;

					IWbemQualifierSet *classQualifierObject ;
					HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
					if ( SUCCEEDED ( result ) )
					{
						t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
						classQualifierObject->Release () ;
						if ( t_Status ) 
						{
							m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

							t_Status = Send_Variable_Binding_List ( 

								snmpObject , 
								m_VarBindsLeftBeforeTooBig 
							) ;

							state = 23 ;
						}
						else
						{
							m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
							m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							m_errorObject.SetMessage ( L"Internal Error" ) ;
							t_Status = FALSE ;
						}
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
			}
		}
		break ;

		case 24:
		{
			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;

				t_Status = FALSE ;
			}
			else
			{
				SetComplete () ;
				return ;
			}
		}
		break ;

		case 30:
		{
			if ( ! SUCCEEDED ( m_errorObject.GetStatus () ) )
			{
				SetComplete () ;
				return ;
			}

			if ( m_QueryOperation->GetRowReceived () == 0 )
			{
				t_Status = Update_Only () ;
			}
			else
			{
				t_Status = Create_Only () ;
			}
		}
		break ;

		default:
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE  ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"UNKNOWN STATE TRANSITION" ) ;

			t_Status = FALSE ;
		}
		break ;
	}

	if ( t_Status == FALSE ) 
	{
		SetComplete () ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: ReceiveComplete ()" 
	) ;
)
}

void SnmpUpdateAsyncEventObject :: SnmpTooBig () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SnmpTooBig ()" 
	) ;
)

	m_SnmpTooBig = TRUE ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: SnmpTooBig ()" 
	) ;
)
}

BOOL SnmpUpdateEventObject :: Create_Only ()
{
	BOOL t_Status = TRUE ;

/*
 *	V2C SMI ROWSTATUS - CREATE_ONLY
 */

	WbemSnmpProperty *t_Property ;
	snmpObject.ResetProperty () ;
	while ( t_Property = snmpObject.NextProperty () )
	{
		t_Property->SetTag ( FALSE ) ;
	}

	ULONG t_VarBindsPerPdu = 0 ;

	IWbemQualifierSet *classQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
		classQualifierObject->Release () ;
		if ( t_Status ) 
		{
			m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

			ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

/*
 * Check to see if we can fit all vbs in to one pdu
 */
			if ( t_NumberOfWritable < t_VarBindsPerPdu )
			{

// Does fit
				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					t_NumberOfWritable , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: createAndGo 
				) ;

				state = 7 ;
			}
			else
			{
// Does not fit, therefore decompose

				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					m_VarBindsLeftBeforeTooBig , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
				) ;

				state = 8 ;
			}
		}
		else
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"Internal Error" ) ;
			t_Status = FALSE ;
		}
	}
	else
	{
		m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		m_errorObject.SetMessage ( L"Internal Error" ) ;
		t_Status = FALSE ;
	}


	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Update_Only ()
{
	BOOL t_Status = TRUE ;

/*
 *	V2C SMI ROWSTATUS - UPDATE_ONLY
 */

	WbemSnmpProperty *t_Property ;
	snmpObject.ResetProperty () ;
	while ( t_Property = snmpObject.NextProperty () )
	{
		t_Property->SetTag ( FALSE ) ;
	}

	ULONG t_VarBindsPerPdu = 0 ;

	IWbemQualifierSet *classQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
		classQualifierObject->Release () ;
		if ( t_Status ) 
		{
			m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

			ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

	/*
	 * Check to see if we can fit all vbs in to one pdu
	 */
			if ( t_NumberOfWritable < t_VarBindsPerPdu )
			{

	// Does fit
				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					t_NumberOfWritable , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: active 
				) ;

				state = 7 ;
			}
			else
			{
	// Does not fit, therefore decompose

				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					m_VarBindsLeftBeforeTooBig , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: notInService
				) ;

				state = 8 ;
			}
		}
		else
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"Internal Error" ) ;
			t_Status = FALSE ;
		}
	}
	else
	{
		m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		m_errorObject.SetMessage ( L"Internal Error" ) ;
		t_Status = FALSE ;
	}

	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Create_Or_Update ()
{
	BOOL t_Status = FALSE ;

	state = 30 ;
	t_Status = CheckForRowExistence ( m_errorObject ) ;

	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Send_Variable_Binding_List ( 

	SnmpSetClassObject &a_SnmpSetClassObject , 
	ULONG a_NumberToSend 
)
{
/*
 * Find Property of RowStatus type and make sure we don't send in request
 */

	BOOL t_Status = FALSE ;

	WbemSnmpProperty *t_Property ;

	a_SnmpSetClassObject.ResetProperty () ;
	while ( t_Property = a_SnmpSetClassObject.NextProperty () )
	{
		if ( typeid ( *t_Property->GetValue () ) == typeid ( SnmpRowStatusType ) )
		{
			t_Property->SetTag ( TRUE ) ;
		}
	}

	t_Status = SendSnmp ( m_errorObject , a_NumberToSend ) ;

	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Send_Variable_Binding_List ( 

	SnmpSetClassObject &a_SnmpSetClassObject , 
	ULONG a_NumberToSend ,
	SnmpRowStatusType :: SnmpRowStatusEnum a_SnmpRowStatusEnum
)
{
	BOOL t_Status = FALSE ;

	WbemSnmpProperty *t_Property ;

	a_SnmpSetClassObject.ResetProperty () ;
	while ( t_Property = a_SnmpSetClassObject.NextProperty () )
	{
		if ( typeid ( *t_Property->GetValue () ) == typeid ( SnmpRowStatusType ) )
		{
			t_Property->SetTag ( FALSE ) ;
			SnmpRowStatusType *t_RowStatus = new SnmpRowStatusType ( a_SnmpRowStatusEnum ) ;
			t_Property->SetValue ( t_RowStatus ) ;
		}
	}

	t_Status = SendSnmp ( m_errorObject , a_NumberToSend ) ;

	return t_Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propquery.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <provtree.h>
#include <provdnf.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propinst.h"
#include "propquery.h"
#include "snmpnext.h"

QueryPreprocessor :: QuadState SnmpQueryEventObject :: Compare ( 

	LONG a_Operand1 , 
	LONG a_Operand2 , 
	DWORD a_Operand1Func ,
	DWORD a_Operand2Func ,
	WmiTreeNode &a_OperatorType 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	switch ( a_Operand1Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		t_Status = a_Operand1 == a_Operand2 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		t_Status = a_Operand1 != a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		t_Status = a_Operand1 >= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		t_Status = a_Operand1 <= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		t_Status = a_Operand1 < a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		t_Status = a_Operand1 > a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;

	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	return t_Status ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: Compare ( 

	wchar_t *a_Operand1 , 
	wchar_t *a_Operand2 , 
	DWORD a_Operand1Func ,
	DWORD a_Operand2Func ,
	WmiTreeNode &a_OperatorType 
)
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: Compare ()"
	) ;
)

	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	wchar_t *a_Operand1AfterFunc = NULL ;
	wchar_t *a_Operand2AfterFunc = NULL ; 

	if (a_Operand1)
	{
		switch ( a_Operand1Func ) 
		{
			case WmiValueNode :: WmiValueFunction :: Function_None:
			{
			}
			break ;

			case WmiValueNode :: WmiValueFunction :: Function_Upper:
			{
				ULONG length = wcslen ( a_Operand1 ) ;
				a_Operand1AfterFunc = new wchar_t [ length + 1 ] ;
				for ( ULONG index = 0 ; index < length ; index ++ )
				{
					a_Operand1AfterFunc [ index ] = towupper ( a_Operand1 [ index ] ) ;
				}

				a_Operand1AfterFunc [ index ] = 0 ;
			}
			break ;

			case WmiValueNode :: WmiValueFunction :: Function_Lower:
			{
				ULONG length = wcslen ( a_Operand1 ) ;
				a_Operand1AfterFunc = new wchar_t [ length + 1 ] ;
				for ( ULONG index = 0 ; index < length ; index ++ )
				{
					a_Operand1AfterFunc [ index ] = towlower ( a_Operand1 [ index ] ) ;
				}

				a_Operand1AfterFunc [ index ] = 0 ;
			}
			break ;

			default:
			{
			}
			break ;
		}
	}

	if (a_Operand2)
	{
		switch ( a_Operand2Func ) 
		{
			case WmiValueNode :: WmiValueFunction :: Function_None:
			{
			}
			break ;

			case WmiValueNode :: WmiValueFunction :: Function_Upper:
			{
				ULONG length = wcslen ( a_Operand2 ) ;
				a_Operand2AfterFunc = new wchar_t [ length + 1 ] ;
				for ( ULONG index = 0 ; index < length ; index ++ )
				{
					a_Operand2AfterFunc [ index ] = towupper ( a_Operand2 [ index ] ) ;
				}

				a_Operand2AfterFunc [ index ] = 0 ;
			}
			break ;

			case WmiValueNode :: WmiValueFunction :: Function_Lower:
			{
				ULONG length = wcslen ( a_Operand2 ) ;
				a_Operand2AfterFunc = new wchar_t [ length + 1 ] ;
				for ( ULONG index = 0 ; index < length ; index ++ )
				{
					a_Operand2AfterFunc [ index ] = towlower ( a_Operand2 [ index ] ) ;
				}

				a_Operand2AfterFunc [ index ] = 0 ;
			}
			break ;

			default:
			{
			}
			break ;
		}
	}

	const wchar_t *t_Arg1 = a_Operand1AfterFunc ? a_Operand1AfterFunc : a_Operand1 ;
	const wchar_t *t_Arg2 = a_Operand2AfterFunc ? a_Operand2AfterFunc : a_Operand2 ;

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) == 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) != 0 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) >= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_False ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) <= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) < 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) > 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	delete [] a_Operand1AfterFunc ;
	delete [] a_Operand2AfterFunc ;

	return t_Status ;
}

WmiTreeNode *SnmpQueryEventObject :: AllocTypeNode ( 

	void *a_Context ,
	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if (( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 ))
		{
			if (a_Variant.vt == VT_BSTR)
			{
				t_Node = new WmiStringNode ( 

					a_PropertyName , 
					a_Variant.bstrVal , 
					a_PropertyFunction ,
					a_ConstantFunction ,
					0xFFFFFFFF ,
					a_Parent 
				) ;
			}
			else if (V_VT(&a_Variant) == VT_NULL)
			{
				t_Node = new WmiNullNode (

					a_PropertyName , 
					0xFFFFFFFF ,
					a_Parent 
				);
			}
		}
		else if (( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 ))
		{
			if (a_Variant.vt == VT_I4)
			{
				t_Node = new WmiSignedIntegerNode ( 

					a_PropertyName , 
					a_Variant.lVal , 
					0xFFFFFFFF ,
					a_Parent 
				) ;
			}
			else if (V_VT(&a_Variant) == VT_NULL)
			{
				t_Node = new WmiNullNode (

					a_PropertyName , 
					0xFFFFFFFF ,
					a_Parent 
				);
			}
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
		{
		}
	}
	else
	{
		WbemSnmpProperty *t_Property ;
		if ( t_Property = snmpObject.FindProperty ( a_PropertyName ) )
		{
			t_VarType = t_Property->GetValueVariantEncodedType () ;
		}

		switch ( t_VarType )
		{
			case VT_I4:
			{
				if (a_Variant.vt == VT_I4)
				{
					t_Node = new WmiSignedIntegerNode ( 

						a_PropertyName , 
						a_Variant.lVal , 
						t_Property->GetKeyOrder () ,
						a_Parent 
					) ;
				}
				else if (V_VT(&a_Variant) == VT_NULL)
				{
					t_Node = new WmiNullNode (

						a_PropertyName , 
						t_Property->GetKeyOrder () ,
						a_Parent 
					);
				}
			}
			break ;

			case VT_UI4:
			{
				if ((a_Variant.vt == VT_I4) || (a_Variant.vt == VT_UI4))
				{
					t_Node = new WmiUnsignedIntegerNode ( 

						a_PropertyName , 
						a_Variant.lVal , 
						t_Property->GetKeyOrder () ,
						a_Parent 
					) ;
				}
				else if (V_VT(&a_Variant) == VT_NULL)
				{
					t_Node = new WmiNullNode (

						a_PropertyName , 
						t_Property->GetKeyOrder () ,
						a_Parent 
					);
				}
			}
			break ;

			case VT_BSTR:
			{
				if (a_Variant.vt == VT_BSTR)
				{
					t_Node = new WmiStringNode ( 

						a_PropertyName , 
						a_Variant.bstrVal , 
						a_PropertyFunction ,
						a_ConstantFunction ,
						t_Property->GetKeyOrder () ,
						a_Parent 
					) ;
				}
				else if (V_VT(&a_Variant) == VT_NULL)
				{
					t_Node = new WmiNullNode (

						a_PropertyName , 
						t_Property->GetKeyOrder () ,
						a_Parent 
					);
				}
			}
			break ;

			default:
			{
			}
			break ;
		}
	}

	return t_Node ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: CompareString ( 

	BSTR a_PropertyName , 
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand ,
	bool a_Class 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;
	
	if ( typeid ( *a_Operand ) != typeid ( WmiStringNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_True ;
	}

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	WmiStringNode *t_StringNode = ( WmiStringNode * ) a_Operand ;

	HRESULT t_Result ;

	if ( a_Class )
	{
		t_Result = GetClassObject ()->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	}
	else
	{
		t_Result = GetInstanceObject ()->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == VT_BSTR )
		{
			t_Status = Compare ( 

				t_StringNode->GetValue () ,
				t_Variant.bstrVal ,
				t_StringNode->GetPropertyFunction () ,
				t_StringNode->GetConstantFunction () ,
				*a_Operator 
			) ;
		}
		else
		{
			t_Status = QueryPreprocessor :: QuadState :: State_Error ; 
		}
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: CompareCaseInsensitiveString ( 

	BSTR a_PropertyName , 
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand ,
	bool a_Class 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;
	
	if ( typeid ( *a_Operand ) != typeid ( WmiStringNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_True ;
	}

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	WmiStringNode *t_StringNode = ( WmiStringNode * ) a_Operand ;

	HRESULT t_Result ;

	if ( a_Class )
	{
		t_Result = GetClassObject ()->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	}
	else
	{
		t_Result = GetInstanceObject ()->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == VT_BSTR )
		{
			t_Status = Compare ( 

				t_StringNode->GetValue () ,
				t_Variant.bstrVal ,
				WmiValueNode :: WmiValueFunction :: Function_Upper ,
				WmiValueNode :: WmiValueFunction :: Function_Upper ,
				*a_Operator 
			) ;
		}
		else
		{
			t_Status = QueryPreprocessor :: QuadState :: State_Error ; 
		}
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: CompareInteger ( 

	BSTR a_PropertyName , 
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;
	
	if ( typeid ( *a_Operand ) != typeid ( WmiSignedIntegerNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_True ;
	}

	WmiSignedIntegerNode *t_IntegerNode = ( WmiSignedIntegerNode * ) a_Operand ; 

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = GetInstanceObject ()->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == VT_I4 )
		{
			t_Status = Compare ( 

				t_IntegerNode->GetValue () ,
				t_Variant.lVal ,
				t_IntegerNode->GetPropertyFunction () ,
				t_IntegerNode->GetConstantFunction () ,
				*a_Operator 
			) ;
		}
		else
		{
			t_Status = QueryPreprocessor :: QuadState :: State_Error ; 
		}
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: InvariantEvaluate ( 

	void *a_Context ,
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand 
)
{
	WmiValueNode *t_Node = ( WmiValueNode * ) a_Operand ;
	BSTR t_PropertyName = t_Node->GetPropertyName () ;
	
	if ( t_PropertyName != NULL )
	{
		if ( *t_PropertyName == L'_' )
		{
			// System property, must check values
			QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

			if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
			{
				t_Status = CompareCaseInsensitiveString ( 

					SYSTEM_PROPERTY_CLASS ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
			{
				t_Status = CompareCaseInsensitiveString ( 

					SYSTEM_PROPERTY_SUPERCLASS ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 )
			{
				t_Status = CompareInteger ( 

					SYSTEM_PROPERTY_GENUS ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 )
			{
				t_Status = CompareCaseInsensitiveString ( 

					SYSTEM_PROPERTY_SERVER ,
					a_Operator ,
					a_Operand ,
					true
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 )
			{
				t_Status = CompareCaseInsensitiveString ( 

					SYSTEM_PROPERTY_NAMESPACE ,
					a_Operator ,
					a_Operand ,
					true 
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 )
			{
				t_Status = CompareInteger ( 

					SYSTEM_PROPERTY_PROPERTY_COUNT ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 )
			{
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 )
			{
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 )
			{
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
			{
			}

			return t_Status ;
		}
		else
		{
			WbemSnmpProperty *t_Property ;
			if ( t_Property = snmpObject.FindKeyProperty ( t_PropertyName ) )
			{
				if ( typeid ( *a_Operand ) == typeid ( WmiNullNode ) )
				{
					return QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					return QueryPreprocessor :: QuadState :: State_Undefined ;
				}
			}
			else
			{
				return QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}

	if ( typeid ( *a_Operand ) == typeid ( WmiNullNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_True ;
	}

#if 0
	else if ( typeid ( *a_Operator ) == typeid ( WmiStringNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiUnsignedIntegerNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiSignedIntegerNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}

	if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLessNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorGreaterNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLikeNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotLikeNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
#endif

	return QueryPreprocessor :: QuadState :: State_Undefined ;
}

WmiRangeNode *SnmpQueryEventObject :: AllocInfiniteRangeNode (

	void *a_Context ,
	BSTR a_PropertyName 
)
{
	WmiRangeNode *t_RangeNode = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	WbemSnmpProperty *t_Property ;
	if ( t_Property = snmpObject.FindKeyProperty ( a_PropertyName ) )
	{
		t_VarType = t_Property->GetValueVariantEncodedType () ;
	}

	switch ( t_VarType )
	{
		case VT_I4:
		{
			t_RangeNode = new WmiSignedIntegerRangeNode ( 

				a_PropertyName , 
				0xFFFFFFFF , 
				TRUE ,
				TRUE ,
				FALSE ,
				FALSE ,
				0 ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		break ;

		case VT_UI4:
		{
			t_RangeNode = new WmiUnsignedIntegerRangeNode ( 

				a_PropertyName , 
				0xFFFFFFFF , 
				TRUE ,
				TRUE ,
				FALSE ,
				FALSE ,
				0 ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		break ;

		case VT_BSTR:
		{
			t_RangeNode = new WmiStringRangeNode ( 

				a_PropertyName , 
				0x0 , 
				TRUE ,
				TRUE ,
				FALSE ,
				FALSE ,
				NULL ,
				NULL ,
				NULL , 
				NULL 
			) ;
		}
		break ;

		default:
		{
		}
		break ;
	}

	return t_RangeNode ;
}

void SnmpQueryEventObject :: GetPropertiesToPartition ( ULONG &a_Count , BSTR *&a_Container )
{
	a_Count = snmpObject.GetKeyPropertyCount () ;
	a_Container = new BSTR [ a_Count ] ;

	ULONG t_PropertyIndex = 0 ;

	WbemSnmpProperty *t_Property = NULL ;
	snmpObject.ResetKeyProperty () ;
	while ( t_Property = snmpObject.NextKeyProperty () )
	{
		a_Container [ t_PropertyIndex ] = SysAllocString ( t_Property->GetName () ) ;
		t_PropertyIndex ++ ;
	}
}

SnmpQueryEventObject :: SnmpQueryEventObject ( 

	CImpPropProv *providerArg , 
	BSTR QueryFormatArg , 
	BSTR QueryArg , 
	IWbemContext *a_Context 

) : SnmpInstanceResponseEventObject ( providerArg , a_Context ) ,
	Query ( NULL ) ,
	QueryFormat ( NULL ) ,
	parser ( NULL ) ,
	source ( NULL ) ,
	requestObject ( NULL ) ,
	rpnExpression ( NULL )
{
	Query = UnicodeStringDuplicate ( QueryArg ) ;
	QueryFormat = UnicodeStringDuplicate ( QueryFormatArg ) ;
	source.SetString(Query);
	parser.SetSource(&source);
}

SnmpQueryEventObject :: ~SnmpQueryEventObject ()
{
	delete [] Query ;
	delete [] QueryFormat ;
	delete rpnExpression ;
	delete requestObject ;
}

BOOL SnmpQueryEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;

	if ( _wcsicmp ( QueryFormat , WBEM_QUERY_LANGUAGE_WQL ) == 0 )
	{
		status = parser.Parse ( & rpnExpression ) ;
		if ( status == FALSE )
		{
			IWbemServices *t_Serv = provider->GetServer();

			HRESULT result = WBEM_E_FAILED;
			
			if (t_Serv)
			{
				result = t_Serv->GetObject (

					rpnExpression->bsClassName,
					0 ,
					m_Context ,
					& classObject ,
					NULL 
				) ;

				t_Serv->Release();
			}

			if ( SUCCEEDED ( result ) )
			{
				result = classObject->SpawnInstance ( 0 , & instanceObject ) ;
				if ( SUCCEEDED ( result ) )
				{
					if ( status = GetNamespaceObject ( a_errorObject ) )
					{
						if ( status = snmpObject.Set ( a_errorObject , classObject , FALSE ) )
						{
							if ( status = snmpObject.Check ( a_errorObject ) )
							{
								if ( status = PreEvaluate ( a_errorObject ) )
								{
									WmiTreeNode *t_Root = NULL ;

									QueryPreprocessor :: QuadState t_State = PreProcess (

										m_Context ,
										rpnExpression ,
										t_Root
									) ;

									switch ( t_State )
									{
										case QueryPreprocessor :: QuadState :: State_True:
										{
											ULONG t_PropertyContainerCount = 0 ;
											BSTR *t_PropertyContainer = NULL ;
											GetPropertiesToPartition ( t_PropertyContainerCount , t_PropertyContainer ) ;

											try
											{
												t_State = PreProcess (	

													m_Context ,
													rpnExpression ,
													t_Root ,
													t_PropertyContainerCount , 
													t_PropertyContainer ,
													m_PartitionSet
												) ;
											}
											catch ( ... )
											{
												// delete properties container
												if ( t_PropertyContainerCount )
												{
													for ( ULONG t_Count = 0; t_Count < t_PropertyContainerCount; t_Count++ )
													{
														if ( t_PropertyContainer [ t_Count ] )
														{
															::SysFreeString ( t_PropertyContainer [ t_Count] );
															t_PropertyContainer [ t_Count ] = NULL;
														}
													}

													delete [] t_PropertyContainer;
													t_PropertyContainer = NULL;
												}

												if ( m_PartitionSet )
												{
													delete m_PartitionSet;
													m_PartitionSet = NULL;
												}

												if ( t_Root )
												{
													delete t_Root;
													t_Root = NULL;
												}

												throw;
											}

											// delete properties container
											if ( t_PropertyContainerCount )
											{
												for ( ULONG t_Count = 0; t_Count < t_PropertyContainerCount; t_Count++ )
												{
													if ( t_PropertyContainer [ t_Count ] )
													{
														::SysFreeString ( t_PropertyContainer [ t_Count] );
														t_PropertyContainer [ t_Count ] = NULL;
													}
												}

												delete [] t_PropertyContainer;
												t_PropertyContainer = NULL;
											}

											switch ( t_State )
											{
												case QueryPreprocessor :: QuadState :: State_True:
												{
													delete m_PartitionSet ;
													m_PartitionSet = NULL ;
													status = SendSnmp ( a_errorObject ) ;
												}
												break ;

												case QueryPreprocessor :: QuadState :: State_False:
												{
													status = FALSE ;
													delete m_PartitionSet ;
													m_PartitionSet = NULL ;

													a_errorObject.SetStatus ( WBEM_SNMP_NO_ERROR ) ;
													a_errorObject.SetWbemStatus ( WBEM_S_NO_ERROR ) ;
													a_errorObject.SetMessage ( L"" ) ;
												}
												break ;

												case QueryPreprocessor :: QuadState :: State_Undefined:
												{
													status = SendSnmp ( a_errorObject ) ;
												}
												break ;

												default:
												{
													status = FALSE ;
													a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
													a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
													a_errorObject.SetMessage ( L"WQL query was invalid" ) ;
												}
												break ;
											}

											delete t_Root ;
										}
										break ;
									
										default:
										{
											status = FALSE ;
											a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
											a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
											a_errorObject.SetMessage ( L"WQL query was invalid" ) ;
										}
										break ;
									}
								}
							}
							else
							{
DebugMacro3( 


SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Check : Class definition did not conform to mapping"
) ;
)

							}
						}
						else
						{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
						}
					}
				}
			}
			else
			{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Class definition unknown"
	) ;
)
			}
		}
		else
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Illegal SQL 1 Query"
	) ;
)

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_errorObject.SetMessage ( L"WQL query was invalid" ) ;
		}
	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Query format not known"
	) ;
)

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY_TYPE ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY_TYPE ) ;
		a_errorObject.SetMessage ( L"Query Language not supported" ) ;
	}

	return status ;
}

BOOL SnmpQueryEventObject :: IsSystemProperty (const wchar_t *propertyName )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: SnmpQueryEventObject :: IsSystemProperty (const wchar_t *propertyName )"
	) ;
)

	//Only SYSTEM properties may start with an '_' character.

	return ( *propertyName == SYTEM_PROPERTY_START_CHARACTER ) ;
}

BOOL SnmpQueryEventObject :: PreEvaluate ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: PreEvaluate ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	if ( rpnExpression->nNumberOfProperties == 0 )
	{
// Get All Properties

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Get All Properties"
	) ;
)

		requestObject = new SnmpInstanceClassObject ( snmpObject ) ;
	}
	else if ( snmpObject.IsVirtual () )
	{
// Get All Properties since some keys are virtuals

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Get All Properties because some keys are virtual"
	) ;
)

		requestObject = new SnmpInstanceClassObject ( snmpObject ) ;
	}
	else
	{
// Get List of Properties for return and list of properties for filter evaluation

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Get Subset of Properties"
	) ;
)

		requestObject = new SnmpInstanceClassObject ( this );

		status = FilterSelectProperties ( a_errorObject ) ;
	}

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Check Where Clause is legal"
	) ;
)

		status = PreEvaluateWhereClause ( a_errorObject ) ;
	}

	return status ;
}

BOOL SnmpQueryEventObject :: FilterSelectProperties ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: FilterSelectProperties ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;
	
	LONG varType = 0 ;
	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpQualifier *qualifier = NULL ;

	snmpObject.ResetQualifier () ;
	while ( status && ( qualifier = snmpObject.NextQualifier () ) )
	{
		WbemSnmpQualifier *copy = new WbemSnmpQualifier ( *qualifier ) ;
		status = requestObject->AddQualifier ( copy ) ;

		if (!status)
		{
			delete copy;
		}
	}

	int index = 0 ;
	BOOL has_path_property = FALSE ;

	while ( status && ( index <  rpnExpression->nNumberOfProperties ) )
	{
		wchar_t *propertyName = rpnExpression->pbsRequestedPropertyNames [ index ] ;

		WbemSnmpProperty *property ;
		if ( property = snmpObject.FindProperty ( propertyName ) )	
		{
			status = requestObject->AddProperty ( new WbemSnmpProperty ( *property ) ) ;

			if (!status)
			{
				delete property;
			}
		}
		else if ( IsSystemProperty ( propertyName ) )
		{
			if ( ( _wcsicmp ( propertyName , SYSTEM_PROPERTY_RELPATH ) == 0 ) ||
				( _wcsicmp ( propertyName , SYSTEM_PROPERTY_PATH ) == 0 ) )
			{
				has_path_property = TRUE;
			}
		}
		else
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Property in SELECT clause is not a valid class property"
	) ;
)

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_errorObject.SetMessage ( L"SELECT properties of WQL query were invalid" ) ;
		}

		index ++ ;
	}

	if ( status && has_path_property )
	{
		//add in all keys not present...
		WbemSnmpProperty *property = NULL;
		while ( property = snmpObject.NextKeyProperty () )
		{
			if ( ! requestObject->FindProperty ( property->GetName () ) ) 
			{
				status = requestObject->AddProperty ( new WbemSnmpProperty ( *property ) ) ;

				if (!status)
				{
					delete property;
				}
			}
		}

	}

	if ( status )
	{
		status = requestObject->Check ( a_errorObject ) ;
	}
	
	return status ;
}

BOOL SnmpQueryEventObject :: CheckWhereCondition ( 

	WbemSnmpErrorObject &a_errorObject , 
	WbemSnmpProperty *property ,
	SQL_LEVEL_1_TOKEN *token
)
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: SnmpQueryEventObject :: CheckWhereCondition ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ,	SQL_LEVEL_1_TOKEN *token)"
	) ;
)

	BOOL status = TRUE ;

	switch ( property->GetValueVariantEncodedType () )
	{
		case VT_UI4:
		case VT_I4:
		{
			switch ( token->vConstValue.vt )
			{
				case VT_NULL:
				case VT_I4:
				{
				}
				break ;

				default:
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
					a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
				}
				break ;
			}
		}
		break ;

		case VT_BSTR:
		{
			switch ( token->vConstValue.vt )
			{
				case VT_NULL:
				case VT_BSTR:
				{
				}
				break ;

				default:
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
					a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
				}
				break ;
			}
		}
		break ;

		case VT_NULL:
		{
			switch ( token->vConstValue.vt )
			{
				case VT_NULL:
				{
				}
				break ;

				default:
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
					a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
		}
		break ;
	}

	return status ;
}

BOOL SnmpQueryEventObject :: PreEvaluateWhereClause ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: PreEvaluateWhereClause ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	int index = 0 ;
	while ( status && ( index <  rpnExpression->nNumTokens ) )
	{
		SQL_LEVEL_1_TOKEN *propertyValue = &rpnExpression->pArrayOfTokens [ index ] ;
		if ( propertyValue->nTokenType == SQL_LEVEL_1_TOKEN :: OP_EXPRESSION )
		{	
			wchar_t *propertyName = propertyValue->pPropertyName ;

			WbemSnmpProperty *property ;
			if ( property = requestObject->FindProperty ( propertyName ) )	
			{
				status = CheckWhereCondition ( a_errorObject , property , propertyValue ) ;
				if ( status )
				{
					requestObject->AddProperty ( new WbemSnmpProperty ( *property ) ) ;
				}
				else
				{
				}
			}
			else if ( ! IsSystemProperty ( propertyName ) ) 
			{
// Property Not Found

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_SUPPORTED ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_NOT_SUPPORTED ) ;
				a_errorObject.SetMessage ( L"WHERE clause of WQL query specified unknown property name" ) ;
			}
		}

		index ++ ;
	}

	return status ;
}

#ifdef POST_FILTERING_RECEIVED_ROW
BOOL SnmpQueryEventObject :: Compare ( 

	const LONG & op1 , 
	const LONG & op2 , 
	const DWORD & op1Func ,
	const DWORD & op2Func ,
	const int & operatorType 
)
{
	BOOL status = FALSE ;

	switch ( op1Func ) 
	{
		case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( op2Func ) 
	{
		case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( operatorType )
	{
		case SQL_LEVEL_1_TOKEN :: OP_EQUAL:
		{
			status = op1 == op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_NOT_EQUAL:
		{
			status = op1 != op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_EQUALorGREATERTHAN:
		{
			status = op1 >= op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_EQUALorLESSTHAN:
		{
			status = op1 <= op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_LESSTHAN:
		{
			status = op1 < op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_GREATERTHAN:
		{
			status = op1 > op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_LIKE:
		default:
		{
		}
		break ;
	}

	return status ;
}

BOOL SnmpQueryEventObject :: Compare ( 

	const wchar_t * & op1 , 
	const wchar_t * & op2 , 
	const DWORD & op1Func ,
	const DWORD & op2Func ,
	const int & operatorType 
)
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: Compare ()"
	) ;
)

	BOOL status = FALSE ;

	wchar_t *op1AfterFunc = NULL ;
	wchar_t *op2AfterFunc = NULL ; 

	switch ( op1Func ) 
	{
		case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
		{
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
		{
			ULONG length = wcslen ( op1 ) ;
			wchar_t *op1AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				op1AfterFunc [ index ] = toupper ( op1 [ index ] ) ;
			}
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
		{
			ULONG length = wcslen ( op1 ) ;
			wchar_t *op1AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				op1AfterFunc [ index ] = tolower ( op1 [ index ] ) ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( op2Func ) 
	{
		case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
		{
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
		{
			ULONG length = wcslen ( op2 ) ;
			wchar_t *op2AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				op2AfterFunc [ index ] = toupper ( op2 [ index ] ) ;
			}
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
		{
			ULONG length = wcslen ( op2 ) ;
			wchar_t *op2AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				op2AfterFunc [ index ] = tolower ( op2 [ index ] ) ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	const wchar_t *arg1 = op1AfterFunc ? op1AfterFunc : op1 ;
	const wchar_t *arg2 = op2AfterFunc ? op2AfterFunc : op2 ;

	switch ( operatorType )
	{
		case SQL_LEVEL_1_TOKEN :: OP_EQUAL:
		{
			status = wcscmp ( arg1 , arg2 ) == 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_NOT_EQUAL:
		{
			status = wcscmp ( arg1 , arg2 ) != 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_EQUALorGREATERTHAN:
		{
			status = wcscmp ( arg1 , arg2 ) >= 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_EQUALorLESSTHAN:
		{
			status = wcscmp ( arg1 , arg2 ) <= 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_LESSTHAN:
		{
			status = wcscmp ( arg1 , arg2 ) < 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_GREATERTHAN:
		{
			status = wcscmp ( arg1 , arg2 ) > 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_LIKE:
		default:
		{
		}
		break ;
	}

	delete [] op1AfterFunc ;
	delete [] op2AfterFunc ;

	return status ;
}

BOOL SnmpQueryEventObject :: ExpressionCompare ( SnmpInstanceClassObject *snmpObject , SQL_LEVEL_1_TOKEN *propertyValue )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: ExpressionCompare ( SnmpInstanceClassObject *snmpObject , SQL_LEVEL_1_TOKEN *propertyValue )"
	) ;
)

	BOOL status = FALSE ;

	wchar_t *propertyName = propertyValue->pPropertyName ;

	WbemSnmpProperty *property ;
	if ( property = snmpObject->FindProperty ( propertyName ) )
	{
		VARIANT variant ;
		VariantInit ( & variant ) ;

DebugMacro3( 

	wchar_t *t_StringValue = ( property->GetValue () ) ? property->GetValue ()->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Property (%s),(%s)",
			propertyName ,
			t_StringValue
		) ;
	}

	delete [] t_StringValue ;
)


		CIMTYPE varType ;
		if ( property->GetValue ( variant , cimType ) ) 
		{
			switch ( variant.vt )
			{
				case VT_NULL:
				{
					switch ( propertyValue->vConstValue.vt )
					{
						case VT_NULL:
						{
							status = TRUE ;
						}
						break ;

						default:
						{
						}
						break ;
					}
				}
				break;

				case VT_I4:
				{
					switch ( propertyValue->vConstValue.vt )
					{
						case VT_I4:
						{
							status = Compare ( 

								variant.lVal , 
								propertyValue->vConstValue.lVal ,
								propertyValue->dwPropertyFunction ,
								propertyValue->dwConstFunction ,
								propertyValue->nOperator
							) ;
						}
						break ;

						default:
						{
						}
						break ;
					}
				}
				break ;

				case VT_BSTR:
				{
					switch ( propertyValue->vConstValue.vt )
					{
						case VT_BSTR:
						{
							status = Compare ( 

								variant.bstrVal , 
								propertyValue->vConstValue.bstrVal ,
								propertyValue->dwPropertyFunction ,
								propertyValue->dwConstFunction ,
								propertyValue->nOperator
							) ;
						}
						break ;

						default:
						{
						}
						break ;
					}
				}
				break ;

				default:
				{
				}
				break ;
			}

			VariantClear ( &variant ) ;
			
		}
		else
		{
// Problem Here
		}
	}
	else
	{
// Problem Here
	}

	return status ;
}

BOOL SnmpQueryEventObject :: PostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: PostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject )" 
	) ;
)

	BOOL t_Status = TRUE ;
	if ( rpnExpression->nNumTokens )
	{
		int count = rpnExpression->nNumTokens - 1 ;
		t_Status = RecursivePostEvaluateWhereClause ( snmpObject , count ) ;
	}
	else
	{
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"PostEvaluation Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)

	return t_Status ;
}

BOOL SnmpQueryEventObject :: RecursivePostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject , int &index )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: RecursivePostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject , int &index )"
	) ;
)

	BOOL status = FALSE ;

	SQL_LEVEL_1_TOKEN *propertyValue = & ( rpnExpression->pArrayOfTokens [ index ] ) ;
	index -- ;


	switch ( propertyValue->nTokenType )
	{
		case SQL_LEVEL_1_TOKEN :: OP_EXPRESSION:
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = OP_EXPESSION"
	) ;
)

			status = ExpressionCompare ( snmpObject , propertyValue ) ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_AND:
		{

			status = RecursivePostEvaluateWhereClause ( snmpObject , index ) &&
					 RecursivePostEvaluateWhereClause ( snmpObject , index ) ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_AND"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_OR:
		{

			status = RecursivePostEvaluateWhereClause ( snmpObject , index ) ||
					 RecursivePostEvaluateWhereClause ( snmpObject , index ) ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_OR"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_NOT:
		{
			status = ! RecursivePostEvaluateWhereClause ( snmpObject , index ) ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_NOT"
	) ;
)

		}
		break ;
	}

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"RecursivePostEvaluation Status = (%lu)" ,
		( ULONG ) status
	) ;

	return status ;
}
#endif //POST_FILTERING_RECEIVED_ROW

SnmpQueryAsyncEventObject :: SnmpQueryAsyncEventObject (

	CImpPropProv *providerArg , 
	BSTR QueryFormat , 
	BSTR Query,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context 

) : SnmpQueryEventObject ( providerArg , QueryFormat , Query , a_Context ) , notificationHandler ( notify ) , state ( 0 )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: SnmpQueryAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpQueryAsyncEventObject :: ~SnmpQueryAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ~SnmpQueryAsyncEventObject ()" 
	) ;
)

// Get Status object

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *notifyStatus = NULL;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status && (notifyStatus != NULL))
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

#ifndef POST_FILTERING_RECEIVED_ROW

			if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
			{
				//let CIMOM do the post filtering!
				WBEMSTATUS t_wbemStatus = WBEM_S_FALSE ;
				VARIANT t_variant ;
				VariantInit( & t_variant ) ;
				t_variant.vt = VT_I4 ;
				t_variant.lVal = WBEM_S_FALSE ;

				HRESULT result = notifyStatus->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_variant , 0 ) ;
				VariantClear ( &t_variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					result = notificationHandler->SetStatus ( 0 , t_wbemStatus , NULL , notifyStatus ) ;
				}
				else
				{
					result = notificationHandler->SetStatus ( 0 , WBEM_E_PROVIDER_FAILURE , NULL , NULL ) ;
				}
			}
			else
			{
				HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			}
		}

#else

		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;

#endif //POST_FILTERING_RECEIVED_ROW

		notifyStatus->Release () ;
	}
	else
	{
		HRESULT t_Result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpQueryAsyncEventObject :: ~SnmpQueryAsyncEventObject ()" 
	) ;
)

}

void SnmpQueryAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Query Succeeded" 
	) ;
)

	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Query Failed" 
	) ;
)

	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	AutoRetrieveOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	Complete () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;
}

void SnmpQueryAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			BOOL status = Instantiate ( m_errorObject ) ;
			if ( status )
			{
			}
			else
			{
				ReceiveComplete () ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpQueryAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpQueryAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;
	BOOL status = TRUE ;

	notificationHandler->Indicate ( 1 , & snmpObject ) ;
	if ( ! HasNonNullKeys ( snmpObject ) )
	{
		if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
		}
	}			
}

void SnmpQueryAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject*snmpObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;
	BOOL status = TRUE ;

#ifdef POST_FILTERING_RECEIVED_ROW
	if ( status = PostEvaluateWhereClause ( snmpObject ) )
#endif //POST_FILTERING_RECEIVED_ROW
	{
		IWbemClassObject *cloneObject ;
		if ( SUCCEEDED ( result = classObject->SpawnInstance ( 0 , & cloneObject ) ) ) 
		{
			WbemSnmpErrorObject errorObject ;
			if ( status = snmpObject->Get ( errorObject , cloneObject ) )
			{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Object" 
	) ;
)
				notificationHandler->Indicate ( 1 , & cloneObject ) ;
				if ( ! HasNonNullKeys ( cloneObject ) )
				{
					if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
					}
				}			
			}	
			else
			{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Failed to Convert WbemSnmpClassObject to IWbemClassObject" 
	) ;
)

			}

			cloneObject->Release () ;
		}
	}
#ifdef POST_FILTERING_RECEIVED_ROW
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Object discarded due to query filter " 
	) ;
)

	}
#endif //POST_FILTERING_RECEIVED_ROW

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\snmpget.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <provtree.h>
#include <provdnf.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "snmpget.h"

GetOperation :: GetOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpGetResponseEventObject *eventObjectArg 

) :	SnmpGetOperation ( sessionArg ) , 
	session ( & sessionArg ) ,
	varBindsReceived ( 0 ) ,
	erroredVarBindsReceived ( 0 ) ,
	eventObject ( eventObjectArg ) ,
	virtuals ( FALSE ) ,
	virtualsInitialised ( FALSE ) ,	
	m_PropertyContainer ( NULL ) ,
	m_PropertyContainerLength ( 0 ) 
{
}

GetOperation :: ~GetOperation ()
{
	delete [] m_PropertyContainer ;

	session->DestroySession () ;
}

void GetOperation :: ReceiveResponse () 
{
// Inform creator all is done

	if ( varBindsReceived == 0 )
	{
/*
 *	Don't mask errors encountered previously
 */

		if ( eventObject->GetErrorObject ().GetWbemStatus () == S_OK )
		{
			eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			eventObject->GetErrorObject ().SetMessage ( L"Instance unknown" ) ;
		}
	}
	else
	{
		if ( FAILED ( eventObject->GetErrorObject ().GetWbemStatus () ) ) 
		{
			if ( eventObject->GetErrorObject ().GetStatus () == WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) 
			{
				eventObject->GetErrorObject ().SetWbemStatus ( WBEM_S_TIMEDOUT ) ;
			}
		}
	}

	eventObject->ReceiveComplete () ;
}

void GetOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,	
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	varBindsReceived ++ ;

	IWbemClassObject *snmpObject = eventObject->GetInstanceObject () ;

	if ( ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchObject ) ) || ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchInstance ) ) )
	{
	}
	else
	{
	// Set Property value

		WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ] ;
		SnmpValue &value = replyVarBind.GetValue () ;

		// Set Property value

		if ( property->SetValue ( snmpObject , &value , SetValueRegardlessReturnCheck ) )
		{
		// Set worked
		}
		else
		{
	// Type Mismatch

			property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
			WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
			if ( qualifier )
			{
				IWbemQualifierSet *t_QualifierSet = NULL;
				HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
				if ( SUCCEEDED ( result ) )
				{
					SnmpIntegerType integer ( 1 , NULL ) ;
					qualifier->SetValue ( t_QualifierSet , integer ) ;
				}

				t_QualifierSet->Release () ;
			}
		}

		if ( virtuals && virtualsInitialised == FALSE )
		{
// Get Phantom Key properties from first Variable Binding of Row

			BOOL status = TRUE ;
			SnmpObjectIdentifier decodeObject ( NULL , 0 ) ;

			//remove object info so we're left with instance (key) info only
			WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
			if ( qualifier )
			{
				SnmpInstanceType *value = qualifier->GetValue () ;
				if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
				{
					SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
					replyVarBind.GetInstance().Suffix( objectIdentifierType->GetValueLength () , decodeObject ) ;
				}
			}

			SnmpGetClassObject *t_SnmpObject = ( SnmpGetClassObject * ) eventObject->GetSnmpClassObject () ;

			WbemSnmpProperty *property ;
			t_SnmpObject->ResetKeyProperty () ;
			while ( status && ( property = t_SnmpObject->NextKeyProperty () ) )
			{
// For each Phantom Key in Key Order consume instance information

				SnmpInstanceType *decodeValue = property->GetValue () ;
				decodeObject = decodeValue->Decode ( decodeObject ) ;
				if ( *decodeValue )
				{
// Decode worked correctly

					const SnmpValue *value = decodeValue->GetValueEncoding () ;
// Set Property value for Phantom Key
					property->SetValue ( snmpObject , value , SetValueRegardlessReturnCheck ) ;
				}
				else
				{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

					WbemSnmpProperty *property ;
					t_SnmpObject->ResetKeyProperty () ;
					while ( property = t_SnmpObject->NextKeyProperty () )
					{
						WbemSnmpQualifier *qualifier = NULL ;
						property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
						{
// Property which is a phantom key could not be decoded correctly.

							IWbemQualifierSet *t_QualifierSet = NULL;
							HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
							if ( SUCCEEDED ( result ) )
							{
								SnmpIntegerType integer ( 1 , NULL ) ;
								qualifier->SetValue ( t_QualifierSet , integer ) ;
							}

							t_QualifierSet->Release () ;
						}
						else
						{
// Problem Here
						}
					}

					status = FALSE ;
				}
			}

// Check we have consumed all instance information

			if ( decodeObject.GetValueLength () )
			{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

				WbemSnmpProperty *property ;
				t_SnmpObject->ResetKeyProperty () ;
				while ( property = t_SnmpObject->NextKeyProperty () )
				{
					WbemSnmpQualifier *qualifier = NULL ;
					property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
					{
// Property which is a phantom key could not be decoded correctly.

						IWbemQualifierSet *t_QualifierSet = NULL;
						HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
						if ( SUCCEEDED ( result ) )
						{
							SnmpIntegerType integer ( 1 , NULL ) ;
							qualifier->SetValue ( t_QualifierSet , integer ) ;
						}

						t_QualifierSet->Release () ;
					}
					else
					{
// Problem Here
					}
				}
			}

// No need to set Phantom keys for further columns of row
			
			virtualsInitialised = TRUE ;
		}
	}
}

#pragma warning (disable:4065)

void GetOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	erroredVarBindsReceived ++ ;

	WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ] ;

	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{
// Invalid property requested
				}
				break ;

				case Snmp_Bad_Value:
				{
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Bad Value for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
				}
				break ;

				case Snmp_Read_Only:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;

					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Read Only for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Gen_Error:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported General Error for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Too_Big:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Too Big for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}
}

#pragma warning (default:4065)

void GetOperation :: FrameTooBig () 
{
}

void GetOperation :: FrameOverRun () 
{
}

void GetOperation :: Send ()
{
// Send Variable Bindings for requested properties

	SnmpVarBindList varBindList ;
	SnmpNull snmpNull ;

	SnmpObjectIdentifier instanceObjectIdentifier ( NULL , 0 ) ;

	IWbemClassObject *snmpObject = eventObject->GetInstanceObject () ;

	SnmpClassObject *t_SnmpObject = eventObject->GetSnmpClassObject () ;
	if ( t_SnmpObject )
	{
// Encode Variable Binding instance for all key properties

		if ( t_SnmpObject->GetKeyPropertyCount () )
		{
			WbemSnmpProperty *property ;
			t_SnmpObject->ResetKeyProperty () ;
			while ( property = t_SnmpObject->NextKeyProperty () )
			{
				instanceObjectIdentifier = property->GetValue()->Encode ( instanceObjectIdentifier ) ;
			}
		}
		else
		{
			SnmpIntegerType integerType ( ( LONG ) 0 , NULL ) ;
			instanceObjectIdentifier = integerType.Encode ( instanceObjectIdentifier ) ;
		}

		virtuals = FALSE ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{
			if ( property->IsKey () && property->IsVirtualKey () )
			{
// There are some properties which are phantom

				virtuals = TRUE ;
			}

			if ( property->IsReadable () )
			{
				BOOL t_Status = ( t_SnmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( t_SnmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						m_PropertyContainerLength ++ ;
					}
				}
			}
		}

		m_PropertyContainer = new WbemSnmpProperty * [ m_PropertyContainerLength ] ;

// Add Variable binding to Variable binding list
// Insert new Object Identifier / Property Hash entries for newly created object

		ULONG t_Index = 0 ;

		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				BOOL t_Status = ( t_SnmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( t_SnmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;
				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE ) 
					{
						WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
						if ( qualifier )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
								SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
								SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
								SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

								SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

								m_PropertyContainer [ t_Index ] = property ;

								SnmpVarBind varBind ( requestIdentifier , snmpNull ) ;
								varBindList.Add ( varBind ) ;

								t_Index ++ ;
							}
							else
							{
		// Problem Here
							}
						}
						else
						{
		// Problem Here
						}
					}
					else
					{
	// Don't retrieve properties marked as virtual keys.
					}
				}
			}

/*
 *	Initialise value to NULL
 */

			property->SetValue ( snmpObject , ( SnmpValue * ) NULL ) ;
		}

// Finally Send request

		SendRequest ( varBindList ) ;
	}
	else
	{
// Problem Here
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\snmpnext.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <provtree.h>
#include <provdnf.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propinst.h"
#include "propquery.h"
#include "snmpnext.h"

BOOL DecrementObjectIdentifier ( 

	SnmpObjectIdentifier &a_Object , 
	SnmpObjectIdentifier &a_DecrementedObject 
)
{
	BOOL t_Status = TRUE ;

	ULONG t_ObjectLength = a_Object.GetValueLength () ;
	ULONG *t_ObjectValue = a_Object.GetValue () ;

	ULONG *t_DecrementedValue = new ULONG [ t_ObjectLength ] ;

	BOOL t_Decrement = TRUE ;

	for ( ULONG t_Index = t_ObjectLength ; t_Index > 0 ; t_Index -- )
	{
		ULONG t_Component = t_ObjectValue [ t_Index - 1 ] ;

		if ( t_Decrement )
		{
			if ( t_Component == 0 ) 
			{
				t_Component -- ;
			}
			else
			{
				t_Decrement = FALSE ;
				t_Component -- ;
			}
		}

		t_DecrementedValue [ t_Index - 1 ] = t_Component ;
	}
	
	a_DecrementedObject.SetValue ( t_DecrementedValue , t_ObjectLength ) ;

	delete [] t_DecrementedValue;

	t_Status = t_Decrement == FALSE ;

	return t_Status ;
}

BOOL IncrementObjectIdentifier ( 

	SnmpObjectIdentifier &a_Object , 
	SnmpObjectIdentifier &a_IncrementedObject 
)
{
	BOOL t_Status = TRUE ;

	ULONG t_ObjectLength = a_Object.GetValueLength () ;
	ULONG *t_ObjectValue = a_Object.GetValue () ;

	ULONG *t_IncrementedValue = new ULONG [ t_ObjectLength ] ;

	BOOL t_Increment = TRUE ;

	for ( ULONG t_Index = t_ObjectLength ; t_Index > 0 ; t_Index -- )
	{
		ULONG t_Component = t_ObjectValue [ t_Index - 1 ] ;

		if ( t_Increment )
		{
			if ( t_Component == 0xFFFFFFFF ) 
			{
				t_Component ++ ;
			}
			else
			{
				t_Component ++ ;
				t_Increment = FALSE ;
			}
		}

		t_IncrementedValue [ t_Index - 1 ] = t_Component ;
	}
	
	a_IncrementedObject.SetValue ( t_IncrementedValue , t_ObjectLength ) ;

	delete [] t_IncrementedValue;

	t_Status = t_Increment == FALSE ;

	return t_Status ;
}

AutoRetrieveOperation :: AutoRetrieveOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpInstanceResponseEventObject *eventObjectArg 

) :	SnmpAutoRetrieveOperation ( sessionArg ) , 
	session ( &sessionArg ) ,
	eventObject ( eventObjectArg ) ,
	varBindsReceived ( 0 ) ,
	erroredVarBindsReceived ( 0 ) ,	
	rowVarBindsReceived ( 0 ) ,
	rowsReceived ( 0 ) ,
	snmpObject ( NULL ) ,
	virtuals ( FALSE ) ,
	virtualsInitialised ( FALSE ) ,
	m_PropertyContainer ( NULL ) ,
	m_PropertyContainerLength ( 0 ) 
{
}

AutoRetrieveOperation :: ~AutoRetrieveOperation ()
{
	if ( snmpObject ) 
	{
		snmpObject->Release () ;
		snmpObject = NULL;
	}

	delete [] m_PropertyContainer ;

	session->DestroySession () ;
}

void AutoRetrieveOperation :: ReceiveResponse () 
{
// Inform creator all is done

	eventObject->ReceiveComplete () ;
}

void AutoRetrieveOperation :: ReceiveRowResponse () 
{
// Receive of Row is not complete

	rowsReceived ++ ;

// Inform Creator row has been received

	if ( snmpObject )
	{
		eventObject->ReceiveRow ( snmpObject ) ;
		snmpObject->Release () ;
		snmpObject = NULL;
	}

// Insert new Object Identifier / Property Hash entries for newly created object

	IWbemClassObject *t_ClassObject = eventObject->GetInstanceObject () ;
	HRESULT t_Result = t_ClassObject->Clone ( & snmpObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{

	/*
	 *	Initialise value to NULL
	 */

			property->SetValue ( snmpObject , ( SnmpValue * ) NULL ) ;

		}
	}
	else
	{
// Problem Here

		if ( t_Result == WBEM_E_OUT_OF_MEMORY )
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
		}
	}

	virtualsInitialised = FALSE ;
}

void AutoRetrieveOperation :: ReceiveRowVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	rowVarBindsReceived ++ ;

// Set Variable Binding Value for property

	WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ].m_Property ;
	SnmpValue &value = replyVarBind.GetValue () ;
	if ( property->SetValue ( snmpObject , &value , SetValueRegardlessReturnCheck ) )
	{
	// Set worked
	}
	else
	{
// Type Mismatch

		property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
		WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
		if ( qualifier )
		{
			if ( snmpObject )
			{
				IWbemQualifierSet *t_QualifierSet = NULL;
				HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
				if ( SUCCEEDED ( result ) )
				{
					SnmpIntegerType integer ( 1 , NULL ) ;
					qualifier->SetValue ( t_QualifierSet , integer ) ;
				}

				if ( t_QualifierSet )
				{
					t_QualifierSet->Release () ;
					t_QualifierSet = NULL;
				}
			}
		}
	}

	if ( virtuals && virtualsInitialised == FALSE )
	//if ( virtualsInitialised == FALSE )
	{
// Get Phantom Key properties from first Variable Binding of Row

		BOOL status = TRUE ;
		SnmpObjectIdentifier decodeObject = replyVarBind.GetInstance () ;

		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetKeyProperty () ;
		while ( status && ( property = t_SnmpObject->NextKeyProperty () ) )
		{
// For each Phantom Key in Key Order consume instance information

			SnmpInstanceType *decodeValue = property->GetValue () ;
			decodeObject = decodeValue->Decode ( decodeObject ) ;
			if ( *decodeValue )
			{
// Decode worked correctly

				const SnmpValue *value = decodeValue->GetValueEncoding () ;
// Set Property value for Key
				property->SetValue ( snmpObject , value , SetValueRegardlessReturnCheck ) ;
			}
			else
			{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

				WbemSnmpProperty *property ;
				t_SnmpObject->ResetKeyProperty () ;
				while ( property = t_SnmpObject->NextKeyProperty () )
				{
					WbemSnmpQualifier *qualifier = NULL ;
					property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
					{
// Property which is a phantom key could not be decoded correctly.

						if ( snmpObject )
						{
							IWbemQualifierSet *t_QualifierSet = NULL;
							HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
							if ( SUCCEEDED ( result ) )
							{
								SnmpIntegerType integer ( 1 , NULL ) ;
								qualifier->SetValue ( t_QualifierSet , integer ) ;
							}

							if ( t_QualifierSet )
							{
								t_QualifierSet->Release () ;
								t_QualifierSet = NULL;
							}
						}
					}
					else
					{
// Problem Here
					}
				}

				status = FALSE ;
			}
		}

// Check we have consumed all instance information

		if ( decodeObject.GetValueLength () )
		{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

			WbemSnmpProperty *property ;
			t_SnmpObject->ResetKeyProperty () ;
			while ( property = t_SnmpObject->NextKeyProperty () )
			{
				WbemSnmpQualifier *qualifier = NULL ;
				property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
				if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
				{
// Property which is a phantom key could not be decoded correctly.

					if ( snmpObject )
					{
						IWbemQualifierSet *t_QualifierSet = NULL;
						HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
						if ( SUCCEEDED ( result ) )
						{
							SnmpIntegerType integer ( 1 , NULL ) ;
							qualifier->SetValue ( t_QualifierSet , integer ) ;
						}

						if ( t_QualifierSet )
						{
							t_QualifierSet->Release () ;
							t_QualifierSet = NULL;
						}
					}
				}
				else
				{
// Problem Here
				}
			}
		}

// No need to set Phantom keys for further columns of row
		
		virtualsInitialised = TRUE ;
	}
}

void AutoRetrieveOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	varBindsReceived ++ ;
}

#pragma warning (disable:4065)

void AutoRetrieveOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	erroredVarBindsReceived ++ ;

	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{
// End of MIB tree.
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}

	erroredVarBindsReceived ++ ;
}

#pragma warning (default:4065)

void AutoRetrieveOperation :: FrameTooBig ()
{
}

void AutoRetrieveOperation :: FrameOverRun () 
{
}

void AutoRetrieveOperation :: Send ()
{
// Send Variable Bindings for requested properties

	SnmpNull snmpNull ;
	SnmpVarBindList varBindList ;
	SnmpVarBindList startVarBindList ;

// Create class object for subsequent receipt of response

	IWbemClassObject *t_ClassObject = eventObject->GetInstanceObject () ;
	HRESULT t_Result = t_ClassObject->Clone ( & snmpObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
		SnmpInstanceClassObject *t_RequestSnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpRequestClassObject () ;

// Check for properties which are phantom

		virtualsInitialised = FALSE ;
		virtuals = FALSE ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetKeyProperty () ;
		while ( property = t_SnmpObject->NextKeyProperty () )
		{
			if ( property->IsVirtualKey () )
			{
// There are some properties which are phantom

				virtuals = TRUE ;
			}

			if ( ! t_RequestSnmpObject->FindProperty ( property->GetName () ) ) 
			{
				virtuals = TRUE ;
			}
		}

		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				BOOL t_Status = ( t_SnmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( t_SnmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						m_PropertyContainerLength ++ ;
					}
				}
			}
		}

		m_PropertyContainer = new PropertyDefinition [ m_PropertyContainerLength ] ;

// Add Variable binding to Variable binding list
// Insert new Object Identifier / Property Hash entries for newly created object

		ULONG t_Index = 0 ;
		t_RequestSnmpObject->ResetProperty () ;
		while ( property = t_RequestSnmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				BOOL t_Status = ( t_RequestSnmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( t_RequestSnmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
						if ( qualifier )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
								SnmpObjectIdentifier t_CurrentIdentifier ( 0 , NULL ) ;
								SnmpObjectIdentifier t_StartIdentifier ( 0 , NULL ) ;
								LONG t_Scoped = EvaluateInitialVarBind ( 

									t_Index , 
									t_CurrentIdentifier , 
									t_StartIdentifier 
								) ;

								m_PropertyContainer [ t_Index ].m_Property = property ;

								SnmpObjectIdentifierType requestIdentifierType ( * ( SnmpObjectIdentifierType * ) value ) ;

								SnmpObjectIdentifier t_RequestIdentifier = * ( SnmpObjectIdentifier * ) requestIdentifierType.GetValueEncoding () ; 

								SnmpVarBind t_VarBind ( t_RequestIdentifier , snmpNull ) ;
								varBindList.Add ( t_VarBind ) ;

								if ( t_Scoped > 0 )
								{
									t_RequestIdentifier = t_RequestIdentifier + t_StartIdentifier ;
								}

// Add Variable binding to list

								SnmpVarBind t_StartVarBind ( t_RequestIdentifier , snmpNull ) ;
								startVarBindList.Add ( t_StartVarBind ) ;

								t_Index ++ ;
							}
						}
					}
					else
					{
// Don't Send properties marked as virtual key
					} 
				}
			} 
/*
 *	Initialise value to NULL
 */

			property->SetValue ( snmpObject , ( SnmpValue * ) NULL ) ;

		}

// Finally Send request

		SendRequest ( varBindList , startVarBindList ) ;
	}
	else
	{
	}
}

LONG AutoRetrieveOperation :: EvaluateNextRequest (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN SnmpVarBind &sendVarBind
)
{
	LONG t_Evaluation = 0 ;

	PartitionSet *t_Partition = eventObject->GetPartitionSet () ;
	if ( t_Partition )
	{
		BOOL t_Status = TRUE ;

		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
		ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;
		SnmpObjectIdentifier t_DecodeObject = replyVarBind.GetInstance () ;

		ULONG t_Index = 0 ;
		WbemSnmpProperty *t_Property ;
		t_SnmpObject->ResetKeyProperty () ;
		while ( t_Status && ( t_Property = t_SnmpObject->NextKeyProperty () ) )
		{
// For each Key in Key Order consume instance information

			SnmpInstanceType *t_DecodeValue = t_Property->GetValue () ;
			t_DecodeObject = t_DecodeValue->Decode ( t_DecodeObject ) ;

			SnmpObjectIdentifier t_Encode ( 0 , NULL ) ;
			t_Encode = t_DecodeValue->Encode ( t_Encode ) ;

			m_PropertyContainer [ var_bind_index - 1 ].m_ObjectIdentifierComponent [ t_Index + 1 ] = ( SnmpObjectIdentifier * ) t_Encode.Copy () ;
			t_Index ++ ;
		}

		SnmpObjectIdentifier t_AdvanceObjectIdentifier ( 0 , NULL ) ;

		t_Evaluation = EvaluateResponse (

			var_bind_index - 1 ,
			t_KeyCount ,
			t_AdvanceObjectIdentifier
		) ;

		if ( t_Evaluation > 0 )
		{
			SnmpNull t_SnmpNull ;
			SnmpVarBind t_VarBind ( t_AdvanceObjectIdentifier , t_SnmpNull ) ;
			sendVarBind = t_VarBind ;
		}

		for ( t_Index = 0 ; t_Index < m_PropertyContainer [ var_bind_index - 1 ].m_KeyCount ; t_Index ++ )
		{
			delete m_PropertyContainer [ var_bind_index - 1 ].m_ObjectIdentifierComponent [ t_Index + 1 ] ;
			m_PropertyContainer [ var_bind_index - 1 ].m_ObjectIdentifierComponent [ t_Index + 1 ] = NULL ;
		}
	}

	return t_Evaluation ;
}

LONG AutoRetrieveOperation :: EvaluateResponse (

	IN ULONG a_PropertyIndex ,
	IN ULONG &a_CurrentIndex ,
	IN SnmpObjectIdentifier &a_AdvanceObjectIdentifier 
)
{
	LONG t_Evaluation = 0 ;
	BOOL t_UseStartAsAdvance = FALSE ;

	for ( ULONG t_Index = 0 ; t_Index < m_PropertyContainer [ a_PropertyIndex ].m_KeyCount ; t_Index ++ )
	{
		SnmpObjectIdentifier *t_Encode = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ t_Index + 1 ] ;
		SnmpObjectIdentifier *t_Start = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index + 1 ] ;
		if ( t_Start )
		{
/*
 *	We have a start which is not negatively infinite
 */
			if ( *t_Encode > *t_Start )
			{
/*
 *	The encoded object from the device is greater than the start value, so add the encoded value
 *  to the running total.
 */
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Encode ;
			}			
			else if ( *t_Encode == *t_Start )
			{
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Encode ;
			}
			else
			{

/*
 * Encoded value is less than start value so we need to advance to the start value
 */

				t_UseStartAsAdvance = TRUE ;

/*
 *	The encoded object from the device is less than the start value, so add the encoded value
 *  to the running total.
 */
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Start ;
			}
		}
		else
		{
/*
 * Start is negatively infinite
 */
			if ( t_UseStartAsAdvance )
			{
/*
 *	We have already identified a starting position which is greater than the encoded value.
 *  The new value is a negative infinite so we should stop here
 */
				t_Index ++ ;
				break ;
			}
			else
			{
/*
 *	The start position is negatively infinite and we haven't had to use a different value from the one
 *  returned from the device.
 */
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Encode ;
			}
		}


/*
 * The value was not taken from the start value with an 
 * infinite range on next key index, so we must check to see if the range is less than the 'end'
 */

		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index + 1 ] ;
		WmiRangeNode *t_Range = t_KeyPartition->GetRange () ;
		SnmpObjectIdentifier *t_End = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index + 1 ] ;
		if ( t_End )
		{
			BOOL t_InRange = ( ( t_Range->ClosedUpperBound () && ( *t_Encode <= *t_End ) ) ||
							 ( ! t_Range->ClosedUpperBound () && ( *t_Encode < *t_End ) ) ) ;

			
			if ( t_InRange )
			{
/*
 *	We are still within the boundaries
 */
			}
			else
			{
/*
*  Move to new partition because we have moved past end 
*/

				SnmpObjectIdentifier t_StartObjectIdentifier ( 0 , NULL ) ;

/*
 *	Advance to the next partition, we will use the next partition starting point for next request
 */
				t_Evaluation = EvaluateSubsequentVarBind ( 

					a_PropertyIndex , 
					a_CurrentIndex ,
					a_AdvanceObjectIdentifier ,
					t_StartObjectIdentifier 
				) ;

				if ( t_Evaluation >= 0 )
				{
					a_AdvanceObjectIdentifier = t_StartObjectIdentifier ;
				}

				t_UseStartAsAdvance = FALSE ;

				t_Index ++ ;
				break ;
			}
		}
		else
		{
/*
 *	Range is infinite so go on to next
 */
		}
	}

	if ( t_UseStartAsAdvance ) 
	{
/*
 *	We have got all the way to the end without move to the end of a partition and have used new start position
 */

		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] ;
		WmiRangeNode *t_Range = t_KeyPartition->GetRange () ;

		if( t_Range->ClosedLowerBound () )
		{
			if ( ! DecrementObjectIdentifier ( a_AdvanceObjectIdentifier , a_AdvanceObjectIdentifier ) )
			{
				t_Evaluation = -1 ;
				return t_Evaluation ;
			}
		}

		t_Evaluation = 1 ;
	}

	return t_Evaluation ;
}

LONG AutoRetrieveOperation :: EvaluateInitialVarBind ( 

	ULONG a_PropertyIndex ,
	SnmpObjectIdentifier &a_CurrentIdentifier ,
	SnmpObjectIdentifier &a_StartIdentifier 
)
{
	LONG t_Scoped = -1 ;

	PartitionSet *t_Partition = eventObject->GetPartitionSet () ;
	if ( t_Partition )
	{
		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
		ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;

		if ( ! m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex )
		{
			m_PropertyContainer [ a_PropertyIndex ].m_KeyCount = t_KeyCount ;
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart = new SnmpObjectIdentifier * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd = new SnmpObjectIdentifier * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent = new SnmpObjectIdentifier * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition  = new PartitionSet * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex = new ULONG [ t_KeyCount + 1 ] ;

			for ( ULONG t_Index = 0 ; t_Index <= t_KeyCount ; t_Index ++ ) 
			{
				m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ] = NULL ;
				m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] = NULL ;
				m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ t_Index ] = NULL ;
				m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ t_Index ] = 0 ;
				m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] = t_Partition ;
				t_Partition = t_Partition->GetPartition ( 0 ) ;
			}

			t_Scoped = EvaluateVarBind ( a_PropertyIndex , a_StartIdentifier ) ;
		}
	}

	return t_Scoped ;
}

LONG AutoRetrieveOperation :: EvaluateSubsequentVarBind ( 

	ULONG a_PropertyIndex ,
	ULONG &a_CurrentIndex ,
	SnmpObjectIdentifier &a_CurrentIdentifier ,
	SnmpObjectIdentifier &a_StartIdentifier 
)
{
	LONG t_Scoped = -1 ;

	SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
	ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;

	BOOL t_Complete = FALSE ;

	BOOL t_AdvanceInsidePartition = FALSE ;

	while ( ! t_Complete )
	{
		if ( a_CurrentIndex > 0 )
		{
			if ( t_AdvanceInsidePartition )
			{
				SnmpObjectIdentifier *t_Encode = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ a_CurrentIndex ] ;

				BOOL t_Incremented = IncrementObjectIdentifier ( *t_Encode , *t_Encode ) ;
				if ( t_Incremented )
				{
					t_Scoped = EvaluateResponse ( 

						a_PropertyIndex ,
						a_CurrentIndex ,
						a_StartIdentifier
					) ;

					t_Complete = TRUE ;
				}
				else
				{
/*
*	Increment failed so next time around loop to next partition
*/
					t_AdvanceInsidePartition = FALSE ;
				}
			}
			else
			{
/*
*	Get the current partition index and increment to get next possible partition index
*/
				ULONG t_PartitionIndex = m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ a_CurrentIndex - 1 ] + 1 ;

/*
* Get the parent partition set associated with the current key partition
*/

				PartitionSet *t_ParentPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition  [ a_CurrentIndex - 1 ] ;

/*
*	Check there are more partitions left to scan
*/
				if ( t_PartitionIndex >= t_ParentPartition->GetPartitionCount () )
				{
					if ( ! t_AdvanceInsidePartition )
					{
/*
*	Reset the current partition value to NULL object identifier
*/

						*m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ a_CurrentIndex ] = SnmpObjectIdentifier ( 0 , NULL ) ;

/*
* No more partitions for this key, move to previous key and attempt to get next value for that key
*/
						t_AdvanceInsidePartition = TRUE ;
						a_CurrentIndex -- ;
/*
* We are not in the scope for this key
*/
						t_Scoped = 0 ;
					}
				}
				else
				{
/*
* More partitions for this key
*
* Set the partition for the current ( keyindex == t_CurrentIndex - 1 ) to t_PartitionIndex 
*/

					m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ a_CurrentIndex - 1 ] = t_PartitionIndex ;
/*
* Move to the next partition for ( keyIndex == t_CurrentIndex - 1 ) and t_PartitionIndex
*/
					m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ a_CurrentIndex ] = t_ParentPartition->GetPartition ( t_PartitionIndex ) ;

					for ( ULONG t_Index = a_CurrentIndex ; t_Index < t_KeyCount ; t_Index ++ )
					{
						m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ t_Index ] = 0 ;
					}

					t_Scoped = EvaluateVarBind ( a_PropertyIndex , a_StartIdentifier ) ;

					if ( a_StartIdentifier < a_CurrentIdentifier ) 
					{
						a_StartIdentifier = a_CurrentIdentifier ;
					}

					PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ a_CurrentIndex ] ;
					WmiRangeNode *t_Range = t_KeyPartition->GetRange () ;
					SnmpObjectIdentifier *t_End = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ a_CurrentIndex ] ;
					if ( t_End )
					{
						BOOL t_InRange = ( ( t_Range->ClosedUpperBound () && ( a_StartIdentifier <= *t_End ) ) ||
										 ( ! t_Range->ClosedUpperBound () && ( a_StartIdentifier < *t_End ) ) ) ;

			
						if ( t_InRange )
						{
							t_Complete = TRUE ;
						}
						else
						{
							a_StartIdentifier = SnmpObjectIdentifier ( 0 , NULL ) ;
						}

					}
					else
					{
						t_Complete = TRUE ;
					}
				}
			}
		}
		else
		{
			t_Complete = TRUE ;
		}
	}

	return t_Scoped ;
}

LONG AutoRetrieveOperation :: EvaluateVarBind ( 

	ULONG a_PropertyIndex ,
	SnmpObjectIdentifier &a_StartIdentifier 
)
{
	LONG t_Scoped = 0 ;

	SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
	ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;

	BOOL t_FoundInfinite = FALSE ;

	WbemSnmpProperty *t_KeyProperty = NULL ;
	t_SnmpObject->ResetKeyProperty () ;
	for ( ULONG t_Index = 1 ; t_Index <= t_KeyCount ; t_Index ++ ) 
	{
		t_KeyProperty = t_SnmpObject->NextKeyProperty () ;

		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] ;
		WmiRangeNode *t_Range = t_KeyPartition->GetRange () ;
		
		if ( t_Range->InfiniteLowerBound () )
		{
			t_FoundInfinite = TRUE ;
		}
		else
		{
			// if we are in the middle partition we need to delete
			//
			// 00 <- 0				| 0 <---> n					| n -> 00
			// infinite lowerbound	| no infinite lowerbound	| no infinite lowerbound
			//
			// it may be allocated before and none will delete it
			
			if ( m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ] )
			{
				delete m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ];
				m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ] = NULL;
			}

			t_Scoped = 1 ;

			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ] = new SnmpObjectIdentifier ( 0 , NULL ) ;

			if ( typeid ( *t_Range ) == typeid ( WmiUnsignedIntegerRangeNode ) )
			{
				WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_Range ;
				ULONG t_Integer = t_Node->LowerBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ]  ) ;

				if ( ! t_FoundInfinite ) 
				{
					t_KeyProperty->Encode ( t_Variant , a_StartIdentifier ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
			else if ( typeid ( *t_Range ) == typeid ( WmiSignedIntegerRangeNode ) )
			{
				WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) t_Range  ;
				LONG t_Integer = t_Node->LowerBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ]  ) ;

				if ( ! t_FoundInfinite ) 
				{
					t_KeyProperty->Encode ( t_Variant , a_StartIdentifier ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
			if ( typeid ( *t_Range ) == typeid ( WmiStringRangeNode ) )
			{
				WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_Range ;
				BSTR t_String = t_Node->LowerBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( t_String ) ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ]  ) ;

				if ( ! t_FoundInfinite ) 
				{
					t_KeyProperty->Encode ( t_Variant , a_StartIdentifier ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
		}

		if ( ( t_Index == t_KeyCount ) && t_Range->ClosedLowerBound () )
		{
			BOOL t_Decremented = DecrementObjectIdentifier ( 

				a_StartIdentifier , 
				a_StartIdentifier
			) ;
			
			t_Scoped = t_Decremented ? 1 : 0 ;
		}
	}

	t_SnmpObject->ResetKeyProperty () ;
	for ( t_Index = 1 ; t_Index <= t_KeyCount ; t_Index ++ ) 
	{
		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] ;
		WmiRangeNode *t_Range = t_KeyPartition->GetRange () ;

		t_KeyProperty = t_SnmpObject->NextKeyProperty () ;

		if ( ! t_Range->InfiniteUpperBound () )
		{
			// if we are in the middle partition we need to delete
			//
			// 00 <- 0					| 0 <---> n					| n -> 00
			// no infinite upperbound	| no infinite lowerbound	| infinite lowerbound
			//
			// it may be allocated before and none will delete it
			
			if ( m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] )
			{
				delete m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ];
				m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] = NULL;
			}

			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] = new SnmpObjectIdentifier ( 0 , NULL ) ;
			
			if ( typeid ( *t_Range ) == typeid ( WmiUnsignedIntegerRangeNode ) )
			{
				WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_Range ;
				ULONG t_Integer = t_Node->UpperBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ]  ) ;

				VariantClear ( & t_Variant ) ;
			}
			else if ( typeid ( *t_Range ) == typeid ( WmiSignedIntegerRangeNode ) )
			{
				WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) t_Range  ;
				LONG t_Integer = t_Node->UpperBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ]  ) ;

				VariantClear ( & t_Variant ) ;
			}
			if ( typeid ( *t_Range ) == typeid ( WmiStringRangeNode ) )
			{
				WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_Range ;
				BSTR t_String = t_Node->UpperBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( t_String ) ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] ) ;

				VariantClear ( & t_Variant ) ;
			}

			if ( t_Range->ClosedUpperBound () )
			{
				SnmpObjectIdentifier *t_End = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] ;
				if ( IncrementObjectIdentifier ( * t_End , * t_End ) )
				{
				}
				else
				{
					if ( m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] )
					{
						delete m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ];
						m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] = NULL;
					}
				}
			}
		}
	}

	return t_Scoped ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\snmpqset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "snmpget.h"
#include "snmpset.h"
#include "snmpqset.h"

SetQueryOperation :: SetQueryOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpSetResponseEventObject *eventObjectArg 

) :	SnmpGetOperation ( sessionArg ) , 
	session ( &sessionArg ) ,
	eventObject ( eventObjectArg ) ,
	rowReceived ( FALSE )
{
}

SetQueryOperation :: ~SetQueryOperation ()
{
	session->DestroySession () ;
}

void SetQueryOperation :: ReceiveResponse () 
{
	eventObject->ReceiveComplete () ;
}

void SetQueryOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	if ( ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchObject ) ) || ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchInstance ) ) )
	{
	}
	else
	{
		rowReceived = TRUE ;
	}
}

#pragma warning (disable:4065)

void SetQueryOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{
// Invalid property requested
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}
}

#pragma warning (default:4065)

void SetQueryOperation :: Send ()
{
// Send Variable Bindings for requested properties

	SnmpVarBindList varBindList ;
	SnmpNull snmpNull ;

// Create class object for subsequent receipt of response

// Add Variable binding to Variable binding list

	SnmpClassObject *snmpObject = eventObject->GetSnmpClassObject () ;
	if ( snmpObject )
	{
// Encode Variable Binding instance for all key properties

		SnmpObjectIdentifier instanceObjectIdentifier ( NULL , 0 ) ;

		if ( snmpObject->GetKeyPropertyCount () )
		{
			WbemSnmpProperty *property ;
			snmpObject->ResetKeyProperty () ;
			while ( property = snmpObject->NextKeyProperty () )
			{
				instanceObjectIdentifier = property->GetValue()->Encode ( instanceObjectIdentifier ) ;
			}
		}	
		else
		{
			SnmpIntegerType integerType ( ( LONG ) 0 , NULL ) ;
			instanceObjectIdentifier = integerType.Encode ( instanceObjectIdentifier ) ;
		}

		WbemSnmpProperty *property ;
		snmpObject->ResetProperty () ;
		while ( property = snmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				BOOL t_Status = ( snmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( snmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
						if ( qualifier )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
								SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
								SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
								SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

								SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

		// Add Variable binding to list

								SnmpVarBind varBind ( requestIdentifier , snmpNull ) ;
								varBindList.Add ( varBind ) ;
							}
							else
							{
		// Problem Here
							}
						}
						else
						{
		// Problem Here
						}
					}
					else
					{
	// Don't Send properties marked as virtual key
					} 
				}
			} 
		}

// Finally Send request

		SendRequest ( varBindList ) ;
	}
	else
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\snmpobj.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <winerror.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpobj.h>

static SnmpMap <wchar_t *,wchar_t *,ULONG,ULONG> mibTypeMap ;

BOOL InitialiseMibTypeMap ()
{
	mibTypeMap [ WBEM_TYPE_INTEGER ]			= WBEM_INDEX_TYPE_INTEGER ;
	mibTypeMap [ WBEM_TYPE_INTEGER32 ]			= WBEM_INDEX_TYPE_INTEGER32 ;
	mibTypeMap [ WBEM_TYPE_OCTETSTRING ]		= WBEM_INDEX_TYPE_OCTETSTRING ;
	mibTypeMap [ WBEM_TYPE_OBJECTIDENTIFIER ]	= WBEM_INDEX_TYPE_OBJECTIDENTIFIER ;
	mibTypeMap [ WBEM_TYPE_NULL ]				= WBEM_INDEX_TYPE_NULL ;
	mibTypeMap [ WBEM_TYPE_IPADDRESS ]			= WBEM_INDEX_TYPE_IPADDRESS ;
	mibTypeMap [ WBEM_TYPE_COUNTER ]			= WBEM_INDEX_TYPE_COUNTER ;
	mibTypeMap [ WBEM_TYPE_GAUGE ]				= WBEM_INDEX_TYPE_GAUGE ;
	mibTypeMap [ WBEM_TYPE_TIMETICKS ]			= WBEM_INDEX_TYPE_TIMETICKS ;
	mibTypeMap [ WBEM_TYPE_OPAQUE ]			= WBEM_INDEX_TYPE_OPAQUE ;
	mibTypeMap [ WBEM_TYPE_NETWORKADDRESS ]	= WBEM_INDEX_TYPE_NETWORKADDRESS ;
	mibTypeMap [ WBEM_TYPE_COUNTER32 ]			= WBEM_INDEX_TYPE_COUNTER32 ;
	mibTypeMap [ WBEM_TYPE_COUNTER64 ]			= WBEM_INDEX_TYPE_COUNTER64 ;
	mibTypeMap [ WBEM_TYPE_GAUGE32 ]			= WBEM_INDEX_TYPE_GAUGE32 ;
	mibTypeMap [ WBEM_TYPE_UNSIGNED32 ]		= WBEM_INDEX_TYPE_UNSIGNED32;

	return TRUE ;
}

BOOL initialisedMibTypeMap = InitialiseMibTypeMap () ;

static SnmpMap <wchar_t *,wchar_t *,ULONG,ULONG> textualConventionMap ;

BOOL InitialiseTextualConventionMap ()
{
	textualConventionMap [ WBEM_TYPE_INTEGER ]				= WBEM_INDEX_TYPE_INTEGER ;
	textualConventionMap [ WBEM_TYPE_INTEGER32 ]			= WBEM_INDEX_TYPE_INTEGER32 ;
	textualConventionMap [ WBEM_TYPE_OCTETSTRING ]			= WBEM_INDEX_TYPE_OCTETSTRING ;
	textualConventionMap [ WBEM_TYPE_OBJECTIDENTIFIER ]	= WBEM_INDEX_TYPE_OBJECTIDENTIFIER ;
	textualConventionMap [ WBEM_TYPE_NULL ]				= WBEM_INDEX_TYPE_NULL ;
	textualConventionMap [ WBEM_TYPE_IPADDRESS ]			= WBEM_INDEX_TYPE_IPADDRESS ;
	textualConventionMap [ WBEM_TYPE_COUNTER ]				= WBEM_INDEX_TYPE_COUNTER ;
	textualConventionMap [ WBEM_TYPE_GAUGE ]				= WBEM_INDEX_TYPE_GAUGE ;
	textualConventionMap [ WBEM_TYPE_TIMETICKS ]			= WBEM_INDEX_TYPE_TIMETICKS ;
	textualConventionMap [ WBEM_TYPE_OPAQUE ]				= WBEM_INDEX_TYPE_OPAQUE ;
	textualConventionMap [ WBEM_TYPE_NETWORKADDRESS ]		= WBEM_INDEX_TYPE_NETWORKADDRESS ;
	textualConventionMap [ WBEM_TYPE_DISPLAYSTRING ]		= WBEM_INDEX_TYPE_DISPLAYSTRING ;
	textualConventionMap [ WBEM_TYPE_MACADDRESS ]			= WBEM_INDEX_TYPE_MACADDRESS ;
	textualConventionMap [ WBEM_TYPE_PHYSADDRESS ]			= WBEM_INDEX_TYPE_PHYSADDRESS ;
	textualConventionMap [ WBEM_TYPE_ENUMERATEDINTEGER ]	= WBEM_INDEX_TYPE_ENUMERATEDINTEGER ;
	textualConventionMap [ WBEM_TYPE_COUNTER32 ]			= WBEM_INDEX_TYPE_COUNTER32 ;
	textualConventionMap [ WBEM_TYPE_COUNTER64 ]			= WBEM_INDEX_TYPE_COUNTER64 ;
	textualConventionMap [ WBEM_TYPE_GAUGE32 ]				= WBEM_INDEX_TYPE_GAUGE32 ;
	textualConventionMap [ WBEM_TYPE_UNSIGNED32 ]			= WBEM_INDEX_TYPE_UNSIGNED32 ;
	textualConventionMap [ WBEM_TYPE_DATETIME ]			= WBEM_INDEX_TYPE_DATETIME ;
	textualConventionMap [ WBEM_TYPE_BITS ]				= WBEM_INDEX_TYPE_BITS ;
	textualConventionMap [ WBEM_TYPE_SNMPOSIADDRESS ]		= WBEM_INDEX_TYPE_SNMPOSIADDRESS ;
	textualConventionMap [ WBEM_TYPE_SNMPUDPADDRESS ]		= WBEM_INDEX_TYPE_SNMPUDPADDRESS ;
	textualConventionMap [ WBEM_TYPE_SNMPIPXADDRESS ]		= WBEM_INDEX_TYPE_SNMPIPXADDRESS ;
	textualConventionMap [ WBEM_TYPE_ROWSTATUS ]		= WBEM_INDEX_TYPE_ROWSTATUS ;
	return TRUE ;
}

BOOL initialisedTextualConventionMap = InitialiseTextualConventionMap () ;

static SnmpMap <ULONG,ULONG,CIMTYPE,CIMTYPE> cimTypeMap ;

BOOL InitialiseCimTypeMap ()
{
	cimTypeMap [ WBEM_INDEX_TYPE_INTEGER ]			= CIM_SINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_INTEGER32 ]			= CIM_SINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_OCTETSTRING ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_OBJECTIDENTIFIER ]	= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_NULL ]				= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_IPADDRESS ]			= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_COUNTER ]			= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_GAUGE ]				= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_TIMETICKS ]			= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_OPAQUE ]				= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_NETWORKADDRESS ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_DISPLAYSTRING ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_MACADDRESS ]			= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_PHYSADDRESS ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_ENUMERATEDINTEGER ]	= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_COUNTER32 ]			= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_COUNTER64 ]			= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_GAUGE32 ]			= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_UNSIGNED32 ]			= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_DATETIME ]			= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_BITS ]				= CIM_STRING | CIM_FLAG_ARRAY ;
	cimTypeMap [ WBEM_INDEX_TYPE_SNMPOSIADDRESS ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_SNMPUDPADDRESS ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_SNMPIPXADDRESS ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_ROWSTATUS ]			= CIM_STRING ;
	return TRUE ;
}

BOOL initialisedCimTypeMap = InitialiseCimTypeMap () ;

static SnmpMap <wchar_t *,wchar_t *,ULONG,ULONG> validQualifierMap ;

BOOL InitialiseQualifierMap ()
{
	validQualifierMap [ WBEM_QUALIFIER_TEXTUAL_CONVENTION ]			= WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION ;
	validQualifierMap [ WBEM_QUALIFIER_SYNTAX ]						= WBEM_INDEX_QUALIFIER_SYNTAX ;
	validQualifierMap [ WBEM_QUALIFIER_OBJECT_IDENTIFIER ]				= WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER ;
	validQualifierMap [ WBEM_QUALIFIER_ENCODING ]						= WBEM_INDEX_QUALIFIER_ENCODING ;
	validQualifierMap [ WBEM_QUALIFIER_FIXED_LENGTH ]					= WBEM_INDEX_QUALIFIER_FIXED_LENGTH ;
	validQualifierMap [ WBEM_QUALIFIER_VARIABLE_LENGTH ]				= WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH ;
	validQualifierMap [ WBEM_QUALIFIER_VARIABLE_VALUE ]				= WBEM_INDEX_QUALIFIER_VARIABLE_VALUE ;
	validQualifierMap [ WBEM_QUALIFIER_ENUMERATION ]					= WBEM_INDEX_QUALIFIER_ENUMERATION ;
	validQualifierMap [ WBEM_QUALIFIER_BITS ]							= WBEM_INDEX_QUALIFIER_BITS ;
	validQualifierMap [ WBEM_QUALIFIER_DISPLAY_HINT ]					= WBEM_INDEX_QUALIFIER_DISPLAY_HINT ;
	validQualifierMap [ WBEM_QUALIFIER_KEY ]							= WBEM_INDEX_QUALIFIER_KEY ;
	validQualifierMap [ WBEM_QUALIFIER_KEY_ORDER ]						= WBEM_INDEX_QUALIFIER_KEY_ORDER ;
	validQualifierMap [ WBEM_QUALIFIER_VIRTUAL_KEY ]					= WBEM_INDEX_QUALIFIER_VIRTUAL_KEY ;
	validQualifierMap [ WBEM_QUALIFIER_READ ]							= WBEM_INDEX_QUALIFIER_READ ;
	validQualifierMap [ WBEM_QUALIFIER_WRITE ]							= WBEM_INDEX_QUALIFIER_WRITE ;
	validQualifierMap [ WBEM_QUALIFIER_NOT_AVAILABLE ]					= WBEM_INDEX_QUALIFIER_NOT_AVAILABLE ;
	validQualifierMap [ WBEM_QUALIFIER_TYPE_MISMATCH ]					= WBEM_INDEX_QUALIFIER_TYPE_MISMATCH ;
	validQualifierMap [ WBEM_QUALIFIER_VALUE_MISMATCH ]					= WBEM_INDEX_QUALIFIER_VALUE_MISMATCH ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTSNMPVERSION ]				= WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTTRANSPORT ]				= WBEM_INDEX_QUALIFIER_AGENTTRANSPORT ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTADDRESS ]					= WBEM_INDEX_QUALIFIER_AGENTADDRESS ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME ]		= WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME ]		= WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTRETRYCOUNT ]				= WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTRETRYTIMEOUT ]				= WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTVARBINDSPERPDU ]			= WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE ]	= WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE ;
	validQualifierMap [ WBEM_QUALIFIER_SINGLETON ]					= WBEM_INDEX_QUALIFIER_SINGLETON ;
	validQualifierMap [ WBEM_QUALIFIER_TABLECLASS ]					= WBEM_INDEX_QUALIFIER_TABLECLASS;
	validQualifierMap [ WBEM_QUALIFIER_KEYTYPES ]					= WBEM_INDEX_QUALIFIER_KEYTYPES;
	validQualifierMap [ WBEM_QUALIFIER_KEYVALUES ]					= WBEM_INDEX_QUALIFIER_KEYVALUES;
	validQualifierMap [ WBEM_QUALIFIER_VARBINDINDEX ]				= WBEM_INDEX_QUALIFIER_VARBINDINDEX;
	validQualifierMap [ WBEM_QUALIFIER_ROWSTATUS ]				= WBEM_INDEX_QUALIFIER_ROWSTATUS;

	return TRUE ;
}

BOOL initialisedQualifierMap = InitialiseQualifierMap () ;

WbemSnmpQualifier  :: WbemSnmpQualifier (

	const wchar_t *qualifierNameArg ,
	const SnmpInstanceType *typeValueArg 

) : typeValue ( NULL ) , qualifierName (NULL )
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValueArg ) ? typeValueArg->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: WbemSnmpQualifier ( const wchar_t *qualifierNameArg = (%s) , const SnmpInstanceType *typeValueArg = (%lx),(%s) )" ,
			qualifierNameArg ,
			typeValueArg ,
			t_StringValue
		) ;
	}
	else
	{ 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: WbemSnmpQualifier ( const wchar_t *qualifierNameArg = (%s) , const SnmpInstanceType *typeValueArg = (NULL) )" ,
			qualifierNameArg ,
			typeValueArg
		) ;
	}
	delete [] t_StringValue ;


)

	qualifierName = new wchar_t [ wcslen ( qualifierNameArg ) + 1 ] ;
	wcscpy ( qualifierName , qualifierNameArg ) ;

	if ( typeValueArg )
	{
		typeValue = typeValueArg->Copy () ;
	}
}

WbemSnmpQualifier :: WbemSnmpQualifier ( const WbemSnmpQualifier &copy ) : qualifierName ( NULL ), typeValue ( NULL )
{
DebugMacro7( 

	wchar_t *t_StringValue = ( copy.typeValue ) ? copy.typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: const WbemSnmpQualifier &copy (%s),(%s) )" , 
			copy.qualifierName ,
			t_StringValue
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: const WbemSnmpQualifier &copy (%s),(NULL)" ,
			copy.qualifierName 
		) ;
	}

	delete [] t_StringValue ;
)

	qualifierName = new wchar_t [ wcslen ( copy.qualifierName ) + 1 ] ;
	wcscpy ( qualifierName , copy.qualifierName ) ;

	if ( copy.typeValue )
	{
		typeValue = copy.typeValue->Copy () ;
	}
}

WbemSnmpQualifier :: ~WbemSnmpQualifier () 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,L"WbemSnmpQualifier :: ~WbemSnmpQualifier ( (%s),(%s) )" ,
			qualifierName ? qualifierName : L"!!NULL!!",
			t_StringValue
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,L"WbemSnmpQualifier :: ~WbemSnmpQualifier ( (%s),(NULL) )" ,
			qualifierName ? qualifierName : L"!!NULL!!" 
		) ;
	}

	delete [] t_StringValue ;
)

	delete [] qualifierName ;
	delete typeValue ;
}

wchar_t *WbemSnmpQualifier :: GetName () const
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpQualifier :: GetName ( %s )" ,
		qualifierName
	) 
)

	return qualifierName ;
}

SnmpInstanceType *WbemSnmpQualifier :: GetValue () const 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( (%s), (%s) )" ,
			qualifierName ,
			t_StringValue 
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( (%s) , (NULL) )" ,
			qualifierName
		) ;
	}

	delete [] t_StringValue ;
) 

	return typeValue ;
}

BOOL WbemSnmpQualifier :: GetValue ( VARIANT &variant ) const
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( VARIANT &variant ( (%s),(%s) )" ,
			qualifierName ,
			t_StringValue
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( VARIANT &variant ( (%s),(NULL) )" ,
			qualifierName
		) ;
	}

	delete [] t_StringValue ;
) 

	BOOL status = TRUE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpObjectIdentifierType ) ) 
				{
					SnmpObjectIdentifierType *objectIdentifier = ( SnmpObjectIdentifierType * ) typeValue ;
					wchar_t *string = objectIdentifier ->GetStringValue () ;
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( string ) ;
					delete [] string ;
				}	
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_ENCODING:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
					wchar_t *string = displayString->GetValue () ;
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( string ) ;
					delete [] string ;
				}	
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) ) 
				{
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					variant.vt = VT_BOOL ;
					variant.boolVal = integer->GetValue () ? VARIANT_TRUE : VARIANT_FALSE ;
				}
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) ) 
				{
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					variant.vt = VT_I4 ;
					variant.lVal = integer->GetValue () ;
				}
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}
			break ;

			default:
			{
				status = FALSE ;
				variant.vt = VT_NULL ;
			}
		}
	}
	else
	{
		status = FALSE ;
		variant.vt = VT_NULL ;
	}

	return status ;
}

VARTYPE WbemSnmpQualifier :: GetValueVariantType () const 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpQualifier :: GetValueVariantType ()" ) ) 

	VARTYPE varType = VT_NULL ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			case WBEM_INDEX_QUALIFIER_ENCODING:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				varType = VT_BSTR ;
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				varType = VT_BOOL ;
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				varType = VT_I4 ;
			}
			break ;

			default:
			{
				varType = VT_NULL ;
			}
		}
	}
	else
	{
		varType = VT_NULL ;
	}

	return varType ;
}

BOOL WbemSnmpQualifier :: IsPropagatable () const 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpQualifier :: IsPropagatable ()" ) ) 

	BOOL status = FALSE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			case WBEM_INDEX_QUALIFIER_ENCODING:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				status = FALSE ;
			}
			break ;

			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			{
				status = TRUE ;
			}
			break ;

			default:
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpQualifier :: SetValue ( IWbemQualifierSet *a_Qualifier , const SnmpInstanceType &value ) 
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	t_Variant.vt = VT_NULL ;

	BOOL status = FALSE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			{
				if ( (typeid ( value ) == typeid ( SnmpDisplayStringType )) && typeValue) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) & value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( textualConventionMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
						SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *string = displayString->GetValue () ;
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( string ) ;
					}

					delete [] string ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_ENCODING:
			{
				if ( ( typeid ( value ) == typeid ( SnmpDisplayStringType ) ) && typeValue ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) & value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( mibTypeMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
						SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *string = displayString->GetValue () ;
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( string ) ;
					}

					delete [] string ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( (typeid ( value ) == typeid ( SnmpObjectIdentifierType ) ) && typeValue )
				{
					status = TRUE ;
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
					wchar_t *string = displayString->GetValue () ;
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( string ) ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( ( typeid ( value ) == typeid ( SnmpDisplayStringType ) ) && typeValue) 
				{
					status = TRUE ;
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
					wchar_t *string = displayString->GetValue () ;
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( string ) ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			{
				if ( typeid ( value ) == typeid ( SnmpIntegerType ) ) 
				{
					status = TRUE ;
					SnmpIntegerType *integer = typeValue ? ( SnmpIntegerType * ) typeValue : ( SnmpIntegerType * ) &value;
					t_Variant.vt = VT_BOOL ;
					t_Variant.boolVal = integer->GetValue () ? VARIANT_TRUE : VARIANT_FALSE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( ( typeid ( value ) == typeid ( SnmpIntegerType ) ) && typeValue) 
				{
					status = TRUE ;
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					t_Variant.vt = VT_BOOL ;
					t_Variant.boolVal = integer->GetValue () ? VARIANT_TRUE : VARIANT_FALSE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( ( typeid ( value ) == typeid ( SnmpIntegerType ) ) && typeValue ) 
				{
					status = TRUE ;
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					t_Variant.vt = VT_I4 ;
					t_Variant.lVal = integer->GetValue () ;
				}
			}
			break ;

			default:	
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	if ( status )
	{
		if ( value.IsValid () )
		{
			a_Qualifier->Put ( qualifierName , &t_Variant , WBEM_CLASS_PROPAGATION ) ;
		}
		else
		{
			status = FALSE ;
		}

		VariantClear ( &t_Variant ) ;
	}

	return status ;
}

BOOL WbemSnmpQualifier :: SetValue ( const SnmpInstanceType *value ) 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: SetValue ( const SnmpInstanceType *value ( (%s),(%s) ) )" ,
			qualifierName , 
			t_StringValue 
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: SetValue ( const SnmpInstanceType *value ( (%s),(NULL) ) )" ,
			qualifierName 
		) ;
	}

	delete [] t_StringValue ;
) 

	BOOL status = FALSE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			{
				if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( textualConventionMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
					}

					delete [] string ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_ENCODING:
			{
				if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( mibTypeMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
					}

					delete [] string ;
				}
			}
			break ;


			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
				{
					status = TRUE ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
				{
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( typeid ( *value ) == typeid ( SnmpIntegerType ) ) 
				{
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( typeid ( *value ) == typeid ( SnmpIntegerType ) ) 
				{
					status = TRUE ;
				}
			}
			break ;

			default:	
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	if ( status )
	{
		if ( value && value->IsValid () )
		{
			delete typeValue  ;
			typeValue = value->Copy () ;
		}
		else
		{
			status = FALSE ;
		}
	}

	return status ;
}

BOOL WbemSnmpQualifier :: SetValue ( const VARIANT &variant ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpQualifier :: SetValue ( const VARIANT &variant )" ) ) 

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			{
				if ( variant.vt == VT_BSTR )
				{
					ULONG stringItem ;
					wchar_t *string = variant.bstrVal ;
					if ( textualConventionMap.Lookup ( string , stringItem ) )
					{
						value = new SnmpDisplayStringType ( string , NULL ) ;
						status = TRUE ;
					}
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_ENCODING:
			{
				if ( variant.vt == VT_BSTR )
				{
					ULONG stringItem ;
					wchar_t *string = variant.bstrVal ;
					if ( mibTypeMap.Lookup ( string , stringItem ) )
					{
						value = new SnmpDisplayStringType ( string , NULL ) ;
						status = TRUE ;
					}
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( variant.vt == VT_BSTR )
				{
					value = new SnmpObjectIdentifierType ( variant.bstrVal ) ;
					status = TRUE ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_BITS:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( variant.vt == VT_BSTR )
				{
					value = new SnmpDisplayStringType ( variant.bstrVal , NULL ) ;
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( variant.vt == VT_UI1 )
				{
					value = new SnmpIntegerType ( variant.bVal , NULL ) ;
					status = TRUE ;
				}
				else if ( variant.vt == VT_I4 )
				{
					value = new SnmpIntegerType ( variant.lVal , NULL ) ;
					status = TRUE ;

				}
				else if ( variant.vt == VT_BOOL )
				{
					value = new SnmpIntegerType ( (variant.boolVal == VARIANT_FALSE) ? 0 : 1, NULL ) ;
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( variant.vt == VT_UI1 )
				{
					value = new SnmpIntegerType ( variant.bVal , NULL ) ;
					status = TRUE ;
				}
				else if ( variant.vt == VT_I4 )
				{
					value = new SnmpIntegerType ( variant.lVal , NULL ) ;
					status = TRUE ;
				}
			}
			break ;

			default:	
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	if ( status )
	{
		if ( value && value->IsValid () ) 
		{
			typeValue = value ;
		}
		else
		{
			status = FALSE ;
			delete value ;
		}
	}
	else
	{
		delete value ;
	}

	return status ;
}

WbemSnmpProperty :: WbemSnmpProperty ( cons