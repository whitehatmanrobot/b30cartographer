 CMacroMgr *, CTypeID *, CMacroMgrList * );
BOOL InstantiateMacros ( CInput *, CMacroMgr * );
BOOL GenerateOutput ( CInput *, COutput *, CMacroMgr *, CTypeID * );
void BuildOutputFileName ( LPSTR pszInputFileName, LPSTR pszNewOutputFileName );


class CFileList : public CList
{
    DEFINE_CLIST(CFileList, LPSTR)
};


int __cdecl main ( int argc, char * argv[] )
{
    BOOL rc;
    BOOL fShowHelp = (1 == argc);
    int i;
    LPSTR pszMainInputFile = NULL;
    LPSTR pszMainOutputFile = NULL;

    CFileList FileList;
    CMacroMgrList MacroMgrList;

    LPSTR psz;
    char szScratch[MAX_PATH];

    // output product information
    printf("ASN.1 Compiler Preprocessor V0.1\n");
    printf("Copyright (C) Microsoft Corporation, 1998. All rights reserved.\n");

    // parse command line
    for (i = 1; i < argc; i++)
    {
        if ('-' == *argv[i])
        {
            // parse the option
            if (0 == ::strcmp(argv[i], "-h"))
            {
                fShowHelp = TRUE;
            }
            else
            if (0 == ::strcmp(argv[i], "-o"))
            {
                pszMainOutputFile = ::My_strdup(argv[++i]);
                ASSERT(NULL != pszMainOutputFile);
            }
            else
            {
                fprintf(stderr, "Unknown option [%s]\n", argv[i]);
                fShowHelp = TRUE;
                break;
            }
        }
        else
        {
            // must be a file name
            FileList.Append(argv[i]);

            // the last file will be the main input file
            pszMainInputFile = argv[i];
        }
    }

    // output help information if needed
    if (fShowHelp || 0 == FileList.GetCount() || NULL == pszMainInputFile)
    {
        printf("Usage: %s [options] [imported.asn ...] main.asn\n", argv[0]);
        printf("Options:\n");
        printf("-h\t\tthis help\n");
        printf("-o filename\toutput file name\n");
        return EXIT_SUCCESS;
    }

    // construct outpt file name if needed
    if (NULL == pszMainOutputFile)
    {
        // create an output file
        ::BuildOutputFileName(pszMainInputFile, &szScratch[0]);
        pszMainOutputFile = ::My_strdup(&szScratch[0]);
        ASSERT(NULL != pszMainOutputFile);
    }

    // input and output files must have a different name.
    ASSERT(0 != ::strcmp(pszMainInputFile, pszMainOutputFile));

    // expand macros in the files
    FileList.Reset();
    while (NULL != (psz = FileList.Iterate()))
    {
        if (0 != ::strcmp(psz, pszMainInputFile))
        {
            ::BuildOutputFileName(psz, &szScratch[0]);
            rc = ::ExpandFile(psz, &szScratch[0], &MacroMgrList);
            ASSERT(rc);

            // remove all the instances of macros
            MacroMgrList.Uninstance();
        }
        else
        {
            // it is main input file
            rc = ::ExpandFile(pszMainInputFile, pszMainOutputFile, &MacroMgrList);
            ASSERT(rc);
        }
    }

    //
    // Cleanup
    //
    delete pszMainOutputFile;
    MacroMgrList.DeleteList();

    return EXIT_SUCCESS;
}


BOOL ExpandFile
(
    LPSTR           pszInputFile,
    LPSTR           pszOutputFile,
    CMacroMgrList  *pMacroMgrList
)
{
    BOOL rc, rc1, rc2;
    CInput *pInput = NULL;
    COutput *pOutput = NULL;
    CTypeID *pTypeID = NULL;
    CMacroMgr *pMacroMgr = NULL;

    pInput = new CInput(&rc1, pszInputFile);
    pOutput = new COutput(&rc2, pszOutputFile);
    pTypeID = new CTypeID();
    pMacroMgr = new CMacroMgr();
    if (NULL != pInput && rc1 &&
        NULL != pOutput && rc2 &&
        NULL != pTypeID &&
        NULL != pMacroMgr)
    {
        //
        // Locate a list of macros
        //
        rc = ::CollectMacros(pInput, pMacroMgr, pTypeID, pMacroMgrList);
        if (rc)
        {
            rc = pInput->Rewind();
            ASSERT(rc);

            //
            // Create instances of macros
            //
            rc = ::InstantiateMacros(pInput, pMacroMgr);
            if (rc)
            {
                rc = pInput->Rewind();
                ASSERT(rc);

                //
                // Generate macro-expanded file
                //
                rc = ::GenerateOutput(pInput, pOutput, pMacroMgr, pTypeID);
                ASSERT(rc);
            }
            else
            {
                ASSERT(rc);
            }
        }
        else
        {
            ASSERT(rc);
        }
    }
    else
    {
        ASSERT(0);
    }

    //
    // Cleanup
    //
    if (NULL != pMacroMgrList && NULL != pMacroMgr)
    {
        pMacroMgrList->Append(pMacroMgr);
    }
    else
    {
        delete pMacroMgr;
    }
    delete pTypeID;
    delete pOutput;
    delete pInput;

    return rc;
}


BOOL CollectMacros
(
    CInput          *pInput,
    CMacroMgr       *pMacroMgr,
    CTypeID         *pTypeID,
    CMacroMgrList   *pMacroMgrList
)
{
    CNameList   NameList(16);

    // Create a running symbol handler
    CSymbol *pSym = new CSymbol(pInput);
    if (NULL == pSym)
    {
        return FALSE;
    }

    BOOL rc;
    BOOL fWasNewLine = TRUE;
    BOOL fEndMacro = FALSE;
    UINT cInsideBigBracket = 0;
    BOOL fInsideComment = FALSE;

    char szNameScratch[MAX_PATH];

    // Get the module name first
    pSym->NextUsefulSymbol();
    if (pSym->GetID() == SYMBOL_IDENTIFIER)
    {
        ::strcpy(&szNameScratch[0], pSym->GetStr());
        pSym->NextUsefulSymbol();
        if (pSym->GetID() == SYMBOL_KEYWORD &&
            0 == ::strcmp(pSym->GetStr(), "DEFINITIONS"))
        {
            pMacroMgr->AddModuleName(&szNameScratch[0]);
        }
    }

    // Rewind the input file
    rc = pInput->Rewind();
    ASSERT(rc);

    // Walk through the text
    while (pSym->NextSymbol())
    {
        // printf("symbol:id[%d], str[%s]\n", pSym->GetID(), pSym->GetStr());

        if (pSym->GetID() == SYMBOL_SPACE_EOL)
        {
            fWasNewLine = TRUE;
            fInsideComment = FALSE;
            continue;
        }

        if (pSym->IsComment())
        {
            fInsideComment = ! fInsideComment;
        }
        else
        if (! fInsideComment)
        {
            if (pSym->IsLeftBigBracket())
            {
                cInsideBigBracket++;
            }
            else
            if (pSym->IsRightBigBracket())
            {
                cInsideBigBracket--;
            }
            else
            // The macro must be outside the big brackets and
            // in the beginning of a line.
            if (fWasNewLine &&
                (0 == cInsideBigBracket) &&
                (pSym->GetID() == SYMBOL_IDENTIFIER))
            {
                ::strcpy(&szNameScratch[0], pSym->GetStr());
                pSym->NextUsefulSymbol();
                if (pSym->IsLeftBigBracket())
                {
                    cInsideBigBracket++;
                    CMacro *pMacro = new CMacro(&rc, &szNameScratch[0]);
                    ASSERT(NULL != pMacro);
                    ASSERT(rc);

                    // process argument list
                    do
                    {
                        pSym->NextUsefulSymbol();
                        pMacro->SetArg(pSym->GetStr());
                        pSym->NextUsefulSymbol();
                    }
                    while (pSym->IsComma());
                    ASSERT(pSym->IsRightBigBracket());
                    if (pSym->IsRightBigBracket())
                    {
                        cInsideBigBracket--;
                    }

                    // save the macro body
                    ASSERT(0 == cInsideBigBracket);
                    fEndMacro = FALSE;
                    while (! fEndMacro || pSym->GetID() != SYMBOL_SPACE_EOL)
                    {
                        pSym->NextSymbol();
                        if (pSym->GetID() == SYMBOL_SPACE_EOL)
                        {
                            fInsideComment = FALSE;
                        }
                        else
                        if (pSym->IsComment())
                        {
                            fInsideComment = ! fInsideComment;
                        }
                        else
                        if (! fInsideComment)
                        {
                            if (pSym->IsLeftBigBracket())
                            {
                                cInsideBigBracket++;
                            }
                            else
                            if (pSym->IsRightBigBracket())
                            {
                                cInsideBigBracket--;
                                if (0 == cInsideBigBracket && ! fEndMacro)
                                {
                                    // basically, it is the end of macro
                                    pMacro->SetBodyPart(pSym->GetStr());
                                    fEndMacro = TRUE;
                                }
                            }
                        } // while

                        // throw away anything possibly in CONSTRAINED BY
                        if (! fEndMacro)
                        {
                            pMacro->SetBodyPart(pSym->GetStr());
                        }
                    } // while

                    // macro must end with a eol
                    fWasNewLine = TRUE;
                    fInsideComment = FALSE;

                    // write out the eol
                    pMacro->SetBodyPart("\n");

                    // take a note of ending a macro
                    pMacro->EndMacro();
                    pMacroMgr->AddMacro(pMacro);

                    // to avoid fWasNewLine being reset.
                    continue;
                } // if left bracket
                else
                if (pSym->GetID() == SYMBOL_DEFINITION)
                {
                    pSym->NextUsefulSymbol();
                    if (pSym->GetID() == SYMBOL_IDENTIFIER &&
                        pTypeID->FindAlias(pSym->GetStr()))
                    {
                        // Found a type identifier
                        pSym->NextSymbol();
                        if (pSym->IsDot())
                        {
                            pSym->NextSymbol();
                            if (pSym->GetID() == SYMBOL_FIELD &&
                                0 == ::strcmp("&Type", pSym->GetStr()))
                            {
                                // defined type identifier
                                pSym->NextUsefulSymbol();
                                ASSERT(pSym->IsLeftParenth());
                                if (pSym->IsLeftParenth())
                                {
                                    pSym->NextUsefulSymbol();
                                    if (pSym->GetID() == SYMBOL_IDENTIFIER)
                                    {
                                        rc = pTypeID->AddInstance(&szNameScratch[0], pSym->GetStr());
                                        ASSERT(rc);

                                        pSym->NextUsefulSymbol();
                                        ASSERT(pSym->IsRightParenth());
                                    }
                                }
                            }
                        }
                        else
                        {
                            rc = pTypeID->AddAlias(&szNameScratch[0]);
                            ASSERT(rc);
                        }
                    }
                } // if symbol definition
            } // if symbol identifier
            else
            if (fWasNewLine &&
                (0 == cInsideBigBracket) &&
                (pSym->GetID() == SYMBOL_KEYWORD) &&
                (0 == ::strcmp("IMPORTS", pSym->GetStr())))
            {
                // skip the entire import area
                do
                {
                    pSym->NextUsefulSymbol();
                    if (pSym->GetID() == SYMBOL_IDENTIFIER)
                    {
                        ::strcpy(&szNameScratch[0], pSym->GetStr());
                        pSym->NextUsefulSymbol();
                        if (pSym->IsLeftBigBracket())
                        {
                            NameList.AddName(&szNameScratch[0]);
                            pSym->NextUsefulSymbol();
                            ASSERT(pSym->IsRightBigBracket());
                        }
                    }
                    // else // no else because the current symbol can be FROM
                    if (pSym->GetID() == SYMBOL_KEYWORD &&
                        0 == ::strcmp("FROM", pSym->GetStr()))
                    {
                        pSym->NextUsefulSymbol();
                        if (pSym->GetID() == SYMBOL_IDENTIFIER)
                        {
                            LPSTR pszName;
                            CMacro *pMacro;
                            while (NULL != (pszName = NameList.Get()))
                            {
                                pMacro = pMacroMgrList->FindMacro(pSym->GetStr(), pszName);
                                if (NULL != pMacro)
                                {
                                    pMacro = new CMacro(&rc, pMacro);
                                    if (NULL != pMacro && rc)
                                    {
                                        pMacroMgr->AddMacro(pMacro);
                                    }
                                    else
                                    {
                                        ASSERT(0);
                                    }
                                }
                                else
                                {
                                    ASSERT(0);
                                }
                                delete pszName;
                            } // while
                        }
                    }
                }
                while (! pSym->IsSemicolon());
            }
        } // if ! comment

        // Must be reset at the end of this block.
        fWasNewLine = FALSE;
    } // while

    delete pSym;
    return TRUE;
}


BOOL InstantiateMacros
(
    CInput          *pInput,
    CMacroMgr       *pMacroMgr
)
{
    // Create a running symbol handler
    CSymbol *pSym = new CSymbol(pInput);
    if (NULL == pSym)
    {
        return FALSE;
    }

    BOOL rc;
    BOOL fInsideComment = FALSE;
    UINT cInsideBigBracket = 0;

    // Walk through the text
    while (pSym->NextSymbol())
    {
        if (pSym->GetID() == SYMBOL_SPACE_EOL)
        {
            fInsideComment = FALSE;
        }
        else
        if (pSym->IsComment())
        {
            fInsideComment = ! fInsideComment;
        }
        else
        if (! fInsideComment)
        {
            if (pSym->IsLeftBigBracket())
            {
                cInsideBigBracket++;
            }
            else
            if (pSym->IsRightBigBracket())
            {
                cInsideBigBracket--;
            }
            else
            if ((0 < cInsideBigBracket) &&
                (pSym->GetID() == SYMBOL_IDENTIFIER))
            {
                CMacro *pMacro = pMacroMgr->FindMacro(pSym->GetStr());
                if (NULL != pMacro)
                {
                    UINT cCurrBracket = cInsideBigBracket;

                    // Found a macro instance
                    pSym->NextUsefulSymbol();
                    if (pSym->IsLeftBigBracket())
                    {
                        cInsideBigBracket++;

                        // We need to process the argument list now.
                        do
                        {
                            pSym->NextUsefulSymbol();
                            pMacro->SetArg(pSym->GetStr());
                            pSym->NextUsefulSymbol();
                        }
                        while (pSym->IsComma());

                        ASSERT(pSym->IsRightBigBracket());
                        if (pSym->IsRightBigBracket())
                        {
                            cInsideBigBracket--;
                        }
                        ASSERT(cCurrBracket == cInsideBigBracket);

                        rc = pMacro->InstantiateMacro();
                        ASSERT(rc);
                    }
                }
            }
        } // ! inside comment
    } // while

    delete pSym;
    return TRUE;
}


BOOL GenerateOutput
(
    CInput          *pInput,
    COutput         *pOutput,
    CMacroMgr       *pMacroMgr,
    CTypeID         *pTypeID
)
{
    // Create a running symbol handler
    CSymbol *pSym = new CSymbol(pInput);
    if (NULL == pSym)
    {
        return FALSE;
    }

    BOOL rc;
    BOOL fWasNewLine = FALSE;
    BOOL fEndMacro = FALSE;
    UINT cInsideBigBracket = 0;
    BOOL fInsideComment = FALSE;
    BOOL fIgnoreThisSym = FALSE;
    BOOL fInsideImport = FALSE;
    UINT nOutputImportedMacrosNow = 0;

    // Walk through the text
    while (pSym->NextSymbol())
    {
        fIgnoreThisSym = FALSE; // default is to output this symbol

        if (pSym->GetID() == SYMBOL_SPACE_EOL)
        {
            fWasNewLine = TRUE;
            fInsideComment = FALSE;
        }
        else
        {
            if (pSym->IsComment())
            {
                fInsideComment = ! fInsideComment;
            }
            else
            if (! fInsideComment)
            {
                if (pSym->IsLeftBigBracket())
                {
                    cInsideBigBracket++;
                }
                else
                if (pSym->IsRightBigBracket())
                {
                    cInsideBigBracket--;
                }
                else
                if (pSym->IsSemicolon())
                {
                    fInsideImport = FALSE;
                    nOutputImportedMacrosNow++;
                }
                else
                // The macro must be outside the big brackets and
                // in the beginning of a line.
                if (fWasNewLine &&
                    (0 == cInsideBigBracket) &&
                    (pSym->GetID() == SYMBOL_IDENTIFIER))
                {
                    CMacro *pMacro;
                    LPSTR pszOldSubType;

                    if (NULL != (pMacro = pMacroMgr->FindMacro(pSym->GetStr())))
                    {
                        // Found a macro template
                        fIgnoreThisSym = TRUE;

                        if (! pMacro->IsImported())
                        {
                            // Output all instances of this macro.
                            rc = pMacro->OutputInstances(pOutput);
                            ASSERT(rc);

                            // Ignore the macro template body
                            pSym->NextUsefulSymbol();
                            if (pSym->IsLeftBigBracket())
                            {
                                cInsideBigBracket++;

                                // Ignore the argument list
                                do
                                {
                                    // yes, two calls... not a mistake!
                                    pSym->NextUsefulSymbol();
                                    pSym->NextUsefulSymbol();
                                }
                                while (pSym->IsComma());
                                ASSERT(pSym->IsRightBigBracket());
                                if (pSym->IsRightBigBracket())
                                {
                                    cInsideBigBracket--;
                                }

                                // Ignore the macro body
                                ASSERT(0 == cInsideBigBracket);
                                fEndMacro = FALSE;
                                while (! fEndMacro || pSym->GetID() != SYMBOL_SPACE_EOL)
                                {
                                    pSym->NextSymbol();
                                    if (pSym->GetID() == SYMBOL_SPACE_EOL)
                                    {
                                        fInsideComment = FALSE;
                                    }
                                    else
                                    if (pSym->IsComment())
                                    {
                                        fInsideComment = ! fInsideComment;
                                    }
                                    else
                                    if (! fInsideComment)
                                    {
                                        if (pSym->IsLeftBigBracket())
                                        {
                                            cInsideBigBracket++;
                                        }
                                        else
                                        if (pSym->IsRightBigBracket())
                                        {
                                            cInsideBigBracket--;
                                            if (0 == cInsideBigBracket)
                                            {
                                                // basically, it is the end of macro
                                                fEndMacro = TRUE;
                                            }
                                        }
                                    }
                                } // while

                                // macro must end with a eol
                                fWasNewLine = TRUE;
                                fInsideComment = FALSE;

                                // to avoid fWasNewLine being reset
                                // it is ok to continue because we do not output this symbol.
                                ASSERT(fIgnoreThisSym);
                                continue;
                            } // if left bracket
                        } // ! imported
                        else
                        {
                            // Ignore the macro template body
                            pSym->NextUsefulSymbol();
                            ASSERT(pSym->IsLeftBigBracket());
                            pSym->NextUsefulSymbol();
                            ASSERT(pSym->IsRightBigBracket());
                            pSym->NextUsefulSymbol();
                            if (! pSym->IsComma())
                            {
                                fIgnoreThisSym = FALSE;
                            }
                        } // imported
                    } // if pMacro
                    else
                    if (pTypeID->FindAlias(pSym->GetStr()))
                    {
                        // Found a type ID alias. Let's skip this line entirely
                        do
                        {
                            pSym->NextSymbol();
                        }
                        while (pSym->GetID() != SYMBOL_SPACE_EOL);
                    } // if find alias
                    else
                    if (NULL != (pszOldSubType = pTypeID->FindInstance(pSym->GetStr())))
                    {
                        // Found a type ID instance. Let's output the construct.
                        rc = pTypeID->GenerateOutput(pOutput, pSym->GetStr(), pszOldSubType);
                        ASSERT(rc);

                        // Skip the body entirely
                        do
                        {
                            pSym->NextUsefulSymbol();
                        }
                        while (! pSym->IsRightParenth());

                        // Skip the rest of this line
                        do
                        {
                            pSym->NextSymbol();
                        }
                        while (pSym->GetID() != SYMBOL_SPACE_EOL);
                    } // if find instance
                }
                else
                if ((0 < cInsideBigBracket) &&
                    (pSym->GetID() == SYMBOL_IDENTIFIER))
                {
                    CMacro *pMacro = pMacroMgr->FindMacro(pSym->GetStr());
                    if (NULL != pMacro)
                    {
                        UINT cCurrBracket = cInsideBigBracket;

                        // Found a macro instance
                        fIgnoreThisSym = TRUE;

                        // Create an instance name.
                        pSym->NextUsefulSymbol();
                        if (pSym->IsLeftBigBracket())
                        {
                            cInsideBigBracket++;

                            // We need to process the argument list now.
                            do
                            {
                                pSym->NextUsefulSymbol();
                                pMacro->SetArg(pSym->GetStr());
                                pSym->NextUsefulSymbol();
                            }
                            while (pSym->IsComma());

                            ASSERT(pSym->IsRightBigBracket());
                            if (pSym->IsRightBigBracket())
                            {
                                cInsideBigBracket--;
                            }
                            ASSERT(cCurrBracket == cInsideBigBracket);

                            LPSTR pszInstanceName = pMacro->CreateInstanceName();
                            ASSERT(NULL != pszInstanceName);
                            if (NULL != pszInstanceName)
                            {
                                rc = pOutput->Write(pszInstanceName, ::strlen(pszInstanceName));
                                ASSERT(rc);
                                delete pszInstanceName;
                            }
                            pMacro->DeleteArgList();
                        }
                    }
                }
                else
                if (fWasNewLine &&
                    (0 == cInsideBigBracket) &&
                    (pSym->GetID() == SYMBOL_KEYWORD) &&
                    (0 == ::strcmp("IMPORTS", pSym->GetStr())))
                {
                    fInsideImport = TRUE;
                }
            } // if ! comment

            // Must be reset at the end of this block.
            fWasNewLine = FALSE;
        } // if ! space eol

        if (! fIgnoreThisSym)
        {
            // write out this symbol
            rc = pOutput->Write(pSym->GetStr(), pSym->GetStrLen());
            ASSERT(rc);
        }

        // only generate once
        if (1 == nOutputImportedMacrosNow)
        {
            nOutputImportedMacrosNow++;
            rc = pMacroMgr->OutputImportedMacros(pOutput);
            ASSERT(rc);
        }
    } // while

    delete pSym;
    return TRUE;
}



void BuildOutputFileName
(
    LPSTR           pszInputFileName,
    LPSTR           pszNewOutputFileName
)
{
    LPSTR psz;
    ::strcpy(pszNewOutputFileName, pszInputFileName);
    if (NULL != (psz = ::strrchr(pszNewOutputFileName, '.')) &&
        0 == ::strcmpi(psz, ".asn"))
    {
        ::strcpy(psz, ".out");
    }
    else
    {
        ::strcat(pszNewOutputFileName, ".out");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\getsym.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "getsym.h"
#include "utils.h"


CInput::
CInput
(
    BOOL           *pfRetCode,
    LPSTR           pszPathName,
    UINT            cbBufSize
)
:
    m_cbBufSize(cbBufSize),
    m_cbValidData(0),
    m_nCurrOffset(0),
    m_chCurr(INVALID_CHAR),
    m_fEndOfFile(TRUE)
{
    m_pszPathName = ::My_strdup(pszPathName);
    m_pbDataBuf = new BYTE[m_cbBufSize];

    m_hFile = ::CreateFile(pszPathName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL, // default security
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_READONLY,
                           NULL); // no template

    m_cbFileSize = (NULL != m_hFile) ? ::GetFileSize(m_hFile, NULL) : 0;

    *pfRetCode = (NULL != m_pszPathName) &&
                 (NULL != m_pbDataBuf) &&
                 (NULL != m_hFile);

    if (*pfRetCode)
    {
        if (CheckBuffer(1))
        {
            m_chCurr = m_pbDataBuf[0];
            m_fEndOfFile = FALSE;
        }
    }
}


CInput::
~CInput ( void )
{
    delete m_pszPathName;
    delete m_pbDataBuf;

    if (NULL != m_hFile)
    {
        ::CloseHandle(m_hFile);
    }
}


void CInput::
NextChar ( void )
{
    if (INVALID_CHAR != m_chCurr)
    {
        // set up the next new char
        if (CheckBuffer(1))
        {
            m_chCurr = m_pbDataBuf[++m_nCurrOffset];
        }
        else
        {
            m_chCurr = INVALID_CHAR;
            m_fEndOfFile = TRUE;
        }
    }
}


void CInput::
PeekChars ( UINT cChars, LPSTR pszChars )
{
    if (CheckBuffer(cChars - 1))
    {
        ::CopyMemory(pszChars, &m_pbDataBuf[m_nCurrOffset], cChars);
    }
    else
    {
        ::ZeroMemory(pszChars, cChars);
    }
}


void CInput::
SkipChars ( UINT cChars )
{
    for (UINT i = 0; i < cChars; i++)
    {
        NextChar();
    }
}


BOOL CInput::
CheckBuffer ( UINT cChars )
{
    if (m_nCurrOffset + cChars >= m_cbValidData)
    {
        ASSERT(m_cbValidData >= m_nCurrOffset);
        UINT cbCurrValid = m_cbValidData - m_nCurrOffset;
        UINT cbToRead = m_cbBufSize - cbCurrValid;

        if (cbCurrValid > 0)
        {
            // Move the data to the front of the buffer.
            ::CopyMemory(&m_pbDataBuf[0], &m_pbDataBuf[m_nCurrOffset], cbCurrValid);
            m_nCurrOffset = 0;
        }

        ULONG cbRead = 0;
        if (::ReadFile(m_hFile, &m_pbDataBuf[cbCurrValid], cbToRead, &cbRead, NULL))
        {
            ASSERT(cbRead <= cbToRead);
            m_cbValidData = cbCurrValid + cbRead;
            m_nCurrOffset = 0;

            if (cbRead < cbToRead)
            {
                m_fEndOfFile = TRUE;
            }
        }
        else
        {
            m_fEndOfFile = TRUE;
        }

        return (m_nCurrOffset + cChars < m_cbValidData);
    }

    return TRUE;
}


BOOL CInput::
Rewind ( void )
{
    if ((DWORD) -1 != ::SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN))
    {
        // clean up members
        m_cbValidData = 0;
        m_nCurrOffset = 0;
        m_chCurr = INVALID_CHAR;

        // set up the buffer
        if (CheckBuffer(1))
        {
            m_chCurr = m_pbDataBuf[0];
            m_fEndOfFile = FALSE;
        }
        else
        {
            m_fEndOfFile = TRUE;
        }
        return TRUE;
    }
    return FALSE;
}




CSymbol::
CSymbol ( CInput *pInput )
:
    m_pInput(pInput),
    m_eSymbolID(SYMBOL_UNKNOWN),
    m_cchSymbolStr(0)
{
    m_szSymbolStr[0] = '\0';
}


BOOL CSymbol::
NextSymbol ( void )
{
    if (SYMBOL_EOF == m_eSymbolID)
    {
        return FALSE;
    }

    char ch = m_pInput->GetChar();
    m_szSymbolStr[0] = ch;
    m_cchSymbolStr = 1;

    m_pInput->NextChar();

    if (::isdigit(ch))
    {
        // numbers
        while (INVALID_CHAR != (ch = m_pInput->GetChar()))
        {
            if (::isdigit(ch))
            {
                m_szSymbolStr[m_cchSymbolStr++] = ch;
                m_pInput->NextChar();
            }
            else
            {
                break;
            }
        }
        m_eSymbolID = SYMBOL_NUMBER;
    }
    else
    if (::isalpha(ch))
    {
        // alphanumeric
        while (INVALID_CHAR != (ch = m_pInput->GetChar()))
        {
            if (::isalnum(ch) || '_' == ch || '-' == ch)
            {
                m_szSymbolStr[m_cchSymbolStr++] = ch;
                m_pInput->NextChar();
            }
            else
            {
                m_szSymbolStr[m_cchSymbolStr] = '\0';
                break;
            }
        }

        m_eSymbolID = ::IsKeyword(&m_szSymbolStr[0]) ? SYMBOL_KEYWORD : SYMBOL_IDENTIFIER;
    }
    else
    if ('\n' == ch)
    {
        m_szSymbolStr[m_cchSymbolStr++] = '\n';
        m_eSymbolID = SYMBOL_SPACE_EOL;
    }
    else
    if (::isspace(ch))
    {
        // space
        m_eSymbolID = SYMBOL_SPACE;
        while (INVALID_CHAR != (ch = m_pInput->GetChar()))
        {
            if (::isspace(ch))
            {
                m_szSymbolStr[m_cchSymbolStr++] = ch;
                m_pInput->NextChar();
                if ('\n' == ch)
                {
                    m_eSymbolID = SYMBOL_SPACE_EOL;
                }
            }
            else
            {
                break;
            }
        }
    }
    else
    if ('&' == ch)
    {
        m_eSymbolID = SYMBOL_FIELD;

        // alphanumeric
        while (INVALID_CHAR != (ch = m_pInput->GetChar()))
        {
            if (::isalnum(ch) || '_' == ch)
            {
                m_szSymbolStr[m_cchSymbolStr++] = ch;
                m_pInput->NextChar();
            }
            else
            {
                m_szSymbolStr[m_cchSymbolStr] = '\0';
                break;
            }
        }
    }
    else
    {
        char szTemp[4];
        m_eSymbolID = SYMBOL_SPECIAL;

        if (':' == ch)
        {
            m_pInput->PeekChars(2, &szTemp[0]);
            if (':' == szTemp[0] && '=' == szTemp[1])
            {
                m_pInput->SkipChars(2);
                m_szSymbolStr[m_cchSymbolStr++] = ':';
                m_szSymbolStr[m_cchSymbolStr++] = '=';
                m_eSymbolID = SYMBOL_DEFINITION;
            }
        }
        else
        if ('-' == ch)
        {
            m_pInput->PeekChars(1, &szTemp[0]);
            if ('-' == szTemp[0])
            {
                m_pInput->SkipChars(1);
                m_szSymbolStr[m_cchSymbolStr++] = '-';
                m_eSymbolID = SYMBOL_COMMENT;
            }
        }
        else
        if ('.' == ch)
        {
            m_pInput->PeekChars(2, &szTemp[0]);
            if ('.' == szTemp[0] && '.' == szTemp[1])
            {
                m_pInput->SkipChars(2);
                m_szSymbolStr[m_cchSymbolStr++] = '.';
                m_szSymbolStr[m_cchSymbolStr++] = '.';
                m_eSymbolID = SYMBOL_DOTDOTDOT;
            }
        }
    }

    // null terminate the string
    m_szSymbolStr[m_cchSymbolStr] = '\0';

    if (INVALID_CHAR != m_szSymbolStr[0])
    {
        return TRUE;
    }

    m_eSymbolID = SYMBOL_EOF;
    return FALSE;
}


BOOL CSymbol::
NextUsefulSymbol ( void )
{
    BOOL fInsideComment = FALSE;
    while (NextSymbol())
    {
        if (SYMBOL_SPACE_EOL == m_eSymbolID)
        {
            fInsideComment = FALSE;
        }
        else
        if (SYMBOL_COMMENT == m_eSymbolID)
        {
            fInsideComment = ! fInsideComment;
        }
        else
        if (! fInsideComment)
        {
            if (SYMBOL_SPACE != m_eSymbolID)
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}



COutput::
COutput
(
    BOOL           *pfRetCode,
    LPSTR           pszPathName,
    UINT            cbBufSize
)
:
    m_cbBufSize(cbBufSize),
    m_cbValidData(0)
{
    m_pszPathName = ::My_strdup(pszPathName);
    m_pbDataBuf = new BYTE[m_cbBufSize];
    m_hFile = ::CreateFile(pszPathName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL, // default security
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL); // no template
    *pfRetCode = (NULL != m_pszPathName) &&
                 (NULL != m_pbDataBuf) &&
                 (NULL != m_hFile);
}


COutput::
~COutput ( void )
{
    delete m_pszPathName;
    delete m_pbDataBuf;

    if (NULL != m_hFile)
    {
        Flush();
        ::CloseHandle(m_hFile);
    }
}


BOOL COutput::
Write
(
    LPBYTE          pbDataBuf,
    UINT            cbToWrite
)
{
    ULONG cbWritten;

    while (0 != cbToWrite)
    {
        if (::WriteFile(m_hFile, pbDataBuf, cbToWrite, &cbWritten, NULL))
        {
            pbDataBuf += cbWritten;
            cbToWrite -= cbWritten;
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL COutput::
Writeln
(
    LPBYTE          pbDataBuf,
    UINT            cbToWrite
)
{
    return Write(pbDataBuf, cbToWrite) && Write("\n", 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\precomp.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h>
#include <ctype.h>
#include <memory.h>

#define ASN1CPP

#include <windows.h>

#define ARRAY_SIZE(arr)     (sizeof(arr) / sizeof(arr[0]))


#ifdef _DEBUG

__inline void MyDebugBreak(void) { DebugBreak(); }

#undef ASSERT
#define ASSERT(x)           if (!(x)) MyDebugBreak();

#else

#undef ASSERT
#define ASSERT(x)

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\macro.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#ifndef _MACRO_H_
#define _MACRO_H_

#include "getsym.h"
#include "utils.h"
#include "cntlist.h"


#define DEF_BODY_SIZE       2048

#define ARG_ESCAPE_CHAR     '$'
#define ARG_INDEX_BASE      '0'


// forward class definitions
class CMacro;
class CMacroMgr;
class CMacroInstance;

// list classes
class CMacroInstList : public CList
{
    DEFINE_CLIST(CMacroInstList, CMacroInstance*);
    void DeleteList ( void );
};
class CMacroList : public CList
{
    DEFINE_CLIST(CMacroList, CMacro*);
    void DeleteList ( void );
};
class CMacroMgrList : public CList
{
    DEFINE_CLIST(CMacroMgrList, CMacroMgr*);
    CMacro *FindMacro ( LPSTR pszModuleName, LPSTR pszMacroName );
    CMacroMgr *FindMacroMgr ( LPSTR pszModuleName );
    void Uninstance ( void );
    void DeleteList ( void );
};
class CNameList : public CList
{
    DEFINE_CLIST(CNameList, LPSTR);
    BOOL AddName ( LPSTR );
    LPSTR GetNthItem ( UINT nth );
    void DeleteList ( void );
};






class CMacro
{
public:

    CMacro ( BOOL *pfRetCode, LPSTR pszMacroName, UINT cbMaxBodySize = DEF_BODY_SIZE );
    CMacro ( BOOL *pfRetCode, CMacro *pMacro );
    ~CMacro ( void );

    void SetArg ( LPSTR pszArgName ) { m_ArgList.AddName(pszArgName); }
    void DeleteArgList ( void ) { m_ArgList.DeleteList(); }

    BOOL SetBodyPart ( LPSTR pszBodyPart );
    void EndMacro ( void );

    LPSTR CreateInstanceName ( void );
    BOOL InstantiateMacro ( void );
    BOOL OutputInstances ( COutput *pOutput );

    LPSTR GetName ( void ) { return m_pszMacroName; }

    void Uninstance ( void );

    BOOL IsImported ( void ) { return m_fImported; }

private:

    LPSTR               m_pszMacroName;

    UINT                m_cFormalArgs;
    CNameList           m_ArgList;

    UINT                m_cbMaxBodySize;
    UINT                m_cbBodySize;
    LPSTR               m_pszCurr;
    LPSTR               m_pszBodyBuffer;
    LPSTR               m_pszExpandBuffer;

    CMacroInstList      m_MacroInstList;

    BOOL                m_fArgExistsInBody;
    BOOL                m_fImported;
};



class CMacroMgr
{
public:

    CMacroMgr ( void );
    ~CMacroMgr ( void );

    BOOL AddModuleName ( LPSTR pszModuleName );
    LPSTR GetModuleName ( void ) { return m_pszModuleName; }

    void AddMacro ( CMacro *pMacro ) { m_MacroList.Append(pMacro); }
    CMacro *FindMacro ( LPSTR pszMacroName );

    BOOL OutputImportedMacros ( COutput *pOutput );

    void Uninstance ( void );

private:

    CMacroList          m_MacroList;
    LPSTR               m_pszModuleName;
};



class CMacroInstance
{
public:

    CMacroInstance ( BOOL *pfRetCode, LPSTR pszInstanceName, UINT cbBufSize, LPSTR pszInstBuf );
    ~CMacroInstance ( void );

    LPSTR GetName ( void ) { return m_pszInstanceName; }
    UINT GetNameLen ( void ) { return ::strlen(m_pszInstanceName); }

    LPSTR GetBuffer ( void ) { return m_pszInstanceBuffer; }
    UINT GetBufSize ( void ) { return m_cbBufSize; }

private:

    LPSTR               m_pszInstanceName;

    UINT                m_cbBufSize;
    LPSTR               m_pszInstanceBuffer;
};



#endif // _MACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\getsym.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#ifndef _GETSYM_H_
#define _GETSYM_H_

#define INPUT_BUFFER_SIZE       4096
#define OUTPUT_BUFFER_SIZE      4096

#define INVALID_CHAR            ((char) 0)

class CInput
{
public:

    CInput ( BOOL *pfRetCode, LPSTR pszPathName, UINT cbBufSize = INPUT_BUFFER_SIZE );
    ~CInput ( void );

    void NextChar ( void );
    void PeekChars ( UINT cChars, LPSTR pszChars );
    void SkipChars ( UINT cChars );
    char GetChar ( void ) { return (char)m_chCurr; }

    BOOL IsEOF ( void )
    {
        return (m_fEndOfFile && (m_nCurrOffset >= m_cbValidData));
    }

    UINT GetFileSize ( void ) { return m_cbFileSize; }
    BOOL Rewind ( void );

private:

    BOOL CheckBuffer ( UINT cChars );

    LPSTR           m_pszPathName;
    UINT            m_chCurr;
    UINT            m_nCurrOffset;
    BOOL            m_fEndOfFile;
    UINT            m_cbBufSize;
    LPBYTE          m_pbDataBuf;
    UINT            m_cbValidData;
    HANDLE          m_hFile;
    UINT            m_cbFileSize;
};



typedef enum
{
    SYMBOL_UNKNOWN,     // initial value
    SYMBOL_EOF,
    SYMBOL_IDENTIFIER,
    SYMBOL_KEYWORD,
    SYMBOL_SPECIAL,
    SYMBOL_NUMBER,
    SYMBOL_DEFINITION,  // "::="
    SYMBOL_COMMENT,     // "--"
    SYMBOL_DOTDOTDOT,   // "..."
    SYMBOL_SPACE,
    SYMBOL_SPACE_EOL,
    SYMBOL_FIELD,       // "&Type"
}
    SYMBOL_ID;


class CSymbol
{
public:

    CSymbol ( CInput *pInput );
    ~CSymbol ( void ) { }

    BOOL NextSymbol ( void );
    BOOL NextUsefulSymbol ( void );

    SYMBOL_ID GetID ( void ) { return m_eSymbolID; }
    UINT GetStrLen ( void ) { return m_cchSymbolStr; }
    LPSTR GetStr ( void ) { return &m_szSymbolStr[0]; }

    BOOL IsSpecial ( void ) { return (SYMBOL_SPECIAL == m_eSymbolID); }
    BOOL IsSpecialChar ( char ch ) { return (IsSpecial() && ch == m_szSymbolStr[0]); }

    BOOL IsLeftBigBracket ( void ) { return IsSpecialChar('{'); }
    BOOL IsRightBigBracket ( void ) { return IsSpecialChar('}'); }
    BOOL IsComma ( void ) { return IsSpecialChar(','); }
    BOOL IsDot ( void ) { return IsSpecialChar('.'); }
    BOOL IsLeftParenth ( void ) { return IsSpecialChar('('); }
    BOOL IsRightParenth ( void ) { return IsSpecialChar(')'); }
    BOOL IsSemicolon ( void ) { return IsSpecialChar(';'); }
    BOOL IsComment ( void ) { return (SYMBOL_COMMENT == m_eSymbolID); }

private:

    CInput         *m_pInput;
    SYMBOL_ID       m_eSymbolID;
    UINT            m_cchSymbolStr;
    char            m_szSymbolStr[MAX_PATH];
};




class COutput
{
public:

    COutput ( BOOL *pfRetCode, LPSTR pszPathName, UINT cbBufSize = OUTPUT_BUFFER_SIZE );
    ~COutput ( void );

    void Flush ( void ) { ::FlushFileBuffers(m_hFile); }

    BOOL Write ( LPBYTE pbDataBuf, UINT cbData );
    BOOL Write ( LPSTR pszDataBuf, UINT cbData ) { return Write((LPBYTE) pszDataBuf, cbData); }
    BOOL Write ( LPCSTR pszDataBuf, UINT cbData ) { return Write((LPBYTE) pszDataBuf, cbData); }
    BOOL Write ( CSymbol *pSym ) { return Write(pSym->GetStr(), pSym->GetStrLen()); }

    BOOL Writeln ( LPBYTE pbDataBuf, UINT cbData );
    BOOL Writeln ( LPSTR pszDataBuf, UINT cbData ) { return Writeln((LPBYTE) pszDataBuf, cbData); }
    BOOL Writeln ( LPCSTR pszDataBuf, UINT cbData ) { return Writeln((LPBYTE) pszDataBuf, cbData); }

private:

    LPSTR           m_pszPathName;
    UINT            m_cbBufSize;
    LPBYTE          m_pbDataBuf;
    UINT            m_cbValidData;
    HANDLE          m_hFile;
};


#endif // _GETSYM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\macro.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "macro.h"


CMacro::
CMacro
(
    BOOL           *pfRetCode,
    LPSTR           pszMacroName,
    UINT            cbMaxBodySize
)
:
    m_ArgList(8),  // default 8 arguments
    m_MacroInstList(16), // default 16 instances of this macro
    m_cFormalArgs(0),
    m_cbBodySize(0),
    m_cbMaxBodySize(cbMaxBodySize),
    m_pszExpandBuffer(NULL),
    m_fArgExistsInBody(FALSE),
    m_fImported(FALSE)
{
    m_pszMacroName = ::My_strdup(pszMacroName);

    m_pszBodyBuffer = new char[m_cbMaxBodySize];
    m_pszCurr = m_pszBodyBuffer;

    *pfRetCode = (NULL != m_pszMacroName) &&
                 (NULL != m_pszBodyBuffer);
}


CMacro::
CMacro
(
    BOOL            *pfRetCode,
    CMacro          *pMacro
)
:
    m_ArgList(pMacro->m_ArgList.GetCount()),  // default 8 arguments
    m_MacroInstList(16), // default 16 instances of this macro
    m_cFormalArgs(pMacro->m_cFormalArgs),
    m_cbBodySize(pMacro->m_cbBodySize),
    m_cbMaxBodySize(pMacro->m_cbMaxBodySize),
    m_pszExpandBuffer(NULL),
    m_fArgExistsInBody(pMacro->m_fArgExistsInBody),
    m_fImported(TRUE)
{
    m_pszMacroName = ::My_strdup(pMacro->m_pszMacroName);
    m_pszBodyBuffer = new char[m_cbMaxBodySize];
    if (NULL != m_pszMacroName && NULL != m_pszBodyBuffer)
    {
        // copy the body
        ::memcpy(m_pszBodyBuffer, pMacro->m_pszBodyBuffer, pMacro->m_cbBodySize);

        // adjust the current buffer pointer
        m_pszCurr = m_pszBodyBuffer + m_cbBodySize;

        // null terminated the body
        *m_pszCurr++ = '\0';

        // set up the expand buffer
        m_pszExpandBuffer = m_pszCurr;

        *pfRetCode = TRUE;
    }
    else
    {
        *pfRetCode = FALSE;
    }
}


CMacro::
~CMacro ( void )
{
    delete m_pszBodyBuffer;

    Uninstance();
}


void CMacro::
Uninstance ( void )
{
    m_ArgList.DeleteList();
    m_MacroInstList.DeleteList();
}


BOOL CMacro::
SetBodyPart ( LPSTR pszBodyPart )
{
    UINT cch = ::strlen(pszBodyPart);
    ASSERT(m_pszCurr + cch + 1 < m_pszBodyBuffer + m_cbMaxBodySize);
    if (m_pszCurr + cch + 1 < m_pszBodyBuffer + m_cbMaxBodySize)
    {
        LPSTR psz;
        m_ArgList.Reset();
        for (UINT i = 0; NULL != (psz = m_ArgList.Iterate()); i++)
        {
            if (0 == ::strcmp(pszBodyPart, psz))
            {
                // this is an argument
                m_fArgExistsInBody = TRUE;
                *m_pszCurr++ = ARG_ESCAPE_CHAR;
                *m_pszCurr++ = ARG_INDEX_BASE + i;
                return TRUE;
            }
        }

        // this is not an argument.
        ::memcpy(m_pszCurr, pszBodyPart, cch);
        m_pszCurr += cch;
        *m_pszCurr = '\0';
        return TRUE;
    }
    return FALSE;
}


void CMacro::
EndMacro ( void )
{
    // save the count of arguments
    m_cFormalArgs = m_ArgList.GetCount();

    // calculate the size of the body
    m_cbBodySize = m_pszCurr - m_pszBodyBuffer;

    // null terminated the body
    *m_pszCurr++ = '\0';

    // set up the expand buffer
    m_pszExpandBuffer = m_pszCurr;

    // free the memory
    DeleteArgList();
}


BOOL CMacro::
InstantiateMacro ( void )
{
    BOOL rc = FALSE; // assume failure
    LPSTR pszInstName, pszSrc, pszDst;
    UINT i, cch;
    CMacroInstance *pInst;

    if (! m_fArgExistsInBody)
    {
        // No need to instantiate because the body does not contain any argument.
        // We can take the body as the instance.
        rc = TRUE;
        goto MyExit;
    }

    ASSERT(m_ArgList.GetCount() == m_cFormalArgs);
    if (m_ArgList.GetCount() != m_cFormalArgs)
    {
        goto MyExit;
    }

    pszInstName = CreateInstanceName();
    if (NULL == pszInstName)
    {
        goto MyExit;
    }

    m_MacroInstList.Reset();
    while (NULL != (pInst = m_MacroInstList.Iterate()))
    {
        if (0 == ::strcmp(pszInstName, pInst->GetName()))
        {
            // same instance has been instantiated before.
            rc = TRUE;
            delete pszInstName;
            goto MyExit;
        }
    }

    // Let's instantiate a new instance...

    pszSrc = m_pszBodyBuffer;
    pszDst = m_pszExpandBuffer;

    // put in macro name first
    ::strcpy(pszDst, pszInstName);
    pszDst += ::strlen(pszDst);

    // put in macro body now.
    while (*pszSrc != '\0')
    {
        if (*pszSrc == ARG_ESCAPE_CHAR)
        {
            pszSrc++;
            i = *pszSrc++ - ARG_INDEX_BASE;
            ASSERT(i < m_ArgList.GetCount());
            LPSTR pszArgName = m_ArgList.GetNthItem(i);
            cch = ::strlen(pszArgName);
            ::memcpy(pszDst, pszArgName, cch);
            pszDst += cch;
        }
        else
        {
            *pszDst++ = *pszSrc++;
        }
    }
    *pszDst++ = '\n';
    *pszDst = '\0';

    // create an instance
    pInst = new CMacroInstance(&rc,
                               pszInstName,
                               pszDst - m_pszExpandBuffer,
                               m_pszExpandBuffer);
    if (NULL != pInst && rc)
    {
        m_MacroInstList.Append(pInst);
    }

MyExit:

    // free up temporary argument names
    m_ArgList.DeleteList();

    return rc;
}


BOOL CMacro::
OutputInstances ( COutput *pOutput )
{
    BOOL rc = TRUE;
    CMacroInstance *pInst;
    if (m_fArgExistsInBody)
    {
        m_MacroInstList.Reset();
        while (NULL != (pInst = m_MacroInstList.Iterate()))
        {
            rc = pOutput->Write(pInst->GetBuffer(), pInst->GetBufSize());
            ASSERT(rc);
        }
    }
    else
    {
        rc = pOutput->Write(m_pszMacroName, ::strlen(m_pszMacroName));
        ASSERT(rc);
        rc = pOutput->Writeln(m_pszBodyBuffer, m_cbBodySize);
        ASSERT(rc);
    }
    return rc;
}


LPSTR CMacro::
CreateInstanceName ( void )
{
    UINT cch = ::strlen(m_pszMacroName) + 2;
    UINT i;
    LPSTR psz, pszArgName;

    if (m_fArgExistsInBody)
    {
        ASSERT(m_ArgList.GetCount() == m_cFormalArgs);
        m_ArgList.Reset();
        while (NULL != (pszArgName = m_ArgList.Iterate()))
        {
            cch += ::strlen(pszArgName) + 1;
        }
    }

    LPSTR pszInstanceName = new char[cch];
    if (NULL != pszInstanceName)
    {
        psz = pszInstanceName;
        ::strcpy(psz, m_pszMacroName);

        if (m_fArgExistsInBody)
        {
            psz += ::strlen(psz);
            m_ArgList.Reset();
            while (NULL != (pszArgName = m_ArgList.Iterate()))
            {
                *psz++ = '-';
                ::strcpy(psz, pszArgName);
                psz += ::strlen(psz);
            }
        }
    }

    return pszInstanceName;
}





CMacro * CMacroMgrList::
FindMacro
(
    LPSTR           pszModuleName,
    LPSTR           pszMacroName
)
{
    CMacroMgr *pMacroMgr = FindMacroMgr(pszModuleName);
    return (NULL != pMacroMgr) ? pMacroMgr->FindMacro(pszMacroName) : NULL;
}


CMacroMgr * CMacroMgrList::
FindMacroMgr ( LPSTR pszModuleName )
{
    CMacroMgr *pMacroMgr;
    Reset();
    while (NULL != (pMacroMgr = Iterate()))
    {
        if (0 == ::strcmp(pszModuleName, pMacroMgr->GetModuleName()))
        {
            return pMacroMgr;
        }
    }
    return NULL;
}


void CMacroMgrList::
Uninstance ( void )
{
    CMacroMgr *pMacroMgr;
    Reset();
    while (NULL != (pMacroMgr = Iterate()))
    {
        pMacroMgr->Uninstance();
    }
}






CMacroMgr::
CMacroMgr ( void )
:
    m_MacroList(16),  // default 16 macros
    m_pszModuleName(NULL)
{
}


CMacroMgr::
~CMacroMgr ( void )
{
    m_MacroList.DeleteList();
    delete m_pszModuleName;
}


BOOL CMacroMgr::
AddModuleName ( LPSTR pszModuleName )
{
    // can only be set once
    ASSERT(NULL == m_pszModuleName);

    m_pszModuleName = ::My_strdup(pszModuleName);
    ASSERT(NULL != m_pszModuleName);

    return (NULL != m_pszModuleName);
}


CMacro *CMacroMgr::
FindMacro ( LPSTR pszMacroName )
{
    CMacro *pMacro;
    m_MacroList.Reset();
    while (NULL != (pMacro = m_MacroList.Iterate()))
    {
        if (0 == ::strcmp(pszMacroName, pMacro->GetName()))
        {
            return pMacro;
        }
    }
    return NULL;
}


BOOL CMacroMgr::
OutputImportedMacros ( COutput *pOutput )
{
    BOOL rc = TRUE;
    CMacro *pMacro;

    rc = pOutput->Write("\n\n", 2);

    m_MacroList.Reset();
    while (NULL != (pMacro = m_MacroList.Iterate()))
    {
        if (pMacro->IsImported())
        {
            rc = pMacro->OutputInstances(pOutput);
            if (! rc)
            {
                ASSERT(0);
                return FALSE;
            }
        }
    }
    return rc;
}


void CMacroMgr::
Uninstance ( void )
{
    CMacro *pMacro;
    m_MacroList.Reset();
    while (NULL != (pMacro = m_MacroList.Iterate()))
    {
        pMacro->Uninstance();  
    }
}







CMacroInstance::
CMacroInstance
(
    BOOL       *pfRetCode,
    LPSTR       pszInstanceName,
    UINT        cbBufSize,
    LPSTR       pszInstBuf
)
:
    m_pszInstanceName(pszInstanceName),
    m_cbBufSize(cbBufSize)
{
    m_pszInstanceBuffer = new char[m_cbBufSize];
    if (NULL != m_pszInstanceBuffer)
    {
        ::memcpy(m_pszInstanceBuffer, pszInstBuf, m_cbBufSize);
    }

    *pfRetCode = (NULL != m_pszInstanceName) && (NULL != m_pszInstanceBuffer);
}


CMacroInstance::
~CMacroInstance ( void )
{
    delete m_pszInstanceName;
    delete m_pszInstanceBuffer;
}





void CMacroInstList::
DeleteList ( void )
{
    CMacroInstance *pInst;
    while (NULL != (pInst = Get()))
    {
        delete pInst;
    }
}




void CMacroList::
DeleteList ( void )
{
    CMacro *pMacro;
    while (NULL != (pMacro = Get()))
    {
        delete pMacro;
    }
}



void CMacroMgrList::
DeleteList ( void )
{
    CMacroMgr *pMacroMgr;
    while (NULL != (pMacroMgr = Get()))
    {
        delete pMacroMgr;
    }
}


BOOL CNameList::
AddName ( LPSTR pszName )
{
    pszName = ::My_strdup(pszName);
    if (NULL != pszName)
    {
        Append(pszName);
        return TRUE;
    }
    return FALSE;
}


LPSTR CNameList::
GetNthItem ( UINT nth )
{
    LPSTR psz;
    if (nth < GetCount())
    {
        Reset();
        do
        {
            psz = Iterate();
        }
        while (nth--);
    }
    else
    {
        psz = NULL;
    }
    return psz;
}


void CNameList::
DeleteList ( void )
{
    LPSTR psz;
    while (NULL != (psz = Get()))
    {
        delete psz;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\utils.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "utils.h"


LPSTR My_strdup ( LPCSTR pszSrc )
{
    LPSTR pszDst = NULL;
    if (NULL != pszSrc)
    {
        UINT cch = ::strlen(pszSrc) + 1;
        if (NULL != (pszDst = new char[cch]))
        {
            ::CopyMemory(pszDst, pszSrc, cch);
        }
    }
    return pszDst;
}


const LPSTR c_apszKeywords[] =
{
    "ANY",
    "AUTOMATIC",
    "BEGIN",
    "BIT",
    "BMPString",
    "BY",
    "CHOICE",
    "COMPONENT",
    "CONSTRAINED",
    "DEFINITIONS",
    "END",
    "FROM",
    "IDENTIFIER",
    "IMPORTS",
    "INTEGER",
    "IV8",
    "NULL",
    "OBJECT",
    "OCTET",
    "OPTIONAL",
    "SEQUENCE",
    "SIZE",
    "STRING",
    "SYNTAX",
    "TAGS",
    "WITH",
};


BOOL IsKeyword ( LPSTR pszSymbol )
{
    return (BOOL) BinarySearch_Str(pszSymbol, &c_apszKeywords[0], ARRAY_SIZE(c_apszKeywords));
}


LPSTR BinarySearch_Str ( LPSTR pszKey, const LPSTR aKeyTbl[], UINT cKeys )
{
    UINT lo = 0;
    UINT hi = cKeys - 1;
    UINT num = cKeys;
    UINT mid, half;
    int result;

    while (lo <= hi)
    {
        if (0 != (half = num >> 1))
        {
            mid = lo + ((num - 1) >> 1);
            if (0 == (result = ::strcmp(pszKey, aKeyTbl[mid])))
            {
                return aKeyTbl[mid];
            }
            else if (result < 0)
            {
                hi = mid - 1;
                num = (num - 1) >> 1;
            }
            else
            {
                lo = mid + 1;
                num = half;
            }
        }
        else if (num)
        {
            return (::strcmp(pszKey, aKeyTbl[lo]) ? NULL : aKeyTbl[lo]);
        }
        else
        {
            break;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\typeid.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#ifndef _TYPEID_H_
#define _TYPEID_H_

#include "getsym.h"
#include "utils.h"
#include "cntlist.h"



// list classes
class CAliasList : public CList
{
    DEFINE_CLIST(CAliasList, LPSTR);
};
class CTypeInstList2 : public CList2
{
    // key: new super type, item: old sub type
    DEFINE_CLIST2__(CTypeInstList2, LPSTR);
};


class CTypeID
{
public:

    CTypeID ( void );
    ~CTypeID ( void );

    BOOL AddAlias ( LPSTR pszAlias );
    LPSTR FindAlias ( LPSTR pszToMatch );

    BOOL AddInstance ( LPSTR pszNewSuperType, LPSTR pszOldSubType );
    LPSTR FindInstance ( LPSTR pszInstName );

    BOOL GenerateOutput ( COutput *pOutput, LPSTR pszNewSuperType, LPSTR pszOldSubType );

private:

    UINT                m_cbPriorPartSize;
    UINT                m_cbPostPartSize;

    CAliasList          m_AliasList;
    CTypeInstList2      m_TypeInstList2;
};




#endif // _TYPEID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\typeid.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "typeid.h"


const char c_szTypeIdentifierPriorPart[] = 
                    " ::= SEQUENCE \n"
                    "{\n"
                    "\tid\t\tOBJECT IDENTIFIER,\n"
                    "\ttype\t\t";

const char c_szTypeIdentifierPostPart[] = 
                    "\n"
                    "}\n";



CTypeID::
CTypeID ( void )
:
    m_AliasList(8), // default 8 aliases
    m_TypeInstList2(16) // default 16 type instances
{
    m_cbPriorPartSize = ::strlen(&c_szTypeIdentifierPriorPart[0]);
    m_cbPostPartSize = ::strlen(&c_szTypeIdentifierPostPart[0]);

    BOOL rc;
    rc = AddAlias("TYPE-IDENTIFIER");
    ASSERT(rc);
    rc = AddAlias("ABSTRACT-IDENTIFIER");
    ASSERT(rc);
}


CTypeID::
~CTypeID ( void )
{
    LPSTR pszAlias;
    while (NULL != (pszAlias = m_AliasList.Get()))
    {
        delete pszAlias;
    }

    LPSTR pszNewSuperType, pszOldSubType;
    while (NULL != (pszOldSubType = m_TypeInstList2.Get(&pszNewSuperType)))
    {
        delete pszOldSubType;
        delete pszNewSuperType;
    }
}


BOOL CTypeID::
AddAlias ( LPSTR pszAlias )
{
    pszAlias = ::My_strdup(pszAlias);
    if (NULL != pszAlias)
    {
        m_AliasList.Append(pszAlias);
        return TRUE;
    }
    return FALSE;
}


LPSTR CTypeID::
FindAlias ( LPSTR pszToMatch )
{
    LPSTR pszAlias;
    m_AliasList.Reset();
    while (NULL != (pszAlias = m_AliasList.Iterate()))
    {
        if (0 == ::strcmp(pszAlias, pszToMatch))
        {
            break;
        }
    }
    return pszAlias;
}


BOOL CTypeID::
AddInstance
(
    LPSTR       pszNewSuperType,
    LPSTR       pszOldSubType
)
{
    pszNewSuperType = ::My_strdup(pszNewSuperType);
    pszOldSubType = ::My_strdup(pszOldSubType);
    if (NULL != pszNewSuperType && NULL != pszOldSubType)
    {
        m_TypeInstList2.Append(pszNewSuperType, pszOldSubType);
        return TRUE;
    }

    delete pszNewSuperType;
    delete pszOldSubType;
    return FALSE;
}


LPSTR CTypeID::
FindInstance ( LPSTR pszInstName )
{
    LPSTR pszNewSuperType, pszOldSubType;
    m_TypeInstList2.Reset();
    while (NULL != (pszOldSubType = m_TypeInstList2.Iterate(&pszNewSuperType)))
    {
        if (0 == ::strcmp(pszInstName, pszNewSuperType))
        {
            return pszOldSubType;
        }
    }
    return NULL;
}


BOOL CTypeID::
GenerateOutput
(
    COutput    *pOutput,
    LPSTR       pszNewSuperType,
    LPSTR       pszOldSubType
)
{
    BOOL rc1, rc2, rc3, rc4;

    rc1 = pOutput->Write(pszNewSuperType, ::strlen(pszNewSuperType));
    ASSERT(rc1);

    rc2 = pOutput->Write(&c_szTypeIdentifierPriorPart[0], m_cbPriorPartSize);
    ASSERT(rc2);

    rc3 = pOutput->Write(pszOldSubType, ::strlen(pszOldSubType));
    ASSERT(rc3);

    rc4 = pOutput->Write(&c_szTypeIdentifierPostPart[0], m_cbPostPartSize);
    ASSERT(rc4);

    return (rc1 && rc2 && rc3 && rc4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\utils.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#ifndef _UTILS_H_
#define _UTILS_H_


LPSTR My_strdup ( LPCSTR pszSrc );

BOOL IsKeyword ( LPSTR pszSymbol );
LPSTR BinarySearch_Str ( LPSTR pszKey, const LPSTR aKeyTbl[], UINT cKeys );

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\autosafe\autosafe.h ===
#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>
#include <wchar.h>


#include <stdio.h>
#include <stdlib.h>

#pragma warning(disable:4127)   // conditional expression is constant
#pragma warning(disable:4213)   // nonstandard extension used : cast on l-value


#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

extern PBOOT_OPTIONS BootOptions;
extern ULONG BootOptionsLength;
extern PBOOT_OPTIONS OriginalBootOptions;
extern ULONG OriginalBootOptionsLength;

extern PULONG BootEntryOrder;
extern ULONG BootEntryOrderCount;
extern PULONG OriginalBootEntryOrder;
extern ULONG OriginalBootEntryOrderCount;

//
// MY_BOOT_ENTRY is the internal representation of an EFI NVRAM boot item.
// The NtBootEntry item is the structure passed to/from the NT boot entry APIs.
//
typedef struct _MY_BOOT_ENTRY {
    LIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PUCHAR AllocationEnd;
    ULONG Status;
    ULONG Id;
    ULONG Attributes;
    PWSTR FriendlyName;
    ULONG FriendlyNameLength;
    PWSTR OsLoadOptions;
    ULONG OsLoadOptionsLength;
    PFILE_PATH BootFilePath;
    PFILE_PATH OsFilePath;
    PUCHAR ForeignOsOptions;
    ULONG ForeignOsOptionsLength;
    BOOT_ENTRY NtBootEntry;
} MY_BOOT_ENTRY, *PMY_BOOT_ENTRY;

#define MBE_STATUS_IS_NT        0x00000001
#define MBE_STATUS_NEW          0x00000002
#define MBE_STATUS_DELETED      0x00000004
#define MBE_STATUS_MODIFIED     0x00000008
#define MBE_STATUS_COMMITTED    0x80000000

#define MBE_IS_NT(_be) (((_be)->Status & MBE_STATUS_IS_NT) != 0)
#define MBE_IS_NEW(_be) (((_be)->Status & MBE_STATUS_NEW) != 0)
#define MBE_IS_DELETED(_be) (((_be)->Status & MBE_STATUS_DELETED) != 0)
#define MBE_IS_MODIFIED(_be) (((_be)->Status & MBE_STATUS_MODIFIED) != 0)
#define MBE_IS_COMMITTED(_be) (((_be)->Status & MBE_STATUS_COMMITTED) != 0)

#define MBE_SET_IS_NT(_be) ((_be)->Status |= MBE_STATUS_IS_NT)
#define MBE_SET_NEW(_be) ((_be)->Status |= MBE_STATUS_NEW)
#define MBE_SET_DELETED(_be) ((_be)->Status |= MBE_STATUS_DELETED)
#define MBE_SET_MODIFIED(_be) ((_be)->Status |= MBE_STATUS_MODIFIED)
#define MBE_SET_COMMITTED(_be) ((_be)->Status |= MBE_STATUS_COMMITTED)

#define MBE_CLEAR_IS_NT(_be) ((_be)->Status &= ~MBE_STATUS_IS_NT)
#define MBE_CLEAR_NEW(_be) ((_be)->Status &= ~MBE_STATUS_NEW)
#define MBE_CLEAR_DELETED(_be) ((_be)->Status &= ~MBE_STATUS_DELETED)
#define MBE_CLEAR_MODIFIED(_be) ((_be)->Status &= ~MBE_STATUS_MODIFIED)
#define MBE_CLEAR_COMMITTED(_be) ((_be)->Status &= ~MBE_STATUS_COMMITTED)

#define MBE_IS_ACTIVE(_be) (((_be)->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0)
#define MBE_SET_ACTIVE(_be) ((_be)->Status |= BOOT_ENTRY_ATTRIBUTE_ACTIVE)
#define MBE_CLEAR_ACTIVE(_be) ((_be)->Status &= ~BOOT_ENTRY_ATTRIBUTE_ACTIVE)

#define IS_SEPARATE_ALLOCATION(_be,_p)                                  \
        ((_be->_p != NULL) &&                                           \
         (((PUCHAR)_be->_p < (PUCHAR)_be) ||                            \
          ((PUCHAR)_be->_p > (PUCHAR)_be->AllocationEnd)))

#define FREE_IF_SEPARATE_ALLOCATION(_be,_p)                             \
        if (IS_SEPARATE_ALLOCATION(_be,_p)) {                           \
            MemFree(_be->_p);                                           \
        }

extern LIST_ENTRY BootEntries;
extern LIST_ENTRY DeletedBootEntries;
extern LIST_ENTRY ActiveUnorderedBootEntries;
extern LIST_ENTRY InactiveUnorderedBootEntries;

PVOID
MemAlloc(
    IN SIZE_T Size
    );

PVOID
MemRealloc(
    IN PVOID Block,
    IN SIZE_T NewSize
    );

VOID
MemFree(
    IN PVOID Block
    );

VOID
InitializeMenuSystem (
    VOID
    );

VOID
MainMenu (
    VOID
    );

VOID
ClearMenuArea (
    VOID
    );

PMY_BOOT_ENTRY
SaveChanges (
    PMY_BOOT_ENTRY CurrentBootEntry
    );

PWSTR
GetNtNameForFilePath (
    IN PFILE_PATH FilePath
    );

VOID
FatalError (
    DWORD Error,
    PWSTR Format,
    ...
    );

VOID
SetStatusLine (
    PWSTR Status
    );

VOID
SetStatusLineAndWait (
    PWSTR Status
    );

VOID
SetStatusLine2 (
    PWSTR Status
    );

VOID
SetStatusLine2AndWait (
    PWSTR Status
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\autosafe\autosafe.c ===
#include "autosafe.h"

PWSTR SystemPartitionNtName;

PBOOT_OPTIONS BootOptions;
ULONG BootOptionsLength;
PBOOT_OPTIONS OriginalBootOptions;
ULONG OriginalBootOptionsLength;

PULONG BootEntryOrder;
ULONG BootEntryOrderCount;
PULONG OriginalBootEntryOrder;
ULONG OriginalBootEntryOrderCount;

LIST_ENTRY BootEntries;
LIST_ENTRY DeletedBootEntries;
LIST_ENTRY ActiveUnorderedBootEntries;
LIST_ENTRY InactiveUnorderedBootEntries;

VOID
ConcatenatePaths (
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    );

VOID
ConvertBootEntries (
    PBOOT_ENTRY_LIST BootEntries
    );

PMY_BOOT_ENTRY
CreateBootEntryFromBootEntry (
    IN PMY_BOOT_ENTRY OldBootEntry
    );

VOID
FreeBootEntry (
    IN PMY_BOOT_ENTRY BootEntry
    );

VOID
InitializeEfi (
    VOID
    );

NTSTATUS
(*AddBootEntry) (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );

NTSTATUS
(*DeleteBootEntry) (
    IN ULONG Id
    );

NTSTATUS
(*ModifyBootEntry) (
    IN PBOOT_ENTRY BootEntry
    );

NTSTATUS
(*EnumerateBootEntries) (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );

NTSTATUS
(*QueryBootEntryOrder) (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );

NTSTATUS
(*SetBootEntryOrder) (
    IN PULONG Ids,
    IN ULONG Count
    );

NTSTATUS
(*QueryBootOptions) (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );

NTSTATUS
(*SetBootOptions) (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );

NTSTATUS
(*TranslateFilePath) (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputFilePath,
    IN OUT PULONG OutputFilePathLength
    );

NTSTATUS LabelDefaultIA64(WCHAR *szKeyWord);
NTSTATUS LabelDefaultX86(CHAR *szKeyWord);
NTSTATUS MoveSafeIA64(WCHAR *szKeyWord);
NTSTATUS MoveSafeX86(CHAR *szKeyWord);

WCHAR x86DetermineSystemPartition();
WCHAR *ParseArgs();
CHAR *sPreLabel(CHAR* szBootOp, CHAR* szLabel);
CHAR *sReChanged(CHAR* szBootData, CHAR* szBootTitle, CHAR* szNewBootTitle);

WCHAR Usage[] =
L"Autosafe - Set next boot OS\n"
L"Usage: \tAutosafe [/?][boot entry keywords]\n" \
L"Ex: \tAutosafe \"Build 2505\"\n" \
L"  /? this message\n" \
L"  defaults to keyword = 'safe'\n";

CHAR *sReChanged(CHAR* szBootData, CHAR* szBootTitle, CHAR* szNewBootTitle){

       CHAR* pMatch = NULL;
       CHAR* szHdPart   = NULL;
       CHAR* szTlPart   = NULL;
       CHAR* szNewBootData = NULL;

          szHdPart = (CHAR*)(MemAlloc(1+strlen(szBootData)));
          szTlPart = (CHAR*)(MemAlloc(1+strlen(szBootData)));
          szNewBootData = (CHAR*)(MemAlloc(3 + strlen(szNewBootTitle)+strlen(szBootData)));
          ZeroMemory(szNewBootData, 1+strlen(szBootData));
          ZeroMemory(szHdPart, 1+strlen(szBootData));
          ZeroMemory(szTlPart, 1+strlen(szBootData));


       if ((pMatch = strstr(szBootData, _strlwr(szBootTitle)))){          

          memcpy(szHdPart, szBootData, (pMatch - szBootData));
          sprintf(szTlPart, "%s", pMatch + strlen(szBootTitle));          
          sprintf(szNewBootData, "%s%s%s", szHdPart,  szNewBootTitle, szTlPart);
        }

          MemFree(szHdPart);
          MemFree(szTlPart);
          return szNewBootData;

}


CHAR *sPreLabel(CHAR* szBootOp, CHAR* szLabel){

     CHAR* szOutputOp = NULL;
     CHAR* pQuote = NULL;
     CHAR* szHdPart = NULL;
     CHAR* szTlPart = NULL; 
     UINT lIgLn = strlen("microsoft windows xp professional");

     szOutputOp = (CHAR*)(MemAlloc(3 + strlen(szBootOp)+strlen(szLabel)));
     szHdPart       = (CHAR*)(MemAlloc(1 + strlen(szBootOp)));
     szTlPart       = (CHAR*)(MemAlloc(1 + strlen(szBootOp)));

     ZeroMemory(szOutputOp,  3 + strlen(szBootOp)+strlen(szLabel));
     ZeroMemory(szHdPart,        strlen(szBootOp)+1);
     ZeroMemory(szTlPart,        strlen(szBootOp)+1);

        if ((pQuote = strchr(szBootOp, '"'))){

           memcpy(szHdPart, szBootOp, (pQuote - szBootOp) + 1);
           sprintf(szTlPart, "%s", pQuote + 1);
           sprintf(szOutputOp, "%s%s%s", szHdPart, szLabel , szTlPart);

        }
        else {
           sprintf(szOutputOp, "%s%s", szLabel, szBootOp);
        }     

     /* if (lIgLn < strlen(szOutputOp)){

         *(szOutputOp+lIgLn-3) = '.';
         *(szOutputOp+lIgLn-2) = '.';
         *(szOutputOp+lIgLn-1) = '.';
         *(szOutputOp+lIgLn)   = '\0';
      }
     // do not handle this case yet 
     */
     MemFree(szHdPart);
     MemFree(szTlPart);

     return szOutputOp;

}

WCHAR* ParseArgs()
{

       WCHAR * szwKeyWord = NULL;
       szwKeyWord = wcschr(GetCommandLineW(), ' ') + 1;

       //look for /?
       if( wcsstr( L"/?", szwKeyWord) ){
              wprintf(Usage);
              return NULL;
       }

       //strip beginning & trailing " if there
       if( L'"' == *szwKeyWord  && L'"' == *(CharPrev(szwKeyWord, szwKeyWord + lstrlen(szwKeyWord))) )
       {
               szwKeyWord = CharNext(szwKeyWord);
               *(CharPrev(szwKeyWord, szwKeyWord + lstrlen(szwKeyWord)))  = L'\0';
       }
       
       return szwKeyWord;
}

int
__cdecl
main (int argc, CHAR *argv[])
{
       WCHAR dllName[MAX_PATH];
       HMODULE h; 
       DWORD err; 
       SYSTEM_INFO siInfo;
       WCHAR *szwKeyWord;
       CHAR szKeyWord[255];

       VOID (*GetNativeSystemInfo) (OUT LPSYSTEM_INFO lpSystemInfo) = NULL;

       ZeroMemory(szKeyWord, sizeof(szKeyWord));
       szwKeyWord = L"safe";

       if(argc > 1) // parseargs
       if(NULL == (szwKeyWord = ParseArgs())) return 1;
         
    //We want to run this via Wow64 on ia64 so we'll
    //determine proc arch - via GetNativeSystemInfo
       GetSystemDirectory( dllName, MAX_PATH );
    ConcatenatePaths( dllName, L"kernel32.dll", MAX_PATH );
    h = LoadLibrary( dllName );
    if ( h == NULL ) {
        err = GetLastError();
        FatalError( err, L"Can't load KERNEL32.DLL: %d\n", err );
    }

       GetNativeSystemInfo = (VOID(__stdcall *)(LPSYSTEM_INFO)) GetProcAddress(h, "GetNativeSystemInfo");

       if(!GetNativeSystemInfo) {
              //Not running WinXP - meaning not ia64/wow64 env, default to GetSystemInfo
              GetSystemInfo(&siInfo);
       }
       else
       {
              GetNativeSystemInfo(&siInfo);
       }

       switch( siInfo.wProcessorArchitecture )
       {
              wprintf(L"%i\n", siInfo.wProcessorArchitecture );
              case PROCESSOR_ARCHITECTURE_IA64:
                     InitializeEfi( );

			if(!MoveSafeIA64(szwKeyWord)){
				wprintf(L"Boot option \"%ws\" not found.\nLabel the default option \"%ws\"\n", 
                                szwKeyWord, szwKeyWord);
                                if(!LabelDefaultIA64(szwKeyWord)){
                                    wprintf(L"Could not lebel the default option \"%ws\"\nNo changes made\n", 
                                    szwKeyWord);
                                }
			}

              break;

              case PROCESSOR_ARCHITECTURE_INTEL:
                     if(!WideCharToMultiByte( CP_ACP, 
                                   WC_NO_BEST_FIT_CHARS,
                                   szwKeyWord, 
                                   -1,
                                   szKeyWord,
                                   sizeof(szKeyWord),
                                   NULL,
                                   NULL))
                     {
                            FatalError(0, L"Couldn't convert string");
                     }



                     if(!MoveSafeX86(szKeyWord)){
                         wprintf(L"Boot option \"%ws\" not found.\nLabel the default option \"%ws\"\n", 
                                szwKeyWord,szwKeyWord);
                         if(!LabelDefaultX86(szKeyWord)){
                                    wprintf(L"Could not lebel the default option \"%ws\"\nNo changes made\n", 
                                    szwKeyWord);
                               }
                     }
              break;
              default:
                     FatalError( 0, L"Can't determine processor type.\n" );
       }

    return 0;
}


NTSTATUS MoveSafeX86(CHAR *szKeyWord){

    HANDLE hfile;
    DWORD dwFileSize = 0, dwRead, dwSafeSize, dwCnt;
    CHAR *lcbuf = NULL, *buf = NULL, *SafeBootLine = NULL;
	CHAR *pt1,*pt2,*pdefault,*plast,*p0,*p1,*psafe;
	BOOL b;
    WCHAR szBootIni[] = L"?:\\BOOT.INI";

	*szBootIni = x86DetermineSystemPartition();

	//
    // Open and read boot.ini.
    //
    b = FALSE;
	SetFileAttributes(szBootIni, FILE_ATTRIBUTE_NORMAL);

    hfile = CreateFile(szBootIni,
						GENERIC_READ,
						FILE_SHARE_READ,
						NULL,
						OPEN_EXISTING,
						0,
						NULL);


	if(hfile != INVALID_HANDLE_VALUE) {

        dwFileSize = GetFileSize(hfile, NULL);

		if(dwFileSize != INVALID_FILE_SIZE) {
	        buf = (CHAR*)(MemAlloc((SIZE_T)(dwFileSize+1)));
			b = ReadFile(hfile, buf, dwFileSize, &dwRead, NULL);
		}
		
		SetFileAttributes( szBootIni,
			FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | 
			FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN
        );
        CloseHandle(hfile);
		
    }

    if(!b) {
        if(buf) MemFree(buf);
		FatalError(0, L"failed to read boot.ini\n");
    }
	
	//Set pdefault to end of default=
	if(!(pdefault = strstr(buf, "default=")) ||
		!(pdefault += sizeof("default"))) {
			MemFree(buf);
			FatalError(0, L"failed to find 'default' entry\n");
			return FALSE;
		}

	//Get the next line
	plast = strchr(pdefault, '\n') + 1;

	//Get the SafeBootLine
	//Set p0 to the first [operating systems] entry, p1 to the last, search between the two
	if(!(p0 = strstr(buf,"[operating systems]")) ||
		 !(p0 = strchr(p0,'\n') + 1) ) {
		MemFree(buf);
		FatalError(0, L"failed to find '[operating systems]' entry\n");
        return FALSE;
    }
	

	//Find next ini section - or end of file
	if(!(p1 = strchr(p0, '['))) p1 = buf+strlen(buf);

	//create lowercase buffer to search through
	lcbuf = (CHAR*)( MemAlloc(p1-p0) );
	memcpy(lcbuf, p0, p1-p0);
	_strlwr(lcbuf);

	//Find szKeyWord string
	if(!(psafe = strstr(lcbuf, _strlwr(szKeyWord)))) {
		printf("No '%s' build found.\n", szKeyWord);
		MemFree(buf);
		MemFree(lcbuf);
        return FALSE;
	}

	//relate to position in org buffer: p0 + offset into psafe buffer - 1
	psafe = p0 + (psafe - lcbuf) - 1;
	
	MemFree(lcbuf);
	
	//Now Set p0 to begining & p1 to end of 'safe' entry & copy into SafeBootLine buffer
	p1 = p0;
	
	while( (p1 = strchr(p1, '\n') + 1) 
		&& (p1 < psafe )) 
			p0 = p1;
	
	p1 = strchr(p0, '=');
	dwSafeSize = (DWORD)(p1-p0+2);
	SafeBootLine = (CHAR*)(MemAlloc(dwSafeSize));
	ZeroMemory(SafeBootLine, dwSafeSize);
	memcpy(SafeBootLine, p0, dwSafeSize);
	*(SafeBootLine + dwSafeSize - 2) = '\r';
	*(SafeBootLine + dwSafeSize - 1) = '\n';
	*(SafeBootLine + dwSafeSize ) = '\0';
	

	printf("Setting as next boot: \n\t%s\n", SafeBootLine); 				
	

    //
    // Write:
    //
    // 1) the first part, start=buf, len=pdefault-buf
    // 2) the default= line
    // 3) the last part, start=plast, len=buf+sizeof(buf)-plast
    //
	SetFileAttributes(szBootIni, FILE_ATTRIBUTE_NORMAL);

	hfile = CreateFile(szBootIni,
						GENERIC_ALL,
						0,
						NULL,
						OPEN_EXISTING,
						0,
						NULL);


	if(!WriteFile(hfile, buf, (DWORD)(pdefault-buf), &dwCnt, NULL) ||
			!WriteFile(hfile, SafeBootLine, dwSafeSize, &dwCnt, NULL) ||
			!WriteFile(hfile, plast, (DWORD)(buf+dwFileSize-plast+1), &dwCnt, NULL) )
    {
			CloseHandle(hfile);
		    MemFree(buf);
			FatalError(0, L"Failed to write new boot.ini\n");
			return FALSE;
	}	

    //
    // Make boot.ini archive, read only, and system.
    //
    SetFileAttributes(
        szBootIni,
        FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN
        );

	MemFree(buf);
    return(TRUE);
}


NTSTATUS MoveSafeIA64(WCHAR *szwKeyWord){
	
	PMY_BOOT_ENTRY bootEntry;
	PLIST_ENTRY listEntry = NULL;
	PLIST_ENTRY ListHead = NULL;
	WCHAR szFriendlyName[255];

	ListHead = &BootEntries;

	if ( ListHead->Flink == ListHead ){
			//Don't have to move anything
			return 1;
	}
	
	for ( listEntry = ListHead->Flink;
              listEntry != ListHead;
              listEntry = listEntry->Flink ) {

            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
			wcscpy(szFriendlyName, bootEntry->FriendlyName);
            if( wcsstr( _wcslwr(szFriendlyName), szwKeyWord ))
			{
				wprintf(L"Setting as next boot: \n\t%s\n", bootEntry->FriendlyName); 				
				RemoveEntryList( listEntry );
                InsertHeadList( &BootEntries, listEntry);
                SaveChanges(NULL);
				return 1;
			}

	}

	return 0;
}

NTSTATUS LabelDefaultX86(CHAR *szKeyWord){

    HANDLE hfile;
    DWORD dwFileSize = 0, dwRead, dwSafeSize, dwCnt, dwDefaultSize;
    CHAR *lcbuf = NULL, *buf = NULL; 
    CHAR *sCurrentBootChoice = NULL;
    CHAR *sBootTitle   = NULL, *newsBootTitle = NULL; 
    CHAR *sBootDefault = NULL, *sBootData     = NULL;
    CHAR *pdefault,*plast,*p0,*p1, *p2, *psafe;
    CHAR *szInsKeyWord = NULL;
    BOOL  bReadFile    = FALSE;
    BOOL  bWriteFile   = FALSE;
    WCHAR szBootIni[]  = L"?:\\BOOT.INI";

    *szBootIni = x86DetermineSystemPartition();

    szInsKeyWord = (CHAR*)(MemAlloc(2+strlen(szKeyWord)));
    sprintf(szInsKeyWord, "%s ", szKeyWord);

    //
    // Open and read boot.ini.
    //

    SetFileAttributes(szBootIni, FILE_ATTRIBUTE_NORMAL);

    hfile = CreateFile(    szBootIni,GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

       if(hfile != INVALID_HANDLE_VALUE) {

                dwFileSize = GetFileSize(hfile, NULL);

                if(dwFileSize != INVALID_FILE_SIZE) {
                         buf = (CHAR*)( MemAlloc((SIZE_T)(dwFileSize+1)));
                         bReadFile = ReadFile(hfile, buf, dwFileSize, &dwRead, NULL);
                         _strlwr(buf); 
               }
              
              SetFileAttributes( szBootIni,
                     FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | 
                     FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN
                     );
              CloseHandle(hfile);               
    }

    if(!bReadFile) {
        if(buf) MemFree(buf);
              FatalError(0, L"failed to read boot.ini\n");
              return FALSE;
    }

       //Set pdefault to end of default=... line
       if(!(pdefault = strstr(buf, "default=")) ||
              !(pdefault += sizeof("default"))) {
                     MemFree(buf); 
                     FatalError(0, L"failed to find 'default' entry\n");
                     return FALSE;
              }
	   dwDefaultSize = (DWORD)(pdefault - buf);

       //Get the next line

       plast = strchr(pdefault, '\n') - 1;

       sCurrentBootChoice = (CHAR*)( MemAlloc(plast - pdefault));
       ZeroMemory(sCurrentBootChoice, sizeof(sCurrentBootChoice));
       memcpy(sCurrentBootChoice, pdefault, plast - pdefault);

       // printf("Default:\n%s\n", sCurrentBootChoice); 
                
       plast = strchr(pdefault, '\n') + 1;

       //Get the sBootTitle
       //Set p0 to the first [Operating Systems] entry, p1 to the last, search between the two
       if(!(p0 = strstr(buf,"[operating systems]")) ||
               !(p0 = strchr(p0,'\n') + 1) ) {
                MemFree(buf);
                FatalError(0, L"failed to find '[Operating systems]' entry\n");
        return FALSE;
    }

       //Find next ini section - or end of file
       if(!(p1 = strchr(p0, '['))) p1 = buf+strlen(buf);
     
       dwSafeSize      = (DWORD)(p1 - p0)+1;
       sBootDefault    = (CHAR*)(MemAlloc(dwSafeSize));
       ZeroMemory(sBootDefault, dwSafeSize);
       sprintf(sBootDefault, "%s\r\n",sCurrentBootChoice);

       // printf("Setting label to: \n\t%s\n", sBootDefault);

       //create lowercase buffer to search through

       lcbuf = (CHAR*)( MemAlloc(p1-p0) );
       memcpy(lcbuf, p0, p1-p0);
       _strlwr(lcbuf);

       //Find sCurrentBootChoice string
       if(!(psafe = strstr(lcbuf, _strlwr(sCurrentBootChoice)))) {

              wprintf(L"Default boot \"%ws\" not found.\n", sCurrentBootChoice);
              MemFree(buf);
              MemFree(lcbuf);
        return FALSE;
       }
       //relate to position in org buffer: p0 + offset into psafe buffer - 1
       psafe = p0 + (psafe - lcbuf) - 1;
       
       MemFree(lcbuf);
       
       // Set p0 to begining & p1 to end of entry & 
       // copy into sBootTitle buffer
       p1 = p0 ;
       
       while( (p1 = strchr(p1, '\n') + 1) 
              && (p1 < psafe )) 
                     p0 = p1;
       
       p1 =   1 + strchr(psafe, '=');
       p2 =  -1 + strchr(p1, '\n');

       dwSafeSize = (DWORD)(p2 - p1) + 1 ;
       sBootTitle = (CHAR*)(MemAlloc(dwSafeSize));
       ZeroMemory(sBootTitle, dwSafeSize);
       memcpy(sBootTitle, p1, dwSafeSize);
       newsBootTitle = (CHAR*)(MemAlloc(dwSafeSize+ strlen(szKeyWord) + 3));      
       ZeroMemory(newsBootTitle, dwSafeSize+ strlen(szKeyWord) + 3); 
       sprintf(newsBootTitle,"%s", sPreLabel(sBootTitle, szInsKeyWord ));

       // printf("Title:\n%s\n", newsBootTitle);       
       sBootData = (CHAR* ) (MemAlloc(dwFileSize + strlen(szKeyWord) + 3));
       ZeroMemory(sBootData, dwFileSize + strlen(szKeyWord) + 3);
       memcpy(sBootData, buf, dwFileSize);

       // printf("Boot file data(old): \n%s\n", sBootData);
       sprintf(sBootData, "%s", sReChanged(sBootData, sBootTitle, newsBootTitle));
       MemFree(sBootTitle);
       MemFree(newsBootTitle);

       // printf("Boot file data(new): \n%s\n", sBootData);
       SetFileAttributes(szBootIni, FILE_ATTRIBUTE_NORMAL);

       hfile = CreateFile(szBootIni, GENERIC_ALL,0,NULL, OPEN_EXISTING, 0, NULL);
                         
       if(hfile != INVALID_HANDLE_VALUE) {


                if(!WriteFile(hfile, sBootData , strlen(sBootData), &dwCnt, NULL)){
                              CloseHandle(hfile);
                              MemFree(buf);
                              FatalError(0, L"Failed to write new boot.ini\n");
                              return FALSE;
                              }       

              bWriteFile = TRUE;

              //
              // Make boot.ini archive, read only, and system.
              //
              SetFileAttributes(
                                szBootIni,
                        FILE_ATTRIBUTE_READONLY | 
                        FILE_ATTRIBUTE_SYSTEM | 
                        FILE_ATTRIBUTE_ARCHIVE | 
                        FILE_ATTRIBUTE_HIDDEN
                        );
       }
       MemFree(buf);
       MemFree(sBootData);
       MemFree(szInsKeyWord);                         
    return(bWriteFile);
}


NTSTATUS LabelDefaultIA64(WCHAR *szwKeyWord){
       
       PMY_BOOT_ENTRY bootEntry;
       PLIST_ENTRY listEntry = NULL;
       PLIST_ENTRY ListHead = NULL;
       WCHAR  szFriendlyName[1024];
       WCHAR  szwSmFrFriendlyName[1024];
       WCHAR  szwSmToFriendlyName[1024];
       CHAR   szSmFrFriendlyName[1024];
       CHAR   szSmToFriendlyName[1024];
       CHAR   szInsKeyWord[1024];  
       INT    dOuTMB2WC;

       ListHead = &BootEntries;

       bootEntry = 
                 CONTAINING_RECORD( 
                                   ListHead->Flink, 
                                   MY_BOOT_ENTRY, 
                                   ListEntry );
      // modify friendly name for default entry.

      wsprintf(szwSmFrFriendlyName, L"%ws", bootEntry->FriendlyName);

      if(!WideCharToMultiByte( CP_ACP, 
                                   WC_NO_BEST_FIT_CHARS,
                                   szwKeyWord, 
                                   -1,
                                   szInsKeyWord,
                                   sizeof(szInsKeyWord),
                                   NULL,
                                   NULL)) {
                FatalError(0, L"Couldn't convert string");
      }


      sprintf(szInsKeyWord, "%s ", szInsKeyWord);

      if(!WideCharToMultiByte( CP_ACP, 
                                   WC_NO_BEST_FIT_CHARS,
                                   szwSmFrFriendlyName, 
                                   -1,
                                   szSmFrFriendlyName,
                                   sizeof(szSmFrFriendlyName),
                                   NULL,
                                   NULL)) {
                FatalError(0, L"Couldn't convert string");
      }
      wprintf(L"original(w): \"%ws\"\n", szwSmFrFriendlyName);
      sprintf(szSmToFriendlyName, "%s", sPreLabel(szSmFrFriendlyName, szInsKeyWord));   

      //do a hack here. Do not extend the Friendly name beyong 
      //its former size. unless you wish to debug why 
      //CreateBootEntryFromBootEntry sig segv 

      szSmToFriendlyName[strlen(szSmFrFriendlyName)] = '\0';
      szSmToFriendlyName[strlen(szSmFrFriendlyName)-1] = '.';
      szSmToFriendlyName[strlen(szSmFrFriendlyName)-2] = '.';
      szSmToFriendlyName[strlen(szSmFrFriendlyName)-3] = '.';

      if (!(dOuTMB2WC=MultiByteToWideChar(CP_ACP, 
                                         MB_PRECOMPOSED,
                                         szSmToFriendlyName,
                                         strlen(szSmToFriendlyName) + 1,
                                         szwSmToFriendlyName,
                                         sizeof(szwSmToFriendlyName)/sizeof(szwSmToFriendlyName[0])))){
              FatalError(0, L"Couldn't convert string back");
      }
      wprintf(L"modified(w): \"%ws\"\n", szwSmToFriendlyName);
      
           wcscpy( bootEntry->FriendlyName, szwSmToFriendlyName);
           // bootEntry->FriendlyNameLength = 2*strlen(szSmToFriendlyName)+2;
           // this seems to be ignored anyway.
           MBE_SET_MODIFIED( bootEntry );
           wprintf(L"saving changes:\n\"%ws\"\n", 
                            bootEntry->FriendlyName);
           SaveChanges(bootEntry);


     for ( listEntry = ListHead->Flink;
           listEntry != ListHead;
           listEntry = listEntry->Flink ) {

            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
            wcscpy(szFriendlyName, bootEntry->FriendlyName);
            if( wcsstr( _wcslwr(szFriendlyName), _wcslwr(szwSmToFriendlyName ))){
                      wprintf(L"committed changes:\n\"%ws\"\n", 
                                                     bootEntry->FriendlyName);

                      return 1;
            }

      }

      return 0;

}

PVOID
MemAlloc(
    IN SIZE_T Size
    )
{
    PSIZE_T p;

    //
    // Add space for storing the size of the block.
    //
    p = (PSIZE_T)(RtlAllocateHeap( RtlProcessHeap(), 0, Size + sizeof(SIZE_T) ));

    if ( p == NULL ) {
        FatalError( ERROR_NOT_ENOUGH_MEMORY, L"Insufficient memory\n" );
    }

    //
    // Store the size of the block, and return the address
    // of the user portion of the block.
    //
    *p++ = Size;

    return p;
}


VOID
MemFree(
    IN PVOID Block
    )
{
    if (Block == NULL)
        return;

    //
    // Free the block at its real address.
    //
    RtlFreeHeap( RtlProcessHeap(), 0, (PSIZE_T)Block - 1);
}





WCHAR
x86DetermineSystemPartition(
    VOID
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    If for some reason we cannot determine the system partition by the above
    method, we simply assume it's C:.

Arguments:

    None

Return Value:

    Drive letter of system partition.

--*/

{
    BOOL  GotIt;
    PWSTR NtDevicePath = NULL;
    WCHAR Drive;
    WCHAR DriveName[3];
    WCHAR Buffer[512];
       WCHAR FileName[512];
       WCHAR *BootFiles[4];
    DWORD NtDevicePathLen = 0;
    PWSTR p;
    DWORD PhysicalDriveNumber;
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;
    PVOID DriveLayout;
    DWORD DriveLayoutSize;
       DWORD d;
       int i;
       

    DriveName[1] = L':';
    DriveName[2] = 0;

    GotIt = FALSE;
       
       BootFiles[0] = L"BOOT.INI";
       BootFiles[1] = L"NTLDR";
       BootFiles[2] = L"NTDETECT.COM";
       BootFiles[3] = NULL;
       
                    
       // The system partition can only be a drive that is on
       // this disk.  We make this determination by looking at NT drive names
       // for each drive letter and seeing if the nt equivalent of
       // multi(0)disk(0)rdisk(0) is a prefix.
       //
       for(Drive=L'C'; Drive<=L'Z'; Drive++) {
              
              WCHAR drvbuf[5];
              
              swprintf(drvbuf, L"%c:\\", Drive);
              if(GetDriveType(drvbuf) == DRIVE_FIXED) {
                     
                     DriveName[0] = Drive;
                     
                     if(QueryDosDeviceW(DriveName,Buffer,sizeof(Buffer)/sizeof(WCHAR))) {
                            
                            if(!_wcsnicmp(NtDevicePath,Buffer,NtDevicePathLen)) {
                                   
                                   //
                                   // Now look to see whether there's an nt boot sector and
                                   // boot files on this drive.
                                   //
                                   
                                   
                                   for(i=0; BootFiles[i]; i++) {
                                          DWORD d;
                                          swprintf(FileName, L"%s%s", drvbuf, BootFiles[i]);
                                          
                                          if(-1 == GetFileAttributes(FileName))
                                                 break;
                                   
                                   }
                                   return Drive;
                            }
                            
                     }
              }
       }

       return L'C';
       
}



VOID
FatalError (
    DWORD Error,
    PWSTR Format,
    ...
    )
{
    va_list marker;

       va_start( marker, Format );
       wprintf(L"Fatal error:\n \t");
    vwprintf( Format, marker );
    va_end( marker );

    if ( Error == NO_ERROR ) {
        Error = ERROR_GEN_FAILURE;
    }
    exit( Error );

} // FatalError 


VOID
ConvertBootEntries (
    PBOOT_ENTRY_LIST NtBootEntries
    )

/*++

Routine Description:

    Convert boot entries read from EFI NVRAM into our internal format.

Arguments:

    None.

Return Value:

    NTSTATUS - Not STATUS_SUCCESS if an unexpected error occurred.

--*/

{
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PBOOT_ENTRY bootEntryCopy;
    PMY_BOOT_ENTRY myBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    ULONG length;

    bootEntryList = NtBootEntries;

    while (TRUE) {

        bootEntry = &bootEntryList->BootEntry;

        //
        // Calculate the length of our internal structure. This includes
        // the base part of MY_BOOT_ENTRY plus the NT BOOT_ENTRY.
        //
        length = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;
        myBootEntry = (PMY_BOOT_ENTRY) (MemAlloc(length));

        RtlZeroMemory(myBootEntry, length);

        //
        // Link the new entry into the list.
        //
        if ( (bootEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0 ) {
            InsertTailList( &ActiveUnorderedBootEntries, &myBootEntry->ListEntry );
            myBootEntry->ListHead = &ActiveUnorderedBootEntries;
        } else {
            InsertTailList( &InactiveUnorderedBootEntries, &myBootEntry->ListEntry );
            myBootEntry->ListHead = &InactiveUnorderedBootEntries;
        }

        //
        // Copy the NT BOOT_ENTRY into the allocated buffer.
        //
        bootEntryCopy = &myBootEntry->NtBootEntry;
        memcpy(bootEntryCopy, bootEntry, bootEntry->Length);

        //
        // Fill in the base part of the structure.
        //
        myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + length - 1;
        myBootEntry->Id = bootEntry->Id;
        myBootEntry->Attributes = bootEntry->Attributes;
        myBootEntry->FriendlyName = (PWSTR)(ADD_OFFSET(bootEntryCopy, FriendlyNameOffset));
        myBootEntry->FriendlyNameLength =
            ((ULONG)wcslen(myBootEntry->FriendlyName) + 1) * sizeof(WCHAR);
        myBootEntry->BootFilePath = (PFILE_PATH)(ADD_OFFSET(bootEntryCopy, BootFilePathOffset));

        //
        // If this is an NT boot entry, capture the NT-specific information in
        // the OsOptions.
        //
        osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;

        if ((bootEntryCopy->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
            (strcmp((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0)) {

            MBE_SET_IS_NT( myBootEntry );
            myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
            myBootEntry->OsLoadOptionsLength =
                ((ULONG)wcslen(myBootEntry->OsLoadOptions) + 1) * sizeof(WCHAR);
            myBootEntry->OsFilePath = (PFILE_PATH)(ADD_OFFSET(osOptions, OsLoadPathOffset));

        } else {

            //
            // Foreign boot entry. Just capture whatever OS options exist.
            //

            myBootEntry->ForeignOsOptions = bootEntryCopy->OsOptions;
            myBootEntry->ForeignOsOptionsLength = bootEntryCopy->OsOptionsLength;
        }

        //
        // Move to the next entry in the enumeration list, if any.
        //
        if (bootEntryList->NextEntryOffset == 0) {
            break;
        }
        bootEntryList = (PBOOT_ENTRY_LIST)(ADD_OFFSET(bootEntryList, NextEntryOffset));
    }

    return;

} // ConvertBootEntries

VOID
ConcatenatePaths (
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    )

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

{
    BOOL NeedBackslash = TRUE;
    DWORD l;
     
    if(!Path1)
        return;

    l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(Path2 && *Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(Path2 && ((l+lstrlen(Path2)) < BufferSizeChars)) {
        lstrcat(Path1,Path2);
    }
}

PMY_BOOT_ENTRY
CreateBootEntryFromBootEntry (
    IN PMY_BOOT_ENTRY OldBootEntry
    )
{
    ULONG requiredLength;
    ULONG osOptionsOffset;
    ULONG osLoadOptionsLength;
    ULONG osLoadPathOffset;
    ULONG osLoadPathLength;
    ULONG osOptionsLength;
    ULONG friendlyNameOffset;
    ULONG friendlyNameLength;
    ULONG bootPathOffset;
    ULONG bootPathLength;
    PMY_BOOT_ENTRY newBootEntry;
    PBOOT_ENTRY ntBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    PFILE_PATH osLoadPath;
    PWSTR friendlyName;
    PFILE_PATH bootPath;
    //
    // Calculate how long the internal boot entry needs to be. This includes
    // our internal structure, plus the BOOT_ENTRY structure that the NT APIs
    // use.
    //
    // Our structure:
    //
    requiredLength = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);

    //
    // Base part of NT structure:
    //
    requiredLength += FIELD_OFFSET(BOOT_ENTRY, OsOptions);

    //
    // Save offset to BOOT_ENTRY.OsOptions. Add in base part of
    // WINDOWS_OS_OPTIONS. Calculate length in bytes of OsLoadOptions
    // and add that in.
    //
    osOptionsOffset = requiredLength;

    if ( MBE_IS_NT( OldBootEntry ) ) {

        //
        // Add in base part of WINDOWS_OS_OPTIONS. Calculate length in
        // bytes of OsLoadOptions and add that in.
        //
        requiredLength += FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions);
        osLoadOptionsLength = OldBootEntry->OsLoadOptionsLength;
        requiredLength += osLoadOptionsLength;

        //
        // Round up to a ULONG boundary for the OS FILE_PATH in the
        // WINDOWS_OS_OPTIONS. Save offset to OS FILE_PATH. Calculate length
        // in bytes of FILE_PATH and add that in. Calculate total length of 
        // WINDOWS_OS_OPTIONS.
        // 
        requiredLength = ALIGN_UP(requiredLength, ULONG);
        osLoadPathOffset = requiredLength;
        requiredLength += OldBootEntry->OsFilePath->Length;
        osLoadPathLength = requiredLength - osLoadPathOffset;

    } else {

        //
        // Add in length of foreign OS options.
        //
        requiredLength += OldBootEntry->ForeignOsOptionsLength;

        osLoadOptionsLength = 0;
        osLoadPathOffset = 0;
        osLoadPathLength = 0;
    }

    osOptionsLength = requiredLength - osOptionsOffset;

    //
    // Round up to a ULONG boundary for the friendly name in the BOOT_ENTRY.
    // Save offset to friendly name. Calculate length in bytes of friendly name
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    friendlyNameOffset = requiredLength;
    friendlyNameLength = OldBootEntry->FriendlyNameLength;
    requiredLength += friendlyNameLength;

    //
    // Round up to a ULONG boundary for the boot FILE_PATH in the BOOT_ENTRY.
    // Save offset to boot FILE_PATH. Calculate length in bytes of FILE_PATH
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    bootPathOffset = requiredLength;
    requiredLength += OldBootEntry->BootFilePath->Length;
    bootPathLength = requiredLength - bootPathOffset;

    //
    // Allocate memory for the boot entry.
    //
    newBootEntry = (PMY_BOOT_ENTRY)(MemAlloc(requiredLength));
    ASSERT(newBootEntry != NULL);

    RtlZeroMemory(newBootEntry, requiredLength);

    //
    // Calculate addresses of various substructures using the saved offsets.
    //
    ntBootEntry = &newBootEntry->NtBootEntry;
    osOptions = (PWINDOWS_OS_OPTIONS)ntBootEntry->OsOptions;
    osLoadPath = (PFILE_PATH)((PUCHAR)newBootEntry + osLoadPathOffset);
    friendlyName = (PWSTR)((PUCHAR)newBootEntry + friendlyNameOffset);
    bootPath = (PFILE_PATH)((PUCHAR)newBootEntry + bootPathOffset);

    //
    // Fill in the internal-format structure.
    //
    newBootEntry->AllocationEnd = (PUCHAR)newBootEntry + requiredLength;
    newBootEntry->Status = OldBootEntry->Status & MBE_STATUS_IS_NT;
    newBootEntry->Attributes = OldBootEntry->Attributes;
    newBootEntry->Id = OldBootEntry->Id;
    newBootEntry->FriendlyName = friendlyName;
    newBootEntry->FriendlyNameLength = friendlyNameLength;
    newBootEntry->BootFilePath = bootPath;
    if ( MBE_IS_NT( OldBootEntry ) ) {
        newBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
        newBootEntry->OsLoadOptionsLength = osLoadOptionsLength;
        newBootEntry->OsFilePath = osLoadPath;
    }

    //
    // Fill in the base part of the NT boot entry.
    //
    ntBootEntry->Version = BOOT_ENTRY_VERSION;
    ntBootEntry->Length = requiredLength - FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);
    ntBootEntry->Attributes = OldBootEntry->Attributes;
    ntBootEntry->Id = OldBootEntry->Id;
    ntBootEntry->FriendlyNameOffset = (ULONG)((PUCHAR)friendlyName - (PUCHAR)ntBootEntry);
    ntBootEntry->BootFilePathOffset = (ULONG)((PUCHAR)bootPath - (PUCHAR)ntBootEntry);
    ntBootEntry->OsOptionsLength = osOptionsLength;

    if ( MBE_IS_NT( OldBootEntry ) ) {
    
        //
        // Fill in the base part of the WINDOWS_OS_OPTIONS, including the
        // OsLoadOptions.
        //
        strcpy((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE);
        osOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
        osOptions->Length = osOptionsLength;
        osOptions->OsLoadPathOffset = (ULONG)((PUCHAR)osLoadPath - (PUCHAR)osOptions);
        wcscpy(osOptions->OsLoadOptions, OldBootEntry->OsLoadOptions);
    
        //
        // Copy the OS FILE_PATH.
        //
        memcpy( osLoadPath, OldBootEntry->OsFilePath, osLoadPathLength );

    } else {

        //
        // Copy the foreign OS options.
        //

        memcpy( osOptions, OldBootEntry->ForeignOsOptions, osOptionsLength );
    }

    //
    // Copy the friendly name.
    //
    wcscpy(friendlyName, OldBootEntry->FriendlyName);

    //
    // Copy the boot FILE_PATH.
    //
    memcpy( bootPath, OldBootEntry->BootFilePath, bootPathLength );

    return newBootEntry;

} // CreateBootEntryFromBootEntry

VOID
FreeBootEntry (
    IN PMY_BOOT_ENTRY BootEntry
    )
{
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, FriendlyName );
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, OsLoadOptions );
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, BootFilePath );
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, OsFilePath );

    MemFree( BootEntry );

    return;

} // FreeBootEntry

VOID
InitializeEfi (
    VOID
    )
{
    DWORD error;
    NTSTATUS status;
    BOOLEAN wasEnabled;
    HMODULE h;
    WCHAR dllName[MAX_PATH]; 
    ULONG length;
    HKEY key;
    DWORD type;
    PBOOT_ENTRY_LIST ntBootEntries;
    ULONG i;
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY bootEntry;

    //
    // Enable the privilege that is necessary to query/set NVRAM.
    //

    status = RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                TRUE,
                FALSE,
                &wasEnabled
                );
    if ( !NT_SUCCESS(status) ) {
        error = RtlNtStatusToDosError( status );
        FatalError(error , L"Insufficient privilege.\n" );
    }

    //
    // Get the NT name of the system partition from the registry.
    //

    error = RegOpenKey( HKEY_LOCAL_MACHINE, TEXT("System\\Setup"), &key );
    if ( error != ERROR_SUCCESS ) {
        FatalError( error, L"Unable to read SystemPartition registry value: %d\n", error );
    }

    error = RegQueryValueEx( key, TEXT("SystemPartition"), NULL, &type, NULL, &length );
    if ( error != ERROR_SUCCESS ) {
        FatalError( error, L"Unable to read SystemPartition registry value: %d\n", error );
    }
    if ( type != REG_SZ ) {
        FatalError(
            ERROR_INVALID_PARAMETER,
            L"Unable to read SystemPartition registry value: wrong type\n"
            );
    }

    SystemPartitionNtName = (PWSTR)(MemAlloc( length ));

    error = RegQueryValueEx( 
                key,
                TEXT("SystemPartition"),
                NULL,
                &type,
                (PBYTE)SystemPartitionNtName,
                &length
                );
    if ( error != ERROR_SUCCESS ) {
        FatalError( error, L"Unable to read SystemPartition registry value: %d\n", error );
    }
    
    RegCloseKey( key );

    //
    // Load ntdll.dll from the system directory.
    //

    GetSystemDirectory( dllName, MAX_PATH );
    ConcatenatePaths( dllName, TEXT("ntdll.dll"), MAX_PATH );
    h = LoadLibrary( dllName );
    if ( h == NULL ) {
        error = GetLastError();
        FatalError( error, L"Can't load NTDLL.DLL: %d\n", error );
    }

    //
    // Get the addresses of the NVRAM APIs that we need to use. If any of
    // these APIs are not available, this must be a pre-EFI NVRAM build.
    //

       AddBootEntry = (NTSTATUS (__stdcall *)(PBOOT_ENTRY,PULONG))GetProcAddress( h, "NtAddBootEntry" );
    DeleteBootEntry = (NTSTATUS (__stdcall *)(ULONG))GetProcAddress( h, "NtDeleteBootEntry" );
    ModifyBootEntry = (NTSTATUS (__stdcall *)(PBOOT_ENTRY))GetProcAddress( h, "NtModifyBootEntry" );
    EnumerateBootEntries = (NTSTATUS (__stdcall *)(PVOID,PULONG))GetProcAddress( h, "NtEnumerateBootEntries" );
    QueryBootEntryOrder = (NTSTATUS (__stdcall *)(PULONG,PULONG))GetProcAddress( h, "NtQueryBootEntryOrder" );
    SetBootEntryOrder = (NTSTATUS (__stdcall *)(PULONG,ULONG))GetProcAddress( h, "NtSetBootEntryOrder" );
    QueryBootOptions = (NTSTATUS (__stdcall *)(PBOOT_OPTIONS,PULONG))GetProcAddress( h, "NtQueryBootOptions" );
    SetBootOptions = (NTSTATUS (__stdcall *)(PBOOT_OPTIONS,ULONG))GetProcAddress( h, "NtSetBootOptions" );
    TranslateFilePath = (NTSTATUS (__stdcall *)(PFILE_PATH,ULONG,PFILE_PATH,PULONG))GetProcAddress( h, "NtTranslateFilePath" );

    if ( (AddBootEntry == NULL) ||
         (DeleteBootEntry == NULL) ||
         (ModifyBootEntry == NULL) ||
         (EnumerateBootEntries == NULL) ||
         (QueryBootEntryOrder == NULL) ||
         (SetBootEntryOrder == NULL) ||
         (QueryBootOptions == NULL) ||
         (SetBootOptions == NULL) ||
         (TranslateFilePath == NULL) ) {
        FatalError( ERROR_OLD_WIN_VERSION, L"This build does not support EFI NVRAM\n" );
    }

    //
    // Get the global system boot options. If the call fails with
    // STATUS_NOT_IMPLEMENTED, this is not an EFI machine.
    //

    length = 0;
    status = QueryBootOptions( NULL, &length );

    if ( status == STATUS_NOT_IMPLEMENTED ) {
        FatalError( ERROR_OLD_WIN_VERSION, L"This build does not support EFI NVRAM\n" );
    }

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unexpected error from NtQueryBootOptions: 0x%x\n", status );
    }

    BootOptions = (PBOOT_OPTIONS)(MemAlloc( length ));
    OriginalBootOptions = (PBOOT_OPTIONS)(MemAlloc( length ));

    status = QueryBootOptions( BootOptions, &length );
    if ( status != STATUS_SUCCESS ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unexpected error from NtQueryBootOptions: 0x%x\n", status );
    }

    memcpy( OriginalBootOptions, BootOptions, length );
    BootOptionsLength = length;
    OriginalBootOptionsLength = length;

    //
    // Get the system boot order list.
    //

    length = 0;
    status = QueryBootEntryOrder( NULL, &length );

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        if ( status == STATUS_SUCCESS ) {
            length = 0;
        } else {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtQueryBootEntryOrder: 0x%x\n", status );
        }
    }

    if ( length != 0 ) {

        BootEntryOrder = (PULONG)(MemAlloc( length * sizeof(ULONG) ));
        OriginalBootEntryOrder = (PULONG)(MemAlloc( length * sizeof(ULONG) ));

        status = QueryBootEntryOrder( BootEntryOrder, &length );
        if ( status != STATUS_SUCCESS ) {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtQueryBootEntryOrder: 0x%x\n", status );
        }

        memcpy( OriginalBootEntryOrder, BootEntryOrder, length * sizeof(ULONG) );
    }

    BootEntryOrderCount = length;
    OriginalBootEntryOrderCount = length;

    //
    // Get all existing boot entries.
    //

    length = 0;
    status = EnumerateBootEntries( NULL, &length );
    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        if ( status == STATUS_SUCCESS ) {
            length = 0;
        } else {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtEnumerateBootEntries: 0x%x\n", status );
        }
    }

    InitializeListHead( &BootEntries );
    InitializeListHead( &DeletedBootEntries );
    InitializeListHead( &ActiveUnorderedBootEntries );
    InitializeListHead( &InactiveUnorderedBootEntries );

    if ( length != 0 ) {
    
        ntBootEntries = (PBOOT_ENTRY_LIST)(MemAlloc( length ));

        status = EnumerateBootEntries( ntBootEntries, &length );
        if ( status != STATUS_SUCCESS ) {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtEnumerateBootEntries: 0x%x\n", status );
        }

        //
        // Convert the boot entries into an internal representation.
        //

        ConvertBootEntries( ntBootEntries );

        //
        // Free the enumeration buffer.
        //

        MemFree( ntBootEntries );
    }

    //
    // Build the ordered boot entry list.
    //

    for ( i = 0; i < BootEntryOrderCount; i++ ) {
        ULONG id = BootEntryOrder[i];
        for ( listEntry = ActiveUnorderedBootEntries.Flink;
              listEntry != &ActiveUnorderedBootEntries;
              listEntry = listEntry->Flink ) {
            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
            if ( bootEntry->Id == id ) {
                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &BootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &BootEntries;
            }
        }
        for ( listEntry = InactiveUnorderedBootEntries.Flink;
              listEntry != &InactiveUnorderedBootEntries;
              listEntry = listEntry->Flink ) {
            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
            if ( bootEntry->Id == id ) {
                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &BootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &BootEntries;
            }
        }
    }

    return;

} // InitializeEfi

PMY_BOOT_ENTRY
SaveChanges (
    PMY_BOOT_ENTRY CurrentBootEntry
    )
{
    NTSTATUS status;
    DWORD error;
    PLIST_ENTRY listHeads[4];
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    ULONG list;
    PMY_BOOT_ENTRY bootEntry;
    PMY_BOOT_ENTRY newBootEntry;
    PMY_BOOT_ENTRY newCurrentBootEntry;
    ULONG count;

    //SetStatusLine( L"Saving changes..." );

    //
    // Walk the three lists, updating boot entries in NVRAM.
    //

    newCurrentBootEntry = CurrentBootEntry;


    listHeads[0] = &DeletedBootEntries;
    listHeads[1] = &InactiveUnorderedBootEntries;
    listHeads[2] = &ActiveUnorderedBootEntries;
    listHeads[3] = &BootEntries;

    for ( list = 0; list < 4; list++ ) {
    
        listHead = listHeads[list];

        for ( listEntry = listHead->Flink; listEntry != listHead; listEntry = listEntry->Flink ) {

            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

            //
            // Check first for deleted entries, then for new entries, and
            // finally for modified entries.
            //

            if ( MBE_IS_DELETED( bootEntry ) ) {

                //
                // If it's also marked as new, it's not in NVRAM, so there's
                // nothing to delete.
                //

                if ( !MBE_IS_NEW( bootEntry ) ) {

                    status = DeleteBootEntry( bootEntry->Id );
                    if ( !NT_SUCCESS(status) ) {
                        if ( status != STATUS_VARIABLE_NOT_FOUND ) {
                            error = RtlNtStatusToDosError( status );
                            FatalError( error, L"Unable to delete boot entry: 0x%x\n", status );
                        }
                    }
                }

                //
                // Delete this entry from the list and from memory.
                //

                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );

                FreeBootEntry( bootEntry );
                ASSERT( bootEntry != CurrentBootEntry );

            } else if ( MBE_IS_NEW( bootEntry ) ) {

                //
                // We don't support this yet.
                //

                FatalError(
                    ERROR_GEN_FAILURE,
                    L"How did we end up in SaveChanges with a NEW boot entry?!?\n"
                    );

            } else if ( MBE_IS_MODIFIED( bootEntry ) ) {

                //
                // Create a new boot entry structure using the existing one.
                // This is necessary to make an NT BOOT_ENTRY that can be
                // passed to NtModifyBootEntry.
                //

                newBootEntry = CreateBootEntryFromBootEntry( bootEntry );

                status = ModifyBootEntry( &newBootEntry->NtBootEntry );
                if ( !NT_SUCCESS(status) ) {
                    error = RtlNtStatusToDosError( status );
                    FatalError( error, L"Unable to modify boot entry: 0x%x\n", status );
                }

                //
                // Insert the new boot entry in place of the existing one.
                // Free the old one.
                //

                InsertHeadList( &bootEntry->ListEntry, &newBootEntry->ListEntry );
                RemoveEntryList( &bootEntry->ListEntry );

                FreeBootEntry( bootEntry );
                if ( bootEntry == CurrentBootEntry ) {

                    newCurrentBootEntry = newBootEntry;
                }
            }
        }
    }

    //
    // Build and write the new boot entry order list.
    //

    listHead = &BootEntries;

    count = 0;
    for ( listEntry = listHead->Flink; listEntry != listHead; listEntry = listEntry->Flink ) {
        count++;
    }

    MemFree( BootEntryOrder );
    BootEntryOrder = (PULONG)(MemAlloc( count * sizeof(ULONG) ));

    count = 0;
    for ( listEntry = listHead->Flink; listEntry != listHead; listEntry = listEntry->Flink ) {
        bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
        BootEntryOrder[count++] = bootEntry->Id;
    }

    status = SetBootEntryOrder( BootEntryOrder, count );
    if ( !NT_SUCCESS(status) ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unable to set boot entry order: 0x%x\n", status );
    }

    MemFree( OriginalBootEntryOrder );
    OriginalBootEntryOrder = (PULONG)(MemAlloc( count * sizeof(ULONG) ));
    memcpy( OriginalBootEntryOrder, BootEntryOrder, count * sizeof(ULONG) );

    //
    // Write the new timeout.
    //

    status = SetBootOptions( BootOptions, BOOT_OPTIONS_FIELD_TIMEOUT );
    if ( !NT_SUCCESS(status) ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unable to set boot options: 0x%x\n", status );
    }

    MemFree( OriginalBootOptions );
    OriginalBootOptions = (PBOOT_OPTIONS)(MemAlloc( BootOptionsLength ));
    memcpy( OriginalBootOptions, BootOptions, BootOptionsLength );
    OriginalBootOptionsLength = BootOptionsLength;

    return newCurrentBootEntry;

} // SaveChanges

PWSTR
GetNtNameForFilePath (
    IN PFILE_PATH FilePath
    )
{
    NTSTATUS status;
    ULONG length;
    PFILE_PATH ntPath;
    PWSTR osDeviceNtName;
    PWSTR osDirectoryNtName;
    PWSTR fullNtName;

    length = 0;
    status = TranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                NULL,
                &length
                );
    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        return NULL;
    }

    ntPath = (PFILE_PATH)(MemAlloc( length ));
    status = TranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                ntPath,
                &length
                );
    if ( !NT_SUCCESS(status) ) {
        MemFree( ntPath );
        return NULL;
    }

    osDeviceNtName = (PWSTR)ntPath->FilePath;
    osDirectoryNtName = osDeviceNtName + wcslen(osDeviceNtName) + 1;

    length = (ULONG)(wcslen(osDeviceNtName) + wcslen(osDirectoryNtName) + 1) * sizeof(WCHAR);
    fullNtName = (PWSTR)(MemAlloc( length ));

    wcscpy( fullNtName, osDeviceNtName );
    wcscat( fullNtName, osDirectoryNtName );

    MemFree( ntPath );

    return fullNtName;

} // GetNtNameForFilePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\autosafe\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Authors:

    Ted Sanders (tsanders), Serguei Kouzmine (sergueik) 05/2002


!ENDIF

MAJORCOMP=autosafe
MINORCOMP=autosafe

TARGETNAME=autosafe
TARGETPATH=.
TARGETTYPE=PROGRAM

SOURCES=        \
    autosafe.c



MSC_WARNING_LEVEL=/W3 /WX

INCLUDES=$(BASE_INC_PATH)

USE_MSVCRT=1

UMTYPE=console

C_DEFINES= -DDBG=1 -DDEBUG=1
TARGETLIBS= \
	$(SDK_LIB_PATH)\ntdll.lib \
	$(SDK_LIB_PATH)\User32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bin2c\bin2c.c ===
#include <windows.h>
#include <fcntl.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

int
dump(
    char     *buffer,
    unsigned  buflen,
    FILE     *Out,
    char     *VarName
    );

int
DumpAscii(
    LPSTR   FileNameIn,
    LPSTR   FileNameOut,
    LPSTR   VarName
    );




// argv:
//
//  1 - in filename
//  2 - required length
//  3 - offset of region in question
//  4 - length of region in question
//  5 - out filename
//  6 - name of variable

int
__cdecl
main(
    int   argc,
    char *argv[]
    )
{
    int      In,rc;
    FILE    *Out;
    void    *buffer;
    unsigned ReqLen,RegStart,RegLen,FileLen;


    if (argc == 5 &&
        (argv[1][0] == '-' || argv[1][0] == '/') &&
        tolower(argv[1][1]) == 'a') {
            return DumpAscii( argv[2], argv[3], argv[4] );
    }

    if(argc != 7) {
        printf("Usage: %s <src file> <src file len> <region offset>\n",argv[0]);
        printf("       <region length> <dst file> <var name>\n");
        return(2);
    }

    ReqLen = atoi(argv[2]);
    RegStart = atoi(argv[3]);
    RegLen = atoi(argv[4]);

    In = _open(argv[1],O_RDONLY | O_BINARY);
    if(In == -1) {
        printf("%s: Unable to open file %s\n",argv[0],argv[1]);
        return(2);
    }

    FileLen = _lseek(In,0,SEEK_END);

    if(RegStart > FileLen) {
        _close(In);
        printf("%s: Desired region is out of range\n",argv[0]);
        return(2);
    }

    if((unsigned)_lseek(In,RegStart,SEEK_SET) != RegStart) {
        _close(In);
        printf("%s: Unable to seek in file %s\n",argv[0],argv[1]);
        return(2);
    }

    if((buffer = malloc(RegLen)) == NULL) {
        _close(In);
        printf("%s: Out of memory\n",argv[0]);
        return(2);
    }

    memset(buffer, 0, RegLen);

    if((unsigned)_read(In,buffer,RegLen) > RegLen) {
        _close(In);
        printf("%s: Unable to read file %s\n",argv[0],argv[1]);
        return(2);
    }

    _close(In);

    Out = fopen(argv[5],"wb");
    if(Out == NULL) {
        printf("%s: Unable to open file %s for writing\n",argv[0],argv[5]);
        free(buffer);
        return(2);
    }

    rc = dump(buffer,RegLen,Out,argv[6]);
    if(rc) {
        printf("%s: Unable to write file %s\n",argv[0],argv[5]);
    }

    fclose(Out);

    free(buffer);

    return(rc);
}


int
dump(
    char     *buffer,
    unsigned  buflen,
    FILE     *Out,
    char     *VarName
    )
{
    unsigned       major,minor;
    unsigned       i;
    unsigned char *bufptr = buffer;
    int            bw;
    char          *DefName;


    DefName = malloc(strlen(VarName) + 1 + 5);
    if(DefName == NULL) {
        return(2);
    }
    strcpy(DefName,VarName);
    _strupr(DefName);
    strcat(DefName,"_SIZE");

    bw = fprintf(Out,"#define %s %u\n\n\n",DefName,buflen);

    bw = fprintf(Out,"unsigned char %s[] = {\n",VarName);
    if(bw <= 0) {
        return(2);
    }

    major = buflen/16;
    minor = buflen%16;

    for(i=0; i<major; i++) {

        bw = fprintf(Out,
                    "%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u",
                     bufptr[ 0],
                     bufptr[ 1],
                     bufptr[ 2],
                     bufptr[ 3],
                     bufptr[ 4],
                     bufptr[ 5],
                     bufptr[ 6],
                     bufptr[ 7],
                     bufptr[ 8],
                     bufptr[ 9],
                     bufptr[10],
                     bufptr[11],
                     bufptr[12],
                     bufptr[13],
                     bufptr[14],
                     bufptr[15]
                    );

        if(bw <= 0) {
            return(2);
        }

        if((i == major-1) && !minor) {
            bw = fprintf(Out,"\n");
        } else {
            bw = fprintf(Out,",\n");
        }

        if(bw <= 0) {
            return(2);
        }

        bufptr += 16;
    }

    if(minor) {
        for(i=0; i<minor-1; i++) {
            bw = fprintf(Out,"%u,",*bufptr++);
            if(bw <= 0) {
                return(2);
            }
        }
        bw = fprintf(Out,"%u\n",*bufptr);
    }

    bw = fprintf(Out,"};\n");
    if(bw <= 0) {
        return(2);
    }
    return(0);
}

int
DumpAscii(
    LPSTR   FileNameIn,
    LPSTR   FileNameOut,
    LPSTR   VarName
    )
{
    HANDLE  hFileIn;
    HANDLE  hFileOut;
    HANDLE  hMapIn;
    HANDLE  hMapOut;
    LPVOID  DataIn;
    LPVOID  DataOut;
    LPSTR   din;
    LPSTR   dout;
    DWORD   FileSize;
    DWORD   Bytes;
    BOOL    LineBegin = TRUE;


    //
    // open the input file
    //

    hFileIn = CreateFile(
        FileNameIn,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFileIn == INVALID_HANDLE_VALUE) {
        return 1;
    }

    FileSize = GetFileSize( hFileIn, NULL );

    hMapIn = CreateFileMapping(
        hFileIn,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL
        );
    if (!hMapIn) {
        return 1;
    }

    DataIn = (LPSTR) MapViewOfFile(
        hMapIn,
        FILE_MAP_READ,
        0,
        0,
        0
        );
    if (!DataIn) {
        return 1;
    }

    //
    // open the output file
    //

    hFileOut = CreateFile(
        FileNameOut,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL
        );
    if (hFileOut == INVALID_HANDLE_VALUE) {
        return 1;
    }

    hMapOut = CreateFileMapping(
        hFileOut,
        NULL,
        PAGE_READWRITE,
        0,
        FileSize * 2,
        NULL
        );
    if (!hMapOut) {
        return 1;
    }

    DataOut = (LPSTR) MapViewOfFile(
        hMapOut,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!DataOut) {
        return 1;
    }

    din = DataIn;
    dout = DataOut;

    sprintf( dout, "char %s[] =\r\n", VarName );
    Bytes = strlen(dout);
    dout += Bytes;

    while( FileSize ) {
        if (LineBegin) {
            if (*din == ';') {
                while (*din != '\n') {
                    FileSize -= 1;
                    din += 1;
                }
                FileSize -= 1;
                din += 1;
                continue;
            }
            *dout++ = '\"';
            Bytes += 1;
            LineBegin = FALSE;
        }

        FileSize -= 1;

        if (*din == '\r') {
            din += 1;
            *dout++ = '\\';
            *dout++ = 'r';
            Bytes += 2;
            continue;
        }

        if (*din == '\n') {
            din += 1;
            *dout++ = '\\';
            *dout++ = 'n';
            *dout++ = '\"';
            *dout++ = '\r';
            *dout++ = '\n';
            Bytes += 5;
            LineBegin = TRUE;
            continue;
        }

        *dout++ = *din++;
        Bytes += 1;
    }

    *dout++ = ';';
    *dout++ = '\r';
    *dout++ = '\n';
    Bytes += 3;

    UnmapViewOfFile( DataIn );
    CloseHandle( hMapIn );
    CloseHandle( hFileIn );

    UnmapViewOfFile( DataOut );
    CloseHandle( hMapOut );
    SetFilePointer( hFileOut, Bytes, NULL, FILE_BEGIN );
    SetEndOfFile( hFileOut );
    CloseHandle( hFileOut );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bootstat\bootstat.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cdp.c

Abstract:

    A user mode app that allows simple commands to be sent to a
    selected scsi device.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <bootstatus.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#include <windows.h>

// #include "bootstatus.h"

#ifdef DBG
#define dbg(x) x
#define HELP_ME() printf("Reached line %4d\n", __LINE__);
#else
#define dbg(x)    /* x */
#define HELP_ME() /* printf("Reached line %4d\n", __LINE__); */
#endif

#define ARGUMENT_USED(x)    (x == NULL)


//
// The default size of the safemode.dat file - it must be large enough that the 
// data stream isn't a resident attribute of the metadata or the loader's 
// NTFS implementation can't write to it.
//

#define DEFAULT_SAFEMODE_FILE_SIZE  0x800

typedef struct {
    PCHAR Name;
    PCHAR Description;
    BOOLEAN LockData;
    ULONG (*Function)(HANDLE BootStatusData, int argc, char *argv[]);
} COMMAND;

DWORD TestCommand(HANDLE BootStatusData, int argc, char *argv[]);
DWORD Disable(HANDLE BootStatusData, int argc, char *argv[]);
DWORD Enable(HANDLE BootStatusData, int argc, char *argv[]);
DWORD Create(HANDLE BootStatusData, int argc, char *argv[]);
DWORD CreateEx(HANDLE BootStatusData, int argc, char *argv[]);
DWORD SetFlags(HANDLE BootStatusData, int argc, char *argv[]);
DWORD ClearFlags(HANDLE BootStatusData, int argc, char *argv[]);
DWORD ListSettings(HANDLE BootStatusData, int argc, char *argv[]);

DWORD ListCommand(int argc, char *argv[]);

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

COMMAND CommandArray[] = {
    {"create",  "Creates the boot status data file",     FALSE, Create},
    {"createex",  "Tests creation code",                 FALSE, CreateEx},
    {"disable", "Disables Auto Advanced Boot",           TRUE,  Disable},
    {"enable",  "Enables Auto Advanced Boot",            TRUE,  Enable},
    {"set",     "Sets the boot status flags",            TRUE,  SetFlags},
    {"settings","Lists the Auto Advanced Boot settings", TRUE,  ListSettings},
    {NULL, NULL, FALSE, NULL}
    };

int __cdecl main(int argc, char *argv[])
{
    int i = 0;
    HANDLE bootStatusData;
    BOOLEAN bsdLocked = FALSE;

    if(argc < 2) {
        printf("Usage: %s <command> [parameters]\n", argv[0]);
        printf("possible commands: \n");
        ListCommand(argc, argv);
        printf("\n");
        return -1;
    }

    //
    // Iterate through the command array and find the correct function to
    // call.
    //

    while(CommandArray[i].Name != NULL) {

        if(strcmp(argv[1], CommandArray[i].Name) == 0) {

            NTSTATUS status;

            if(CommandArray[i].LockData) {
                status = RtlLockBootStatusData(&bootStatusData);
    
                if(!NT_SUCCESS(status)) {
                    printf("Error %#08lx opening boot status bootStatusData\n", 
                           status);
                    return -1;
                }

                bsdLocked = TRUE;
            } else {
                bootStatusData = NULL;
            }

            (CommandArray[i].Function)(bootStatusData, (argc - 1), &(argv[1]));

            break;
        }

        i++;
    }

    if(CommandArray[i].Name == NULL) {
        printf("Unknown command %s\n", argv[1]);
    }

    if(bsdLocked) {
        RtlUnlockBootStatusData(bootStatusData);
    }
    return 0;
}



DWORD TestCommand(HANDLE BootStatusData, int argc, char *argv[])
/*++

Routine Description:

    Tests the command "parsing"

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{
    int i;

    UNREFERENCED_PARAMETER(BootStatusData);

    printf("Test - %d additional arguments\n", argc);

    for(i = 0; i < argc; i++) {
        printf("arg %d: %s\n", i, argv[i]);
    }

    return STATUS_SUCCESS;
}

DWORD ListCommand(int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i = 0;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    while(CommandArray[i].Name != NULL) {

        if(CommandArray[i].Description != NULL) {

            printf("\t%s - %s\n",
                   CommandArray[i].Name,
                   CommandArray[i].Description);
        }

        i++;
    }

    return STATUS_SUCCESS;
}

DWORD 
Create(
    HANDLE Unused, 
    int argc, 
    char *argv[]
    )
{
    BOOLEAN enabled;

    NTSTATUS status;

    status = RtlCreateBootStatusDataFile();

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx creating boot status data\n", status);
    }

    return status;
}

DWORD 
Enable(
    HANDLE BootStatusData, 
    int argc, 
    char *argv[]
    )
{
    BOOLEAN enabled;

    NTSTATUS status;

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemAabEnabled,
                                     &enabled,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("Enabling Automatic Advanced Boot\n");
    printf("Previous setting was %s\n", enabled ? "enabled" : "disabled");

    enabled = TRUE;

    status = RtlGetSetBootStatusData(BootStatusData,
                                     FALSE,
                                     RtlBsdItemAabEnabled,
                                     &enabled,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx writing boot status data\n", status);
    }

    return status;
}

DWORD 
Disable(
    HANDLE BootStatusData, 
    int argc, 
    char *argv[]
    )
{
    BOOLEAN enabled;

    NTSTATUS status;

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemAabEnabled,
                                     &enabled,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("Disabling Automatic Advanced Boot\n");
    printf("Previous setting was %s\n", enabled ? "enabled" : "disabled");

    enabled = FALSE;

    status = RtlGetSetBootStatusData(BootStatusData,
                                     FALSE,
                                     RtlBsdItemAabEnabled,
                                     &enabled,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx writing boot status data\n", status);
    }

    return status;
}

DWORD 
ListSettings(
    HANDLE BootStatusData, 
    int argc, 
    char *argv[]
    )
{
    BOOLEAN flag;

    NTSTATUS status;

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemAabEnabled,
                                     &flag,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("Automatic Advanced Boot is %s\n", flag ? "enabled" : "disabled");

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemAabTimeout,
                                     &flag,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("Automatic Advanced Boot timeout is %d seconds\n", (UCHAR) flag);

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemBootGood,
                                     &flag,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("LastBootSucceeded = %#x\n", flag);

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemBootShutdown,
                                     &flag,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("LastBootShutdown = %#x\n", flag);

    return STATUS_SUCCESS;
}

DWORD SetFlags(HANDLE BootStatusData, int argc, char *argv[])
{
    int count;

    if(argc <= 1) {
        printf("usage: autosafeboot set <Boot|Shutdown>=<value> ...");
        return 0;
    }

    for(count = 1; count < argc; count++) {
        PUCHAR nameString;
        PUCHAR valueString;

        ULONG index;
        UCHAR value;

        index = -1;

        //
        // match the string.
        //

        nameString = argv[count];
        valueString = strrchr(nameString, '=');

        if(valueString == NULL) {
            printf("** element \"%s\" not understood\n", nameString);
            continue;
        }

        valueString[0] = '\0';
        valueString += 1;

        value = (UCHAR) atoi(valueString);

        if(_stricmp(nameString, "boot") == 0) {
            printf("Setting LastBootSucceeded to %#x\n", value);
            index = RtlBsdItemBootGood;

        } else if(_stricmp(nameString, "shutdown") == 0) {

            printf("Setting LastBootShutdown to %#x\n", value);
            index = RtlBsdItemBootShutdown;
        }

        if(index != -1) {

            NTSTATUS status;

            status = RtlGetSetBootStatusData(BootStatusData,
                                             FALSE,
                                             index,
                                             &value,
                                             sizeof(UCHAR),
                                             NULL);

            if(!NT_SUCCESS(status)) {
                printf("Error %#08lx reading boot status data\n", status);
                continue;
            }
        } else {
            printf("** element \"%s=%s\" not understood\n", nameString, valueString);
        }
    }

    return 0;
}

NTSTATUS
MyCreateBootStatusDataFile(
    PUCHAR DataFileName
    )
{
    OBJECT_ATTRIBUTES objectAttributes;

    WCHAR fileNameBuffer[MAXIMUM_FILENAME_LENGTH+1];
    ANSI_STRING ansiFileName;
    UNICODE_STRING fileName;

    HANDLE dataFileHandle;

    IO_STATUS_BLOCK ioStatusBlock;

    LARGE_INTEGER t;
    UCHAR zero = 0;

    BSD_BOOT_STATUS_DATA defaultValues;

    NTSTATUS status;

    RtlZeroMemory(fileNameBuffer, sizeof(fileNameBuffer));

    RtlInitAnsiString(&ansiFileName, DataFileName);

    fileName.Length = 0;
    fileName.MaximumLength = sizeof(fileNameBuffer);
    fileName.Buffer = fileNameBuffer;


    RtlAnsiStringToUnicodeString(&fileName, &ansiFileName, FALSE);

    InitializeObjectAttributes(&objectAttributes,
                               &fileName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // The file must be large enough that it doesn't reside in the MFT entry 
    // or the loader won't be able to write to it.
    // 

    t.QuadPart = 2048;

    //
    // Create the file.
    //

    status = NtCreateFile(&dataFileHandle,
                          FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                          &objectAttributes,
                          &(ioStatusBlock),
                          &t,
                          FILE_ATTRIBUTE_SYSTEM,
                          0,
                          FILE_CREATE,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    ASSERT(status != STATUS_PENDING);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Write a single zero byte to the 0x7ffth byte in the file to make
    // sure that 2k are actually allocated.  This is to ensure that the 
    // file will not become attribute resident even after a conversion
    // from FAT to NTFS.
    //

    t.QuadPart = t.QuadPart - 1;
    status = NtWriteFile(dataFileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         &zero,
                         1,
                         &t,
                         NULL);

    ASSERT(status != STATUS_PENDING);

    if(!NT_SUCCESS(status)) {
        goto CreateDone;
    }

    //
    // Now write out the default values to the beginning of the file.
    //

    defaultValues.Version = sizeof(BSD_BOOT_STATUS_DATA);
    RtlGetNtProductType(&(defaultValues.ProductType));
    defaultValues.AutoAdvancedBoot = FALSE;
    defaultValues.AdvancedBootMenuTimeout = 30;
    defaultValues.LastBootSucceeded = TRUE;
    defaultValues.LastBootShutdown = FALSE;

    t.QuadPart = 0;

    status = NtWriteFile(dataFileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         &defaultValues,
                         sizeof(BSD_BOOT_STATUS_DATA),
                         &t,
                         NULL);

    ASSERT(status != STATUS_PENDING);

    if(!NT_SUCCESS(status)) {

        //
        // The data file was created and we can assume the contents were zeroed
        // even if we couldn't write out the defaults.  Since this wouldn't 
        // enable auto-advanced boot we'll leave the data file in place with 
        // its zeroed contents.
        //

    }

CreateDone:

    NtClose(dataFileHandle);

    return status;
}

DWORD 
CreateEx(
    HANDLE Unused, 
    int argc, 
    char *argv[]
    )
{
    BOOLEAN enabled;

    NTSTATUS status;

    if(argc < 2) {

        printf("Error - must supply file name\n");
        return -1;
    }

    printf("Will Create file %s\n", argv[1]);

    status = MyCreateBootStatusDataFile(argv[1]);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx creating boot status data\n", status);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\avrf\avrf.cxx ===
//
// Application verifier manager (command line version)
// Copyright (c) Microsoft Corporation, 2001
//

//
// module: avrf.cxx
// author: silviuc
// created: 02/14/2001
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <common.ver>

LPTSTR HelpText =
    TEXT("avrf - Base application verifier settings --") BUILD_MACHINE_TAG TEXT("\n")
    VER_LEGALCOPYRIGHT_STR TEXT("\n") 
    TEXT("                                                                       \n")
    TEXT("NOTE. In order to access all application verifier features please use  \n")
    TEXT("`appverif.exe'. The tool can be downloaded from `http://appverifier'.  \n")
    TEXT("                                                                       \n")
    TEXT("avrf [OPTION ...]                                                      \n")
    TEXT("                                                                       \n")
    TEXT("    /enable PROGRAM     Enable verifier with default settings.         \n")
    TEXT("    /disable PROGRAM    Disable verifier.                              \n")
    TEXT("                                                                       \n")
    TEXT("    /pageheap           Enable full page heap (default).               \n")
    TEXT("    /lightheap          Enable light page heap.                        \n")
    TEXT("    /locks              Enable critical section verifier (default).    \n")
    TEXT("    /nolocks            Disable critical section verifier.             \n")
    TEXT("    /handles            Enable handle checking and tracking (default). \n")
    TEXT("    /nohandles          Disable handle checking.                       \n")
    TEXT("    /stacks             Stack overflow in low memory conditions checks.\n")
    TEXT("    /nostacks           Disable stack overflow checks (default).       \n")
    TEXT("    /tls                Check thread local storage calls (default).    \n")
    TEXT("    /notls              Do not check thread local storage calls.       \n")
    TEXT("    /rpc                Enable RPC verifier.                           \n")
    TEXT("    /norpc              Disable RPC verifier (default).                \n")
    TEXT("    /locals             Check for uninitialized local variables.       \n")
    TEXT("    /nolocals           Do not check for uninitialized locals (default).\n")
    TEXT("    /com                Enable COM verifier.                           \n")
    TEXT("    /nocom              Disable COM verifier (default).                \n")
    TEXT("    /deadlock           Enable deadlock verifier.                      \n")
    TEXT("    /nodeadlock         Disable deadlock verifier (default).           \n")
    TEXT("    /race               Enable race checks (random delays).            \n")
    TEXT("    /norace             Disable race checks (default).                 \n")
    TEXT("    /badapis            Detect calls to dangerous APIs (default).      \n")
    TEXT("    /nobadapis          Do not detect calls to dangerous APIs.         \n")
    TEXT("    /vmem               Check virtual memory calls (default).          \n")
    TEXT("    /novmem             Do not check virtual memory calls.             \n")
    TEXT("                                                                       \n")
    TEXT("    The following checks marked by (*) are experimental and should     \n")
    TEXT("    not be used on a large scale in labs. They are supported though    \n")
    TEXT("    and you will get assistance from `avrf' alias' for debugging.      \n")
    TEXT("                                                                       \n")
    TEXT("    /misc           (*) Miscellaneous checks (e.g. wrap tick count).   \n")
    TEXT("    /nomisc         (*) No miscellaneous checks (default).             \n")
    TEXT("    /log            (*) Log issues in a file instead of debugger.      \n")
    TEXT("    /nolog          (*) Do not log in a file (default).                \n")
    TEXT("    /fastheap       (*) Enable fast fill debug heap.                   \n")
    TEXT("    /nofastheap     (*) No fast fill heap (default).                   \n")
    TEXT("                                                                       \n")
    TEXT("    /debug              Launch under debugger `ntsd -g -G -x'.         \n")
    TEXT("    /kdebug             Launch under debugger `ntsd -g -G -d -x'.      \n")
    TEXT("                                                                       \n")
    TEXT("    /verifier DLL ...   Specify additional verifier providers. Verifier providers \n")
    TEXT("                        are special DLLs which extend verifier functionality. \n")
    TEXT("                        This option cannot be used to verify only one DLL in a process. \n")
    TEXT("                                                                       \n")
    TEXT("                                                                       \n")
    TEXT("PROGRAM     Name of the binary with extension (.exe or something else).\n")
    TEXT("DLL         Name of the binary with extension (.dll or something else).\n")
    TEXT("                                                                       \n")
    TEXT("If no option specified the program will print all verifier enabled     \n")
    TEXT("applications and their specific options.                               \n")
    TEXT("                                                                       \n")
    TEXT("The /verifier option is useful whenever additional verification layers \n")
    TEXT("must run on top of the core verification layer. The dlls specified     \n")
    TEXT("must obey the format for a verifier provider dll.                      \n")
    TEXT("                                                                       \n")
    TEXT("The /badapis option detects calls to interfaces like TerminateThread.  \n")
    TEXT("                                                                       \n")
    TEXT("Note. Enabling application verifier does not affect currently running  \n")
    TEXT("processes. If you need to use verifier for processes that are          \n")
    TEXT("already running and cannot be restarted (csrss.exe, winlogon.exe),     \n")
    TEXT("a reboot is needed after the verifier has been enabled for             \n")
    TEXT("that process.                                                          \n")
    TEXT("                                                                       \n");

VOID
Help (
    )
{
    _fputts (HelpText, stdout);
    exit(1);
}

VOID
PrintFlags (
    DWORD Flags
    )
{
    if ((Flags & RTL_VRF_FLG_FULL_PAGE_HEAP)) {
        printf("pageheap ");
    }
    else {
        printf("lightheap ");
    }

    if ((Flags & RTL_VRF_FLG_LOCK_CHECKS)) {
        printf("locks ");
    }
    
    if ((Flags & RTL_VRF_FLG_HANDLE_CHECKS)) {
        printf("handles ");
    }
    
    if ((Flags & RTL_VRF_FLG_STACK_CHECKS)) {
        printf("stacks ");
    }

    if ((Flags & RTL_VRF_FLG_TLS_CHECKS)) {
        printf("tls ");
    }
    
    if ((Flags & RTL_VRF_FLG_RPC_CHECKS)) {
        printf("rpc ");
    }
    
    if ((Flags & RTL_VRF_FLG_COM_CHECKS)) {
        printf("com ");
    }
    
    if ((Flags & RTL_VRF_FLG_RACE_CHECKS)) {
        printf("race ");
    }
    
    if ((Flags & RTL_VRF_FLG_DEADLOCK_CHECKS)) {
        printf("deadlock ");
    }
    
    if ((Flags & RTL_VRF_FLG_DANGEROUS_APIS)) {
        printf("badapis ");
    }
    
    if ((Flags & RTL_VRF_FLG_DIRTY_STACKS)) {
        printf("uninit_locals ");
    }

    if ((Flags & RTL_VRF_FLG_VIRTUAL_MEM_CHECKS)) {
        printf("vmem ");
    }

    if ((Flags & RTL_VRF_FLG_ENABLE_LOGGING)) {
        printf("log ");
    }

    if ((Flags & RTL_VRF_FLG_FAST_FILL_HEAP)) {
        printf("fastheap ");
    }

    if ((Flags & RTL_VRF_FLG_MISCELLANEOUS_CHECKS)) {
        printf("misc ");
    }
}

BOOL
EnableVerifier (
    LPCTSTR Name,
    LPTSTR DebugString,
    char * * Args);

BOOL
DisableVerifier (
    LPCTSTR Name);

BOOL
IsVerifierEnabled (
    LPCTSTR Name);

BOOL
IsVerifierFlagsValueDefined (
    LPCTSTR Name,
    PDWORD Value);

BOOL
ReadGlobalFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
WriteGlobalFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
ReadVerifierValue (
    HKEY Key,
    LPTSTR Name,
    PDWORD Value
    );

BOOL
WriteVerifierValue (
    HKEY Key,
    LPTSTR Name,
    DWORD Value
    );

BOOL
DeleteVerifierFlagValue (
    HKEY Key);

BOOL
WriteDebuggerValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
DeleteDebuggerValue (
    HKEY Key);

HKEY
OpenImageKey (
    LPCTSTR Name,
    BOOL ShouldExist);

VOID
CloseImageKey (
    HKEY Key);

VOID
CreateImageName (
    LPCTSTR Source,
    LPTSTR Name,
    ULONG Length);

VOID
PrintVerifierEnabledApplications (
    );

VOID
Help (
    );

VOID
__cdecl
Error (
    LPCTSTR Format,
    ...);

BOOL 
IsWow64Active (
    );

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

char * * 
SearchOption (
    char * Args[],
    char * Option
    )
{
    while (*Args) {
        if (_stricmp(*Args, Option) == 0) {
            return Args;
        }

        Args++;
    }

    return NULL;
}


void _cdecl
main (int argc, char *argv[])
{
    TCHAR ImageName [MAX_PATH];
    char * * Option;

    if (IsWow64Active()) {
        _tprintf (TEXT ("Warning: avrf.exe is running inside WOW64. \n"
                        "This scenario can be used to test x86 binaries (running inside WOW64) \n"
                        "but not native (IA64) binaries. \n\n"));
    }
    
    if (argc == 2 && strstr (argv[1], TEXT("?")) != NULL) {

        Help ();
    }
    else if ((Option = SearchOption(argv + 1, "/enable"))) {

        PCHAR DebugString = NULL;

        if (SearchOption (argv + 1, "/debug") != NULL) {
            DebugString = "ntsd -g -G -x";
        }

        if (SearchOption (argv + 1, "/kdebug") != NULL) {
            DebugString = "ntsd -g -G -d -x";
        }

        if (Option[1] && Option[1][0] != '/') {
            CreateImageName (Option[1], ImageName, MAX_PATH);
            EnableVerifier (ImageName, DebugString, argv);
        }
        else {
            Help();
        }
    }
    else if ((Option = SearchOption(argv + 1, "/disable"))) {
        
        if (Option[1]) {
            CreateImageName (Option[1], ImageName, MAX_PATH);
            DisableVerifier (ImageName);
        }
        else {
            Help();
        }
    }
    else if (argc == 2) {

        CreateImageName (argv[1], ImageName, MAX_PATH);
        if (IsVerifierEnabled (ImageName) == FALSE) {
            _tprintf (TEXT("%s: verifier is not enabled for this application \n"), argv[1]);
        }
        else {

            DWORD Value;

            if (IsVerifierFlagsValueDefined (ImageName, &Value)) {
                
                _tprintf (TEXT("%s: verifier enabled with flags ("), argv[1]);
                PrintFlags (Value);
                _tprintf (TEXT(")\n"));
            }
            else {

                _tprintf (TEXT("%s: verifier enabled with default flags  \n"), argv[1]);
            }
        }
    }
    else {

        PrintVerifierEnabledApplications ();
    }
}


VOID
__cdecl
Error (

    LPCTSTR Format,
    ...)
{
    va_list Params;

    va_start (Params, Format);
    _tprintf (TEXT("Error: "));
    _vtprintf (Format, Params);
    _tprintf ( TEXT("\n "));
    exit (1);
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

BOOL
IsVerifierEnabled (

    LPCTSTR Name)
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;
    BOOL Success;

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        return FALSE;
    }

    Success = ReadGlobalFlagValue (Key, Buffer, sizeof Buffer);

    CloseImageKey (Key);

    if (Success == FALSE) {

        return FALSE;
    }

    if (_stscanf (Buffer, TEXT("%x"), &Flags) == 0) {

        return FALSE;
    }

    return (Flags & FLG_APPLICATION_VERIFIER) ? TRUE : FALSE;
}


BOOL
IsVerifierFlagsValueDefined (
    LPCTSTR Name,
    PDWORD Value)
{
    HKEY Key;
    DWORD VerifierFlags = 0;

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        return FALSE;
    }

    if (ReadVerifierValue (Key, TEXT("VerifierFlags"), &VerifierFlags) == FALSE) {

        CloseImageKey (Key);
        return FALSE;
    }

    CloseImageKey (Key);

    *Value = VerifierFlags;
    return TRUE;
}


BOOL
EnableVerifier (
    LPCTSTR Name,
    LPTSTR DebugString,
    char * * Args
    )
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;
    DWORD VerifierFlags;
    char * * Option;
    LONG Result;
    int Scanned;

    if ((Key = OpenImageKey (Name, FALSE)) == NULL) {

        Error (TEXT("Cannot open image registry key for %s"), Name);
    }

    if (ReadGlobalFlagValue (Key, Buffer, sizeof Buffer) == FALSE) {

        Flags = 0;
    }
    else {

        Scanned = _stscanf (Buffer, TEXT("%x"), &Flags);

        if (Scanned != 1) {
            Error (TEXT("Cannot convert to a number the globals flags value %s \n"), Buffer);
        }
    }

    Flags |= FLG_APPLICATION_VERIFIER;
    _stprintf (Buffer, TEXT("0x%08X"), Flags);

    if (WriteGlobalFlagValue (Key, Buffer, _tcslen(Buffer)) == FALSE) {

        return FALSE;
    }

    //
    // Write `Debugger' value if needed.
    //

    if (DebugString != NULL) {

        if (WriteDebuggerValue (Key, DebugString, _tcslen(DebugString)) == FALSE) {

            return FALSE;
        }
    }

    //
    // Fill out default verifier settings.
    //

    VerifierFlags = RTL_VRF_FLG_FULL_PAGE_HEAP 
                    | RTL_VRF_FLG_LOCK_CHECKS
                    | RTL_VRF_FLG_HANDLE_CHECKS
                    | RTL_VRF_FLG_TLS_CHECKS
                    | RTL_VRF_FLG_DANGEROUS_APIS
                    | RTL_VRF_FLG_VIRTUAL_MEM_CHECKS;
    //
    // Check for explicit feature requests.
    //

    if ((Option = SearchOption (Args, "/pageheap")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_FULL_PAGE_HEAP;
    }

    if ((Option = SearchOption (Args, "/lightheap")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_FULL_PAGE_HEAP;
    }

    if ((Option = SearchOption (Args, "/locks")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_LOCK_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/nolocks")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_LOCK_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/handles")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_HANDLE_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/nohandles")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_HANDLE_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/stacks")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_STACK_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/nostacks")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_STACK_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/tls")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_TLS_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/notls")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_TLS_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/rpc")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_RPC_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/norpc")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_RPC_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/com")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_COM_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/nocom")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_COM_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/deadlock")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_DEADLOCK_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/nodeadlock")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_DEADLOCK_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/race")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_RACE_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/norace")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_RACE_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/badapis")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_DANGEROUS_APIS;
    }
    
    if ((Option = SearchOption (Args, "/nobadapis")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_DANGEROUS_APIS;
    }
    
    if ((Option = SearchOption (Args, "/locals")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_DIRTY_STACKS;
    }
    
    if ((Option = SearchOption (Args, "/nolocals")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_DIRTY_STACKS;
    }
    
    if ((Option = SearchOption (Args, "/vmem")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_VIRTUAL_MEM_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/novmem")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_VIRTUAL_MEM_CHECKS;
    }

    if ((Option = SearchOption (Args, "/log")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_ENABLE_LOGGING;
    }
    
    if ((Option = SearchOption (Args, "/nolog")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_ENABLE_LOGGING;
    }

    if ((Option = SearchOption (Args, "/fastheap")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_FAST_FILL_HEAP;
    }
    
    if ((Option = SearchOption (Args, "/nofastheap")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_FAST_FILL_HEAP;
    }

    if ((Option = SearchOption (Args, "/misc")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_MISCELLANEOUS_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/nomisc")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_MISCELLANEOUS_CHECKS;
    }

    if ((Option = SearchOption (Args, "/_debug")) != NULL) {
        
        DWORD DebugFlags = 0;

        if (Option[1] && Option[1][0] != '/') {
            
            printf("Setting _debug to %s \n", Option[1]);

            if (_stscanf (Option[1], TEXT("%x"), &DebugFlags) == 0) {
                Error (TEXT("Failed to set internal debug flags."));
            }

            if (WriteVerifierValue (Key, TEXT("VerifierDebug"), DebugFlags) == FALSE) {
                Error (TEXT("Failed to write verifier internal debug registry value."));
            }
        }
    }
    
    //
    // Check /dlls option
    //

    Option = SearchOption (Args, "/verifier");

    if (Option != NULL) {

        TCHAR Dlls[512];
        ULONG Index;

        if (Option[1]) {

            for (Index = 1, Dlls[0] = '\0';
                Option[Index] && Option[Index][0] != '/';
                Index++) {

                _tcscat (Dlls, Option[Index]);
                _tcscat (Dlls, " ");

                //
                // We do not allow more than 200 characters because the verifier
                // support in loader (\nt\base\ntdll\verifier.c) does not handle
                // more characters anyway.
                //

                if (_tcslen (Dlls) > 200) {
                    break;
                }
            }

            //
            // SilviuC: the call to _tcslen below is not correct if we
            // ever will want to make this program Unicode.
            //

            Result = RegSetValueEx (
                Key, TEXT ("VerifierDlls"), 0, REG_SZ,
                (LPBYTE)(Dlls), _tcslen(Dlls) + 1);

            if (Result) {
                Error (TEXT("Failed to write VerifierDlls value: error %u"), Result);
            }
        }
    }

    //
    // Finally write the verifier flags value.
    //

    if (WriteVerifierValue (Key, TEXT("VerifierFlags"), VerifierFlags) == FALSE) {

        Error (TEXT("Failed to write VerifierFlags value."));
        return FALSE;
    }

    CloseImageKey (Key);
    return TRUE;
}

BOOL
DisableVerifier (

    LPCTSTR Name)
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        //
        // There is no key therefore nothing to disable.
        //

        return TRUE;
    }

    if (ReadGlobalFlagValue (Key, Buffer, sizeof Buffer) == FALSE) {

        Flags = 0;
    }
    else {

        if (_stscanf (Buffer, TEXT("%x"), &Flags) == 0) {

            Flags = 0;;
        }
    }

    Flags &= ~FLG_APPLICATION_VERIFIER;
    _stprintf (Buffer, TEXT("0x%08X"), Flags);

    //
    // If by wiping the verifier bit from `GlobalFlags' we get a zero
    // value we will wipe out the value altogether. This is important
    // when we run the app under debugger. In this case it makes a 
    // difference if the value is not there or is all zeroes.
    //

    if (Flags != 0) {
        
        if (WriteGlobalFlagValue (Key, Buffer, _tcslen(Buffer)) == FALSE) {

            return FALSE;
        }
    }
    else {

        RegDeleteValue (Key, TEXT ("GlobalFlag"));
    }

    RegDeleteValue (Key, TEXT ("VerifierFlags"));
    RegDeleteValue (Key, TEXT ("VerifierDebug"));
    RegDeleteValue (Key, TEXT ("VerifierDlls"));
    RegDeleteValue (Key, TEXT ("Debugger"));

    CloseImageKey (Key);
    return TRUE;
}


BOOL
ReadGlobalFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;
    DWORD Type;
    DWORD ReadLength = Length;

    Result = RegQueryValueEx (

        Key,
        TEXT ("GlobalFlag"),
        0,
        &Type,
        (LPBYTE)Buffer,
        &ReadLength);

    if (Result != ERROR_SUCCESS || Type != REG_SZ) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
WriteGlobalFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;

    Result = RegSetValueEx (

        Key,
        TEXT ("GlobalFlag"),
        0,
        REG_SZ,
        (LPBYTE)Buffer,
        Length);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
ReadVerifierValue (
    HKEY Key,
    LPTSTR Name,
    PDWORD Value
    )
{
    LONG Result;
    DWORD Type;
    DWORD ReadLength = sizeof *Value;

    Result = RegQueryValueEx (Key,
                              Name,
                              0,
                              &Type,
                              (LPBYTE)Value,
                              &ReadLength);

    if (Result != ERROR_SUCCESS || Type != REG_DWORD) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
WriteVerifierValue (
    HKEY Key,
    LPTSTR Name,
    DWORD Value
    )
{
    LONG Result;

    Result = RegSetValueEx (Key,
                            Name,
                            0,
                            REG_DWORD,
                            (LPBYTE)(&Value),
                            sizeof Value);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
WriteDebuggerValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;

    Result = RegSetValueEx (

        Key,
        TEXT ("Debugger"),
        0,
        REG_SZ,
        (LPBYTE)Buffer,
        Length);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}


BOOL
IsShutdownFlagsValueDefined (
    LPCTSTR KeyName
    )
{
    HKEY Key;
    LONG Result;
    DWORD Value;
    DWORD Type;
    DWORD ReadLength = sizeof (DWORD);

    if ((Key = OpenImageKey (KeyName, TRUE)) == NULL) {
        return FALSE;
    }
    
    Result = RegQueryValueEx (
        Key,
        TEXT ("ShutdownFlags"),
        0,
        &Type,
        (LPBYTE)(&Value),
        &ReadLength);

    CloseImageKey (Key);

    if (Result == ERROR_SUCCESS && (Value & 0x03) == 0x03) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

HKEY
OpenImageKey (

    LPCTSTR Name,
    BOOL ShouldExist)
{
    HKEY Key;
    LONG Result;
    TCHAR Buffer [2 * MAX_PATH];

    _stprintf (
        Buffer,
        TEXT ("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s"),
        Name);

    if (ShouldExist) {

        Result = RegOpenKeyEx (

            HKEY_LOCAL_MACHINE,
            Buffer,
            0,
            KEY_ALL_ACCESS,
            &Key);
    }
    else {

        Result = RegCreateKeyEx (

            HKEY_LOCAL_MACHINE,
            Buffer,
            0,
            0,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &Key,
            NULL);
    }

    if (Result != ERROR_SUCCESS) {

        return NULL;
    }
    else {

        return Key;
    }

}


VOID
CloseImageKey (

    HKEY Key)
{
    RegCloseKey (Key);
}


VOID
CreateImageName (

    LPCTSTR Source,
    LPTSTR Name,
    ULONG Length)
{
    SIZE_T ExtraSpace;

    ExtraSpace = 1 + _tcslen (TEXT(".exe"));

    if (Length <= ExtraSpace) {
        return;
    }

    RtlZeroMemory (Name, Length);
    _tcsncpy (Name, Source, Length - ExtraSpace);
    Name[Length - 1] = 0;

    _tcslwr (Name);

    if (_tcsstr (Name, TEXT(".")) == 0) {

        _tcscat (Name, TEXT(".exe"));
    }
}


VOID
PrintVerifierEnabledApplications (

    )
{
    LPCTSTR ImageFileExecutionOptionsKeyName =
        TEXT ("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options");

    HKEY OptionsKey;
    LONG Result;
    TCHAR KeyName [MAX_PATH];
    ULONG KeySize;
    BOOL FoundOne = FALSE;
    ULONG Index;
    FILETIME FileTime;

    Result = RegOpenKeyEx (

        HKEY_LOCAL_MACHINE,
        ImageFileExecutionOptionsKeyName,
        0,
        KEY_ALL_ACCESS,
        &OptionsKey);

    if (Result != ERROR_SUCCESS) {

        Error (TEXT("Cannot open registry key %s: error %u"),
               ImageFileExecutionOptionsKeyName,
               Result);
    }

    for (Index = 0; TRUE; Index++) {

        KeySize = MAX_PATH;

        Result = RegEnumKeyEx (

            OptionsKey,
            Index,
            KeyName,
            &KeySize,
            NULL,
            NULL,
            NULL,
            &FileTime);

        if (Result == ERROR_NO_MORE_ITEMS) {

            break;
        }

        if (Result != ERROR_SUCCESS) {

            Error (TEXT("Cannot enumerate registry key %s: error %u"),
               ImageFileExecutionOptionsKeyName,
               Result);
        }

        if (IsVerifierEnabled (KeyName)) {

            DWORD Value;

            FoundOne = TRUE;
            
            if (IsVerifierFlagsValueDefined (KeyName, &Value)) {
                _tprintf (TEXT("%s: verifier enabled with flags ("), KeyName);
                PrintFlags (Value);
                _tprintf (TEXT(")\n"));
            }
            else {
                _tprintf (TEXT("%s: verifier enabled with default flags \n"), KeyName);
            }
        }
    }

    if (FoundOne == FALSE) {

        _tprintf (TEXT("No application has verifier enabled.\n"));
    }
}


BOOL 
IsWow64Active (
    )                 
{

    ULONG_PTR       ul;
    NTSTATUS        st;

    //
    // If this call succeeds then we are on Windows 2000 or later.
    //

    st = NtQueryInformationProcess(NtCurrentProcess(), 
                                   ProcessWow64Information,
                                   &ul, 
                                   sizeof(ul), 
                                   NULL);

    if (NT_SUCCESS(st) && (0 != ul)) {
        // 32-bit code running on Win64
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\bugcheck.c ===
#include <ntddk.h>

#include "tdriver.h"
#include "bugcheck.h"


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////// Bugcheck functions
/////////////////////////////////////////////////////////////////////

VOID
BgChkForceCustomBugcheck (
    PVOID NotUsed
    )
/*++

Routine Description:

    This function breaks into debugger and waits for the user to set the
    value for bugcheck data. Then it will bugcheck using the specified code
    and data. It is useful to test the mini triage feature.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    ULONG BugcheckData [5];

    DbgPrint ("Buggy: `ed %p' to enter the bugcheck code and data \n", BugcheckData );
    DbgBreakPoint();

    KeBugCheckEx (
        BugcheckData [ 0 ],
        BugcheckData [ 1 ],
        BugcheckData [ 2 ],
        BugcheckData [ 3 ],
        BugcheckData [ 4 ] );
}


VOID BgChkProcessHasLockedPages (
    PVOID NotUsed
    )
{
    PMDL Mdl;
    PVOID Address;

    DbgPrint ("Buggy: ProcessHasLockedPages \n");

    Mdl = IoAllocateMdl(

        (PVOID)0x10000,    // adress
        0x1000,            // size
        FALSE,             // not secondary buffer
        FALSE,             // do not charge quota
        NULL);             // no irp

    if (Mdl != NULL) {
        DbgPrint ("Buggy: mdl created \n");
    }
#if 0
    try {

        MmProbeAndLockPages (
            Mdl,
            KernelMode,
            IoReadAccess);

        DbgPrint ("Buggy: locked pages \n");
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        DbgPrint ("Buggy: exception raised while locking \n");
    }
#endif
}


VOID BgChkNoMoreSystemPtes (
    PVOID NotUsed
    )
{
    DWORDLONG Index;
    PHYSICAL_ADDRESS Address;
    ULONG Count = 0;
    char Buffer [1024];

    DbgPrint ("Buggy: NoMoresystemPtes\n");

    for (Index = 0; Index < (DWORDLONG)0x80000000 * 4; Index += 0x10000) {
        Address.QuadPart = (DWORDLONG)Index;
        if (MmMapIoSpace (Address, 0x10000, FALSE)) {
            Count += 0x10000;
        }
    }

    DbgPrint ("Finished eating system PTEs %08X ... \n", Count);
}


VOID BgChkBadPoolHeader (
    PVOID NotUsed
    )
{
    PULONG Block;

    DbgPrint ("Buggy: BadPoolHeader\n");

    Block = (PULONG) ExAllocatePoolWithTag (
        NonPagedPool,
        128,
        TD_POOL_TAG);

    //
    // Trash 4 bytes in the block header.
    //

    *(Block - 1) = 0xBADBAD01;

    //
    // This free operation should bugcheck.
    //

    ExFreePool (Block);
}


VOID BgChkDriverCorruptedSystemPtes (
    PVOID NotUsed
    )
{
    PVOID Block;

    DbgPrint ("Buggy: DriverCorruptedSystemPtes\n");

    Block = (PULONG) ExAllocatePoolWithTag (
        NonPagedPool,
        0x2000,
        TD_POOL_TAG);

    MmUnmapIoSpace (Block, 0x2000);

}


VOID BgChkDriverCorruptedExPool (
    PVOID NotUsed
    )
{
    PULONG Block;

    DbgPrint ("Buggy: DriverCorruptedExPool\n");

    Block = (PULONG) ExAllocatePoolWithTag (
        NonPagedPool,
        128,
        TD_POOL_TAG);

    //
    // Trash 8 bytes in the block header.
    //

    *(Block - 2) = 0xBADBAD01;
    *(Block - 1) = 0xBADBAD01;

    //
    // This free operation should bugcheck.
    //

    ExFreePool (Block);
}


VOID BgChkDriverCorruptedMmPool (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: DriverCorruptedMmPool\n");

    ExFreePool (NULL);
}


VOID BgChkIrqlNotLessOrEqual (
    PVOID NotUsed
    )
{
    KIRQL irql;
    VOID *pPagedData;

    DbgPrint ("Buggy: IrqlNotLessOrEqual\n");

    pPagedData = ExAllocatePoolWithTag(
        PagedPool,
        16,
        TD_POOL_TAG);

    if( pPagedData == NULL )
    {
        DbgPrint( "Cannot allocate 16 bytes of paged pool\n" );
        return;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &irql );

    *((ULONG*)pPagedData) = 16;

    KeLowerIrql( irql );
}


VOID BgChkPageFaultBeyondEndOfAllocation (
    PVOID NotUsed
    )
{
    PVOID *pHalfPage;
    PVOID *pLastUlongToWrite;
    ULONG *pCrtULONG;

    DbgPrint ("Buggy: PageFaultBeyondEndOfAllocation\n");

    //
    // allocate half a page
    //

    pHalfPage = ExAllocatePoolWithTag(
        NonPagedPool,
        PAGE_SIZE >> 1,
        TD_POOL_TAG);

    if( pHalfPage == NULL )
    {
        DbgPrint ("Buggy: cannot allocate half page of NP pool\n");
    }
    else
    {
        //
        // touch a page more
        //

        pCrtULONG = (ULONG*)pHalfPage;

        while( (ULONG_PTR)pCrtULONG < (ULONG_PTR)pHalfPage + (PAGE_SIZE >> 1) + 2 * PAGE_SIZE )
        {
            *pCrtULONG = PtrToUlong( pCrtULONG );
            pCrtULONG ++;
        }

        ExFreePool( pHalfPage );
    }
}


VOID BgChkDriverVerifierDetectedViolation (
    PVOID NotUsed
    )
{
    PVOID *pHalfPage;
    PVOID *pLastUlongToWrite;
    ULONG *pCrtULONG;

    DbgPrint ("Buggy: DriverVerifierDetectedViolation\n");

    //
    // allocate half a page
    //

    pHalfPage = ExAllocatePoolWithTag(
        NonPagedPool,
        PAGE_SIZE >> 1,
        TD_POOL_TAG);

    if( pHalfPage == NULL )
    {
        DbgPrint ("Buggy: cannot allocate half page of NP pool\n");
    }
    else
    {
        //
        // touch 1 ULONG more
        //

        pCrtULONG = (ULONG*)pHalfPage;

        while( (ULONG_PTR)pCrtULONG < (ULONG_PTR)pHalfPage + (PAGE_SIZE >> 1) + sizeof( ULONG) )
        {
            *pCrtULONG = PtrToUlong( pCrtULONG );
            pCrtULONG ++;
        }

        //
        // free -> BC
        //

        ExFreePool( pHalfPage );
    }
}


VOID
BgChkCorruptSystemPtes(
    PVOID NotUsed
    )
/*++

Routine Description:

    This function corrupts system PTEs area on purpose. This is
    done so that we can test if the crache is mini triaged correctly.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    PULONG puCrtAdress = (PULONG)LongToPtr(0xC0300000);
    ULONG uCrtValue;
    int nCrtStep;

#define NUM_ULONGS_TO_CORRUPT       0x100
#define FIRST_ULONG_VALUE           0xABCDDCBA
#define NUM_ULONGS_SKIP_EACH_STEP   16


    uCrtValue = FIRST_ULONG_VALUE;

    for( nCrtStep = 0; nCrtStep < NUM_ULONGS_TO_CORRUPT; nCrtStep++ )
    {
        *puCrtAdress = uCrtValue;

        puCrtAdress += NUM_ULONGS_SKIP_EACH_STEP;

        uCrtValue++;
    }
}


VOID
BgChkHangCurrentProcessor (
    PVOID NotUsed
    )
/*++

Routine Description:

    This routine will hang the current processor.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    KIRQL PreviousIrql;

    KeRaiseIrql( DISPATCH_LEVEL, &PreviousIrql );

    while ( TRUE ) {
        //
        // this will hang the current processor
        //
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\active.h ===
#ifndef _ACTIVE_H_INCLUDED_
#define _ACTIVE_H_INCLUDED_

#define CONTMEM_ACTIVE    0
#define SECTMAP_ACTIVE    0
#define TRACEDB_ACTIVE    0
#define PHYSMEM_ACTIVE    0
#define MMTESTS_ACTIVE    1
#define MAPVIEW_ACTIVE    1
#define LOCKTEST_ACTIVE   1
#define RESRVMAP_ACTIVE   1

#define NEWSTUFF_ACTIVE   0


#endif // #ifndef _ACTIVE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\bugcheck.h ===
#ifndef _BUGCHECK_H_INCLUDED_
#define _BUGCHECK_H_INCLUDED_

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////// Bugcheck functions
/////////////////////////////////////////////////////////////////////

VOID
BgChkForceCustomBugcheck (
    PVOID
    );

VOID 
BgChkProcessHasLockedPages (
    PVOID
    );

VOID 
BgChkNoMoreSystemPtes (
    PVOID
    );

VOID 
BgChkBadPoolHeader (
    PVOID
    );

VOID 
BgChkDriverCorruptedSystemPtes (
    PVOID
    );

VOID 
BgChkDriverCorruptedExPool (
    PVOID
    );

VOID 
BgChkDriverCorruptedMmPool (
    PVOID
    );

VOID 
BgChkIrqlNotLessOrEqual (
    PVOID
    );

VOID 
BgChkPageFaultBeyondEndOfAllocation (
    PVOID
    );

VOID 
BgChkDriverVerifierDetectedViolation (
    PVOID
    );

VOID BgChkCorruptSystemPtes(
    PVOID
    );

VOID
BgChkHangCurrentProcessor (
    PVOID
    );



#endif // #ifndef _BUGCHECK_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\control\tcontrol.cxx ===
//
// Template driver user-mode controller
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  tcontrol.cxx
// Author:  Silviu Calinoiu (SilviuC)
// Created: 4/20/1999 3:40pm
//
// This module contains a user-mode controller for a template
// driver.
//
// --- History ---
//
// 4/20/1999 (SilviuC): initial version.
//

#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <windows.h>
#include <winioctl.h>
#include <time.h>

#define NO_BUGGY_FUNCTIONS
#define FUNS_DEFINITION_MODULE
#include "..\driver\tdriver.h"
#include "..\driver\funs.h"


//
// Get rid of performance warnings for BOOL to bool conversions
//

#pragma warning (disable: 4800)


bool TdCreateService (LPCTSTR DriverName);
bool TdDeleteService (LPCTSTR DriverName);
bool TdStartService (LPCTSTR DriverName);
bool TdStopService (LPCTSTR DriverName);
bool TdOpenDevice (LPCTSTR DriverName, PHANDLE DeviceHandle);
bool TdCloseDevice (HANDLE Device);
bool TdSendIoctl (IN HANDLE Device, IN DWORD Ioctl, IN PVOID pData OPTIONAL, IN ULONG uDataSize OPTIONAL);

void TdSectMapProcessAddressSpaceTest();
void TdSectMapSystemAddressSpaceTest();

VOID
TdReservedMapSetSize( int argc, char *argv[] );

VOID
TdReservedMapRead( VOID );

BOOL
ProcessCommandLine (
    LPCTSTR Option
    );

ULONG_PTR
UtilHexStringToUlongPtr( char *szHexNumber );

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////// Main()
///////////////////////////////////////////////////////////////////////////////

void _cdecl
main (int argc, char *argv[])
{
    BOOL DisplayHelp;
    HANDLE Device;
    DWORD Index;
    char *pCrtChar;

    DisplayHelp = FALSE;

    try {

        if (argc == 3 && _stricmp (argv[1], "/create") == 0) {
            TdCreateService (argv[2]);
        }
        else if (argc == 3 && _stricmp (argv[1], "/delete") == 0) {
            TdDeleteService (argv[2]);
        }
        else if (argc == 3 && _stricmp (argv[1], "/start") == 0) {
            TdStartService (argv[2]);
        }
        else if (argc == 3 && _stricmp (argv[1], "/stop") == 0) {
            TdStopService (argv[2]);
        }
        else if (argc == 2 && _stricmp (argv[1], "/sectionmaptest") == 0) {

            TdSectMapProcessAddressSpaceTest();
        }
        else if (argc == 2 && _stricmp (argv[1], "/sectionmaptestsysspace") == 0) {

            TdSectMapSystemAddressSpaceTest();
        }
        else if ( argc >= 2 && _stricmp (argv[1], "/ReservedMapSetSize") == 0) {

            TdReservedMapSetSize( argc, argv );
        }
        else if ( argc >= 2 && _stricmp (argv[1], "/ReservedMapRead") == 0) {

            TdReservedMapRead();
        }
        else if (argc >= 2 && _stricmp (argv[1], "/ioctlbugcheck") == 0) {

            //
            // Send the bugcheck parameters from the command line
            //

            BUGCHECK_PARAMS BugcheckParams;

            ZeroMemory( &BugcheckParams, sizeof( BugcheckParams ) );

            //
            // Bugcheck code
            //

            if( argc >= 3 )
            {
                BugcheckParams.BugCheckCode = (ULONG)UtilHexStringToUlongPtr( argv[ 2 ] );
            }

            //
            // Bugcheck paramaters
            //

            for( int nCrtCommandLineArg = 3; nCrtCommandLineArg < argc; nCrtCommandLineArg++ )
            {
                BugcheckParams.BugCheckParameters[ nCrtCommandLineArg - 3 ] = 
                    UtilHexStringToUlongPtr( argv[ nCrtCommandLineArg ] );
            }

            //
            // Send the IOCTL to the driver
            //

            HANDLE Device;

            if ( TdOpenDevice ("buggy", &Device) ) {
                
                TdSendIoctl (
                    Device, 
                    IOCTL_TD_BUGCHECK,
                    &BugcheckParams,
                    sizeof( BugcheckParams ) );

                TdCloseDevice (Device);
            }
        }
        else {
            if (argc >= 2 && ProcessCommandLine (argv[1]) == FALSE) {
                DisplayHelp = TRUE;
            }
        }
    }
    catch (char * Message) {

        printf ("Error: s", GetLastError(), Message);
    }

    if ( DisplayHelp == TRUE ) {

        printf ("ctlbuggy /create DRIVER \n");
        printf ("ctlbuggy /delete DRIVER \n");
        printf ("ctlbuggy /start DRIVER \n");
        printf ("ctlbuggy /stop DRIVER \n");
        printf ("                                 \n");
        printf ("ctlbuggy /sectionmaptest             \n");
        printf ("ctlbuggy /sectionmaptestsysspace     \n");
        printf ("                                 \n");
        printf ("ctlbuggy IOCTL-NAME              \n");
        printf ("\n\n");

        for (Index = 0; BuggyFuns[Index].Ioctl != 0 && BuggyFuns[Index].Command != NULL; Index++) {
            printf("ctlbuggy %s \n", BuggyFuns[Index].Command);
        }

        printf ("\n");
        exit (1);
    }

    exit( 0 );
}

BOOL
ProcessCommandLine (
    LPCTSTR Option
    )
/*++

Routine Description:

    This routine tries to figure out if the command line option
    is specifies one of the ioctls that can be processed.

Arguments:

    `Option' - command line option.

Return Value:

    TRUE if an option has been found and processed.
    FALSE otherwise.

Environment:

    Nothing special.

--*/

{
    DWORD Index;
    HANDLE Device;
    BOOL Result = FALSE;

    for (Index = 0; BuggyFuns[Index].Ioctl != 0; Index++) {
        if (BuggyFuns[Index].Command != NULL && _stricmp (BuggyFuns[Index].Command, Option) == 0) {
            if ( TdOpenDevice ("buggy", &Device) ) {
                
                TdSendIoctl (Device, BuggyFuns[Index].Ioctl, NULL, 0);
                
                if (BuggyFuns[Index].Ioctl == IOCTL_TD_NONPAGEDPOOLMDLTEST_MAP)
                {
                    //
                    // Sleep for a while
                    //

                    //DWORD SleepTime = 2 * 60 * 1000;
                    DWORD SleepTime = 10 * 1000;

                    printf ("Sleeping for %u millisec\n",
                            SleepTime);

                    Sleep (SleepTime);

                    //
                    // Unmap the memory.
                    //

                    printf ("Unmapping memory.\n");

                    TdSendIoctl (Device, IOCTL_TD_NONPAGEDPOOLMDLTEST_UNMAP, NULL, 0);
                }

                TdCloseDevice (Device);
                Result = TRUE;
                break;
            }
        }
    }

    return Result;
}

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////// Driver load/unload
///////////////////////////////////////////////////////////////////////////////

bool
TdCreateService (

    LPCTSTR DriverName)
{
    SC_HANDLE ServiceManager = NULL;
    SC_HANDLE ServiceHandle = NULL;
    BOOL ReturnValue;
    HANDLE Driver;
    TCHAR ScratchBuffer [MAX_PATH];
    TCHAR DriverPath [MAX_PATH];
    TCHAR DevicePath [MAX_PATH];

    try {

        GetSystemDirectory (ScratchBuffer, sizeof ScratchBuffer);
        _stprintf (DriverPath, "%s\\drivers\\%s.sys", ScratchBuffer, DriverName);
        _stprintf (DevicePath, "\\\\.\\%s", DriverName);

        //
        // Open the service control manager
        //

        ServiceManager = OpenSCManager (

            NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS);

        if (ServiceManager == NULL) {
            throw "OpenScManager()";
        }

        //
        // Create the service
        //

        printf("Driver path: %s \n", DriverPath);
        printf("Device path: %s \n", DevicePath);

        ServiceHandle = CreateService (

            ServiceManager,         // handle to SC manager
            DriverName,             // name of service
            DriverName,             // display name
            SERVICE_ALL_ACCESS,     // access mask
            SERVICE_KERNEL_DRIVER,  // service type
            SERVICE_DEMAND_START,   // start type
            SERVICE_ERROR_NORMAL,   // error control
            DriverPath,             // full path to driver
            NULL,                   // load ordering
            NULL,                   // tag id
            NULL,                   // dependency
            NULL,                   // account name
            NULL);                  // password

        if (ServiceHandle == NULL && GetLastError() != ERROR_SERVICE_EXISTS) {
            throw "CreateService()";
        }

        ReturnValue = TRUE;
    }
    catch (char * Msg) {

        printf("Error: %u: %s\n", GetLastError(), Msg);
        fflush (stdout);
        ReturnValue = FALSE;
    }

    //
    // Close handles and return.
    //

    if (ServiceHandle) {
        CloseServiceHandle (ServiceHandle);
    }

    if (ServiceManager) {
        CloseServiceHandle (ServiceManager);
    }

    return ReturnValue;


}

bool
TdStartService (

    LPCTSTR DriverName)
{
    SC_HANDLE ServiceManager = NULL;
    SC_HANDLE ServiceHandle = NULL;
    BOOL ReturnValue;
    HANDLE Driver;
    TCHAR ScratchBuffer [MAX_PATH];
    TCHAR DriverPath [MAX_PATH];
    TCHAR DevicePath [MAX_PATH];


    try {

        GetSystemDirectory (ScratchBuffer, sizeof ScratchBuffer);
        _stprintf (DriverPath, "%s\\drivers\\%s.sys", ScratchBuffer, DriverName);
        _stprintf (DevicePath, "\\\\.\\%s", DriverName);

        //
        // Open the service control manager
        //

        ServiceManager = OpenSCManager (

            NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS);

        if (ServiceManager == NULL) {
            throw "OpenScManager()";
        }

        //
        // Open the service. The function assumes that
        // TdCreateService has been called before this one
        // and the service is already installed.
        //

        ServiceHandle = OpenService (

            ServiceManager,
            DriverName,
            SERVICE_ALL_ACCESS);

        if (ServiceHandle == NULL) {
            throw "OpenService()";
        }

        //
        // Start the service
        //

        if (! StartService (ServiceHandle, 0, NULL)) {
            if (GetLastError() != ERROR_SERVICE_ALREADY_RUNNING) {
                throw "StartService()";
            }
        }

        ReturnValue = TRUE;
    }
    catch (char * Msg) {

        printf("Error: %u: %s\n", GetLastError(), Msg);
        fflush (stdout);
        ReturnValue = FALSE;
    }

    //
    // Close handles and return.
    //

    if (ServiceHandle) {
        CloseServiceHandle (ServiceHandle);
    }

    if (ServiceManager) {
        CloseServiceHandle (ServiceManager);
    }

    return ReturnValue;
}

bool
TdStopService (

    LPCTSTR DriverName)
{
    SC_HANDLE ServiceManager = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    BOOL ReturnValue;

    try {

        //
        // Open the service control manager
        //

        ServiceManager = OpenSCManager (

            NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS);

        if (ServiceManager == NULL) {
            throw "OpenSCManager()";
        }

        //
        // Open the service so we can stop it
        //

        ServiceHandle = OpenService (

            ServiceManager,
            DriverName,
            SERVICE_ALL_ACCESS);

        if (ServiceHandle == NULL) {
            throw "OpenService()";
        }

        //
        // Stop the service
        //

        if (! ControlService (ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus)) {
            throw "ControlService()";
        }

        ReturnValue = TRUE;
    }
    catch (char * Msg) {

        printf("Error: %u: %s\n", GetLastError(), Msg);
        fflush (stdout);
        ReturnValue = FALSE;
    }

    //
    // Close handles ans return.
    //

    if (ServiceHandle) {
        CloseServiceHandle (ServiceHandle);
    }

    if (ServiceManager) {
        CloseServiceHandle (ServiceManager);
    }

    return ReturnValue;
}

bool
TdDeleteService (

    LPCTSTR DriverName)
{
    SC_HANDLE ServiceManager = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    BOOL ReturnValue;

    try {

        //
        // Open the service control manager
        //

        ServiceManager = OpenSCManager (

            NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS);

        if (ServiceManager == NULL) {
            throw "OpenSCManager()";
        }

        //
        // Open the service so we can stop it
        //

        ServiceHandle = OpenService (

            ServiceManager,
            DriverName,
            SERVICE_ALL_ACCESS);

        if (ServiceHandle == NULL) {
            throw "OpenService()";
        }

        //
        // Delete the service
        //

        if (! DeleteService (ServiceHandle)) {
            if (GetLastError() != ERROR_SERVICE_MARKED_FOR_DELETE) {
                throw "DeleteService()";
            }
        }

        ReturnValue = TRUE;
    }
    catch (char * Msg) {

        printf("Error: %u: %s\n", GetLastError(), Msg);
        fflush (stdout);
        ReturnValue = FALSE;
    }

    //
    // Close handles ans return.
    //

    if (ServiceHandle) {
        CloseServiceHandle (ServiceHandle);
    }

    if (ServiceManager) {
        CloseServiceHandle (ServiceManager);
    }

    return ReturnValue;
}

bool
TdOpenDevice (

    LPCTSTR DriverName,
    PHANDLE DeviceHandle)
{
    SC_HANDLE ServiceManager = NULL;
    SC_HANDLE ServiceHandle = NULL;
    BOOL ReturnValue;
    HANDLE Device;
    TCHAR ScratchBuffer [MAX_PATH];
    TCHAR DriverPath [MAX_PATH];
    TCHAR DevicePath [MAX_PATH];

    //
    // Sanity checks
    //

    if (DeviceHandle == NULL) {
        return FALSE;
    }

    try {

        GetSystemDirectory (ScratchBuffer, sizeof ScratchBuffer);
        _stprintf (DriverPath, "%s\\drivers\\%s.sys", ScratchBuffer, DriverName);
        _stprintf (DevicePath, "\\\\.\\%s", DriverName);

        //
        // Open the service control manager
        //

        ServiceManager = OpenSCManager (

            NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS);

        if (ServiceManager == NULL) {
            throw "OpenScManager()";
        }

        //
        // Service should already exist.
        //

        ServiceHandle = OpenService (

            ServiceManager,
            DriverName,
            SERVICE_ALL_ACCESS);

        if (ServiceHandle == NULL) {
            throw "OpenService()";
        }

        //
        // Open the device
        //

        Device = CreateFile (

            DevicePath,
            GENERIC_READ|GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (Device == INVALID_HANDLE_VALUE) {
            throw "CreateFile()";
        }

        ReturnValue = TRUE;
    }
    catch (char * Msg) {

        printf("Error: %u: %s\n", GetLastError(), Msg);
        fflush (stdout);
        ReturnValue = FALSE;
    }

    //
    // Close handles and return.
    //

    if (ServiceHandle) {
        CloseServiceHandle (ServiceHandle);
    }

    if (ServiceManager) {
        CloseServiceHandle (ServiceManager);
    }

    if (Device != INVALID_HANDLE_VALUE) {
        *DeviceHandle = Device;
    }

    return ReturnValue;

}

bool
TdCloseDevice (

    HANDLE Device)
{
    if (Device == INVALID_HANDLE_VALUE) {
        return false;
    }

    return CloseHandle(Device);
}

//
// Function:
//
//     SendIoctl
//
// Description:
//
//     This function sends an ioctl code to the driver.
//

bool
TdSendIoctl (

    IN HANDLE Driver,
    IN DWORD Ioctl,
    IN PVOID pData OPTIONAL, 
    IN ULONG uDataSize OPTIONAL )
{
    DWORD BytesReturned;
    BOOL Result;

    if (Driver == INVALID_HANDLE_VALUE) {
        return false;
    }

    Result = DeviceIoControl (

        Driver,
        Ioctl,
        pData,
        uDataSize,
        NULL,
        0,
        &BytesReturned,
        NULL);

    return Result == TRUE;
}

//
//
//
#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
MapProcessAddressSpaceThread( LPVOID lpData )
{
    HANDLE hDevice;
    DWORD dwTimeToSleep;

    hDevice = (HANDLE)lpData;

    while( TRUE )
    {
        dwTimeToSleep = rand() % 5000;

        Sleep( dwTimeToSleep );

        TdSendIoctl (hDevice, IOCTL_TD_SECTION_MAP_TEST_PROCESS_SPACE, NULL, 0);
    }

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


//
//
//

#define TD_MAPSECT_TEST_THREADS 4

void TdSectMapProcessAddressSpaceTest()
{
    HANDLE Device;
    time_t theTime;
    int nCrtThread;
    DWORD dwThreadId;
    TCHAR strMessage[ 128 ];

    time( &theTime );

    _stprintf(
        strMessage,
        "Process %u, rand seed = %u\n",
        GetCurrentProcessId(),
        (unsigned int)theTime );

    OutputDebugString( strMessage );

    srand( (unsigned int)theTime );

    if( TdOpenDevice ("buggy", &Device) )
    {
        for( nCrtThread = 0; nCrtThread < TD_MAPSECT_TEST_THREADS - 1; nCrtThread++ )
        {
            CreateThread(
                NULL,
                0,
                MapProcessAddressSpaceThread,
                (LPVOID)Device,
                0,
                &dwThreadId );
        }

        //
        // reuse the main thread
        //

        MapProcessAddressSpaceThread( (LPVOID)Device );

        TdCloseDevice (Device);
    }
}

//
//
//

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
DWORD
MapSystemAddressSpaceThread( LPVOID lpData )
{
    HANDLE hDevice;
    DWORD dwTimeToSleep;

    hDevice = (HANDLE)lpData;

    while( TRUE )
    {
        dwTimeToSleep = rand() % 5000;

        Sleep( dwTimeToSleep );

        TdSendIoctl (hDevice, IOCTL_TD_SECTION_MAP_TEST_SYSTEM_SPACE, NULL, 0);
    }

    return 0;
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


//
//
//

void TdSectMapSystemAddressSpaceTest()
{
    HANDLE Device;
    time_t theTime;
    int nCrtThread;
    DWORD dwThreadId;
    TCHAR strMessage[ 128 ];

    time( &theTime );

    _stprintf(
        strMessage,
        "Process %u, rand seed = %u\n",
        GetCurrentProcessId(),
        (unsigned int)theTime );

    OutputDebugString( strMessage );

    srand( (unsigned int)theTime );

    if( TdOpenDevice ("buggy", &Device) )
    {
        for( nCrtThread = 0; nCrtThread < TD_MAPSECT_TEST_THREADS - 1; nCrtThread++ )
        {
            CreateThread(
                NULL,
                0,
                MapProcessAddressSpaceThread,
                (LPVOID)Device,
                0,
                &dwThreadId );
        }

        //
        // reuse the main thread - only this thread will map into system address space
        //

        MapSystemAddressSpaceThread( (LPVOID)Device );

        TdCloseDevice (Device);
    }
}

//
// Convert a hex string from the command line to an UNLONG_PTR
//

ULONG_PTR
UtilHexStringToUlongPtr( char *szHexNumber )
{
    ULONG_PTR uNewDigit;
    ULONG_PTR uResult = 0;
    char *pCrtChar = szHexNumber;

    while( ( *pCrtChar ) != (char)0 )
    {
        uNewDigit = 0;

        if( ( *pCrtChar ) >= '0' && ( *pCrtChar ) <= '9' )
        {
            uNewDigit = ( *pCrtChar ) - '0';
        }
        else
        {
            if( ( *pCrtChar ) >= 'A' && ( *pCrtChar ) <= 'F' )
            {
                uNewDigit = ( *pCrtChar ) - 'A' + 10;
            }
            else
            {
                if( ( *pCrtChar ) >= 'a' && ( *pCrtChar ) <= 'f' )
                {
                    uNewDigit = ( *pCrtChar ) - 'a' + 10;
                }
            }
        }

        uResult = uResult * 16 + uNewDigit;

        pCrtChar++;
    }

    return uResult;
}

//
// Set the current reserved size and address as asked by the user
//


VOID
TdReservedMapSetSize( 
	int argc, 
	char *argv[] )
{
	SIZE_T NewSize;
    HANDLE Device;
    time_t theTime;
    TCHAR strMessage[ 128 ];

	if( argc >= 3 )
	{
		//
		// User-specified buffer size
		//

		NewSize = atoi( argv[ 2 ] );
	}
	else
	{
		//
		// Seed the random numbers generator 
		//

		time( &theTime );

		_stprintf(
			strMessage,
			"Process %u, rand seed = %u\n",
			GetCurrentProcessId(),
			(unsigned int)theTime );

		OutputDebugString( strMessage );

		srand( (unsigned int)theTime );

		//
		// New size is random, up to 10 pages
		//

		NewSize = ( abs( rand() ) % 10 + 1 ) * 0x1000;
	}

	if( TdOpenDevice ("buggy", &Device) )
	{
		printf( "TdReservedMapSetSize: sending size %p\n",
			NewSize );

        TdSendIoctl (
            Device, 
            IOCTL_TD_RESERVEDMAP_SET_SIZE,
            &NewSize,
            sizeof( NewSize ) );

        TdCloseDevice (Device);
	}
}

//
// Ask for a "read" operation from our driver
//

VOID
TdReservedMapRead( VOID )
{
    HANDLE Device;
    time_t theTime;
	SIZE_T ReadBufferSize;
	SIZE_T ReadPages;
	SIZE_T CrtReadPage;
	PSIZE_T CrtPageAddress;
	PVOID UserBuffer;
	BOOL Success;
	SYSTEM_INFO SystemInfo;
    TCHAR strMessage[ 128 ];

	//
	// Get the page size
	//

	GetSystemInfo( 
		&SystemInfo );

	//
	// Seed the random numbers generator 
	//

	time( &theTime );

	_stprintf(
		strMessage,
		"Process %u, rand seed = %u\n",
		GetCurrentProcessId(),
		(unsigned int)theTime );

	//OutputDebugString( strMessage );
	puts( strMessage );

	srand( (unsigned int)theTime );

	//
	// Choose a size >= PAGE_SIZE and <= ~1 Mb 
	//
	
	ReadBufferSize = abs( rand() * rand() * rand() ) % ( 1024 * 1024 ) + SystemInfo.dwPageSize;

	UserBuffer = VirtualAlloc( 
		NULL,
		ReadBufferSize,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_READWRITE );

	if( NULL != UserBuffer )
	{
		if( TdOpenDevice ("buggy", &Device) )
		{
			//
			// Prepare the parameters to the driver
			//

			USER_READ_BUFFER UserReadBuffer;

			UserReadBuffer.UserBuffer = UserBuffer;
			UserReadBuffer.UserBufferSize = ReadBufferSize;

			_stprintf(
				strMessage,
				"TdReservedMapRead: sending buffer %p, size %p\n",
				UserReadBuffer.UserBuffer,
				UserReadBuffer.UserBufferSize );

			//OutputDebugString( strMessage );
			puts( strMessage );

			//
			// Send the request to the driver
			//

			Success = TdSendIoctl (
				Device, 
				IOCTL_TD_RESERVEDMAP_READ_OP,
				&UserReadBuffer,
				sizeof( UserReadBuffer ) );

			if( TRUE == Success )
			{
				//
				// If the call succeeded then we check the validity of data returned by the driver
				//

				ReadPages = ReadBufferSize / SystemInfo.dwPageSize;
				CrtPageAddress = (PSIZE_T)UserBuffer;

				for( CrtReadPage = 1; CrtReadPage <= ReadPages; CrtReadPage++ )
				{
					if( *CrtPageAddress != CrtReadPage )
					{
						_stprintf(
							strMessage,
							"Incorrect data received from buggy.sys: page %p, expected %p, actual data %p\n",
							CrtPageAddress,
							CrtReadPage,
							*CrtPageAddress );

						OutputDebugString( strMessage );

						DebugBreak();
					}
					
					CrtPageAddress = (PSIZE_T) ( (PCHAR)CrtPageAddress + SystemInfo.dwPageSize );
					ReadPages -= 1;
				}
				
			}

			TdCloseDevice (Device);
		}

		VirtualFree( 
			UserBuffer,
			0,
			MEM_RELEASE );
	}

}

//
// End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\deadlock.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   vfpdlock.h

Abstract:

    Detect deadlocks in arbitrary synchronization objects.

Author:

    Jordan Tigani (jtigani) 2-May-2000
    Silviu Calinoiu (silviuc) 9-May-2000


Revision History:

--*/


#ifndef _VFDLOCK_H_
#define _VFDLOCK_H_


VOID 
VfDeadlockDetectionInitialize(
    VOID
    );


//
// Resource types supported by deadlock verifier.
//

typedef enum _VI_DEADLOCK_RESOURCE_TYPE {
    ViDeadlockUnknown = 0,
    ViDeadlockMutex,
    ViDeadlockFastMutex,    
    ViDeadlockTypeMaximum
} VI_DEADLOCK_RESOURCE_TYPE, *PVI_DEADLOCK_RESOURCE_TYPE;

//
// Deadlock detection package initialization.
//

VOID 
ViDeadlockDetectionInitialize(
    );

//
// Resource interfaces
//

BOOLEAN
ViDeadlockAddResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );

BOOLEAN
ViDeadlockQueryAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );
VOID
ViDeadlockAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );

VOID
ViDeadlockReleaseResource(
    IN PVOID Resource
    );

//
// Used for resource garbage collection.
//

VOID 
ViDeadlockDeleteMemoryRange(
    IN PVOID Address,
    IN SIZE_T Size
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\deadlock.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   vfpdlock.c

Abstract:

    Detect deadlocks in arbitrary synchronization objects.

Author:

    Jordan Tigani (jtigani) 2-May-2000
    Silviu Calinoiu (silviuc) 9-May-2000


Revision History:

--*/

//
// TO DO LIST
//
// - detect a resource allocated on the stack of current thread and give
//   warning about this.
// - clean deletion of resources, threads, nodes
// - get rid of FirstNode hack
// - create nodes based on (R, T, Stk).
// - keep deleted nodes around if other nodes in the path are still alive.
//   See ISSUE in ViDeadlockDeleteRange.
// - Make sure NodeCount is updated all over the place.
//

#define _BUGGY_ 1

//
// ISSUE -- 
// This ifdef lets us move the code back and forth between the kernel
// and the buggy driver -- the latter is for testing purposes
//

#if _BUGGY_

#include <ntddk.h>
#include "deadlock.h"

#else

#include "vfdef.h"
#endif

//#include "vfpdlock.h"

//
// Deadlock detection structures.
//
// There are three important structures involved: THREAD, RESOURCE, NODE.
//
// For every active thread in the system that holds at least one resource
// the package maintains a THREAD structure. This gets created when a thread 
// acquires first resource and gets destroyed when thread releases the last
// resource. If a thread does not hold any resource it will not have a
// corresponding THREAD structure.
//
// For every resource in the system there is a RESOURCE structure. A dead resource
// might still have a RESOURCE laying around because the algorithm to garbage
// collect old resources is of the lazy type. 
//
// Every acquisition of a resource is modeled by a NODE structure. When a thread 
// acquires resource B while holding A the package will create a NODE for B and link
// it to the node for A. Beware that this is a very general description of what 
// happens.
//
// There are three important functions that make the interface with the outside
// world.
//
//     ViDeadlockAddResource          hook for resource initialization
//     ViDeadlockQueryAcquireResource checks for deadlock before resource acquisition
//     ViDeadlockAcquireResource      hook for resource acquire
//     ViDeadlockReleaseResource      hook for resource release
//
// Unfortunately almost no kernel synchronization object has a delete routine
// therefore we need to lazily garbage collect any zombie resources from our
// structures.
//

//
// Did we initialize the verifier deadlock detection package?
// If this variable is false no detection will be done whatsoever.
//

BOOLEAN ViDeadlockDetectionInitialized = FALSE;

//
// Enable/disable the deadlock detection package. This can be used
// to disable temporarily the deadlock detection package.
//
                
BOOLEAN ViDeadlockDetectionEnabled = 
#if _BUGGY_
    TRUE;
#else
    FALSE;
#endif


#define VI_DEADLOCK_FLAG_RECURSIVE_ACQUISITION_OK       0x1 
#define VI_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION     0x2

ULONG ViDeadlockResourceTypeInfo[ViDeadlockTypeMaximum] =
{
    // ViDeadlockUnknown //    
    0,   

    // ViDeadlockMutex//    
    VI_DEADLOCK_FLAG_RECURSIVE_ACQUISITION_OK,

    // ViDeadlockFastMutex //    
    VI_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION,    
    
};


//
// Max depth of stack traces captured.
//

#define VI_MAX_STACK_DEPTH 8

NTSYSAPI
USHORT
NTAPI
RtlCaptureStackBackTrace(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash
   );

//
// Deadlock specific issues (bugs)
//
// SELF_DEADLOCK
//
//     Acquire resource recursively.
//
// DEADLOCK_DETECTED
//
//     Plain deadlock. Need the previous information
//     messages to build a deadlock proof.
//
// UNINITIALIZED_RESOURCE
//
//     Acquiring a resource that was never initialized.
//
// UNEXPECTED_RELEASE
//
//     Releasing a resource which is not the last one
//     acquired by the current thread. 
//
// UNEXPECTED_THREAD
//
//     Current thread does not have any resources
//     acquired.
//
// MULTIPLE_INITIALIZATION
//
//      Attempting to initialize a second time the same 
//      resource.
//

#define VI_DEADLOCK_ISSUE_DEADLOCK_SELF_DEADLOCK  0x1000
#define VI_DEADLOCK_ISSUE_DEADLOCK_DETECTED       0x1001
#define VI_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE  0x1002
#define VI_DEADLOCK_ISSUE_UNEXPECTED_RELEASE      0x1003
#define VI_DEADLOCK_ISSUE_UNEXPECTED_THREAD       0x1004
#define VI_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION 0x1005
#define VI_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES  0x1006

//
// VI_DEADLOCK_NODE
//

typedef struct _VI_DEADLOCK_NODE {

    //
    // Node representing the acquisition of the previous resource.
    //

    struct _VI_DEADLOCK_NODE * Parent;

    //
    // Node representing the next resource acquisitions, that are
    // done after acquisition of the current resource.
    //

    struct _LIST_ENTRY ChildrenList;

    //
    // Field used to chain siblings in the tree. A parent node has the
    // ChildrenList field as the head of the children list that is chained
    // with the Siblings field.
    //

    struct _LIST_ENTRY SiblingsList;


    //
    // List of nodes representing the same resource acquisition 
    // as the current node but in different contexts (lock combinations).
    //

    struct _LIST_ENTRY ResourceList;

    //
    // Back pointer to the descriptor for this resource.
    // If the node has been marked for deletion then the
    // ResourceAddress field should be used and it has the address
    // of the kernel resource address involved. The Root pointer is
    // no longer valid because we deallocate the RESOURCE structure
    // when it gets deleted.
    //

    union {
        struct _VI_DEADLOCK_RESOURCE * Root;

        PVOID ResourceAddress;
    };

    //
    // The number of nodes that are below this one at any depth.
    // This counter is used in the node deletion algorithms. It is
    // incremented by one on all ancestors of a node created (resource
    // acquired) and decremented by one when resource gets deleted.
    // If a root of a tree has NodeCount equal to zero the whole tree
    // will be deleted.
    //

    ULONG NodeCount;

    //
    // When we find a deadlock, we keep this info around in order to 
    // be able to identify the parties involved who have caused 
    // the deadlock.
    //

    PKTHREAD Thread;
    
    PVOID StackTrace[VI_MAX_STACK_DEPTH];    

} VI_DEADLOCK_NODE, *PVI_DEADLOCK_NODE;


//
// VI_DEADLOCK_RESOURCE
//

typedef struct _VI_DEADLOCK_RESOURCE {

    //
    // Since we may need to clean up different kinds of resources
    // in different ways, keep track of what kind of resource
    // this is.
    //

    VI_DEADLOCK_RESOURCE_TYPE Type;

    //
    // The address of the synchronization object used by the kernel.
    //

    PVOID ResourceAddress;

    //
    // The thread that curently owns the resource
    // (null if no owner)
    //
    PKTHREAD ThreadOwner;   

    //
    // List of resource nodes representing acquisitions of this resource.
    //

    LIST_ENTRY ResourceList;

    //
    // Number of resource nodes created for this resource. 
    // ISSUE: Why do we need this counter ? (silviuc)
    //

    ULONG NodeCount;

    //
    // List used for chaining resources from a hash bucket.
    //

    LIST_ENTRY HashChainList;

    //
    // Stack trace of the resource creator.
    //

    PVOID InitializeStackTrace [VI_MAX_STACK_DEPTH];


} VI_DEADLOCK_RESOURCE, * PVI_DEADLOCK_RESOURCE;


//
// VI_DEADLOCK_THREAD
//

typedef struct _VI_DEADLOCK_THREAD {

    //
    // Kernel thread address
    //
    
    PKTHREAD Thread;

    //
    // The node representing the last resource acquisition made by
    // this thread.
    //

    PVI_DEADLOCK_NODE CurrentNode;

    //
    // Thread list. It is used for chaining into a hash bucket.
    //

    LIST_ENTRY ListEntry;

} VI_DEADLOCK_THREAD, *PVI_DEADLOCK_THREAD;

typedef struct _VI_DEADLOCK_PARTICIPANT {
    //
    // Address of participant -- could be a resource
    // address or a resource node, depending on whether
    // NodeInformation is set
    //
    // NULL participant means that there are no more
    // participants
    //

    PVOID Participant;

    //
    // True:  Participant is type VI_DEADLOCK_NODE
    // False: Participant is a PVOID and shouldn't be deref'd
    //
    BOOLEAN NodeInformation;
    
} VI_DEADLOCK_PARTICIPANT, *PVI_DEADLOCK_PARTICIPANT;

//
// Deadlock resource and thread databases.
//
//

#define VI_DEADLOCK_HASH_BINS 1

PLIST_ENTRY ViDeadlockResourceDatabase;
PLIST_ENTRY ViDeadlockThreadDatabase;

ULONG ViDeadlockNumberParticipants;

PVI_DEADLOCK_PARTICIPANT ViDeadlockParticipation;

//
// Performance counters
//

ULONG ViDeadlockNumberOfNodes;
ULONG ViDeadlockNumberOfResources;
ULONG ViDeadlockNumberOfThreads;

//
// Maximum recursion depth for deadlock detection algorithm.
//

#define VI_DEADLOCK_MAXIMUM_DEGREE 4

ULONG ViDeadlockMaximumDegree;

//
//  Verifier deadlock detection pool tag.
//

#define VI_DEADLOCK_TAG 'kclD' 

//
// Global `deadlock lock database' lock
//

KSPIN_LOCK ViDeadlockDatabaseLock;
PKTHREAD ViDeadlockDatabaseOwner;

#define LOCK_DEADLOCK_DATABASE(OldIrql)                     \
    KeAcquireSpinLock(&ViDeadlockDatabaseLock, (OldIrql));  \
    ViDeadlockDatabaseOwner = KeGetCurrentThread ();

#define UNLOCK_DEADLOCK_DATABASE(OldIrql)                   \
    ViDeadlockDatabaseOwner = NULL;                         \
    KeReleaseSpinLock(&ViDeadlockDatabaseLock, OldIrql);

//
// Internal deadlock detection functions
//

VOID 
ViDeadlockDetectionInitialize(
    );

PLIST_ENTRY
ViDeadlockDatabaseHash( 
    IN PLIST_ENTRY Database,
    IN PVOID Address
    );

PVI_DEADLOCK_RESOURCE 
ViDeadlockSearchResource(
    IN PVOID ResourceAddress
    );

BOOLEAN
ViDeadlockAddResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );

BOOLEAN
ViDeadlockQueryAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );

BOOLEAN 
ViDeadlockSimilarNode (
    IN PVOID Resource,
    IN PKTHREAD Thread,
    IN PVOID * Trace,
    IN PVI_DEADLOCK_NODE Node
    );

VOID
ViDeadlockAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );


VOID 
ViDeadlockReleaseResource(
    IN PVOID Resource
    );

BOOLEAN
ViDeadlockAnalyze(
    IN PVOID ResourceAddress,  
    IN PVI_DEADLOCK_NODE CurrentNode,
    IN ULONG Degree
    );

PVI_DEADLOCK_THREAD
ViDeadlockSearchThread (
    PKTHREAD Thread
    );

PVI_DEADLOCK_THREAD
ViDeadlockAddThread (
    PKTHREAD Thread
    );

VOID
ViDeadlockDeleteThread (
    PVI_DEADLOCK_THREAD Thread
    );

PVOID
ViDeadlockAllocate (
    SIZE_T Size
    );

VOID
ViDeadlockFree (
    PVOID Object
    );

VOID
ViDeadlockReportIssue (
    ULONG_PTR Param1,
    ULONG_PTR Param2,
    ULONG_PTR Param3,
    ULONG_PTR Param4
    );

VOID
ViDeadlockAddParticipant(
    PVOID ResourceAddress,              
    PVI_DEADLOCK_NODE FirstParticipant, OPTIONAL
    PVI_DEADLOCK_NODE SecondParticipant, 
    ULONG Degree
    );

VOID
ViDeadlockDeleteResource (
    PVI_DEADLOCK_RESOURCE Resource
    );

VOID
ViDeadlockDeleteTree (
    PVI_DEADLOCK_NODE Root
    );

BOOLEAN
ViDeadlockIsNodeMarkedForDeletion (
    PVI_DEADLOCK_NODE Node
    );


PVOID
ViDeadlockGetNodeResourceAddress (
    PVI_DEADLOCK_NODE Node
    );

#ifdef ALLOC_PRAGMA

#if ! _BUGGY_
#pragma alloc_text(INIT, ViDeadlockDetectionInitialize)

#pragma alloc_text(PAGEVRFY, ViDeadlockAnalyze)
#pragma alloc_text(PAGEVRFY, ViDeadlockDatabaseHash)

#pragma alloc_text(PAGEVRFY, ViDeadlockSearchResource)
#pragma alloc_text(PAGEVRFY, ViDeadlockAddResource)
#pragma alloc_text(PAGEVRFY, ViDeadlockSimilarNode)
#pragma alloc_text(PAGEVRFY, ViDeadlockAcquireResource)
#pragma alloc_text(PAGEVRFY, ViDeadlockReleaseResource)

#pragma alloc_text(PAGEVRFY, ViDeadlockSearchThread)
#pragma alloc_text(PAGEVRFY, ViDeadlockAddThread)
#pragma alloc_text(PAGEVRFY, ViDeadlockDeleteThread)

#pragma alloc_text(PAGEVRFY, ViDeadlockAllocate)
#pragma alloc_text(PAGEVRFY, ViDeadlockFree)

#pragma alloc_text(PAGEVRFY, ViDeadlockReportIssue)
#pragma alloc_text(PAGEVRFY, ViDeadlockAddParticipant)

#pragma alloc_text(PAGEVRFY, ViDeadlockDeleteMemoryRange);
#pragma alloc_text(PAGEVRFY, ViDeadlockDeleteResource);
#pragma alloc_text(PAGEVRFY, ViDeadlockWholeTree);
#pragma alloc_text(PAGEVRFY, ViDeadlockIsNodeMarkedForDeletion);
#pragma alloc_text(PAGEVRFY, ViDeadlockGetNodeResourceAddress);

#endif
#endif

/////////////////////////////////////////////////////////////////////
///////////////////// Initialization and deadlock database management
/////////////////////////////////////////////////////////////////////


PLIST_ENTRY
ViDeadlockDatabaseHash( 
    IN PLIST_ENTRY Database,
    IN PVOID Address
    )
/*++

Routine Description:

    This routine determines hashes the resource address into the deadlock database.
    The hash bin is represented by a list entry
    
    silviuc: very simple minded hash table.

Arguments:

    ResourceAddress: Address of the resource that is being hashed
    
Return Value:

    PLIST_ENTRY -- the list entry associated with the hash bin we land in.
--*/    
{
    return Database + ((ULONG_PTR)Address % VI_DEADLOCK_HASH_BINS);
} 


VOID 
ViDeadlockDetectionInitialize(
    )
/*++

Routine Description:

    This routine initializes the data structures necessary for detecting
    deadlocks in kernel synchronization objects.

Arguments:

    None.

Return Value:

    None. Sets ViDeadlockDetectionInitialized to TRUE if successful.

Environment:

    System initialization only.

--*/    
{    
    ULONG I;
    SIZE_T TableSize;
    SIZE_T ParticipationTableSize;

    //
    // Allocate hash tables for resources and threads.
    //

    TableSize = sizeof (LIST_ENTRY) * VI_DEADLOCK_HASH_BINS;

    ViDeadlockResourceDatabase = ViDeadlockAllocate (TableSize);

    if (!ViDeadlockResourceDatabase) {
        return;
    }
        
    ViDeadlockThreadDatabase = ViDeadlockAllocate (TableSize);

    if (!ViDeadlockThreadDatabase) {
        ViDeadlockFree (ViDeadlockResourceDatabase);
        return;
    }

    //
    // Initialize all.
    //

    for (I = 0; I < VI_DEADLOCK_HASH_BINS; I += 1) {

        InitializeListHead(&ViDeadlockResourceDatabase[I]);    
        InitializeListHead(&ViDeadlockThreadDatabase[I]);    
    }

    KeInitializeSpinLock(&ViDeadlockDatabaseLock);

    ViDeadlockMaximumDegree = VI_DEADLOCK_MAXIMUM_DEGREE;

    ViDeadlockNumberParticipants = FALSE;    

    ViDeadlockDetectionInitialized = TRUE;
   //ViDeadlockDetectionEnabled = TRUE;
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// Deadlock detection logic
/////////////////////////////////////////////////////////////////////

BOOLEAN
ViDeadlockAnalyze(
    IN PVOID ResourceAddress,  
    IN PVI_DEADLOCK_NODE AcquiredNode,
    IN ULONG Degree
    )
/*++

Routine Description:

    This routine determines whether the acquisition of a certain resource
    could result in a deadlock.

    The routine assumes the deadlock database lock is held.

Arguments:

    ResourceAddress - address of the resource that will be acquired
    
    AcquiredNode - a graph describing which resources have been acquired by
    the current thread.
      
Return Value:
        
    True if deadlock detected, false otherwise.
          
--*/    
{

    PVI_DEADLOCK_RESOURCE CurrentResource;
    PVI_DEADLOCK_NODE CurrentAcquiredNode;
    PVI_DEADLOCK_NODE CurrentNode;
    PVI_DEADLOCK_NODE CurrentParent;
    BOOLEAN FoundDeadlock;
    PLIST_ENTRY Current;
    
    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread ());
    ASSERT (AcquiredNode);
    
    //
    // Stop recursion if it gets to deep.
    //
    
    if (Degree > ViDeadlockMaximumDegree) {
        return FALSE;
    }
    
    
    
    FoundDeadlock = FALSE;
    
    
    
    CurrentAcquiredNode = AcquiredNode;
    
    //
    // Loop over all nodes containing same resource as all of the Acquired nodes
    // parameter. For each such node we will traverse the Parent chain
    // to check if ResourceAddress appears at some point. If it does
    // we found a two way deadlock (caused by two threads). 
    //
    while(CurrentAcquiredNode != NULL) {        
        
        //
        // Check for a self cycle.
        //
        if (ViDeadlockGetNodeResourceAddress(CurrentAcquiredNode) == ResourceAddress) {
            
            ViDeadlockAddParticipant(ResourceAddress, NULL, CurrentAcquiredNode, Degree);
            FoundDeadlock = TRUE;
            goto Exit;
            
        }

        CurrentResource = CurrentAcquiredNode->Root;
        
        Current = CurrentResource->ResourceList.Flink;
        
        while (Current != &(CurrentResource->ResourceList)) {
            
            CurrentNode = CONTAINING_RECORD (Current,
                VI_DEADLOCK_NODE,
                ResourceList);
            
            CurrentParent = CurrentNode->Parent;
            
            //
            // Traverse the parent chain looking for two-way deadlocks.
            //
            
            while (CurrentParent != NULL) {
                
                if (ViDeadlockGetNodeResourceAddress(CurrentParent) == ResourceAddress) {
                    
                    FoundDeadlock = TRUE;
                                        

                    if (! Degree) {

                        ViDeadlockAddParticipant(ResourceAddress, 
                            NULL, 
                            CurrentAcquiredNode, 
                            Degree);

                        ViDeadlockAddParticipant(ResourceAddress, 
                            CurrentNode, 
                            CurrentParent, 
                            Degree);


                    } else {

                        ViDeadlockAddParticipant(ResourceAddress, 
                            AcquiredNode, 
                            CurrentParent, 
                            Degree);
                    }


                    
                    goto Exit;
                }
                
                CurrentParent = CurrentParent->Parent;
            }
            
            //
            // Move on to the next node (AcquiredNode->Root type of nodes).
            //
            
            Current = Current->Flink;
        }
        CurrentAcquiredNode = CurrentAcquiredNode->Parent;
    }
    
    CurrentAcquiredNode = AcquiredNode;
    
    while(CurrentAcquiredNode != NULL) {
        
        //
        // In order to find multiway deadlocks we traverse the Parent chain 
        // a second time and enter into recursion. This way we can detect 
        // cycles in the graph that are caused by multiple threads (up to Degree).
        //
        
        CurrentResource = CurrentAcquiredNode->Root;
        
        Current = CurrentResource->ResourceList.Flink;
        
        while (Current != &(CurrentResource->ResourceList)) {
            
            CurrentNode = CONTAINING_RECORD (Current,
                VI_DEADLOCK_NODE,
                ResourceList);
            
            //
            // Loop again over parents but this time get into recursion.
            // We could have done this in the loop above but we want to first search
            // completely the existing graph (tree actually) and only after that 
            // traverse it recursively.
            //
            
            CurrentParent = CurrentNode->Parent;
            
            while (CurrentParent != NULL) {
                
                FoundDeadlock = ViDeadlockAnalyze (ResourceAddress,
                    CurrentParent,
                    Degree + 1);
                
                if (FoundDeadlock) {
                    

                    if (! Degree) {

                        ViDeadlockAddParticipant(ResourceAddress, 
                            CurrentNode, 
                            CurrentParent, 
                            Degree);

                        ViDeadlockAddParticipant(ResourceAddress, 
                            NULL, 
                            CurrentAcquiredNode, 
                            Degree);
                        
                    

                        
                    } else {

                        ViDeadlockAddParticipant(ResourceAddress, 
                            AcquiredNode, 
                            CurrentParent, 
                            Degree);

                    }
                    

                    
                    goto Exit;
                }
                
                CurrentParent = CurrentParent->Parent;
            }
            
            //
            // Move on to the next node (AcquiredNode->Root type of nodes).
            //
            
            Current = Current->Flink;
        }

        CurrentAcquiredNode = CurrentAcquiredNode->Parent;
        
    }

    Exit:

    if (FoundDeadlock && Degree == 0) {
        
        ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_DEADLOCK_DETECTED,
                               (ULONG_PTR)ResourceAddress,
                               (ULONG_PTR)CurrentAcquiredNode,
                               0);
    }
 
    return FoundDeadlock;
#
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// Resource management
/////////////////////////////////////////////////////////////////////


PVI_DEADLOCK_RESOURCE 
ViDeadlockSearchResource(
    IN PVOID ResourceAddress
    )
/*++

Routine Description:

    This routine finds the resource descriptor structure for a 
    resource if one exists. 

Arguments:

    ResourceAddress: Address of the resource in question (as used by
       the kernel).

Return Value:

    PVI_DEADLOCK_RESOURCE structure describing the resource, if available,
    or else NULL

    Note. The caller of the function should hold the database lock.
    
--*/    

{
    PLIST_ENTRY ListHead;
    PLIST_ENTRY Current;
    PVI_DEADLOCK_RESOURCE Resource;

    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread ());

    ListHead = ViDeadlockDatabaseHash (ViDeadlockResourceDatabase, ResourceAddress);    

    if (IsListEmpty(ListHead)) {

        return NULL;
    }

    Current = ListHead->Flink;

    while (Current != ListHead) {

        Resource = CONTAINING_RECORD(Current,
                                     VI_DEADLOCK_RESOURCE,
                                     HashChainList);

        if (Resource->ResourceAddress == ResourceAddress) {

            return Resource;
        }

        Current = Current->Flink;
    }

    return NULL;         
} 


BOOLEAN
ViDeadlockAddResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    )
/*++

Routine Description:

    This routine adds an entry for a new resource to our deadlock detection 
    database.

Arguments:

    Resource: Address of the resource in question as used by the kernel.
    
    Type: Type of the resource.

Return Value:

    True if we created and initialized a new RESOURCE structure.
    
    Note. The caller of the function should not hold the database
    lock.

--*/    
{
    PLIST_ENTRY hashBin;
    PVI_DEADLOCK_RESOURCE resourceRoot;
    PVI_DEADLOCK_NODE resourceNode;
    KIRQL OldIrql;
    ULONG HashValue;

    //
    // If we aren't initialized or package is not enabled
    // we return immediately.
    //

    if (! (ViDeadlockDetectionInitialized && ViDeadlockDetectionEnabled)) {
        return FALSE;
    }

    //
    // Check if this resource was initialized before. 
    // This would be a bug.
    //

    LOCK_DEADLOCK_DATABASE( &OldIrql );

    resourceRoot = ViDeadlockSearchResource (Resource);

    if (resourceRoot) {
            
        ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION,
                               (ULONG_PTR)Resource,
                               (ULONG_PTR)resourceRoot,
                               0);

        UNLOCK_DEADLOCK_DATABASE( OldIrql);
        return TRUE;
    }

    UNLOCK_DEADLOCK_DATABASE( OldIrql);

    //
    // Allocate the memory for the root of the new resource's tree.
    //

    resourceRoot = ViDeadlockAllocate (sizeof(VI_DEADLOCK_RESOURCE));

    if (NULL == resourceRoot) {
        return FALSE;
    }

    RtlZeroMemory(resourceRoot, sizeof(VI_DEADLOCK_RESOURCE));

    //
    // Fill information about resource.
    //

    resourceRoot->Type = Type;
    resourceRoot->ResourceAddress = Resource;

    InitializeListHead (&resourceRoot->ResourceList);

    resourceRoot->NodeCount = 0;

    //
    // Capture the stack trace of the guy that creates the resource first.
    // This should happen when resource gets initialized.
    //

    RtlCaptureStackBackTrace (0, // silviuc: how many frames to skip?
                              VI_MAX_STACK_DEPTH,
                              resourceRoot->InitializeStackTrace,
                              &HashValue);

    //
    // Figure out which hash bin this resource corresponds to.
    //

    hashBin = ViDeadlockDatabaseHash(ViDeadlockResourceDatabase, Resource);
    
    //
    // Now add to the list corresponding to the current hash bin
    //  

    LOCK_DEADLOCK_DATABASE( &OldIrql );

    InsertHeadList(hashBin, 
                   &(resourceRoot->HashChainList));

    ViDeadlockNumberOfResources += 1;

    UNLOCK_DEADLOCK_DATABASE( OldIrql);

    return TRUE;    
}


BOOLEAN
ViDeadlockQueryAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    )
/*++

Routine Description:

    This routine makes sure that it is ok to acquire the resource without
    causing a deadlock. .

Arguments:

    Resource: Address of the resource in question as used by kernel.

    Type: Type of the resource.

Return Value:

    None.

--*/
{
    PKTHREAD CurrentThread;
    PVI_DEADLOCK_THREAD ThreadEntry;    
    KIRQL OldIrql;
    PVI_DEADLOCK_NODE CurrentNode;
    PVI_DEADLOCK_RESOURCE ResourceRoot;
    PLIST_ENTRY Current;
    BOOLEAN FoundDeadlock;
    ULONG DeadlockFlags;

    //
    // If we are not initialized or package is not enabled
    // we return immediately.
    //
    

    if (! (ViDeadlockDetectionInitialized && ViDeadlockDetectionEnabled)) {
        return FALSE;
    }
    
    FoundDeadlock = FALSE;

    CurrentThread = KeGetCurrentThread(); 

    DeadlockFlags = ViDeadlockResourceTypeInfo[Type];

    LOCK_DEADLOCK_DATABASE( &OldIrql );

    //
    // Look for this thread in our thread list. 
    // Add a new thread if it is not in the list.
    //

    ThreadEntry = ViDeadlockSearchThread (CurrentThread);

    if (ThreadEntry == NULL) {
        //
        // Threads without allocations can't cause deadlocks
        //
        goto Exit;
    }        

    //
    // Check if this resource is already in our database
    //
    
    ResourceRoot = ViDeadlockSearchResource (Resource);

    //
    // Resources that we haven't seen before can't cause deadlocks
    //
    if (ResourceRoot == NULL) {
        goto Exit;
    }


    ASSERT (ResourceRoot);
    ASSERT (ThreadEntry);

    //
    // Check if thread holds any resources.
    // Threads that don't have any resources
    // yet can't cause deadlocks
    //

    if (ThreadEntry->CurrentNode == NULL) {
        goto Exit;
    }


    //
    // If we get here, the current thread had already acquired resources.
    //
    
    //
    // Find whether the link already exists. We are looking for a direct
    // link between ThreadEntry->CurrentNode and Resource (parameter).
    //        
    
    Current = ThreadEntry->CurrentNode->ChildrenList.Flink;
    
    while (Current != &(ThreadEntry->CurrentNode->ChildrenList)) {
        
        CurrentNode = CONTAINING_RECORD (Current,
            VI_DEADLOCK_NODE,
            SiblingsList);
        
        if (ViDeadlockGetNodeResourceAddress(CurrentNode) == Resource) {
            
            //
            // We have found a link.
            // A link that already exists doesn't have to be
            // checked for a deadlock because it would have
            // been caught when the link was created...
            // so we can just update the pointers and exit.
            //
            
            ThreadEntry->CurrentNode = CurrentNode;
            
            goto Exit;
        }
        
        Current = Current->Flink;
    }
    
    //
    // Now we know that we're in it for the long haul .. 
    // doesn't cause a deadlock
    //
    
    CurrentNode = NULL;
    
    //
    // We will analyze deadlock if the resource just about to be acquired
    // was acquired before and there are nodes in the graph for the
    // resource.
    //
    
    
    
    if (ViDeadlockAnalyze(Resource,  ThreadEntry->CurrentNode, 0)) {
        
        //
        // Go back to ground 0 with this thread
        //
        ThreadEntry->CurrentNode = NULL;    
        FoundDeadlock = TRUE;
        
    }

    //
    //  Exit point.
    //

    Exit:     
    
    //
    // Release deadlock database and return.
    //

    UNLOCK_DEADLOCK_DATABASE( OldIrql );
    return FoundDeadlock;

}


BOOLEAN 
ViDeadlockSimilarNode (
    IN PVOID Resource,
    IN PKTHREAD Thread,
    IN PVOID * Trace,
    IN PVI_DEADLOCK_NODE Node
    )
{
    SIZE_T Index;

    if (Resource == ViDeadlockGetNodeResourceAddress(Node) &&
        Thread == Node->Thread) {

        Index = RtlCompareMemory (Trace, Node->StackTrace, sizeof (Node->StackTrace));

        if (Index == sizeof (Node->StackTrace)) {

            return TRUE;
        }
    }

    return FALSE;
}


VOID
ViDeadlockAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type        
    )
/*++

Routine Description:

    This routine makes sure that it is ok to acquire the resource without
    causing a deadlock. It will also update the resource graph with the new
    resource acquisition.

Arguments:

    Resource: Address of the resource in question as used by kernel.

    Type: Type of the resource.

Return Value:

    None.

--*/    
{
    PKTHREAD CurrentThread;
    PVI_DEADLOCK_THREAD ThreadEntry;    
    KIRQL OldIrql;
    PVI_DEADLOCK_NODE CurrentNode;
    PVI_DEADLOCK_RESOURCE ResourceRoot;
    PLIST_ENTRY Current;
    ULONG HashValue;
    ULONG DeadlockFlags;
    BOOLEAN CreatingRootNode = FALSE;
    PVOID Trace [VI_MAX_STACK_DEPTH];

    //
    // If we are not initialized or package is not enabled
    // we return immediately.
    //

    if (! (ViDeadlockDetectionInitialized && ViDeadlockDetectionEnabled)) {
        return;
    }
    
    CurrentThread = KeGetCurrentThread(); 

    DeadlockFlags = ViDeadlockResourceTypeInfo[Type];

    //
    // Capture stack trace. We will need it to figure out
    // if we've been in this state before. We will skip two frames
    // for ViDeadlockAcquireResource and the verifier thunk that
    // calls it.
    //


    RtlZeroMemory (Trace, sizeof Trace);

    RtlCaptureStackBackTrace (
        2,
        VI_MAX_STACK_DEPTH,
        Trace,
        &HashValue);

    //
    // Lock the deadlock database.
    //

    LOCK_DEADLOCK_DATABASE( &OldIrql );

    //
    // Look for this thread in our thread list. 
    // Add a new thread if it is not in the list.
    //

    ThreadEntry = ViDeadlockSearchThread (CurrentThread);

    if (ThreadEntry == NULL) {

        //
        // Note that ViDeadlockAddThread will drop the lock
        // while allocating memory and then reacquire it.
        //

        ThreadEntry = ViDeadlockAddThread (CurrentThread);

        if (ThreadEntry == NULL) {

            //
            // If we cannot allocate a new thread entry then 
            // no deadlock detection will happen.
            //

            UNLOCK_DEADLOCK_DATABASE( OldIrql );
            return;
        }
    }

    //
    // Check if this resource is already in our database
    //
    
    ResourceRoot = ViDeadlockSearchResource (Resource);

    if (ResourceRoot == NULL) {

        //
        // Could not find the resource descriptor.
        // 

        
        if ((DeadlockFlags & VI_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION)) {

            //
            // Certain resource types have no initialization function ..
            // in which case we'll get an 'acquire' without an 'add' 
            // first -- this is entirely OK
            //            

            UNLOCK_DEADLOCK_DATABASE( OldIrql );

            if (FALSE == ViDeadlockAddResource(Resource, Type) ) {
                return;
            }            

            LOCK_DEADLOCK_DATABASE( &OldIrql );
            
            //
            // Note that even though we dropped the lock, we don't have 
            // to reobtain the thread entry pointer -- since thread
            // entry for the current thread can't have gone away.
            //

            ResourceRoot = ViDeadlockSearchResource (Resource);


        } else {
            
            // 
            // This resource type does have an initialization function --
            // and it wasn't called. This is bad.            
            //
            
            ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE,
                                   (ULONG_PTR)Resource,
                                   0,
                                   0);

            //
            // ISSUE (silviuc) Difficult to recover from this failure.
            // We will complain during release that resource was not acquired.
            //

            ThreadEntry->CurrentNode = NULL;
            
            UNLOCK_DEADLOCK_DATABASE( OldIrql );            
            return;
        }
    }
    
    //
    // At this point we have a THREAD and a RESOURCE to play with.
    // In addition we are just about to acquire the resource which means
    // there should not be another thread owning it.
    //

    ASSERT (ResourceRoot);
    ASSERT (ThreadEntry);
    ASSERT (NULL == ResourceRoot->ThreadOwner);

    //
    // Check if thread holds any resources. If it does we will have to determine
    // at that local point in the dependency graph if we need to create a
    // new node. If this is the first resource acquired by the thread we need
    // to create a new root node or reuse one created in the past.
    //
    // A node created in the past will match the current situation if the same 
    // thread acquires, the same resource is acquired and the stack traces match.
    // A node represents a triad (Thread, Resource, StackTrace).
    //
    
    if (ThreadEntry->CurrentNode != NULL) {

        //
        // If we get here, the current thread had already acquired resources.
        // Must now do three things ... 
        //
        // 1. if link already exists, update pointers and exit
        // 2. otherwise create a new node
        // 3. check for deadlocks
        //

        //
        // Find whether the link already exists. We are looking for a direct
        // link between ThreadEntry->CurrentNode and Resource (parameter).
        //        

        Current = ThreadEntry->CurrentNode->ChildrenList.Flink;

        while (Current != &(ThreadEntry->CurrentNode->ChildrenList)) {

            CurrentNode = CONTAINING_RECORD (Current,
                                             VI_DEADLOCK_NODE,
                                             SiblingsList);

            Current = Current->Flink;
            
            if (ViDeadlockSimilarNode (Resource, CurrentThread, Trace, CurrentNode)) {

                //
                // We have found a link.
                // A link that already exists doesn't have to be
                // checked for a deadlock because it would have
                // been caught when the link was created...
                // so we can just update the pointers to reflect the new
                // resource acquired and exit.
                //

                ThreadEntry->CurrentNode = CurrentNode;

                goto Exit;
            }
        }

        //
        // Now we know that we're in it for the long haul .. we must create a new
        // link and make sure that it doesn't cause a deadlock
        //

        CurrentNode = NULL;

        //
        // We will analyze deadlock if the resource just about to be acquired
        // was acquired before and there are nodes in the graph for the
        // resource.
        //

        if (ResourceRoot->NodeCount > 0) {

            if (ViDeadlockAnalyze(Resource,  ThreadEntry->CurrentNode, 0)) {      

                //
                // Go back to ground 0 with this thread if a deadlock has been
                // detected.
                //

                ThreadEntry->CurrentNode = NULL;
                ResourceRoot->ThreadOwner = NULL;
                goto Exit;
            }
        }
    }
    else {

        //
        // Thread does not have any resources acquired. We have to figure out
        // if this is a scenario we have encountered in the past by looking
        // at all nodes (that are roots) for the resource to be acquired.
        //

        PLIST_ENTRY Current;
        PVI_DEADLOCK_NODE Node;
        BOOLEAN FoundNode = FALSE;

        Current = ResourceRoot->ResourceList.Flink;

        while (Current != &(ResourceRoot->ResourceList)) {

            Node = CONTAINING_RECORD (Current,
                                      VI_DEADLOCK_NODE,
                                      ResourceList);

            Current = Node->ResourceList.Flink;

            if (Node->Parent == NULL) {

                if (ViDeadlockSimilarNode (Resource, CurrentThread, Trace, Node)) {

                    FoundNode = TRUE;
                    break;
                }
            }
        }

        if (FoundNode) {

            ThreadEntry->CurrentNode = Node;
            goto Exit;
        }
        else {

            CreatingRootNode = TRUE;
        }

    }

    //
    // At this moment we know for sure the new link will not cause
    // a deadlock. We will create the new resource node.
    //

    CurrentNode = ViDeadlockAllocate (sizeof (VI_DEADLOCK_NODE));

    if (CurrentNode != NULL) {

        //
        // Initialize the new resource node
        //            

        RtlZeroMemory (CurrentNode, sizeof *CurrentNode);

        CurrentNode->Parent = ThreadEntry->CurrentNode;

        CurrentNode->Root = ResourceRoot;

        InitializeListHead (&(CurrentNode->ChildrenList));

        //
        // Add to the children list of the parent.
        //        

        if (! CreatingRootNode) {
            
            InsertHeadList(&(ThreadEntry->CurrentNode->ChildrenList), 
                           &(CurrentNode->SiblingsList));
        }

        //
        // Register the new resource node in the list of nodes maintained
        // for this resource.
        //

        InsertHeadList(&(ResourceRoot->ResourceList), 
                       &(CurrentNode->ResourceList));

        ResourceRoot->NodeCount += 1;

        //
        // Update NodeCount for all NODEs all the way up to the
        // root of the tree.
        //

        {
            PVI_DEADLOCK_NODE Parent;

            Parent = CurrentNode->Parent;

            while (Parent != NULL) {

                Parent->NodeCount += 1;

                Parent = Parent->Parent;
            }
        }
    }

    //
    // Update current resource held by thread.
    //
    // NOTE -- Do this even if the allocation FAILS --
    // Since when the resource is released, we won't
    // recognize it (since the node could not be allocated)
    // and we'll bugcheck. 
    //

    ThreadEntry->CurrentNode = CurrentNode;

    //
    //  Exit point.
    //

    Exit: 

    //
    // Add information we use to identify the culprit should
    // a deadlock occur
    //            

    if (CurrentNode) {
        
        CurrentNode->Thread = CurrentThread;
        ResourceRoot->ThreadOwner = CurrentThread;

        RtlCopyMemory (CurrentNode->StackTrace, Trace, sizeof Trace);
    }
    
    //
    // Release deadlock database and return.
    //

    UNLOCK_DEADLOCK_DATABASE( OldIrql );
    return;
}


VOID 
ViDeadlockReleaseResource(
    IN PVOID Resource
    )
/*++

Routine Description:

    This routine does the maintenance necessary to release resources from our 
    deadlock detection database.    

Arguments:

    Resource: Address of the resource in question.    

Return Value:

    None.
--*/    

{
    PKTHREAD CurrentThread;
    PVI_DEADLOCK_THREAD ThreadEntry;    
    KIRQL OldIrql;
    PVI_DEADLOCK_NODE CurrentNode;
    PVI_DEADLOCK_RESOURCE ResourceRoot;

    ASSERT (ViDeadlockDatabaseOwner != KeGetCurrentThread());
    
    //
    // If we aren't initialized or package is not enabled
    // we return immediately.
    //

    if (! (ViDeadlockDetectionInitialized && ViDeadlockDetectionEnabled)) {
        return;
    }

    CurrentThread = KeGetCurrentThread();

    LOCK_DEADLOCK_DATABASE( &OldIrql );

    ResourceRoot = ViDeadlockSearchResource (Resource);

    if (ResourceRoot == NULL) {
        //
        // This is probably bad but we con't complain since
        // we may have faild an allocation -- we don't want
        // to accuse somebody of foul play just because
        // our allocation function failed
        //
        // ISSUE (silviuc): should complain if no allocation ever failed.
        //
        UNLOCK_DEADLOCK_DATABASE( OldIrql );
        return;
    }
    
    if (ResourceRoot->ThreadOwner == NULL) {
        //
        // Most likely someone is releasing a resource that
        // was never acquired. However the other possibility
        // is that we have failed an allocation. So we can't 
        // complain -- but we can't really do anything either
        //
        // ISSUE (silviuc): should complain if no allocation ever failed.
        //
        UNLOCK_DEADLOCK_DATABASE( OldIrql );
        return;
    }

    //
    // Look for this thread in our thread list,
    // Note we are looking actually for the thread
    // that acquired the resource -- not the current one
    // It should, in fact be the current one, but if 
    // the resource is being released in a different thread 
    // from the one it was acquired in, we need the original.
    //
    
    ThreadEntry = ViDeadlockSearchThread (ResourceRoot->ThreadOwner);
    
    if (NULL == ThreadEntry) {
        //
        // This can happen when we recover from an unexpected release --
        // there is still a therad owner for the resource but we nuked the
        // thread entry.
        // Indicate that we no longer hold this resource.
        //
        // ISSUE (silviuc): So, we do not need to complain here ?
        //
        ResourceRoot->ThreadOwner = NULL;        
        UNLOCK_DEADLOCK_DATABASE( OldIrql );
        return;
    }


    if (ResourceRoot->ThreadOwner != CurrentThread) {
        
        //
        // Someone acquired a resource but it was
        // released in another thread. This is bad 
        // design.
        //                

        DbgPrint("Thread %p acquired resource %p but thread %p released it\n",            
           ThreadEntry->Thread, Resource, CurrentThread );        
       
        ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_UNEXPECTED_THREAD,                               
                               (ULONG_PTR)ResourceRoot,
                               (ULONG_PTR)ThreadEntry,                               
                               (ULONG_PTR)ViDeadlockSearchThread(CurrentThread)
                               );
        //
        // If we don't want this to be fatal, in order to 
        // continue we must pretend that the current
        // thread is the resource's owner.
        //
        CurrentThread = ResourceRoot->ThreadOwner;
    

    }                

    //
    // Wipe out the resource owner since resource will be released.
    //
    
    ResourceRoot->ThreadOwner = NULL;

    //
    // Check the case where the thread does not appear to hold a resource.
    // ISSUE (silviuc): We kind of cluttered the code to make it restartable
    // after an error. It might be better to clean it up even if not restartable.
    //

    if(NULL == ThreadEntry->CurrentNode) {

        //
        // This will happen when we recover from a deadlock        
        //        

        UNLOCK_DEADLOCK_DATABASE( OldIrql );
        return;
    
    }    
    
    //
    // All nodes must have a root -- just make sure because we're deref'ing
    // it in a minute
    //
    
    ASSERT (ThreadEntry->CurrentNode->Root);    

    //
    // Found the thread list entry 
    //
    
    if (ViDeadlockGetNodeResourceAddress(ThreadEntry->CurrentNode) != Resource) {
        
        //
        // Getting here means that soembody acquires a then b then tries
        // to release b before a. This is bad.        
        //
        //
        // ISSUE (jtigani): -- flesh out reporting -- so we can prove that this
        // actually happenned.
        //        
        DbgPrint("ERROR: Must release resources in reverse-order\n");
        DbgPrint("Resource %p acquired before resource %p -- \n"
                 "Current thread is trying to release it first\n",
                 Resource, 
                 ViDeadlockGetNodeResourceAddress(ThreadEntry->CurrentNode));

        
        ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_UNEXPECTED_RELEASE,
            (ULONG_PTR)Resource,
            (ULONG_PTR)ThreadEntry->CurrentNode,
            (ULONG_PTR)CurrentThread);

        //
        // The thread state is hosed. 
        // Try to keep going.
        // 
        
        ThreadEntry->CurrentNode = NULL;        

    } else {
        
        //
        // Indicate that we have released the curent node
        //
        ThreadEntry->CurrentNode = ThreadEntry->CurrentNode->Parent;    
        
    }
        
    //
    // If thread does not hold resources anymore we will destroy the
    // thread information.
    //
    
    if (ThreadEntry->CurrentNode == NULL) {
        
        ViDeadlockDeleteThread (ThreadEntry);
    }
    

    UNLOCK_DEADLOCK_DATABASE(OldIrql);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Thread management
/////////////////////////////////////////////////////////////////////

PVI_DEADLOCK_THREAD
ViDeadlockSearchThread (
    PKTHREAD Thread
    )
/*++

Routine Description:

    This routine searches for a thread in the thread database.
    
    The function assumes the deadlock database lock is held.

Arguments:

    Thread - thread address

Return Value:

    Address of VI_DEADLOCK_THREAD structure if thread was found.
    Null otherwise.
    
--*/    
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_THREAD ThreadInfo;
    PLIST_ENTRY HashBin;

    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread ());

    ThreadInfo = NULL;

    HashBin = ViDeadlockDatabaseHash(ViDeadlockThreadDatabase, Thread);

    if (IsListEmpty(HashBin)) {
        return NULL;
    }

    Current = HashBin->Flink;

    while (Current != HashBin) {

        ThreadInfo = CONTAINING_RECORD (Current,
                                        VI_DEADLOCK_THREAD,
                                        ListEntry);

        if (ThreadInfo->Thread == Thread) {
            return ThreadInfo;
        }

        Current = Current->Flink;
    }

    return NULL;
}


PVI_DEADLOCK_THREAD
ViDeadlockAddThread (
    PKTHREAD Thread
    )
/*++

Routine Description:

    This routine adds a new thread to the thread database.
    
    The function assumes the deadlock database lock is held. It will
    drop the lock while allocating memory for the thread structure and
    then reacquire the lock. Special attention in the caller of this 
    function (ViDeadlockAcquireResource) because any internal pointer
    should be reobtained since the lock was dropped.

Arguments:

    Thread - thread address 

Return Value:

    Address of the VI_DEADLOCK_THREAD resource just added.
    Null if allocation failed.
--*/    
{
    KIRQL OldIrql;
    PVI_DEADLOCK_THREAD ThreadInfo;
    PLIST_ENTRY HashBin;

    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread ());

    //
    // It is safe to play with OldIrql like below because this function
    // is called from ViDeadlockAcquireResource with irql raised at DPC
    // level.
    //

    OldIrql = DISPATCH_LEVEL;

    UNLOCK_DEADLOCK_DATABASE (OldIrql);

    ThreadInfo = ViDeadlockAllocate (sizeof(VI_DEADLOCK_THREAD));

    LOCK_DEADLOCK_DATABASE (&OldIrql);

    if (ThreadInfo == NULL) {
        return NULL;
    }

    RtlZeroMemory (ThreadInfo, sizeof *ThreadInfo);

    ThreadInfo->Thread = Thread;

    HashBin = ViDeadlockDatabaseHash(ViDeadlockThreadDatabase, Thread);

    InsertHeadList (HashBin, 
                    &ThreadInfo->ListEntry);

    ViDeadlockNumberOfThreads += 1;

    return ThreadInfo;
}


VOID
ViDeadlockDeleteThread (
    PVI_DEADLOCK_THREAD Thread
    )
/*++

Routine Description:

    This routine deletes a thread.

Arguments:

    Thread - thread address

Return Value:

    None.
--*/    
{
    KIRQL OldIrql;
    VI_DEADLOCK_THREAD ThreadInfo;
    PLIST_ENTRY Current;
    BOOLEAN Result;
    PKTHREAD CurrentThread;
    PLIST_ENTRY HashBin;

    CurrentThread = KeGetCurrentThread ();

    ASSERT (ViDeadlockDatabaseOwner == CurrentThread);
    ASSERT (Thread && Thread->Thread == CurrentThread);
    ASSERT (Thread->CurrentNode == NULL);

    RemoveEntryList (&(Thread->ListEntry));

    ViDeadlockNumberOfThreads -= 1;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Allocate/Free
/////////////////////////////////////////////////////////////////////

PVOID
ViDeadlockAllocate (
    SIZE_T Size
    )
{
    return ExAllocatePoolWithTag(NonPagedPool, Size, VI_DEADLOCK_TAG);
}

VOID
ViDeadlockFree (
    PVOID Object
    )
{
    ExFreePool (Object);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Error reporting and debugging
/////////////////////////////////////////////////////////////////////

ULONG ViDeadlockDebug = 0x01;

VOID
ViDeadlockReportIssue (
    ULONG_PTR Param1,
    ULONG_PTR Param2,
    ULONG_PTR Param3,
    ULONG_PTR Param4
    )
{
    

    if ((ViDeadlockDebug & 0x01)) {

        DbgPrint ("Verifier: deadlock: stop: %u %p %p %p %p \n",
                  DRIVER_VERIFIER_DETECTED_VIOLATION,
                  Param1,
                  Param2,
                  Param3,
                  Param4);

        DbgBreakPoint ();
    }
    else {

        KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                      Param1,
                      Param2,
                      Param3,
                      Param4);
    }

    ViDeadlockNumberParticipants = FALSE;
}


VOID
ViDeadlockAddParticipant(
    PVOID ResourceAddress,              
    PVI_DEADLOCK_NODE FirstParticipant, OPTIONAL
    PVI_DEADLOCK_NODE SecondParticipant, 
    ULONG Degree
    )
{
    ULONG Participants;
    
    if (0 == ViDeadlockNumberParticipants) {        

        Participants = Degree + 2;        

        ViDeadlockParticipation = ViDeadlockAllocate(
            sizeof(VI_DEADLOCK_PARTICIPANT) * (2 * Participants + 1)
            );
        RtlZeroMemory(
            ViDeadlockParticipation, 
            sizeof(VI_DEADLOCK_PARTICIPANT) * (2 * Participants + 1)
            );        
            


        DbgPrint("|**********************************************************************\n");
        DbgPrint("|** \n");
        DbgPrint("|** Deadlock detected trying to acquire synchronization object at \n");
        DbgPrint("|** address %p (%d-way deadlock)\n",
            ResourceAddress,
            Participants            
            );

        if (ViDeadlockParticipation) {
            DbgPrint("|** For more information, type \n");            
            DbgPrint("|**    !deadlock\n");
            DbgPrint("|** \n");
            DbgPrint("|**********************************************************************\n");


        } else {
            DbgPrint("|** More information is not available because memory could\n");            
            DbgPrint("|**    not be allocated to save the state information");
            DbgPrint("|** \n");
            DbgPrint("|**********************************************************************\n");
            
            return;
        }

        
       
    }    
#if 0
    DbgPrint ("Verifier: deadlock: message: participant1 @ %p, participant2 @ %p, \n",
              (FirstParticipant) ?
                    ViDeadlockGetNodeResourceAddress(FirstParticipant) :
                    ResourceAddress, 
                    
              ViDeadlockGetNodeResourceAddress(SecondParticipant)
              );
#endif
    if (FirstParticipant) {
        
        ViDeadlockParticipation[ViDeadlockNumberParticipants].NodeInformation = 
            TRUE;
        ViDeadlockParticipation[ViDeadlockNumberParticipants].Participant = 
            FirstParticipant;

    } else {

        ViDeadlockParticipation[ViDeadlockNumberParticipants].NodeInformation = 
            FALSE;
        ViDeadlockParticipation[ViDeadlockNumberParticipants].Participant = 
            ViDeadlockSearchResource(ResourceAddress);

    }

    ViDeadlockParticipation[ViDeadlockNumberParticipants+1].NodeInformation = 
        TRUE;
    ViDeadlockParticipation[ViDeadlockNumberParticipants+1].Participant = 
        SecondParticipant;

    ViDeadlockNumberParticipants +=2;
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// Resource cleanup
/////////////////////////////////////////////////////////////////////


VOID 
ViDeadlockDeleteMemoryRange(
    IN PVOID Address,
    IN SIZE_T Size
    )
/*++

Routine Description:

    This routine is called whenever some region of kernel virtual space
    is no longer valid. We need this hook because most kernel resources
    do not have a "delete resource" function and we need to figure out
    what resources are not valid. Otherwise our dependency graph will 
    become populated by many zombie resources.
    
    The important moments when the function gets called are ExFreePool
    (and friends) and driver unloading. Dynamic and static memory are the
    main regions where a resource gets allocated. There can be the possibility
    of a resource allocated on the stack but this is a very weird scenario.
    We might need to detect this and flag it as a potential issue. 
    
    If a resource or thread lives within the range specified then all graph
    paths with nodes reachable from the resource or thread will be wiped out.
    
    ISSUE (silviuc). This policy might lose some cases. 
    For instance if T1 acquires ABC,
    then C is deleted and then T2 acquires BA this is a potential deadlock but
    we will not catch it because when C gets deleted the whole ABC path will
    disappear. Right now we have no solution for that. If we do not delete there
    is no way we can decide when to wipe regions of the graph withouth creating
    accumulations of zombies. One solution would be to keep nodes around and delete
    them only if all nodes in the tree are supposed to be deleted.

Arguments:

    Address - start address of the range to be deleted.
    
    Size - size in bytes of the range to be deleted.

Return Value:

    None. 

--*/    
{
    ULONG Index;
    PLIST_ENTRY Current;
    PVI_DEADLOCK_RESOURCE Resource;
    PVI_DEADLOCK_THREAD Thread;
    KIRQL OldIrql;

    LOCK_DEADLOCK_DATABASE(&OldIrql)
    
    //
    // Iterate all resources and delete the ones contained in the
    // memory range.
    //

    for (Index = 0; Index < VI_DEADLOCK_HASH_BINS; Index += 1) {

        Current = ViDeadlockResourceDatabase[Index].Flink;

        while (Current != &(ViDeadlockResourceDatabase[Index])) {


            Resource = CONTAINING_RECORD (Current,
                                          VI_DEADLOCK_RESOURCE,
                                          HashChainList);

            Current = Current->Flink;

            if ((PVOID)(Resource->ResourceAddress) >= Address &&
                ((ULONG_PTR)(Resource->ResourceAddress) <= ((ULONG_PTR)Address + Size))) {

                ViDeadlockDeleteResource (Resource);
            }
        }
    }

    //
    // Iterate all threads and delete the ones contained in the 
    // memory range. Note that it is actually a bug if we find a
    // thread to be deleted because this means thread is dying while
    // holding some resources.
    //

    for (Index = 0; Index < VI_DEADLOCK_HASH_BINS; Index += 1) {

        Current = ViDeadlockThreadDatabase[Index].Flink;

        while (Current != &(ViDeadlockThreadDatabase[Index])) {


            Thread = CONTAINING_RECORD (Current,
                                        VI_DEADLOCK_THREAD,
                                        ListEntry);

            Current = Current->Flink;

            if ((PVOID)(Thread->Thread) >= Address &&
                ((ULONG_PTR)(Thread->Thread) <= ((ULONG_PTR)Address + Size))) {

                ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES,
                                       (ULONG_PTR)Thread,
                                       (ULONG_PTR)(Thread->CurrentNode),
                                       0); 
            }
        }
    }


    UNLOCK_DEADLOCK_DATABASE(OldIrql)
}


BOOLEAN
ViDeadlockIsNodeMarkedForDeletion (
    PVI_DEADLOCK_NODE Node
    )
{
    ASSERT (Node);

    if (Node->ResourceList.Flink == NULL) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


PVOID
ViDeadlockGetNodeResourceAddress (
    PVI_DEADLOCK_NODE Node
    )
{
    if (ViDeadlockIsNodeMarkedForDeletion(Node)) {
        return Node->ResourceAddress;
    }
    else {
        return Node->Root->ResourceAddress;
    }
}

VOID
ViDeadlockDeleteResource (
    PVI_DEADLOCK_RESOURCE Resource
    )
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_NODE Node;
    PVI_DEADLOCK_NODE Parent;
    PVI_DEADLOCK_NODE Root;

    ASSERT (Resource != NULL);

    //
    // Traverse the list of nodes representing acquisition of this resource
    // and mark them all as deleted. If the NodeCount of the root becomes zero
    // then we can delete the whole tree under the root.
    //

    Current = Resource->ResourceList.Flink;

    while (Current != &(Resource->ResourceList)) {

        Node = CONTAINING_RECORD (Current,
                                  VI_DEADLOCK_NODE,
                                  ResourceList);


        Current = Current->Flink;

        //
        //  Mark node as deleted
        //

        Node->ResourceList.Flink = NULL;
        Node->ResourceList.Blink = NULL;
        Node->ResourceAddress = Node->Root->ResourceAddress;

        //
        // Update NodeCount all the way to the root.
        //

        Parent = Node->Parent;
        Root = Node;

        while (Parent != NULL) {

            Parent->NodeCount -= 1;

            Root = Parent;
            Parent = Parent->Parent;
        }

        //
        // If all nodes in the tree have been marked as deleted
        // it is time to delete and deallocate the whole tree.
        //

        if (Root->NodeCount == 0) {

            ViDeadlockDeleteTree (Root);
        }
    }

    //
    // Delete the resource structure.
    //

    ViDeadlockFree (Node->Root);
}


VOID
ViDeadlockDeleteTree (
    PVI_DEADLOCK_NODE Root
    )
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_NODE Node;

    Current = Root->ChildrenList.Flink;

    while (Current != &(Root->ChildrenList)) {

        Node = CONTAINING_RECORD (Current,
                                  VI_DEADLOCK_NODE,
                                  SiblingsList);

        Current = Current->Flink;

        ViDeadlockDeleteTree (Node);
    }

    ViDeadlockFree (Root);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\locktest.h ===
#ifndef _LOCKTEST_H_INCLUDED_
#define _LOCKTEST_H_INCLUDED_

VOID DeadlockPositiveTest (
    PVOID NotUsed
    );

VOID DeadlockNegativeTest (
    PVOID NotUsed
    );

VOID DeadlockStressTest (
    PVOID NotUsed
    );

#endif // #ifndef _LOCKTEST_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\contmem.c ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  contmem.c
// Author:  Daniel Mihai (DMihai)
// Created: 6/19/1999 2:39pm
//
// This module contains tests for MmAllocateContiguousMemorySpecifyCache.
//
// --- History ---
//
// 6/19/1999 (DMihai): initial version.
//

#include <ntddk.h>

#include "active.h" 
#include "ContMem.h"

#if !CONTMEM_ACTIVE

VOID
TdMmAllocateContiguousMemorySpecifyCacheTest(
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: contmem test is disabled \n");
}

#else 

/////////////////////////////////////////////////////////////////////////
//
// data structures
//

typedef struct _tag_cont_mem_test_variation
{
    SIZE_T sizeChunk;
    PHYSICAL_ADDRESS phaLowestAcceptableAddress;
    PHYSICAL_ADDRESS phaHighestAcceptableAddress;
    PHYSICAL_ADDRESS phaBoundaryAddressMultiple;
    MEMORY_CACHING_TYPE CacheType;
} ContMemTestVariation, *PContMemTestVariation;

/////////////////////////////////////////////////////////////////////////
//
// test variations
//

// TEST TEST
ContMemTestVariation aTestVariations[ 864 ];
// ContMemTestVariation aTestVariations[ 54 ];
// TEST TEST

/////////////////////////////////////////////////////////////////////////
//
// private functions declaration
//

void
FillVariationsBuffer();

void
InitializeVariation(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType );
 
void
InitializeVariationBound1Page(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType );

void
InitializeVariationBoundFourthTimeSize(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType );


/////////////////////////////////////////////////////////////////////////
//
// public functions
//

void
TdMmAllocateContiguousMemorySpecifyCacheTest(
    PVOID NotUsed
    )
{
    int nVariations;
    int nCrtVariation;
    ULONG_PTR nNumPages;
    ULONG_PTR nCrtPage;
    PVOID pBuffer;
    PHYSICAL_ADDRESS phaCrtPage;
    PHYSICAL_ADDRESS phaPrevPage;
    PUCHAR pcCrtPage;

    //
    // setup the variations data
    //

    FillVariationsBuffer();

    //
    // loop fo every variation structure
    //

    nVariations = ARRAY_LENGTH( aTestVariations );

    //while( TRUE )
    {
        for( nCrtVariation = 0; nCrtVariation < nVariations; nCrtVariation++ )
        {
            //
            // output the current variation's parameters
            //

            DbgPrint( "Variation %d: (%p, %I64X, %I64X, %I64X, %s)\n",
                nCrtVariation,

                aTestVariations[ nCrtVariation ].sizeChunk,

                aTestVariations[ nCrtVariation ].phaLowestAcceptableAddress.QuadPart,
                aTestVariations[ nCrtVariation ].phaHighestAcceptableAddress.QuadPart,
                aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple.QuadPart,

                (aTestVariations[ nCrtVariation ].CacheType == MmCached) ? "MmCached" : "MmNonCached" );

            //
            // try to allocate the buffer
            //

            pBuffer = MmAllocateContiguousMemorySpecifyCache(
                aTestVariations[ nCrtVariation ].sizeChunk,
                aTestVariations[ nCrtVariation ].phaLowestAcceptableAddress,
                aTestVariations[ nCrtVariation ].phaHighestAcceptableAddress,
                aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple,
                aTestVariations[ nCrtVariation ].CacheType );

            //
            // output the returned address
            //

            DbgPrint( "MmAllocateContiguousMemorySpecifyCache returned %p\n",
                pBuffer );

            //
            // sanity checks
            //

            if( pBuffer != NULL )
            {
                nNumPages = aTestVariations[ nCrtVariation ].sizeChunk / PAGE_SIZE;

                pcCrtPage = (PUCHAR)pBuffer;
            
                phaPrevPage.QuadPart = 0;

                for( nCrtPage = 0; nCrtPage < nNumPages; nCrtPage++ )
                {
                    //
                    // get the physical address for this page
                    //

                    phaCrtPage = MmGetPhysicalAddress( pcCrtPage );

                    if( phaCrtPage.QuadPart == 0 )
                    {
                        DbgPrint( "MmGetPhysicalAddress( %p ) returned NULL!\n" );
                    
                        DbgBreakPoint();
                    }
                    else
                    {
                        //
                        // check LowestAcceptableAddress
                        //

                        if( phaCrtPage.QuadPart < aTestVariations[ nCrtVariation ].phaLowestAcceptableAddress.QuadPart )
                        {
                            DbgPrint( "%p, physical %I64X, LowestAcceptableAddress = %I64X\n",
                                pcCrtPage,
                                phaCrtPage.QuadPart,
                                aTestVariations[ nCrtVariation ].phaLowestAcceptableAddress.QuadPart );
                        
                            DbgBreakPoint();
                        }
                        /*
                        // TEST TEST
                        else
                        {
                            DbgPrint( "%p, physical %I64X, LowestAcceptableAddress = %I64X -> OK\n",
                                pcCrtPage,
                                phaCrtPage.QuadPart,
                                aTestVariations[ nCrtVariation ].phaLowestAcceptableAddress.QuadPart );
                        }
                        // TEST TEST
                        */

                        //
                        // check HighestAcceptableAddress
                        //

                        if( phaCrtPage.QuadPart > aTestVariations[ nCrtVariation ].phaHighestAcceptableAddress.QuadPart )
                        {
                            DbgPrint( "%p, physical %I64X, HighestAcceptableAddress = %I64X\n",
                                pcCrtPage,
                                phaCrtPage.QuadPart,
                                aTestVariations[ nCrtVariation ].phaHighestAcceptableAddress.QuadPart );
                        
                            DbgBreakPoint();
                        }
                        /*
                        // TEST TEST
                        else
                        {
                            DbgPrint( "%p, physical %I64X, HighestAcceptableAddress = %I64X -> OK\n",
                                pcCrtPage,
                                phaCrtPage.QuadPart,
                                aTestVariations[ nCrtVariation ].phaHighestAcceptableAddress.QuadPart );
                        }
                        // TEST TEST
                        */

                        //
                        // check BoundaryAddressMultiple
                        //

                        if( aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple.QuadPart != 0 )
                        {
                            if( pcCrtPage != pBuffer &&     // not the first page
                                ( phaCrtPage.QuadPart % aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple.QuadPart ) == 0 )
                            {
                                DbgPrint( "%p, physical %I64X, BoundaryAddressMultiple = %I64X\n",
                                    pcCrtPage,
                                    phaCrtPage.QuadPart,
                                    aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple.QuadPart );
                        
                                DbgBreakPoint();
                            }
                            /*
                            // TEST TEST
                            else
                            {
                                DbgPrint( "%p, physical %I64X, BoundaryAddressMultiple = %I64X -> OK\n",
                                    pcCrtPage,
                                    phaCrtPage.QuadPart,
                                    aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple.QuadPart );
                            }
                            // TEST TEST
                            */
                        }

                        //
                        // verify that the pages are physically contiguous
                        //

                        if( phaPrevPage.QuadPart != 0 )
                        {
                            if( phaCrtPage.QuadPart - phaPrevPage.QuadPart != PAGE_SIZE )
                            {
                                DbgPrint( "%p, physical %I64X, previous physical page = %I64X\n",
                                    pcCrtPage,
                                    phaCrtPage.QuadPart,
                                    phaPrevPage.QuadPart );

                                DbgBreakPoint();
                            }
                            /*
                            // TEST TEST
                            else
                            {
                                DbgPrint( "%p, physical %I64X, previous physical page = %I64X -> OK\n",
                                    pcCrtPage,
                                    phaCrtPage.QuadPart,
                                    phaPrevPage.QuadPart );
                            }
                            // TEST TEST
                            */
                        }

                        //
                        // write something there
                        //

                        *pcCrtPage = 'x';

                        //
                        // keep track of the latest page
                        //

                        phaPrevPage = phaCrtPage;
                    }

                    //
                    // next page 
                    //

                    pcCrtPage += PAGE_SIZE;
                }
            
                //
                // free the buffer
                //

                MmFreeContiguousMemorySpecifyCache( 
                    pBuffer,
                    aTestVariations[ nCrtVariation ].sizeChunk,
                    aTestVariations[ nCrtVariation ].CacheType );
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////
//
// private functions
//

void
InitializeVariation(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType )
{
    pTestVar->sizeChunk = sizeChunk;
    pTestVar->phaLowestAcceptableAddress.QuadPart = phaLowestAcceptableAddress;
    pTestVar->phaHighestAcceptableAddress.QuadPart = phaHighestAcceptableAddress;
    pTestVar->phaBoundaryAddressMultiple.QuadPart = phaBoundaryAddressMultiple;
    pTestVar->CacheType = CacheType;
}

/////////////////////////////////////////////////////////////////////////

void
InitializeVariationBound1Page(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType )
{
    phaBoundaryAddressMultiple = (LONGLONG) sizeChunk + (LONGLONG) PAGE_SIZE;
    
    InitializeVariation(
        pTestVar,
        sizeChunk,
        phaLowestAcceptableAddress,
        phaHighestAcceptableAddress,
        phaBoundaryAddressMultiple,
        CacheType );
}

void
InitializeVariationBoundFourthTimeSize(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType )
{
    phaBoundaryAddressMultiple = (LONGLONG) sizeChunk * (LONGLONG) 4;
    
    InitializeVariation(
        pTestVar,
        sizeChunk,
        phaLowestAcceptableAddress,
        phaHighestAcceptableAddress,
        phaBoundaryAddressMultiple,
        CacheType );
}

/////////////////////////////////////////////////////////////////////////

void
FillVariationsBuffer()
{
    int nCrtVarIndex;

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-16 Mb limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 0 ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 1 ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 2 ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 3 ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 4 ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 5 ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 6 ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 7 ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 8 ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 9 ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 10 ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 11 ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 12 ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 13 ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 14 ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 15 ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 16 ],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 17 ],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-32 Mb limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 18 ], 
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 19 ],
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 20 ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 21 ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 22 ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 23 ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 24 ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 25 ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 26 ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 27 ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 28 ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 29 ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 30 ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 31 ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 32 ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 33 ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 34 ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 35 ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (2 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 36 ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 37 ],
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 38 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 39 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 40 ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 41 ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 42 ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 43 ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 44 ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 45 ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 46 ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 47 ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 48 ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 49 ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 50 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 51 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 52 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 53 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );


// TEST TEST
    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (4 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 54 ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 55 ],
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 56 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 57 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 58 ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 59 ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 60 ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 61 ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 62 ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 63 ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 64 ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 65 ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 66 ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 67 ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 68 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 69 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 70 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 71 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (8 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 72 ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 73 ],
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 74 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 75 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 76 ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 77 ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 78 ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 79 ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 80 ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 81 ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 82 ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 83 ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 84 ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 85 ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 86 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 87 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 88 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 89 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////
    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8-16 Mb limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 90 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 91 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 92 ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 93 ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 94 ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 95 ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 96 ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 97 ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 98 ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 99 ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 100 ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 101 ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 102 ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 103 ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 104 ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 105 ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 106 ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 107 ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - 32 Mb limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 108 ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 109 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 110 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 111 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 112 ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 113 ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 114 ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 115 ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 116 ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 117 ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 118 ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 119 ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 120 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 121 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 122 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 123 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 124 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 125 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (2 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 126 ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 127 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 128 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 129 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 130 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 131 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 132 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 133 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 134 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 135 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 136 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 137 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 138 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 139 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 140 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 141 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 142 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 143 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (4 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 144 ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 145 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 146 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 147 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 148 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 149 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 150 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 151 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 152 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 153 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 154 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 155 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 156 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 157 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 158 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 159 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 160 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 161 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (8 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 162 ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 163 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 164 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 165 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 166 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 167 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 168 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 169 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 170 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 171 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 172 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 173 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 174 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 175 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 176 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 177 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 178 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 179 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (2 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 180 ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 181 ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 182 ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 183 ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 184 ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 185 ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 186 ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 187 ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 188 ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 189 ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 190 ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 191 ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 192 ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 193 ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 194 ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 195 ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 196 ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 197 ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (4 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 198 ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 199 ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 200 ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 201 ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 202 ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 203 ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 204 ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    nCrtVarIndex = 205;

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (8 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 233
    //

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (4 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (8 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 269
    //

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 4 Gb - (8 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 287
    //

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-16 Mb limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;
    
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-32 Mb limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (2 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (4 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8-16 Mb limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - 32 Mb limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (2 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (4 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (2 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (4 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 233
    //

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (4 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 269
    //

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 4 Gb - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 575
    //

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-16 Mb limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;
    
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-32 Mb limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (2 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (4 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (8 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8-16 Mb limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - 32 Mb limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (2 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (4 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (8 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (2 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (4 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (8 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 233
    //

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (4 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (8 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 269
    //

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 4 Gb - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 863
    //

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    //////////////////////////////////////////
// TEST TEST
}

#endif // #if !CONTMEM_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\locktest.c ===
#include <ntddk.h>

#include "active.h"
#include "locktest.h"

#if LOCKTEST_ACTIVE

//
// Real implementation if the module is active
//

VOID DeadlockPositiveTest (
    PVOID NotUsed
    )
{
	DbgPrint ("Buggy: not implemented \n");
}


VOID DeadlockNegativeTest (
    PVOID NotUsed
    )
{
	DbgPrint ("Buggy: not implemented \n");
}

/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////// Stress test
/////////////////////////////////////////////////////////////////////

VOID 
StressLockHierarchy (
    ULONG NumberOfIterations,
    ULONG NumberOfResources,
    ULONG Probability,
    ULONG Seed,
    BOOLEAN InjectDeadlocks
    );

NTSYSAPI                                            // ntifs
ULONG                                               // ntifs
NTAPI                                               // ntifs
RtlRandom (                                         // ntifs
    PULONG Seed                                     // ntifs
    );                                              // ntifs


ULONG InjectDeadlocks;

VOID 
DeadlockStressTest (
    PVOID NotUsed
    )
{
    StressLockHierarchy (128, 
                         64,
                         20,
                         0, 
                         InjectDeadlocks ? TRUE : FALSE);
}

#define LOCK_ACQUIRED 0x0001
#define LOCK_DELETED  0x0002
#define LOCK_RANDOM   0x0004

ULONG Finish;

VOID 
StressLockHierarchy (
    ULONG NumberOfIterations,
    ULONG NumberOfResources,
    ULONG Probability,
    ULONG Seed,
    BOOLEAN InjectDeadlocks
    )
{
    PFAST_MUTEX * Locks; 
    PULONG Flags;
    ULONG I, J, K, Ri;
    BOOLEAN ShouldAcquire;
    BOOLEAN ShouldDelete;

    Locks = NULL;
    Flags = NULL;

    Locks = (PFAST_MUTEX *) ExAllocatePool (NonPagedPool, NumberOfResources * sizeof (PFAST_MUTEX));

    if (! Locks) {
        goto Exit;
    }

    Flags = (PULONG) ExAllocatePool (NonPagedPool, NumberOfResources * sizeof (ULONG));

    if (! Flags) {
        goto Exit;
    }

    RtlZeroMemory (Locks, NumberOfResources * sizeof (PFAST_MUTEX));
    RtlZeroMemory (Flags, NumberOfResources * sizeof (ULONG));

    for (I = 0; I < NumberOfResources; I += 1) {

        Locks[I] = ExAllocatePool (NonPagedPool, sizeof (FAST_MUTEX));

        if (! (Locks[I])) {
            goto Exit;
        }

        ExInitializeFastMutex (Locks[I]);
    }

    DbgPrint ("Starting test iterations ... \n");

    KeEnterCriticalRegion ();

    for (I = 0; I < NumberOfIterations; I += 1) {

        BOOLEAN DeadlockInjected = FALSE;

        if (InjectDeadlocks) {
            
            Ri = RtlRandom(&Seed) % NumberOfResources;

            if (! (Flags[Ri] & LOCK_DELETED)) {

                ExAcquireFastMutexUnsafe (Locks[Ri]);
                Flags[Ri] |= LOCK_ACQUIRED;
                Flags[Ri] |= LOCK_RANDOM;
                DeadlockInjected = TRUE;
            }
        }

        for (J = 0; J < NumberOfResources; J += 1) {
            
            if (Finish) {
                return;
            }

            if ((Flags[J] & LOCK_DELETED)) {
                DbgPrint (".");
                continue;
            }

            if ((Flags[J] & LOCK_RANDOM)) {
                DbgPrint ("*");
                continue;
            }

            ShouldDelete = ((RtlRandom(&Seed) % 1000) < 10) ? TRUE : FALSE;

            if (ShouldDelete) {
                
                DbgPrint ("D");

                // mark block in a special way so verifier version of ExFreePool
                // will know we are deleting a resource.

                *((PULONG)(Locks[J])) = 0xABCDDCBA;
                ExFreePool (Locks[J]);
                Locks[J] = NULL;
                Flags[J] |= LOCK_DELETED;
            }

            if ((Flags[J] & LOCK_DELETED)) {
                continue;
            }

            ShouldAcquire = ((RtlRandom(&Seed) % 100) < Probability) ? TRUE : FALSE;

            if (ShouldAcquire) {
                
                DbgPrint ("A");
                ExAcquireFastMutexUnsafe (Locks[J]);
                Flags[J] |= LOCK_ACQUIRED;
            }
            else {
                DbgPrint ("-");
            }
        }

        for (J = 0; J < NumberOfResources; J += 1) {

            if (Finish) {
                return;
            }

            // K = NumberOfResources - J - 1;
            K = J; // release in reverse order

            if ((Flags[K] & LOCK_DELETED)) {
                continue;
            }
            
            if ((Flags[K] & LOCK_RANDOM)) {
                continue;
            }

            if ((Flags[K] & LOCK_ACQUIRED)) {
                // DbgPrint ("R");
                ExReleaseFastMutexUnsafe (Locks[K]);
                Flags[K] &= ~LOCK_ACQUIRED;
            }
            else {
                // DbgPrint ("-");
            }
        }
        
        if (DeadlockInjected) {

            ExReleaseFastMutexUnsafe (Locks[Ri]);
            Flags[Ri] &= ~LOCK_ACQUIRED;
            Flags[Ri] &= ~LOCK_RANDOM;
        }

        // if (I && I % 100 == 0) {
            DbgPrint ("\n");
        // }
    }

    DbgPrint ("\n");

    KeLeaveCriticalRegion ();

    Exit:

    for (I = 0; I < NumberOfResources; I += 1) {
        if (Locks[I]) {
            
            // mark block in a special way so verifier version of ExFreePool
            // will know we are deleting a resource.

            *((PULONG)(Locks[I])) = 0xABCDDCBA;
            ExFreePool (Locks[I]);
        }
    }
    
    if (Locks) {
        ExFreePool (Locks);
    }
    
    if (Flags) {
        ExFreePool (Flags);
    }
}


#else

//
// Dummy implementation if the module is inactive
//

VOID DeadlockPositiveTest (
    PVOID NotUsed
    )
{
	DbgPrint ("Buggy: deadlock module is disabled \n");
}


VOID DeadlockNegativeTest (
    PVOID NotUsed
    )
{
	DbgPrint ("Buggy: deadlock module is disabled \n");
}

VOID DeadlockStressTest (
    PVOID NotUsed
    )
{
	DbgPrint ("Buggy: deadlock module is disabled \n");
}

#endif // #if !NEWSTUFF_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\contmem.h ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  contmem.h
// Author:  Daniel Mihai (DMihai)
// Created: 6/19/1999 2:39pm
//
// This module contains tests for MmAllocateContiguousMemorySpecifyCache.
//
// --- History ---
//
// 6/19/1999 (DMihai): initial version.
//

void
TdMmAllocateContiguousMemorySpecifyCacheTest(
    PVOID NotUsed
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\funs.h ===
//
// Buggy function declarations
// Copyright (c) Microsoft Corporation, 1999.
//
// Header:  funs.h
// Author:  Silviu Calinoiu (SilviuC)
// Created: 8/14/1999 2:52pm
//

//
// PLEASE READ IF YOU MODIFY THIS FILE !
//
// This header represents the communication mechanism between
// the source code for the driver and the one for the user mode
// controller of the driver. If you have a new operation to add 
// to the driver you have to fulfill the following steps:
//
// (1) Update the `IOCTL' section.
// (2) Update the `Functions' section.
// (3) Update the `Control' section.
//

#ifndef _FUNS_H_INCLUDED_
#define _FUNS_H_INCLUDED_

typedef VOID (* BUGGY_FUNCTION) (PVOID);

typedef struct {

    ULONG Ioctl;
    LPCTSTR Message;
    LPCTSTR Command;
    BUGGY_FUNCTION Function;

} BUGGY_IOCTL_HANDLER_INFORMATION;

#ifndef FUNS_DEFINITION_MODULE
extern BUGGY_IOCTL_HANDLER_INFORMATION BuggyFuns [];
#else

VOID DoNothing (PVOID NotUsed) {}

//
// IOCTL section
//
// In order to add a new IOCTL just declare it at the end of the section incrementing by
// one the last TD_IOCTL declaration.
//

#define TD_IOCTL(n) CTL_CODE(FILE_DEVICE_UNKNOWN, (2048 + (n)), METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

#define IOCTL_TD_NOTHING                                TD_IOCTL(0)
#define IOCTL_TD_BUGCHECK                               TD_IOCTL(1)
#define IOCTL_TD_POOL_STRESS                            TD_IOCTL(2)
#define IOCTL_TD_LOCK_SCENARIO                          TD_IOCTL(3)
#define IOCTL_BGCHK_PROCESS_HAS_LOCKED_PAGES            TD_IOCTL(4)
#define IOCTL_BGCHK_NO_MORE_SYSTEM_PTES                 TD_IOCTL(5)
#define IOCTL_BGCHK_BAD_POOL_HEADER                     TD_IOCTL(6)
#define IOCTL_BGCHK_DRIVER_CORRUPTED_SYSTEM_PTES        TD_IOCTL(7)
#define IOCTL_BGCHK_DRIVER_CORRUPTED_EXPOOL             TD_IOCTL(8)
#define IOCTL_BGCHK_DRIVER_CORRUPTED_MMPOOL             TD_IOCTL(9)
#define IOCTL_TD_IRQL_NOT_LESS_OR_EQUAL                 TD_IOCTL(10)
#define IOCTL_TD_PAGE_FAULT_BEYOND_END_OF_ALLOCATION    TD_IOCTL(11)
#define IOCTL_TD_DRIVER_VERIFIER_DETECTED_VIOLATION     TD_IOCTL(12)
#define IOCTL_TD_HANG_PROCESSOR                         TD_IOCTL(13)
#define IOCTL_TD_CORRUPT_SYSPTES                        TD_IOCTL(14)
#define IOCTL_TD_CONTIG_MEM_TEST                        TD_IOCTL(15)
#define IOCTL_TD_SECTION_MAP_TEST_PROCESS_SPACE         TD_IOCTL(16)
#define IOCTL_TD_SECTION_MAP_TEST_SYSTEM_SPACE          TD_IOCTL(17)
#define IOCTL_TD_COMMONBUFFER_STRESS                    TD_IOCTL(18)
#define IOCTL_TD_POOLFLAG_STRESS                        TD_IOCTL(19)
#define IOCTL_TD_ALLOCPCONTIG_STRESS                    TD_IOCTL(20)
#define IOCTL_TD_MMADDPMEM_STRESS                       TD_IOCTL(21)
#define IOCTL_TD_MMDELPMEM_STRESS                       TD_IOCTL(22)
#define IOCTL_TD_PMEM_SIMPLE_STRESS                     TD_IOCTL(23)
#define IOCTL_TEST_TRACEDB                              TD_IOCTL(24) 
#define IOCTL_TD_MMPROBELOCKFOREVER_STRESS              TD_IOCTL(25) 
#define IOCTL_TD_MMNAMETOADDR_STRESS                    TD_IOCTL(26) 
#define IOCTL_TD_MMECCBAD_STRESS                        TD_IOCTL(27) 
#define IOCTL_TD_MMMAPVSYSSPACE_LARGEST                 TD_IOCTL(28)
#define IOCTL_TD_MMMAPVSYSSPACE_TOTAL                   TD_IOCTL(29)
#define IOCTL_TD_MMMAPVSESSPACE_LARGEST                 TD_IOCTL(30)
#define IOCTL_TD_MMMAPVSESSPACE_TOTAL                   TD_IOCTL(31)
#define IOCTL_TD_SESSION_POOL_TEST                      TD_IOCTL(32)

#define IOCTL_TD_DEADLOCK_MECHANISM_POSITIVE_TEST       TD_IOCTL(33)
#define IOCTL_TD_DEADLOCK_MECHANISM_NEGATIVE_TEST       TD_IOCTL(34)
#define IOCTL_TD_DEADLOCK_STRESS_TEST                   TD_IOCTL(35)

#define IOCTL_TD_RESERVEDMAP_SET_SIZE                   TD_IOCTL(36)
#define IOCTL_TD_RESERVEDMAP_READ_OP                    TD_IOCTL(37)

#define IOCTL_TD_SYS_PAGED_POOL_MAX_SIZE                TD_IOCTL(38)
#define IOCTL_TD_SYS_PAGED_POOL_TOTAL_SIZE              TD_IOCTL(39)
#define IOCTL_TD_NONPAGED_POOL_MAX_SIZE					TD_IOCTL(40)
#define IOCTL_TD_NONPAGED_POOL_TOTAL_SIZE				TD_IOCTL(41)
#define IOCTL_TD_FREE_SYSTEM_PTES                       TD_IOCTL(42)
#define IOCTL_TD_SESSION_POOL_MAX_SIZE                  TD_IOCTL(43)
#define IOCTL_TD_SESSION_POOL_TOTAL_SIZE                TD_IOCTL(44)

#define IOCTL_TD_NONPAGEDPOOLMDLTEST_MAP                TD_IOCTL(45)
#define IOCTL_TD_NONPAGEDPOOLMDLTEST_UNMAP              TD_IOCTL(46)

#define IOCTL_TD_NEWSTUFF                               TD_IOCTL(47)

//
// Functions section
//
// For a new operation declare the name of the function called
// when the new ioctl is dispatched to the driver. The declaration
// is needed for the user mode driver controller.
//

#ifdef NO_BUGGY_FUNCTIONS
#define BgChkForceCustomBugcheck                     DoNothing
#define StressAllocateContiguousMemory               DoNothing
#define StressAllocateCommonBuffer                   DoNothing
#define StressAddPhysicalMemory                      DoNothing
#define StressDeletePhysicalMemory                   DoNothing
#define StressPhysicalMemorySimple                   DoNothing
#define StressPoolFlag                               DoNothing
#define StressPoolTagTableExtension                  DoNothing
#define StressLockScenario                           DoNothing
#define BgChkProcessHasLockedPages                   DoNothing
#define BgChkNoMoreSystemPtes                        DoNothing
#define BgChkBadPoolHeader                           DoNothing
#define BgChkDriverCorruptedSystemPtes               DoNothing
#define BgChkDriverCorruptedExPool                   DoNothing
#define BgChkDriverCorruptedMmPool                   DoNothing
#define BgChkIrqlNotLessOrEqual                      DoNothing
#define BgChkPageFaultBeyondEndOfAllocation          DoNothing
#define BgChkDriverVerifierDetectedViolation         DoNothing
#define BgChkCorruptSystemPtes                       DoNothing
#define BgChkHangCurrentProcessor                    DoNothing
#define TdMmAllocateContiguousMemorySpecifyCacheTest DoNothing
#define TdSectionMapTestProcessSpace                 DoNothing
#define TdSectionMapTestSystemSpace                  DoNothing
#define TestTraceDatabase                            DoNothing
#define MmTestProbeLockForEverStress                 DoNothing
#define MmTestNameToAddressStress                    DoNothing
#define MmTestEccBadStress                           DoNothing
#define MmMapViewInSystemSpaceLargest                DoNothing
#define MmMapViewInSystemSpaceTotal                  DoNothing
#define MmMapViewInSessionSpaceLargest               DoNothing
#define MmMapViewInSessionSpaceTotal                 DoNothing
#define SessionPoolTest								 DoNothing
#define DeadlockPositiveTest                         DoNothing
#define DeadlockNegativeTest                         DoNothing
#define DeadlockStressTest                           DoNothing
#define TdReservedMappingSetSize                     DoNothing
#define TdReservedMappingDoRead						 DoNothing
#define TdSysPagedPoolMaxTest						 DoNothing
#define TdSysPagedPoolTotalTest						 DoNothing
#define TdNonPagedPoolMaxTest                        DoNothing
#define TdNonPagedPoolTotalTest                      DoNothing
#define TdFreeSystemPtesTest                         DoNothing
#define TdSessionPoolMaxTest                         DoNothing
#define TdSessionPoolTotalTest                       DoNothing
#define TdNonPagedPoolMdlTestMap                     DoNothing
#define TdNonPagedPoolMdlTestUnMap                   DoNothing

#define NewStuff                                     DoNothing
#endif // #ifdef NO_BUGGY_FUNCTIONS

//
// Control section
//
// For a new operation add a new structure at the end of
// BuggyFuns vector (but before the null termination structure).
// Each structure contains the following fields:
//
//     - IOCTL code
//     - short help text displayed when user mode controller
//       prints help information
//     - command line option for user mode controller
//     - Driver function called when IOCTL gets dispatched
//

BUGGY_IOCTL_HANDLER_INFORMATION BuggyFuns [] = {

    {IOCTL_TD_NOTHING, 
     TEXT("nothing"),
     TEXT ("/ioctlnothing"),
     DoNothing },

    {IOCTL_TD_BUGCHECK, 
     TEXT("custom bugcheck"),
     TEXT ("/ioctlbugcheck CODE PARAM1 PARAM2 PARAM3 PARAM4 (hex)"),
     BgChkForceCustomBugcheck },

    {IOCTL_TD_ALLOCPCONTIG_STRESS, 
     TEXT("allocate contiguous memory"), 
     TEXT ("/ioctlmmalloccontig"),
     StressAllocateContiguousMemory },

    {IOCTL_TD_COMMONBUFFER_STRESS, 
     TEXT("allocate common buffer"), 
     TEXT ("/ioctlcommonbuffer"),
     StressAllocateCommonBuffer },

    {IOCTL_TD_MMADDPMEM_STRESS, 
     TEXT("add physical memory"), 
     TEXT ("/ioctladdpmem"),
     StressAddPhysicalMemory },

    {IOCTL_TD_MMDELPMEM_STRESS, 
     TEXT("delete physical memory"), 
     TEXT ("/ioctldelpmem"),
     StressDeletePhysicalMemory },

    {IOCTL_TD_PMEM_SIMPLE_STRESS, 
     TEXT("physical memory simple stress"), 
     TEXT ("/ioctlpmemsimplestress"),
     StressPhysicalMemorySimple },

    {IOCTL_TD_POOLFLAG_STRESS, 
     TEXT("pool flag"), 
     TEXT ("/ioctlpoolflagstress"),
     StressPoolFlag },

    {IOCTL_TD_POOL_STRESS, 
     TEXT("pool tag table extension"), 
     TEXT ("/ioctlpooltagstress"),
     StressPoolTagTableExtension },

    {IOCTL_TD_LOCK_SCENARIO, 
     TEXT("lock scenario"), 
     TEXT ("/ioctllockscenario"),
     StressLockScenario },

    {IOCTL_BGCHK_PROCESS_HAS_LOCKED_PAGES, 
     TEXT("bgchk locked pages"), 
     TEXT ("/bgchkprocesshaslockedpages"),
     BgChkProcessHasLockedPages},

    {IOCTL_BGCHK_NO_MORE_SYSTEM_PTES, 
     TEXT("bgchk no more syptes"), 
     TEXT ("/bgchknomoresystemptes"),
     BgChkNoMoreSystemPtes},

    {IOCTL_BGCHK_BAD_POOL_HEADER, 
     TEXT("bgchk bad pool header"), 
     TEXT ("/bgchkbadpoolheader"),
     BgChkBadPoolHeader},

    {IOCTL_BGCHK_DRIVER_CORRUPTED_SYSTEM_PTES, 
     TEXT("bgchk drv corrupted sysptes"), 
     TEXT ("/bgchkdrivercorruptedsystemptes"),
     BgChkDriverCorruptedSystemPtes},

    {IOCTL_BGCHK_DRIVER_CORRUPTED_EXPOOL, 
     TEXT("bgchk drv corrupted expool"), 
     TEXT ("/bgchkdrivercorruptedexpool"),
     BgChkDriverCorruptedExPool},

    {IOCTL_BGCHK_DRIVER_CORRUPTED_MMPOOL, 
     TEXT("bgchk drv corrupted mmpool"), 
     TEXT ("/bgchkdrivercorruptedmmpool"),
     BgChkDriverCorruptedMmPool},

    {IOCTL_TD_IRQL_NOT_LESS_OR_EQUAL, 
     TEXT("bgchk irql not less or equal"), 
     TEXT ("/bgchkirqlnotlessorequal"),
     BgChkIrqlNotLessOrEqual},

    {IOCTL_TD_PAGE_FAULT_BEYOND_END_OF_ALLOCATION, 
     TEXT("bgchk pgfault beyond allocation"), 
     TEXT ("/bgchkpagefaultbeyondendofallocation"),
     BgChkPageFaultBeyondEndOfAllocation},

    {IOCTL_TD_DRIVER_VERIFIER_DETECTED_VIOLATION, 
     TEXT("bgchk drvvrf detected violation"), 
     TEXT ("/bgchkdriververifierdetectedviolation"),
     BgChkDriverVerifierDetectedViolation},

    {IOCTL_TD_CORRUPT_SYSPTES, 
     TEXT("corrupt system ptes"), 
     TEXT ("/corruptsysptes"),
     BgChkCorruptSystemPtes},

    {IOCTL_TD_HANG_PROCESSOR, 
     TEXT("hang processor"), 
     TEXT ("/hangprocessor"),
     BgChkHangCurrentProcessor},

    {IOCTL_TD_CONTIG_MEM_TEST, 
     TEXT("contiguous memory specify cache"), 
     TEXT ("/contigmemtest"),
     TdMmAllocateContiguousMemorySpecifyCacheTest},

    {IOCTL_TD_SECTION_MAP_TEST_PROCESS_SPACE, 
     TEXT("map test process space"), 
     TEXT ("/sectionmaptest"),
     TdSectionMapTestProcessSpace},

    {IOCTL_TD_SECTION_MAP_TEST_SYSTEM_SPACE, 
     TEXT("map test system space"), 
     TEXT ("/sectionmaptestsysspace"),
     TdSectionMapTestSystemSpace},

    {IOCTL_TEST_TRACEDB, 
     TEXT("test trace database"), 
     TEXT ("/tracedb"),
     TestTraceDatabase},

    {IOCTL_TD_MMPROBELOCKFOREVER_STRESS, 
     TEXT("MmProbeAndLockForEver stress"), 
     TEXT ("/ioctlprobelockforever"),
     MmTestProbeLockForEverStress},

    {IOCTL_TD_MMNAMETOADDR_STRESS, 
     TEXT("MmNameToAddress stress"), 
     TEXT ("/ioctlnametoaddr"),
     MmTestNameToAddressStress},

    {IOCTL_TD_MMECCBAD_STRESS, 
     TEXT("MmEccBad bad stress"), 
     TEXT ("/ioctleccbad"),
     MmTestEccBadStress},

    {IOCTL_TD_MMECCBAD_STRESS, 
     TEXT("MmEccBad good stress - not implemented!!!"), 
     TEXT ("/ioctleccgood"),
     DoNothing},

    {IOCTL_TD_MMMAPVSYSSPACE_LARGEST, 
     TEXT("Determine the max size that can be mapped using MmMapViewInSystemSpace"),
     TEXT ("/mapviewsyslargest"),
     MmMapViewInSystemSpaceLargest},

    {IOCTL_TD_MMMAPVSYSSPACE_TOTAL, 
     TEXT("Determine the total amount of memory that can be mapped using MmMapViewInSystemSpace"),
     TEXT ("/mapviewsystotal"),
     MmMapViewInSystemSpaceTotal},

    {IOCTL_TD_MMMAPVSESSPACE_LARGEST, 
     TEXT("Determine the max size that can be mapped using MmMapViewInSessionSpace"),
     TEXT ("/mapviewseslargest"),
     MmMapViewInSessionSpaceLargest},

    {IOCTL_TD_MMMAPVSESSPACE_TOTAL, 
     TEXT("Determine the total amount of memory that can be mapped using MmMapViewInSessionSpace"),
     TEXT ("/mapviewsestotal"),
     MmMapViewInSessionSpaceTotal},

    {IOCTL_TD_SESSION_POOL_TEST, 
     TEXT("Determine the total amount of pool that can be allocated with SESSION_POOL_MASK flag"),
     TEXT ("/sessionpooltest"),
     SessionPoolTest },


    {IOCTL_TD_DEADLOCK_MECHANISM_POSITIVE_TEST, 
     TEXT("Test the deadlock detection mechanism without actually causing deadlocks"),
     TEXT ("/deadlockpositive"),
     DeadlockPositiveTest },

    {IOCTL_TD_DEADLOCK_MECHANISM_NEGATIVE_TEST, 
     TEXT("Test the deadlock detection mechanism by causing deadlocks"),
     TEXT ("/deadlocknegative"),
     DeadlockNegativeTest },

    {IOCTL_TD_DEADLOCK_STRESS_TEST, 
     TEXT("Stress test for the deadlock detection mechanism"),
     TEXT ("/deadlockstress"),
     DeadlockStressTest },

    {IOCTL_TD_RESERVEDMAP_SET_SIZE, 
     TEXT("Set the size of the reserved mapping address (MmMapLockedPagesWithReservedMapping tests)"),
     TEXT ("/ReservedMapSetSize"),
     TdReservedMappingSetSize },

    {IOCTL_TD_RESERVEDMAP_READ_OP, 
     TEXT("Execute a \"read\" (MmMapLockedPagesWithReservedMapping tests)"),
     TEXT ("/ReservedMapRead"),
     TdReservedMappingDoRead },
 
    {IOCTL_TD_SYS_PAGED_POOL_MAX_SIZE, 
     TEXT("Determine the maximum size of a block of paged pool currently available"),
     TEXT ("/SysPagedPoolMax"),
     TdSysPagedPoolMaxTest },

    {IOCTL_TD_SYS_PAGED_POOL_TOTAL_SIZE, 
     TEXT("Determine the total size of the paged pool currently available (64 Kb - 32 bytes blocks)"),
     TEXT ("/SysPagedPoolTotal"),
     TdSysPagedPoolTotalTest },

    {IOCTL_TD_NONPAGED_POOL_MAX_SIZE, 
     TEXT("Determine the maximum size of a block of non-paged pool currently available"),
     TEXT ("/NonPagedPoolMax"),
     TdNonPagedPoolMaxTest },

    {IOCTL_TD_NONPAGED_POOL_TOTAL_SIZE, 
     TEXT("Determine the total size of the non-paged pool currently available (64 Kb - 32 bytes blocks)"),
     TEXT ("/NonPagedPoolTotal"),
     TdNonPagedPoolTotalTest },

    {IOCTL_TD_FREE_SYSTEM_PTES, 
     TEXT("Determine the total amount of memory that can be mapped using system PTEs (1 Mb chunks)"),
     TEXT ("/FreeSystemPtes"),
     TdFreeSystemPtesTest },

    {IOCTL_TD_SESSION_POOL_MAX_SIZE, 
     TEXT("Determine the maximum size of a block of session pool currently available"),
     TEXT ("/SessionPoolMax"),
     TdSessionPoolMaxTest },

    {IOCTL_TD_SESSION_POOL_TOTAL_SIZE, 
     TEXT("Determine the total size of the session pool currently available (64 Kb - 32 bytes blocks)"),
     TEXT ("/SessionPoolTotal"),
     TdSessionPoolTotalTest },

    {IOCTL_TD_NONPAGEDPOOLMDLTEST_MAP, 
     TEXT("MmBuildMdlForNonPagedPoolMap"),
     TEXT ("/BuildMdlForNonPagedPoolTest"),
     TdNonPagedPoolMdlTestMap },

    {IOCTL_TD_NONPAGEDPOOLMDLTEST_UNMAP, 
     TEXT("MmBuildMdlForNonPagedPoolUnMap"),
     NULL,
     TdNonPagedPoolMdlTestUnMap },

     {IOCTL_TD_NEWSTUFF, 
     TEXT("new stuff ioctl"), 
     TEXT ("/newstuff"),
     NewStuff},
    
    {0, NULL, NULL, NULL} // termination
};
    
#endif // #ifndef FUNS_DEFINITION_MODULE

#endif // #ifndef _FUNS_H_INCLUDED_

//
// End of header: funs.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\mapview.h ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 2000.
//
// Module:  MapView.h
// Author:  Daniel Mihai (DMihai)
// Created: 4/6/2000
//
// This module contains tests for MmMapViewInSystemSpace & MmMapViewInSessionSpace.
//
// --- History ---
//
// 4/6/2000 (DMihai): initial version.
//

#ifndef _MAPVIEW_H_INCLUDED_
#define _MAPVIEW_H_INCLUDED_

VOID MmMapViewInSystemSpaceLargest (
    PVOID NotUsed
    );

VOID MmMapViewInSystemSpaceTotal (
    PVOID NotUsed
    );

VOID MmMapViewInSessionSpaceLargest (
    PVOID NotUsed
    );

VOID MmMapViewInSessionSpaceTotal (
    PVOID NotUsed
    );

VOID SessionPoolTest (
    PVOID NotUsed
    );

#endif // #ifndef _MAPVIEW_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\mmtests.h ===
#ifndef _MMTESTS_H_INCLUDED_
#define _MMTESTS_H_INCLUDED_

VOID MmTestProbeLockForEverStress (
    IN PVOID IrpAddress
    );

VOID MmTestNameToAddressStress (
    IN PVOID IrpAddress
    );

VOID MmTestEccBadStress (
    IN PVOID IrpAddress
    );

VOID
TdSysPagedPoolMaxTest(
    IN PVOID IrpAddress
    );

VOID
TdSysPagedPoolTotalTest(
    IN PVOID IrpAddress
    );

VOID
TdNonPagedPoolMaxTest(
    IN PVOID IrpAddress
    );

VOID
TdNonPagedPoolTotalTest(
    IN PVOID IrpAddress
    );

VOID
TdFreeSystemPtesTest(
    IN PVOID IrpAddress
    );

VOID
StressPoolFlag (
    PVOID NotUsed
    );

VOID 
StressPoolTagTableExtension (
    PVOID NotUsed
    );

VOID
TdSessionPoolMaxTest(
    IN PVOID IrpAddress
    );

VOID
TdSessionPoolTotalTest(
    IN PVOID IrpAddress
    );

VOID
TdNonPagedPoolMdlTestMap(
    IN PVOID IrpAddress
    );

VOID
TdNonPagedPoolMdlTestUnMap(
    IN PVOID IrpAddress
    );

#endif // #ifndef _MMTESTS_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\mapview.c ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 2000.
//
// Module:  MapView.c
// Author:  Daniel Mihai (DMihai)
// Created: 4/6/2000
//
// This module contains tests for MmMapViewInSystemSpace & MmMapViewInSessionSpace.
// Note that SystemViewSize & SessionViewSize are configurable using the registry.
//
// SessionPoolTest is exercising the paged pool allocated with SESSION_POOL_MASK.
// The size of this pool can be also configured using the SsessionViewSize registry
// value.
//
// --- History ---
//
// 4/6/2000 (DMihai): initial version.
//

#include <ntddk.h>

#include "active.h"
#include "MapView.h"
#include "tdriver.h"

#if !MAPVIEW_ACTIVE

//
// Dummy implementation if the module is inactive
//

VOID MmMapViewInSystemSpaceLargest (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: MapView module is disabled from active.h\n");
}

VOID MmMapViewInSystemSpaceTotal (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: MapView module is disabled from active.h\n");
}

VOID MmMapViewInSessionSpaceLargest (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: MapView module is disabled from active.h\n");
}

VOID MmMapViewInSessionSpaceTotal (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: MapView module is disabled from active.h\n");
}

VOID SessionPoolTest (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: MapView module is disabled from active.h\n");
}

#else

const LARGE_INTEGER BuggyFiveSeconds = {(ULONG)(-5 * 1000 * 1000 * 10), -1};


//
// Real implementation if the module is active
//

#ifndef SEC_COMMIT
#define SEC_COMMIT        0x8000000    
#endif  //#ifndef SEC_COMMIT

#ifndef ZwDeleteFile

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    ); //#ifndef ZwDeleteFile

#endif


#ifndef MmCreateSection


NTKERNELAPI
NTSTATUS
MmCreateSection (
    OUT PVOID *SectionObject,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL,
    IN PFILE_OBJECT File OPTIONAL
    );

NTKERNELAPI
NTSTATUS
MmMapViewInSystemSpace (
    IN PVOID Section,
    OUT PVOID *MappedBase,
    IN PSIZE_T ViewSize
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewInSystemSpace (
    IN PVOID MappedBase
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
MmMapViewInSessionSpace (
    IN PVOID Section,
    OUT PVOID *MappedBase,
    IN OUT PSIZE_T ViewSize
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewInSessionSpace (
    IN PVOID MappedBase
    );

#endif //#ifndef MmCreateSection

#define BUGGY_TEMPORARY_FILE1 L"\\SystemRoot\\Buggy1.tmp"
#define BUGGY_TEMPORARY_FILE2 L"\\SystemRoot\\Buggy2.tmp"
#define BUGGY_TEMPORARY_FILE3 L"\\SystemRoot\\Buggy3.tmp"
#define BUGGY_TEMPORARY_FILE4 L"\\SystemRoot\\Buggy4.tmp"

#define BUGGY_MAX_SECTIONS_TO_MAP   ( 8 * 1024 )

//
// global array for mapped sections
//

/////////////////////////////////////////////////////////////////////////////
//
// verify a mapping
//

VOID VerifyMapping( PVOID pBase, SIZE_T uSize )
{
    SIZE_T *puCrtPage;
    SIZE_T uCrtPageIndex;
    SIZE_T uPages;

    if( uSize > 100 * 1024 * 1024 )
    {
        DbgPrint ( "Buggy: VerifyMapping: don't try to touch all the %p size to avoid deadlock\n",
            uSize );

        return;
    }

    /*
    DbgPrint ( "\nBuggy: Verifying mapping at address %p, size %p...\n",
        pBase,
        (PVOID) uSize );
    */

    uPages = uSize / PAGE_SIZE;

    puCrtPage = (SIZE_T *)pBase;

    for( uCrtPageIndex = 0; uCrtPageIndex < uPages; uCrtPageIndex++ )
    {
        *puCrtPage = uCrtPageIndex;

        puCrtPage = (SIZE_T *) ( ( (CHAR*) puCrtPage ) + PAGE_SIZE );
    }

    while( uCrtPageIndex > 0 )
    {
        uCrtPageIndex --;
        puCrtPage = (SIZE_T *) ( ( (CHAR*) puCrtPage ) - PAGE_SIZE );

        if( *puCrtPage != uCrtPageIndex )
        {
            DbgPrint ( "\nBuggy: Wrong mapping at address %p\n",
                puCrtPage );

            DbgBreakPoint();
        }
    }

    //DbgPrint ( "done\n" );
}

/////////////////////////////////////////////////////////////////////////////

VOID MmMapViewInSystemSpaceLargest (
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    HANDLE hFile = NULL;
    SIZE_T SizeToMap;
    SIZE_T SizeToGrow;
    PVOID pMappedBase = NULL;
    PVOID pSection = NULL;
    LARGE_INTEGER MaxSectionSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Create BUGGY_TEMPORARY_FILE1
    //

    RtlInitUnicodeString(
        &FileName,
        BUGGY_TEMPORARY_FILE1
        );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE ,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
        &hFile,
        GENERIC_READ | GENERIC_WRITE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        0,
        FILE_OVERWRITE_IF,
        FILE_NON_DIRECTORY_FILE,
        NULL,
        0 );

  /*
    Status = ZwCreateFile(
            &hFile,
            GENERIC_READ | GENERIC_WRITE,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN_IF,
            FILE_WRITE_THROUGH |
                FILE_NO_INTERMEDIATE_BUFFERING |
                FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
            );
        */

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint ("Buggy: ZwCreateFile failed - status %X\n",
            Status );

        goto cleanup;
    }
    else
    {
        DbgPrint ( "Buggy: created file, handle %p\n",
            hFile ); 
    }

    //
    // Create a section for the temp file
    //

#ifdef _WIN64
    MaxSectionSize.QuadPart = (LONGLONG)0x40000000 * PAGE_SIZE;
#else
    MaxSectionSize.QuadPart = 0xFFFFFFFF;
#endif //#ifdef _WIN64
    
    do
    {
        Status = MmCreateSection(
            &pSection,
            STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
            NULL,
            &MaxSectionSize,
            PAGE_READWRITE,
            SEC_COMMIT,
            hFile,
            NULL );

        if( ! NT_SUCCESS( Status ) )
        {
            if( Status == STATUS_DISK_FULL  )
            {
                MaxSectionSize.QuadPart /= 2;
                
                DbgPrint ("Buggy: MmCreateSection returned STATUS_DISK_FULL, re-trying with max section size = %I64X\n",
                    MaxSectionSize.QuadPart );
            }
            else
            {
                DbgPrint ("Buggy: MmCreateSection failed - status %X\n",
                    Status );
    
                goto cleanup;
            }
        }
        else
        {
            DbgPrint ( "Buggy: created section with max size %I64X\n",
                MaxSectionSize.QuadPart ); 

            break;
        }

    } while( MaxSectionSize.QuadPart > PAGE_SIZE );


    DbgPrint ( "Buggy: Using section at %p\n",
        pSection );

    //
    // try to map the max size section
    //

	SizeToMap = (SIZE_T) MaxSectionSize.QuadPart;

    while( SizeToMap > PAGE_SIZE )
    {
        Status = MmMapViewInSystemSpace(
            pSection,
            &pMappedBase,
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmMapViewInSystemSpace failed for size %p, status %X\n",
                SizeToMap,
                Status );

            SizeToMap /= 2;
        }
        else
        {
            DbgPrint ( "\n\nFirst result of the test:\n\n" );
            
            DbgPrint ( "Buggy: MmMapViewInSystemSpace succeeded for size %p, mapped base %p\n",
                SizeToMap,
                pMappedBase );

            //DbgPrint ( "\n\n" );

            VerifyMapping( pMappedBase, SizeToMap );

            break;
        }
    }

    //
    // try to grow the size
    //

    while( pMappedBase != NULL )
    {
        //
        // unmap the old one
        //

        Status = MmUnmapViewInSystemSpace( 
            pMappedBase );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSystemSpace failed, status %X\n",
                Status );

            DbgBreakPoint();

            break;
        }

        pMappedBase = NULL;

        //
        // grow the size
        //

        SizeToGrow = SizeToMap / 10;

        if( SizeToGrow < 10 * PAGE_SIZE )
        {
            //
            // don't bother
            //

            break;
        }

        SizeToMap += SizeToGrow;

        //
        // try to use this bigger size
        //

        Status = MmMapViewInSystemSpace(
            pSection,
            &pMappedBase,
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            /*
            DbgPrint ( "Buggy: MmMapViewInSystemSpace failed for size %p, status %X\n",
                SizeToMap,
                Status );
            */

            //
            // can't grow the size anymore
            //

            break;
        }
        else
        {
            DbgPrint ( "\n\nBetter result of the test:\n\n" );
            
            DbgPrint ( "Buggy: MmMapViewInSystemSpace succeeded for size %p, mapped base %p\n",
                SizeToMap,
                pMappedBase );

            //DbgPrint ( "\n\n" );

            VerifyMapping( pMappedBase, SizeToMap );
        }
    }

    //
    // clean-up
    //

cleanup:

    if( pMappedBase != NULL )
    {
        Status = MmUnmapViewInSystemSpace( 
            pMappedBase );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSystemSpace failed, status %X\n",
                Status );

            DbgBreakPoint();
        }
    }

    if( pSection != NULL )
    {
        ObDereferenceObject( 
            pSection );
    }

    if( hFile != NULL )
    {
        ZwClose( hFile );

        Status = ZwDeleteFile(
            &ObjectAttributes );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ("Buggy: ZwDeleteFile failed - status %X\n",
                Status );
        }
        else
        {
            // DbgPrint ("Buggy: temporary file deleted\n" );
        }
    }
}

///////////////////////////////////////////////////////////////////////////

PVOID *MappedSections;

VOID MmMapViewInSystemSpaceTotal (
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    HANDLE hFile = NULL;
    SIZE_T SizeToMap;
    PVOID pSection = NULL;
    SIZE_T CrtMap;
    LARGE_INTEGER MaxSectionSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;

    MappedSections = ExAllocatePoolWithTag(
        NonPagedPool,
        BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ),
        TD_POOL_TAG );

    if( MappedSections == NULL )
    {
        DbgPrint ("Buggy: ExAllocatePoolWithTag failed - bail\n" );
        
        return;
    }

    RtlZeroMemory( MappedSections, BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ) );

    //
    // Create BUGGY_TEMPORARY_FILE2
    //

    RtlInitUnicodeString(
        &FileName,
        BUGGY_TEMPORARY_FILE2
        );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
        &hFile,
        GENERIC_READ | GENERIC_WRITE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        0,
        FILE_OVERWRITE_IF,
        FILE_NON_DIRECTORY_FILE,
        NULL,
        0 );

    if( ! NT_SUCCESS( Status ) )
    {
        /*
        DbgPrint ("Buggy: ZwCreateFile failed - status %X\n",
            Status );
        */

        goto cleanup;
    }
    else
    {
        //DbgPrint ( "Buggy: created file\n" ); 
    }

    //
    // Create a section for the temp file
    //

    MaxSectionSize.QuadPart = 1024 * 1024;
    
    do
    {
        Status = MmCreateSection(
            &pSection,
            STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
            NULL,
            &MaxSectionSize,
            PAGE_READWRITE,
            SEC_COMMIT,
            hFile,
            NULL );

        if( ! NT_SUCCESS( Status ) )
        {
            if( Status == STATUS_DISK_FULL )
            {
                MaxSectionSize.QuadPart /= 2;

                /*
                DbgPrint ("Buggy: MmCreateSection returned STATUS_DISK_FULL, re-trying with max section size = %I64X\n",
                    MaxSectionSize.QuadPart );
                */
            }
            else
            {
                DbgPrint ("Buggy: MmCreateSection failed - status %X\n",
                    Status );
        
                goto cleanup;
            }
        }
        else
        {
            /*
            DbgPrint ( "Buggy: created section with max size %I64X\n",
                MaxSectionSize.QuadPart ); 
            */

            break;
        }

    } while( MaxSectionSize.QuadPart > PAGE_SIZE );


    //
    // get a pointer to the section
    //

    DbgPrint ( "Buggy: Using section at %p\n",
        pSection );

    //
    // try to map the max size section
    //

    SizeToMap = (SIZE_T) MaxSectionSize.QuadPart;

    RtlZeroMemory( MappedSections, BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ) );

    for( CrtMap = 0; CrtMap < BUGGY_MAX_SECTIONS_TO_MAP; CrtMap++ )
    {
        Status = MmMapViewInSystemSpace(
            pSection,
            &MappedSections[ CrtMap ],
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmMapViewInSystemSpace failed for size %p, status %X, chunk %p\n",
                SizeToMap,
                Status,
                CrtMap);

            break;
        }
        else
        {
            if( CrtMap <= 100 )
            {
                VerifyMapping( MappedSections[ CrtMap ], SizeToMap );
            }
        }
    }

    DbgPrint ( "\n\nBuggy: Result of the test:\n\n" );

    DbgPrint ( "Buggy: mapped %u sections with size %p, total %p\n",
        CrtMap,
        SizeToMap,
        SizeToMap * (SIZE_T)CrtMap );

    //DbgBreakPoint ();

    //DbgPrint ( "\n\n" );

    //
    // clean-up
    //

cleanup:

    for( CrtMap = 0; CrtMap < BUGGY_MAX_SECTIONS_TO_MAP; CrtMap++ )
    {
        if( MappedSections[ CrtMap ] == NULL )
        {
            break;
        }

        Status = MmUnmapViewInSystemSpace( 
            MappedSections[ CrtMap ] );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSystemSpace failed for %p, status %X\n",
                MappedSections[ CrtMap ],
                Status );

            DbgBreakPoint();
        }
    }

    DbgPrint ( "Buggy: unmapped %p sections\n",
        CrtMap );

    if( pSection != NULL )
    {
        ObDereferenceObject( 
            pSection );

        DbgPrint ( "Buggy: dereferenced section at %p\n",
            pSection );
    }

    if( hFile != NULL )
    {
        ZwClose( hFile );

        DbgPrint ( "Buggy: calling ZwDeleteFile\n" );

        Status = ZwDeleteFile(
            &ObjectAttributes );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ("Buggy: ZwDeleteFile failed - status %X\n",
                Status );
        }
        else
        {
            DbgPrint ("Buggy: temporary file deleted\n" );
        }
    }

    ExFreePool( MappedSections );
}

/////////////////////////////////////////////////////////////////////////////

VOID MmMapViewInSessionSpaceLargest (
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    HANDLE hFile = NULL;
    SIZE_T SizeToMap;
    SIZE_T SizeToGrow;
    PVOID pMappedBase = NULL;
    PVOID pSection = NULL;
    LARGE_INTEGER MaxSectionSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;

    // Create BUGGY_TEMPORARY_FILE3
    //

    RtlInitUnicodeString(
        &FileName,
        BUGGY_TEMPORARY_FILE3
        );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
        &hFile,
        GENERIC_READ | GENERIC_WRITE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        0,
        FILE_OVERWRITE_IF,
        FILE_NON_DIRECTORY_FILE,
        NULL,
        0 );

    if( ! NT_SUCCESS( Status ) )
    {
        /*
        DbgPrint ("Buggy: ZwCreateFile failed - status %X\n",
            Status );
        */

        goto cleanup;
    }
    else
    {
        //DbgPrint ( "Buggy: created file\n" ); 
    }

    //
    // Create a section for the temp file
    //

#ifdef _WIN64
    MaxSectionSize.QuadPart = (LONGLONG)0x40000000 * PAGE_SIZE;
#else
    MaxSectionSize.QuadPart = 0xFFFFFFFF;
#endif //#ifdef _WIN64
    
    do
    {
        Status = MmCreateSection(
            &pSection,
            STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
            NULL,
            &MaxSectionSize,
            PAGE_READWRITE,
            SEC_COMMIT,
            hFile,
            NULL );

        if( ! NT_SUCCESS( Status ) )
        {
            if( Status == STATUS_DISK_FULL )
            {
                MaxSectionSize.QuadPart /= 2;

                DbgPrint ("Buggy: MmCreateSection returned STATUS_DISK_FULL, re-trying with max section size = %I64X\n",
                    MaxSectionSize.QuadPart );
            }
            else
            {
                DbgPrint ("Buggy: MmCreateSection failed - status %X\n",
                    Status );
        
                goto cleanup;
            }
        }
        else
        {
            DbgPrint ( "Buggy: created section with max size %I64X\n",
                MaxSectionSize.QuadPart ); 

            break;
        }

    } while( MaxSectionSize.QuadPart > PAGE_SIZE );


    DbgPrint ( "Buggy: Using section at %p\n",
        pSection );

    //
    // try to map the max size section
    //

    SizeToMap = (SIZE_T) MaxSectionSize.QuadPart;

    while( SizeToMap > PAGE_SIZE )
    {
        Status = MmMapViewInSessionSpace(
            pSection,
            &pMappedBase,
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmMapViewInSessionSpace failed for size %p, status %X\n",
                SizeToMap,
                Status );

            SizeToMap /= 2;
        }
        else
        {
            DbgPrint ( "\n\nFirst result of the test:\n\n" );
            
            DbgPrint ( "Buggy: MmMapViewInSessionSpace succeeded for size %p, mapped base %p\n",
                SizeToMap,
                pMappedBase );

            //DbgPrint ( "\n\n" );

            VerifyMapping( pMappedBase, SizeToMap );

            break;
        }
    }

    //
    // try to grow the size
    //

    while( pMappedBase != NULL )
    {
        //
        // unmap the old one
        //

        Status = MmUnmapViewInSessionSpace( 
            pMappedBase );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSessionSpace failed, status %X\n",
                Status );

            DbgBreakPoint();

            break;
        }

        pMappedBase = NULL;

        //
        // grow the size
        //

        SizeToGrow = SizeToMap / 10;

        if( SizeToGrow < 10 * PAGE_SIZE )
        {
            //
            // don't bother
            //

            break;
        }

        SizeToMap += SizeToGrow;

        //
        // try to use this bigger size
        //

        Status = MmMapViewInSessionSpace(
            pSection,
            &pMappedBase,
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmMapViewInSessionSpace failed for size %p, status %X\n",
                SizeToMap,
                Status );

            //
            // can't grow the size anymore
            //

            break;
        }
        else
        {
            DbgPrint ( "\n\nBetter result of the test:\n\n" );
            
            DbgPrint ( "Buggy: MmMapViewInSessionSpace succeeded for size %p, mapped base %p\n",
                SizeToMap,
                pMappedBase );

            //DbgPrint ( "\n\n" );

            VerifyMapping( pMappedBase, SizeToMap );
        }
    }

    //
    // clean-up
    //

cleanup:

    if( pMappedBase != NULL )
    {
        Status = MmUnmapViewInSessionSpace( 
            pMappedBase );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSessionSpace failed, status %X\n",
                Status );

            DbgBreakPoint();
        }
    }

    if( pSection != NULL )
    {
        ObDereferenceObject( 
            pSection );
    }

    if( hFile != NULL )
    {
        ZwClose( hFile );

        Status = ZwDeleteFile(
            &ObjectAttributes );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ("Buggy: ZwDeleteFile failed - status %X\n",
                Status );
        }
        else
        {
            //DbgPrint ("Buggy: temporary file deleted\n" );
        }
    }
}

///////////////////////////////////////////////////////////////////////////

VOID MmMapViewInSessionSpaceTotal (
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    HANDLE hFile = NULL;
    SIZE_T SizeToMap;
    PVOID pSection = NULL;
    SIZE_T CrtMap;
    LARGE_INTEGER MaxSectionSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID *MappedSections;

    MappedSections = ExAllocatePoolWithTag(
        NonPagedPool,
        BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ),
        TD_POOL_TAG );

    if( MappedSections == NULL )
    {
        DbgPrint ("Buggy: ExAllocatePoolWithTag failed - bail\n" );
        
        return;
    }

    RtlZeroMemory( MappedSections, BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ) );


    //
    // Create BUGGY_TEMPORARY_FILE3
    //

    RtlInitUnicodeString(
        &FileName,
        BUGGY_TEMPORARY_FILE3
        );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
        &hFile,
        GENERIC_READ | GENERIC_WRITE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        0,
        FILE_OVERWRITE_IF,
        FILE_NON_DIRECTORY_FILE,
        NULL,
        0 );

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint ("Buggy: ZwCreateFile failed - status %X\n",
            Status );

        goto cleanup;
    }
    else
    {
        //DbgPrint ( "Buggy: created file\n" ); 
    }

    //
    // Create a section for the temp file
    //

    MaxSectionSize.QuadPart = 1024 * 1024;
    
    do
    {
        Status = MmCreateSection(
            &pSection,
            STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
            NULL,
            &MaxSectionSize,
            PAGE_READWRITE,
            SEC_COMMIT,
            hFile,
            NULL );

        if( ! NT_SUCCESS( Status ) )
        {
            if( Status == STATUS_DISK_FULL )
            {
                MaxSectionSize.QuadPart /= 2;

                /*
                DbgPrint ("Buggy: MmCreateSection returned STATUS_DISK_FULL, re-trying with max section size = %I64X\n",
                    MaxSectionSize.QuadPart );
                */
            }
            else
            {
                DbgPrint ("Buggy: MmCreateSection failed - status %X\n",
                    Status );
        
                goto cleanup;
            }
        }
        else
        {
            /*
            DbgPrint ( "Buggy: created section with max size %I64X\n",
                MaxSectionSize.QuadPart ); 
            */

            break;
        }

    } while( MaxSectionSize.QuadPart > PAGE_SIZE );


    DbgPrint ( "Buggy: Using section at %p\n",
        pSection );

    //
    // try to map the max size section
    //

    SizeToMap = (SIZE_T) MaxSectionSize.QuadPart;

    RtlZeroMemory( MappedSections, BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ) );

    for( CrtMap = 0; CrtMap < BUGGY_MAX_SECTIONS_TO_MAP; CrtMap++ )
    {
        Status = MmMapViewInSessionSpace(
            pSection,
            &MappedSections[ CrtMap ],
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            /*
            DbgPrint ( "Buggy: MmMapViewInSessionSpace failed for size %p, status %X, chunk %p\n",
                SizeToMap,
                Status
                );
            */

            break;
        }
        else
        {
            if( CrtMap <= 100 )
            {
                VerifyMapping( MappedSections[ CrtMap ], SizeToMap );
            }
        }
    }

    DbgPrint ( "\n\nBuggy: Result of the test:\n\n" );

    DbgPrint ( "Buggy: mapped %u sections with size %p, total %p\n",
        CrtMap,
        SizeToMap,
        SizeToMap * (SIZE_T)CrtMap );

    //DbgPrint ( "\n\n" );

    //
    // clean-up
    //

cleanup:

    for( CrtMap = 0; CrtMap < BUGGY_MAX_SECTIONS_TO_MAP; CrtMap++ )
    {
        if( MappedSections[ CrtMap ] == NULL )
        {
            break;
        }

        Status = MmUnmapViewInSessionSpace( 
            MappedSections[ CrtMap ] );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSessionSpace failed for %p, status %X\n",
                MappedSections[ CrtMap ],
                Status );

            DbgBreakPoint();
        }
    }

    if( pSection != NULL )
    {
        ObDereferenceObject( 
            pSection );
    }

    if( hFile != NULL )
    {
        ZwClose( hFile );

        Status = ZwDeleteFile(
            &ObjectAttributes );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ("Buggy: ZwDeleteFile failed - status %X\n",
                Status );
        }
        else
        {
            //DbgPrint ("Buggy: temporary file deleted\n" );
        }
    }

    ExFreePool( MappedSections );
}

///////////////////////////////////////////////////////////////////////////

VOID SessionPoolTest (
    PVOID NotUsed
    )
{
    PVOID *SessionPoolChunks;
    ULONG uCrtPoolChunk;

    SessionPoolChunks = ExAllocatePoolWithTag(
        NonPagedPool,
        BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ),
        TD_POOL_TAG );

    if( SessionPoolChunks == NULL )
    {
        DbgPrint ("Buggy: ExAllocatePoolWithTag failed - bail\n" );
        
        return;
    }

    RtlZeroMemory( SessionPoolChunks, BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ) );

    for( uCrtPoolChunk = 0; uCrtPoolChunk < BUGGY_MAX_SECTIONS_TO_MAP; uCrtPoolChunk++ )
    {
        SessionPoolChunks[ uCrtPoolChunk ] = ExAllocatePoolWithTag(
            PagedPool | SESSION_POOL_MASK,
            1024 * 1024,
            TD_POOL_TAG );

        if( SessionPoolChunks[ uCrtPoolChunk ] == NULL )
        {
            DbgPrint ("\n\nBuggy: Result of the test allocated %u chunks with size 1 Mb in the session pool\n\n",
                uCrtPoolChunk );
            break;
        }
    }

    DbgPrint ( "Buggy: Touching all these pool chuncks...\n" );

    while( uCrtPoolChunk > 0 )
    {
        uCrtPoolChunk--;

        if( uCrtPoolChunk <= 100 )
        {
            VerifyMapping( SessionPoolChunks[ uCrtPoolChunk ], 1024 * 1024 );
        }

        ExFreePool( SessionPoolChunks[ uCrtPoolChunk ] );
    }

    DbgPrint ( "Done\n" );

    ExFreePool( SessionPoolChunks );
}

#endif // #if !MAPVIEW_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\physmem.h ===
#ifndef _PHYSMEM_H_INCLUDED_
#define _PHYSMEM_H_INCLUDED_

VOID
StressAllocateContiguousMemory (
    PVOID NotUsed
    );

VOID
StressAllocateCommonBuffer (
    PVOID NotUsed
    );

VOID 
EditPhysicalMemoryParameters (
    );

VOID
StressAddPhysicalMemory (
    PVOID NotUsed
    );

VOID
StressDeletePhysicalMemory (
    PVOID NotUsed
    );

VOID
StressLockScenario (
    PVOID NotUsed
    );

VOID
StressPhysicalMemorySimple (
    PVOID NotUsed
    );

extern LARGE_INTEGER BuggyOneSecond;

#endif // #ifndef _PHYSMEM_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\mmtests.c ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  tdriver.c
// Author:  Silviu Calinoiu (SilviuC)
// Created: 4/20/1999 2:39pm
//
// This module contains a template driver.
//
// --- History ---
//
// 4/20/1999 (SilviuC): initial version.
//
// 10/25/1999 (DMihai): Aded tests for:
//  - paged pool size
//  - non paged pool size
//  - number of free system PTEs 
//

#include <ntddk.h>

#include "active.h"
#include "mmtests.h"
#include "physmem.h"
#include "tdriver.h"

#if !MMTESTS_ACTIVE

//
// Dummy implementation if the module is inactive
//

VOID MmTestDisabled (VOID)
{
    DbgPrint ("Buggy: mmtests module is disabled (check \\driver\\active.h header) \n");
}

VOID MmTestProbeLockForEverStress (
    IN PVOID NotUsed
    )
{
    MmTestDisabled ();    
}

VOID MmTestNameToAddressStress (
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID MmTestEccBadStress (
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
TdSysPagedPoolMaxTest(
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
TdSysPagedPoolTotalTest(
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
TdNonPagedPoolMaxTest(
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
TdNonPagedPoolTotalTest(
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
TdFreeSystemPtesTest(
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
StressPoolFlag (
    PVOID NotUsed
    )
{
    MmTestDisabled ();    
}

VOID 
StressPoolTagTableExtension (
    PVOID NotUsed
    )
{
    MmTestDisabled ();    
}

#else

//
// Real implementation if the module is active
//


ULONG BuggyPP = (96 * 1024 * 1024);
PVOID BuggyOld;
SIZE_T UserVaSize = (50 * 1024 * 1024);
ULONG BuggyHold = 1;

ULONG OverrideStart;
ULONG OverrideSize;
ULONG OverrideCount;

#define VERBOSITY_PRINT         0x0001
#define VERBOSITY_BREAK         0x0002

ULONG Verbosity = 0x0003;


NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSTATUS
MmMarkPhysicalMemoryAsBad (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes
    );

NTSTATUS
MmMarkPhysicalMemoryAsGood (
    IN PPHYSICAL_ADDRESS StartAddress,
    IN OUT PLARGE_INTEGER NumberOfBytes
    );


VOID MmTestProbeLockForEverStress (
    IN PVOID IrpAddress
    )
{
    PIRP Irp = (PIRP) IrpAddress;
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG Ioctl;
    NTSTATUS Status;
    ULONG BufferSize;
    ULONG ReturnedSize;

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    Ioctl = IrpStack->Parameters.DeviceIoControl.IoControlCode;

    {
        SIZE_T RegionSize;
        PVOID UserVa;
        PMDL Mdl;

        UserVa = NULL;
        RegionSize = UserVaSize;

        Status = ZwAllocateVirtualMemory (NtCurrentProcess(),
            (PVOID *)&UserVa,
            0,
            &RegionSize,
            MEM_COMMIT,
            PAGE_READWRITE);
        if (NT_SUCCESS(Status)) {

            Mdl = IoAllocateMdl (
                UserVa,
                (ULONG)RegionSize,
                FALSE,             // not secondary buffer
                FALSE,             // do not charge quota          
                NULL);             // no irp

            if (Mdl != NULL) {

                try {
                    MmProbeAndLockPages (Mdl,
                        KernelMode,
                        IoReadAccess);

                    DbgPrint ("Buggy: locked pages in MDL %p\n", Mdl);
                    DbgBreakPoint ();

                    //
                    // Don't exit now without unlocking !
                    //

                    while (BuggyHold != 0) {
                        KeDelayExecutionThread (KernelMode, FALSE, &BuggyOneSecond);
                    }
                    MmUnlockPages (Mdl);
                    IoFreeMdl (Mdl);
                }
                except (EXCEPTION_EXECUTE_HANDLER) {

                    DbgPrint ("Buggy: exception raised while locking %p\n", Mdl);
                    DbgBreakPoint ();
                }
            }
        }
    }

    DbgPrint ("Buggy: finish with probe-and-lock forever ioctl \n");
    Status = STATUS_SUCCESS;
}


VOID MmTestNameToAddressStress (
    IN PVOID IrpAddress
    )
{
    PIRP Irp = (PIRP) IrpAddress;
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG Ioctl;
    NTSTATUS Status;
    ULONG BufferSize;
    ULONG ReturnedSize;

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    Ioctl = IrpStack->Parameters.DeviceIoControl.IoControlCode;

    {

#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }

        const UNICODE_STRING RoutineA = CONSTANT_UNICODE_STRING( L"KfRaiseIrql" );

        const UNICODE_STRING RoutineList[] = {

            CONSTANT_UNICODE_STRING( L"KeBugCheckEx" ),
            CONSTANT_UNICODE_STRING( L"KiBugCheckData" ),
            CONSTANT_UNICODE_STRING( L"KeWaitForSingleObject" ),
            CONSTANT_UNICODE_STRING( L"KeWaitForMutexObject" ),
            CONSTANT_UNICODE_STRING( L"Junk1" ),
            CONSTANT_UNICODE_STRING( L"CcCanIWrite" ),
            CONSTANT_UNICODE_STRING( L"Junk" ),

        };

        PVOID Addr;
        ULONG i;

        Addr = MmGetSystemRoutineAddress ((PUNICODE_STRING)&RoutineA);

        DbgPrint ("Addr is %p\n", Addr);

        for (i = 0; i < sizeof (RoutineList) / sizeof (UNICODE_STRING); i += 1) {

            Addr = MmGetSystemRoutineAddress ((PUNICODE_STRING)&RoutineList[i]);

            DbgPrint ("Addr0 is %p\n", Addr);
        }
    }
}


VOID MmTestEccBadStress (
    IN PVOID IrpAddress
    )
{
    PIRP Irp = (PIRP) IrpAddress;
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG Ioctl;
    NTSTATUS Status;
    ULONG BufferSize;
    ULONG ReturnedSize;

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    Ioctl = IrpStack->Parameters.DeviceIoControl.IoControlCode;


    DbgPrint ("Buggy: mark physical memory ECC bad ioctl \n");

    {
        ULONG i;
        PPHYSICAL_MEMORY_RANGE Ranges;
        PPHYSICAL_MEMORY_RANGE p;

        PHYSICAL_ADDRESS StartAddress;
        LARGE_INTEGER NumberOfBytes;

        PHYSICAL_ADDRESS InputAddress;
        LARGE_INTEGER InputBytes;

        Ranges = MmGetPhysicalMemoryRanges ();
        if (Ranges == NULL) {
            DbgPrint ("Buggy: MmRemovePhysicalMemory cannot get ranges\n");
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return;
        }

        i = 0;
        DbgPrint("StartAddress @ %p, OverrideSize @ %p, OverrideCount @ %p\n", &OverrideStart, &OverrideSize, &OverrideCount);
        DbgBreakPoint();

        p = Ranges;
        while (p->BaseAddress.QuadPart != 0 && p->NumberOfBytes.QuadPart != 0) {
            StartAddress.QuadPart = p->BaseAddress.QuadPart;
            NumberOfBytes.QuadPart = p->NumberOfBytes.QuadPart;

            if (OverrideStart != 0) {
                StartAddress.LowPart = OverrideStart;
            }

            InputAddress.QuadPart = StartAddress.QuadPart;
            InputBytes.QuadPart = NumberOfBytes.QuadPart;

#ifdef BIG_REMOVES
            if (InputBytes.QuadPart > (64 * 1024)) {
                InputBytes.QuadPart = (64 * 1024);
            }
#else
            if (InputBytes.QuadPart > (4 * 1024)) {
                InputBytes.QuadPart = (4 * 1024);
            }
#endif

            if (OverrideSize != 0) {
                InputBytes.LowPart = OverrideSize;
            }

            while (InputAddress.QuadPart + InputBytes.QuadPart <=
                StartAddress.QuadPart + NumberOfBytes.QuadPart) {

                if (OverrideCount != 0 && i > OverrideCount) {
                    break;
                }

                i += 1;

                DbgPrint ("buggy: MmMarkPhysicalMemoryAsBad %x %x %x %x\n",
                    InputAddress.HighPart,
                    InputAddress.LowPart,
                    InputBytes.HighPart,
                    InputBytes.LowPart);

                Status = MmMarkPhysicalMemoryAsBad (&InputAddress,
                    &InputBytes);

                DbgPrint ("buggy: MmMarkPhysicalMemoryAsBad %x %x %x %x %x\n\n",
                    Status,
                    InputAddress.HighPart,
                    InputAddress.LowPart,
                    InputBytes.HighPart,
                    InputBytes.LowPart);

                KeDelayExecutionThread (KernelMode, FALSE, &BuggyOneSecond);

                if (NT_SUCCESS(Status)) {

                    DbgPrint ("buggy: MmMarkPhysicalMemoryAsGood %x %x %x %x\n",
                        InputAddress.HighPart,
                        InputAddress.LowPart,
                        InputBytes.HighPart,
                        InputBytes.LowPart);

                    Status = MmMarkPhysicalMemoryAsGood (&InputAddress,
                        &InputBytes);

                    if (NT_SUCCESS(Status)) {
                        DbgPrint ("\n\n***************\nbuggy: MmMarkPhysicalMemoryAsGood WORKED %x %x %x %x %x\n****************\n",
                            Status,
                            InputAddress.HighPart,
                            InputAddress.LowPart,
                            InputBytes.HighPart,
                            InputBytes.LowPart);
                    }
                    else {
                        DbgPrint ("buggy: MmMarkPhysicalMemoryAsGood FAILED %x %x %x %x %x\n\n",
                            Status,
                            InputAddress.HighPart,
                            InputAddress.LowPart,
                            InputBytes.HighPart,
                            InputBytes.LowPart);
                        DbgBreakPoint ();
                    }
                }

                if (InputAddress.QuadPart + InputBytes.QuadPart ==
                    StartAddress.QuadPart + NumberOfBytes.QuadPart) {

                    break;
                }

                InputAddress.QuadPart += InputBytes.QuadPart;

                if (InputAddress.QuadPart + InputBytes.QuadPart >
                    StartAddress.QuadPart + NumberOfBytes.QuadPart) {

                    InputBytes.QuadPart = StartAddress.QuadPart + NumberOfBytes.QuadPart - InputAddress.QuadPart;
                }
            }

            if (OverrideCount != 0 && i > OverrideCount) {
                break;
            }

            p += 1;
        }
        ExFreePool (Ranges);
        DbgPrint ("Buggy: MmMarkPhysicalMemory Ecc BAD test finished\n");
    }
}

////////////////////////////////////////////////////////////////////////////

typedef struct 
{
    LIST_ENTRY List;
    PVOID ChunkPointers[ ( 63 * 1024 ) / sizeof( PVOID ) ];
} ALLOCATION_TABLE, *PALLOCATION_TABLE;

LIST_ENTRY PagedPoolAllocationListHead;
LIST_ENTRY NonPagedPoolAllocationListHead;
LIST_ENTRY SessionPoolAllocationListHead;

const SIZE_T PoolChunkSize = 64 * 1024 - 32;


//
// 
//

VOID
TdpWriteSignature(
    PVOID Allocation,
    SIZE_T CurrentSize 
    )
{
    PSIZE_T CrtSignature;
    SIZE_T CrtSignatureValue;

    CrtSignature  = (PSIZE_T)Allocation;
    CrtSignatureValue = ( (SIZE_T)Allocation ) ^ CurrentSize;

    if( CurrentSize > 100 * 1024 * 1024 )
    {
        DbgPrint( "Buggy: Writing signature %p from address %p, size %p\n",
            CrtSignatureValue,
            CrtSignature,
            CurrentSize );
    }

    while( 100 * PAGE_SIZE <= CurrentSize )
    {
        *CrtSignature = CrtSignatureValue;

        CrtSignatureValue +=1;

        CrtSignature = (PSIZE_T)( (PCHAR)CrtSignature + 100 * PAGE_SIZE );
        CurrentSize -= 100 * PAGE_SIZE;
    }
}


//
//
// 

VOID
TdpVerifySignature(
    PVOID Allocation,
    SIZE_T CurrentSize )
{
    PSIZE_T CrtSignature;
    SIZE_T CrtSignatureValue;

    CrtSignature  = (PSIZE_T)Allocation;
    CrtSignatureValue = ( (SIZE_T)Allocation ) ^ CurrentSize;

    if( CurrentSize > 100 * 1024 * 1024 )
    {
        DbgPrint( "Buggy: Verifying signature %p from address %p, size %p\n",
            CrtSignatureValue,
            CrtSignature,
            CurrentSize );
    }

    while( 100 * PAGE_SIZE <= CurrentSize )
    {
        if( *CrtSignature != CrtSignatureValue )
        {
            DbgPrint ("Buggy: Signature at %p is incorrect, expected %p, base allocation %p\n",
                CrtSignature,
                CrtSignatureValue, 
                Allocation );

            DbgBreakPoint ();
        }

        CrtSignatureValue +=1;
        
        CrtSignature = (PSIZE_T)( (PCHAR)CrtSignature + 100 * PAGE_SIZE );
        CurrentSize -= 100 * PAGE_SIZE;
    }
}


//
// 
//

VOID
TdpCleanupPoolAllocationTable(
    PLIST_ENTRY ListHead,
    SIZE_T Allocations
    )
{
    PLIST_ENTRY NextEntry;
    PALLOCATION_TABLE AllocationTable;
    SIZE_T ChunksPerAllocationEntry;
    SIZE_T CrtChunksIndex;

    ChunksPerAllocationEntry = ARRAY_LENGTH( AllocationTable->ChunkPointers );

    NextEntry = ListHead->Flink;

    while( NextEntry != ListHead )
    {
        RemoveEntryList( NextEntry );

        AllocationTable = CONTAINING_RECORD( NextEntry, ALLOCATION_TABLE, List );

        DbgPrint( "Buggy: Current allocation table = %p\n",
            AllocationTable );

        for( CrtChunksIndex = 0; CrtChunksIndex < ChunksPerAllocationEntry; CrtChunksIndex++ )
        {
            if( 0 == Allocations )
            {
                //
                // Freed them all
                //

                break;
            }
            else
            {
                Allocations -= 1;

                if( 0 == Allocations % 0x100 )
                {
                    //
                    // Let the user know that we are still working on something
                    //

                    DbgPrint( "Buggy: cleaning up allocation index %p\n",
                        Allocations );
                }

                /*
                DbgPrint( "Buggy: Verify and free chunk index %p (from the end) at address %p\n",
                    Allocations,
                    AllocationTable->ChunkPointers[ CrtChunksIndex ] );
                */

                TdpVerifySignature(
                    AllocationTable->ChunkPointers[ CrtChunksIndex ],
                    PoolChunkSize );

                ExFreePoolWithTag(
                    AllocationTable->ChunkPointers[ CrtChunksIndex ],
                    TD_POOL_TAG );
            }
        }

        //
        // Free the table as well
        //

        ExFreePoolWithTag(
            AllocationTable,
            TD_POOL_TAG );

        //
        // Go to the next allocations table
        //

        NextEntry = ListHead->Flink;
    }

    //
    // At this point, Allocations should be zero and the
    // list should be empty
    //

    if( 0 != Allocations )
    {
        DbgPrint ("Buggy: Emptied the allocation table list but still have %p allocations - this is a bug\n",
            Allocations );

        DbgBreakPoint();
    }

    if( ! IsListEmpty( ListHead ) )
    {
        DbgPrint ("Buggy: No allocations left but the list at %p is not empty yet - this is a bug\n",
            ListHead );

        DbgBreakPoint();
    }
}


//
// Delay execution for a few seconds so we can get a chance to use
// !poolused, poolmon.exe, etc.
//

VOID
TdpSleep( ULONG Seconds )
{
    LARGE_INTEGER Interval = {(ULONG)(-1000 * 1000 * 10), -1}; // One second.

    DbgPrint( "Buggy: Sleeping for %u seconds\n",
		      Seconds );

    Interval.QuadPart *= Seconds;

    KeDelayExecutionThread( KernelMode,
						    FALSE,
						    &Interval );
}


//
// Determine the maximum size of a block of paged pool currently available
//

VOID
TdSysPagedPoolMaxTest(
    IN PVOID IrpAddress
    )
{
    SIZE_T CurrentSize;
    SIZE_T SizeIncrement;
    ULONG Increment;
    PVOID Allocation;

#ifdef _WIN64

    CurrentSize = 0xFFFFFFFF00000000;

#else

    CurrentSize = 0xFFFFFFFF;

#endif //#ifdef _WIN64

    do
    {
        DbgPrint ("Buggy: Trying to allocate %p bytes paged pool\n",
            CurrentSize );

        Allocation = ExAllocatePoolWithTag(
            PagedPool,
            CurrentSize,
            TD_POOL_TAG );

        if( NULL != Allocation )
        {
            DbgPrint ("Buggy: allocated %p bytes paged pool at %p\n",
                CurrentSize,
	            Allocation);

            TdpWriteSignature(
                Allocation,
                CurrentSize );

            TdpVerifySignature(
                Allocation,
                CurrentSize );

            ExFreePoolWithTag(
                Allocation,
                TD_POOL_TAG );
        }
        else
        {
            CurrentSize /= 2;
        }
    }
    while( NULL == Allocation && PAGE_SIZE <= CurrentSize );

    if( NULL != Allocation )
    {
        //
        // Try to find an even bigger size in 10% increments
        //

        SizeIncrement = CurrentSize / 10;

        if( PAGE_SIZE <= SizeIncrement )
        {
            for( Increment = 0; Increment < 10; Increment += 1 )
            {
                CurrentSize += SizeIncrement;

                DbgPrint ("Buggy: Trying to allocate %p bytes paged pool\n",
                    CurrentSize );

                Allocation = ExAllocatePoolWithTag(
                    PagedPool,
                    CurrentSize,
                    TD_POOL_TAG );

                if( NULL != Allocation )
                {
                    DbgPrint ("Buggy: Better result of the test: allocated %p bytes paged pool at %p\n",
                              CurrentSize,
                              Allocation);

                    TdpSleep( 15 );

                    TdpWriteSignature(
                        Allocation,
                        CurrentSize );
                    
                    TdpVerifySignature(
                        Allocation,
                        CurrentSize );

                    ExFreePoolWithTag(
                        Allocation,
                        TD_POOL_TAG );
                }
                else
                {
                    DbgPrint ("Buggy: could not allocate %p bytes paged pool - done\n",
                        CurrentSize );

                    break;
                }
            }
        }
    }
}


//
// Determine the total size of the paged pool currently available (64 Kb - 32 bytes blocks)
//

VOID
TdSysPagedPoolTotalTest(
    IN PVOID IrpAddress
    )
{
    SIZE_T CurrentChunkIndex;
    SIZE_T ChunksPerAllocationEntry;
    SIZE_T TotalBytes;
    PALLOCATION_TABLE AllocationListEntry;
    PVOID Allocation;

    //
    // No allocations yet
    //

    InitializeListHead( 
        &PagedPoolAllocationListHead );

    //
    // We want to allocate 64 k chunks but leave space for the pool block header
    //

    ChunksPerAllocationEntry = ARRAY_LENGTH( AllocationListEntry->ChunkPointers );

    CurrentChunkIndex = 0;

    do
    {
        if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
        {
            //
            // Need a new allocation entry structure
            //

            AllocationListEntry = (PALLOCATION_TABLE) ExAllocatePoolWithTag(
                PagedPool,
                sizeof( ALLOCATION_TABLE ),
                TD_POOL_TAG );

            if( NULL == AllocationListEntry )
            {
                DbgPrint ("Buggy: could not allocate new ALLOCATION_TABLE - aborting test here\n" );
                break;
            }

            RtlZeroMemory( 
                AllocationListEntry,
                sizeof( ALLOCATION_TABLE ) );

            DbgPrint( "Buggy: New allocation table = %p\n",
                AllocationListEntry );
        }
        
        //
        // Try to allocate a new chunk
        //

        Allocation = ExAllocatePoolWithTag(
            PagedPool,
            PoolChunkSize,
            TD_POOL_TAG );

        if( NULL == Allocation )
        {
            DbgPrint ("Buggy: could not allocate paged pool chunk index %p - done\n",
                CurrentChunkIndex );

            if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
            {
                //
                // We are using a new list entry - free it now because
                // we don't want to have empty tables in the list so we didn't insert it yet so we didn't insert it yet
                //

                ExFreePoolWithTag( 
                    AllocationListEntry,
                    TD_POOL_TAG );
            }
        }
        else
        {
            if( 0 == CurrentChunkIndex % 0x100 )
            {
                //
                // Let the user know that we are still working on something
                //

                DbgPrint( "Buggy: Allocated pool chunk index = %p\n",
                    CurrentChunkIndex );
            }

            if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
            {
                //
                // We are using a new list entry - add it to our list only now because
                // we don't want to have empty tables in the list so we didn't insert it yet
                //

                InsertTailList(
                    &PagedPoolAllocationListHead,
                    &AllocationListEntry->List );
            }

            AllocationListEntry->ChunkPointers[ CurrentChunkIndex % ChunksPerAllocationEntry ] = Allocation;

            TdpWriteSignature(
                Allocation,
                PoolChunkSize );

            /*
            DbgPrint( "Buggy: Written signature to chunk index %p at address %p\n",
                CurrentChunkIndex,
                Allocation );
            */

            CurrentChunkIndex += 1;
        }    
    }
    while( NULL != Allocation );

    TotalBytes = CurrentChunkIndex * 64 * 1024;

    DbgPrint ("Buggy: Result of the test: approx. %p total bytes of paged pool allocated\n",
        TotalBytes );

    //
    // Clean-up what we have allocated
    //

    TdpCleanupPoolAllocationTable( 
        &PagedPoolAllocationListHead,
        CurrentChunkIndex );
}


VOID
TdNonPagedPoolMaxTest(
    IN PVOID IrpAddress
    )
{
    SIZE_T CurrentSize;
    SIZE_T SizeIncrement;
    ULONG Increment;
    PVOID Allocation;

#ifdef _WIN64

    CurrentSize = 0xFFFFFFFF00000000;

#else

    CurrentSize = 0xFFFFFFFF;

#endif //#ifdef _WIN64

    do
    {
        DbgPrint ("Buggy: Trying to allocate %p bytes non-paged pool\n",
                  CurrentSize );

        Allocation = ExAllocatePoolWithTag(
            NonPagedPool,
            CurrentSize,
            TD_POOL_TAG );

        if( NULL != Allocation )
        {
            DbgPrint ("Buggy: allocated %p bytes non-paged pool at %p\n",
                      CurrentSize,
                      Allocation);

            TdpWriteSignature(
                Allocation,
                CurrentSize );

            ExFreePoolWithTag(
                Allocation,
                TD_POOL_TAG );
        }
        else
        {
            CurrentSize /= 2;
        }
    }
    while( NULL == Allocation && PAGE_SIZE <= CurrentSize );

    if( NULL != Allocation )
    {
        //
        // Try to find an even bigger size in 10% increments
        //

        SizeIncrement = CurrentSize / 10;

        if( PAGE_SIZE <= SizeIncrement )
        {
            for( Increment = 0; Increment < 10; Increment += 1 )
            {
                CurrentSize += SizeIncrement;

                DbgPrint ("Buggy: Trying to allocate %p bytes non-paged pool\n",
                    CurrentSize );

                Allocation = ExAllocatePoolWithTag(
                    NonPagedPool,
                    CurrentSize,
                    TD_POOL_TAG );

                if( NULL != Allocation )
                {
                    DbgPrint ("Buggy: Better result of the test: allocated %p bytes non-paged pool at %p\n",
                              CurrentSize,
                              Allocation);

                    TdpSleep( 15 );

                    TdpWriteSignature(
                        Allocation,
                        CurrentSize );

                    TdpVerifySignature(
                        Allocation,
                        CurrentSize );

                    ExFreePoolWithTag(
                        Allocation,
                        TD_POOL_TAG );
                }
                else
                {
                    DbgPrint ("Buggy: could not allocate %p bytes non-paged pool - done\n",
                        CurrentSize );

                    break;
                }
            }
        }
    }
}


//
// Determine the total size of the non-paged pool currently available (64 Kb - 32 bytes blocks)
//

VOID
TdNonPagedPoolTotalTest(
    IN PVOID IrpAddress
    )
{
    SIZE_T CurrentChunkIndex;
    SIZE_T ChunksPerAllocationEntry;
    SIZE_T TotalBytes;
    PALLOCATION_TABLE AllocationListEntry;
    PVOID Allocation;

    //
    // No allocations yet
    //

    InitializeListHead( 
        &NonPagedPoolAllocationListHead );

    //
    // We want to allocate 64 k chunks but leave space for the pool block header
    //

    ChunksPerAllocationEntry = ARRAY_LENGTH( AllocationListEntry->ChunkPointers );

    CurrentChunkIndex = 0;

    do
    {
        if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
        {
            //
            // Need a new allocation entry structure
            //

            AllocationListEntry = (PALLOCATION_TABLE) ExAllocatePoolWithTag(
                PagedPool,
                sizeof( ALLOCATION_TABLE ),
                TD_POOL_TAG );

            if( NULL == AllocationListEntry )
            {
                DbgPrint ("Buggy: could not allocate new ALLOCATION_TABLE - aborting test here\n" );
                break;
            }
        }
        
        //
        // Try to allocate a new chunk
        //

        Allocation = ExAllocatePoolWithTag(
            NonPagedPool,
            PoolChunkSize,
            TD_POOL_TAG );

        if( NULL == Allocation )
        {
            DbgPrint ("Buggy: could not allocate non-paged pool chunk index %p - done\n",
                CurrentChunkIndex );

            if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
            {
                //
                // We are using a new list entry - free it now because
                // we don't want to have empty tables in the list so we didn't insert it yet so we didn't insert it yet
                //

                ExFreePoolWithTag( 
                    AllocationListEntry,
                    TD_POOL_TAG );
            }
        }
        else
        {
            if( 0 == CurrentChunkIndex % 0x100 )
            {
                //
                // Let the user know that we are still working on something
                //

                DbgPrint( "Buggy: Allocated pool chunk index = %p\n",
                    CurrentChunkIndex );
            }

            if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
            {
                //
                // We are using a new list entry - add it to our list only now because
                // we don't want to have empty tables in the list so we didn't insert it yet
                //

                InsertTailList(
                    &NonPagedPoolAllocationListHead,
                    &AllocationListEntry->List );
            }

            AllocationListEntry->ChunkPointers[ CurrentChunkIndex % ChunksPerAllocationEntry ] = Allocation;

            TdpWriteSignature(
                Allocation,
                PoolChunkSize );

            CurrentChunkIndex += 1;
        }    
    }
    while( NULL != Allocation );

    TotalBytes = CurrentChunkIndex * 64 * 1024;

    DbgPrint ("Buggy: Result of the test: approx. %p total bytes of non-paged pool allocated\n",
        TotalBytes );

    //
    // Clean-up what we have allocated
    //

    TdpCleanupPoolAllocationTable( 
        &NonPagedPoolAllocationListHead,
        CurrentChunkIndex );
}

/////////////////////////////////////////////////////////////////////////////////////


typedef struct 
{
    LIST_ENTRY List;
    PMDL Mappings[ ( 63 * 1024 ) / sizeof( PMDL ) ];
} MAPPING_TABLE_ENTRY, *PMAPPING_TABLE_ENTRY;

LIST_ENTRY IoMappingsListHead;

ULONG BytesPerIoMapping = 1024 * 1024;


//
// 
//

VOID
TdpCleanupMappingsAllocationTable(
    PLIST_ENTRY ListHead,
    SIZE_T Mappings
    )
{
    PLIST_ENTRY NextEntry;
    PMAPPING_TABLE_ENTRY MappingTableEntry;
    SIZE_T MappingsPerMappingTableEntry;
    SIZE_T CrtMappingIndex;

    MappingsPerMappingTableEntry = ARRAY_LENGTH( MappingTableEntry->Mappings );

    NextEntry = ListHead->Flink;

    while( NextEntry != ListHead )
    {
        RemoveEntryList( NextEntry );

        MappingTableEntry = CONTAINING_RECORD( NextEntry, MAPPING_TABLE_ENTRY, List );

        for( CrtMappingIndex = 0; CrtMappingIndex < MappingsPerMappingTableEntry; CrtMappingIndex++ )
        {
            if( 0 == Mappings )
            {
                //
                // Freed them all
                //

                break;
            }
            else
            {
                Mappings -= 1;

                if( 0 == Mappings % 0x100 )
                {
                    //
                    // Let the user know that we are still working on something
                    //

                    DbgPrint( "Buggy: cleaning up mapping index %p\n",
                        Mappings );
                }

                //
                // Unmap
                //

                MmUnmapIoSpace(
                    MappingTableEntry->Mappings[ CrtMappingIndex ],
                    BytesPerIoMapping );
            }
        }

        //
        // Free the table as well
        //

        ExFreePoolWithTag(
            MappingTableEntry,
            TD_POOL_TAG );

        //
        // Go to the next allocations table
        //

        NextEntry = ListHead->Flink;
    }

    //
    // At this point, Mappings should be zero and the
    // list should be empty
    //

    if( 0 != Mappings )
    {
        DbgPrint ("Buggy: Emptied the mappings table list but still have %p allocations - this is a bug\n",
            Mappings );

        DbgBreakPoint();
    }

    if( ! IsListEmpty( ListHead ) )
    {
        DbgPrint ("Buggy: No mappings left but the list at %p is not empty yet - this is a bug\n",
            ListHead );

        DbgBreakPoint();
    }
}


//
// Determine the total amount of memory that can be mapped using system PTEs (1 Mb chunks)
//

VOID
TdFreeSystemPtesTest(
    IN PVOID IrpAddress
    )
{
    ULONG MemType;
    PHYSICAL_ADDRESS PortAddress;
    PHYSICAL_ADDRESS MyPhysicalAddress;
    SIZE_T CurrentMappingIndex;
    SIZE_T MappingsPerMappingTableEntry;
    SIZE_T TotalBytes;
    PVOID NewMapping;
    PMAPPING_TABLE_ENTRY MappingTableEntry;
    PMDL NewMdl;
    NTSTATUS Status;

    //
    // Use some joystick port address
    //

    MemType = 1;                 // IO space
    PortAddress.LowPart = 0x200;
    PortAddress.HighPart = 0;

    HalTranslateBusAddress(
                Isa,
                0,
                PortAddress,
                &MemType,
                &MyPhysicalAddress);

    //
    // No Mappings allocated yet
    //

    InitializeListHead( 
        &IoMappingsListHead );

    //
    // Map a ~64 Kb chunk over and over again to consume system PTEs
    //

    MappingsPerMappingTableEntry = ARRAY_LENGTH( MappingTableEntry->Mappings );

    CurrentMappingIndex = 0;

    do
    {
        if( 0 == CurrentMappingIndex % MappingsPerMappingTableEntry )
        {
            //
            // Need a new allocation entry structure
            //

            MappingTableEntry = (PMAPPING_TABLE_ENTRY) ExAllocatePoolWithTag(
                PagedPool,
                sizeof( MAPPING_TABLE_ENTRY ),
                TD_POOL_TAG );

            if( NULL == MappingTableEntry )
            {
                DbgPrint ("Buggy: could not allocate new MAPPING_TABLE_ENTRY - aborting test here\n" );
                break;
            }
        }

        NewMapping = MmMapIoSpace(
            MyPhysicalAddress,
            BytesPerIoMapping,
            MmNonCached );

        if( NULL == NewMapping )
        {
            DbgPrint ("Buggy: could not create mapping index %p\n",
                CurrentMappingIndex );

            if( 0 == CurrentMappingIndex % MappingsPerMappingTableEntry )
            {
                //
                // We are using a new list entry - free it now because
                // we don't want to have empty tables in the list so we didn't insert it yet so we didn't insert it yet
                //
                
                ExFreePoolWithTag(
                    MappingTableEntry,
                    TD_POOL_TAG );
            }
        }
        else
        {
            //DbgPrint ("Buggy: created Mapping index %p at address %p\n",
            //    CurrentMappingIndex,
            //    NewMapping );

            if( 0 == CurrentMappingIndex % 0x100 )
            {
                //
                // Let the user know that we are still working on something
                //

                DbgPrint( "Buggy: mapped chunk index = %p\n",
                    CurrentMappingIndex );
            }

            if( 0 == CurrentMappingIndex % MappingsPerMappingTableEntry )
            {
                //
                // We are using a new list entry - add it to our list only now because
                // we don't want to have empty tables in the list so we didn't insert it yet
                //

                InsertTailList(
                    &IoMappingsListHead,
                    &MappingTableEntry->List );
            }

            MappingTableEntry->Mappings[ CurrentMappingIndex % MappingsPerMappingTableEntry ] = NewMapping;

            CurrentMappingIndex += 1;
         }
    }
    while( NULL != NewMapping );

    TotalBytes = CurrentMappingIndex * BytesPerIoMapping;

    DbgPrint( "Buggy: Result of the test: %p total bytes mapped\n",
        TotalBytes );

    //
    // Clean-up what we have allocated and locked
    //

    TdpCleanupMappingsAllocationTable( 
        &IoMappingsListHead,
        CurrentMappingIndex );
}


//
// Function:
//
//     GetTag
//
// Description:
//
//     This function transforms an integer into a four letter
//     string. This is useful for the pool tag dynamic table
//     in order to populate it with many different tags.
//

ULONG
    GetTag (
    ULONG Index
    )
{
    UCHAR Value[4];

    Value[0] = (UCHAR)(((Index & 0x000F) >> 0 )) + 'A';
    Value[1] = (UCHAR)(((Index & 0x00F0) >> 4 )) + 'A';
    Value[2] = (UCHAR)(((Index & 0x0F00) >> 8 )) + 'A';
    Value[3] = (UCHAR)(((Index & 0xF000) >> 12)) + 'A';

    return *((PULONG)Value);
}



VOID
StressPoolFlag (
    PVOID NotUsed
    )
/*++

Routine Description:

    This function iterates through all the pool types, pool flags
    and pool sizes (1 .. 8 * PAGE_SIZE).

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    POOL_TYPE PoolType;
    SIZE_T NumberOfBytes;
    EX_POOL_PRIORITY Priority;
    PVOID Va;
    ULONG i;

    for (PoolType = NonPagedPool; PoolType < 0xff; PoolType += 1) {
        for (Priority = LowPoolPriority; Priority < LowPoolPriority + 2; Priority += 1) {
            for (i = 1; i < 8 * PAGE_SIZE; i += 1) {

                NumberOfBytes = i;

                if (PoolType & 0x40) { 
                    break;
                }

                if ((NumberOfBytes > PAGE_SIZE) && (PoolType & 0x2)) {
                    break;
                }

                try {
                    Va = ExAllocatePoolWithTagPriority (
                        PoolType,
                        NumberOfBytes,
                        'ZXCV',
                        Priority);
                }
                except (EXCEPTION_EXECUTE_HANDLER) {

                    if (Verbosity & VERBOSITY_PRINT) {
                        DbgPrint( "buggy: ExAllocatePool exceptioned %x %x %x\n",
                            PoolType, NumberOfBytes, Priority);
                    }

                    if (Verbosity & VERBOSITY_BREAK) {
                        DbgBreakPoint ();
                    }

                    Va = NULL;
                }

                if (Va) {
                    ExFreePool (Va);
                }
                else {
                    
                    if (Verbosity & VERBOSITY_PRINT) {
                        DbgPrint( "buggy: ExAllocatePool failed %x %x %x\n",
                            PoolType, NumberOfBytes, Priority);
                    }
                    
                    if (Verbosity & VERBOSITY_BREAK) {
                        DbgBreakPoint ();
                    }
                }
            }
        }
    }

    DbgPrint ("Buggy: ExAllocatePoolFlag test finished\n");
}



VOID 
StressPoolTagTableExtension (
    PVOID NotUsed
    )
/*++

Routine Description:

    This function stresses the pool tag table dynamic extension.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    PVOID * Blocks;
    ULONG Index;

    Blocks = ExAllocatePoolWithTag (
        NonPagedPool,
        16384 * sizeof(PVOID),
        'tguB');

    if (Blocks == NULL) {
        DbgPrint ("Buggy: cannot allocate pool buffer\n");
    }
    else {

        //
        // Loop with 8 byte size.
        //

        for (Index = 0; Index < 10000; Index++) {

            if (Index && Index % 100 == 0) {
                DbgPrint ("Index(a): %u \n", Index);
            }

            Blocks[Index] = ExAllocatePoolWithTag (
                NonPagedPool,
                8,
                GetTag(Index));
        }

        for (Index = 0; Index < 10000; Index++) {

            if (Index && Index % 100 == 0) {
                DbgPrint ("Index(f): %u \n", Index);
            }

            if (Blocks[Index]) {
                ExFreePool (Blocks[Index]);
            }
        }

        //
        // Loop with PAGE_SIZE byte size.
        //

        for (Index = 0; Index < 4000; Index++) {

            if (Index && Index % 100 == 0) {
                DbgPrint ("Index(A): %u \n", Index);
            }

            Blocks[Index] = ExAllocatePoolWithTag (
                NonPagedPool,
                PAGE_SIZE,
                GetTag(Index + 16384));
        }

        for (Index = 0; Index < 4000; Index++) {

            if (Index && Index % 100 == 0) {
                DbgPrint ("Index(F): %u \n", Index);
            }

            if (Blocks[Index]) {
                ExFreePool (Blocks[Index]);
            }
        }

        //
        // Free block info.
        //

        ExFreePool (Blocks);
    }
}


//
// Determine the maximum size of a block of session pool currently available
//

VOID
TdSessionPoolMaxTest(
    IN PVOID IrpAddress
    )
{
    SIZE_T CurrentSize;
    SIZE_T SizeIncrement;
    ULONG Increment;
    PVOID Allocation;

#ifdef _WIN64

    CurrentSize = 0xFFFFFFFF00000000;

#else

    CurrentSize = 0xFFFFFFFF;

#endif //#ifdef _WIN64

    do
    {
        DbgPrint ("Buggy: Trying to allocate %p bytes session pool\n",
            CurrentSize );

        Allocation = ExAllocatePoolWithTag(
            PagedPool | SESSION_POOL_MASK,
            CurrentSize,
            TD_POOL_TAG );

        if( NULL != Allocation )
        {
            DbgPrint ("Buggy: allocated %p bytes session pool at %p\n",
                      CurrentSize,
                      Allocation);

            TdpWriteSignature(
                Allocation,
                CurrentSize );

            ExFreePoolWithTag(
                Allocation,
                TD_POOL_TAG );
        }
        else
        {
            CurrentSize /= 2;
        }
    }
    while( NULL == Allocation && PAGE_SIZE <= CurrentSize );

    if( NULL != Allocation )
    {
        //
        // Try to find an even bigger size in 10% increments
        //

        SizeIncrement = CurrentSize / 10;

        if( PAGE_SIZE <= SizeIncrement )
        {
            for( Increment = 0; Increment < 10; Increment += 1 )
            {
                CurrentSize += SizeIncrement;

                DbgPrint ("Buggy: Trying to allocate %p bytes session pool\n",
                    CurrentSize );

                Allocation = ExAllocatePoolWithTag(
                    PagedPool | SESSION_POOL_MASK,
                    CurrentSize,
                    TD_POOL_TAG );

                if( NULL != Allocation )
                {
                    DbgPrint ("Buggy: Better result of the test: allocated %p bytes sesssion pool at %p\n",
                              CurrentSize,
                              Allocation);

					TdpSleep( 15 );

                    TdpWriteSignature(
                        Allocation,
                        CurrentSize );
                    
                    TdpVerifySignature(
                        Allocation,
                        CurrentSize );

                    ExFreePoolWithTag(
                        Allocation,
                        TD_POOL_TAG );
                }
                else
                {
                    DbgPrint ("Buggy: could not allocate %p bytes session pool - done\n",
                        CurrentSize );

                    break;
                }
            }
        }
    }
}


//
// Determine the total size of the session pool currently available (64 Kb - 32 bytes blocks)
//

VOID
TdSessionPoolTotalTest(
    IN PVOID IrpAddress
    )
{
    SIZE_T CurrentChunkIndex;
    SIZE_T ChunksPerAllocationEntry;
    SIZE_T TotalBytes;
    PALLOCATION_TABLE AllocationListEntry;
    PVOID Allocation;

    //
    // No allocations yet
    //

    InitializeListHead( 
        &SessionPoolAllocationListHead );

    //
    // We want to allocate 64 k chunks but leave space for the pool block header
    //

    ChunksPerAllocationEntry = ARRAY_LENGTH( AllocationListEntry->ChunkPointers );

    CurrentChunkIndex = 0;

    do
    {
        if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
        {
            //
            // Need a new allocation entry structure
            //

            AllocationListEntry = (PALLOCATION_TABLE) ExAllocatePoolWithTag(
                PagedPool | SESSION_POOL_MASK,
                sizeof( ALLOCATION_TABLE ),
                TD_POOL_TAG );

            if( NULL == AllocationListEntry )
            {
                DbgPrint ("Buggy: could not allocate new ALLOCATION_TABLE - aborting test here\n" );
                break;
            }

            RtlZeroMemory( 
                AllocationListEntry,
                sizeof( ALLOCATION_TABLE ) );

            DbgPrint( "Buggy: New allocation table = %p\n",
                AllocationListEntry );
        }
        
        //
        // Try to allocate a new chunk
        //

        Allocation = ExAllocatePoolWithTag(
            PagedPool | SESSION_POOL_MASK,
            PoolChunkSize,
            TD_POOL_TAG );

        if( NULL == Allocation )
        {
            DbgPrint ("Buggy: could not allocate session pool chunk index %p - done\n",
                CurrentChunkIndex );

            if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
            {
                //
                // We are using a new list entry - free it now because
                // we don't want to have empty tables in the list so we didn't insert it yet so we didn't insert it yet
                //

                ExFreePoolWithTag( 
                    AllocationListEntry,
                    TD_POOL_TAG );
            }
        }
        else
        {
            if( 0 == CurrentChunkIndex % 0x100 )
            {
                //
                // Let the user know that we are still working on something
                //

                DbgPrint( "Buggy: Allocated pool chunk index = %p\n",
                    CurrentChunkIndex );
            }

            if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
            {
                //
                // We are using a new list entry - add it to our list only now because
                // we don't want to have empty tables in the list so we didn't insert it yet
                //

                InsertTailList(
                    &SessionPoolAllocationListHead,
                    &AllocationListEntry->List );
            }

            AllocationListEntry->ChunkPointers[ CurrentChunkIndex % ChunksPerAllocationEntry ] = Allocation;

            TdpWriteSignature(
                Allocation,
                PoolChunkSize );

            /*
            DbgPrint( "Buggy: Written signature to chunk index %p at address %p\n",
                CurrentChunkIndex,
                Allocation );
            */

            CurrentChunkIndex += 1;
        }    
    }
    while( NULL != Allocation );

    TotalBytes = CurrentChunkIndex * 64 * 1024;

    DbgPrint ("Buggy: Result of the test: approx. %p total bytes of session pool allocated\n",
        TotalBytes );

    //
    // Clean-up what we have allocated
    //

    TdpCleanupPoolAllocationTable( 
        &SessionPoolAllocationListHead,
        CurrentChunkIndex );
}


//
// 
//


#define BUGGY_PAGE_DIRECTORY_BOUNDARY ((PVOID)0x40000000)
#define BUGGY_VAD_GRANULARITY (64 * 1024)

#if defined( _IA64_ )
#define BUGGY_PDE_GRANULARITY (8 * 1024 * 1024)
#elif defined( _AMD64_ )
#define BUGGY_PDE_GRANULARITY (2 * 1024 * 1024)
#else
#define BUGGY_PDE_GRANULARITY (4 * 1024 * 1024)
#endif

typedef struct _BUGGY_PAGEDPOOLMDLTEST {

    PVOID RequestedUserVa;
    PMDL Mdl;
    PVOID MappedAddress;
    ULONG NumberOfPages;

} BUGGY_PAGEDPOOLMDLTEST, *PBUGGY_PAGEDPOOLMDLTEST;

BUGGY_PAGEDPOOLMDLTEST PagedPoolMdlTestArray [] =
{
    {BUGGY_PAGE_DIRECTORY_BOUNDARY,                                NULL, NULL, 3},
    {(PCHAR)BUGGY_PAGE_DIRECTORY_BOUNDARY + BUGGY_VAD_GRANULARITY, NULL, NULL, 3},
    {(PCHAR)BUGGY_PAGE_DIRECTORY_BOUNDARY - BUGGY_VAD_GRANULARITY, NULL, NULL, 3},
    {(PCHAR)BUGGY_PAGE_DIRECTORY_BOUNDARY + BUGGY_PDE_GRANULARITY - BUGGY_VAD_GRANULARITY,
        NULL, NULL, (2 * BUGGY_VAD_GRANULARITY) / PAGE_SIZE}
};


VOID
TdNonPagedPoolMdlTestMap(
    IN PVOID IrpAddress
    )
{
    PVOID VirtualAddress;
    ULONG MapIndex;
    ULONG SizeToMap;

#if defined( _IA64_ )
    //
    // IA64
    //
    // 0xe0000168`02000000 maps NonCached 0x800 pages starting with PFN 0x78000 on dmihai-ita.
    //

    VirtualAddress = (PVOID)0xe000016802000000;
#elif defined( _AMD64_ )
    //
    // AMD64
    //
    // 0xfffffadf`f0a91000 maps WriteCombined 0x100 pages starting with PFN 0xd0200 on dmihai-amd64.
    //

    //VirtualAddress = (PVOID)0xffffffffffd00000;
    VirtualAddress = (PVOID)0xfffffadff0a91000;
#else
    //
    // X86
    //
    // f1000000 maps NonChached 0x800 pages starting with PFN f5000 on dmihai-amd.
    //

    VirtualAddress = (PVOID)0xf1000000;
#endif

    for (MapIndex = 0 ; MapIndex < ARRAY_LENGTH (PagedPoolMdlTestArray); MapIndex += 1) 
    {
        //
        //
        // 

        SizeToMap = PAGE_SIZE * PagedPoolMdlTestArray [MapIndex].NumberOfPages;

        PagedPoolMdlTestArray [MapIndex].Mdl = IoAllocateMdl (VirtualAddress,
                                                              SizeToMap,
                                                              FALSE,
                                                              FALSE,
                                                              NULL);

        if (PagedPoolMdlTestArray [MapIndex].Mdl == NULL)
        {
            DbgPrint ("IoAllocateMdl failed\n");
            return;
        }

        DbgPrint ("Mdl %p allocated\n",
                  PagedPoolMdlTestArray [MapIndex].Mdl);

        //
        // 
        //

        MmBuildMdlForNonPagedPool (PagedPoolMdlTestArray [MapIndex].Mdl);

        //
        //
        //

        /*
        UserVANonPagedPoolMdlTest = MmMapLockedPages (MdlNonPagedPoolMdlTest,
                                                    UserMode);
        */

        PagedPoolMdlTestArray [MapIndex].MappedAddress = MmMapLockedPagesSpecifyCache (
                                                            PagedPoolMdlTestArray [MapIndex].Mdl,
                                                            UserMode,
                                                            MmNonCached,
                                                            PagedPoolMdlTestArray [MapIndex].RequestedUserVa,
                                                            FALSE,
                                                            HighPagePriority);

        DbgPrint ("Mapped %p bytes at address %p\n",
                  SizeToMap,
                  PagedPoolMdlTestArray [MapIndex].MappedAddress);
    }

    //DbgBreakPoint ();
}

VOID
TdNonPagedPoolMdlTestUnMap(
    IN PVOID IrpAddress
    )
{
    ULONG MapIndex;

    for (MapIndex = 0 ; MapIndex < ARRAY_LENGTH (PagedPoolMdlTestArray); MapIndex += 1) 
    {
        if (PagedPoolMdlTestArray [MapIndex].MappedAddress != NULL)
        {
            //
            // Unmap
            // 

            MmUnmapLockedPages (PagedPoolMdlTestArray [MapIndex].MappedAddress,
                                PagedPoolMdlTestArray [MapIndex].Mdl);

            PagedPoolMdlTestArray [MapIndex].MappedAddress = NULL;
        }

        if (PagedPoolMdlTestArray [MapIndex].Mdl != NULL)
        {
            //
            // Free Mdl
            //

            IoFreeMdl (PagedPoolMdlTestArray [MapIndex].Mdl);

            PagedPoolMdlTestArray [MapIndex].Mdl = NULL;
        }
    }
}


#endif // #if !MMTESTS_ACTIVE

//
// End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\physmem.c ===
//
// Buggy.sys
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  physmem.c
// Author:  Silviu Calinoiu (SilviuC)
// Created: 4/20/1999 2:39pm
//
// This module contains stress functions for physical memory
// manipulation routines and also some pool allocaiton routines.
//
// --- History ---
//
// 08/14/99 (SilviuC): initial version (integrating code got from LandyW).
//

#include <ntddk.h>

#include "active.h"
#include "physmem.h"

#if !PHYSMEM_ACTIVE

//
// Dummy implementation if the module is inactive
//

LARGE_INTEGER BuggyOneSecond = {(ULONG)(-10 * 1000 * 1000 * 1), -1};

VOID PhysmemDisabled (VOID)
{
    DbgPrint ("Buggy: physmem module is disabled (check \\driver\\active.h header) \n");
}

VOID
StressAllocateContiguousMemory (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

VOID
StressAllocateCommonBuffer (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

VOID
StressAddPhysicalMemory (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

VOID
StressDeletePhysicalMemory (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

VOID
StressLockScenario (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

VOID
StressPhysicalMemorySimple (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

#else

//
// Real implementation if the module is active
//


//////////////////////////

#define MAX_BUFFER_SIZE     (2 * 1024 * 1024)

// #define BUFFER_SIZE         (32 * 1024)

// ULONG uBufferSize = (64 * 1024);
ULONG uBufferSize = (4 * 1024);

int zlw = 3;

LARGE_INTEGER BuggyTenSeconds = {(ULONG)(-10 * 1000 * 1000 * 10), -1};
LARGE_INTEGER BuggyOneSecond = {(ULONG)(-10 * 1000 * 1000 * 1), -1};




VOID
StressAllocateContiguousMemory (
    PVOID NotUsed
    )
/*++

Routine Description:

Arguments:

Return Value:

Environment:

--*/
{
    PHYSICAL_ADDRESS LogicalAddress;
    PVOID VirtualAddress;
    ULONG j;
    ULONG i;
    ULONG k;
    PULONG_PTR p;
    PVOID MyVirtualAddress[16];
    PHYSICAL_ADDRESS MyLogicalAddress[16];
    ULONG MySize[16];
    PHYSICAL_ADDRESS LowestAcceptableAddress;
    PHYSICAL_ADDRESS HighestAcceptableAddress;
    PHYSICAL_ADDRESS BoundaryAddressMultiple;
    MEMORY_CACHING_TYPE CacheType;

    DbgPrint ("Buggy: MmAllocateContiguousMemorySpecifyCache stress ioctl \n");

    //
    // allocate the buffer
    //

    uBufferSize = (64 * 1024);

    LowestAcceptableAddress.QuadPart = 0;
    HighestAcceptableAddress.QuadPart = 0x100000;
    BoundaryAddressMultiple.QuadPart = 0;
    LogicalAddress.QuadPart = 0;

    for (k = 0; k <= 12; k += 1) {

        if (k < 4) {
            LowestAcceptableAddress.QuadPart = 0;
            HighestAcceptableAddress.QuadPart = 0x1000000;
            BoundaryAddressMultiple.QuadPart = 0x10000;
        }
        else if (k < 4) {
            LowestAcceptableAddress.QuadPart = 0x1000000;
            HighestAcceptableAddress.QuadPart = 0x2000000;
            BoundaryAddressMultiple.QuadPart = 0;
        }
        else {
            LowestAcceptableAddress.QuadPart = 0x1800000;
            HighestAcceptableAddress.QuadPart = 0x4000000;
            BoundaryAddressMultiple.QuadPart = 0x30000;
        }

        for (CacheType = MmCached; CacheType <= MmWriteCombined; CacheType += 1) {

            for (i = 0; i < 16; i += 1) {

                DbgPrint( "buffer size = %08X\n", uBufferSize );
                if (uBufferSize == 0) {
                    MyVirtualAddress[i] = NULL;
                    continue;
                }

                VirtualAddress = MmAllocateContiguousMemorySpecifyCache (
                    uBufferSize,
                    LowestAcceptableAddress,
                    HighestAcceptableAddress,
                    BoundaryAddressMultiple,
                    CacheType);

                if (VirtualAddress == NULL) {
                    DbgPrint( "buggy: MmAllocateContiguousMemSpecifyCache( %08X ) failed\n",
                        (ULONG) uBufferSize );

                    // Status = STATUS_DRIVER_INTERNAL_ERROR;
                    MyVirtualAddress[i] = NULL;
                }
                else {

                    DbgPrint( "buggy: MmAllocateContiguousMemSpecifyCache( %p %08X ) - success\n",
                        VirtualAddress, (ULONG) uBufferSize);

                    MyVirtualAddress[i] = VirtualAddress;
                    MyLogicalAddress[i] = LogicalAddress;
                    MySize[i] = uBufferSize;

                    p = VirtualAddress;

                    for (j = 0; j < uBufferSize / sizeof(ULONG_PTR); j += 1) {
                        *p = ((ULONG_PTR)VirtualAddress + j);
                        p += 1;
                    }
                }
                uBufferSize -= PAGE_SIZE;
            }

            for (i = 0; i < 16; i += 1) {
                if (MyVirtualAddress[i]) {
                    DbgPrint( "buggy: MmFreeContiguousMemorySpecifyCache( %x %08X )\n",
                        MyVirtualAddress[i], (ULONG) MySize[i]);

                    MmFreeContiguousMemorySpecifyCache (MyVirtualAddress[i],
                        MySize[i],
                        CacheType);
                }
            }
        }
    }
    DbgPrint ("Buggy: MmAllocateContiguousMemSpecifyCache test finished\n");
}



VOID
StressAllocateCommonBuffer (
    PVOID NotUsed
    )
/*++

Routine Description:

Arguments:

Return Value:

Environment:

--*/
{
    DEVICE_DESCRIPTION DeviceDescription;      // DMA adapter object description
    PADAPTER_OBJECT pAdapterObject;            // DMA adapter object 
    ULONG NumberOfMapRegisters;
    PHYSICAL_ADDRESS LogicalAddress;
    PVOID VirtualAddress;
    ULONG j;
    ULONG i;
    PULONG_PTR p;
    PVOID MyVirtualAddress[16];
    PHYSICAL_ADDRESS MyLogicalAddress[16];
    ULONG MySize[16];

    DbgPrint ("Buggy: HalAllocateCommonBuffer stress ioctl \n");

    //
    // Zero the device description structure.
    //

    RtlZeroMemory(&DeviceDescription, sizeof(DEVICE_DESCRIPTION));

    //
    // Get the adapter object for this card.
    //

    DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
    DeviceDescription.DmaChannel = 0;
    DeviceDescription.InterfaceType = Internal;
    DeviceDescription.DmaWidth = Width8Bits;
    DeviceDescription.DmaSpeed = Compatible;
    DeviceDescription.MaximumLength = MAX_BUFFER_SIZE;
    DeviceDescription.BusNumber = 0;

    pAdapterObject = HalGetAdapter (&DeviceDescription,
        &NumberOfMapRegisters);

    if ( pAdapterObject == NULL ) {
        DbgPrint( "buggy: HalGetAdapter - failed\n" );
        // return STATUS_DRIVER_INTERNAL_ERROR;
        return;
    }

    DbgPrint( "buggy: HalGetAdapter - success\n" );

    //
    // allocate the buffer
    //

    uBufferSize = (64 * 1024);

    for (i = 0; i < 16; i += 1) {

        DbgPrint( "buffer size = %08X\n", uBufferSize );

        VirtualAddress = HalAllocateCommonBuffer (pAdapterObject,
            uBufferSize,
            &LogicalAddress,
            FALSE );

        if (VirtualAddress == NULL) {
            DbgPrint( "buggy: HalAllocateCommonBuffer( %08X ) failed\n",
                (ULONG) uBufferSize );

            // Status = STATUS_DRIVER_INTERNAL_ERROR;
            MyVirtualAddress[i] = NULL;
        }
        else {

            DbgPrint( "buggy: HalAllocateCommonBuffer( %p %08X ) - success\n",
                VirtualAddress, (ULONG) uBufferSize);

            MyVirtualAddress[i] = VirtualAddress;
            MyLogicalAddress[i] = LogicalAddress;
            MySize[i] = uBufferSize;

            p = VirtualAddress;

            for (j = 0; j < uBufferSize / sizeof(ULONG_PTR); j += 1) {
                *p = ((ULONG_PTR)VirtualAddress + j);
                p += 1;
            }
        }
        uBufferSize -= PAGE_SIZE;
    }

    for (i = 0; i < 16; i += 1) {
        if (MyVirtualAddress[i]) {
            DbgPrint( "buggy: HalFreeCommonBuffer( %x %08X )\n",
                MyVirtualAddress[i], (ULONG) MySize[i]);
            HalFreeCommonBuffer(
                pAdapterObject,
                MySize[i],
                MyLogicalAddress[i],
                MyVirtualAddress[i],
                FALSE );
        }
    }
    
    DbgPrint ("Buggy: HalAllocateCommonBuffer test finished\n");
    // LWFIX: Halfreeadapter needed ?
}



LOGICAL StopToEdit = TRUE;
PFN_NUMBER TestBasePage;
PFN_NUMBER TestPageCount; 

VOID 
EditPhysicalMemoryParameters (
    )
/*++

Routine Description:

    This function is called from StressAdd/DeletePhysicalMemory
    to allow user to set the parameters for stress (what region should
    be used for add/remove ?).

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    DbgPrint ("`dd nt!mmphysicalmemoryblock l1' should give the address of memory descriptor\n");
    DbgPrint ("`dd ADDRESS' (first dword displayed by previous command) gives description\n");
    DbgPrint ("The structure of the memory descriptor is presented below: \n");
    DbgPrint ("(4) NoOfRuns                                               \n");
    DbgPrint ("(4) NoOfPages                                              \n");
    DbgPrint ("(4) Run[0]: BasePage                                       \n");
    DbgPrint ("(4) Run[0]: PageCount                                      \n");
    DbgPrint ("(4) Run[1]: ...                                            \n");
    DbgPrint ("(4) ...                                                    \n");
    DbgPrint ("                                                           \n");
    DbgPrint ("When you decide on values you should edit the following:   \n");
    DbgPrint ("buggy!StopToEdit       <- 0                                \n");
    DbgPrint ("buggy!TestBasePage     <- decided value                    \n");
    DbgPrint ("buggy!TestPageCount    <- decided value                    \n");
    DbgPrint ("                                                           \n");

    DbgBreakPoint ();
}


VOID
StressAddPhysicalMemory (
    PVOID NotUsed
    )
/*++

Routine Description:

    This function regresses the MmAddPhysicalMemory kernel API.
    It does not really stress it but rather iterate through some
    possible combinations.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    NTSTATUS Status;
    ULONG i;
    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;

    DbgPrint ("Buggy: add physical memory stress ioctl \n");

    //
    // (SilviuC): We need an automatic way to figure out memory runs.
    //

    if (StopToEdit) {
        EditPhysicalMemoryParameters ();
    }

    StartAddress.QuadPart =  (LONGLONG)TestBasePage * PAGE_SIZE;
    NumberOfBytes.QuadPart = (LONGLONG)TestPageCount * PAGE_SIZE;

    i = 0;
    do {

        i += 1;
        DbgPrint ("buggy: MmAddPhysicalMemory0 %x %x %x %x\n",
            StartAddress.HighPart,
            StartAddress.LowPart,
            NumberOfBytes.HighPart,
            NumberOfBytes.LowPart);

        Status = MmAddPhysicalMemory (
            &StartAddress,
            &NumberOfBytes);

        DbgPrint ("buggy: MmAddPhysicalMemory %x %x %x %x %x\n",
            Status,
            StartAddress.HighPart,
            StartAddress.LowPart,
            NumberOfBytes.HighPart,
            NumberOfBytes.LowPart);

        if ((i % 8) == 0) {
            KeDelayExecutionThread (KernelMode, FALSE, &BuggyTenSeconds);
        }

        StartAddress.QuadPart -= NumberOfBytes.QuadPart;
    } while (StartAddress.QuadPart > 0);
    
    DbgPrint ("Buggy: MmAddPhysicalMemory test finished\n");
}



VOID
StressDeletePhysicalMemory (
    PVOID NotUsed
    )
/*++

Routine Description:

    This function regresses the MmRemovePhysicalMemory kernel API.
    It does not really stress the function but rather iterate
    throughout the physical memory and attempt to remove chunks of it.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    NTSTATUS Status;
    ULONG i;
    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;

    //
    // SilviuC: we need an automatic way to figure out memory runs.
    //

    if (StopToEdit) {
        EditPhysicalMemoryParameters ();
    }

    StartAddress.QuadPart =  (LONGLONG)TestBasePage * PAGE_SIZE;
    NumberOfBytes.QuadPart = (LONGLONG)TestPageCount * PAGE_SIZE;


    for (i = 0; i < (0xf0000000 / NumberOfBytes.LowPart); i += 1) {

        DbgPrint ("buggy: MmRemovePhysicalMemory0 %x %x %x %x\n",
            StartAddress.HighPart,
            StartAddress.LowPart,
            NumberOfBytes.HighPart,
            NumberOfBytes.LowPart);

        Status = MmRemovePhysicalMemory (
            &StartAddress,
            &NumberOfBytes);

        DbgPrint ("buggy: MmRemovePhysicalMemory %x %x %x %x %x\n",
            Status,
            StartAddress.HighPart,
            StartAddress.LowPart,
            NumberOfBytes.HighPart,
            NumberOfBytes.LowPart);

        StartAddress.QuadPart += NumberOfBytes.QuadPart;

        if ((i % 8) == 0) {
            KeDelayExecutionThread (KernelMode, FALSE, &BuggyTenSeconds);
        }
    }
    
    DbgPrint ("Buggy: MmRemovePhysicalMemory test finished\n");
}


//
// Global:
//
//     BigData
//
// Description:
//
//     Dummy pageable array needed to test lock/unlock scenarios.
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma data_seg("BDAT")
ULONG BigData [0x10000];
#pragma data_seg()
#endif // #ifdef ALLOC_PRAGMA

VOID
StressLockScenario (
    PVOID NotUsed
    )
/*++

Routine Description:

Arguments:

Return Value:

Environment:

--*/
{
    ULONG I;
    PVOID Handle;

#if 0
    for (I = 0; I < 16; I++) {

        Handle = MmLockPagableDataSection (BigData);
        DbgPrint ("Buggy: lock handle %p \n", Handle);
        MmUnlockPagableImageSection (Handle);
    }
#else
    for (I = 0; I < 16; I++) {

        MmPageEntireDriver (DriverEntry);
        MmResetDriverPaging (BigData);
    }
#endif
}



VOID
StressPhysicalMemorySimple (
    PVOID NotUsed
    )
/*++

Routine Description:

    This routine exercises add/remove physical memory functions
    using a simple remove scenario.
    
    Note. This function contributed by LandyW.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
#if 0
    ULONG i;
    PPHYSICAL_MEMORY_RANGE Ranges;
    PPHYSICAL_MEMORY_RANGE p;

    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;

    PHYSICAL_ADDRESS InputAddress;
    LARGE_INTEGER InputBytes;

    Ranges = MmGetPhysicalMemoryRanges ();

    if (Ranges == NULL) {
        DbgPrint ("Buggy: MmRemovePhysicalMemory cannot get ranges\n");
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return;
    }

    p = Ranges;
    while (p->BaseAddress.QuadPart != 0 && p->NumberOfBytes.QuadPart != 0) {

        StartAddress.QuadPart = p->BaseAddress.QuadPart;
        NumberOfBytes.QuadPart = p->NumberOfBytes.QuadPart;

        InputAddress.QuadPart = StartAddress.QuadPart;
        InputBytes.QuadPart = NumberOfBytes.QuadPart;

        if (InputBytes.QuadPart > (128 * 1024 * 1024)) {
            InputBytes.QuadPart = (128 * 1024 * 1024);
        }

        while (InputAddress.QuadPart + InputBytes.QuadPart <=
            StartAddress.QuadPart + NumberOfBytes.QuadPart) {

            DbgPrint ("buggy: MmRemovePhysicalMemory0 %x %x %x %x\n",
                InputAddress.HighPart,
                InputAddress.LowPart,
                InputBytes.HighPart,
                InputBytes.LowPart);

            Status = MmRemovePhysicalMemory (&InputAddress,
                &InputBytes);

            DbgPrint ("buggy: MmRemovePhysicalMemory %x %x %x %x %x\n\n",
                Status,
                InputAddress.HighPart,
                InputAddress.LowPart,
                InputBytes.HighPart,
                InputBytes.LowPart);

            KeDelayExecutionThread (KernelMode, FALSE, &BuggyOneSecond);

            if (NT_SUCCESS(Status)) {

                DbgPrint ("buggy: MmAddPhysicalMemory0 %x %x %x %x\n",
                    InputAddress.HighPart,
                    InputAddress.LowPart,
                    InputBytes.HighPart,
                    InputBytes.LowPart);

                Status = MmAddPhysicalMemory (
                    &InputAddress,
                    &InputBytes);

                if (NT_SUCCESS(Status)) {
                    DbgPrint ("\n\n***************\nbuggy: MmAddPhysicalMemory WORKED %x %x %x %x %x\n****************\n",
                        Status,
                        InputAddress.HighPart,
                        InputAddress.LowPart,
                        InputBytes.HighPart,
                        InputBytes.LowPart);
                }
                else {
                    DbgPrint ("buggy: MmAddPhysicalMemory FAILED %x %x %x %x %x\n\n",
                        Status,
                        InputAddress.HighPart,
                        InputAddress.LowPart,
                        InputBytes.HighPart,
                        InputBytes.LowPart);
                    DbgBreakPoint ();
                }
            }

            if (InputAddress.QuadPart + InputBytes.QuadPart ==
                StartAddress.QuadPart + NumberOfBytes.QuadPart) {

                break;
            }

            InputAddress.QuadPart += InputBytes.QuadPart;

            if (InputAddress.QuadPart + InputBytes.QuadPart >
                StartAddress.QuadPart + NumberOfBytes.QuadPart) {

                InputBytes.QuadPart = StartAddress.QuadPart + NumberOfBytes.QuadPart - InputAddress.QuadPart;
            }
        }

        p += 1;
    }

    ExFreePool (Ranges);
    DbgPrint ("Buggy: Add/remove physical memory simple stress finished\n");
#endif // #if 0
}


#endif // #if !PHYSMEM_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\newstuff.h ===
#ifndef _NEWSTUFF_H_INCLUDED_
#define _NEWSTUFF_H_INCLUDED_

VOID NewStuff (
    PVOID NotUsed
    );

#endif // #ifndef _NEWSTUFF_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\newstuff.c ===
#include <ntddk.h>

#include "active.h"
#include "newstuff.h"

#if !NEWSTUFF_ACTIVE

//
// Dummy implementation if the module is inactive
//

VOID NewStuff (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: newstuff module is disabled \n");
}

#else

//
// Real implementation if the module is active
//

VOID NewStuff (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: newstuff module is enabled \n");
}

#endif // #if !NEWSTUFF_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\resrvmap.h ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  SectMap.h
// Author:  Daniel Mihai (DMihai)
// Created: 6/19/1999 2:39pm
//
// This module contains tests for MmMapViewOfSection & MmMapViewInSystemSpace.
//
// --- History ---
//
// 6/19/1999 (DMihai): initial version.
//

#ifndef __BUGGY_RESRVMAP_H__
#define __BUGGY_RESRVMAP_H__

VOID
TdReservedMappingCleanup( 
	VOID 
	);

VOID
TdReservedMappingSetSize(
    IN PVOID Irp
    );

VOID
TdReservedMappingDoRead(
    IN PVOID Irp
    );

#endif //#ifndef __BUGGY_RESRVMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\resrvmap.c ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 2000.
//
// Module:  ResrvMap.c
// Author:  Daniel Mihai (DMihai)
// Created: 10/18/2000 
//
// This module contains tests for Mm APIs for reserved mapping addresses
//
//	MmAllocateMappingAddress
//	MmFreeMappingAddress
//	MmMapLockedPagesWithReservedMapping
//	MmUnmapReservedMapping
//
// --- History ---
//
// 10/18/2000 (DMihai): initial version.
//

#include <ntddk.h>
#include <wchar.h>

#include "active.h"
#include "tdriver.h"
#include "ResrvMap.h"

#if !RESRVMAP_ACTIVE

//
// Dummy stubs in case this module is disabled
//

VOID
TdReservedMappingSetSize(
    IN PVOID Irp
    )
{
    DbgPrint( "Buggy: ReservedMapping module is disabled (check \\driver\\active.h header)\n");
}

#else	//#if !RESRVMAP_ACTIVE

//
// This is the real stuff
//

//////////////////////////////////////////////////////////
//
// Global data
//

//
// Size of the current reserved mapping address
//

SIZE_T CrtReservedSize;

//
// Current reserved mapping address
//

PVOID CrtReservedAddress;

/////////////////////////////////////////////////////////////////////
//
// Clean-up a possible currently reserved buffer
// Called for IRP_MJ_CLEANUP
//

VOID
TdReservedMappingCleanup( 
	VOID 
	)
{
	if( NULL != CrtReservedAddress )
	{
		DbgPrint( "Buggy: TdReservedMappingCleanup: free reserved mapping address %p\n",
			CrtReservedAddress );

		MmFreeMappingAddress(
			CrtReservedAddress,
			TD_POOL_TAG );
	}
	else
	{
		ASSERT( 0 == CrtReservedSize );
	}
}

/////////////////////////////////////////////////////////////////////
//
// Set the current reserved size and address as asked by the user
//

VOID
TdReservedMappingSetSize(
    IN PVOID Irp
    )
{
    PIO_STACK_LOCATION IrpStack;
	ULONG InputBufferLength;
	SIZE_T NewReservedSize;
	PVOID NewReservedAddress;

    IrpStack = IoGetCurrentIrpStackLocation ( (PIRP)Irp);
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

	if( InputBufferLength != sizeof( SIZE_T ) )
	{
		//
		// The user should send us the new size of the buffer
		//

		DbgPrint( "Buggy: TdReservedMappingSetSize: invalid buffer length %p\n",
			InputBufferLength );

		DbgBreakPoint();

		return;
	}

	//
	// This will be our new reserved mapping address size 
	//

	NewReservedSize = *(PSIZE_T) ( (PIRP) Irp )->AssociatedIrp.SystemBuffer;

	if( NewReservedSize < PAGE_SIZE )
	{
		NewReservedSize = PAGE_SIZE;
	}
	else
	{
		NewReservedSize = ROUND_TO_PAGES( NewReservedSize );
	}

	//DbgPrint( "Buggy: TdReservedMappingSetSize: new reserved mapping address size %p\n",
	// NewReservedSize );

	if( 0 != NewReservedSize )
	{
		//
		// Try to reserve NewReservedSize bytes
		//

		NewReservedAddress = MmAllocateMappingAddress(
			NewReservedSize,
			TD_POOL_TAG );

		if( NULL == NewReservedAddress )
		{
			DbgPrint(
				"Buggy: TdReservedMappingSetSize: MmAllocateMappingAddress returned NULL, keeping old reserved address %p, size = %p\n",
				CrtReservedAddress,
				CrtReservedSize );

			return;
		}
	}
	else
	{
		//
		// Just release the old reserved address and set the size to 0
		//

		NewReservedAddress = NULL;
	}

	//
	// We have a new buffer, release the old one
	//

	TdReservedMappingCleanup();

	CrtReservedSize = NewReservedSize;
	CrtReservedAddress = NewReservedAddress;

	/*
	DbgPrint(
		"Buggy: TdReservedMappingSetSize: new reserved address %p, size = %p\n",
		CrtReservedAddress,
		CrtReservedSize );
	*/
}

////////////////////////////////////////////////////////////////////////
//
// Simulate a "read" operation in a user-supplied buffer
//

VOID
TdReservedMappingDoRead(
    IN PVOID Irp
    )
{
	PVOID UserBuffer;
	PVOID MappedAddress;
	PSIZE_T CrtPageAdddress;
	SIZE_T UserBufferSize;
	SIZE_T CrtPageIndex;
	SIZE_T CrtCycleSize;
	SIZE_T CrtCyclePages;
	PMDL Mdl;
    PIO_STACK_LOCATION IrpStack;
	ULONG InputBufferLength;
	PUSER_READ_BUFFER UserReadBufferStruct;
	BOOLEAN Locked;

	//
	// If we don't have a reserved address for mapping currently we cannot 
	// execute the operation
	//

	if( NULL == CrtReservedAddress )
	{
		ASSERT( 0 == CrtReservedSize );

		DbgPrint( "Buggy: TdReservedMappingDoRead: no buffer available - rejecting request\n" );

		return;
	}

	//
	// Make a copy of the user-supplied buffer address and size
	//

    IrpStack = IoGetCurrentIrpStackLocation ( (PIRP)Irp);
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

	if( InputBufferLength != sizeof( USER_READ_BUFFER ) )
	{
		//
		// The user should have sent us a USER_READ_BUFFER
		//

		DbgPrint( "Buggy: TdReservedMappingDoRead: invalid user buffer length %p, expected %p\n",
			InputBufferLength,
			(SIZE_T)sizeof( USER_READ_BUFFER ) );

		DbgBreakPoint();

		return;
	}

	UserReadBufferStruct = (PUSER_READ_BUFFER) ( (PIRP) Irp )->AssociatedIrp.SystemBuffer ;

	UserBuffer = UserReadBufferStruct->UserBuffer;
	UserBufferSize = UserReadBufferStruct->UserBufferSize;


	//
	// Map CrtReservedSize bytes at most
	//

	CrtPageIndex = 1;

	while( UserBufferSize >= PAGE_SIZE )
	{
		//DbgPrint( "Buggy: TdReservedMappingDoRead: %p bytes left to be read at adddress %p\n",
		//	UserBufferSize,
		//	UserBuffer );

		if( UserBufferSize > CrtReservedSize )
		{
			CrtCycleSize = CrtReservedSize;
		}
		else
		{
			CrtCycleSize = UserBufferSize;
		}

		//DbgPrint( "Buggy: TdReservedMappingDoRead: reading %p bytes this cycle\n",
		//	CrtCycleSize );

		//
		// Allocate an MDL
		//

		Mdl = IoAllocateMdl(
			UserBuffer,
			(ULONG)CrtCycleSize,
			FALSE,             // not secondary buffer
			FALSE,             // do not charge quota          
			NULL);             // no irp

		if( NULL != Mdl )
		{
			//
			// Try to lock the pages 
			//

			Locked = FALSE;

			try 
			{
				MmProbeAndLockPages(
					Mdl,
					KernelMode,
					IoWriteAccess);

				//DbgPrint( 
				//	"Buggy: locked pages in MDL %p\n", 
				//	Mdl);

				Locked = TRUE;
			}
			except (EXCEPTION_EXECUTE_HANDLER) 
			{
				DbgPrint( 
					"Buggy: MmProbeAndLockPages( %p ) raised exception %X\n", 
					Mdl,
					GetExceptionCode() );

				DbgBreakPoint();
			}

			if( TRUE == Locked )
			{
				//
				// Map them to our reserved address
				//

				MappedAddress = MmMapLockedPagesWithReservedMapping(
					CrtReservedAddress,
					TD_POOL_TAG,
					Mdl,
					MmCached );

				if( NULL == MappedAddress )
				{
					DbgPrint( 
						"Buggy: MmProbeAndLockPages( %p, MDL %p ) returned NULL. This API is almost guaranteed to succeed\n",
						CrtReservedAddress,
						Mdl );

					DbgBreakPoint();
				}
				else
				{
					//
					// Mapped successfully - execute the "read"
					//

					CrtCyclePages = CrtCycleSize / PAGE_SIZE;
					CrtPageAdddress = (PSIZE_T)MappedAddress;

					//
					// Stamp all the pages with their index, starting from 1
					//

					while( CrtCyclePages > 0 )
					{
						*CrtPageAdddress = CrtPageIndex;

						CrtPageIndex += 1;
						CrtCyclePages -= 1;
						CrtPageAdddress = (PSIZE_T)( (PCHAR)CrtPageAdddress + PAGE_SIZE );
					}

					//
					// Unmap
					//
					
					MmUnmapReservedMapping(
						MappedAddress,
						TD_POOL_TAG,
						Mdl );
				}

				//
				// Unlock
				//

                MmUnlockPages (Mdl);
			}

			//
			// Free MDL
			//

			IoFreeMdl (Mdl);
		}
		else
		{
			//
			// Bad luck - couldn't allocate the MDL
			//

			DbgPrint( "Buggy: TdReservedMappingDoRead: IoAllocateMdl( %p, %p ) returned NULL\n",
				UserBuffer,
				UserBufferSize );
		}
	
		//
		// How many bytes left to be read and to what address?
		//

		UserBufferSize -= CrtCycleSize;
		UserBuffer = (PVOID)( (PCHAR)UserBuffer + CrtCycleSize );
	}
}


#endif	//#if !RESRVMAP_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\sectmap.c ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  SectMap.c
// Author:  Daniel Mihai (DMihai)
// Created: 6/19/1999 2:39pm
//
// This module contains tests for MmMapViewOfSection & MmMapViewInSystemSpace.
//
// --- History ---
//
// 6/19/1999 (DMihai): initial version.
//

#include <ntddk.h>
#include <wchar.h>

#include "active.h"
#include "ContMem.h"


#if !SECTMAP_ACTIVE

void
TdSectionMapTestProcessSpace(
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: sectmap test is disabled \n");
}

void
TdSectionMapTestSystemSpace(
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: sectmap test is disabled \n");
}

#else


NTKERNELAPI
NTSTATUS
MmCreateSection (
    OUT PVOID *SectionObject,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL,
    IN PFILE_OBJECT File OPTIONAL
    );

NTKERNELAPI
NTSTATUS
MmMapViewOfSection(
    IN PVOID SectionToMap,
    IN PEPROCESS Process,
    IN OUT PVOID *CapturedBase,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset,
    IN OUT PSIZE_T CapturedViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewOfSection(
    IN PEPROCESS Process,
    IN PVOID BaseAddress
     );

/////////////////////////////////////////////////////////////////////////
//
// macros
//

#define SECTMAP_TEST_FILE_SIZE  (4 * 1024 * 1024)

#ifndef SEC_COMMIT
#define SEC_COMMIT        0x8000000    
#endif

/////////////////////////////////////////////////////////////////////////
//
// test variations
//

void
TdSectionMapTestProcessSpace(
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    ULONG uCrtThreadId;
    ULONG uPagesNo;
    PULONG puCrtUlong;
    PEPROCESS pEProcess;
    PVOID pSectionObject;
    PVOID pViewBase;
    PVOID pAfterLastValidPage;
    HANDLE hFile;
    SIZE_T sizeView;
    LARGE_INTEGER liMaxSize;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER liSectionOffset;
    UNICODE_STRING ustrFileName;
    OBJECT_ATTRIBUTES ObjAttrib;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR strFileName[ 64 ] = L"\\DosDevices\\c:\\maptest";
    WCHAR strThreadId[ 16 ];

    uCrtThreadId = PtrToUlong( PsGetCurrentThreadId() );

    //
    // generate the file name
    //

    swprintf( strThreadId, L"%u", uCrtThreadId );
    wcscat( strFileName, strThreadId );

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, using file %ws\n",
        uCrtThreadId,
        strFileName );
    */
    
    //
    // make it a UNICODE_STRING
    //

    RtlInitUnicodeString(
        &ustrFileName,
        strFileName
        );

    InitializeObjectAttributes(
        &ObjAttrib,
        &ustrFileName,
        OBJ_CASE_INSENSITIVE,
        0,
        0
        );

    //
    // open the file
    //

    liMaxSize.QuadPart = SECTMAP_TEST_FILE_SIZE;

    Status = ZwCreateFile(
            &hFile,
            GENERIC_READ | GENERIC_WRITE,
            &ObjAttrib,
            &IoStatusBlock,
            &liMaxSize,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN_IF,
            FILE_WRITE_THROUGH |
                FILE_NO_INTERMEDIATE_BUFFERING |
                FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
            );

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, ZwCreateFile failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, file opened\n",
        uCrtThreadId );
    */

    ASSERT( IoStatusBlock.Information == FILE_CREATED || IoStatusBlock.Information == FILE_OPENED );
    ASSERT( hFile != (HANDLE)-1 );
    ASSERT( liMaxSize.QuadPart == SECTMAP_TEST_FILE_SIZE );

    //
    // create the section
    //

    Status = MmCreateSection(
        &pSectionObject,
        STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
        0,
        &liMaxSize,
        PAGE_READWRITE,
        SEC_COMMIT,
        hFile,
        NULL
        );

    ZwClose(hFile);

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, MmCreateSection failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, section %p created\n",
        uCrtThreadId,
        pSectionObject );
    */

    //
    // map the section
    //

    sizeView = (SIZE_T)liMaxSize.LowPart;
    liSectionOffset.QuadPart = 0;

    pEProcess = PsGetCurrentProcess();

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, mapping section %p in process %p\n",
        uCrtThreadId,
        pSectionObject,
        pEProcess );
    */

    pViewBase = NULL;

    Status = MmMapViewOfSection(
        pSectionObject,
        pEProcess,
        &pViewBase,
        0,
        0,
        &liSectionOffset,
        &sizeView,
        ViewUnmap,
        0,              // allocation type 
        PAGE_READWRITE
        );

    if( ! NT_SUCCESS( Status ) )
    {
        //
        // dereference the section object 
        //

        ObDereferenceObject( pSectionObject );

        DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, MmMapViewOfSection failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, section mapped, pViewBase = %p\n",
        uCrtThreadId,
        pViewBase );
    */

    // DbgBreakPoint();

    ASSERT( liSectionOffset.QuadPart == 0 );
    ASSERT( sizeView == SECTMAP_TEST_FILE_SIZE );
    ASSERT( pViewBase != NULL );

    //
    // touch some of the pages
    //

    uPagesNo = (ULONG)sizeView / PAGE_SIZE;
    pAfterLastValidPage = (PVOID)( (ULONG_PTR)pViewBase + uPagesNo * PAGE_SIZE );

    KeQuerySystemTime (&CurrentTime);
    puCrtUlong = (PULONG)( (ULONG_PTR)pViewBase + (CurrentTime.LowPart % 5) * PAGE_SIZE );

    while( (ULONG_PTR)puCrtUlong < (ULONG_PTR)pAfterLastValidPage )
    {
        /*
        DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, touching page %p\n",
            uCrtThreadId,
            puCrtUlong );
        */

        *puCrtUlong = CurrentTime.LowPart;

        KeQuerySystemTime (&CurrentTime);
        puCrtUlong = (PULONG)( (ULONG_PTR)puCrtUlong + (CurrentTime.LowPart % 5 + 1) * PAGE_SIZE );
    }
    
    //
    // clean-up
    //

    //
    // un-map the section
    //

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, MmUnmapViewOfSection process %p, pViewBase = %p\n",
        uCrtThreadId,
        pEProcess,
        pViewBase );
    */

    Status = MmUnmapViewOfSection(
        pEProcess,
        pViewBase );

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, MmUnmapViewOfSection failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();
    }

    //
    // dereference the section object 
    //
    
    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, dereference section at %p\n",
        uCrtThreadId,
        pSectionObject );
    */

    ObDereferenceObject( pSectionObject );
}

/////////////////////////////////////////////////////////////////////////

void
TdSectionMapTestSystemSpace(
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    ULONG uCrtThreadId;
    ULONG uPagesNo;
    PULONG puCrtUlong;
    PVOID pSectionObject;
    PVOID pViewBase;
    PVOID pAfterLastValidPage;
    HANDLE hFile;
    SIZE_T sizeView;
    LARGE_INTEGER liMaxSize;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER liSectionOffset;
    UNICODE_STRING ustrFileName;
    OBJECT_ATTRIBUTES ObjAttrib;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR strFileName[ 64 ] = L"\\DosDevices\\c:\\maptest";
    WCHAR strThreadId[ 16 ];

    uCrtThreadId = PtrToUlong( PsGetCurrentThreadId() );

    //
    // generate the file name
    //

    swprintf( strThreadId, L"%u", uCrtThreadId );
    wcscat( strFileName, strThreadId );

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, using file %ws\n",
        uCrtThreadId,
        strFileName );
    */
    
    //
    // make it a UNICODE_STRING
    //

    RtlInitUnicodeString(
        &ustrFileName,
        strFileName
        );

    InitializeObjectAttributes(
        &ObjAttrib,
        &ustrFileName,
        OBJ_CASE_INSENSITIVE,
        0,
        0
        );

    //
    // open the file
    //

    liMaxSize.QuadPart = SECTMAP_TEST_FILE_SIZE;

    Status = ZwCreateFile(
            &hFile,
            GENERIC_READ | GENERIC_WRITE,
            &ObjAttrib,
            &IoStatusBlock,
            &liMaxSize,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN_IF,
            FILE_WRITE_THROUGH |
                FILE_NO_INTERMEDIATE_BUFFERING |
                FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
            );

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, ZwCreateFile failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, file opened\n",
        uCrtThreadId );
    */

    ASSERT( IoStatusBlock.Information == FILE_CREATED || IoStatusBlock.Information == FILE_OPENED );
    ASSERT( hFile != (HANDLE)-1 );
    ASSERT( liMaxSize.QuadPart == SECTMAP_TEST_FILE_SIZE );

    //
    // create the section
    //

    Status = MmCreateSection(
        &pSectionObject,
        STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
        0,
        &liMaxSize,
        PAGE_READWRITE,
        SEC_COMMIT,
        hFile,
        NULL
        );

    ZwClose(hFile);

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, MmCreateSection failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, section %p created\n",
        uCrtThreadId,
        pSectionObject );
    */

    //
    // map the section
    //

    sizeView = (SIZE_T)liMaxSize.LowPart;
    liSectionOffset.QuadPart = 0;

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, mapping section %p system space\n",
        uCrtThreadId,
        pSectionObject );
    */

    pViewBase = NULL;

    Status = MmMapViewInSystemSpace(
        pSectionObject,
        &pViewBase,
        &sizeView
        );

    if( ! NT_SUCCESS( Status ) )
    {
        //
        // dereference the section object 
        //

        ObDereferenceObject( pSectionObject );

        DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, MmMapViewInSystemSpace failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, section mapped, pViewBase = %p\n",
        uCrtThreadId,
        pViewBase );
    */

    // DbgBreakPoint();

    ASSERT( liSectionOffset.QuadPart == 0 );
    ASSERT( sizeView == SECTMAP_TEST_FILE_SIZE );
    ASSERT( pViewBase != NULL );

    //
    // touch some of the pages
    //

    uPagesNo = (ULONG)sizeView / PAGE_SIZE;
    pAfterLastValidPage = (PVOID)( (ULONG_PTR)pViewBase + uPagesNo * PAGE_SIZE );

    KeQuerySystemTime (&CurrentTime);
    puCrtUlong = (PULONG)( (ULONG_PTR)pViewBase + (CurrentTime.LowPart % 5) * PAGE_SIZE );

    while( (ULONG_PTR)puCrtUlong < (ULONG_PTR)pAfterLastValidPage )
    {
        /*
        DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, touching page %p\n",
            uCrtThreadId,
            puCrtUlong );
        */ 

        *puCrtUlong = CurrentTime.LowPart;

        KeQuerySystemTime (&CurrentTime);
        puCrtUlong = (PULONG)( (ULONG_PTR)puCrtUlong + (CurrentTime.LowPart % 5 + 1) * PAGE_SIZE );
    }
    
    //
    // clean-up
    //

    //
    // un-map the section
    //

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, MmUnmapViewInSystemSpace pViewBase = %p\n",
        uCrtThreadId,
        pViewBase );
    */

    Status = MmUnmapViewInSystemSpace(
        pViewBase );

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, MmUnmapViewInSystemSpace failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();
    }

    //
    // dereference the section object 
    //

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, dereference section at %p\n",
        uCrtThreadId,
        pSectionObject );
    */

    ObDereferenceObject( pSectionObject );
}

#endif // #if !SECTMAP_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\tracedb.h ===
#ifndef _TRACEDB_H_INCLUDED_
#define _TRACEDB_H_INCLUDED_

VOID TestTraceDatabase (
    PVOID
    );

#endif // #ifndef _TRACEDB_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\sectmap.h ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  SectMap.h
// Author:  Daniel Mihai (DMihai)
// Created: 6/19/1999 2:39pm
//
// This module contains tests for MmMapViewOfSection & MmMapViewInSystemSpace.
//
// --- History ---
//
// 6/19/1999 (DMihai): initial version.
//

void
TdSectionMapTestProcessSpace(
    PVOID
    );

void
TdSectionMapTestSystemSpace(
    PVOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\tdriver.c ===
//
// Buggy - Template Test Driver
// Copyright (c) Microsoft Corporation, 1999, 2000.
//
// Module:  tdriver.c
// Author:  Silviu Calinoiu (SilviuC)
// Created: 4/20/1999 2:39pm
//
// This module contains a template driver.
//
// --- History ---
//
// 4/20/1999 (SilviuC): initial version.
//
// 1/19/2000 (SilviuC): make it really extensible.
//

//
// PLEASE READ IF YOU MODIFY THIS FILE !
//
// The only modification needed in this module is an include
// statement for the header of the module implementing the new
// test in the section `Test specific headers'. That's all.
//

#include <ntddk.h>

//
// Test specific headers.
//

#include "active.h"

#include "bugcheck.h"
#include "ContMem.h"
#include "SectMap.h"
#include "tracedb.h"
#include "physmem.h"
#include "mmtests.h"
#include "MapView.h"
#include "locktest.h"
#include "ResrvMap.h"

#include "newstuff.h"

//
// Standard tdriver headers.
//

#define FUNS_DEFINITION_MODULE
#include "tdriver.h"
#include "funs.h"

//
// Driver implementation
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
    NTSTATUS Status;
    UNICODE_STRING NtName;
    UNICODE_STRING Win32Name;
    ULONG Index;    
    PDEVICE_OBJECT Device;

    DbgPrint ("Buggy: DriverEntry() \n");

    //
    // Create Unicode NT name for the device.

    RtlInitUnicodeString (

        &NtName, 
        TD_NT_DEVICE_NAME);

    //
    // Create NT device
    //

    Status = IoCreateDevice (

        DriverObject,             // pointer to driver object
        sizeof (TD_DRIVER_INFO),  // device extension
        &NtName,                  // device name
        FILE_DEVICE_UNKNOWN,      // device type
        0,                        // device characteristics
        FALSE,                    // not exclusive
        &Device);                 // returned device object pointer

    if (! NT_SUCCESS(Status)) {

        return Status;
    }

    //
    // Create dispatch points
    //

    for (Index = 0; Index < IRP_MJ_MAXIMUM_FUNCTION; Index++) {
        DriverObject->MajorFunction[Index] = TdInvalidDeviceRequest;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = TdDeviceCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = TdDeviceClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = TdDeviceCleanup;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = TdDeviceControl;
    DriverObject->DriverUnload                         = TdDeviceUnload;

    //
    // Create counted string version of our Win32 device name.
    //

    RtlInitUnicodeString (

        &Win32Name, 
        TD_DOS_DEVICE_NAME);

    //
    // Create a link from our device name to a name in the Win32 namespace.
    //

    Status = IoCreateSymbolicLink (

        &Win32Name, 
        &NtName);

    if (! NT_SUCCESS(Status)) {

        IoDeleteDevice (DriverObject->DeviceObject);
        return Status;
    }

    return Status;
}


NTSTATUS
TdDeviceCreate (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
//
// Handles create IRP.
//

{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


NTSTATUS
TdDeviceClose (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
//
// Handles close IRP.
//
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


NTSTATUS
TdDeviceCleanup (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
//
// Handles cleanup IRP.
//
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


NTSTATUS
TdDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
//
// Handles control IRP.
//
{
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG Ioctl;
    NTSTATUS Status;
    ULONG BufferSize;
    ULONG ReturnedSize;
    KIRQL irql;
    ULONG Index;
    LOGICAL IoctlFound = FALSE;

    Status = STATUS_SUCCESS;

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    Ioctl = IrpStack->Parameters.DeviceIoControl.IoControlCode;

    if( Ioctl == IOCTL_TD_BUGCHECK )
    {
        if( InputBufferLength == sizeof( BUGCHECK_PARAMS ) )
        {
            PBUGCHECK_PARAMS pBugcheckParams = (PBUGCHECK_PARAMS)(Irp->AssociatedIrp.SystemBuffer);

            DbgPrint( "Buggy: calling KeBugCheckEx( %X, %p, %p, %p, %p )\n",
                pBugcheckParams->BugCheckCode,
                pBugcheckParams->BugCheckParameters[ 0 ],
                pBugcheckParams->BugCheckParameters[ 1 ],
                pBugcheckParams->BugCheckParameters[ 2 ],
                pBugcheckParams->BugCheckParameters[ 3 ] );

            KeBugCheckEx(
                pBugcheckParams->BugCheckCode,
                pBugcheckParams->BugCheckParameters[ 0 ],
                pBugcheckParams->BugCheckParameters[ 1 ],
                pBugcheckParams->BugCheckParameters[ 2 ],
                pBugcheckParams->BugCheckParameters[ 3 ] );
        }
        else
        {
            DbgPrint( "Buggy: cannot read bugcheck data, expected data length %u, IrpStack->Parameters.DeviceIoControl.InputBufferLength = %u\n",
                sizeof( BUGCHECK_PARAMS ),
                InputBufferLength );
        }

        goto Done;

    }

    //
    // (SilviuC): maybe we should do parameter checking on the info buffer.
    // Not really important since this is not a production driver.
    //

    for (Index = 0; BuggyFuns[Index].Ioctl != 0; Index++) {
        if (Ioctl == BuggyFuns[Index].Ioctl) {
            DbgPrint ("Buggy: %s ioctl \n", BuggyFuns[Index].Message);
            (BuggyFuns[Index].Function)((PVOID)Irp);
            DbgPrint ("Buggy: done with %s. \n", BuggyFuns[Index].Message);
            IoctlFound = TRUE;
            break;
        }
    }

    //
    // Complain if Ioctl code not found.
    //

    if (! IoctlFound) {
        DbgPrint ("Buggy: unrecognized ioctl code %u \n", Ioctl);
    }

    //
    // Complete the irp and return.
    //
Done:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return Status;
}


VOID
TdDeviceUnload (
    IN PDRIVER_OBJECT DriverObject
    )
//
// This function handles driver unloading. All this driver needs to do 
// is to delete the device object and the symbolic link between our 
// device name and the Win32 visible name.
//
{
    UNICODE_STRING  Win32Name;

    DbgPrint ("Buggy: unload \n");

#if RESRVMAP_ACTIVE

	//
	// Clean-up a possible currently reserved buffer
	//

	TdReservedMappingCleanup();

#endif //#if RESRVMAP_ACTIVE

    //
    //
    //
    // Create counted string version of our Win32 device name.
    //

    RtlInitUnicodeString (

        &Win32Name, 
        TD_DOS_DEVICE_NAME );

    //
    // Delete the link from our device name to a name in the Win32 namespace.
    //

    IoDeleteSymbolicLink (&Win32Name);

    //
    // Finally delete our device object
    //

    IoDeleteDevice (DriverObject->DeviceObject);

}


NTSTATUS
TdInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is the default dispatch routine for all driver entries
    not implemented by drivers that have been loaded into the system.  Its
    responsibility is simply to set the status in the packet to indicate
    that the operation requested is invalid for this device type, and then
    complete the packet.

Arguments:

    DeviceObject - Specifies the device object for which this request is
        bound.  Ignored by this routine.

    Irp - Specifies the address of the I/O Request Packet (IRP) for this
        request.

Return Value:

    The final status is always STATUS_INVALID_DEVICE_REQUEST.


--*/    
{
    UNREFERENCED_PARAMETER( DeviceObject );

    //
    // Simply store the appropriate status, complete the request, and return
    // the same status stored in the packet.
    //

    if ((IoGetCurrentIrpStackLocation(Irp))->MajorFunction == IRP_MJ_POWER) {
        PoStartNextPowerIrp(Irp);
    }
    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_INVALID_DEVICE_REQUEST;
}

//
// End of module: tdriver.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\tracedb.c ===
#include <nt.h>
#include <ntrtl.h>
// #include <ntddk.h>

#include "active.h"
#include "tracedb.h"

#if !TRACEDB_ACTIVE

//
// Dummy implementation if the module is inactive
//

VOID TestTraceDatabase (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: tracedb module is disabled \n");
}

#else


#define assert_(Expr) {                                                     \
    if (!(Expr)) {                                                          \
        DbgPrint ("Test tracedb assert: (%s, %d): \" %s \" -- assertion failed \n", \
          __FILE__, __LINE__, #Expr);                                       \
        DbgBreakPoint ();                                                   \
        return;                                                             \
    }}

//
// Real implementation if the module is active
//

VOID
TestTraceDatabase (
    PVOID NotUsed
    )
{
    PRTL_TRACE_DATABASE Db;
    ULONG_PTR Trace [16];
    PRTL_TRACE_BLOCK Blk;
    PRTL_TRACE_BLOCK BlkX;
    ULONG Index, I;
    BOOLEAN Result; 
    ULONG Seed = 0xABCDDCBA;

    Db = RtlTraceDatabaseCreate (16, 
                                 0, 
                                 RTL_TRACE_USE_NONPAGED_POOL, 
                                 'bDrT', 
                                 0);

    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Db != NULL);

    for (Index = 0; Index < 16; Index++) {
        Trace[Index] = (ULONG_PTR)RtlRandom(&Seed);
    }

    Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &Blk);
    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Result);
    assert_ (Blk->Size == 16);
    assert_ (Blk->Count == 1);

    Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &BlkX);
    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Result);
    assert_ (Blk->Size == 16);
    assert_ (Blk->Count == 2);
    assert_ (Blk == BlkX);

    //
    // Stress a little bit the whole thing
    //

    Seed = 0xABCDDCBA;

    for (I = 0; I < 10000; I++) {
        
        for (Index = 0; Index < 16; Index++) {
            RtlRandom(&Seed);
            Trace[Index] = (ULONG_PTR)Seed;
        }

        Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &Blk);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);

        Result = RtlTraceDatabaseFind (Db, 16, (PVOID *)Trace, &BlkX);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);
        assert_ (Blk == BlkX);

        if (I % 512 == 0) {
            DbgPrint(".");
        }
    }

    DbgPrint("\n");

    //
    // Stress a little bit the whole thing
    //

    Seed = 0xABCDDCBA;

    for (I = 0; I < 10000; I++) {
        
        for (Index = 0; Index < 16; Index++) {
            RtlRandom(&Seed);
            Trace[Index] = (ULONG_PTR)Seed;
        }

        Result = RtlTraceDatabaseFind (Db, 16, (PVOID *)Trace, &Blk);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);

        Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &BlkX);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 2);
        assert_ (Blk == BlkX);

        if (I % 512 == 0) {
            DbgPrint(".");
        }
    }

    DbgPrint("\n");

    RtlTraceDatabaseDestroy (Db);


    //
    // Use paged pool also.
    //

    Db = RtlTraceDatabaseCreate (16, 
                                 0, 
                                 RTL_TRACE_USE_PAGED_POOL, 
                                 'bDrT', 
                                 0);

    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Db != NULL);

    for (Index = 0; Index < 16; Index++) {
        Trace[Index] = (ULONG_PTR)RtlRandom(&Seed);
    }

    Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &Blk);
    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Result);
    assert_ (Blk->Size == 16);
    assert_ (Blk->Count == 1);

    Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &BlkX);
    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Result);
    assert_ (Blk->Size == 16);
    assert_ (Blk->Count == 2);
    assert_ (Blk == BlkX);

    //
    // Stress a little bit the whole thing
    //

    Seed = 0xABCDDCBA;

    for (I = 0; I < 10000; I++) {
        
        for (Index = 0; Index < 16; Index++) {
            RtlRandom(&Seed);
            Trace[Index] = (ULONG_PTR)Seed;
        }

        Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &Blk);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);

        Result = RtlTraceDatabaseFind (Db, 16, (PVOID *)Trace, &BlkX);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);
        assert_ (Blk == BlkX);

        if (I % 512 == 0) {
            DbgPrint(".");
        }
    }

    DbgPrint("\n");

    //
    // Stress a little bit the whole thing
    //

    Seed = 0xABCDDCBA;

    for (I = 0; I < 10000; I++) {
        
        for (Index = 0; Index < 16; Index++) {
            RtlRandom(&Seed);
            Trace[Index] = (ULONG_PTR)Seed;
        }

        Result = RtlTraceDatabaseFind (Db, 16, (PVOID *)Trace, &Blk);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);

        Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &BlkX);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 2);
        assert_ (Blk == BlkX);

        if (I % 512 == 0) {
            DbgPrint(".");
        }
    }

    DbgPrint("\n");

    RtlTraceDatabaseDestroy (Db);

}

#endif // #if !TRACEDB_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\build.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

--*/

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       build.h
//
//  Contents:   Main Include file for build.exe
//
//  History:    16-May-89     SteveWo  Created
//              26-Jul-94     LyleC    Cleanup/Add Support for Pass0
//
//----------------------------------------------------------------------------

#include <assert.h>
#include <process.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <malloc.h>
#include <errno.h>
#include <ctype.h>
#include <signal.h>
#include <string.h>
#include <time.h>
#include <io.h>
#include <conio.h>
#include <sys\types.h>
#include <sys\stat.h>

#define INC_OLE2

#include <windows.h>

#define UINT DWORD
#define HDIR HANDLE


VOID
ClearLine(VOID);


//
// Types and Constant Definitions
//

#if DBG
#define DEBUG_1 (fDebug & 1)
#else
#define DEBUG_1 FALSE
#endif

BOOL fDebug;
#define DEBUG_2 (fDebug & 3)
#define DEBUG_4 (fDebug & 4)

//
// Target specific dirs file name.
//

extern LPSTR pszTargetDirs;

#define MAX_TARGET_MACHINES 4

typedef struct _TARGET_MACHINE_INFO {
    UCHAR SourceSubDirMask;     // TMIDIR_I386
    LPSTR Description;          // "i386"
    LPSTR Switch;               // "-386"
    LPSTR Switch2;              // "-x86"
    LPSTR MakeVariable;         // "386=1"
    LPSTR SourceVariable;       // "i386_SOURCES"
    LPSTR ObjectVariable;       // "386_OBJECTS"
    LPSTR AssociateDirectory;   // "i386"
    LPSTR SourceDirectory;      // "i386"
    LPSTR TargetDirs;           // "i386dirs"
    LPSTR ObjectDirectory[2];   // "i386" -- initialize only first entry
    ULONG DirIncludeMask;       // Platform/Group/etc.
    LPSTR ObjectMacro;          // don't initialize

} TARGET_MACHINE_INFO, *PTARGET_MACHINE_INFO;

#define DIR_INCLUDE_NONE     0x00000000
#define DIR_INCLUDE_X86      0x00000001
//                           0x00000002
#define DIR_INCLUDE_IA64     0x00000004
//                           0x00000008
#define DIR_INCLUDE_WIN32    0x00000010
#define DIR_INCLUDE_WIN64    0x00000020
#define DIR_INCLUDE_RISC     0x00000040
#define DIR_INCLUDE_AMD64    0x00000080
#define DIR_INCLUDE_ARM      0x00000100
#define DIR_INCLUDE_ALL      0xffffffff

// It's possible to have SOURCES= entries of the following forms:
//      entry           SourceSubDirMask
//      -----           ----------------
//      foo.c                    0
//      i386\foo.c               1
//      amd64\foo.c              2
//      ia64\foo.c               4
//      arm\foo.c                8
//      ..\foo.c                80
//      ..\i386\foo.c           81
//      ..\amd64\foo.c          82
//      ..\ia64\foo.c           84
//      ..\arm\foo.c            88

#define TMIDIR_I386     0x0001
#define TMIDIR_AMD64    0x0002
#define TMIDIR_IA64     0x0004
#define TMIDIR_ARM      0x0008
#define TMIDIR_PARENT   0x0080  // or'd in with above bits


#define SIG_DIRREC      0x44644464      // "DdDd"

#ifdef SIG_DIRREC
#define SIG_FILEREC     0x46664666      // "FfFf"
#define SIG_INCLUDEREC  0x49694969      // "IiIi"
#define SIG_SOURCEREC   0x53735373      // "SsSs"
#define SigCheck(s)     s
#else
#define SigCheck(s)
#endif

#define AssertDir(pdr) \
        SigCheck(assert((pdr) != NULL && (pdr)->Sig == SIG_DIRREC))

#define AssertOptionalDir(pdr) \
        SigCheck(assert((pdr) == NULL || (pdr)->Sig == SIG_DIRREC))

#define AssertFile(pfr) \
        SigCheck(assert((pfr) != NULL && (pfr)->Sig == SIG_FILEREC))

#define AssertOptionalFile(pfr) \
        SigCheck(assert((pfr) == NULL || (pfr)->Sig == SIG_FILEREC))

#define AssertInclude(pir) \
        SigCheck(assert((pir) != NULL && (pir)->Sig == SIG_INCLUDEREC))

#define AssertOptionalInclude(pir) \
        SigCheck(assert((pir) == NULL || (pir)->Sig == SIG_INCLUDEREC))

#define AssertSource(psr) \
        SigCheck(assert((psr) != NULL && (psr)->Sig == SIG_SOURCEREC))

#define AssertOptionalSource(psr) \
        SigCheck(assert((psr) == NULL || (psr)->Sig == SIG_SOURCEREC))

//
// Information about source directories is stored an in-memory database.
// The information is saved on disk by writing the contents of the database
// to "build.dat".  It is reloaded from disk for subsequent invocations,
// and re-written only when it has been updated.
//


typedef struct _INCLUDEREC {
    SigCheck(ULONG Sig;)
    struct _INCLUDEREC *Next;     // static list describes original arcs
    struct _INCLUDEREC *NextTree; // dynamic list -- cycles are collapsed
    struct _FILEREC *pfrCycleRoot;
    struct _FILEREC *pfrInclude;
    USHORT Version;
    USHORT IncFlags;
    char Name[1];
} INCLUDEREC, *PINCLUDEREC;


#define INCLUDEDB_LOCAL         0x0001  // include "foo.h"
#define INCLUDEDB_POST_HDRSTOP  0x0002  // appears after #pragma hdrstop
#define INCLUDEDB_MISSING       0x0400  // include file was once missing
#define INCLUDEDB_GLOBAL        0x0800  // include file is in global directory
#define INCLUDEDB_SNAPPED       0x1000  // include file snapped
#define INCLUDEDB_CYCLEALLOC    0x2000  // allocated to flatten cycle
#define INCLUDEDB_CYCLEROOT     0x4000  // moved to root file to flatten cycle
#define INCLUDEDB_CYCLEORPHAN   0x8000  // orphaned to flatten cycle

// Flags preserved when loading build.dat:

#define INCLUDEDB_DBPRESERVE    (INCLUDEDB_LOCAL | INCLUDEDB_POST_HDRSTOP)



#define IsCleanTree(pir)        \
  ((pir)->NextTree == NULL &&   \
   ((pir)->IncFlags &           \
    (INCLUDEDB_CYCLEALLOC | INCLUDEDB_CYCLEROOT | INCLUDEDB_CYCLEORPHAN)) == 0)


#if DBG
VOID AssertCleanTree(INCLUDEREC *pir, OPTIONAL struct _FILEREC *pfr);
#else
#define AssertCleanTree(pir, pfr)       assert(IsCleanTree(pir))
#endif

//
// Make file description structure definition.
//

typedef struct _FILEDESC {
    LPSTR   pszPattern;         //  pattern to match file name
    LPSTR   pszCommentToEOL;    //  comment-to-eol string
    BOOL    fNeedFileRec;       //  TRUE => file needs a file record
    ULONG   FileFlags;          //  flags to be set in file record
    ULONG   DirFlags;           //  flags to be set in directory record
} FILEDESC;

extern FILEDESC FileDesc[];

typedef struct _FILEREC {
    SigCheck(ULONG Sig;)
    struct _FILEREC *Next;
    struct _DIRREC *Dir;
    INCLUDEREC *IncludeFiles;       // static list describes original arcs
    INCLUDEREC *IncludeFilesTree;   // dynamic list -- cycles are collapsed
    struct _FILEREC *NewestDependency;
    LPSTR  pszCommentToEOL;         // comment-to-eol string in source
    ULONG  DateTime;
    ULONG  DateTimeTree;            // Newest DateTime for included tree
    ULONG  TotalSourceLines;        // line count in all included files
    ULONG  FileFlags;
    ULONG  SourceLines;
    USHORT Attr;
    USHORT SubDirIndex;
    USHORT Version;
    USHORT GlobalSequence;          // Sequence number for dynamic include tree
    USHORT LocalSequence;           // Sequence number for dynamic include tree
    USHORT idScan;                  // id used for detecting multiple inclusion
    USHORT CheckSum;                // Name checksum
    UCHAR fDependActive;            // TRUE-> we're scanning at or below this file.
    char Name[1];
} FILEREC, *PFILEREC;

#define FILEDB_SOURCE           0x00000001
#define FILEDB_DIR              0x00000002
#define FILEDB_HEADER           0x00000004
#define FILEDB_ASM              0x00000008
#define FILEDB_MASM             0x00000010
#define FILEDB_RC               0x00000020
#define FILEDB_C                0x00000040
#define FILEDB_MIDL             0x00000080
#define FILEDB_ASN              0x00000100
#define FILEDB_JAVA             0x00000200
#define FILEDB_MOF              0x00000400
#define FILEDB_CSHARP           0x00000800
#define FILEDB_SCANNED          0x00001000
#define FILEDB_OBJECTS_LIST     0x00002000
#define FILEDB_FILE_MISSING     0x00004000
#define FILEDB_MKTYPLIB         0x00008000
#define FILEDB_MULTIPLEPASS     0x00010000
#define FILEDB_PASS0            0x00020000
#define FILEDB_SOURCEREC_EXISTS 0x00040000
#define FILEDB_VBP              0x00080000
#define FILEDB_VB_NET           0x00100000

// Flags preserved when loading build.dat:

#define FILEDB_DBPRESERVE       (FILEDB_SOURCE |       \
                                 FILEDB_DIR |          \
                                 FILEDB_HEADER |       \
                                 FILEDB_ASM |          \
                                 FILEDB_MASM |         \
                                 FILEDB_RC |           \
                                 FILEDB_C |            \
                                 FILEDB_MIDL |         \
                                 FILEDB_ASN |          \
                                 FILEDB_JAVA |         \
                                 FILEDB_MOF |          \
                                 FILEDB_VBP |          \
                                 FILEDB_VB_NET |       \
                                 FILEDB_CSHARP |       \
                                 FILEDB_MKTYPLIB |     \
                                 FILEDB_MULTIPLEPASS | \
                                 FILEDB_PASS0)


typedef struct _SOURCEREC {
    SigCheck(ULONG Sig;)
    struct _SOURCEREC *psrNext;
    FILEREC *pfrSource;
    UCHAR SourceSubDirMask;
    UCHAR SrcFlags;
} SOURCEREC;

#define SOURCEDB_SOURCES_LIST           0x01
#define SOURCEDB_FILE_MISSING           0x02
#define SOURCEDB_PCH                    0x04
#define SOURCEDB_OUT_OF_DATE            0x08
#define SOURCEDB_COMPILE_NEEDED         0x10


typedef struct _DIRSUP {
    LPSTR TestType;
    LPSTR LocalIncludePath;
    LPSTR UserIncludePath;
    LPSTR LastIncludePath;
    LPSTR NTIncludePath;
    LPSTR PchIncludeDir;
    LPSTR PchInclude;
    LPSTR PchTargetDir;
    LPSTR PchTarget;
    LPSTR PassZeroHdrDir;
    LPSTR PassZeroSrcDir1;
    LPSTR PassZeroSrcDir2;
    LPSTR ConditionalIncludes;
    ULONG DateTimeSources;
    ULONG IdlType;
    ULONG fNoTarget;
    LPSTR SourcesVariables[MAX_TARGET_MACHINES + 2];
    SOURCEREC *psrSourcesList[MAX_TARGET_MACHINES + 2];
} DIRSUP;


typedef struct _DIRREC {
    SigCheck(ULONG Sig;)
    struct _DIRREC *Next;
    LIST_ENTRY Produces;
    LIST_ENTRY Consumes;
    DIRSUP *pds;                 // Used to preserve info from pass zero
    PFILEREC Files;
    LPSTR TargetPath;
    LPSTR TargetPathLib;
    LPSTR TargetName;
    LPSTR TargetExt;
    LPSTR KernelTest;
    LPSTR UserAppls;
    LPSTR UserTests;
    LPSTR NTTargetFile0;
    LPSTR Pch;
    LPSTR PchObj;
    LONG SourceLinesToCompile;
    LONG PassZeroLines;
    ULONG DirFlags;
    ULONG RecurseLevel;
    USHORT FindCount;
    USHORT CountSubDirs;
    SHORT CountOfFilesToCompile;
    SHORT CountOfPassZeroFiles;
    USHORT CheckSum;                // Name checksum
    char Name[1];
} DIRREC, *PDIRREC;


#define DIRDB_SOURCES                   0x00000001
#define DIRDB_DIRS                      0x00000002
#define DIRDB_MAKEFILE                  0x00000004
#define DIRDB_MAKEFIL0                  0x00000008
#define DIRDB_TARGETFILE0               0x00000010
#define DIRDB_TARGETFILES               0x00000020
#define DIRDB_RESOURCE                  0x00000040
#define DIRDB_PASS0                     0x00000080

#define DIRDB_SOURCES_SET               0x00000100
#define DIRDB_SYNC_PRODUCES             0x00000200
#define DIRDB_SYNC_CONSUMES             0x00000400

#define DIRDB_CHICAGO_INCLUDES          0x00000800

#define DIRDB_NEW                       0x00001000
#define DIRDB_SCANNED                   0x00002000
#define DIRDB_SHOWN                     0x00004000
#define DIRDB_GLOBAL_INCLUDES           0x00008000

#define DIRDB_SYNCHRONIZE_BLOCK         0x00010000
#define DIRDB_SYNCHRONIZE_PASS2_BLOCK   0x00020000
#define DIRDB_SYNCHRONIZE_DRAIN         0x00040000
#define DIRDB_SYNCHRONIZE_PASS2_DRAIN   0x00080000
#define DIRDB_COMPILENEEDED             0x00100000
#define DIRDB_COMPILEERRORS             0x00200000

#define DIRDB_SOURCESREAD               0x00400000
#define DIRDB_DLLTARGET                 0x00800000
#define DIRDB_LINKNEEDED                0x01000000
#define DIRDB_FORCELINK                 0x02000000
#define DIRDB_PASS0NEEDED               0x04000000
#define DIRDB_MAKEFIL1                  0x08000000
#define DIRDB_CHECKED_ALT_DIR           0x10000000
#define DIRDB_MANAGED_CODE              0x20000000
#define DIRDB_IDLTYPERPC                0x40000000

// Flags preserved when loading build.dat:

#define DIRDB_DBPRESERVE        0

//
// Dependency structure
//
typedef struct _DEPENDENCY {
    struct _DEPENDENCY *Next;   // Links together all dependencies
    LIST_ENTRY DependencyList;  // Links together all dependencies produced by this DIRREC
    LIST_ENTRY WaitList;        // List of DIRRECs that consume this dependency 
    PDIRREC    Producer;        // DIRREC that is going to produce this dependency
    HANDLE     hEvent;          // Signalled when dependency is produced
    BOOL       Done;
    USHORT     CheckSum;
    char       Name[1];
} DEPENDENCY, *PDEPENDENCY;

PDEPENDENCY AllDependencies;

typedef struct _DEPENDENCY_WAIT {
    LIST_ENTRY ListEntry;       // Links together all dependencies consumed by this DIRREC
    PDEPENDENCY Dependency;     // Dependency this wait block is waiting for
    PDIRREC    Consumer;        // DIRREC that is waiting on this dependency
} DEPENDENCY_WAIT, *PDEPENDENCY_WAIT;


typedef struct _TARGET {
    FILEREC *pfrCompiland;
    DIRREC *pdrBuild;
    LPSTR pszSourceDirectory;
    LPSTR ConditionalIncludes;
    ULONG DateTime;
    ULONG DirFlags;
    char Name[1];
} TARGET, *PTARGET;


#define BUILD_VERSION           0x0422
#define DBMASTER_NAME           "build.dat"
#define DB_MAX_PATH_LENGTH      512     // There's some sick people out there using 250 byte paths with 100 byte filenames
#define MAKEPARAMETERS_MAX_LEN  512

// If you change or add any values to this enum,
// also fix MemTab in buildutl.c:

typedef enum _MemType {
    MT_TOTALS = 0,
    MT_UNKNOWN,

    MT_CHILDDATA,
    MT_CMDSTRING,
    MT_DIRDB,
    MT_DIRSUP,
    MT_DIRPATH,
    MT_DIRSTRING,
    MT_EVENTHANDLES,
    MT_FILEDB,
    MT_FILEREADBUF,
    MT_FRBSTRING,
    MT_INCLUDEDB,
    MT_IOBUFFER,
    MT_MACRO,
    MT_SOURCEDB,
    MT_TARGET,
    MT_THREADFILTER,
    MT_THREADHANDLES,
    MT_THREADSTATE,
    MT_DEPENDENCY,
    MT_DEPENDENCY_WAIT,
    MT_XMLTHREADSTATE,
    MT_PXMLTHREADSTATE,
    
    MT_INVALID = 255,
} MemType;

struct _THREADSTATE;

typedef BOOL (*FILTERPROC)(struct _THREADSTATE *ThreadState, LPSTR p);

typedef struct _BUILDMETRICS {
    UINT NumberCompileWarnings;
    UINT NumberCompileErrors;
    UINT NumberCompiles;
    UINT NumberLibraries;
    UINT NumberLibraryWarnings;
    UINT NumberLibraryErrors;
    UINT NumberLinks;
    UINT NumberLinkWarnings;
    UINT NumberLinkErrors;
    UINT NumberBSCMakes;
    UINT NumberBSCWarnings;
    UINT NumberBSCErrors;
    UINT NumberVSToolErrors;
    UINT NumberVSToolWarnings;
    UINT NumberBinplaces;
    UINT NumberBinplaceWarnings;
    UINT NumberBinplaceErrors;
   
// XML support and fragments
    UINT NumberDirActions;
    UINT NumberActWarnings;
    UINT NumberActErrors;
} BUILDMETRICS, *PBUILDMETRICS;

typedef struct _THREADSTATE {
    USHORT cRowTotal;
    USHORT cColTotal;
    BOOL IsStdErrTty;
    FILE *ChildOutput;
    UINT ChildState;
    UINT ChildFlags;
    LPSTR ChildTarget;
    UINT LinesToIgnore;
    FILTERPROC FilterProc;
    ULONG ThreadIndex;
    ULONG XMLThreadIndex;
    CHAR UndefinedId[ DB_MAX_PATH_LENGTH ];
    CHAR ChildCurrentDirectory[ DB_MAX_PATH_LENGTH ];
    CHAR ChildCurrentFile[ DB_MAX_PATH_LENGTH ];
    DIRREC *CompileDirDB;
    BUILDMETRICS BuildMetrics;
} THREADSTATE, *PTHREADSTATE;

//
// Global Data (uninit will always be FALSE)
//

BOOL fUsage;                     // Set when usage message is to be displayed
BOOL fStatus;                    // Set by -s and -S options
BOOL fStatusTree;                // Set by -S option
BOOL fShowTree;                  // Set by -t and -T options
BOOL fShowTreeIncludes;          // Set by -T option
BOOL fClean;                     // Set by -c option
BOOL fCleanLibs;                 // Set by -C option
BOOL fCleanRestart;              // Set by -r option
BOOL fRestartClean;              // Set if -c and -r were both given
BOOL fRestartCleanLibs;          // Set if -C and -r were both given
BOOL fPause;                     // Set by -p option
BOOL fParallel;                  // Set on a multiprocessor machine or by -M
BOOL fPrintElapsed;              // Set by -P option
BOOL fQuery;                     // Set by -q option
BOOL fStopAfterPassZero;         // Set by -0 option
BOOL fQuicky;                    // Set by -z and -Z options
BOOL fQuickZero;                 // Set by -3
BOOL fSemiQuicky;                // Set by -Z option
BOOL fShowOutOfDateFiles;        // Set by -o option
BOOL fSyncLink;                  // Set by -a option
BOOL fForce;                     // Set by -f option
BOOL fEnableVersionCheck;        // Set by -v option
BOOL fSilentDependencies;        // Set by -i option
BOOL fKeep;                      // Set by -k option
BOOL fCompileOnly;               // Set by -L option
BOOL fLinkOnly;                  // Set by -l option
BOOL fErrorLog;                  // Set by -e option
BOOL fGenerateObjectsDotMacOnly; // Set by -O option
BOOL fShowWarningsOnScreen;      // Set by -w option
BOOL fNoisyScan;                 // Set by -y option
BOOL fFullErrors;                // Set by -b option
BOOL fWhyBuild;                  // Set by -why option
BOOL fChicagoProduct;            // Set if CHICAGO_PRODUCT is set in environment
BOOL fLineCleared;               // Current line on screen clear?
BOOL fPassZero;                  // Indicates we've found pass zero dirs
BOOL fFirstScan;                 // Indicates this is the first scan
BOOL fAlwaysPrintFullPath;       // Set by -F option
BOOL fTargetDirs;                // Set by -g option
BOOL fAlwaysKeepLogfile;         // Set by -E option
BOOL fShowUnusedDirs;            // Set by -u option
BOOL fColorConsole;              // set by -g option
BOOL fCheckIncludePaths;         // Set by -# option
BOOL fErrorBaseline;             // Set by -B option
BOOL fXMLOutput;                 // Set by -X option
BOOL fXMLVerboseOutput;          // Set by -Xv option
BOOL fXMLFragment;               // Set bu -Xf option
BOOL fNoThreadIndex;             // Set by -I option
BOOL fIgnoreSync;                // Set by -I option
BOOL fMTScriptSync;              // Set when communicating with the MTScript engine
BOOL fBuildAltDirSet;            // set when BUILD_ALT_DIR is defined.
BOOL fSuppressOutput;            // Set by -h options  

#define MAX_INCLUDE_PATTERNS 32

LPSTR AcceptableIncludePatternList[ MAX_INCLUDE_PATTERNS + 1 ];
LPSTR UnacceptableIncludePatternList[ MAX_INCLUDE_PATTERNS + 1 ];

LPSTR MakeProgram;
char MakeParameters[ MAKEPARAMETERS_MAX_LEN ];
LPSTR MakeParametersTail;
char MakeTargets[ 256 ];
char RestartDir[ 256 ];
char NtRoot[ 256 ];
char DbMasterName[ 256 ];
extern const char szNewLine[];

char BaselinePathName[DB_MAX_PATH_LENGTH];    // The file name for -B
BOOL bBaselineFailure;              // Indicates if there is a build failure that is not in the baseline file
VOID* pvBaselineContent;            // The content of the baseline file
DWORD cbBaselineContentSize;        // The size of the baseline file

char XMLFragmentDirectory[DB_MAX_PATH_LENGTH];  // The path for -Xf

char *pszSdkLibDest;
char *pszDdkLibDest;
char *pszPublicInternalPath;
char *pszIncOak;
char *pszIncDdk;
char *pszIncWdm;
char *pszIncSdk;
char *pszIncMfc;
char *pszIncCrt;
char *pszIncPri;
char *pszIncOs2;
char *pszIncPosix;
char *pszIncChicago;

char *szBuildTag;
char *pszObjDir;
char *pszObjDirSlash;
char *pszObjDirSlashStar;
BOOL fCheckedBuild;
ULONG iObjectDir;
extern ULONG NumberProcesses;
CRITICAL_SECTION TTYCriticalSection;
CRITICAL_SECTION XMLCriticalSection;

CHAR const *cmdexe;

LONG TotalFilesToCompile;
LONG TotalFilesCompiled;

LONG TotalLinesToCompile;
LONG TotalLinesCompiled;

ULONG ElapsedCompileTime;
DIRREC *CurrentCompileDirDB;

// Fixed length arrays...

UINT CountTargetMachines;
TARGET_MACHINE_INFO *TargetMachines[MAX_TARGET_MACHINES];
TARGET_MACHINE_INFO *PossibleTargetMachines[MAX_TARGET_MACHINES];
TARGET_MACHINE_INFO i386TargetMachine;
TARGET_MACHINE_INFO ia64TargetMachine;
TARGET_MACHINE_INFO Amd64TargetMachine;
TARGET_MACHINE_INFO ARMTargetMachine;
UINT TargetToPossibleTarget[MAX_TARGET_MACHINES];


#define MAX_OPTIONAL_DIRECTORIES        256
UINT CountOptionalDirs;
LPSTR OptionalDirs[MAX_OPTIONAL_DIRECTORIES];
BOOLEAN OptionalDirsUsed[MAX_OPTIONAL_DIRECTORIES];
BOOL BuildAllOptionalDirs;


#define MAX_EXCLUDE_DIRECTORIES         MAX_OPTIONAL_DIRECTORIES
UINT CountExcludeDirs;
LPSTR ExcludeDirs[MAX_EXCLUDE_DIRECTORIES];
BOOLEAN ExcludeDirsUsed[MAX_OPTIONAL_DIRECTORIES];


#define MAX_EXCLUDE_INCS                128
UINT CountExcludeIncs;
LPSTR ExcludeIncs[MAX_EXCLUDE_INCS];


#define MAX_INCLUDE_DIRECTORIES         256
UINT CountIncludeDirs;
UINT CountSystemIncludeDirs;
DIRREC *IncludeDirs[MAX_INCLUDE_DIRECTORIES];



#define MAX_BUILD_DIRECTORIES           8192

UINT CountPassZeroDirs;
DIRREC *PassZeroDirs[MAX_BUILD_DIRECTORIES];

UINT CountCompileDirs;
DIRREC *CompileDirs[MAX_BUILD_DIRECTORIES];

UINT CountLinkDirs;
DIRREC *LinkDirs[MAX_BUILD_DIRECTORIES];

UINT CountShowDirs;
DIRREC *ShowDirs[MAX_BUILD_DIRECTORIES];



DIRREC *AllDirs;
CHAR CurrentDirectory[DB_MAX_PATH_LENGTH];

BOOL AllDirsInitialized;
BOOL AllDirsModified;

USHORT GlobalSequence;
USHORT LocalSequence;

BOOLEAN fConsoleInitialized;
DWORD NewConsoleMode;

LPSTR BuildDefault;
LPSTR BuildParameters;

LPSTR SystemIncludeEnv;
LPSTR LocalIncludeEnv;

LPSTR BigBuf;
UINT BigBufSize;

UINT RecurseLevel;

FILE *LogFile;
FILE *WrnFile;
FILE *ErrFile;
FILE *IPGScriptFile;
FILE *IncFile;
FILE *XMLFile;

BUILDMETRICS PassMetrics;
BUILDMETRICS BuildMetrics;
BUILDMETRICS RunningTotals;

char szAsterisks[];
ULONG BuildStartTime;

WORD DefaultConsoleAttributes;

//
// Global message color settings. MsgColorSettings array defined in build.c.
//

typedef enum _MsgColor {
    MSG_COLOR_STATUS = 0,
    MSG_COLOR_SUMMARY,
    MSG_COLOR_WARNING,
    MSG_COLOR_ERROR,
    MSG_COLOR_COUNT // keep this at the end
} MsgColor;

typedef struct _MSG_COLOR_SETTINGS
{
    LPCSTR EnvVarName;
    WORD Color;
} MSG_COLOR_SETTINGS;

extern MSG_COLOR_SETTINGS MsgColorSettings[MSG_COLOR_COUNT];

#define MAKE_MSG_COLOR(index) \
    (MsgColorSettings[index].Color | (DefaultConsoleAttributes & (0x00f0)))

#define COLOR_STATUS  MAKE_MSG_COLOR(MSG_COLOR_STATUS)
#define COLOR_SUMMARY MAKE_MSG_COLOR(MSG_COLOR_SUMMARY)
#define COLOR_WARNING MAKE_MSG_COLOR(MSG_COLOR_WARNING)
#define COLOR_ERROR   MAKE_MSG_COLOR(MSG_COLOR_ERROR)

VOID ReportDirsUsage(VOID);

VOID SetObjDir(BOOL fAlternate);

//
// Stuff defined in buildscr.cpp
//

typedef enum _PROC_EVENTS
{
    PE_PASS0_COMPLETE = WM_USER,
    PE_PASS1_COMPLETE,
    PE_PASS2_COMPLETE,
    PE_EXIT
} PROC_EVENTS;


EXTERN_C HANDLE g_hMTThread;
EXTERN_C HANDLE g_hMTEvent;
EXTERN_C DWORD  g_dwMTThreadId;

EXTERN_C DWORD WINAPI MTScriptThread(LPVOID pv);
EXTERN_C void WaitForResume(BOOL fPause, PROC_EVENTS pe);
EXTERN_C void ExitMTScriptThread();

//
// Data Base functions defined in builddb.c
//

PDIRREC
LoadDirDB(LPSTR DirName);

#if DBG
VOID
PrintAllDirs(VOID);
#endif

VOID
PrintSourceDBList(SOURCEREC *psr, int i);

VOID
PrintFileDB(FILE *pf, FILEREC *pfr, int DetailLevel);

VOID
PrintDirDB(DIRREC *pdr, int DetailLevel);

FILEREC *
FindSourceFileDB(DIRREC *pdr, LPSTR pszRelPath, DIRREC **ppdr);

DIRREC *
FindSourceDirDB(
    LPSTR pszDir,               // directory
    LPSTR pszRelPath,           // relative path
    BOOL fTruncateFileName);    // TRUE: drop last component of path

SOURCEREC *
FindSourceDB(
    SOURCEREC *psr,
    FILEREC *pfr);

SOURCEREC *
InsertSourceDB(
    SOURCEREC **ppsrNext,
    FILEREC *pfr,
    UCHAR SubDirMask,
    UCHAR SrcFlags);

VOID
FreeSourceDB(SOURCEREC **ppsr);

VOID
UnsnapIncludeFiles(FILEREC *pfr, BOOL fUnsnapGlobal);

VOID
UnsnapAllDirectories(VOID);

VOID
FreeAllDirs(VOID);

PFILEREC
LookupFileDB(
    PDIRREC DirDB,
    LPSTR FileName);


PFILEREC
InsertFileDB(
    PDIRREC DirDB,
    LPSTR FileName,
    ULONG DateTime,
    USHORT Attr,
    ULONG  FileFlags);

VOID
DeleteUnscannedFiles(PDIRREC DirDB);

PINCLUDEREC
InsertIncludeDB(
    PFILEREC FileDB,
    LPSTR IncludeFileName,
    USHORT IncFlags);

VOID
LinkToCycleRoot(INCLUDEREC *pir, FILEREC *pfrRoot);

VOID
RemoveFromCycleRoot(INCLUDEREC *pir, FILEREC *pfrRoot);

VOID
MergeIncludeFiles(FILEREC *pfr, INCLUDEREC *pirList, FILEREC *pfrRoot);

VOID
MarkIncludeFileRecords(PFILEREC FileDB);

VOID
DeleteIncludeFileRecords(PFILEREC FileDB);

PFILEREC
FindIncludeFileDB(
    FILEREC *pfrSource,
    FILEREC *pfrCompiland,
    DIRREC *pdrBuild,
    LPSTR pszSourceDirectory,
    INCLUDEREC *IncludeDB);

BOOL
SaveMasterDB(VOID);

void
LoadMasterDB(VOID);

PDIRREC
LoadMasterDirDB(LPSTR s);

PFILEREC
LoadMasterFileDB(LPSTR s);

PINCLUDEREC
LoadMasterIncludeDB(LPSTR s);

USHORT
CheckSum(LPSTR psz);

//
// Scanning functions defined in buildscn.c
//

VOID
AddIncludeDir(DIRREC *pdr, UINT *pui);

VOID
AddShowDir(DIRREC *pdr);

VOID
ScanGlobalIncludeDirectory(LPSTR path);

VOID
ScanIncludeEnv(LPSTR IncludeEnv);

PDIRREC
ScanDirectory(LPSTR DirName);

BOOL
ScanFile(PFILEREC FileDB);


//
// Functions defined in buildmak.c
//

VOID
ScanSourceDirectories(LPSTR DirName);

VOID
CompilePassZeroDirectories(VOID);

VOID
CompileSourceDirectories(VOID);

VOID
LinkSourceDirectories(VOID);


VOID
FreeDirSupData(DIRSUP *pds);

VOID
FreeDirData(DIRREC *pdr);

BOOL
CheckDependencies(
    PTARGET Target,
    FILEREC *FileDB,
    BOOL CheckDate,
    FILEREC **ppFileDBRoot);

BOOL
CreateBuildDirectory(LPSTR Name);

VOID
CreatedBuildFile(LPSTR DirName, LPSTR FileName);

VOID
GenerateObjectsDotMac(DIRREC *DirDB, DIRSUP *pds, ULONG DateTimeSources);

VOID
ExpandObjAsterisk(
    LPSTR pbuf,
    LPSTR pszpath,
    LPSTR *ppszObjectDirectory);

//
// Build -# functions defined in buildinc.c
//

LPCTSTR
FindCountedSequenceInString(
    IN LPCTSTR String,
    IN LPCTSTR Sequence,
    IN DWORD   Length);

BOOL
DoesInstanceMatchPattern(
    IN LPCTSTR Instance,
    IN LPCTSTR Pattern);

LPSTR
CombinePaths(
    IN  LPCSTR ParentPath,
    IN  LPCSTR ChildPath,
    OUT LPSTR  TargetPath);

VOID
CreateRelativePath(
    IN  LPCSTR SourceAbsName,
    IN  LPCSTR TargetAbsName,
    OUT LPSTR  RelativePath);

BOOL
ShouldWarnInclude(
    IN LPCSTR CompilandFullName,
    IN LPCSTR IncludeeFullName);

VOID
CheckIncludeForWarning(
    IN LPCSTR CompilandDir,
    IN LPCSTR CompilandName,
    IN LPCSTR IncluderDir,
    IN LPCSTR IncluderName,
    IN LPCSTR IncludeeDir,
    IN LPCSTR IncludeeName);

//
// Utility functions defined in buildutl.c
//

VOID
AllocMem(size_t cb, VOID **ppv, MemType mt);

VOID
FreeMem(VOID **ppv, MemType mt);

VOID
ReportMemoryUsage(VOID);


BOOL
MyOpenFile(
    LPSTR DirName,
    LPSTR FileName,
    LPSTR Access,
    FILE **Stream,
    BOOL fBufferedIO);

BOOL
OpenFilePush(
    LPSTR pszdir,
    LPSTR pszfile,
    LPSTR pszCommentToEOL,
    FILE **ppf
    );

BOOL
SetupReadFile(LPSTR pszdir, LPSTR pszfile, LPSTR pszCommentToEOL,
              FILE **ppf);

ULONG
CloseReadFile(UINT *pcline);

LPSTR
ReadLine(FILE *pf);

UINT
ProbeFile(
    LPSTR DirName,
    LPSTR FileName);

BOOL
EnsureDirectoriesExist(
    LPSTR DirName);

ULONG
DateTimeFile(
    LPSTR DirName,
    LPSTR FileName);

ULONG
DateTimeFile2(
    LPSTR DirName,
    LPSTR FileName);

ULONG (*pDateTimeFile)(LPSTR, LPSTR);

BOOL (WINAPI * pGetFileAttributesExA)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID);

BOOL
DeleteSingleFile(
    LPSTR DirName,
    LPSTR FileName,
    BOOL QuietFlag);

BOOL
DeleteMultipleFiles(
    LPSTR DirName,
    LPSTR FilePattern);

BOOL
CloseOrDeleteFile(
    FILE **Stream,
    LPSTR DirName,
    LPSTR FileName,
    ULONG SizeThreshold);

LPSTR
PushCurrentDirectory(LPSTR NewCurrentDirectory);

VOID
PopCurrentDirectory(LPSTR OldCurrentDirectory);

UINT
ExecuteProgram(
    LPSTR ProgramName,
    LPSTR CommandLine,
    LPSTR MoreCommandLine,
    BOOL MustBeSynchronous,
    LPCSTR XMLDir,
    LPCSTR XMLAction);

VOID
WaitForParallelThreads(PDIRREC Dir);

VOID
CheckAllConsumer(BOOL);

BOOL
CanonicalizePathName(
    LPSTR SourcePath,
    UINT Action,
    LPSTR FullPath);


#define CANONICALIZE_ONLY 0
#define CANONICALIZE_FILE 1
#define CANONICALIZE_DIR  2

LPSTR
FormatPathName(
    LPSTR DirName,
    LPSTR FileName);

#if DBG
VOID
AssertPathString(LPSTR pszPath);
#else
#define AssertPathString(p)
#endif

LPSTR
AppendString(
    LPSTR Destination,
    LPSTR Source,
    BOOL PrefixWithSpace);

LPSTR CopyString(LPSTR Destination, LPSTR Source, BOOL fPath);
VOID  MakeString(LPSTR *Destination, LPSTR Source, BOOL fPath, MemType mt);
VOID  MakeExpandedString(LPSTR *Destination, LPSTR Source);
VOID  FreeString(LPSTR *Source, MemType mt);
LPSTR FormatNumber(ULONG Number);
LPSTR FormatTime(ULONG Seconds);

BOOL AToX(LPSTR *pp, ULONG *pul);
BOOL AToD(LPSTR *pp, ULONG *pul);
EXTERN_C VOID __cdecl LogMsg(const char *pszfmt, ...);
EXTERN_C VOID __cdecl BuildMsg(const char *pszfmt, ...);
EXTERN_C VOID __cdecl BuildMsgRaw(const char *pszfmt, ...);
EXTERN_C VOID __cdecl BuildError(const char *pszfmt, ...);
EXTERN_C VOID __cdecl BuildErrorRaw(const char *pszfmt, ...);
EXTERN_C VOID __cdecl BuildColorMsg(WORD, const char *pszfmt, ...);
EXTERN_C VOID __cdecl BuildColorMsgRaw(WORD, const char *pszfmt, ...);
EXTERN_C VOID __cdecl BuildColorError(WORD, const char *pszfmt, ...);
EXTERN_C VOID __cdecl BuildColorErrorRaw(WORD, const char *pszfmt, ...);

VOID*
memfind(VOID* pvWhere, DWORD cbWhere, VOID* pvWhat, DWORD cbWhat);

//
// XML logging
//

UINT NumberPasses;
DWORD XMLStartTicks;

#define XML_THREAD_BUFFER_SIZE  (2*1024*1024)
#define XML_LOCAL_BUFFER_SIZE   4096

#define XML_SCHEMA "buildschema.xml"

// general purpose buffer 
// initially used to hold the command line
char szXMLBuffer[XML_LOCAL_BUFFER_SIZE];

typedef struct _XMLTHREADSTATE {
    BYTE XMLBuffer[XML_THREAD_BUFFER_SIZE];
    SIZE_T iXMLBufferPos;
    SIZE_T iXMLBufferLen;
    SIZE_T iXMLFileStart;
    BOOL fXMLInAction;      // indicates if the thread has opened action tag
} XMLTHREADSTATE, *PXMLTHREADSTATE;

PXMLTHREADSTATE* PXMLThreadStates;
PXMLTHREADSTATE PXMLGlobalState;
BOOL fXMLInitialized;

// Initializes the XML structures
BOOL
XMLInit(VOID);

// Frees the allocated memory
VOID
XMLUnInit(VOID);

// Prepares XML buffer fot the thread
VOID
XMLThreadInitBuffer(PTHREADSTATE ThreadState);

// writes into the thread's block and then all other threads' blocks
VOID _cdecl
XMLThreadWrite(PTHREADSTATE ThreadState, LPCSTR pszFmt, ...);

// opens tag in the thread's block
VOID _cdecl
XMLThreadOpenTag(PTHREADSTATE ThreadState, LPCSTR pszTag, LPCSTR pszFmt, ...);

// closes the last open tag; the argument is for verification only
VOID
XMLThreadCloseTag(PTHREADSTATE ThreadState, LPCSTR pszTag);

// writes out completely the thread's block and releases it
VOID
XMLThreadReleaseBuffer(PTHREADSTATE ThreadState);

// writes into the global block. It is restricted to not have any threads open
VOID _cdecl
XMLGlobalWrite(LPCSTR pszFmt, ...);

// opens tag in the global block
VOID _cdecl
XMLGlobalOpenTag(LPCSTR pszTag, LPCSTR pszFmt, ...);

// closes the last open tag
VOID
XMLGlobalCloseTag();

VOID
XMLUpdateEndTag(BOOL fCompleted);

LPSTR
XMLEncodeBuiltInEntities(LPSTR pszString, DWORD cbStringSize);

LPSTR
XMLEncodeBuiltInEntitiesCopy(LPSTR pszString, LPSTR pszTarget);

BOOL
XMLScanBackTag(LPSTR pszEnd, LPSTR pszSentinel, LPSTR* ppszStart);

LPSTR
XMLBuildMetricsString(PBUILDMETRICS Metrics);

// XML fragment
VOID _cdecl
XMLWriteFragmentFile(LPCSTR pszBaseFileName, LPCSTR pszFmt, ...);

VOID _cdecl
XMLWriteDirFragmentFile(LPCSTR pszRelPath, PVOID pvBlock, SIZE_T cbCount);

VOID
AddBuildMetrics(PBUILDMETRICS TargetMetrics, PBUILDMETRICS SourceMetrics);

VOID
XMLEnterCriticalSection();

VOID
XMLLeaveCriticalSection();

//
// Functions in buildsrc.c
//

extern DWORD StartTime;

VOID
StartElapsedTime(VOID);

VOID
PrintElapsedTime(VOID);

LPSTR
FormatElapsedTime(DWORD dwStartTime);

LPSTR
FormatCurrentDateTime();

BOOL
ReadDirsFile(DIRREC *DirDB);


VOID
ProcessLinkTargets(PDIRREC DirDB, LPSTR CurrentDirectory);

BOOL
SplitToken(LPSTR pbuf, char chsep, LPSTR *ppstr);

BOOL
MakeMacroString(LPSTR *pp, LPSTR p);

VOID
SaveMacro(LPSTR pszName, LPSTR pszValue);

VOID
FormatLinkTarget(
    LPSTR path,
    LPSTR *ObjectDirectory,
    LPSTR TargetPath,
    LPSTR TargetName,
    LPSTR TargetExt);

BOOL
ReadSourcesFile(DIRREC *DirDB, DIRSUP *pds, ULONG *pDateTimeSources);

VOID
PostProcessSources(DIRREC *pdr, DIRSUP *pds);

VOID
PrintDirSupData(DIRSUP *pds);

//+---------------------------------------------------------------------------
//
//  Function:   IsFullPath
//
//----------------------------------------------------------------------------

__inline BOOL
IsFullPath(char *pszfile)
{
    return(pszfile[0] == '\\' || (isalpha(pszfile[0]) && pszfile[1] == ':'));
}

//
// List macros stolen from ntrtl.h
//
VOID
FORCEINLINE
InitializeListHead(
    IN PLIST_ENTRY ListHead
    )
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))



VOID
FORCEINLINE
RemoveEntryList(
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;
}

PLIST_ENTRY
FORCEINLINE
RemoveHeadList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;
    return Entry;
}



PLIST_ENTRY
FORCEINLINE
RemoveTailList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;
    return Entry;
}


VOID
FORCEINLINE
InsertTailList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
}


VOID
FORCEINLINE
InsertHeadList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buggy\driver\tdriver.h ===
//
// Template driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Header:  tdriver.h
// Author:  Silviu Calinoiu (SilviuC)
// Created: 4/20/1999 3:04pm
//

#ifndef _TDRIVER_H_INCLUDED_
#define _TDRIVER_H_INCLUDED_

//
// Structure received from user-mode with the
// bugcheck number and parameters
//

typedef struct _tag_BUGCHECK_PARAMS
{
    ULONG BugCheckCode;
    ULONG_PTR BugCheckParameters[ 4 ];
} BUGCHECK_PARAMS, *PBUGCHECK_PARAMS;

//
// Structure receoved from user mode with the parameters
// for a "read" operation in TdReservedMappingDoRead
//

typedef struct _tag_USER_READ_BUFFER
{
	PVOID UserBuffer;
	SIZE_T UserBufferSize;
} USER_READ_BUFFER, *PUSER_READ_BUFFER;

//
// Device name. This should end in the of the driver.
//

#define TD_NT_DEVICE_NAME      L"\\Device\\buggy"
#define TD_DOS_DEVICE_NAME     L"\\DosDevices\\buggy"

#define TD_POOL_TAG            '_guB' // Bug_

//
// Constants used in the user-mode driver controller.
//

#define TD_DRIVER_NAME     TEXT("buggydriver")

//
// Array length macro
//

#ifndef ARRAY_LENGTH
#define ARRAY_LENGTH( array ) ( sizeof( array ) / sizeof( array[ 0 ] ) )
#endif //#ifndef ARRAY_LENGTH


//
//
//

#ifndef SESSION_POOL_MASK
#define SESSION_POOL_MASK 32
#endif //#ifndef SESSION_POOL_MASK


//
// Local function used inside the driver. They are enclosed
// in #ifdef _NTDDK_ so that user mode program including the header
// are not affected by this.
//

#ifdef _NTDDK_

NTSTATUS
TdDeviceCreate (

    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
TdDeviceClose (

    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
TdDeviceCleanup (

    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
TdDeviceControl (

    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

VOID
TdDeviceUnload (

    IN PDRIVER_OBJECT DriverObject);

NTSTATUS
TdInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#endif // #ifdef _NTDDK_


//
// Type:
//
//     TD_DRIVER_INFO
//
// Description:
//
//     This is the driver device extension structure.
//

typedef struct {

    ULONG Dummy;

} TD_DRIVER_INFO, * PTD_DRIVER_INFO;


#endif // #ifndef _TDRIVER_H_INCLUDED_

//
// End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\build.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994.
//
//  File:       build.c
//
//  Contents:   Parameter processing and main entry point for Build.exe
//
//  History:    16-May-89      SteveWo         Created
//              ...   See SLM log
//              26-Jul-94      LyleC           Cleanup/Add Pass0 support
//
//----------------------------------------------------------------------------

#include "build.h"

#include <ntverp.h>

#ifdef _X86_
extern PVOID __safe_se_handler_table;   // Absolute symbol whose address is the count of entries.
extern BYTE  __safe_se_handler_count;   // Base of the safe handler entry table
extern DWORD_PTR __security_cookie;
#endif

//
// Increase critical section timeout so people don't get
// frightened when the CRT takes a long time to acquire
// its critical section.
//
IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    sizeof(_load_config_used),  // Size
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // GlobalFlagsClear
    0,                          // GlobalFlagsSet
    1000 * 60 * 60 * 24,        // CriticalSectionTimeout (milliseconds)
    0,                          // DeCommitFreeBlockThreshold
    0,                          // DeCommitTotalFreeThreshold
    0,                          // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0,        // Reserved
#ifdef _X86_
    (DWORD)&__security_cookie,
    (DWORD)&__safe_se_handler_table,
    (DWORD)&__safe_se_handler_count
#else
    0,
    0,
    0
#endif
};

//
// Target machine info:
//
//  SourceSubDirMask, Description, Switch, MakeVariable,
//  SourceVariable, ObjectVariable, AssociateDirectory,
//  SourceDirectory, ObjectDirectory
//

TARGET_MACHINE_INFO i386TargetMachine = {
    TMIDIR_I386, "i386", "-386", "-x86", "386=1",
    "i386_SOURCES", "386_OBJECTS", "i386",
    "i386", "i386dirs", { "i386"},
    DIR_INCLUDE_X86 | DIR_INCLUDE_WIN32
};

TARGET_MACHINE_INFO ia64TargetMachine = {
    TMIDIR_IA64, "IA64", "-ia64", "-merced", "IA64=1",
    "IA64_SOURCES", "IA64_OBJECTS", "ia64",
    "ia64", "ia64dirs", { "ia64"},
    DIR_INCLUDE_IA64 | DIR_INCLUDE_RISC | DIR_INCLUDE_WIN64
};

TARGET_MACHINE_INFO Amd64TargetMachine = {
    TMIDIR_AMD64, "AMD64", "-amd64", "-amd64", "AMD64=1",
    "AMD64_SOURCES", "AMD64_OBJECTS", "amd64",
    "amd64", "amd64dirs", { "amd64"},
    DIR_INCLUDE_AMD64 | DIR_INCLUDE_RISC | DIR_INCLUDE_WIN64
};

TARGET_MACHINE_INFO ARMTargetMachine = {
    TMIDIR_ARM, "ARM", "-arm", "-arm", "ARM=1",
    "ARM_SOURCES", "ARM_OBJECTS", "arm",
    "arm", "armdirs", { "arm"},
    DIR_INCLUDE_ARM | DIR_INCLUDE_WIN32
};

TARGET_MACHINE_INFO *PossibleTargetMachines[MAX_TARGET_MACHINES] = {
    &i386TargetMachine,
    &ia64TargetMachine,
    &Amd64TargetMachine,
    &ARMTargetMachine
};

//
// Global message color settings, set to default values.
//

MSG_COLOR_SETTINGS MsgColorSettings[MSG_COLOR_COUNT] = {
    "BUILD_COLOR_STATUS",  FOREGROUND_INTENSITY | FOREGROUND_BLUE | FOREGROUND_GREEN,
    "BUILD_COLOR_SUMMARY", FOREGROUND_INTENSITY | FOREGROUND_GREEN,
    "BUILD_COLOR_WARNING", FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN,
    "BUILD_COLOR_ERROR",   FOREGROUND_INTENSITY | FOREGROUND_RED
};

//
// Machine specific target dirs default. If one there is only one build
// target and a target specific dirs file is selected, then this gets
// filled with a pointer to the target specific dirs filename.
//

LPSTR pszTargetDirs = "";

#define AltDirMaxSize 10            // Maximum size for alternate obj dir name

CHAR LogDirectory[DB_MAX_PATH_LENGTH] = ".";
CHAR LogFileName[DB_MAX_PATH_LENGTH] = "build";
CHAR WrnFileName[DB_MAX_PATH_LENGTH] = "build";
CHAR ErrFileName[DB_MAX_PATH_LENGTH] = "build";
CHAR IncFileName[DB_MAX_PATH_LENGTH] = "build";
CHAR XMLFileName[DB_MAX_PATH_LENGTH] = "build";

CHAR szObjRoot[DB_MAX_PATH_LENGTH];
CHAR *pszObjRoot;

CHAR szObjDir[DB_MAX_PATH_LENGTH];
CHAR szObjDirSlash[DB_MAX_PATH_LENGTH];
CHAR szObjDirSlashStar[DB_MAX_PATH_LENGTH];

CHAR szObjDirD[DB_MAX_PATH_LENGTH];
CHAR szObjDirSlashD[DB_MAX_PATH_LENGTH];
CHAR szObjDirSlashStarD[DB_MAX_PATH_LENGTH];

CHAR *pszObjDir = szObjDir;
CHAR *pszObjDirSlash = szObjDirSlash;
CHAR *pszObjDirSlashStar = szObjDirSlashStar;
CHAR *pszObjDirD = szObjDirD;

BOOL fCheckedBuild = TRUE;
ULONG iObjectDir = 0;
BOOL fDependencySwitchUsed;
BOOL fCmdLineDependencySwitchUsed;
BOOL fCmdLineQuicky;
BOOL fCmdLineSemiQuicky;
BOOL fCmdLineQuickZero;
BOOL fErrorBaseline;
BOOL fBuildAltDirSet;
CHAR *BuildProduct;

char BaselinePathName[DB_MAX_PATH_LENGTH];    // The file name for -B
BOOL bBaselineFailure;              // Indicates if there is a build failure that is not in the baseline file
DWORD dwLastBaselineSeekPos;        // Keeps track on the passed baseline failures

ULONG DefaultProcesses = 0;
CHAR *szBuildTag;

#define MAX_ENV_ARG 512

const char szNewLine[] = "\r\n";
const char szUsage[] =
"Usage: BUILD [-?] display this message\n"
"\t[-#] force _objects.mac to be regenerated\n"
"\t[-0] pass 0 generation only, no compile, no link\n"
"\t[-2] same as old -Z (only do a 2 pass build - no pass 0)\n"
"\t[-3] same as -Z\n"
"\t[-a] allows synchronized blocks and drains during link pass\n"
"\t[-b] displays full error message text (doesn't truncate)\n"
"\t[-B [baseline]] Checks the build failures against a baseline\n"
"\t\tIf there is no baseline,terminates the build on the first error\n"
"\t[-c] deletes all object files\n"
"\t[-C] deletes all .lib files only\n"
#if DBG
"\t[-d] display debug information\n"
#endif
"\t[-D] check dependencies before building (on by default if BUILD_PRODUCT != NT)\n"
"\t[-e] generates build.log, build.wrn & build.err files\n"
"\t[-E] always keep the log/wrn/err files (use with -z)\n"
"\t[-f] force rescan of all source and include files\n"
"\t[-F] when displaying errors/warnings to stdout, print the full path\n"
"\t[-g] Display warnings/errors/summary in color\n"
"\t[-h] Hide console output\n"
"\t[-G] enables target specific dirs files iff one target\n"
"\t[-i] ignore extraneous dependency warning messages\n"
"\t[-I] do not display thread index if multiprocessor build\n"
"\t[-j filename] use 'filename' as the name for log files\n"
"\t[-k] keep (don't delete) out-of-date targets\n"
"\t[-l] link only, no compiles\n"
"\t[-L] compile only, no link phase\n"
"\t[-m] run build in the idle priority class\n"
"\t[-M [n]] Multiprocessor build (for MP machines)\n"
"\t[-n] No SYNCHRONIZE_BLOCK and SYNCHRONIZE_DRAIN directives\n"
"\t[-o] display out-of-date files\n"
"\t[-O] generate obj\\_objects.mac file for current directory\n"
"\t[-p] pause' before compile and link phases\n"
"\t[-P] Print elapsed time after every directory\n"
"\t[-q] query only, don't run NMAKE\n"
"\t[-r dirPath] restarts clean build at specified directory path\n"
"\t[-s] display status line at top of display\n"
"\t[-S] display status line with include file line counts\n"
"\t[-t] display the first level of the dependency tree\n"
"\t[-T] display the complete dependency tree\n"
"\t[-$] display the complete dependency tree hierarchically\n"
"\t[-u] display unused BUILD_OPTIONS\n"
"\t[-v] enable include file version checking\n"
"\t[-w] show warnings on screen\n"
"\t[-x filename] exclude include file from dependency checks\n"
"\t[-X] generates build.xml file\n"
"\t[-Xv] generates verbose build.xml file\n"
"\t[-y] show files scanned\n"
"\t[-z] no dependency checking or scanning of source files -\n"
"\t\tone pass compile/link\n"
"\t[-Z] no dependency checking or scanning of source files -\n"
"\t\tthree passes\n"
"\t[-why] list reasons for building targets\n"
"\n"
"\t[-386] build targets for 32-bit Intel\n"
"\t[-x86] Same as -i386\n"
"\t[-ia64] build targets for IA64\n"
"\t[-amd64] build targets for AMD64\n"
"\t[-arm] build targets for ARM\n"
"\n"
"\t[-jpath pathname] use 'pathname' as the path for log files instead of \".\"\n"
"\t[-nmake arg] argument to pass to NMAKE\n"
"\t[-clean] equivalent to '-nmake clean'\n"
"\tNon-switch parameters specify additional source directories\n"
"\t* builds all optional source directories\n";


BOOL
ProcessParameters(int argc, LPSTR argv[], BOOL SkipFirst);

VOID
GetEnvParameters(
                LPSTR EnvVarName,
                LPSTR DefaultValue,
                int *pargc,
                int maxArgc,
                LPSTR argv[]);

VOID
FreeEnvParameters(int argc, LPSTR argv[]);

VOID
FreeCmdStrings(VOID);

VOID
MungePossibleTarget(
                   PTARGET_MACHINE_INFO pti
                   );

VOID
GetIncludePatterns(
                  LPSTR EnvVarName,
                  int maxArgc,
                  LPSTR argv[]);

VOID
FreeIncludePatterns(
                   int argc,
                   LPSTR argv[]);

BOOL
LoadBaselineFile(VOID);

VOID
FreeBaselineFile(VOID);

VOID
ResetProducerEvents(VOID);

BOOL
WINAPI
ControlCHandler(DWORD CtrlType)
{
    if ((CtrlType == CTRL_C_EVENT) || (CtrlType == CTRL_BREAK_EVENT)) {
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), DefaultConsoleAttributes);
    }
    return FALSE;
}
//+---------------------------------------------------------------------------
//
//  Function:   main
//
//----------------------------------------------------------------------------

int
__cdecl main(
            int argc,
            LPSTR argv[]
            )
{
    char c;
    PDIRREC DirDB;
    UINT i;
    int EnvArgc = 0;
    LPSTR EnvArgv[ MAX_ENV_ARG ] = {0};
    LPSTR s, s1;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    time_t ltime;

    LPSTR PostBuildCmd;
    BOOL  fPauseDone = FALSE;

#if DBG
    BOOL fDebugSave;

    fDebug = 0;
#endif

    if ( getenv("NTMAKEENV") == NULL ) {
        printf("environment variable NTMAKEENV must be defined\n");
        exit(1);
    }
    strcpy(szObjDir, "obj");
    strcpy(szObjDirSlash, "obj\\");
    strcpy(szObjDirSlashStar, "obj\\*");
    strcpy(szObjDirD, "objd");
    strcpy(szObjDirSlashD, "objd\\");
    strcpy(szObjDirSlashStarD, "objd\\*");

    for (i=3; i<_NFILE; i++) {
        _close( i );
    }

    pGetFileAttributesExA = (BOOL (WINAPI *)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID))
                            GetProcAddress(GetModuleHandle("kernel32.dll"), "GetFileAttributesExA");

    if (pGetFileAttributesExA) {
        pDateTimeFile = DateTimeFile2;
    } else {
        pDateTimeFile = DateTimeFile;
    }

    InitializeCriticalSection(&TTYCriticalSection);

    s1 = getenv("COMSPEC");
    if (s1) {
        cmdexe = s1;
    } else {
        cmdexe = ( _osver & 0x8000 ) ? "command.com" : "cmd.exe";
    }

    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
    DefaultConsoleAttributes = csbi.wAttributes;

    memset(&RunningTotals, 0, sizeof(RunningTotals));

    for (i = 0; i < MSG_COLOR_COUNT; i++) {
        s = getenv(MsgColorSettings[i].EnvVarName);
        if (s) {
            MsgColorSettings[i].Color = atoi(s) & (0x000f);
        }
    }

    SetConsoleCtrlHandler(ControlCHandler, TRUE);

    {
        SYSTEMTIME st;
        FILETIME   ft;

        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);

        FileTimeToDosDateTime( &ft,
                               ((LPWORD)&BuildStartTime)+1,
                               (LPWORD)&BuildStartTime
                             );
    }

    BigBufSize = 0xFFF0;
    AllocMem(BigBufSize, &BigBuf, MT_IOBUFFER);

    // All env parsing should happen here (after the cmd line is processed)

    s = getenv("BASEDIR");
    if (s) {
        strcpy(NtRoot, s);
    } else {
        s = getenv("_NTROOT");
        if (!s)
            s = "\\nt";

        s1 = getenv("_NTDRIVE");
        if (!s1)
            s1 = "";

        sprintf(NtRoot, "%s%s", s1, s);
    }
    sprintf(DbMasterName, "%s\\%s", NtRoot, DBMASTER_NAME);


    s = getenv("_OBJ_ROOT");
    if (s) {
        pszObjRoot = strcpy(szObjRoot, s);
    }

    s = getenv("BUILD_ALT_DIR");
    if (s) {
        if (strlen(s) > sizeof(szObjDir) - strlen(szObjDir) - 1) {
            BuildError("environment variable BUILD_ALT_DIR may not be longer than %d characters.\r\n",
                       sizeof(szObjDir) - strlen(szObjDir) - 1);
            exit(1);
        }
        strcat(szObjDir, s);
        strcpy(szObjDirSlash, szObjDir);
        strcpy(szObjDirSlashStar, szObjDir);
        strcat(szObjDirSlash, "\\");
        strcat(szObjDirSlashStar, "\\*");
        strcat(LogFileName, s);
        strcat(WrnFileName, s);
        strcat(ErrFileName, s);
        strcat(IncFileName, s);
        strcat(XMLFileName, s);
        fBuildAltDirSet= TRUE;
    }

    s = getenv("NTDEBUG");
    if (!s || *s == '\0' || strcmp(s, "retail") == 0 || strcmp(s, "ntsdnodbg") == 0) {
        fCheckedBuild = FALSE;
    }

    s = getenv("OS2_INC_PATH");
    if (s) {
        MakeString(&pszIncOs2, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncOs2, "\\public\\sdk\\inc\\os2");
    }
    s = getenv("POSIX_INC_PATH");
    if (s) {
        MakeString(&pszIncPosix, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncPosix, "\\public\\sdk\\inc\\posix");
    }
    s = getenv("CHICAGO_INC_PATH");
    if (s) {
        MakeString(&pszIncChicago, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncChicago, "\\public\\sdk\\inc\\chicago");
    }
    s = getenv("CRT_INC_PATH");
    if (s) {
        MakeString(&pszIncCrt, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncCrt, "\\public\\sdk\\inc\\crt");
    }
    s = getenv("SDK_INC_PATH");
    if (s) {
        MakeString(&pszIncSdk, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncSdk, "\\public\\sdk\\inc");
    }
    s = getenv("OAK_INC_PATH");
    if (s) {
        MakeString(&pszIncOak, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncOak, "\\public\\oak\\inc");
    }
    s = getenv("DDK_INC_PATH");
    if (s) {
        MakeString(&pszIncDdk, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncDdk, "\\public\\ddk\\inc");
    }
    s = getenv("WDM_INC_PATH");
    if (s) {
        MakeString(&pszIncWdm, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncWdm, "\\public\\ddk\\inc\\wdm");
    }
    s = getenv("PRIVATE_INC_PATH");
    if (s) {
        MakeString(&pszIncPri, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncPri, "\\private\\inc");
    }
    s = getenv("MFC_INCLUDES");
    if (s) {
        MakeString(&pszIncMfc, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncMfc, "\\public\\sdk\\inc\\mfc42");
    }
    s = getenv("SDK_LIB_DEST");
    if (s) {
        MakeString(&pszSdkLibDest, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszSdkLibDest, "\\public\\sdk\\lib");
    }
    s = getenv("DDK_LIB_DEST");
    if (s) {
        MakeString(&pszDdkLibDest, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszDdkLibDest, "\\public\\sdk\\lib");
    }

    s = getenv("PUBLIC_INTERNAL_PATH");
    if (s) {
        MakeString(&pszPublicInternalPath, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszPublicInternalPath, "\\public\\internal");
    }


    szBuildTag = getenv("BUILD_TAG");

    strcpy( MakeParameters, "" );
    MakeParametersTail = AppendString( MakeParameters,
                                       "/c BUILDMSG=Stop.",
                                       FALSE);

    RecurseLevel = 0;

#if DBG
    if ((s = getenv("BUILD_DEBUG_FLAG")) != NULL) {
        i = atoi(s);
        if (!isdigit(*s)) {
            i = 1;
        }
        BuildMsg("Debug Output Enabled: %u ==> %u\r\n", fDebug, fDebug | i);
        fDebug |= i;
    }
#endif

    if (!(MakeProgram = getenv( "BUILD_MAKE_PROGRAM" ))) {
        MakeProgram = "NMAKE.EXE";
    }

    if (s = getenv("BUILD_PATH")) {
        SetEnvironmentVariable("PATH", s);
    }

    if (s = getenv("COPYCMD")) {
        if (!strchr(s, 'y') && !strchr(s, 'Y')) {
            // COPYCMD is set, but /y isn't a part of it.  Add /Y.
            BuildMsg("Adding /Y to COPYCMD so xcopy ops won't hang.\r\n");
            s1 = malloc(strlen(s) + sizeof(" /Y") + 1);
            if (s1) {
                strcpy(s1, s);
                strcat(s1, " /Y");
                SetEnvironmentVariable("COPYCMD", s1);
            }
        }
    } else {
        // COPYCMD not set.  Do so.
        BuildMsg("Adding /Y to COPYCMD so xcopy ops won't hang.\r\n");
        SetEnvironmentVariable("COPYCMD", "/Y");
    }

    PostBuildCmd = getenv("BUILD_POST_PROCESS");

    SystemIncludeEnv = getenv( "INCLUDE" );
    GetCurrentDirectory( sizeof( CurrentDirectory ), CurrentDirectory );

    for (i = 0; i < MAX_TARGET_MACHINES; i++) {
        TargetMachines[i] = NULL;
        TargetToPossibleTarget[i] = 0;
        MungePossibleTarget(PossibleTargetMachines[i]);
    }

    // prepare the command line in the XML buffer in case we need it
    strcpy(szXMLBuffer, "CMDLINE=\"");
    XMLEncodeBuiltInEntitiesCopy(GetCommandLine(), szXMLBuffer + strlen(szXMLBuffer));
    strcat(szXMLBuffer, "\"");

    if (!(BuildProduct = getenv("BUILD_PRODUCT"))) {
        BuildProduct = "";
    }

    if (!ProcessParameters( argc, argv, TRUE )) {
        fUsage = TRUE;
    } else {
        int CurrentEnvArgc = EnvArgc;
        fCmdLineDependencySwitchUsed = fDependencySwitchUsed;
        fCmdLineQuicky = fQuicky;
        fCmdLineSemiQuicky = fSemiQuicky;
        fCmdLineQuickZero = fQuickZero;
        GetEnvParameters( "BUILD_DEFAULT", NULL, &EnvArgc, MAX_ENV_ARG, EnvArgv );
        if (CurrentEnvArgc != EnvArgc) {
            strcat(szXMLBuffer, " BUILD_DEFAULT=\"");
            while (CurrentEnvArgc < EnvArgc) {
                XMLEncodeBuiltInEntitiesCopy(EnvArgv[CurrentEnvArgc], szXMLBuffer + strlen(szXMLBuffer));
                strcat(szXMLBuffer, " ");
                CurrentEnvArgc++;
            }
            strcat(szXMLBuffer, "\"");
        }
        CurrentEnvArgc = EnvArgc;
        GetEnvParameters( "BUILD_OPTIONS", NULL, &EnvArgc, MAX_ENV_ARG, EnvArgv );
        if (CurrentEnvArgc != EnvArgc) {
            strcat(szXMLBuffer, " BUILD_OPTIONS=\"");
            while (CurrentEnvArgc < EnvArgc) {
                XMLEncodeBuiltInEntitiesCopy(EnvArgv[CurrentEnvArgc], szXMLBuffer + strlen(szXMLBuffer));
                strcat(szXMLBuffer, " ");
                CurrentEnvArgc++;
            }
            strcat(szXMLBuffer, "\"");
        }
        if (CountTargetMachines == 0) {
            if ( getenv("PROCESSOR_ARCHITECTURE") == NULL ) {
                BuildError("environment variable PROCESSOR_ARCHITECTURE must be defined\r\n");
                exit(1);
            }

            CurrentEnvArgc = EnvArgc;
            if (!strcmp(getenv("PROCESSOR_ARCHITECTURE"), "IA64"))
                GetEnvParameters( "BUILD_DEFAULT_TARGETS", "-ia64", &EnvArgc, MAX_ENV_ARG, EnvArgv );
            else
                if (!strcmp(getenv("PROCESSOR_ARCHITECTURE"), "AMD64"))
                GetEnvParameters( "BUILD_DEFAULT_TARGETS", "-amd64", &EnvArgc, MAX_ENV_ARG, EnvArgv );
            else
                if (!strcmp(getenv("PROCESSOR_ARCHITECTURE"), "ARM"))
                GetEnvParameters( "BUILD_DEFAULT_TARGETS", "-arm", &EnvArgc, MAX_ENV_ARG, EnvArgv );
            else
                GetEnvParameters( "BUILD_DEFAULT_TARGETS", "-386", &EnvArgc, MAX_ENV_ARG, EnvArgv );
            if (CurrentEnvArgc != EnvArgc) {
                strcat(szXMLBuffer, " BUILD_DEFAULT_TARGETS=\"");
                while (CurrentEnvArgc < EnvArgc) {
                    XMLEncodeBuiltInEntitiesCopy(EnvArgv[CurrentEnvArgc], szXMLBuffer + strlen(szXMLBuffer));
                    strcat(szXMLBuffer, " ");
                    CurrentEnvArgc++;
                }
                strcat(szXMLBuffer, "\"");
            }
        }
        if (!ProcessParameters( EnvArgc, EnvArgv, FALSE )) {
            fUsage = TRUE;
        }
    }
    FreeEnvParameters(EnvArgc, EnvArgv);

    if (!fUsage && !fGenerateObjectsDotMacOnly) {
        if (!_stricmp(BuildProduct, "NT")) {
            if (fCmdLineDependencySwitchUsed) {
                fDependencySwitchUsed = fCmdLineDependencySwitchUsed;
                fQuicky = fCmdLineQuicky;
                fSemiQuicky = fCmdLineSemiQuicky;
                fQuickZero = fCmdLineQuickZero;
            }
            if (!fDependencySwitchUsed) {
                BuildError("(Fatal Error) One of either /D, /Z, /z, or /3 is required for NT builds\r\n");
                exit( 1 );
            } else {
                if (fDependencySwitchUsed == 1) {
                    if (fQuicky) {
                        BuildError("(Fatal Error) switch can not be used with /Z, /z, or /3\r\n");
                        exit( 1 );
                    }
                }
                if (fDependencySwitchUsed == 2) {
                    if (fStopAfterPassZero) {
                        BuildError("(Fatal Error) switch /0 can not be used with /z\r\n");
                        exit( 1 );
                    }
                }
            }
        }
    }

    GetIncludePatterns( "BUILD_ACCEPTABLE_INCLUDES", MAX_INCLUDE_PATTERNS, AcceptableIncludePatternList );
    GetIncludePatterns( "BUILD_UNACCEPTABLE_INCLUDES", MAX_INCLUDE_PATTERNS, UnacceptableIncludePatternList );

    if (( fCheckIncludePaths ) &&
        ( AcceptableIncludePatternList[ 0 ] == NULL ) &&
        ( UnacceptableIncludePatternList[ 0 ] == NULL )) {

        BuildMsgRaw( "WARNING: -# specified without BUILD_[UN]ACCEPTABLE_INCLUDES set\r\n" );
    }

    if (fCleanRestart) {
        if (fClean) {
            fClean = FALSE;
            fRestartClean = TRUE;
        } else
            if (fCleanLibs) {
            fCleanLibs = FALSE;
            fRestartCleanLibs = TRUE;
        } else {
            BuildError("/R switch only valid with /c or /C switch.\r\n");
            fUsage = TRUE;
        }
    }

    NumberProcesses = 1;
    if (fParallel || getenv("BUILD_MULTIPROCESSOR")) {
        SYSTEM_INFO SystemInfo;

        if (DefaultProcesses == 0) {
            GetSystemInfo(&SystemInfo);
            NumberProcesses = SystemInfo.dwNumberOfProcessors;
        } else {
            NumberProcesses = DefaultProcesses;
        }
        if (NumberProcesses == 1) {
            fParallel = FALSE;
        } else {
            if (NumberProcesses > 64) {
                BuildError("(Fatal Error) Number of Processes: %d exceeds max (64)\r\n", NumberProcesses);
                exit(1);
            }
            fParallel = TRUE;
            BuildMsg("Using %d child processes\r\n", NumberProcesses);
        }
    }

    XMLStartTicks = GetTickCount();
    time(&ltime);
    if (fPrintElapsed) {
        BuildColorMsg(COLOR_STATUS, "Start time: %s", ctime(&ltime));
    }

    if (fBuildAltDirSet) {
        BuildColorMsg(COLOR_STATUS, "Object root set to: ==> %s\r\n", szObjDir);
    }

    if (fUsage) {
        BuildMsgRaw(
                   "\r\nBUILD: Version %x.%02x.%04d\r\n\r\n",
                   BUILD_VERSION >> 8,
                   BUILD_VERSION & 0xFF,
                   VER_PRODUCTBUILD);
        BuildMsgRaw(szUsage);
    } else
        if (CountTargetMachines != 0) {
        BuildColorError(COLOR_STATUS,
                        "%s for ",
                        fLinkOnly? "Link" : (fCompileOnly? "Compile" : "Compile and Link"));
        for (i = 0; i < CountTargetMachines; i++) {
            BuildColorErrorRaw(COLOR_STATUS, i==0? "%s" : ", %s", TargetMachines[i]->Description);
            AppendString(
                        MakeTargets,
                        TargetMachines[i]->MakeVariable,
                        TRUE);
        }

        BuildErrorRaw(szNewLine);

        //
        // If there is one and only one build target and target dirs has
        // been enabled, then fill in the appropriate target dirs name.
        //

        if (CountTargetMachines == 1) {
            if (fTargetDirs == TRUE) {
                pszTargetDirs = TargetMachines[0]->TargetDirs;
                FileDesc[0].pszPattern = TargetMachines[0]->TargetDirs;
            }
        }

        if (DEBUG_1) {
            if (CountExcludeIncs) {
                BuildError("Include files that will be excluded:");
                for (i = 0; i < CountExcludeIncs; i++) {
                    BuildErrorRaw(i == 0? " %s" : ", %s", ExcludeIncs[i]);
                }
                BuildErrorRaw(szNewLine);
            }
            if (CountOptionalDirs) {
                BuildError("Optional Directories that will be built:");
                for (i = 0; i < CountOptionalDirs; i++) {
                    BuildErrorRaw(i == 0? " %s" : ", %s", OptionalDirs[i]);
                }
                BuildErrorRaw(szNewLine);
            }
            if (CountExcludeDirs) {
                BuildError("Directories that will be NOT be built:");
                for (i = 0; i < CountExcludeDirs; i++) {
                    BuildErrorRaw(i == 0? " %s" : ", %s", ExcludeDirs[i]);
                }
                BuildErrorRaw(szNewLine);
            }
            BuildMsg("MakeParameters == %s\r\n", MakeParameters);
            BuildMsg("MakeTargets == %s\r\n", MakeTargets);
        }

#if DBG
        fDebugSave = fDebug;
        // fDebug = 0;
#endif

        //
        // Generate the _objects.mac file if requested
        //

        if (fGenerateObjectsDotMacOnly) {
            DIRSUP DirSup;
            ULONG DateTimeSources;

            DirDB = ScanDirectory( CurrentDirectory );

            if (DirDB && (DirDB->DirFlags & (DIRDB_DIRS | DIRDB_SOURCES))) {
                FreeBaselineFile();

                if (!ReadSourcesFile(DirDB, &DirSup, &DateTimeSources)) {
                    BuildError("Current directory not a SOURCES directory.\r\n");
                    return ( 1 );
                }

                GenerateObjectsDotMac(DirDB, &DirSup, DateTimeSources);

                FreeDirSupData(&DirSup);
                ReportDirsUsage();
                FreeCmdStrings();
                ReportMemoryUsage();
                return (0);
            }
        }

        if (!fQuery && fErrorLog) {
            strcat(LogFileName, ".log");
            if (!MyOpenFile(LogDirectory, LogFileName, "wb", &LogFile, TRUE)) {
                BuildError("(Fatal Error) Unable to open log file\r\n");
                exit( 1 );
            }
            CreatedBuildFile(LogDirectory, LogFileName);

            strcat(WrnFileName, ".wrn");
            if (!MyOpenFile(LogDirectory, WrnFileName, "wb", &WrnFile, FALSE)) {
                BuildError("(Fatal Error) Unable to open warning file\r\n");
                exit( 1 );
            }
            CreatedBuildFile(LogDirectory, WrnFileName);

            strcat(ErrFileName, ".err");
            if (!MyOpenFile(LogDirectory, ErrFileName, "wb", &ErrFile, FALSE)) {
                BuildError("(Fatal Error) Unable to open error file\r\n");
                exit( 1 );
            }
            CreatedBuildFile(LogDirectory, ErrFileName);

            if ( fCheckIncludePaths ) {

                strcat( IncFileName, ".inc");
                if (!MyOpenFile( LogDirectory, IncFileName, "wb", &IncFile, FALSE ) ) {
                    BuildError( "(Fatal Error) Unable to open include log file\r\n");
                    exit( 1 );
                }
                CreatedBuildFile( LogDirectory, IncFileName );
            }
        } else {
            LogFile = NULL;
            WrnFile = NULL;
            ErrFile = NULL;
            IncFile = NULL;
        }

        // in case of query only we are not going to produce XML file
        if (fQuery) {
            fXMLOutput = FALSE;
        }

        // set the XML output file
        if (fXMLOutput) {
            strcat(XMLFileName, ".xml");
            if (!MyOpenFile(".", XMLFileName, "wb", &XMLFile, FALSE)) {
                BuildError("(Fatal Error) Unable to open XML file\r\n");
                exit( 1 );
            }
            CreatedBuildFile(".", XMLFileName);
        } else {
            XMLFile = NULL;
        }
        if (!XMLInit()) {
            exit( 1 );
        }

        sprintf(szXMLBuffer + strlen(szXMLBuffer), " TIME=\"%s\" CURRENTDIR=\"%s\"", ctime(&ltime), CurrentDirectory);
        if (fXMLOutput || fXMLFragment) {
            XMLGlobalWrite("<?xml version=\"1.0\"?>");
            XMLGlobalOpenTag("BUILD",  "xmlns=\"x-schema:buildschema.xml\"");
            XMLGlobalWrite("<START %s/>", szXMLBuffer);
            XMLUpdateEndTag(FALSE);
            if (fXMLFragment) {
                XMLWriteFragmentFile("START", "<BUILD %s/>", szXMLBuffer);
            }
        }

        s = getenv("__MTSCRIPT_ENV_ID");
        if (s) {

            if (fDependencySwitchUsed == 2 && fPause) {
                BuildError("Cannot combine -z (or -2) and -p switches under MTScript");
                exit(1);
            }

            // Make sure any other build.exe's that get launched as child
            // processes don't try to connect to the script engine.
            SetEnvironmentVariable("__MTSCRIPT_ENV_ID", NULL);

            g_hMTEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (g_hMTEvent != NULL) {
                g_hMTThread = CreateThread(NULL,
                                           0,
                                           (LPTHREAD_START_ROUTINE)MTScriptThread,
                                           NULL,
                                           0,
                                           &g_dwMTThreadId);

                if (g_hMTThread) {
                    // Wait for the thread to tell us it's ready.
                    WaitForSingleObject(g_hMTEvent, INFINITE);

                    ResetEvent(g_hMTEvent);

                    if (!g_hMTThread) {
                        // An error occurred connecting to the script engine.
                        // We can't continue.
                        BuildError("Unable to connect to script engine. Exiting.");
                        exit(2);
                    }

                    fMTScriptSync = TRUE;
                } else {
                    BuildError("Failed to launch script handling thread! (%d)", GetLastError());

                    CloseHandle(g_hMTEvent);
                    g_hMTEvent = NULL;
                    fPause = FALSE;
                }
            } else {
                BuildError("Failed to create script communication event! (%d)", GetLastError());
                fPause = FALSE;
            }
        }

        //
        // The user should not have CHICAGO_PRODUCT in
        // their environment, as it can cause problems on other machines with
        // other users that don't have them set.  The following warning
        // messages are intended to alert the user to the presence of these
        // environment variables.
        //
        if (getenv("CHICAGO_PRODUCT") != NULL) {
            BuildError("CHICAGO_PRODUCT was detected in the environment.\r\n" );
            BuildMsg("   ALL directories will be built targeting Chicago!\r\n" );
            fChicagoProduct = TRUE;
        }

        if (!fQuicky) {
            LoadMasterDB();

            BuildError("Computing Include file dependencies:\r\n");

            ScanIncludeEnv(SystemIncludeEnv);
            ScanGlobalIncludeDirectory(pszIncMfc);
            ScanGlobalIncludeDirectory(pszIncOak);
            ScanGlobalIncludeDirectory(pszIncDdk);
            ScanGlobalIncludeDirectory(pszIncWdm);
            ScanGlobalIncludeDirectory(pszIncSdk);
            ScanGlobalIncludeDirectory(pszIncPri);
            CountSystemIncludeDirs = CountIncludeDirs;
        }

#if DBG
        fDebug = fDebugSave;
#endif
        fFirstScan = TRUE;
        fPassZero  = FALSE;
        ScanSourceDirectories( CurrentDirectory );

        if (!fQuicky) {
            if (SaveMasterDB() == FALSE) {
                BuildError("Unable to save the dependency database: %s\r\n", DbMasterName);
            }
        }

        c = '\n';
        if ( !fLinkOnly && CountPassZeroDirs && !bBaselineFailure) {
            if (!fQuicky) {
                TotalFilesToCompile = 0;
                TotalLinesToCompile = 0L;

                for (i=0; i<CountPassZeroDirs; i++) {
                    DirDB = PassZeroDirs[ i ];

                    TotalFilesToCompile += DirDB->CountOfPassZeroFiles;
                    TotalLinesToCompile += DirDB->PassZeroLines;
                }

                if (CountPassZeroDirs > 1 &&
                    TotalFilesToCompile != 0 &&
                    TotalLinesToCompile != 0L) {

                    BuildMsgRaw(
                               "Total of %d pass zero files (%s lines) to compile in %d directories\r\n\r\n",
                               TotalFilesToCompile,
                               FormatNumber( TotalLinesToCompile ),
                               CountPassZeroDirs);
                }
            }

            TotalFilesCompiled    = 0;
            TotalLinesCompiled    = 0L;
            ElapsedCompileTime    = 0L;

            if (fPause && !fMTScriptSync) {
                BuildMsg("Press enter to continue with compilations (or 'q' to quit)...");
                c = (char)getchar();
            }

            if ((CountPassZeroDirs > 0) && (c == '\n') && !bBaselineFailure) {
                DWORD dwStartTime = GetTickCount();
                if (fXMLOutput || fXMLFragment) {
                    XMLGlobalOpenTag("PASS", "NUMBER=\"0\"");
                    if (fXMLFragment) {
                        Sleep(1);
                        XMLWriteFragmentFile("PASS0", "<PASS NUMBER=\"0\"/>");
                        Sleep(1);
                    }
                }
                memset(&PassMetrics, 0, sizeof(PassMetrics));
                CompilePassZeroDirectories();
                WaitForParallelThreads(NULL);

                AddBuildMetrics(&BuildMetrics, &PassMetrics);
                if (fXMLOutput || fXMLFragment) {
                    sprintf(szXMLBuffer, "DIRS=\"%d\" ELAPSED=\"%s\" ", CountPassZeroDirs, FormatElapsedTime(dwStartTime));
                    strcat(szXMLBuffer, XMLBuildMetricsString(&PassMetrics));
                    NumberPasses++;
                    XMLGlobalWrite("<PASSSUMMARY %s/>", szXMLBuffer);
                    XMLGlobalCloseTag();
                    XMLUpdateEndTag(FALSE);
                    if (fXMLFragment) {
                        Sleep(1);
                        XMLWriteFragmentFile("PASS0SUMMARY", "<PASSSUMMARY %s/>", szXMLBuffer);
                        Sleep(1);
                    }
                }

                //
                // Rescan now that we've generated all the generated files
                //
                CountPassZeroDirs = 0;
                CountCompileDirs = 0;
                CountLinkDirs = 0;

                UnsnapAllDirectories();
                // This will reset all the producer events which were signalled in Pass0 Phase
                ResetProducerEvents();

                fPassZero = FALSE;
                fFirstScan = FALSE;
                RecurseLevel = 0;

                if (fMTScriptSync) {
                    WaitForResume(fPause, PE_PASS0_COMPLETE);
                    fPauseDone = TRUE;
                }

                // This will compile directories if fQuicky is TRUE
                if (!fStopAfterPassZero) {
                    ScanSourceDirectories( CurrentDirectory );
                }

                if (!fQuicky) {
                    if (SaveMasterDB() == FALSE) {
                        BuildError("Unable to save the dependency database: %s\r\n", DbMasterName);
                    }
                }
            }
        }

        if (fMTScriptSync && !fPauseDone) {
            WaitForResume(fPause, PE_PASS0_COMPLETE);
        }

        if (fStopAfterPassZero) {
            BuildError("Stopping after pass zero requested: Pass0 done.\r\n");
        }


        if (!fStopAfterPassZero && !fLinkOnly && (c == '\n') && !bBaselineFailure) {
            if (!fQuicky) {
                TotalFilesToCompile = 0;
                TotalLinesToCompile = 0L;

                for (i=0; i<CountCompileDirs; i++) {
                    DirDB = CompileDirs[ i ];

                    TotalFilesToCompile += DirDB->CountOfFilesToCompile;
                    TotalLinesToCompile += DirDB->SourceLinesToCompile;
                }

                if (CountCompileDirs > 1 &&
                    TotalFilesToCompile != 0 &&
                    TotalLinesToCompile != 0L) {

                    BuildMsgRaw(
                               "Total of %d source files (%s lines) to compile in %d directories\r\n\r\n",
                               TotalFilesToCompile,
                               FormatNumber( TotalLinesToCompile ),
                               CountCompileDirs);
                }
            }

            TotalFilesCompiled    = 0;
            TotalLinesCompiled    = 0L;
            ElapsedCompileTime    = 0L;

            if (fPause && !fMTScriptSync) {
                BuildMsg("Press enter to continue with compilations (or 'q' to quit)...");
                c = (char)getchar();
            }

            if (c == '\n' && !bBaselineFailure) {
                DWORD dwStartTime = GetTickCount();
                if (fXMLOutput || fXMLFragment) {
                    XMLGlobalOpenTag("PASS", "NUMBER=\"1\"");
                    if (fXMLFragment) {
                        Sleep(1);
                        XMLWriteFragmentFile("PASS1", "<PASS NUMBER=\"1\"/>");
                        Sleep(1);
                    }
                }
                memset(&PassMetrics, 0, sizeof(PassMetrics));
                // Does nothing if fQuicky is TRUE
                CompileSourceDirectories();
                WaitForParallelThreads(NULL);

                AddBuildMetrics(&BuildMetrics, &PassMetrics);
                if (fXMLOutput || fXMLFragment) {
                    sprintf(szXMLBuffer, "DIRS=\"%d\" ELAPSED=\"%s\" ", CountCompileDirs, FormatElapsedTime(dwStartTime));
                    strcat(szXMLBuffer, XMLBuildMetricsString(&PassMetrics));
                    NumberPasses++;
                    XMLGlobalWrite("<PASSSUMMARY %s/>", szXMLBuffer);
                    XMLGlobalCloseTag();
                    XMLUpdateEndTag(FALSE);
                    if (fXMLFragment) {
                        Sleep(1);
                        XMLWriteFragmentFile("PASS1SUMMARY", "<PASSSUMMARY %s/>", szXMLBuffer);
                        Sleep(1);
                    }
                }
            }
        }

        if (fMTScriptSync) {
            WaitForResume(fPause, PE_PASS1_COMPLETE);
        }

        if (!fStopAfterPassZero && !fCompileOnly && (c == '\n') && !bBaselineFailure) {
            DWORD dwStartTime = GetTickCount();
            if (fXMLOutput || fXMLFragment) {
                XMLGlobalOpenTag("PASS", "NUMBER=\"2\"");
                if (fXMLFragment) {
                    Sleep(1);
                    XMLWriteFragmentFile("PASS2", "<PASS NUMBER=\"2\"/>");
                    Sleep(1);
                }
            }
            memset(&PassMetrics, 0, sizeof(PassMetrics));
            LinkSourceDirectories();

            WaitForParallelThreads(NULL);

            AddBuildMetrics(&BuildMetrics, &PassMetrics);
            if (fXMLOutput || fXMLFragment) {
                sprintf(szXMLBuffer, "DIRS=\"%d\" ELAPSED=\"%s\" ", CountLinkDirs, FormatElapsedTime(dwStartTime));
                strcat(szXMLBuffer, XMLBuildMetricsString(&PassMetrics));
                NumberPasses++;
                XMLGlobalWrite("<PASSSUMMARY %s/>", szXMLBuffer);
                XMLGlobalCloseTag();
                XMLUpdateEndTag(FALSE);
                if (fXMLFragment) {
                    Sleep(1);
                    XMLWriteFragmentFile("PASS2SUMMARY", "<PASSSUMMARY %s/>", szXMLBuffer);
                    Sleep(1);
                }
            }
        }

        if (!fStopAfterPassZero && PostBuildCmd && !fMTScriptSync) {
            // If there's a post build process to invoke, do so but only if
            // not running under the buildcon.

            // PostBuildCmd is of the form <message to display><command to execute>
            // The Message is delimiated with curly brackets.  ie:
            // POST_BUILD_PROCESS={Do randomness}randomness.cmd

            // would display:
            //
            //     BUILD: Do randomness
            //
            // while randomness.cmd was running.  The process is run synchronously and
            // we've still got the i/o pipes setup so any output will be logged to
            // build.log (and wrn/err if formated correctly)

            if (*PostBuildCmd == '{') {
                LPSTR PostBuildMessage = PostBuildCmd+1;
                LogMsg("Executing post build scripts %s\r\n", szAsterisks);
                while (*PostBuildCmd && *PostBuildCmd != '}')
                    PostBuildCmd++;

                if (*PostBuildCmd == '}') {
                    *PostBuildCmd = '\0';
                    PostBuildCmd++;
                    BuildMsg("%s\r\n", PostBuildMessage);
                    LogMsg("%s\r\n", PostBuildMessage);
                    ExecuteProgram(PostBuildCmd, "", "", TRUE, CurrentDirectory, "Executing Postbuild Step");
                }
            } else {
                ExecuteProgram(PostBuildCmd, "", "", TRUE, CurrentDirectory, "Executing Postbuild Step");
            }
        }

        if (fShowTree) {
            for (i = 0; i < CountShowDirs; i++) {
                PrintDirDB(ShowDirs[i], 1|4);
            }
        }
    } else {
        BuildError("No target machine specified\r\n");
    }

    // moved the end time before the log files are closed so we can put it into the XML file
    time(&ltime);

    if (fXMLOutput || fXMLFragment) {
        XMLUpdateEndTag(TRUE);
        XMLGlobalCloseTag();    // BUILD
        if (fXMLFragment) {
            sprintf(szXMLBuffer, "TIME=\"%s\" ELAPSED=\"%s\" PASSES=\"%d\" COMPLETED=\"1\" ", ctime(&ltime), FormatElapsedTime(XMLStartTicks), NumberPasses);
            strcat(szXMLBuffer, XMLBuildMetricsString(&BuildMetrics));
            XMLWriteFragmentFile("END", "<END %s/>", szXMLBuffer);
        }
    }

    if (!fUsage && !fQuery && fErrorLog) {
        ULONG cbLogMin = 32;
        ULONG cbWarnMin = 0;

        if (!fAlwaysKeepLogfile) {
            if (fQuicky && !fSemiQuicky && ftell(ErrFile) == 0) {
                cbLogMin = cbWarnMin = ULONG_MAX;
            }
        }
        CloseOrDeleteFile(&LogFile, LogDirectory, LogFileName, cbLogMin);
        CloseOrDeleteFile(&WrnFile, LogDirectory, WrnFileName, cbWarnMin);
        CloseOrDeleteFile(&ErrFile, LogDirectory, ErrFileName, 0L);
        if ( fCheckIncludePaths ) {
            CloseOrDeleteFile(&IncFile, LogDirectory, IncFileName, cbLogMin);
        }
        CloseOrDeleteFile(&XMLFile, LogDirectory, XMLFileName, 0L);
    }

    if (bBaselineFailure) {
        BuildError(BaselinePathName[0] != '\0' ? 
                   "Diffs from baseline\r\n" :
                   "Terminated at the first error encountered\r\n");
    }

    if (fPrintElapsed) {
        BuildColorMsg(COLOR_STATUS, "Finish time: %s", ctime(&ltime));
    }

    BuildColorError(COLOR_STATUS, "Done\r\n\r\n");

    if (fMTScriptSync) {
        WaitForResume(FALSE, PE_PASS2_COMPLETE);
    }

    if (RunningTotals.NumberCompiles) {
        BuildColorMsgRaw(COLOR_SUMMARY, "    %d file%s compiled", RunningTotals.NumberCompiles, RunningTotals.NumberCompiles == 1 ? "" : "s");
        if (RunningTotals.NumberCompileWarnings) {
            BuildColorMsgRaw(COLOR_WARNING, " - %d Warning%s", RunningTotals.NumberCompileWarnings, RunningTotals.NumberCompileWarnings == 1 ? "" : "s");
        }
        if (RunningTotals.NumberCompileErrors) {
            BuildColorMsgRaw(COLOR_ERROR, " - %d Error%s", RunningTotals.NumberCompileErrors, RunningTotals.NumberCompileErrors == 1 ? "" : "s");
        }

        if (ElapsedCompileTime) {
            BuildColorMsgRaw(COLOR_SUMMARY, " - %5ld LPS", TotalLinesCompiled / ElapsedCompileTime);
        }

        BuildMsgRaw(szNewLine);
    }

    if (RunningTotals.NumberLibraries) {
        BuildColorMsgRaw(COLOR_SUMMARY, "    %d librar%s built", RunningTotals.NumberLibraries, RunningTotals.NumberLibraries == 1 ? "y" : "ies");
        if (RunningTotals.NumberLibraryWarnings) {
            BuildColorMsgRaw(COLOR_WARNING, " - %d Warning%s", RunningTotals.NumberLibraryWarnings, RunningTotals.NumberLibraryWarnings == 1 ? "" : "s");
        }
        if (RunningTotals.NumberLibraryErrors) {
            BuildColorMsgRaw(COLOR_ERROR, " - %d Error%s", RunningTotals.NumberLibraryErrors, RunningTotals.NumberLibraryErrors == 1 ? "" : "s");
        }

        BuildMsgRaw(szNewLine);
    }

    if (RunningTotals.NumberLinks) {
        BuildColorMsgRaw(COLOR_SUMMARY, "    %d executable%sbuilt", RunningTotals.NumberLinks, RunningTotals.NumberLinks == 1 ? " " : "s ");
        if (RunningTotals.NumberLinkWarnings) {
            BuildColorMsgRaw(COLOR_WARNING, " - %d Warning%s", RunningTotals.NumberLinkWarnings, RunningTotals.NumberLinkWarnings == 1 ? "" : "s");
        }
        if (RunningTotals.NumberLinkErrors) {
            BuildColorMsgRaw(COLOR_ERROR, " - %d Error%s", RunningTotals.NumberLinkErrors, RunningTotals.NumberLinkErrors == 1 ? "" : "s");
        }

        BuildMsgRaw(szNewLine);
    }

    if (RunningTotals.NumberBSCMakes) {
        BuildColorMsgRaw(COLOR_SUMMARY, "    %d browse database%s built", RunningTotals.NumberBSCMakes, RunningTotals.NumberBSCMakes == 1 ? "" : "s");
        if (RunningTotals.NumberBSCWarnings) {
            BuildColorMsgRaw(COLOR_WARNING, " - %d Warning%s", RunningTotals.NumberBSCWarnings, RunningTotals.NumberBSCWarnings == 1 ? "" : "s");
        }
        if (RunningTotals.NumberBSCErrors) {
            BuildColorMsgRaw(COLOR_ERROR, " - %d Error%s", RunningTotals.NumberBSCErrors, RunningTotals.NumberBSCErrors == 1 ? "" : "s");
        }

        BuildMsgRaw(szNewLine);
    }

    if (RunningTotals.NumberVSToolErrors + RunningTotals.NumberVSToolWarnings > 0) {
        if (RunningTotals.NumberVSToolWarnings) {
            BuildColorMsgRaw(COLOR_WARNING, "    %d VS Tool Warnings\r\n", RunningTotals.NumberVSToolWarnings);
        }
        if (RunningTotals.NumberVSToolErrors) {
            BuildColorMsgRaw(COLOR_ERROR, "    %d VS Tool Errors\r\n", RunningTotals.NumberVSToolErrors);
        }
    }

    if (RunningTotals.NumberBinplaces) {
        BuildColorMsgRaw(COLOR_SUMMARY, "    %d file%sbinplaced", RunningTotals.NumberBinplaces, RunningTotals.NumberBinplaces == 1 ? " " : "s ");
        if (RunningTotals.NumberBinplaceWarnings) {
            BuildColorMsgRaw(COLOR_WARNING, " - %d Warning%s", RunningTotals.NumberBinplaceWarnings, RunningTotals.NumberBinplaceWarnings == 1 ? "" : "s");
        }
        if (RunningTotals.NumberBinplaceErrors) {
            BuildColorMsgRaw(COLOR_ERROR, " - %d Error%s", RunningTotals.NumberBinplaceErrors, RunningTotals.NumberBinplaceErrors == 1 ? "" : "s");
        }
        BuildMsgRaw(szNewLine);
    }

    ReportDirsUsage();
    XMLUnInit();
    FreeBaselineFile();
    FreeCmdStrings();
    FreeIncludePatterns( MAX_INCLUDE_PATTERNS, AcceptableIncludePatternList );
    FreeIncludePatterns( MAX_INCLUDE_PATTERNS, UnacceptableIncludePatternList );
    ReportMemoryUsage();

    ExitMTScriptThread();

    if (bBaselineFailure)
        return 2;

    if (RunningTotals.NumberCompileErrors || 
        RunningTotals.NumberLibraryErrors || 
        RunningTotals.NumberLinkErrors || 
        RunningTotals.NumberBinplaceErrors || 
        RunningTotals.NumberVSToolErrors || 
        fUsage) {
        return 1;
    } else {
        return ( 0 );
    }
}


VOID
ReportDirsUsage( VOID )
{
    ULONG i;
    BOOLEAN fHeaderPrinted;

    if (!fShowUnusedDirs) {
        return;
    }

    fHeaderPrinted = FALSE;
    for (i=0; i<CountOptionalDirs; i++) {
        if (!OptionalDirsUsed[i]) {
            if (!fHeaderPrinted) {
                printf( "Unused BUILD_OPTIONS:" );
                fHeaderPrinted = TRUE;
            }
            printf( " %s", OptionalDirs[i] );
        }
    }

    for (i=0; i<CountExcludeDirs; i++) {
        if (!ExcludeDirsUsed[i]) {
            if (!fHeaderPrinted) {
                printf( "Unused BUILD_OPTIONS:" );
                fHeaderPrinted = TRUE;
            }
            printf( " ~%s", ExcludeDirs[i] );
        }
    }

    if (fHeaderPrinted) {
        printf( "\n" );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SetObjDir
//
//----------------------------------------------------------------------------

VOID
SetObjDir(BOOL fAlternate)
{
    iObjectDir = 0;
    if (fCheckedBuild) {
        if (fAlternate) {
            pszObjDir = szObjDirD;
            pszObjDirSlash = szObjDirSlashD;
            pszObjDirSlashStar = szObjDirSlashStarD;
            iObjectDir = 1;
        } else {
            pszObjDir = szObjDir;
            pszObjDirSlash = szObjDirSlash;
            pszObjDirSlashStar = szObjDirSlashStar;
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   AddTargetMachine
//
//----------------------------------------------------------------------------

VOID
AddTargetMachine(UINT iTarget)
{
    UINT i;

    for (i = 0; i < CountTargetMachines; i++) {
        if (TargetMachines[i] == PossibleTargetMachines[iTarget]) {
            assert(TargetToPossibleTarget[i] == iTarget);
            return;
        }
    }
    assert(CountTargetMachines < MAX_TARGET_MACHINES);
    TargetToPossibleTarget[CountTargetMachines] = iTarget;
    TargetMachines[CountTargetMachines++] = PossibleTargetMachines[iTarget];
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessParameters
//
//----------------------------------------------------------------------------

BOOL
ProcessParameters(
                 int argc,
                 LPSTR argv[],
                 BOOL SkipFirst
                 )
{
    char c, *p;
    int i;
    BOOL Result;

    if (DEBUG_1) {
        BuildMsg("Parsing:");
        for (i=1; i<argc; i++) {
            BuildMsgRaw(" %s", argv[i]);
        }
        BuildMsgRaw(szNewLine);
    }

    Result = TRUE;
    if (SkipFirst) {
        --argc;
        ++argv;
    }
    while (argc) {
        p = *argv;
        if (*p == '/' || *p == '-') {
            if (DEBUG_1) {
                BuildMsg("Processing \"-%s\" switch\r\n", p+1);
            }

            for (i = 0; i < MAX_TARGET_MACHINES; i++) {
                if (!_stricmp(p, PossibleTargetMachines[i]->Switch) ||
                    !_stricmp(p, PossibleTargetMachines[i]->Switch2)) {
                    AddTargetMachine(i);
                    break;
                }
            }

            if (i < MAX_TARGET_MACHINES) {
            } else
                if (!_stricmp(p + 1, "all")) {
                for (i = 0; i < MAX_TARGET_MACHINES; i++) {
                    AddTargetMachine(i);
                }
            } else
                if (!_stricmp(p + 1, "why")) {
                fWhyBuild = TRUE;
            } else
                while (c = *++p)
                    switch (toupper( c )) {
                        case '?':
                            fUsage = TRUE;
                            break;

                        case '$':
                            fDebug += 2;    // yes, I want to *add* 2.
                            break;

                        case '#':
                            fCheckIncludePaths = TRUE;
                            fForce = TRUE;
                            break;

                        case '0':
                            fStopAfterPassZero = TRUE;
                            if (!fDependencySwitchUsed)
                                fDependencySwitchUsed = 3;
                            break;

                        case '1':
                            fQuicky = TRUE;
                            if (!fDependencySwitchUsed)
                                fDependencySwitchUsed = 2;
                            break;

                        case '2':
                            fSemiQuicky = TRUE;
                            fQuicky = TRUE;
                            if (!fDependencySwitchUsed)
                                fDependencySwitchUsed = 2;
                            break;

                        case '3':
                            fQuickZero = TRUE;
                            fSemiQuicky = TRUE;
                            fQuicky = TRUE;
                            if (!fDependencySwitchUsed)
                                fDependencySwitchUsed = 3;
                            break;

                        case 'A':
                            fSyncLink = TRUE;
                            break;

                        case 'B':
                            if (c == 'b') {
                                fFullErrors = TRUE;
                            } else {
                                fErrorBaseline = TRUE;

                                if (--argc) {
                                    ++argv;

                                    if (**argv != '/' && **argv != '-') {
                                        if (ProbeFile(NULL, *argv) != -1) {
                                            CanonicalizePathName(*argv, CANONICALIZE_ONLY, BaselinePathName);
                                            Result = LoadBaselineFile();
                                        } else {
                                            BuildError("The specified baseline file doesn't exist\r\n");
                                            Result = FALSE;
                                        }
                                    } else {
                                        // the next parameter is a switch, reprocess it
                                        --argv;
                                        ++argc;
                                    }
                                } else {
                                    // no more parameters
                                    ++argc;
                                }
                            }
                            break;

                        case 'C':
                            if (!_stricmp( p, "clean" )) {
                                MakeParametersTail = AppendString( MakeParametersTail,
                                                                   "clean",
                                                                   TRUE);
                                *p-- = '\0';
                            } else
                                if (c == 'C') {
                                fCleanLibs = TRUE;
                            } else {
                                fClean = TRUE;
                            }
                            break;

                        case 'D':
                            if (c == 'D') {
                                fDependencySwitchUsed = 1;
                            }
#if DBG
                            else {
                                fDebug |= 1;
                            }
                            break;
#endif
                        case 'E':
                            if (c == 'E') {
                                fAlwaysKeepLogfile = TRUE;
                            }
                            fErrorLog = TRUE;
                            break;

                        case 'F':
                            if (c == 'F') {
                                fAlwaysPrintFullPath = TRUE;
                            } else {
                                fForce = TRUE;
                            }
                            break;

                        case 'G':
                            if (c == 'G')
                                fTargetDirs = TRUE;
                            else
                                fColorConsole = TRUE;
                            break;

                        case 'H':
                            fSuppressOutput = TRUE;

                        case 'I':
                            if (c == 'I') {
                                fNoThreadIndex = TRUE;
                            } else {
                                fSilentDependencies = TRUE;
                            }
                            break;

                        case 'J': {

                                argc--, argv++;

                                if (!_stricmp( p, "jpath" )) {
                                    // Allow BuildConsole to redirect the logfiles
                                    strncpy(LogDirectory, *argv, sizeof(LogDirectory) - 1);
                                    *p-- = '\0';
                                } else {
                                    // Clear it out
                                    memset(LogFileName, 0, sizeof(LogFileName));
                                    memset(WrnFileName, 0, sizeof(WrnFileName));
                                    memset(ErrFileName, 0, sizeof(ErrFileName));
                                    memset(IncFileName, 0, sizeof(IncFileName));
                                    memset(XMLFileName, 0, sizeof(XMLFileName));

                                    // And set it to the arg passed in.
                                    strncpy(LogFileName, *argv, sizeof(LogFileName) - 4);
                                    strncpy(WrnFileName, *argv, sizeof(WrnFileName) - 4);
                                    strncpy(ErrFileName, *argv, sizeof(ErrFileName) - 4);
                                    strncpy(IncFileName, *argv, sizeof(IncFileName) - 4);
                                    strncpy(XMLFileName, *argv, sizeof(XMLFileName) - 4);
                                }
                                break;
                            }

                        case 'K':
                            fKeep = TRUE;
                            break;

                        case 'L':
                            if (c == 'L') {
                                fCompileOnly = TRUE;
                            } else {
                                fLinkOnly = TRUE;
                            }
                            break;

                        case 'M':
                            if (c == 'M') {
                                fParallel = TRUE;
                                if (--argc) {
                                    DefaultProcesses = atoi(*++argv);
                                    if (DefaultProcesses == 0) {
                                        --argv;
                                        ++argc;
                                    }
                                } else {
                                    ++argc;
                                }
                            } else {
                                SetPriorityClass(GetCurrentProcess(),IDLE_PRIORITY_CLASS);
                            }
                            break;

                        case 'N':
                            if (_stricmp( p, "nmake") == 0) {
                                if (--argc) {
                                    ++argv;
                                    MakeParametersTail = AppendString( MakeParametersTail,
                                                                       *argv,
                                                                       TRUE);
                                } else {
                                    argc++;
                                    BuildError("Argument to /NMAKE switch missing\r\n");
                                    Result = FALSE;
                                }
                                *p-- = '\0';
                                break;
                            } else {
                                fIgnoreSync = TRUE;
                            }

                        case 'O':
                            if (c == 'O') {
                                fGenerateObjectsDotMacOnly = TRUE;
                            } else {
                                fShowOutOfDateFiles = TRUE;
                            }
                            break;

                        case 'P':
                            if (c == 'P') {
                                fPrintElapsed = TRUE;
                            } else {
                                fPause = TRUE;
                            }
                            break;

                        case 'Q':
                            fQuery = TRUE;
                            break;

                        case 'R':
                            if (--argc) {
                                fCleanRestart = TRUE;
                                ++argv;
                                CopyString(RestartDir, *argv, TRUE);
                            } else {
                                argc++;
                                BuildError("Argument to /R switch missing\r\n");
                                Result = FALSE;
                            }
                            break;

                        case 'S':
                            fStatus = TRUE;
                            if (c == 'S') {
                                fStatusTree = TRUE;
                            }
                            break;

                        case 'T':
                            fShowTree = TRUE;
                            if (c == 'T') {
                                fShowTreeIncludes = TRUE;
                            }
                            break;

                        case 'U':
                            fShowUnusedDirs = TRUE;
                            break;

                        case 'V':
                            fEnableVersionCheck = TRUE;
                            break;

                        case 'W':
                            fShowWarningsOnScreen = TRUE;
                            break;

                        case 'X':
                            if (!strcmp(p, "Xf")) {
                                // The Xf switch produces XML fragments in a specified directory
                                if (--argc) {
                                    ++argv;
                                    if (!CanonicalizePathName(*argv, CANONICALIZE_DIR, XMLFragmentDirectory)) {
                                        Result = FALSE;
                                    } else {
                                        fXMLFragment = TRUE;
                                    }
                                } else {
                                    ++argc;
                                    BuildError("Argument to /Xf switch missing\r\n");
                                    Result = FALSE;
                                }
                            } else
                                if (c == 'X') {
                                fXMLOutput = TRUE;
                                if (p[1] == 'v' ) {
                                    ++p;
                                    fXMLVerboseOutput = TRUE;
                                }
                            } else {
                                if (--argc) {
                                    ++argv;
                                    if (CountExcludeIncs >= MAX_EXCLUDE_INCS) {
                                        static BOOL fError = FALSE;
                                        if (!fError) {
                                            BuildError(
                                                      "-x argument table overflow, using first %u entries\r\n",
                                                      MAX_EXCLUDE_INCS);
                                            fError = TRUE;
                                        }
                                    } else {
                                        MakeString(
                                                  &ExcludeIncs[CountExcludeIncs++],
                                                  *argv,
                                                  TRUE,
                                                  MT_CMDSTRING);
                                    }
                                } else {
                                    argc++;
                                    BuildError("Argument to /X switch missing\r\n");
                                    Result = FALSE;
                                }
                            }
                            break;

                        case 'Y':
                            fNoisyScan = TRUE;
                            break;

                        case 'Z':
                            fQuickZero = TRUE;
                            fSemiQuicky = TRUE;
                            fQuicky = TRUE;
                            if (!fDependencySwitchUsed)
                                fDependencySwitchUsed = 3;
                            break;

                        default:
                            BuildError("Invalid switch - /%c\r\n", c);
                            Result = FALSE;
                            break;
                    }
        } else
            if (*p == '~') {
            if (CountExcludeDirs >= MAX_EXCLUDE_DIRECTORIES) {
                static BOOL fError = FALSE;

                if (!fError) {
                    BuildError(
                              "Exclude directory table overflow, using first %u entries\r\n",
                              MAX_EXCLUDE_DIRECTORIES);
                    fError = TRUE;
                }
            } else {
                MakeString(
                          &ExcludeDirs[CountExcludeDirs++],
                          p + 1,
                          TRUE,
                          MT_CMDSTRING);
            }
        } else {
            for (i = 0; i < MAX_TARGET_MACHINES; i++) {
                if (!_stricmp(p, PossibleTargetMachines[i]->MakeVariable)) {
                    AddTargetMachine(i);
                    break;
                }
            }
            if (i >= MAX_TARGET_MACHINES) {
                if (iscsym(*p) || *p == '.') {
                    if (CountOptionalDirs >= MAX_OPTIONAL_DIRECTORIES) {
                        static BOOL fError = FALSE;

                        if (!fError) {
                            BuildError(
                                      "Optional directory table overflow, using first %u entries\r\n",
                                      MAX_OPTIONAL_DIRECTORIES);
                            fError = TRUE;
                        }
                    } else {
                        MakeString(
                                  &OptionalDirs[CountOptionalDirs++],
                                  p,
                                  TRUE,
                                  MT_CMDSTRING);
                    }
                } else
                    if (!strcmp(p, "*")) {
                    BuildAllOptionalDirs = TRUE;
                } else {
                    MakeParametersTail = AppendString(
                                                     MakeParametersTail,
                                                     p,
                                                     TRUE);
                }
            }
        }
        --argc;
        ++argv;
    }
    return (Result);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetEnvParameters
//
//----------------------------------------------------------------------------

VOID
GetEnvParameters(
                LPSTR EnvVarName,
                LPSTR DefaultValue,
                int *pargc,
                int maxArgc,
                LPSTR argv[]
                )
{
    LPSTR p, p1, psz;

    if (!(p = getenv(EnvVarName))) {
        if (DefaultValue == NULL) {
            return;
        } else {
            p = DefaultValue;
        }
    } else {
        if (DEBUG_1) {
            BuildMsg("Using %s=%s\r\n", EnvVarName, p);
        }
    }

    MakeString(&psz, p, FALSE, MT_CMDSTRING);
    p1 = psz;
    while (*p1) {
        while (*p1 <= ' ') {
            if (!*p1) {
                break;
            }
            p1++;
        }
        p = p1;
        while (*p > ' ') {
            if (*p == '#') {
                *p = '=';
            }
            p++;
        }
        if (*p) {
            *p++ = '\0';
        }
        MakeString(&argv[*pargc], p1, FALSE, MT_CMDSTRING);
        if ((*pargc += 1) >= maxArgc) {
            BuildError("Too many parameters (> %d)\r\n", maxArgc);
            exit(1);
        }
        p1 = p;
    }
    FreeMem(&psz, MT_CMDSTRING);
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeEnvParameters
//
//----------------------------------------------------------------------------

VOID
FreeEnvParameters(int argc, LPSTR argv[])
{
    while (--argc >= 0) {
        FreeMem(&argv[argc], MT_CMDSTRING);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeCmdStrings
//
//----------------------------------------------------------------------------

VOID
FreeCmdStrings(VOID)
{
#if DBG
    UINT i;

    for (i = 0; i < CountExcludeIncs; i++) {
        FreeMem(&ExcludeIncs[i], MT_CMDSTRING);
    }
    for (i = 0; i < CountOptionalDirs; i++) {
        FreeMem(&OptionalDirs[i], MT_CMDSTRING);
    }
    for (i = 0; i < CountExcludeDirs; i++) {
        FreeMem(&ExcludeDirs[i], MT_CMDSTRING);
    }
    // It's possible the user may have done:
    // <global macro> = <null>

    // in a sources file.  Don't free mem unless it's still set...

    if (pszSdkLibDest)
        FreeMem(&pszSdkLibDest, MT_DIRSTRING);
    if (pszDdkLibDest)
        FreeMem(&pszDdkLibDest, MT_DIRSTRING);
    if (pszPublicInternalPath)
        FreeMem(&pszPublicInternalPath, MT_DIRSTRING);
    if (pszIncOs2)
        FreeMem(&pszIncOs2, MT_DIRSTRING);
    if (pszIncPosix)
        FreeMem(&pszIncPosix, MT_DIRSTRING);
    if (pszIncChicago)
        FreeMem(&pszIncChicago, MT_DIRSTRING);
    if (pszIncMfc)
        FreeMem(&pszIncMfc, MT_DIRSTRING);
    if (pszIncSdk)
        FreeMem(&pszIncSdk, MT_DIRSTRING);
    if (pszIncCrt)
        FreeMem(&pszIncCrt, MT_DIRSTRING);
    if (pszIncOak)
        FreeMem(&pszIncOak, MT_DIRSTRING);
    if (pszIncDdk)
        FreeMem(&pszIncDdk, MT_DIRSTRING);
    if (pszIncWdm)
        FreeMem(&pszIncWdm, MT_DIRSTRING);
    if (pszIncPri)
        FreeMem(&pszIncPri, MT_DIRSTRING);
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   MungePossibleTarget
//
//----------------------------------------------------------------------------

VOID
MungePossibleTarget(
                   PTARGET_MACHINE_INFO pti
                   )
{
    PCHAR s;
    char *pszDir;

    if (!pti) {
        return;
    }

    // save "i386" string

    pszDir = pti->ObjectDirectory[0];

    // Create "$(_OBJ_DIR)\i386" string

    s = malloc(12 + strlen(pszDir) + 1);
    if (!s)
        return;
    sprintf(s, "$(_OBJ_DIR)\\%s", pszDir);
    pti->ObjectMacro = s;

    // Create "obj$(BUILD_ALT_DIR)\i386" string for default obj dir

    s = malloc(strlen(szObjDir) + 1 + strlen(pszDir) + 1);
    if (!s)
        return;
    sprintf(s, "%s\\%s", szObjDir, pszDir);
    pti->ObjectDirectory[0] = s;

    // Create "objd\i386" string for alternate checked obj dir

    s = malloc(strlen(szObjDirD) + 1 + strlen(pszDir) + 1);
    if (!s)
        return;
    sprintf(s, "%s\\%s", szObjDirD, pszDir);
    pti->ObjectDirectory[1] = s;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetIncludePatterns
//
//----------------------------------------------------------------------------

VOID
GetIncludePatterns(
                  LPSTR EnvVarName,
                  int maxArgc,
                  LPSTR argv[]
                  )
{
    LPSTR p, p1, psz;
    int argc;

    argc = 0;

    if ( ( p = getenv(EnvVarName ) ) == NULL ) {
        return;
    }

    MakeString( &psz, p, FALSE, MT_DIRSTRING );

    p1 = psz;
    while ( *p1 ) {
        while ( *p1 == ';' || *p1 == ' ' ) {
            p1++;
        }
        p = p1;
        while ( *p && *p != ';' ) {
            p++;
        }
        if ( *p ) {
            *p++ = '\0';
        }
        MakeString( &argv[argc], p1, FALSE, MT_DIRSTRING );
        if ( ( argc += 1 ) == maxArgc ) {
            BuildError( "Too many include patterns ( > %d)\r\n", maxArgc );
            exit( 1 );
        }

        p1 = p;
    }

    FreeMem(&psz, MT_DIRSTRING);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeIncludePatterns
//
//----------------------------------------------------------------------------

VOID
FreeIncludePatterns(int argc, LPSTR argv[])
{
    while ( argc ) {
        if ( argv[--argc] ) {
            FreeMem( &argv[argc], MT_DIRSTRING );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadBaselineFile
//
//----------------------------------------------------------------------------
BOOL
LoadBaselineFile(VOID)
{
    BOOL Result = FALSE;
    FILE* FBase = NULL;
    long lSize = 0;

    if (BaselinePathName[0] == '\0')
        goto Cleanup;

    if (!MyOpenFile("", BaselinePathName, "rb", &FBase, FALSE))
        goto Cleanup;

    if (fseek(FBase, 0, SEEK_END))
        goto Cleanup;

    if ((lSize = ftell(FBase)) == -1)
        goto Cleanup;

    if (lSize == 0) {
        // if the baseline is zero-length file, do as if it weren't specified
        Result = TRUE;
        BaselinePathName[0] = '\0';
        goto Cleanup;
    }

    if (fseek(FBase, 0, SEEK_SET))
        goto Cleanup;

    if ((pvBaselineContent = malloc(lSize)) == NULL)
        goto Cleanup;

    if (fread(pvBaselineContent, 1, lSize, FBase) != lSize) {
        free(pvBaselineContent);
        pvBaselineContent = NULL;
        goto Cleanup;
    }

    cbBaselineContentSize = (DWORD)lSize;
    Result = TRUE;

    Cleanup:
    if (FBase != NULL)
        fclose(FBase);
    return Result;
}

VOID
FreeBaselineFile(VOID)
{
    if (NULL != pvBaselineContent)
        free(pvBaselineContent);
    pvBaselineContent = NULL;
    cbBaselineContentSize = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   ResetProducerEvents
//				This function sets all the events created by the producers to unsignalled state.
//				This function will be called after  pass0 and pass1
//
//----------------------------------------------------------------------------

VOID
ResetProducerEvents(VOID)
{
    PDEPENDENCY Dependency;
    Dependency = AllDependencies;
    while (Dependency) {
        Dependency->Done = FALSE;
        ResetEvent(Dependency->hEvent);
        Dependency = Dependency->Next;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\buildexe.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       buildexe.c
//
//  Contents:   Functions related to spawning processes and processing
//              their output, using pipes and multiple threads.
//
//  History:    22-May-89     SteveWo  Created
//                 ... see SLM logs
//              26-Jul-94     LyleC    Cleanup/Add Pass0 Support
//
//----------------------------------------------------------------------------

#include "build.h"

#include <fcntl.h>

//+---------------------------------------------------------------------------
//
// Global Data
//
//----------------------------------------------------------------------------

#define DEFAULT_LPS     (fStatusTree? 5000 : 50)

#define LastRow(pts)    ((USHORT) ((pts)->cRowTotal - 1))
#define LastCol(pts)    ((USHORT) ((pts)->cColTotal - 1))

typedef struct _PARALLEL_CHILD {
    PTHREADSTATE ThreadState;
    HANDLE       Event;
    CHAR         ExecuteProgramCmdLine[1024];
} PARALLEL_CHILD, *PPARALLEL_CHILD;

ULONG_PTR StartCompileTime;

DWORD OldConsoleMode;
DWORD NewConsoleMode;

HANDLE *WorkerThreads;
HANDLE *WorkerEvents;
ULONG NumberProcesses;
ULONG ThreadsStarted;

BOOLEAN fConsoleInitialized = FALSE;
BYTE ScreenCell[2];
BYTE StatusCell[2];

#define STATE_UNKNOWN       0
#define STATE_COMPILING     1
#define STATE_ASSEMBLING    2
#define STATE_LIBING        3
#define STATE_LINKING       4
#define STATE_C_PREPROC     5
#define STATE_S_PREPROC     6
#define STATE_PRECOMP       7
#define STATE_MKTYPLIB      8
#define STATE_MIDL          9
#define STATE_MC            10
#define STATE_STATUS        11
#define STATE_BINPLACE      12
#define STATE_VSTOOL        13
#define STATE_ASN           14
#define STATE_PACKING       15
#define STATE_BATCHCOMPILE  16
#define STATE_BSCMAKING     17
#define STATE_CTCOMPILING   18
#define STATE_AUTODOCING    19
#define STATE_DOCCHECKING   20
#define STATE_POSTBUILD   21

#define FLAGS_CXX_FILE              0x0001
#define FLAGS_WARNINGS_ARE_ERRORS   0x0002

LPSTR States[] = {
    "Unknown",                      // 0
    "Compiling",                    // 1
    "Assembling",                   // 2
    "Building Library",             // 3
    "Linking Executable",           // 4
    "Preprocessing",                // 5
    "Assembling",                   // 6
    "Precompiling",                 // 7
    "Building Type Library",        // 8
    "Running MIDL on",              // 9
    "Compiling message file",       // 10
    "Build Status Line",            // 11
    "Binplacing",                   // 12
    "Processing",                   // 13
    "Running ASN Compiler on",      // 14
    "Packing Theme",                // 15
    "Compiling",                    // 16
    "Building Browse File",         // 17
    "CTC Compiling",                // 18
    "Generating Documentation",     // 19
    "Checking Doc Comments",        // 20
    "PostBuild"                     //21
};

//----------------------------------------------------------------------------
//
// Function prototypes
//
//----------------------------------------------------------------------------

VOID
GetScreenSize(THREADSTATE *ThreadState);

VOID
GetCursorPosition(USHORT *pRow, USHORT *pCol, USHORT *pRowTop);

VOID
SetCursorPosition(USHORT Row, USHORT Col);

VOID
WriteConsoleCells(
                 LPSTR String,
                 USHORT StringLength,
                 USHORT Row,
                 USHORT Col,
                 BYTE *Attribute);

VOID
MoveRectangleUp (
                USHORT Top,
                USHORT Left,
                USHORT Bottom,
                USHORT Right,
                USHORT NumRow,
                BYTE  *FillCell);

VOID
ReadConsoleCells(
                BYTE *pScreenCell,
                USHORT cb,
                USHORT Row,
                USHORT Column);

VOID
ClearRows(
         PTHREADSTATE ThreadState,
         USHORT Top,
         USHORT NumRows,
         PBYTE  Cell
         );

LPSTR
IsolateFirstToken(
                 LPSTR *pp,
                 CHAR delim
                 );

LPSTR
IsolateLastToken(
                LPSTR p,
                CHAR delim
                );

DWORD
ParallelChildStart(
                  PPARALLEL_CHILD Data
                  );

DWORD
PipeSpawnClose (
               FILE *pstream
               );

FILE *
PipeSpawn (
          const CHAR *cmdstring
          );

BOOL
DetermineChildState(
                   PTHREADSTATE ThreadState,
                   LPSTR p
                   );

void
PrintChildState(
               PTHREADSTATE ThreadState,
               LPSTR p,
               PFILEREC FileDB
               );

BOOL
CoffFilter(
          PTHREADSTATE ThreadState,
          LPSTR p
          );

//+---------------------------------------------------------------------------
//
//  Function:   RestoreConsoleMode
//
//----------------------------------------------------------------------------

VOID
RestoreConsoleMode(VOID)
{
    SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), OldConsoleMode);
    NewConsoleMode = OldConsoleMode;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsolateFirstToken
//
//  Synopsis:   Returns the first token in a string.
//
//  Arguments:  [pp]    -- String to parse
//              [delim] -- Token delimiter
//
//  Returns:    Pointer to first token
//
//  Notes:      Leading spaces are ignored.
//
//----------------------------------------------------------------------------

LPSTR
IsolateFirstToken(
                 LPSTR *pp,
                 CHAR delim
                 )
{
    LPSTR p, Result;

    p = *pp;
    while (*p <= ' ') {
        if (!*p) {
            *pp = p;
            return ( "" );
        } else
            p++;
    }

    Result = p;
    while (*p) {
        if (*p == delim) {
            *p++ = '\0';
            break;
        } else {
            p++;
        }
    }
    *pp = p;
    if (*Result == '\0')    // don't overrun the buffer
        return ( Result );

    if (*Result == '.' && Result[1] == '\\') {
        return ( Result+2 );
    } else {
        return ( Result );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   IsolateLastToken
//
//  Synopsis:   Return the last token in a string.
//
//  Arguments:  [p]     -- String to parse
//              [delim] -- Token delimiter
//
//  Returns:    Pointer to last token
//
//  Notes:      Trailing spaces are skipped.
//
//----------------------------------------------------------------------------

LPSTR
IsolateLastToken(
                LPSTR p,
                CHAR delim
                )
{
    LPSTR Start;

    Start = p;
    while (*p) {
        p++;
    }

    while (--p > Start) {
        if (*p <= ' ' || *p == ':') {
            *p = '\0';
        } else
            break;
    }

    while (p > Start) {
        if (*--p == delim) {
            p++;
            break;
        }
    }

    if (*p == '.' && p[1] == '\\') {
        return ( p+2 );
    } else {
        return ( p );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   TestPrefix
//
//  Synopsis:   Returns TRUE if [Prefix] is the first part of [pp]
//
//----------------------------------------------------------------------------

BOOL
TestPrefix(
          LPSTR  *pp,
          LPSTR Prefix
          )
{
    LPSTR p = *pp;
    UINT cb;

    if (!_strnicmp( p, Prefix, cb = strlen( Prefix ) )) {
        *pp = p + cb;
        return ( TRUE );
    } else {
        return ( FALSE );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   TestPrefixPath
//
//  Synopsis:   Returns TRUE if [Prefix] is the first part of [pp]
//              If the firstpart of [pp] (excluding whitespace) contains
//              backslashes, then only the right-most component is used
//
//----------------------------------------------------------------------------

BOOL
TestPrefixPath(
              LPSTR  *pp,
              LPSTR Prefix
              )
{
    LPSTR p = *pp;
    UINT cb;
    LPSTR PathString;
    INT PathStringLength ;
    LPSTR LastComp ;

    cb = strlen( Prefix );

    if (_strnicmp( p, Prefix, cb ) == 0 ) {
        *pp = p + cb;
        return ( TRUE );
    } else {
        PathString = strchr( p, ' ' );

        if ( PathString ) {
            PathStringLength = (INT) (PathString - p) ;

            *PathString = '\0';

            LastComp = strrchr( p, '\\' );

            *PathString = ' ';

            // Do we have backslashes (ie: a full path name to the tool name)?
            if ( LastComp ) {

                // Advance past the path.
                p = LastComp + 1;

                if ( _strnicmp( p, Prefix, cb ) == 0 ) {
                    *pp = p + cb ;
                    return ( TRUE );
                }
            }
        }

        return ( FALSE );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   Substr
//
//----------------------------------------------------------------------------

BOOL
Substr(
      LPSTR s,
      LPSTR p
      )
{
    LPSTR x;

    while (*p) {
        x = s;
        while (*p++ == *x) {
            if (*x == '\0') {
                return ( TRUE );
            }
            x++;
        }
        if (*x == '\0') {
            return ( TRUE );
        }
    }
    return ( FALSE );
}



//+---------------------------------------------------------------------------
//
//  Function:   WriteTTY
//
//  Synopsis:   Writes the given string to the output device.
//
//  Arguments:  [ThreadState]   -- Struct containing info about the output dev.
//              [p]             -- String to display
//              [fStatusOutput] -- If TRUE then put on the status line.
//
//----------------------------------------------------------------------------

VOID
WriteTTY (THREADSTATE *ThreadState, LPSTR p, BOOL fStatusOutput)
{
    USHORT SaveRow;
    USHORT SaveCol;
    USHORT SaveRowTop;
    USHORT cb, cbT;
    PBYTE Attribute;
    BOOL ForceNewline;

    if (fSuppressOutput)
        return;

    //
    // If we're not writing to the screen then don't do anything fancy, just
    // output the string.
    //

    if (!fStatus || !ThreadState->IsStdErrTty) {
        while (TRUE) {
            int cch;

            cch = strcspn(p, "\r");
            if (cch != 0) {
                fwrite(p, 1, cch, stderr);
                p += cch;
            }
            if (*p == '\0') {
                break;
            }
            if (p[1] != '\n') {
                fwrite(p, 1, 1, stderr);
            }
            p++;
        }
        fflush(stderr);
        return;
    }

    assert(ThreadState->cColTotal != 0);
    assert(ThreadState->cRowTotal != 0);

    //
    // Scroll as necessary
    //
    GetCursorPosition(&SaveRow, &SaveCol, &SaveRowTop);

    //  During processing, there might be N threads that are displaying
    //  messages and a single thread displaying directory-level
    //  linking and building messages.  We need to make sure there's room for
    //  the single thread's message as well as ours.  Since that single
    //  thread displays one line at a time (including CRLF) we must make sure
    //  that his display (as well as ours) doesn't inadvertantly scroll
    //  the status line at the top.  We do this by guaranteeing that there is
    //  a blank line at the end.


    //  We are synchronized with the single top-level thread
    //  at a higher level than this routine via TTYCriticalSection.  We
    //  are, thus, assured that we control the cursor completely.


    //  Stay off the LastRow
    if (SaveRow == LastRow(ThreadState)) {
        USHORT RowTop = 2;

        if (fStatus) {
            RowTop += SaveRowTop + (USHORT) NumberProcesses + 1;
        }

        MoveRectangleUp (
                        RowTop,                     // Top
                        0,                          // Left
                        LastRow(ThreadState),       // Bottom
                        LastCol(ThreadState),       // Right
                        2,                          // NumRow
                        ScreenCell);                // FillCell

        SaveRow -= 2;
        SetCursorPosition(SaveRow, SaveCol);
    }

    //
    // Different color for the status line.
    //
    if (fStatusOutput) {
        Attribute = &StatusCell[1];
    } else {
        Attribute = &ScreenCell[1];
    }
    cb = (USHORT) strlen(p);

    //
    // Write out the string.
    //
    while (cb > 0) {
        ForceNewline = FALSE;

        if (cb > 1) {
            if (p[cb - 1] == '\n' && p[cb - 2] == '\r') {
                cb -= 2;
                ForceNewline = TRUE;
            }
        }

        if (cb >= ThreadState->cColTotal - SaveCol) {
            cbT = ThreadState->cColTotal - SaveCol;
            if (fFullErrors)
                ForceNewline = TRUE;
        } else {
            cbT = cb;
        }

        WriteConsoleCells(p, cbT, SaveRow, SaveCol, Attribute);
        SetCursorPosition(SaveRow, SaveCol);

        if (ForceNewline) {
            SaveCol = 0;
            SaveRow++;
        } else {
            SaveCol += cbT;
        }

        if (!fFullErrors) {
            break;
        }

        if (cb > cbT) {
            // we have more to go... do a newline

            //  If we're back at the beginning of the bottom line
            if (SaveRow == LastRow(ThreadState)) {
                USHORT RowTop = 1;

                if (fStatus) {
                    RowTop += SaveRowTop + (USHORT) NumberProcesses + 1;
                }

                // move window up one line (leaving two lines blank at bottom)
                MoveRectangleUp (
                                RowTop,                     // Top
                                0,                          // Left
                                LastRow(ThreadState),       // Bottom
                                LastCol(ThreadState),       // Right
                                1,                          // NumRow
                                ScreenCell);                // FillCell

                SaveRow--;
            }
            SetCursorPosition(SaveRow, SaveCol);
        }

        cb -= cbT;
        p += cbT;
    }

    SetCursorPosition(SaveRow, SaveCol);
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteTTYLoggingErrors
//
//  Synopsis:   Writes a message to the appropriate log file and also the
//              screen if specified.
//
//  Arguments:  [Warning]     -- TRUE if the message is a warning
//              [ThreadState] -- Info about output device
//              [p]           -- String
//
//----------------------------------------------------------------------------

VOID
WriteTTYLoggingErrors(
                     BOOL Warning,
                     PTHREADSTATE ThreadState,
                     LPSTR p
                     )
{
    UINT cb;
    cb = strlen( p );

    // ignore empty strings
    if (0 == cb)
        return;

    if (fErrorLog) {
        fwrite( p, 1, cb, Warning ? WrnFile : ErrFile );
    }
    if (fShowWarningsOnScreen && Warning) {
        WriteTTY(ThreadState, p, FALSE);
        return;
    }
    if (!fErrorLog || !Warning) {
        WriteTTY(ThreadState, p, FALSE);
    }

    if (!Warning && fErrorBaseline && !bBaselineFailure) {
        // don't check for a new failure if there is already one

        if (NULL == pvBaselineContent || NULL == memfind(pvBaselineContent, cbBaselineContentSize, p, cb)) {
            // if there is no baseline file, or if the error is not found, we have new failure
            bBaselineFailure = TRUE;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   RuntimeErrorFilter
//
//  Synopsis:   Filters output from the compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//                               (compiling, linking, etc...)
//              [p]           -- Message we're trying to parse.
//              [FileName]    -- [out] Filename in message
//              [LineNumber]  -- [out] Line number in message
//              [Message]     -- [out] Message number (for post processing)
//              [Warning]     -- [out] TRUE if message is a warning.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    26-Jul-94     sbonev    Created
//
//  Notes:
//
//      This routine filters strings that are not standard tool output.
//      Any unexpected error checking should go here
//
//----------------------------------------------------------------------------

BOOL
RuntimeErrorFilter(
                  PTHREADSTATE ThreadState,
                  LPSTR p,
                  LPSTR *FileName,
                  LPSTR *LineNumber,
                  LPSTR *Message,
                  BOOL *Warning
                  )
{
    if (strstr(p, "Exception occured:")) {
        *FileName = NULL;
        *LineNumber = NULL;
        *Message = p;
        *Warning = FALSE;

        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   MsCompilerFilter
//
//  Synopsis:   Filters output from the compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//                               (compiling, linking, etc...)
//              [p]           -- Message we're trying to parse.
//              [FileName]    -- [out] Filename in message
//              [LineNumber]  -- [out] Line number in message
//              [Message]     -- [out] Message number (for post processing)
//              [Warning]     -- [out] TRUE if message is a warning.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    26-Jul-94     LyleC    Created
//
//  Notes:
//
//    This routine filters strings in the MS compiler format.  That is:
//
//       {toolname} : {number}: {text}
//
//    where:
//
//        toolname    If possible, the container and specific module that has
//                    the error.  For instance, the compiler uses
//                    filename(linenum), the linker uses library(objname), etc.
//                    If unable to provide a container, use the tool name.
//        number      A number, prefixed with some tool identifier (C for
//                    compiler, LNK for linker, LIB for librarian, N for nmake,
//                    etc).
//        test        The descriptive text of the message/error.
//
//        Accepted String formats are:
//
//        container(module): error/warning NUM ...
//        container(module) : error/warning NUM ...
//        container (module): error/warning NUM ...
//        container (module) : error/warning NUM ...
//
//----------------------------------------------------------------------------

BOOL
MsCompilerFilter(
                PTHREADSTATE ThreadState,
                LPSTR p,
                LPSTR *FileName,
                LPSTR *LineNumber,
                LPSTR *Message,
                BOOL *Warning
                )
{
    LPSTR p1;
    BOOL fCommandLineWarning;

    *Message = NULL;

    p1 = p;

    if (strstr(p, "see declaration of"))
        goto notRecognized;

    if (strstr(p, "see previous definition of"))
        goto notRecognized;

    if (strstr(p, "while compiling class-template member function"))
        goto notRecognized;

    if (strstr(p, "see reference to function template instantiation"))
        goto notRecognized;

    if (strstr(p, "Compiler error (")) {
        *Message = p;
        *Warning = FALSE;
        if ((p1 = strstr( p, "source=" )))
            *LineNumber = p1+7;
        else
            *LineNumber = "1";
        *FileName = ThreadState->ChildCurrentFile;
        return TRUE;
    }

    if (!strncmp(p, "fatal error ", strlen("fatal error "))) {
        *Message = p;
        *Warning = FALSE;
        *LineNumber = "1";
        *FileName = ThreadState->ChildCurrentFile;
        return TRUE;
    } else if (!strncmp(p, "error ", strlen("error "))) {
        // Takes care of some C# error messages.
        *Message = p+strlen("error ");
        *Warning = FALSE;
        *LineNumber = "0";
        *FileName = ThreadState->ChildCurrentFile;
        return TRUE;
    }

    // First look for the " : " or "): " sequence.

    while (*p1) {
        if ((p1[0] == ')') && (p1[1] == ' ')) p1++;

        if ((p1[0] == ' ') || (p1[0] == ')')) {
            if (p1[1] == ':') {
                if (p1[2] == ' ') {
                    *Message = p1 + 3;
                    *p1 = '\0';

                    break;
                } else
                    break;   // No sense going any further
            } else if ((p1[0] == ' ') && (p1[1] == '('))
                p1++;
            else
                break;   // No sense going any further
        } else
            p1++;
    }

    if (*Message != NULL) {
        // then figure out if this is an error or warning.

        *Warning = TRUE;        // Assume the best.
        fCommandLineWarning = FALSE;

        if (TestPrefix( Message, "error " ) ||
            TestPrefix( Message, "fatal error " ) ||
            TestPrefix( Message, "command line error " ) ||
            TestPrefix( Message, "Compiler error " )) {
            *Warning = FALSE;
        } else
            if (TestPrefix( Message, "warning " )) {
            *Warning = TRUE;
        } else
            if (TestPrefix( Message, "command line warning " )) {
            // Command-line warnings don't count when considering whether
            // warnings should be errors (under /WX).
            *Warning = TRUE;
            fCommandLineWarning = TRUE;
        } else
            if (TestPrefix( Message, "LNK6" )) {
            // Linker notes should be ignored.
            return (FALSE);
        }

        if (!fCommandLineWarning && (ThreadState->ChildFlags & FLAGS_WARNINGS_ARE_ERRORS) != 0) {
            if (Substr( "X0000", *Message )) {
                *Warning = TRUE;   // Special case this one. Never an error
            } else {
                *Warning = FALSE;  // Warnings treated as errors for this compile
            }
        }

        // Set the container name and look for the module paren's

        *FileName = p;
        *LineNumber = NULL;

        p1 = p;

        while (*p1) {
            if (*p1 == '(' && p1[1] != ')') {
                *p1 = '\0';
                p1++;
                *LineNumber = p1;
                while (*p1) {
                    if (*p1 == ')') {
                        *p1 = '\0';
                        break;
                    }
                    p1++;
                }

                break;
            }

            p1++;
        }

        return (TRUE);
    }

    notRecognized:
    return RuntimeErrorFilter(ThreadState, p, FileName, LineNumber, Message, Warning);

}


//+---------------------------------------------------------------------------
//
//  Function:   FormatMsErrorMessage
//
//  Synopsis:   Take the information obtained from MsCompilerFilter,
//              reconstruct the error message, and print it to the screen.
//
//----------------------------------------------------------------------------

VOID
FormatMsErrorMessage(
                    PTHREADSTATE ThreadState,
                    LPSTR FileName,
                    LPSTR LineNumber,
                    LPSTR Message,
                    BOOL Warning
                    )
{
    char *DirectoryToUse;
    SIZE_T BufferUsed, BufferLen;
    LPSTR pszBuffer;

    if (fColorConsole) {
        if (Warning)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), COLOR_WARNING);
        else
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), COLOR_ERROR);
    }

    if (ThreadState->ChildState == STATE_LIBING) {
        if (Warning) {
            RunningTotals.NumberLibraryWarnings++;
            ThreadState->BuildMetrics.NumberLibraryWarnings++;
        } else {
            RunningTotals.NumberLibraryErrors++;
            ThreadState->BuildMetrics.NumberLibraryErrors++;
        }
    }

    else
        if ((ThreadState->ChildState == STATE_LINKING) ||
            (ThreadState->ChildState == STATE_BINPLACE)) {
        if (Warning) {
            RunningTotals.NumberLinkWarnings++;
            ThreadState->BuildMetrics.NumberLinkWarnings++;
        } else {
            RunningTotals.NumberLinkErrors++;
            ThreadState->BuildMetrics.NumberLinkErrors++;
        }
    } else {
        if (Warning) {
            RunningTotals.NumberCompileWarnings++;
            ThreadState->BuildMetrics.NumberCompileWarnings++;
        } else {
            RunningTotals.NumberCompileErrors++;
            ThreadState->BuildMetrics.NumberCompileErrors++;
            if (ThreadState->CompileDirDB) {
                ThreadState->CompileDirDB->DirFlags |= DIRDB_COMPILEERRORS;
            }
        }
    }

    // start filling up the buffer for the XML log file; 
    // however, we are going to use the same buffer even if no XML log is requested
    // safe to use - it is protected by the TTY critical section
    ZeroMemory(szXMLBuffer, sizeof(szXMLBuffer));
    pszBuffer = szXMLBuffer;
    BufferUsed = 0;
    BufferLen = sizeof(szXMLBuffer) - 1;

    if (fParallel && !fNoThreadIndex ) {
        BufferUsed = _snprintf(pszBuffer, BufferLen, "%d>", ThreadState->ThreadIndex);
        pszBuffer += BufferUsed;
        BufferLen -= BufferUsed;
    }

    if (FileName) {
        DirectoryToUse = ThreadState->ChildCurrentDirectory;

        if (TestPrefix( &FileName, CurrentDirectory )) {
            DirectoryToUse = CurrentDirectory;
            if (*FileName == '\\') {
                FileName++;
            }
        }

        if (TestPrefix( &FileName, ThreadState->ChildCurrentDirectory )) {
            DirectoryToUse = ThreadState->ChildCurrentDirectory;
            if (*FileName == '\\') {
                FileName++;
            }
        }

        // check for some special cases when the FileName is actually the tool name
        // and should not be prepended with path

        if (ThreadState->FilterProc == CoffFilter && _stricmp(FileName, "link") == 0 ||
            ThreadState->FilterProc == CoffFilter && _stricmp(FileName, "lib") == 0) {
            BufferUsed = strlen(strncat(pszBuffer, FileName, BufferLen));
        } else {
            BufferUsed = strlen(strncat(pszBuffer, FormatPathName( DirectoryToUse, FileName), BufferLen));
        }
        pszBuffer += BufferUsed;
        BufferLen -= BufferUsed;
    }

    if (LineNumber && strlen(LineNumber) > 0) {
        BufferUsed = _snprintf(pszBuffer, BufferLen, "(%s)%s", LineNumber, FileName && strlen(FileName) ? " : " : "");
        pszBuffer += BufferUsed;
        BufferLen -= BufferUsed;
    }

    _snprintf(pszBuffer, BufferLen, "%s %s", Warning ? "warning" : "error", Message);

    if (Warning) {
        ThreadState->BuildMetrics.NumberActWarnings++;
    } else {
        ThreadState->BuildMetrics.NumberActErrors++;
    }

    WriteTTYLoggingErrors( Warning, ThreadState, szXMLBuffer);
    WriteTTYLoggingErrors( Warning, ThreadState, "\r\n" );

    if (fXMLOutput || fXMLFragment) {
        XMLThreadWrite(ThreadState, "<%s MESSAGE=\"%s\"/>", Warning ? "WARNING" : "ERROR", XMLEncodeBuiltInEntities(szXMLBuffer, sizeof(szXMLBuffer)));
    }

    if (fColorConsole)
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), DefaultConsoleAttributes);
}


//+---------------------------------------------------------------------------
//
//  Function:   PassThrough
//
//  Synopsis:   Keep track of and print the given message without any
//              filtering.
//
//  Arguments:  [ThreadState] --
//              [p]           -- Message
//              [Warning]     -- TRUE if warning
//
//  Returns:    FALSE
//
//----------------------------------------------------------------------------

BOOL
PassThrough(
           PTHREADSTATE ThreadState,
           LPSTR p,
           BOOL Warning
           )
{
    if (fColorConsole) {
        if (Warning)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), COLOR_WARNING);
        else
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), COLOR_ERROR);
    }

    if (ThreadState->ChildState == STATE_VSTOOL) {
        if (Warning) {
            RunningTotals.NumberVSToolWarnings++;
            ThreadState->BuildMetrics.NumberVSToolWarnings++;
        } else {
            RunningTotals.NumberVSToolErrors++;
            ThreadState->BuildMetrics.NumberVSToolErrors++;
        }
    } else
        if (ThreadState->ChildState == STATE_LIBING) {
        if (Warning) {
            RunningTotals.NumberLibraryWarnings++;
            ThreadState->BuildMetrics.NumberLibraryWarnings++;
        } else {
            RunningTotals.NumberLibraryErrors++;
            ThreadState->BuildMetrics.NumberLibraryErrors++;
        }
    } else
        if (ThreadState->ChildState == STATE_LINKING) {
        if (Warning) {
            RunningTotals.NumberLinkWarnings++;
            ThreadState->BuildMetrics.NumberLinkWarnings++;
        } else {
            RunningTotals.NumberLinkErrors++;
            ThreadState->BuildMetrics.NumberLinkErrors++;
        }
    } else
        if (ThreadState->ChildState == STATE_BINPLACE) {
        if (Warning) {
            RunningTotals.NumberBinplaceWarnings++;
            ThreadState->BuildMetrics.NumberBinplaceWarnings++;
        } else {
            RunningTotals.NumberBinplaceErrors++;
            ThreadState->BuildMetrics.NumberBinplaceErrors++;
        }
    } else {
        if (Warning) {
            RunningTotals.NumberCompileWarnings++;
            ThreadState->BuildMetrics.NumberCompileWarnings++;
        } else {
            RunningTotals.NumberCompileErrors++;
            ThreadState->BuildMetrics.NumberCompileErrors++;
            if (ThreadState->CompileDirDB) {
                ThreadState->CompileDirDB->DirFlags |= DIRDB_COMPILEERRORS;
            }
        }
    }

    // safe to use. it is protected by the TTY critical section
    ZeroMemory(szXMLBuffer, sizeof(szXMLBuffer));

    if (fParallel && !fNoThreadIndex) {
        _snprintf(szXMLBuffer, sizeof(szXMLBuffer)-1, "%d>%s", ThreadState->ThreadIndex, p);
    } else {
        strncpy(szXMLBuffer, p, sizeof(szXMLBuffer)-1);
    }

    if (Warning) {
        ThreadState->BuildMetrics.NumberActWarnings++;
    } else {
        ThreadState->BuildMetrics.NumberActErrors++;
    }

    WriteTTYLoggingErrors( Warning, ThreadState, szXMLBuffer );
    WriteTTYLoggingErrors( Warning, ThreadState, "\r\n" );

    if (fXMLOutput || fXMLFragment) {
        XMLThreadWrite(ThreadState, "<%s MESSAGE=\"%s\"/>", Warning ? "WARNING" : "ERROR", XMLEncodeBuiltInEntities(szXMLBuffer, sizeof(szXMLBuffer)));
    }

    if (fColorConsole)
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), DefaultConsoleAttributes);

    return ( FALSE );
}


//+---------------------------------------------------------------------------
//
//  Function:   PassThroughFilter
//
//  Synopsis:   Straight pass-through filter for compiler messages
//
//----------------------------------------------------------------------------

BOOL
PassThroughFilter(
                 PTHREADSTATE ThreadState,
                 LPSTR p
                 )
{
    return PassThrough( ThreadState, p, FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   NMakeFilter
//
//  Synopsis:   Filters output from NMAKE so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the build
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    10-Jun-99     patbr  Created
//
//----------------------------------------------------------------------------

BOOL
NMakeFilter(
           PTHREADSTATE ThreadState,
           LPSTR p
           )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning)) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning);
        return ( TRUE );
    } else {
        return ( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   BisonFilter
//
//  Synopsis:   Filters output from the bison compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//                               (compiling, linking, etc...)
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    04-Oct-99     TomSe    Created
//
//  Notes:
//
//    This routine filters strings in the bison compiler format.  That is:
//
//        Accepted String formats are:
//
//        ("myfile.y", line 3) error: unknown character: #
//        "myfile.y", line 83: no input grammar
//        vapi.y contains 1 useless nonterminal and 1 useless rule
//
//----------------------------------------------------------------------------

BOOL
BisonFilter(
           PTHREADSTATE ThreadState,
           LPSTR p
           )
{
    LPSTR FileName = NULL;
    LPSTR LineNumber = NULL;
    LPSTR Message = NULL;
    BOOL Warning = TRUE;

    // First colon marks beginnning of message.
    LPSTR p1 = strchr(p,':');

    if (p1) {
        Message = p1 + 1;
        *p1 = '\0';

        // Get filename, line number.
        p1 = p;

        do {
            Warning = FALSE;

            // Skip (.
            if ( '(' == *p1 ) {
                p1++;
            }

            // Skip over leading quote in filename.
            if ( '"' != *p1 ) {
                // Unexpected format.
                break;
            }
            p1++;

            FileName = p1;

            // Look for trailing quote in filename.
            p1 = strchr( p1, '"');
            if (NULL==p1) {
                // Unexpected format.
                FileName = NULL;
                break;
            }

            *p1 = '\0';

            p1++;

            if (0 !=strncmp( p1, ", line ", 7)) {
                // Unexpected format.
                FileName = NULL;
                break;
            }
            p1 += 7;

            LineNumber = p1;

            while (isdigit(*p1)) {
                p1++;
            }

            *p1 = '\0';
        }
        while (0);
    } else {
        // Take whole string as message if no colon is found.
        Message = p;
    }

    if (NULL==FileName) {
        FileName = ThreadState->ChildCurrentFile;
    }

    FormatMsErrorMessage( ThreadState,
                          FileName, LineNumber, Message, Warning );

    // This was a warning or error.
    return TRUE ;
}



//+---------------------------------------------------------------------------
//
//  Function:   C510Filter
//
//  Synopsis:   Compiler filter which strips out unwanted warnings.
//
//  Arguments:  [ThreadState] --
//              [p]           --
//
//----------------------------------------------------------------------------

BOOL
C510Filter(
          PTHREADSTATE ThreadState,
          LPSTR p
          )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;
    LPSTR t;
    PFILEREC FileDB;

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning
                        )
       ) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return ( TRUE );
    } else {

        // If we're compiling, then the compiler spits out various bit of info,
        // namely:
        //      1. filename alone on a line (.c, .cpp, .cxx)
        //      2. "Generating Code..." when the back-end is invoked
        //      3. "Compiling..." when the front-end is invoked again

        if (ThreadState->ChildState == STATE_COMPILING) {

            if (0 == strcmp(p, "Generating Code...")) {

                strcpy( ThreadState->ChildCurrentFile, "Generating Code..." );
                PrintChildState(ThreadState, p, NULL);
                return FALSE;
            }

            t = strrchr(p, '.');
            if (t != NULL &&
                (0 == strcmp(t, ".cxx") ||
                 0 == strcmp(t, ".cpp") ||
                 0 == strcmp(t, ".c"))) {

                strcpy( ThreadState->ChildCurrentFile, IsolateLastToken(p, ' '));
//                strcpy(ThreadState->ChildCurrentFile, p);
                if (strstr(ThreadState->ChildCurrentFile, ".cxx") ||
                    strstr(ThreadState->ChildCurrentFile, ".cpp")) {
                    ThreadState->ChildFlags |= FLAGS_CXX_FILE;
                } else {
                    ThreadState->ChildFlags &= ~FLAGS_CXX_FILE;
                }

                FileDB = NULL;
                if (ThreadState->CompileDirDB) {
                    RunningTotals.NumberCompiles++;
                    ThreadState->BuildMetrics.NumberCompileWarnings++;
                    CopyString(                         // fixup path string
                                                        ThreadState->ChildCurrentFile,
                                                        ThreadState->ChildCurrentFile,
                                                        TRUE);

                    if (!fQuicky) {
                        FileDB = FindSourceFileDB(
                                                 ThreadState->CompileDirDB,
                                                 ThreadState->ChildCurrentFile,
                                                 NULL);
                    }
                }

                PrintChildState(ThreadState, p, FileDB);
                return FALSE;
            }
        }

        return ( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MSBCFilter
//
//  Synopsis:   Filters output from the Basic compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    08-Dec-09     marioch  Created
//
//----------------------------------------------------------------------------

BOOL
MSBCFilter(
          PTHREADSTATE ThreadState,
          LPSTR p
          )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (!strncmp(p, "BC Compiler error", 17)) {
        FormatMsErrorMessage( ThreadState,
                              ThreadState->ChildCurrentFile, NULL, p, FALSE );
        return TRUE;
    }

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning)) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return ( TRUE );
    } else {
        char *pErrorMsg;
        if (NULL != (pErrorMsg = strstr(p, "error BC"))) {
            FormatMsErrorMessage( ThreadState,
                                  ThreadState->ChildCurrentFile, NULL, pErrorMsg+6, FALSE );
            return TRUE;
        }
        return ( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MSJVCFilter
//
//  Synopsis:   Filters output from the JVC compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    24-Mar-99     patbr  Created
//
//----------------------------------------------------------------------------

BOOL
MSJVCFilter(
           PTHREADSTATE ThreadState,
           LPSTR p
           )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (!strncmp(p, "fatal error J", 13) || !strncmp(p, "error J", 7)) {
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), COLOR_ERROR);
        WriteTTYLoggingErrors( FALSE, ThreadState, p );
        WriteTTYLoggingErrors( FALSE, ThreadState, "\r\n" );
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), DefaultConsoleAttributes);
        RunningTotals.NumberCompileErrors++;
        ThreadState->BuildMetrics.NumberCompileErrors++;
        return TRUE;
    }

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning)) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return ( TRUE );
    } else {
        return ( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MSCoolFilter
//
//  Synopsis:   Filters output from the COOL compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    2-Jun-99     patbr  Created
//
//----------------------------------------------------------------------------

BOOL
MSCoolFilter(
            PTHREADSTATE ThreadState,
            LPSTR p
            )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (!strncmp(p, "fatal error SC", 14) || !strncmp(p, "error SC", 8)) {
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), COLOR_ERROR);
        WriteTTYLoggingErrors( FALSE, ThreadState, p );
        WriteTTYLoggingErrors( FALSE, ThreadState, "\r\n" );
        if (fColorConsole)
            SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), DefaultConsoleAttributes);
        RunningTotals.NumberCompileErrors++;
        ThreadState->BuildMetrics.NumberCompileErrors++;
        return TRUE;
    }

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning)) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return ( TRUE );
    } else {
        return ( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MSCSharpFilter
//
//  Synopsis:   Filters output from the CSharp compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    6-Nov-00     sbonev  Copy of MSCoolFilter
//
//----------------------------------------------------------------------------

BOOL
MSCSharpFilter(
              PTHREADSTATE ThreadState,
              LPSTR p
              )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (!strncmp(p, "fatal error CS", 14) || !strncmp(p, "error CS", 8)) {
        Message = p + strlen("error ");
        FileName = ".";
        LineNumber = NULL;
        Warning = FALSE;
        FormatMsErrorMessage( ThreadState, FileName, LineNumber, Message, Warning );
        RunningTotals.NumberCompileErrors++;
        ThreadState->BuildMetrics.NumberCompileErrors++;
        return TRUE;
    }

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning)) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return ( TRUE );
    } else {
        return ( FALSE );
    }
}





BOOL
MSPostBuildFilter(
                 PTHREADSTATE ThreadState,
                 LPSTR p
                 )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;
    LPSTR p1;
    FileName = NULL;
    Message = p +10;
    LineNumber = NULL;
    Warning = FALSE;


    if (strstr (p,"ERROR:"))
        FormatMsErrorMessage( ThreadState, FileName, LineNumber, Message, Warning );
    RunningTotals.NumberCompileErrors++;
    ThreadState->BuildMetrics.NumberCompileWarnings++;
    return TRUE;

}


//+---------------------------------------------------------------------------
//
//  Function:   ResGenFilter
//
//  Synopsis:   Filters output from the .NET Resource Generator so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    22-Mar-01     sbonev
//
//----------------------------------------------------------------------------

BOOL
ResGenFilter(
            PTHREADSTATE ThreadState,
            LPSTR p
            )
{
    if (!strncmp(p, "ResGen: Error: ", 15)) {
        LPSTR LineNumber = _strdup(p);
        LPSTR pch = LineNumber;
        LPCSTR Line = strstr(p, ". Line ");
        LPCSTR Pos = strstr(p, ", position ");

        if (!LineNumber) {
            return FALSE;
        }

        LineNumber[0] = 0;

        // put line,pos info if available
        if (NULL != Line) {
            Line += 7;
            while (isdigit(*Line)) *pch++ = *Line++;

            if (NULL != Pos) {
                Pos += 11;
                *pch++ = ',';
                while (isdigit(*Pos)) *pch++ = *Pos++;
            }
        }

        FormatMsErrorMessage(
                            ThreadState,
                            ThreadState->ChildCurrentFile,
                            LineNumber,
                            strlen(ThreadState->ChildCurrentFile) > 0 ? p + 15 : p, // display full message if there is no filename
                            FALSE);

        free(LineNumber);
        return TRUE;
    }

    return ( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CScriptFilter
//
//  Synopsis:   Filters output from Windows Script Host so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    22-Mar-01     sbonev
//
//----------------------------------------------------------------------------
BOOL
CScriptFilter(
             PTHREADSTATE ThreadState,
             LPSTR p
             )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (NULL != strstr(p, "Microsoft JScript runtime error:") ||
        NULL != strstr(p, "Microsoft JScript compilation error:") ||
        NULL != strstr(p, "Microsoft VBScript runtime error:") ||
        NULL != strstr(p, "Microsoft VBScript compilation error:")) {

        // just display the message
        PassThrough( ThreadState, p, FALSE );
        return TRUE;

    }

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning)) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return ( TRUE );
    } else {
        return ( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ToolNotFoundFilter
//
//  Synopsis:   Filters output from the build looking for "name not recognized"
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//              [p]           -- Message we're trying to parse.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    10-Dec-98     patbr  Created
//
//----------------------------------------------------------------------------

BOOL
ToolNotFoundFilter(
                  PTHREADSTATE ThreadState,
                  LPSTR p
                  )
{
    if ((!strncmp(p, "The name specified is not recognized", 36)) ||
        (!strncmp(p, "internal or external command", 28))) {
        FormatMsErrorMessage( ThreadState,
                              ThreadState->ChildCurrentFile, NULL, p, FALSE );
        return TRUE;
    }

    return (FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   MSToolFilter
//
//----------------------------------------------------------------------------

BOOL
MSToolFilter(
            PTHREADSTATE ThreadState,
            LPSTR p
            )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning
                        )
       ) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return ( TRUE );
    } else {
        return ( FALSE );
    }
}


BOOL
LinkFilter(
          PTHREADSTATE ThreadState,
          LPSTR p
          );

//+---------------------------------------------------------------------------
//
//  Function:   LinkFilter1
//
//----------------------------------------------------------------------------

BOOL
LinkFilter1(
           PTHREADSTATE ThreadState,
           LPSTR p
           )
{
    LPSTR FileName;
    LPSTR p1;
    char buffer[ 256 ];

    if (p[ strlen( p ) - 1 ] == ':') {
        return ( LinkFilter( ThreadState, p ) );
    }

    p1 = p;
    while (*p1) {
        if (*p1 == '(') {
            *p1++ = 0;
            if (*p1 == '.' && p1[1] == '\\') {
                p1 += 2;
            }
            FileName = p1;
            while (*p1) {
                if (*p1 == ')') {
                    *p1++ = 0;
                    strcpy( buffer, "L2029: Unresolved external reference to " );
                    strncat( buffer,
                             ThreadState->UndefinedId,
                             sizeof(buffer) - strlen("L2029: Unresolved external reference to "));
                    FormatMsErrorMessage( ThreadState, FileName, "1",
                                          buffer, FALSE
                                        );
                    return ( TRUE );
                } else {
                    p1++;
                }
            }
        } else {
            p1++;
        }
    }

    return ( FALSE  );
}


//+---------------------------------------------------------------------------
//
//  Function:   LinkFilter
//
//----------------------------------------------------------------------------

BOOL
LinkFilter(
          PTHREADSTATE ThreadState,
          LPSTR p
          )
{
    LPSTR FileName = NULL;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;
    LPSTR p1;

    p1 = p;
    while (*p1) {
        if (*p1 == ':') {
            if (p1[-1] == ']') {
                return ( FALSE );
            }

            if (p1[-1] == ' ' && p1[1] == ' ') {
                if (MsCompilerFilter( ThreadState, p,
                                      &FileName,
                                      &LineNumber,
                                      &Message,
                                      &Warning
                                    )
                   ) {

                    if (!Warning || !(_strnicmp(Message, "L4021", 5) ||
                                      _strnicmp(Message, "L4038", 5) ||
                                      _strnicmp(Message, "L4046", 5))) {
                        if (LineNumber)
                            FileName = LineNumber;
                        if (FileName && FileName[0] == '.' && FileName[1] == '\\') {
                            FileName += 2;
                        }
                        FormatMsErrorMessage( ThreadState, FileName, "1",
                                              Message, FALSE );
                        return ( TRUE );
                    }
                }

                FormatMsErrorMessage( ThreadState, FileName, "1",
                                      Message, TRUE );

                return ( TRUE );
            }

            if (p1[-1] == ')') {
                p1 -= 11;
                if (p1 > p && !strcmp( p1, " in file(s):" )) {
                    strcpy( ThreadState->UndefinedId,
                            IsolateFirstToken( &p, ' ' )
                          );
                    ThreadState->FilterProc = LinkFilter1;
                    return ( TRUE );
                }
            }

            return ( FALSE );
        } else {
            p1++;
        }
    }

    return ( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CoffFilter
//
//----------------------------------------------------------------------------

BOOL
CoffFilter(
          PTHREADSTATE ThreadState,
          LPSTR p
          )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning
                        )
       ) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return ( TRUE );
    } else {
        return ( FALSE );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ClRiscFilter
//
//  Synopsis:   Risc compiler filter
//
//  Note:  It may be possible to remove this filter.
//
//----------------------------------------------------------------------------

BOOL
ClRiscFilter(
            PTHREADSTATE ThreadState,
            LPSTR p
            )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;
    LPSTR q;

    if (TestPrefix( &p, "cfe: " )) {
        if (strncmp(p, "Error: ", strlen("Error: ")) == 0) {
            p += strlen("Error: ");
            Warning = FALSE;

        } else if (strncmp(p, "Warning: ", strlen("Warning: ")) == 0) {
            p += strlen("Warning: ");
            Warning = TRUE;
        } else {
            return (FALSE);
        }

        q = p;
        if (p = strstr( p, ".\\\\" )) {
            p += 3;
        } else {
            p = q;
        }

        FileName = p;
        while (*p > ' ') {
            if (*p == ',' || (*p == ':' && *(p+1) == ' ')) {
                *p++ = '\0';
                break;
            }

            p++;
        }

        if (*p != ' ') {
            return ( FALSE );
        }

        *p++ = '\0';

        if (strcmp(p, "line ") == 0) {
            p += strlen("line ");

        }

        LineNumber = p;
        while (*p != '\0' && *p != ':') {
            p++;
        }

        if (*p != ':') {
            return ( FALSE );
        }

        *p++ = '\0';
        if (*p == ' ') {
            Message = p+1;
            ThreadState->LinesToIgnore = 2;

            FormatMsErrorMessage( ThreadState,
                                  FileName,
                                  LineNumber,
                                  Message,
                                  Warning
                                );
            return ( TRUE );
        }
    }
    //
    // If we did not recognize the cfe compiler, pass it to the MS compiler
    // message filter
    //

    return ( C510Filter( ThreadState, p ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   MSXSLFilter
//
//  Synopsis:   MSXSL filter
//
//----------------------------------------------------------------------------

BOOL
MSXSLFilter(
           PTHREADSTATE ThreadState,
           LPSTR p
           )
{
    LPSTR FirstLine;
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR ColumnNumber;
    LPSTR Message;

    if (strncmp(p, "Error occurred while ", strlen("Error occurred while ")) == 0) {
        FirstLine = p;
        p = ThreadState->ChildOutput->_ptr + 2;

        if (strncmp(p, "Code: ", strlen("Code: ")) == 0) {
            p = strchr(p, '\r') + 2;
        }

        if (strncmp(p, "URL: ", strlen("URL: ")) == 0) {
            p += strlen("URL: ");
            while (*p == ' ') {
                p++;
            }
            p += strlen("file:///");
            FileName = p;
            while (*p != '\r') {
                if (*p == '/') {
                    *p = '\\';
                }
                p++;
            }
            *p = '\0';
            p += 2;

            if (strncmp(p, "Line: ", strlen("Line: ")) == 0) {
                p += strlen("Line: ");
                while (*p == ' ') {
                    p++;
                }
                LineNumber = p;
                p = strchr(p, '\r');
                *p = '\0';
                p += 2;
            }
            if (strncmp(p, "Column: ", strlen("Column: ")) == 0) {
                p += strlen("Column: ");
                while (*p == ' ') {
                    p++;
                }
                ColumnNumber = p;
                p = strchr(p, '\r');
                *p = '\0';
                p += 2;
                strcat (LineNumber, ", ");
                strcat (LineNumber, ColumnNumber);
            }
        } else {
            FileName = strchr(FirstLine, '\'');
            if (FileName) {
                FileName++;
                *strchr(FileName, '\'') = '\0';
            }
            LineNumber = NULL;
        }

        while (*p == '\n' || *p == '\r' || *p == ' ') {
            p++;
        }
        Message = p;
        while (*p != '\n' && *p != '\r') {
            p++;
        }
        *p = '\0';

        FormatMsErrorMessage (ThreadState, FileName, LineNumber, Message, FALSE);

    } else {
        return (FALSE);
    }

    return ( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   MgClientFilter
//
//----------------------------------------------------------------------------

BOOL
MgClientFilter(
              PTHREADSTATE ThreadState,
              LPSTR p
              )
{
    return ( PassThrough( ThreadState, p, TRUE ) );
}


BOOL fAlreadyUnknown = FALSE;

//+---------------------------------------------------------------------------
//
//  Function:   DetermineChildState
//
//  Synopsis:   Parse the message given by the compiler (or whatever) and try
//              to figure out what it's doing.
//
//  Arguments:  [ThreadState] -- Current thread state
//              [p]           -- New message string
//
//  Returns:    TRUE if we figured it out, FALSE if we didn't recognize
//              anything.
//
//----------------------------------------------------------------------------

BOOL
DetermineChildState(
                   PTHREADSTATE ThreadState,
                   LPSTR p
                   )
{
    PFILEREC FileDB;
    char CheckFileName[300];
    LPSTR pCheckFileName;
    LPSTR FileName;
    BOOL fPrintChildState = TRUE;

    //
    // ************ Determine what state the child process is in.
    //               (Compiling, linking, running MIDL, etc.)
    //

    if ( TestPrefixPath( &p, "rc ") || TestPrefixPath( &p, "rc.exe ")) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
        } else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
        } else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
        } else if (strstr( p, "arm") || strstr( p, "ARM")) {
            ThreadState->ChildTarget = ARMTargetMachine.Description;
        } else {
            ThreadState->ChildTarget = "unknown target";
        }
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_COMPILING;
        ThreadState->ChildFlags = 0;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
    } else

        if (TestPrefixPath( &p, "rc16 ") ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
        } else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
        } else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
        } else if (strstr( p, "arm") || strstr( p, "ARM")) {
            ThreadState->ChildTarget = ARMTargetMachine.Description;
        } else {
            ThreadState->ChildTarget = "unknown target";
        }
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_COMPILING;
        ThreadState->ChildFlags = 0;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
    } else

        if ( TestPrefixPath( &p, "cl " )  || TestPrefixPath( &p, "cl.exe " ) ||
             TestPrefixPath( &p, "clarm " )  || TestPrefixPath( &p, "clarm.exe " ) ||
             TestPrefixPath( &p, "covc " )  || TestPrefixPath( &p, "covc.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = C510Filter;
        ThreadState->ChildFlags = 0;
        if ( strstr( p, "/WX" ) != NULL || strstr( p, "-WX" ) != NULL) {
            ThreadState->ChildFlags |= FLAGS_WARNINGS_ARE_ERRORS;
        }
        if ((strstr( p, "/EP " ) != NULL) ||
            (strstr( p, "/E " ) != NULL) ||
            (strstr( p, "/P " ) != NULL) ||
            (strstr( p, "-EP " ) != NULL) ||
            (strstr( p, "-E " ) != NULL) ||
            (strstr( p, "-P " ) != NULL)
           ) {
            if (strstr( p, "amd64") || strstr( p, "AMD64")) {
                ThreadState->ChildTarget = Amd64TargetMachine.Description;
            } else if (strstr( p, "i386") || strstr( p, "I386")) {
                ThreadState->ChildTarget = i386TargetMachine.Description;
            } else if (strstr( p, "ia64") || strstr( p, "IA64")) {
                ThreadState->ChildTarget = ia64TargetMachine.Description;
            } else if (strstr( p, "arm") || strstr( p, "ARM")) {
                ThreadState->ChildTarget = ARMTargetMachine.Description;
            } else {
                ThreadState->ChildTarget = "unknown target";
            }

            strcpy( ThreadState->ChildCurrentFile,IsolateLastToken( p, ' ' ) );
            if ( strstr( p, ".s" ) != NULL )
                ThreadState->ChildState = STATE_S_PREPROC;
            else
                ThreadState->ChildState = STATE_C_PREPROC;
        } else
            if ( (pch = strstr( p, "/Yc" )) != NULL ) {
            size_t namelen = strcspn( pch+3, " \t" );
            if (strstr( p, "ia64") || strstr( p, "IA64")) {
                ThreadState->ChildTarget = ia64TargetMachine.Description;
            } else if (strstr( p, "amd64") || strstr( p, "AMD64")) {
                ThreadState->ChildTarget = Amd64TargetMachine.Description;
            } else if (strstr( p, "i386") || strstr( p, "I386")) {
                ThreadState->ChildTarget = i386TargetMachine.Description;
            } else if (strstr( p, "arm") || strstr( p, "ARM")) {
                ThreadState->ChildTarget = ARMTargetMachine.Description;
            } else {
                ThreadState->ChildTarget = "unknown target";
            }

            ThreadState->ChildState = STATE_PRECOMP;
            strncpy( ThreadState->ChildCurrentFile, pch + 3, namelen);
            ThreadState->ChildCurrentFile[namelen] = '\0';
        } else {
            if (strstr( p, "ia64") || strstr( p, "IA64")) {
                ThreadState->ChildTarget = ia64TargetMachine.Description;
            } else if (strstr( p, "amd64") || strstr( p, "AMD64")) {
                ThreadState->ChildTarget = Amd64TargetMachine.Description;
            } else if (strstr( p, "i386") || strstr( p, "I386")) {
                ThreadState->ChildTarget = i386TargetMachine.Description;
            } else if (strstr( p, "arm") || strstr( p, "ARM")) {
                ThreadState->ChildTarget = ARMTargetMachine.Description;
            } else {
                ThreadState->ChildTarget = "unknown target";
            }
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile, "" );
            fPrintChildState = FALSE;
        }
    } else
        if ( TestPrefixPath( &p, "csc " ) || TestPrefixPath( &p, "csc.exe " ) ) {
        ThreadState->ChildState = STATE_LINKING;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSCSharpFilter;
        strcpy(ThreadState->ChildCurrentFile, IsolateLastToken(p, ' '));
    } else
        if ( TestPrefixPath( &p, "cl16 " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = C510Filter;
        ThreadState->ChildFlags = 0;
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
        } else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
        } else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
        } else if (strstr( p, "arm") || strstr( p, "ARM")) {
            ThreadState->ChildTarget = ARMTargetMachine.Description;
        } else {
            ThreadState->ChildTarget = "unknown target";
        }

        ThreadState->ChildState = STATE_COMPILING;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' ));
    } else

        if (TestPrefixPath( &p, "bc " ) || TestPrefixPath( &p, "bc.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        if (IsolateFirstToken( &p, '-' )) {
            if (*p == '\0')
                return FALSE; // This is a warning/error string
            while (*p != 'i') {
                if (!IsolateFirstToken( &p, '-' )) {
                    break;
                }
            }

            p++;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' ));

            ThreadState->ChildFlags = 0;
            ThreadState->ChildTarget = "all platforms";
            ThreadState->FilterProc = MSBCFilter;

            ThreadState->ChildState = STATE_COMPILING;
        }
    } else

        if (TestPrefixPath( &p, "vbc " ) || TestPrefixPath( &p, "vbc.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSBCFilter;

        ThreadState->ChildState = STATE_COMPILING;
        strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
    } else

        if (TestPrefixPath( &p, "jvc " ) || TestPrefixPath( &p, "jvc.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSJVCFilter;

        if (((pch = strstr( p, "*.java" )) != NULL ) ||
            (((pch = strstr( p, ".java" )) != NULL ) && ((pch2 = strstr( pch+1, ".java" )) != NULL ))) {
            ThreadState->ChildState = STATE_BATCHCOMPILE;
            // batch compiles will be counted by progress output
            if (getenv("JVC_TERSE") != NULL)
                strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, '\\' ) );
            else
                return FALSE;
        } else {
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
    } else

        if (TestPrefixPath( &p, "coolc " ) || TestPrefixPath( &p, "coolc.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSCoolFilter;

        if (((pch = strstr( p, "*.cool" )) != NULL ) ||
            (((pch = strstr( p, ".cool" )) != NULL ) && ((pch2 = strstr( pch+1, ".cool" )) != NULL ))) {
            ThreadState->ChildState = STATE_BATCHCOMPILE;
            // batch compiles will be counted by progress output
            return FALSE;
        } else {
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
    } else

        if (TestPrefixPath( &p, "resgen " ) || TestPrefixPath( &p, "resgen.exe " ) || TestPrefixPath( &p, "ResGen: Error:" )) {
        //
        // resgen usage:
        // ResGen inputFile.ext [outputFile.ext]
        //   no wildcards

        if (*(p-1) == ':') {
            // this is an error string
            if (ThreadState->FilterProc != ResGenFilter) {
                // switch the filter proc if we didn't know that ResGen was running
                ThreadState->FilterProc = ResGenFilter;
                strcpy( ThreadState->ChildCurrentFile, "" );
            }
            return FALSE;
        }

        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = ResGenFilter;

        ThreadState->ChildState = STATE_COMPILING;
        strcpy( ThreadState->ChildCurrentFile, IsolateFirstToken( &p, ' ' ) );
    } else

        if (TestPrefixPath( &p, "cscript " ) || TestPrefixPath( &p, "cscript.exe " )) {
        //
        // cscript usage:
        // CScript [option...] scriptname.extension [option...] [arguments...]
        // options are prefixed with / or -

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->ChildState = STATE_VSTOOL;
        ThreadState->FilterProc = CScriptFilter;
        strcpy( ThreadState->ChildCurrentFile, "" );    // don't care about the name; it would be displayed on error
    } else

        if (TestPrefixPath( &p, "docchecker " ) || TestPrefixPath( &p, "docchecker.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_DOCCHECKING;
        ThreadState->ChildTarget = "all platforms";
        strcpy( ThreadState->ChildCurrentFile, "" );
    } else

        if (TestPrefixPath( &p, "scc " ) || TestPrefixPath( &p, "scc.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSToolFilter;

        if (((pch = strstr( p, "*.sc" )) != NULL ) ||
            (((pch = strstr( p, ".sc" )) != NULL ) && ((pch2 = strstr( pch+1, ".sc" )) != NULL ))) {
            ThreadState->ChildState = STATE_BATCHCOMPILE;
            // batch compiles will be counted by progress output
            return FALSE;
        } else {
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
    } else

        if (TestPrefixPath( &p, "wfctosafec " ) || TestPrefixPath( &p, "wfctosafec.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSToolFilter;

        if (((pch = strstr( p, "*.sc" )) != NULL ) ||
            (((pch = strstr( p, ".sc" )) != NULL ) && ((pch2 = strstr( pch+1, ".sc" )) != NULL ))) {
            ThreadState->ChildState = STATE_BATCHCOMPILE;
            // batch compiles will be counted by progress output
            return FALSE;
        } else {
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
    } else

        if (TestPrefixPath( &p, "ml " ) || TestPrefixPath( &p, "ml.exe " ) ||
            TestPrefix( &p, "ml64 " ) || TestPrefix( &p, "ml64.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_ASSEMBLING;
        ThreadState->ChildFlags = 0;
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
        } else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
        } else {
            ThreadState->ChildTarget = "unknown target";
        }
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
    } else

        if (TestPrefixPath( &p, "masm ") || TestPrefixPath( &p, "masm.exe ") ||
            TestPrefixPath( &p, "armasm ") || TestPrefixPath( &p, "armasm.exe ") ||
            TestPrefixPath( &p, "masm386 ") || TestPrefixPath( &p, "masm386.exe ")) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_ASSEMBLING;
        ThreadState->ChildFlags = 0;
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
        } else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
        } else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
        } else if (strstr( p, "arm") || strstr( p, "ARM")) {
            ThreadState->ChildTarget = ARMTargetMachine.Description;
        } else {
            ThreadState->ChildTarget = "unknown target";
        }

        if (strstr(p, ",")) {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateLastToken(IsolateFirstToken(&p,','), ' '));
        } else {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateLastToken(IsolateFirstToken(&p,';'), ' '));
        }

    } else

        if (TestPrefixPath( &p, "lib " ) || TestPrefixPath( &p, "lib.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
        } else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
        } else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
        } else if (strstr( p, "arm") || strstr( p, "ARM")) {
            ThreadState->ChildTarget = ARMTargetMachine.Description;
        } else {
            ThreadState->ChildTarget = "unknown target";
        }
        ThreadState->FilterProc = CoffFilter;
        ThreadState->ChildFlags = 0;
        if (TestPrefix( &p, "-out:" )) {
            ThreadState->LinesToIgnore = 1;
            ThreadState->ChildState = STATE_LIBING;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' )
                  );
        } else
            if (TestPrefix( &p, "-def:" )) {
            ThreadState->LinesToIgnore = 1;
            ThreadState->ChildState = STATE_LIBING;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' )
                  );
            if (TestPrefix( &p, "-out:" )) {
                strcpy( ThreadState->ChildCurrentFile,
                        IsolateFirstToken( &p, ' ' )
                      );
            }
        } else {
            return FALSE;
        }
    } else

        if (TestPrefixPath( &p, "implib " ) || TestPrefixPath( &p, "implib.exe " ) ||
            TestPrefixPath( &p, "lib16 " )  || TestPrefixPath( &p, "lib16.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
        } else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
        } else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
        } else if (strstr( p, "arm") || strstr( p, "ARM")) {
            ThreadState->ChildTarget = ARMTargetMachine.Description;
        } else {
            ThreadState->ChildTarget = "unknown target";
        }

        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_LIBING;
        if (strstr(p, ";")) {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ';' ));
        } else {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' ));
        }
    } else

        if (TestPrefixPath( &p, "link " ) || TestPrefixPath( &p, "link.exe " ) ||
            TestPrefixPath( &p, "covlink ") || TestPrefixPath( &p, "covlink.exe ")) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
        } else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
        } else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
        } else if (strstr( p, "arm") || strstr( p, "ARM")) {
            ThreadState->ChildTarget = ARMTargetMachine.Description;
        } else {
            ThreadState->ChildTarget = "unknown target";
        }
        ThreadState->FilterProc = CoffFilter;
        ThreadState->ChildFlags = 0;
        if (TestPrefix( &p, "-out:" )) {
            ThreadState->LinesToIgnore = 2;
            ThreadState->ChildState = STATE_LINKING;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' )
                  );
        }
    } else

        if (TestPrefixPath( &p, "link16" ) ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
        } else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
        } else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
        } else if (strstr( p, "arm") || strstr( p, "ARM")) {
            ThreadState->ChildTarget = ARMTargetMachine.Description;
        } else {
            ThreadState->ChildTarget = "unknown target";
        }

        ThreadState->FilterProc = LinkFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_LINKING;
        p = IsolateLastToken(p, ' ');
        if (strstr(p, ";")) {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ';' ));
        } else {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ',' ));
        }

    } else

        if ( TestPrefixPath( &p, "bscmake " ) || TestPrefixPath( &p, "bscmake.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_BSCMAKING;
        ThreadState->ChildTarget = "all platforms";
        if ( (pch = strstr( p, "/o" )) != NULL ) {
            size_t namelen;
            pch2 = pch + 3;
            if ( *pch2 == '"' )
                pch2++;
            namelen = strcspn( pch2, " \t\"" );
            strncpy( ThreadState->ChildCurrentFile, pch2, namelen );
            ThreadState->ChildCurrentFile[namelen] = '\0';
        }
    } else

        if (TestPrefixPath( &p, "icl ")) {
        while (*p == ' ') {
            p++;
        }
        ThreadState->ChildState = STATE_COMPILING;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = ia64TargetMachine.Description;
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
    } else

        if (TestPrefixPath( &p, "mktyplib " ) || TestPrefixPath( &p, "mktyplib.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_MKTYPLIB;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
    } else

        if (TestPrefix( &p, "MC: Compiling " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_MC;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
    } else

        if (TestPrefixPath( &p, "midl " ) || TestPrefixPath( &p, "midl.exe " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_MIDL;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
    } else

        if (TestPrefixPath( &p, "asn1 " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_ASN;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy(ThreadState->ChildCurrentFile, IsolateLastToken(p, ' '));
    } else

        if (TestPrefix( &p, "Build_Status " )) {
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_STATUS;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile, "" );
    }

    else
        if (TestPrefixPath( &p, "binplace " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string

        RunningTotals.NumberBinplaces++;
        ThreadState->BuildMetrics.NumberBinplaces++;

        while (*p == ' ') {
            p++;
        }

        // If this is a standard link/binplace step, don't tell the
        // user what's going on, just pass any errors/warnings to
        // the output.  If this is a straight binplace, list the state.

        if (ThreadState->ChildState == STATE_LINKING) {
            ThreadState->ChildState = STATE_BINPLACE;
            ThreadState->ChildFlags = 0;
            ThreadState->FilterProc = MSToolFilter;
            return TRUE;
        } else {
            ThreadState->ChildState = STATE_BINPLACE;
            ThreadState->ChildFlags = 0;
            ThreadState->FilterProc = MSToolFilter;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
    }

    else
        if (TestPrefixPath( &p, "ctc " ) || TestPrefixPath( &p, "ctc.exe " )) {
        size_t namelen;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_CTCOMPILING;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSToolFilter;
        while (*p == '-') {
            p = p + strcspn( p, " \t" );
            while (*p == ' ')
                p++;
        }
        namelen = strcspn( p, " \t" );
        strncpy( ThreadState->ChildCurrentFile, p, namelen );
        ThreadState->ChildCurrentFile[namelen] = '\0';
    }

    else
        if (TestPrefixPath( &p, "idheader " )) {
        size_t namelen;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_VSTOOL;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSToolFilter;
        namelen = strcspn( p, " \t" );
        strncpy( ThreadState->ChildCurrentFile, p, namelen );
        ThreadState->ChildCurrentFile[namelen] = '\0';
    }

    else
        if (TestPrefixPath( &p, "bison ")) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_VSTOOL;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSToolFilter;
        strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
    } else
        if ((TestPrefix( &p, "packthem " )) || (TestPrefix( &p, "..\\packthem " ))) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string

        while (*p == ' ')
            p++;

        ThreadState->ChildTarget = i386TargetMachine.Description;

        ThreadState->FilterProc = CoffFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_PACKING;

        if (TestPrefix( &p, "-o" )) {
            strcpy( ThreadState->ChildCurrentFile, IsolateFirstToken( &p, ' ' ));
        }
    }

    else
        if (TestPrefixPath( &p, "gnu_bison ")) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_VSTOOL;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = BisonFilter;
        strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
    }

    else
        if ( TestPrefixPath( &p, "vsautodoc " ) || TestPrefixPath( &p, "vsautodoc.exe " )) {
        LPSTR pch, pch2;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_AUTODOCING;
        ThreadState->ChildTarget = "all platforms";
        if ( (pch = strstr( p, "/o" )) != NULL ) {
            size_t namelen;
            pch2 = pch + 3;
            if ( *pch2 == '"' )
                pch2++;
            namelen = strcspn( pch2, " \t\"" );
            strncpy( ThreadState->ChildCurrentFile, pch2, namelen );
            ThreadState->ChildCurrentFile[namelen] = '\0';
        }
    }

    else
        if (TestPrefix( &p, "msxsl " ) ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->FilterProc = MSXSLFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->ChildState = STATE_COMPILING;
        strcpy( ThreadState->ChildCurrentFile, IsolateFirstToken( &p, ' ' ));
    } else
        if (TestPrefix( &p, "POSTBUILD:" ) ) {
        ThreadState->ChildState = STATE_POSTBUILD;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = MSPostBuildFilter;
        return FALSE;
    } else
        if (ThreadState->ChildState == STATE_BATCHCOMPILE) {
        if (strstr( p, "integral type to pointer") ||
            strstr( p, "this conversion is possible") ||
            strstr( p, "void cannot be converted") ||
            strstr( p, "Compiling...") ||
            strstr( p, "Generating Code...") ||
            strstr( p, "Parsing ") ||
            strstr( p, "Loading class:") ||
            strstr( p, "Generating file "))
            return FALSE;       // This is a warning/error/info string
        if (strstr( p, ".c") && !strchr( p, ' ') && !strchr( p, ':'))
            strcpy( ThreadState->ChildCurrentFile, p ); // C/C++ compile
        else if (strstr( p, ".java") && strstr( p, "Compiling ")) {
            if (getenv("JVC_TERSE") != NULL) {
                RunningTotals.NumberCompiles++;
                ThreadState->BuildMetrics.NumberCompiles++;
                return FALSE;
            } else {
                strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, '\\' ) ); // Java compile
            }
        } else
            return FALSE;
    }

    else {
        return FALSE;
    }

    //
    // ***************** Set the Thread State according to what we determined.
    //
    FileName = ThreadState->ChildCurrentFile;

    // make sure directories match to trailing backslash
    strcpy(CheckFileName, FileName);
    pCheckFileName = CheckFileName;

    if (TestPrefix( &pCheckFileName, CurrentDirectory )) {
        if (*pCheckFileName == '\\') {
            FileName += (pCheckFileName - CheckFileName) + 1;
        }

        if (TestPrefix( &pCheckFileName, ThreadState->ChildCurrentDirectory )) {
            if (*pCheckFileName == '\\') {
                FileName += (pCheckFileName - CheckFileName) + 1;
            }
        }

        strcpy( ThreadState->ChildCurrentFile, FileName );
    }

    FileDB = NULL;

    if (ThreadState->ChildState == STATE_LIBING) {
        RunningTotals.NumberLibraries++;
        ThreadState->BuildMetrics.NumberLibraries++;
    } else
        if (ThreadState->ChildState == STATE_LINKING) {
        RunningTotals.NumberLinks++;
        ThreadState->BuildMetrics.NumberLinks++;
    } else
        if (ThreadState->ChildState == STATE_BSCMAKING) {
        RunningTotals.NumberBSCMakes++;
        ThreadState->BuildMetrics.NumberBSCMakes++;
    } else
        if ((ThreadState->ChildState == STATE_STATUS) ||
            // Don't need to do anything here - binplace count already handled above
            (ThreadState->ChildState == STATE_BINPLACE) ||
            (ThreadState->ChildState == STATE_UNKNOWN)) {
        ;  // Do nothing.
    } else {
        if (ThreadState->CompileDirDB) {
            RunningTotals.NumberCompiles++;
            ThreadState->BuildMetrics.NumberCompiles++;
            CopyString(ThreadState->ChildCurrentFile, ThreadState->ChildCurrentFile, TRUE);

            if (!fQuicky) {
                FileDB = FindSourceFileDB(
                                         ThreadState->CompileDirDB,
                                         ThreadState->ChildCurrentFile,
                                         NULL);
            }
        }
    }

    if (strstr(ThreadState->ChildCurrentFile, ".cxx") ||
        strstr(ThreadState->ChildCurrentFile, ".cpp")) {
        ThreadState->ChildFlags |= FLAGS_CXX_FILE;
    }

    if (fPrintChildState)
        PrintChildState(ThreadState, p, FileDB);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   PrintChildState
//
//  Synopsis:
//
//  Arguments:  [ThreadState] -- Current thread state
//
//  Returns:    TRUE if we figured it out, FALSE if we didn't recognize
//              anything.
//
//----------------------------------------------------------------------------

void
PrintChildState(
               PTHREADSTATE ThreadState,
               LPSTR p,
               PFILEREC FileDB
               )
{
    USHORT SaveCol;
    USHORT SaveRow;
    USHORT SaveRowTop;
    BOOL fStatusOutput = FALSE;
    char buffer[ DB_MAX_PATH_LENGTH ];
    LONG FilesLeft;
    LONG LinesLeft;
    ULONG LinesPerSecond;
    ULONG SecondsLeft;
    ULONG PercentDone;

    //
    // *********************** Print the thread state to the screen
    //
    if (ThreadState->IsStdErrTty) {
        GetScreenSize(ThreadState);
        assert(ThreadState->cColTotal != 0);
        assert(ThreadState->cRowTotal != 0);

        if (fStatus) {
            GetCursorPosition(&SaveRow, &SaveCol, &SaveRowTop);

            //  Clear row for process message
            ClearRows (ThreadState,
                       (USHORT) (SaveRowTop + ThreadState->ThreadIndex - 1),
                       1,
                       StatusCell);

            //  Clear row for status message
            ClearRows (ThreadState,
                       (USHORT) (SaveRowTop + NumberProcesses),
                       1,
                       StatusCell);

            //  Make sure there's still some room at the bottom
            if (SaveRow == LastRow(ThreadState)) {
                USHORT RowTop = 1 + SaveRowTop + (USHORT) NumberProcesses + 1;

                MoveRectangleUp (
                                RowTop,                     // Top
                                0,                          // Left
                                LastRow(ThreadState),       // Bottom
                                LastCol(ThreadState),       // Right
                                1,                          // NumRow
                                ScreenCell);                // FillCell

                SaveRow--;
            }

            SetCursorPosition(
                             (USHORT) (SaveRowTop + ThreadState->ThreadIndex - 1),
                             0);
            fStatusOutput = TRUE;
        }
    }

    if (szBuildTag) {
        sprintf(buffer, "%s: ", szBuildTag);
        WriteTTY(ThreadState, buffer, fStatusOutput);
    }

    if (fParallel && !fNoThreadIndex) {
        sprintf(buffer, "%d>", ThreadState->ThreadIndex);
        WriteTTY(ThreadState, buffer, fStatusOutput);
    }

    if (ThreadState->ChildState == STATE_UNKNOWN) {
        if (!fAlreadyUnknown) {
            WriteTTY(
                    ThreadState,
                    "Processing Unknown item(s)...\r\n",
                    fStatusOutput);
            fAlreadyUnknown = TRUE;
        }
    } else
        if (ThreadState->ChildState == STATE_STATUS) {
        WriteTTY(ThreadState, p, fStatusOutput);
        WriteTTY(ThreadState, "\r\n", fStatusOutput);
    } else {
        fAlreadyUnknown = FALSE;
        WriteTTY(ThreadState, States[ThreadState->ChildState], fStatusOutput);
        WriteTTY(ThreadState, " - ", fStatusOutput);
        WriteTTY(ThreadState, FormatPathName(ThreadState->ChildCurrentDirectory, ThreadState->ChildCurrentFile), fStatusOutput);
        WriteTTY(ThreadState, " for ", fStatusOutput);
        WriteTTY(ThreadState, ThreadState->ChildTarget, fStatusOutput);
        WriteTTY(ThreadState, "\r\n", fStatusOutput);

        if (fXMLOutput || fXMLFragment) {
            XMLThreadInitBuffer(ThreadState);
            if (PXMLThreadStates[ThreadState->XMLThreadIndex]->fXMLInAction) {
                // check for action errors or warnings
                if (ThreadState->BuildMetrics.NumberActErrors || ThreadState->BuildMetrics.NumberActWarnings) {
                    sprintf(szXMLBuffer, "<ACTIONSUMMARY ");
                    if (ThreadState->BuildMetrics.NumberActErrors) {
                        sprintf(szXMLBuffer + strlen(szXMLBuffer), " ERRORS=\"%d\"", ThreadState->BuildMetrics.NumberActErrors);
                    }
                    if (ThreadState->BuildMetrics.NumberActWarnings) {
                        sprintf(szXMLBuffer + strlen(szXMLBuffer), " WARNINGS=\"%d\"", ThreadState->BuildMetrics.NumberActWarnings);
                    }
                    strcat(szXMLBuffer, "/>");
                    XMLThreadWrite(ThreadState, szXMLBuffer);
                }
                XMLThreadCloseTag(ThreadState, "ACTION");
                PXMLThreadStates[ThreadState->XMLThreadIndex]->fXMLInAction = FALSE;
            }
            XMLThreadOpenTag(ThreadState, "ACTION", "TYPE=\"%s\" FILE=\"%s\" TARGET=\"%s\"", States[ThreadState->ChildState], ThreadState->ChildCurrentFile, ThreadState->ChildTarget);
            PXMLThreadStates[ThreadState->XMLThreadIndex]->fXMLInAction = TRUE;
        }
        ThreadState->BuildMetrics.NumberDirActions++;
        ThreadState->BuildMetrics.NumberActErrors = 0;
        ThreadState->BuildMetrics.NumberActWarnings = 0;
    }

    if (StartCompileTime) {
        ElapsedCompileTime += (ULONG)(time(NULL) - StartCompileTime);
    }

    if (FileDB != NULL) {
        StartCompileTime = time(NULL);
    } else {
        StartCompileTime = 0L;
    }

    //
    // ****************** Update the status line
    //
    if (ThreadState->IsStdErrTty) {
        assert(ThreadState->cColTotal != 0);
        assert(ThreadState->cRowTotal != 0);

        if (fStatus) {
            if (FileDB != NULL) {
                FilesLeft = TotalFilesToCompile - TotalFilesCompiled;
                if (FilesLeft < 0) {
                    FilesLeft = 0;
                }
                LinesLeft = TotalLinesToCompile - TotalLinesCompiled;
                if (LinesLeft < 0) {
                    LinesLeft = 0;
                    PercentDone = 99;
                } else if (TotalLinesToCompile != 0) {
                    if (TotalLinesCompiled > 20000000L) {
                        int TLC = TotalLinesCompiled / 100;
                        int TLTC = TotalLinesToCompile / 100;

                        PercentDone = (TLC * 100L)/TLTC;
                    } else
                        PercentDone = (TotalLinesCompiled * 100L)/TotalLinesToCompile;
                } else {
                    PercentDone = 0;
                }

                if (ElapsedCompileTime != 0) {
                    LinesPerSecond = TotalLinesCompiled / ElapsedCompileTime;
                } else {
                    LinesPerSecond = 0;
                }

                if (LinesPerSecond != 0) {
                    SecondsLeft = LinesLeft / LinesPerSecond;
                } else {
                    SecondsLeft = LinesLeft / DEFAULT_LPS;
                }

                sprintf(
                       buffer,
                       "%2d%% done. %4ld %sLPS  Time Left:%s  Files: %d  %sLines: %s\r\n",
                       PercentDone,
                       LinesPerSecond,
                       fStatusTree? "T" : "",
                       FormatTime(SecondsLeft),
                       FilesLeft,
                       fStatusTree? "Total " : "",
                       FormatNumber(LinesLeft));

                SetCursorPosition((USHORT) (SaveRowTop + NumberProcesses), 0);

                WriteTTY(ThreadState, buffer, fStatusOutput);
            }

            SetCursorPosition(SaveRow, SaveCol);
        }
    }

    //
    // ***************** Keep track of how many files have been compiled.
    //
    if (ThreadState->ChildState == STATE_COMPILING  ||
        ThreadState->ChildState == STATE_ASSEMBLING ||
        ThreadState->ChildState == STATE_MKTYPLIB   ||
        ThreadState->ChildState == STATE_MIDL       ||
        ThreadState->ChildState == STATE_ASN        ||
        (FileDB != NULL && ThreadState->ChildState == STATE_PRECOMP)) {
        TotalFilesCompiled++;
    }
    if (FileDB != NULL) {
        TotalLinesCompiled += FileDB->TotalSourceLines;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessLine
//
//  Synopsis:   Watch the lines coming from the thread for special strings.
//
//----------------------------------------------------------------------------

BOOL
ProcessLine(
           PTHREADSTATE ThreadState,
           LPSTR p
           )
{
    LPSTR p1;

    while (*p <= ' ') {
        if (!*p) {
            return ( FALSE );
        } else {
            p++;
        }
    }

    p1 = p;
    while (*p1) {
        if (*p1 == '\r')
            break;
        else
            p1++;
    }
    *p1 = '\0';

    p1 = p;
    if (TestPrefix( &p1, "Stop." )) {
        return ( TRUE );
    }

    //  Stop multithread access to shared:
    //      database
    //      window
    //      compilation stats

    EnterCriticalSection(&TTYCriticalSection);

    if (TestPrefix( &p1, "nmake :" )) {
        PassThrough( ThreadState, p, FALSE );
    } else
        if (TestPrefix( &p1, "BUILDMSG: " )) {
        if (TestPrefix(&p1, "Warning")) {
            PassThrough(ThreadState, p, TRUE);
        } else {
            WriteTTY(ThreadState, p, TRUE);
            WriteTTY(ThreadState, "\r\n", TRUE);
        }
    } else
        if (ThreadState->LinesToIgnore) {
        ThreadState->LinesToIgnore--;
    } else {
        if ( !DetermineChildState( ThreadState, p ) ) {
            if (!ToolNotFoundFilter( ThreadState, p )) {
                if (ThreadState->FilterProc != NULL) {
                    (*ThreadState->FilterProc)( ThreadState, p );
                }
            }
        }
    }

    if (fXMLVerboseOutput) {
        XMLThreadWrite(ThreadState, "<RAW MESSAGE=\"%s\"/>\r\n", XMLEncodeBuiltInEntitiesCopy(p, szXMLBuffer));
    }

    LeaveCriticalSection(&TTYCriticalSection);

    return ( FALSE );
}


//+---------------------------------------------------------------------------
//
//  Function:   FilterThread
//
//  Synopsis:   Capture the output of the thread and process it.
//
//----------------------------------------------------------------------------

VOID
FilterThread(
            PTHREADSTATE ThreadState
            )
{
    UINT CountBytesRead;
    LPSTR StartPointer = NULL;
    LPSTR EndPointer;
    LPSTR NewPointer;
    ULONG BufSize = 512;
    UINT uThreadIdLen = 0;

    AllocMem(BufSize, &StartPointer, MT_THREADFILTER);
    while (TRUE) {
        EndPointer = StartPointer;
        do {
            if (BufSize - (EndPointer-StartPointer) < 512) {
                AllocMem(BufSize*2, &NewPointer, MT_THREADFILTER);
                RtlCopyMemory(
                             NewPointer,
                             StartPointer,
                             EndPointer - StartPointer + 1);     // copy null byte, too
                EndPointer += NewPointer - StartPointer;
                FreeMem(&StartPointer, MT_THREADFILTER);
                StartPointer = NewPointer;
                BufSize *= 2;
            }
            if (!fgets(EndPointer, 512, ThreadState->ChildOutput)) {
                if (errno != 0)
                    BuildError("Pipe read failed - errno = %d\r\n", errno);
                FreeMem(&StartPointer, MT_THREADFILTER);
                return;
            }
            CountBytesRead = strlen(EndPointer);
            EndPointer = EndPointer + CountBytesRead;
        } while (CountBytesRead == 511 && EndPointer[-1] != '\n');

        CountBytesRead = (UINT)(EndPointer - StartPointer);
        if (fErrorLog && CountBytesRead) {
            if (fParallel && !fNoThreadIndex) {
                char buffer[50];
                sprintf(buffer, "%d>", ThreadState->ThreadIndex);
                fwrite(buffer, 1, strlen(buffer), LogFile);
            }
            fwrite(StartPointer, 1, CountBytesRead, LogFile);
        }
        if (ProcessLine(ThreadState, StartPointer)) {
            FreeMem(&StartPointer, MT_THREADFILTER);
            return;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ExecuteProgram
//
//  Synopsis:   Spawn a new thread to execute the given program and filter
//              its output.
//
//  Arguments:  [ProgramName]       --
//              [CommandLine]       --
//              [MoreCommandLine]   --
//              [MustBeSynchronous] -- For synchronous operation on a
//                                      multi-processor machine.
//              [XMLDir]            -- For XML output only - the name of 
//                                      the directory processed.
//              [XMLAction]         -- For XML output only - what we are
//                                      doing with the directory.
//
//  Returns:    ERROR_SUCCESS, ERROR_NOTENOUGHMEMORY, or return code from
//              PipeSpawnClose.
//
//  Notes:      On a multiprocessor machine, this will spawn a new thread
//              and then return, letting the thread run asynchronously.  Use
//              WaitForParallelThreads() to ensure all threads are finished.
//              By default, this routine will spawn as many threads as the
//              machine has processors.  This can be overridden with the -M
//              option.
//
//----------------------------------------------------------------------------

char ExecuteProgramCmdLine[ 1024 ];

UINT
ExecuteProgram(
              LPSTR ProgramName,
              LPSTR CommandLine,
              LPSTR MoreCommandLine,
              BOOL MustBeSynchronous,
              LPCSTR XMLDir,
              LPCSTR XMLAction)
{
    LPSTR p;
    UINT rc;
    THREADSTATE *ThreadState;
    UINT OldErrorMode;
    DWORD dwStartTime;

    AllocMem(sizeof(THREADSTATE), &ThreadState, MT_THREADSTATE);

    memset(ThreadState, 0, sizeof(*ThreadState));
    ThreadState->ChildState = STATE_UNKNOWN;
    ThreadState->ChildTarget = "Unknown Target";
    ThreadState->IsStdErrTty = (BOOL) _isatty(_fileno(stderr));
    ThreadState->CompileDirDB = CurrentCompileDirDB;
    ThreadState->FilterProc = NMakeFilter;

    if (ThreadState->IsStdErrTty) {
        GetScreenSize(ThreadState);
        assert(ThreadState->cColTotal != 0);
        assert(ThreadState->cRowTotal != 0);

        // We're displaying to the screen, so initialize the console.

        if (!fConsoleInitialized) {
            StatusCell[1] =
            BACKGROUND_RED |
            FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN |
            FOREGROUND_INTENSITY;

            ReadConsoleCells(ScreenCell, sizeof(ScreenCell), 2, 0);

            // If we stumbled upon an old Status line in row 2 of the window,
            // try the current row to avoid using the Status line background
            // colors for fill when scrolling.

            if (ScreenCell[1] == StatusCell[1]) {
                USHORT Row, Col;

                GetCursorPosition(&Row, &Col, NULL);
                ReadConsoleCells(ScreenCell, sizeof(ScreenCell), Row, 0);
            }
            ScreenCell[0] = StatusCell[0] = ' ';

            GetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), &OldConsoleMode);
            NewConsoleMode = OldConsoleMode;
            fConsoleInitialized = TRUE;
        }
        if (fStatus) {
            NewConsoleMode = OldConsoleMode & ~(ENABLE_WRAP_AT_EOL_OUTPUT);
        } else {
            NewConsoleMode = OldConsoleMode | ENABLE_WRAP_AT_EOL_OUTPUT;
        }
        SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), NewConsoleMode);
    } else {
        ThreadState->cRowTotal = 0;
        ThreadState->cColTotal = 0;
    }

    p = ThreadState->ChildCurrentDirectory;
    GetCurrentDirectory(sizeof(ThreadState->ChildCurrentDirectory), p);

    if (TestPrefix(&p, CurrentDirectory)) {
        if (*p == '\\') {
            p++;
        }
        strcpy(ThreadState->ChildCurrentDirectory, p);
    }

    if (ThreadState->ChildCurrentDirectory[0]) {
        strcat(ThreadState->ChildCurrentDirectory, "\\");
    }

    sprintf(
           ExecuteProgramCmdLine,
           "%s %s%s",
           ProgramName,
           CommandLine,
           MoreCommandLine);
    LogMsg("'%s %s%s'\r\n", ProgramName, CommandLine, MoreCommandLine);

    if (fParallel && !MustBeSynchronous) {
        PPARALLEL_CHILD ChildData;
        DWORD i;
        DWORD ThreadId;

        AllocMem(sizeof(PARALLEL_CHILD), &ChildData, MT_CHILDDATA);
        strcpy(ChildData->ExecuteProgramCmdLine,ExecuteProgramCmdLine);
        ChildData->ThreadState = ThreadState;

        if (ThreadsStarted < NumberProcesses) {
            if (ThreadsStarted == 0) {
                AllocMem(
                        sizeof(HANDLE) * NumberProcesses,
                        (VOID **) &WorkerThreads,
                        MT_THREADHANDLES);
                AllocMem(
                        sizeof(HANDLE) * NumberProcesses,
                        (VOID **) &WorkerEvents,
                        MT_EVENTHANDLES);
            }
            WorkerEvents[ThreadsStarted] = CreateEvent(NULL,
                                                       FALSE,
                                                       FALSE,
                                                       NULL);
            ChildData->Event = WorkerEvents[ThreadsStarted];

            ThreadState->ThreadIndex = ThreadsStarted+1;
            if (fXMLOutput || fXMLFragment) {
                ThreadState->XMLThreadIndex = ThreadState->ThreadIndex;
            }

            /*
            Thread-specific directory message that associates directory to build thread.
            */
            if (fParallel && !fNoThreadIndex && ThreadState->CompileDirDB && fErrorLog) {
                char buffer[500];
                ThreadState->CompileDirDB;
                sprintf(buffer, "%d>BUILDMSG: Processing %s\r\n", ThreadState->ThreadIndex,
                        ThreadState->CompileDirDB->Name);
                fwrite(buffer, 1, strlen(buffer), LogFile);
            }

            if (fXMLOutput || fXMLFragment) {
                char buffer[1024];
                char* pszRelPath = (char*)XMLDir;
                if (TestPrefix(&pszRelPath, CurrentDirectory) && (*pszRelPath == '\\')) pszRelPath++;
                if (strlen(pszRelPath) == 0) {
                    pszRelPath = ".\\";
                }
                strcpy(buffer, "CMDLINE=\"");
                XMLEncodeBuiltInEntitiesCopy(ExecuteProgramCmdLine, buffer+strlen(buffer));
                sprintf(buffer + strlen(buffer), "\" ACTION=\"%s\" FULLPATH=\"%s\" RELPATH=\"%s\"", XMLAction, ThreadState->ChildCurrentDirectory, pszRelPath);
                XMLThreadInitBuffer(ThreadState);
                XMLThreadOpenTag(ThreadState, "DIR", buffer);
                dwStartTime = GetTickCount();
            }
            memset(&(ThreadState->BuildMetrics), 0, sizeof(BUILDMETRICS));

            WorkerThreads[ThreadsStarted] = CreateThread(NULL,
                                                         0,
                                                         (LPTHREAD_START_ROUTINE)ParallelChildStart,
                                                         ChildData,
                                                         0,
                                                         &ThreadId);
            if ((WorkerThreads[ThreadsStarted] == NULL) ||
                (WorkerEvents[ThreadsStarted] == NULL)) {
                FreeMem(&ChildData, MT_CHILDDATA);
                FreeMem(&ThreadState, MT_THREADSTATE);
                return (ERROR_NOT_ENOUGH_MEMORY);
            } else {
                WaitForSingleObject(WorkerEvents[ThreadsStarted],INFINITE);
                ++ThreadsStarted;
            }
        } else {
            //
            // Wait for a thread to complete before starting
            // the next one.
            //
            i = WaitForMultipleObjects(NumberProcesses,
                                       WorkerThreads,
                                       FALSE,
                                       INFINITE);
            CloseHandle(WorkerThreads[i]);
            ChildData->Event = WorkerEvents[i];
            ThreadState->ThreadIndex = i+1;
            if (fXMLOutput || fXMLFragment) {
                ThreadState->XMLThreadIndex = ThreadState->ThreadIndex;
            }

            /*
            Thread-specific directory message that associates directory to build thread.
            */
            if (fParallel && !fNoThreadIndex && ThreadState->CompileDirDB && fErrorLog) {
                char buffer[500];
                ThreadState->CompileDirDB;
                sprintf(buffer, "%d>BUILDMSG: Processing %s\r\n", ThreadState->ThreadIndex,
                        ThreadState->CompileDirDB->Name);
                fwrite(buffer, 1, strlen(buffer), LogFile);
            }

            if (fXMLOutput || fXMLFragment) {
                char buffer[1024];
                char* pszRelPath = (char*)XMLDir;
                if (TestPrefix(&pszRelPath, CurrentDirectory) && (*pszRelPath == '\\')) pszRelPath++;
                if (strlen(pszRelPath) == 0) {
                    pszRelPath = ".\\";
                }
                strcpy(buffer, "CMDLINE=\"");
                XMLEncodeBuiltInEntitiesCopy(ExecuteProgramCmdLine, buffer+strlen(buffer));
                sprintf(buffer + strlen(buffer), "\" ACTION=\"%s\" FULLPATH=\"%s\" RELPATH=\"%s\"", XMLAction, XMLDir, pszRelPath);
                XMLThreadInitBuffer(ThreadState);
                XMLThreadOpenTag(ThreadState, "DIR", buffer);
                dwStartTime = GetTickCount();
            }
            memset(&(ThreadState->BuildMetrics), 0, sizeof(BUILDMETRICS));

            WorkerThreads[i] = CreateThread(NULL,
                                            0,
                                            (LPTHREAD_START_ROUTINE)ParallelChildStart,
                                            ChildData,
                                            0,
                                            &ThreadId);
            if (WorkerThreads[i] == NULL) {
                FreeMem(&ChildData, MT_CHILDDATA);
                FreeMem(&ThreadState, MT_THREADSTATE);
                return (ERROR_NOT_ENOUGH_MEMORY);
            } else {
                WaitForSingleObject(WorkerEvents[i],INFINITE);
            }
        }

        return (ERROR_SUCCESS);

    } else {

        //
        // Synchronous operation
        //
        StartCompileTime = 0L;
        ThreadState->ThreadIndex = 1;
        if (fXMLOutput || fXMLFragment) {
            // the synchronized directories are always processed by the main thread
            ThreadState->XMLThreadIndex = 0;
        }

        //
        // Disable child error popups in child processes.
        //

        if (fClean) {
            OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );
        }

        /*
        Thread-specific directory message that associates directory to build thread.
        */
        if (fParallel && !fNoThreadIndex && ThreadState->CompileDirDB && fErrorLog) {
            char buffer[500];
            ThreadState->CompileDirDB;
            sprintf(buffer, "%d>BUILDMSG: Processing %s\r\n", ThreadState->ThreadIndex,
                    ThreadState->CompileDirDB->Name);
            fwrite(buffer, 1, strlen(buffer), LogFile);
        }

        if (fXMLOutput || fXMLFragment) {
            char buffer[1024];
            char* pszRelPath = (char*)XMLDir;
            if (TestPrefix(&pszRelPath, CurrentDirectory) && (*pszRelPath == '\\')) pszRelPath++;
            if (strlen(pszRelPath) == 0) {
                pszRelPath = ".\\";
            }
            strcpy(buffer, "CMDLINE=\"");
            XMLEncodeBuiltInEntitiesCopy(ExecuteProgramCmdLine, buffer+strlen(buffer));
            sprintf(buffer + strlen(buffer), "\" ACTION=\"%s\" FULLPATH=\"%s\" RELPATH=\"%s\"", XMLAction, XMLDir, pszRelPath);
            XMLThreadInitBuffer(ThreadState);
            XMLThreadOpenTag(ThreadState, "DIR", buffer);
            dwStartTime = GetTickCount();
        }
        memset(&(ThreadState->BuildMetrics), 0, sizeof(BUILDMETRICS));

        ThreadState->ChildOutput = PipeSpawn( ExecuteProgramCmdLine );
        if (fClean) {
            SetErrorMode( OldErrorMode );
        }

        rc = ERROR_SUCCESS;

        if (ThreadState->ChildOutput == NULL) {
            BuildError(
                      "Exec of '%s' failed - errno = %d\r\n",
                      ExecuteProgramCmdLine,
                      errno);
        } else {
            FilterThread( ThreadState );

            if (StartCompileTime) {
                ElapsedCompileTime += (ULONG)(time(NULL) - StartCompileTime);
            }

            rc = PipeSpawnClose( ThreadState->ChildOutput );
            if (rc == -1) {
                BuildError("Child Terminate failed - errno = %d\r\n", errno);
            } else
                if (rc)
                BuildColorError(COLOR_ERROR, "%s failed - rc = %d\r\n", ProgramName, rc);
        }

        if (fXMLOutput || fXMLFragment) {
            XMLEnterCriticalSection();
            AddBuildMetrics(&PassMetrics, &ThreadState->BuildMetrics);

            if (PXMLThreadStates[ThreadState->XMLThreadIndex]->fXMLInAction) {
                // check for action errors or warnings
                if (ThreadState->BuildMetrics.NumberActErrors || ThreadState->BuildMetrics.NumberActWarnings) {
                    sprintf(szXMLBuffer, "<ACTIONSUMMARY ");
                    if (ThreadState->BuildMetrics.NumberActErrors) {
                        sprintf(szXMLBuffer + strlen(szXMLBuffer), " ERRORS=\"%d\"", ThreadState->BuildMetrics.NumberActErrors);
                    }
                    if (ThreadState->BuildMetrics.NumberActWarnings) {
                        sprintf(szXMLBuffer + strlen(szXMLBuffer), " WARNINGS=\"%d\"", ThreadState->BuildMetrics.NumberActWarnings);
                    }
                    strcat(szXMLBuffer, "/>");
                    XMLThreadWrite(ThreadState, szXMLBuffer);
                }
                XMLThreadCloseTag(ThreadState, "ACTION");
                PXMLThreadStates[ThreadState->XMLThreadIndex]->fXMLInAction = FALSE;
            }
            sprintf(szXMLBuffer, "ELAPSED=\"%s\" ACTIONS=\"%d\" ", FormatElapsedTime(dwStartTime), ThreadState->BuildMetrics.NumberDirActions);
            strcat(szXMLBuffer, XMLBuildMetricsString(&(ThreadState->BuildMetrics)));

            XMLThreadWrite(ThreadState, "<DIRSUMMARY %s/>", szXMLBuffer);
            XMLThreadCloseTag(ThreadState, "DIR");
            if (fXMLFragment) {
                LPSTR pszStart;
                PXMLTHREADSTATE XMLState = PXMLThreadStates[ThreadState->XMLThreadIndex];
                XMLScanBackTag(XMLState->XMLBuffer + XMLState->iXMLBufferPos, XMLState->XMLBuffer, &pszStart);
                XMLWriteDirFragmentFile(
                                       strlen(ThreadState->ChildCurrentDirectory) == 0 ? ".\\" : ThreadState->ChildCurrentDirectory,
                                       pszStart, XMLState->XMLBuffer + XMLState->iXMLBufferPos - pszStart);
            }
            XMLThreadReleaseBuffer(ThreadState);
            XMLUpdateEndTag(FALSE);

            XMLLeaveCriticalSection();
        }

        if (ThreadState->IsStdErrTty) {
            RestoreConsoleMode();
        }

        FreeMem(&ThreadState, MT_THREADSTATE);

        //
        // Signal completion
        //

        if (CurrentCompileDirDB && (CurrentCompileDirDB->DirFlags & DIRDB_SYNC_PRODUCES)) {
            PDEPENDENCY_WAIT Wait;
            PDEPENDENCY Dependency;
            PLIST_ENTRY List;
            PLIST_ENTRY WaitList;

            List = CurrentCompileDirDB->Produces.Flink;
            while (List != &CurrentCompileDirDB->Produces) {
                Dependency = CONTAINING_RECORD(List, DEPENDENCY, DependencyList);
                List = List->Flink;
                Dependency->Done = TRUE;
                SetEvent(Dependency->hEvent);
            }
        }

        return ( rc );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   WaitForParallelThreads
//
//  Synopsis:   Wait for all threads to finish before returning.
//
//----------------------------------------------------------------------------

VOID
WaitForParallelThreads(
                      IN PDIRREC Dir
                      )
{
    CheckAllConsumer(TRUE);
    if (fParallel) {
        WaitForMultipleObjects(ThreadsStarted,
                               WorkerThreads,
                               TRUE,
                               INFINITE);
        while (ThreadsStarted) {
            CloseHandle(WorkerThreads[--ThreadsStarted]);
            CloseHandle(WorkerEvents[ThreadsStarted]);
        }
        if (WorkerThreads != NULL) {
            FreeMem((VOID **) &WorkerThreads, MT_THREADHANDLES);
            FreeMem((VOID **) &WorkerEvents, MT_EVENTHANDLES);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ParallelChildStart
//
//  Synopsis:   Function that is run once for each thread.
//
//  Arguments:  [Data] -- Data given to CreateThread.
//
//----------------------------------------------------------------------------

DWORD
ParallelChildStart(
                  PPARALLEL_CHILD Data
                  )
{
    UINT OldErrorMode;
    UINT rc;
    DWORD dwStartTime = GetTickCount();
    PDIRREC DirDB;

    //
    // Disable child error popups
    //
    if (fClean) {
        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );
    }
    Data->ThreadState->ChildOutput = PipeSpawn(Data->ExecuteProgramCmdLine);

    if (fClean) {
        SetErrorMode(OldErrorMode);
    }

    //
    // Poke the event to indicate that the child process has
    // started and it is ok for the main thread to change
    // the current directory.
    //
    SetEvent(Data->Event);

    if (Data->ThreadState->ChildOutput==NULL) {
        BuildError(
                  "Exec of '%s' failed - errno = %d\r\n",
                  ExecuteProgramCmdLine,
                  errno);
    } else {
        FilterThread(Data->ThreadState);
        rc = PipeSpawnClose(Data->ThreadState->ChildOutput);
        if (rc == -1) {
            BuildError("Child terminate failed - errno = %d\r\n", errno);
        } else {
            if (rc) {
                BuildError("%s failed - rc = %d\r\n", Data->ExecuteProgramCmdLine, rc);
            }
        }
    }

    if (Data->ThreadState->IsStdErrTty) {
        RestoreConsoleMode();
    }

    if (fXMLOutput || fXMLFragment) {
        XMLEnterCriticalSection();
        AddBuildMetrics(&PassMetrics, &Data->ThreadState->BuildMetrics);

        if (PXMLThreadStates[Data->ThreadState->XMLThreadIndex]->fXMLInAction) {
            // check for action errors or warnings
            if (Data->ThreadState->BuildMetrics.NumberActErrors || Data->ThreadState->BuildMetrics.NumberActWarnings) {
                sprintf(szXMLBuffer, "<ACTIONSUMMARY ");
                if (Data->ThreadState->BuildMetrics.NumberActErrors) {
                    sprintf(szXMLBuffer + strlen(szXMLBuffer), " ERRORS=\"%d\"", Data->ThreadState->BuildMetrics.NumberActErrors);
                }
                if (Data->ThreadState->BuildMetrics.NumberActWarnings) {
                    sprintf(szXMLBuffer + strlen(szXMLBuffer), " WARNINGS=\"%d\"", Data->ThreadState->BuildMetrics.NumberActWarnings);
                }
                strcat(szXMLBuffer, "/>");
                XMLThreadWrite(Data->ThreadState, szXMLBuffer);
            }
            XMLThreadCloseTag(Data->ThreadState, "ACTION");
            PXMLThreadStates[Data->ThreadState->XMLThreadIndex]->fXMLInAction = FALSE;
        }
        sprintf(szXMLBuffer, "ELAPSED=\"%s\" ACTIONS=\"%d\" ", FormatElapsedTime(dwStartTime), Data->ThreadState->BuildMetrics.NumberDirActions);
        strcat(szXMLBuffer, XMLBuildMetricsString(&(Data->ThreadState->BuildMetrics)));

        XMLThreadWrite(Data->ThreadState, "<DIRSUMMARY %s/>", szXMLBuffer);
        XMLThreadCloseTag(Data->ThreadState, "DIR");
        if (fXMLFragment) {
            LPSTR pszStart;
            PXMLTHREADSTATE XMLState = PXMLThreadStates[Data->ThreadState->XMLThreadIndex];
            XMLScanBackTag(XMLState->XMLBuffer + XMLState->iXMLBufferPos, XMLState->XMLBuffer, &pszStart);
            XMLWriteDirFragmentFile(
                                   strlen(Data->ThreadState->ChildCurrentDirectory) == 0 ? ".\\" : Data->ThreadState->ChildCurrentDirectory,
                                   pszStart, XMLState->XMLBuffer + XMLState->iXMLBufferPos - pszStart);
        }
        XMLThreadReleaseBuffer(Data->ThreadState);
        XMLUpdateEndTag(FALSE);
        XMLLeaveCriticalSection();
    }

    //
    // Signal completion
    //
    DirDB=Data->ThreadState->CompileDirDB;

    if (DirDB &&
        (DirDB->DirFlags & DIRDB_SYNC_PRODUCES)) {
        PDEPENDENCY_WAIT Wait;
        PDEPENDENCY Dependency;
        PLIST_ENTRY List;
        PLIST_ENTRY WaitList;
        List = DirDB->Produces.Flink;
        while (List != &DirDB->Produces) {
            Dependency = CONTAINING_RECORD(List, DEPENDENCY, DependencyList);
            List = List->Flink;
            Dependency->Done = TRUE;
            SetEvent(Dependency->hEvent);
        }
    }

    FreeMem(&Data->ThreadState, MT_THREADSTATE);
    FreeMem(&Data, MT_CHILDDATA);
    return (rc);

}


//+---------------------------------------------------------------------------
//
//  Function:   ClearRows
//
//----------------------------------------------------------------------------

VOID
ClearRows(
         THREADSTATE *ThreadState,
         USHORT Top,
         USHORT NumRows,
         BYTE *Cell)
{
    COORD Coord;
    DWORD NumWritten;

    Coord.X = 0;
    Coord.Y = Top;

    FillConsoleOutputCharacter(
                              GetStdHandle(STD_ERROR_HANDLE),
                              Cell[0],
                              ThreadState->cColTotal * NumRows,
                              Coord,
                              &NumWritten);
    FillConsoleOutputAttribute(
                              GetStdHandle(STD_ERROR_HANDLE),
                              (WORD) Cell[1],
                              ThreadState->cColTotal * NumRows,
                              Coord,
                              &NumWritten);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetScreenSize
//
//----------------------------------------------------------------------------

VOID
GetScreenSize(THREADSTATE *ThreadState)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi)) {
        ThreadState->cRowTotal = 25;
        ThreadState->cColTotal = 80;
    } else {
        ThreadState->cRowTotal = csbi.srWindow.Bottom + 1;
        ThreadState->cColTotal = csbi.dwSize.X;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   GetCursorPosition
//
//----------------------------------------------------------------------------

VOID
GetCursorPosition(
                 USHORT *pRow,
                 USHORT *pCol,
                 USHORT *pRowTop)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
    *pRow = csbi.dwCursorPosition.Y;
    *pCol = csbi.dwCursorPosition.X;
    if (pRowTop != NULL) {
        *pRowTop = csbi.srWindow.Top;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SetCursorPosition
//
//----------------------------------------------------------------------------

VOID
SetCursorPosition(USHORT Row, USHORT Col)
{
    COORD Coord;

    Coord.X = Col;
    Coord.Y = Row;
    SetConsoleCursorPosition(GetStdHandle(STD_ERROR_HANDLE), Coord);
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteConsoleCells
//
//----------------------------------------------------------------------------

VOID
WriteConsoleCells(
                 LPSTR String,
                 USHORT StringLength,
                 USHORT Row,
                 USHORT Col,
                 BYTE *Attribute)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD NumWritten;
    WORD OldAttribute;
    COORD StartCoord;

    //
    // Get current default attribute and save it.
    //

    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    OldAttribute = csbi.wAttributes;

    //
    // Set the default attribute to the passed parameter, along with
    // the cursor position.
    //

    if ((BYTE) OldAttribute != *Attribute) {
        SetConsoleTextAttribute(
                               GetStdHandle(STD_ERROR_HANDLE),
                               (WORD) *Attribute);
    }

    StartCoord.X = Col;
    StartCoord.Y = Row;
    SetConsoleCursorPosition(GetStdHandle(STD_ERROR_HANDLE), StartCoord);

    //
    // Write the passed string at the current cursor position, using the
    // new default attribute.
    //

    WriteFile(
             GetStdHandle(STD_ERROR_HANDLE),
             String,
             StringLength,
             &NumWritten,
             NULL);

    //
    // Restore previous default attribute.
    //

    if ((BYTE) OldAttribute != *Attribute) {
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), OldAttribute);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   MoveRectangleUp
//
//----------------------------------------------------------------------------

VOID
MoveRectangleUp (
                USHORT Top,
                USHORT Left,
                USHORT Bottom,
                USHORT Right,
                USHORT NumRow,
                BYTE  *FillCell)
{
    SMALL_RECT ScrollRectangle;
    COORD DestinationOrigin;
    CHAR_INFO Fill;

    ScrollRectangle.Left = Left;
    ScrollRectangle.Top = Top;
    ScrollRectangle.Right = Right;
    ScrollRectangle.Bottom = Bottom;
    DestinationOrigin.X = Left;
    DestinationOrigin.Y = Top - NumRow;
    Fill.Char.AsciiChar = FillCell[0];
    Fill.Attributes = (WORD) FillCell[1];

    ScrollConsoleScreenBuffer(
                             GetStdHandle(STD_ERROR_HANDLE),
                             &ScrollRectangle,
                             NULL,
                             DestinationOrigin,
                             &Fill);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadConsoleCells
//
//----------------------------------------------------------------------------

VOID
ReadConsoleCells(
                BYTE *ScreenCell,
                USHORT cb,
                USHORT Row,
                USHORT Column)
{
    COORD BufferSize, BufferCoord;
    SMALL_RECT ReadRegion;
    CHAR_INFO CharInfo[1], *p;
    USHORT CountCells;

    CountCells = cb >> 1;
    assert(CountCells * sizeof(CHAR_INFO) <= sizeof(CharInfo));
    ReadRegion.Top = Row;
    ReadRegion.Left = Column;
    ReadRegion.Bottom = Row;
    ReadRegion.Right = Column + CountCells - 1;
    BufferSize.X = 1;
    BufferSize.Y = CountCells;
    BufferCoord.X = 0;
    BufferCoord.Y = 0;
    ReadConsoleOutput(
                     GetStdHandle(STD_ERROR_HANDLE),
                     CharInfo,
                     BufferSize,
                     BufferCoord,
                     &ReadRegion);

    p = CharInfo;
    while (CountCells--) {
        *ScreenCell++ = p->Char.AsciiChar;
        *ScreenCell++ = (BYTE) p->Attributes;
        p++;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ClearLine
//
//----------------------------------------------------------------------------

VOID
ClearLine(VOID)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    COORD Coord;
    DWORD   NumWritten;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    Coord.Y = csbi.dwCursorPosition.Y;
    Coord.X = csbi.dwCursorPosition.X = 0;
    FillConsoleOutputCharacter(
                              GetStdHandle(STD_ERROR_HANDLE),
                              ' ',
                              csbi.dwSize.X,
                              csbi.dwCursorPosition,
                              &NumWritten);

    SetConsoleCursorPosition(GetStdHandle(STD_ERROR_HANDLE), Coord);
    fLineCleared = TRUE;
}


// PipeSpawn variables.  We can get away with one copy per thread.

__declspec(thread) HANDLE ProcHandle;
__declspec(thread) FILE *pstream;

//+---------------------------------------------------------------------------
//
//  Function:   PipeSpawn (similar to _popen)
//
//----------------------------------------------------------------------------

FILE *
PipeSpawn (
          const CHAR *cmdstring
          )
{
    int PipeHandle[2];
    HANDLE WriteHandle, ErrorHandle;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL Status;
    char CmdLine[1024];

    if (cmdstring == NULL)
        return (NULL);

    // Open the pipe where we'll collect the output.

    _pipe(PipeHandle, 1024, _O_BINARY|_O_NOINHERIT);

    DuplicateHandle(GetCurrentProcess(),
                    (HANDLE)_get_osfhandle((LONG)PipeHandle[1]),
                    GetCurrentProcess(),
                    &WriteHandle,
                    0L,
                    TRUE,
                    DUPLICATE_SAME_ACCESS);

    DuplicateHandle(GetCurrentProcess(),
                    (HANDLE)_get_osfhandle((LONG)PipeHandle[1]),
                    GetCurrentProcess(),
                    &ErrorHandle,
                    0L,
                    TRUE,
                    DUPLICATE_SAME_ACCESS);

    _close(PipeHandle[1]);

    pstream = _fdopen(PipeHandle[0], "rb" );
    if (!pstream) {
        CloseHandle(WriteHandle);
        CloseHandle(ErrorHandle);
        _close(PipeHandle[0]);
        return (NULL);
    }

    strcpy(CmdLine, cmdexe);
    strcat(CmdLine, " /c ");
    strcat(CmdLine, cmdstring);

    memset(&StartupInfo, 0, sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);

    StartupInfo.hStdOutput = WriteHandle;
    StartupInfo.hStdError = ErrorHandle;
    StartupInfo.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    StartupInfo.dwFlags = STARTF_USESTDHANDLES;

    memset(&ProcessInformation, 0, sizeof(PROCESS_INFORMATION));

    // And start the process.

    Status = CreateProcess(cmdexe, CmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &StartupInfo, &ProcessInformation);

    CloseHandle(WriteHandle);
    CloseHandle(ErrorHandle);
    CloseHandle(ProcessInformation.hThread);

    if (!Status) {
        fclose(pstream);        // This will close the read handle
        pstream = NULL;
        ProcHandle = NULL;
    } else {
        ProcHandle = ProcessInformation.hProcess;
    }

    return (pstream);
}


//+---------------------------------------------------------------------------
//
//  Function:   PipeSpawnClose (similar to _pclose)
//
//----------------------------------------------------------------------------

DWORD
PipeSpawnClose (
               FILE *pstream
               )
{
    DWORD retval = 0;   /* return value (to caller) */

    if ( pstream == NULL) {
        return retval;
    }

    (void)fclose(pstream);

    if ( WaitForSingleObject(ProcHandle, (DWORD) -1L) == 0) {
        GetExitCodeProcess(ProcHandle, &retval);
    }
    CloseHandle(ProcHandle);

    return (retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\buildinc.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994.
//
//  File:       buildinc.c
//
//  Contents:   This is the checking include module for the NT Build Tool (BUILD.EXE)
//
//              Used for detecting the includes that do not satisfy the acceptable
//              patterns.
//
//  History:    see SLM
//----------------------------------------------------------------------------

#include "build.h"

//+---------------------------------------------------------------------------
//
//  Function:   FoundCountedSequenceInString
//
//  Synopsis:   Roughly equivalent to "strstr" except that the substring doesn't
//              have to be NULL-terminated.
//
//  Arguments:  [String]   -- null-terminated string to search
//              [Sequence] -- string to search for
//              [Length]   -- the length of the sequence
//----------------------------------------------------------------------------

LPCTSTR
FindCountedSequenceInString(
                           IN LPCTSTR String,
                           IN LPCTSTR Sequence,
                           IN DWORD   Length
                           )
{

    assert( Sequence );
    assert( String );

    if ( Length > 0 ) {

        while ( *String ) {

            while (( *String ) && ( *String != *Sequence )) {
                String++;
            }

            if ( *String ) {

                LPCTSTR SubString   = String   + 1;
                LPCTSTR SubSequence = Sequence + 1;
                DWORD   Remaining   = Length   - 1;

                while (( Remaining ) && ( *SubString++ == *SubSequence++ )) {
                    Remaining--;
                }

                if ( Remaining == 0 ) {
                    return String;
                }

                String++;
            }
        }

        return NULL;
    }

    return String;
}


//+---------------------------------------------------------------------------
//
//  Function:   DoesInstanceMatchPattern
//
//  Synopsis:   Returns TRUE if pattern matches instance.
//              Wildcards:
//              * matches any text
//              ? matches any and exactly one character
//              # matches any text up to backslash character or end of string
//
//  Arguments:  [Instance] -- the string to be matched
//              [Pattern]  -- the pattern
//----------------------------------------------------------------------------

BOOL
DoesInstanceMatchPattern(
                        IN LPCTSTR Instance,
                        IN LPCTSTR Pattern
                        )
{

    assert( Instance );
    assert( Pattern );

    while ( *Pattern ) {

        if ( *Pattern == TEXT('*')) {

            Pattern++;

            while ( *Pattern == TEXT('*')) {    // skip multiple '*' characters
                Pattern++;
            }

            if ( *Pattern == 0 ) {      // '*' at end of pattern matches rest
                return TRUE;
            }

            if ( *Pattern == '?' ) {    // '?' following '*'

                //
                //  Expensive because we have to restart match for every
                //  character position remaining since '?' can match anything.
                //

                while ( *Instance ) {

                    if ( DoesInstanceMatchPattern( Instance, Pattern )) {
                        return TRUE;
                    }

                    Instance++;
                }

                return FALSE;
            }

            else {

                //
                //  Now we know that next character in pattern is a regular
                //  character to be matched.  Find out the length of that
                //  string to the next wildcard or end of string.
                //

                LPCTSTR NextWildCard = Pattern + 1;
                DWORD   MatchLength;

                while (( *NextWildCard ) && ( *NextWildCard != TEXT('*')) && ( *NextWildCard != TEXT('?')) && ( *NextWildCard != TEXT('#'))) {
                    NextWildCard++;
                }

                MatchLength = (DWORD)(NextWildCard - Pattern);   // always non-zero

                //
                //  Now try to match with any instance of substring in pattern
                //  found in the instance.
                //

                Instance = FindCountedSequenceInString( Instance, Pattern, MatchLength );

                while ( Instance ) {

                    if ( DoesInstanceMatchPattern( Instance + MatchLength, NextWildCard )) {
                        return TRUE;
                    }

                    Instance = FindCountedSequenceInString( Instance + 1, Pattern, MatchLength );
                }

                return FALSE;
            }
        }

        else if ( *Pattern == TEXT('#')) {

            //
            //  Match text up to backslash character or end of string
            //

            Pattern++;

            while (( *Instance != 0 ) && ( *Instance != '\\' )) {
                Instance++;
            }

            continue;
        }

        else if ( *Pattern == TEXT('?')) {

            if ( *Instance == 0 ) {
                return FALSE;
            }
        }

        else if ( *Pattern != *Instance ) {

            return FALSE;
        }

        Pattern++;
        Instance++;
    }

    return ( *Instance == 0 );
}


//+---------------------------------------------------------------------------
//
//  Function:   CombinePaths
//
//  Synopsis:   Combine two strings to get a full path.
//
//  Arguments:  [ParentPath] -- head path
//              [ChildPath]  -- path to be added
//              [TargetPath] -- full path
//----------------------------------------------------------------------------

LPSTR
CombinePaths(
            IN  LPCSTR ParentPath,
            IN  LPCSTR ChildPath,
            OUT LPSTR  TargetPath   // can be same as ParentPath if want to append
            )
{

    ULONG ParentLength = strlen( ParentPath );
    LPSTR p;

    assert( ParentPath );
    assert( ChildPath );

    if ( ParentPath != TargetPath ) {
        memcpy( TargetPath, ParentPath, ParentLength );
    }

    p = TargetPath + ParentLength;

    if (( ParentLength > 0 )   &&
        ( *( p - 1 ) != '\\' ) &&
        ( *( p - 1 ) != '/'  )) {
        *p++ = '\\';
    }

    strcpy( p, ChildPath );

    return TargetPath;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateRelativePath
//
//  Synopsis:   Determine the "canonical" path of one file relative to
//              another file
//
//  Arguments:  [SourceAbsName] -- absolute path of the source file
//              [TargetAbsName] -- absolute path of the target file
//              [RelativePath]  -- resulted relative path
//----------------------------------------------------------------------------

VOID
CreateRelativePath(
                  IN  LPCSTR SourceAbsName,    // must be lowercase
                  IN  LPCSTR TargetAbsName,    // must be lowercase
                  OUT LPSTR  RelativePath      // must be large enough
                  )
{

    //
    //  First, walk through path components that match in Source and Target.
    //  For example:
    //
    //      d:\nt\private\ntos\dd\efs.h
    //      d:\nt\private\windows\base\ntcrypto\des.h
    //                    ^
    //                    This is where the relative path stops going up (..)
    //                    and starts going back down.
    //
    //  So, the "cannonical" relative path generated should look like:
    //
    //      ..\..\..\windows\base\ntcrypto\des.h
    //
    //  For relative includes that are "below" the includer in the path should
    //  look like this:
    //
    //      .\foo\bar\foobar.h
    //

    LPCSTR Source = SourceAbsName;
    LPCSTR Target = TargetAbsName;
    LPSTR Output = RelativePath;
    ULONG PathSeparatorIndex;
    BOOL  AnyParent;
    ULONG i;

    assert( SourceAbsName );
    assert( TargetAbsName );

    PathSeparatorIndex = 0;

    i = 0;

    //
    //  Scan forward to first non-matching character, and keep track of
    //  most recent path separator character.
    //

    while (( Source[ i ] == Target[ i ] ) && ( Source[ i ] != 0 )) {

        if ( Source[ i ] == '\\' ) {
            PathSeparatorIndex = i;
        }

        ++i;
    }

    //
    //  Coming out of this loop, there are 2 possibilities:
    //
    //       1) Found common ancestor path ( *PathSeparatorIndex == '\\' )
    //       2) Don't have common ancestor ( *PathSeparatorIndex != '\\' )
    //

    if ( Source[ PathSeparatorIndex ] != '\\' ) {
        strcpy( RelativePath, TargetAbsName );
        return;
    }

    i = PathSeparatorIndex + 1;

    //
    //  Now continue to walk down source path and insert a "..\" in the result
    //  for each path separator encountered.
    //

    AnyParent = FALSE;

    while ( Source[ i ] != 0 ) {

        if ( Source[ i ] == '\\' ) {

            AnyParent = TRUE;
            *Output++ = '.';
            *Output++ = '.';
            *Output++ = '\\';
        }

        ++i;
    }

    if ( ! AnyParent ) {

        //
        //  Relative path is below current directory.
        //

        *Output++ = '.';
        *Output++ = '\\';
    }


    //
    //  Now we simply append what's remaining of the Target path from the
    //  ancestor match point.
    //

    strcpy( Output, Target + PathSeparatorIndex + 1 );
}


//+---------------------------------------------------------------------------
//
//  Function:   ShouldWarnInclude
//
//  Synopsis:   Returns true if the name of the included file matches a
//              BUILD_UNACCEPTABLE_INCLUDES pattern or it does not match
//              any of the patterns specified in BUILD_ACCEPTABLE_INCLUDES.
//
//  Arguments:  [CompilandFullName] -- name of the including file
//              [IncludeeFullName]  -- name of the included file
//----------------------------------------------------------------------------

BOOL
ShouldWarnInclude(
                 IN LPCSTR CompilandFullName,
                 IN LPCSTR IncludeeFullName
                 )
{
    UINT i;
    CHAR IncludeeRelativeName[ MAX_PATH ];


    assert( CompilandFullName );
    assert( IncludeeFullName );

    CreateRelativePath( CompilandFullName, IncludeeFullName, IncludeeRelativeName );

    //
    //  First we check for a match against any unacceptable include path
    //  because we always want to warn about these.
    //

    for ( i = 0; UnacceptableIncludePatternList[ i ] != NULL; i++ ) {

        if ( DoesInstanceMatchPattern( IncludeeFullName, UnacceptableIncludePatternList[ i ] )) {
            return TRUE;
        }

        if ( DoesInstanceMatchPattern( IncludeeRelativeName, UnacceptableIncludePatternList[ i ] )) {
            return TRUE;
        }
    }

    //
    //  If we get to here, the include path was not explicitly unacceptable, so
    //  we now want to see if it matches any acceptable paths.  But, if no
    //  acceptable paths are specified, we don't want to warn.
    //

    if ( AcceptableIncludePatternList[ 0 ] == NULL ) {
        return FALSE;
    }

    for ( i = 0; AcceptableIncludePatternList[ i ] != NULL; i++ ) {

        if ( DoesInstanceMatchPattern( IncludeeFullName, AcceptableIncludePatternList[ i ] )) {
            return FALSE;
        }

        if ( DoesInstanceMatchPattern( IncludeeRelativeName, AcceptableIncludePatternList[ i ] )) {
            return FALSE;
        }
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckIncludeForWarning
//
//  Synopsis:   Warnings if the dependency does not respect the
//              BUILD_UNACCEPTABLE_INCLUDES or BUILD_ACCEPTABLE_INCLUDES
//              restristions. Works with build -#.
//
//  Arguments:  [CompilandDir]
//              [CompilandName]
//              [IncluderDir]
//              [IncluderName]
//              [IncludeeDir]
//              [IncludeeName]
//----------------------------------------------------------------------------

VOID
CheckIncludeForWarning(
                      IN LPCSTR CompilandDir,
                      IN LPCSTR CompilandName,
                      IN LPCSTR IncluderDir,
                      IN LPCSTR IncluderName,
                      IN LPCSTR IncludeeDir,
                      IN LPCSTR IncludeeName
                      )
{

    CHAR CompilandFullName[ MAX_PATH ];
    CHAR IncluderFullName[ MAX_PATH ];
    CHAR IncludeeFullName[ MAX_PATH ];

    assert( CompilandDir );
    assert( CompilandName );
    assert( IncluderDir );
    assert( IncluderName );
    assert( IncludeeDir );
    assert( IncludeeName );

    CombinePaths( CompilandDir, CompilandName, CompilandFullName );
    CombinePaths( IncluderDir,  IncluderName,  IncluderFullName  );
    CombinePaths( IncludeeDir,  IncludeeName,  IncludeeFullName  );

    _strlwr( CompilandFullName );
    _strlwr( IncluderFullName );
    _strlwr( IncludeeFullName );

    if ( IncFile ) {
        fprintf(
               IncFile,
               "%s includes %s\r\n",
               IncluderFullName,
               IncludeeFullName
               );
    }

    if ( ShouldWarnInclude( CompilandFullName, IncludeeFullName )) {

        if ( strcmp( IncluderFullName, CompilandFullName ) == 0 ) {

            if ( WrnFile ) {

                fprintf(
                       WrnFile,
                       "WARNING: %s includes %s\n",
                       CompilandFullName,
                       IncludeeFullName
                       );
            }

            if ( fShowWarningsOnScreen ) {

                BuildMsgRaw(
                           "WARNING: %s includes %s\n",
                           CompilandFullName,
                           IncludeeFullName
                           );
            }
        }

        else {

            if ( WrnFile ) {

                fprintf(
                       WrnFile,
                       "WARNING: %s includes %s through %s\n",
                       CompilandFullName,
                       IncludeeFullName,
                       IncluderFullName
                       );
            }

            if ( fShowWarningsOnScreen ) {

                BuildMsgRaw(
                           "WARNING: %s includes %s through %s\n",
                           CompilandFullName,
                           IncludeeFullName,
                           IncluderFullName
                           );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\builddb.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994
//
//  File:       builddb.c
//
//  Contents:   Contains the file and directory database manipulation
//              functions.
//
//  History:    16-May-94     SteveWo  Created
//                 ... see SLM logs
//              26-Jul-94     LyleC    Cleanup/Add Pass0 Support
//
//----------------------------------------------------------------------------

#include "build.h"

BOOL fAssertCleanTree = FALSE;

typedef struct _FLAGSTRINGS {
    ULONG Mask;
    LPSTR pszName;
} FLAGSTRINGS;

FLAGSTRINGS DirFlags[] = {
    { DIRDB_SOURCES,          "Sources"},
    { DIRDB_DIRS,             "Dirs"},
    { DIRDB_MAKEFILE,         "Makefile"},
    { DIRDB_MAKEFIL0,           "Makefil0"},
    { DIRDB_TARGETFILE0,        "Targetfile0"},
    { DIRDB_TARGETFILES,        "Targetfiles"},
    { DIRDB_RESOURCE,           "Resource"},
    { DIRDB_PASS0,              "PassZero"},
    { DIRDB_SOURCES_SET,        "SourcesSet"},
    { DIRDB_CHICAGO_INCLUDES,   "ChicagoIncludes"},
    { DIRDB_NEW,                "New"},
    { DIRDB_SCANNED,            "Scanned"},
    { DIRDB_SHOWN,              "Shown"},
    { DIRDB_GLOBAL_INCLUDES,    "GlobalIncludes"},
    { DIRDB_SYNCHRONIZE_BLOCK,  "SynchronizeBlock"},
    { DIRDB_SYNCHRONIZE_PASS2_BLOCK,  "SynchronizePass2Block"},
    { DIRDB_SYNCHRONIZE_DRAIN,  "SynchronizeDrain"},
    { DIRDB_SYNCHRONIZE_PASS2_DRAIN,  "SynchronizePass2Drain"},
    { DIRDB_COMPILENEEDED,      "CompileNeeded"},
    { DIRDB_COMPILEERRORS,      "CompileErrors"},
    { DIRDB_SOURCESREAD,        "SourcesRead"},
    { DIRDB_DLLTARGET,          "DllTarget"},
    { DIRDB_LINKNEEDED,         "LinkNeeded"},
    { DIRDB_FORCELINK,          "ForceLink"},
    { DIRDB_PASS0NEEDED,        "Pass0Needed"},
    { DIRDB_MAKEFIL1,           "Makefil1"},
    { DIRDB_CHECKED_ALT_DIR,    "CheckedAltDir"},
    { DIRDB_MANAGED_CODE,       "ManagedCode"},
    { DIRDB_SYNC_PRODUCES,      "BuildProduces"},
    { DIRDB_SYNC_CONSUMES,      "BuildConsumes"},
    { 0,                        NULL},
};

FLAGSTRINGS FileFlags[] = {
    { FILEDB_SOURCE,            "Source"},
    { FILEDB_DIR,               "Dir"},
    { FILEDB_HEADER,            "Header"},
    { FILEDB_ASM,               "Asm"},
    { FILEDB_MASM,              "Masm"},
    { FILEDB_RC,                "Rc"},
    { FILEDB_C,                 "C"},
    { FILEDB_MIDL,              "Midl"},
    { FILEDB_ASN,               "Asn"},
    { FILEDB_JAVA,              "Java"},
    { FILEDB_MOF,               "ManagedObjectFormat"},
    { FILEDB_CSHARP,            "C#"},
    { FILEDB_SCANNED,           "Scanned"},
    { FILEDB_OBJECTS_LIST,      "ObjectsList"},
    { FILEDB_FILE_MISSING,      "FileMissing"},
    { FILEDB_MKTYPLIB,          "MkTypeLib"},
    { FILEDB_MULTIPLEPASS,      "MultiplePass"},
    { FILEDB_PASS0,             "PassZero"},
    { FILEDB_VBP,               "VB"},
    { FILEDB_VB_NET,            "VB.NET"},
    { 0,                        NULL},
};

FLAGSTRINGS IncludeFlags[] = {
    { INCLUDEDB_LOCAL,        "Local"},
    { INCLUDEDB_POST_HDRSTOP,   "PostHdrStop"},
    { INCLUDEDB_MISSING,        "Missing"},
    { INCLUDEDB_GLOBAL,         "Global"},
    { INCLUDEDB_SNAPPED,        "Snapped"},
    { INCLUDEDB_CYCLEALLOC,     "CycleAlloc"},
    { INCLUDEDB_CYCLEROOT,      "CycleRoot"},
    { INCLUDEDB_CYCLEORPHAN,    "CycleOrphan"},
    { 0,                        NULL},
};

FLAGSTRINGS SourceFlags[] = {
    { SOURCEDB_SOURCES_LIST,    "SourcesList"},
    { SOURCEDB_FILE_MISSING,    "FileMissing"},
    { SOURCEDB_PCH,             "Pch"},
    { SOURCEDB_OUT_OF_DATE,     "OutOfDate"},
    { SOURCEDB_COMPILE_NEEDED,  "CompileNeeded"},
    { 0,                        NULL},
};

//
// Function prototypes
//

VOID
FreeFileDB(PFILEREC *FileDB);

VOID
PrintFlags(FILE *pf, ULONG Flags, FLAGSTRINGS *pfs);


//+---------------------------------------------------------------------------
//
//  Function:   CheckSum
//
//  Synopsis:   Returns a checksum value for a string.
//
//----------------------------------------------------------------------------

USHORT
CheckSum(LPSTR psz)
{
    USHORT sum = 0;

    while (*psz != '\0') {
        if (sum & 0x8000) {
            sum = ((sum << 1) | 1) + *psz++;
        } else {
            sum = (sum << 1) + *psz++;
        }
    }
    return (sum);
}


//+---------------------------------------------------------------------------
//
//  Function:   FindSourceDirDB
//
//  Synopsis:   Builds a path from the two given components and returns
//              a filled DIRREC structure from it.
//
//  Arguments:  [pszDir]            -- Directory
//              [pszRelPath]        -- Path relative to [pszDir]
//              [fTruncateFileName] -- Remove a filename from [pszRelPath]
//
//  Returns:    A filled DIRREC structure for the given directory.
//
//  Notes:      If the directory does not exist in the data base, then a
//              DIRREC structure will be returned with the DIRDB_NEW flag
//              set and no other data (i.e.  the directory will not have
//              been scanned.)
//
//----------------------------------------------------------------------------

DIRREC *
FindSourceDirDB(
               LPSTR pszDir,               // directory
               LPSTR pszRelPath,           // relative path
               BOOL fTruncateFileName)     // TRUE: drop last component of path
{
    LPSTR pszFile;
    char path[DB_MAX_PATH_LENGTH] = {0};

    AssertPathString(pszDir);
    AssertPathString(pszRelPath);

    if ((strlen(pszDir) + sizeof("\\") + strlen(pszRelPath) + 1) > DB_MAX_PATH_LENGTH) {
        BuildError(
                  "%s\\%s : Path too long - need to rebuild build.exe with larger DB_MAX_PATH_LENGTH\n",
                  pszDir,
                  pszRelPath);
        return NULL;
    }

    if (pszDir[0] == '\0') {
        strncpy( path, pszRelPath, sizeof(path) - 1 );
    } else {
        _snprintf(path, sizeof(path) - 1, "%s\\%s", pszDir, pszRelPath);
    }

    pszFile = path + strlen(path);
    if (fTruncateFileName) {
        while (pszFile > path) {
            pszFile--;
            if (*pszFile == '\\' || *pszFile == '/') {
                *pszFile = '\0';
                break;
            }
        }
    }
    if (!CanonicalizePathName(path, CANONICALIZE_ONLY, path)) {
        return (NULL);
    }
    if (DEBUG_4) {
        BuildMsgRaw(
                   "FindSourceDirDB(%s, %s, %u)\n",
                   path,
                   pszFile,
                   fTruncateFileName);
    }
    AssertPathString(path);
    return (LoadDirDB(path));
}


//+---------------------------------------------------------------------------
//
//  Function:   FindSourceFileDB
//
//  Synopsis:   Returns a FILEREC with information about the given file.
//
//  Arguments:  [pdr]        -- DIRREC giving directory from which to start
//                                looking for [pszRelPath]
//              [pszRelPath] -- Relative path from [pdr] of the file
//              [ppdr]       -- [out] DIRREC of directory actually containing
//                                the file.  Can be NULL.
//
//  Returns:    FILEREC for file of interest.
//
//  Notes:      If the directory containing the file has not yet been scanned,
//              then it will be scanned using ScanDirectory().
//
//----------------------------------------------------------------------------

FILEREC *
FindSourceFileDB(
                DIRREC *pdr,
                LPSTR pszRelPath,
                DIRREC **ppdr)
{
    LPSTR p, pszFile;

    AssertPathString(pszRelPath);

    if (strchr(pszRelPath, '\\') != NULL) {
        // There's a path component in this filename.  Let's see where it points to.
        if ( (pszRelPath[0] == '\\') ||   /* Absolute from root or UNC Path */
             (pszRelPath[1] == ':' )) {     /* drive : path  */
            pdr = FindSourceDirDB("", pszRelPath, TRUE);
        } else {
            pdr = FindSourceDirDB(pdr->Name, pszRelPath, TRUE);
        }
    }
    if (ppdr != NULL) {
        *ppdr = pdr;
    }
    if (pdr == NULL ) {
        return (NULL);
    }
    pszFile = pszRelPath;
    for (p = pszFile; *p != '\0'; p++) {
        if (*p == '\\') {
            pszFile = p + 1;
        }
    }
    if (DEBUG_4) {
        BuildMsgRaw("FindSourceFileDB(%s, %s)\n", pdr->Name, pszFile);
    }

    //
    // Scan the directory containing the file if we haven't already.
    //
    if ((pdr->DirFlags & DIRDB_SCANNED) == 0) {
        if (DEBUG_1) {
            BuildMsgRaw(
                       "FindSourceFileDB(%s, %s) Delayed scan\n",
                       pdr->Name,
                       pszFile);
        }
        pdr = ScanDirectory(pdr->Name);
        if (pdr == NULL) {
            return (NULL);
        }
    }

    return (LookupFileDB(pdr, pszFile));
}


//+---------------------------------------------------------------------------
//
//  Function:   InsertSourceDB
//
//  Synopsis:   Insert a file listed in SOURCES= into a list of SOURCEREC
//              structures.
//
//  Arguments:  [ppsrNext]   -- Head of list of sources files to add to.
//              [pfr]        -- File to be inserted.
//              [SubDirMask] -- Indicates what directory the file is in.
//                                 (Current, Parent, or a machine-specific dir)
//              [SrcFlags]   -- SOURCEDB flags appropriate to this file.
//
//  Returns:    SOURCEREC that was inserted. May be ignored.
//
//  Notes:      InsertSourceDB maintains a sort order for PickFirst() based
//              first on the filename extension, then on the subdirectory
//              mask.
//
//              Two exceptions to the alphabetic sort are:
//                   - No extension sorts last.
//                   - .rc extension sorts first.
//
//              If the file is already in the list of sources then this
//              function just updates the flags and returns.
//
//----------------------------------------------------------------------------

SOURCEREC *
InsertSourceDB(
              SOURCEREC **ppsrNext,
              FILEREC *pfr,
              UCHAR SubDirMask,
              UCHAR SrcFlags)
{
    SOURCEREC *psr;
    SOURCEREC **ppsrInsert;
    LPSTR pszext;
    BOOL fRC;

    AssertFile(pfr);

    ppsrInsert = NULL;
    pszext = strrchr(pfr->Name, '.');
    fRC = FALSE;
    if (pszext != NULL && _stricmp(pszext, ".rc") == 0) {
        fRC = TRUE;
    }
    for ( ; (psr = *ppsrNext) != NULL; ppsrNext = &psr->psrNext) {
        LPSTR p;
        int r;

        AssertSource(psr);
        if (psr->pfrSource == pfr) {
            assert(psr->SourceSubDirMask == SubDirMask);
            psr->SrcFlags = SrcFlags;
            return (psr);
        }
        if (ppsrInsert == NULL && pszext != NULL) {
            if ((p = strrchr(psr->pfrSource->Name, '.')) == NULL) {
                r = -1;                 // insert new file here
            } else {
                r = strcmp(pszext, p);
                if (r != 0) {
                    if (fRC) {
                        r = -1;         // insert new RC file here
                    } else if (strcmp(p, ".rc") == 0) {
                        r = 1;          // old RC file comes first
                    }
                }
            }
            if (r < 0 || SubDirMask > psr->SourceSubDirMask) {
                ppsrInsert = ppsrNext;
            }
        }
    }
    AllocMem(sizeof(SOURCEREC), &psr, MT_SOURCEDB);
    memset(psr, 0, sizeof(*psr));
    SigCheck(psr->Sig = SIG_SOURCEREC);

    if (ppsrInsert != NULL) {
        ppsrNext = ppsrInsert;
    }
    psr->psrNext = *ppsrNext;
    *ppsrNext = psr;

    psr->pfrSource = pfr;
    pfr->FileFlags |= FILEDB_SOURCEREC_EXISTS;
    psr->SourceSubDirMask = SubDirMask;
    psr->SrcFlags = SrcFlags;
    return (psr);
}


//+---------------------------------------------------------------------------
//
//  Function:   FindSourceDB
//
//  Synopsis:   Finds the SOURCEREC in a list which corresponds to the given
//              FILEREC.
//
//----------------------------------------------------------------------------

SOURCEREC *
FindSourceDB(
            SOURCEREC *psr,
            FILEREC *pfr)
{

    while (psr != NULL) {
        AssertSource(psr);
        if (psr->pfrSource == pfr) {
            return (psr);
        }
        psr = psr->psrNext;
    }
    return (NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeSourceDB
//
//  Synopsis:   Frees a list of SOURCERECs
//
//  Arguments:  [ppsr] -- List to free
//
//----------------------------------------------------------------------------

VOID
FreeSourceDB(SOURCEREC **ppsr)
{
    if (*ppsr != NULL) {
        SOURCEREC *psr;
        SOURCEREC *psrNext;

        psr = *ppsr;
        AssertSource(psr);
        psrNext = psr->psrNext;
        SigCheck(psr->Sig = 0);
        FreeMem(ppsr, MT_SOURCEDB);
        *ppsr = psrNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeIncludeDB
//
//----------------------------------------------------------------------------

VOID
FreeIncludeDB(INCLUDEREC **ppir)
{
    if (*ppir != NULL) {
        INCLUDEREC *pir;
        INCLUDEREC *pirNext;

        pir = *ppir;
        AssertInclude(pir);
        AssertCleanTree(pir, NULL);      // Tree must be clean
        pirNext = pir->Next;
        SigCheck(pir->Sig = 0);
        FreeMem(ppir, MT_INCLUDEDB);
        *ppir = pirNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeFileDB
//
//----------------------------------------------------------------------------

VOID
FreeFileDB(FILEREC **ppfr)
{
    if (*ppfr != NULL) {
        FILEREC *pfr;
        FILEREC *pfrNext;

        pfr = *ppfr;
        AssertFile(pfr);
        UnsnapIncludeFiles(pfr, TRUE);
        while (pfr->IncludeFiles) {
            FreeIncludeDB(&pfr->IncludeFiles);
        }
        pfrNext = pfr->Next;
        SigCheck(pfr->Sig = 0);
        FreeMem(ppfr, MT_FILEDB);
        *ppfr = pfrNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeDirDB
//
//----------------------------------------------------------------------------

VOID
FreeDirDB(DIRREC **ppdr)
{
    if (*ppdr != NULL) {
        DIRREC *pdr;
        DIRREC *pdrNext;

        pdr = *ppdr;
        AssertDir(pdr);
        FreeDirData(pdr);
        while (pdr->Files) {
            FreeFileDB(&pdr->Files);
        }
        pdrNext = pdr->Next;
        SigCheck(pdr->Sig = 0);
        FreeMem(ppdr, MT_DIRDB);
        *ppdr = pdrNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeAllDirs
//
//----------------------------------------------------------------------------

VOID
FreeAllDirs(VOID)
{
    while (AllDirs != NULL) {
        FreeDirDB(&AllDirs);
#if DBG
        if (fDebug & 8) {
            BuildMsgRaw("Freed one directory\n");
            PrintAllDirs();
        }
#endif
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupDirDB
//
//  Synopsis:   Searches the database for a given directory.
//
//  Arguments:  [DirName] -- Directory to search for.
//
//  Returns:    DIRREC of the given directory.  NULL if not found.
//
//  Notes:      If the directory is not in the database it will not be added.
//              Use LoadDirDB in this case.
//
//----------------------------------------------------------------------------

PDIRREC
LookupDirDB(
           LPSTR DirName
           )
{
    PDIRREC *DirDBNext = &AllDirs;
    PDIRREC DirDB;
    USHORT sum;

    AssertPathString(DirName);
    sum = CheckSum(DirName);
    while (DirDB = *DirDBNext) {
        if (sum == DirDB->CheckSum && strcmp(DirName, DirDB->Name) == 0) {

            if (DirDB->FindCount == 0 && fForce) {
                FreeDirDB(DirDBNext);
                return (NULL);
            }
            DirDB->FindCount++;

            // Move to head of list to make next lookup faster

            // *DirDBNext = DirDB->Next;
            // DirDB->Next = AllDirs;
            // AllDirs = DirDB;

            return (DirDB);
        }
        DirDBNext = &DirDB->Next;
    }
    return (NULL);
}


PDIRREC
CreateNewDirDB(
              LPSTR DirName

              )
{
    PDIRREC DirDB;

    AllocMem(sizeof(DIRREC) + strlen(DirName), &DirDB, MT_DIRDB);
    memset(DirDB, 0, sizeof(*DirDB));
    SigCheck(DirDB->Sig = SIG_DIRREC);
    CopyString(DirDB->Name, DirName, TRUE);
    DirDB->CheckSum = CheckSum(DirDB->Name);
    InitializeListHead(&DirDB->Produces);
    InitializeListHead(&DirDB->Consumes);
    return ( DirDB );
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadDirDB
//
//  Synopsis:   Searches the database for a directory name, and if not found
//              creates a new DIRREC entry in the database.
//
//  Arguments:  [DirName] -- Directory to search for.
//
//  Returns:    Filled in DIRREC structure for the given directory.
//
//  Notes:      The directory will not be scanned if it wasn't in the
//              database.  Use ScanDirectory to scan the directory,
//              however, note that InsertSourceDB will automatically scan
//              the directory only when necessary.
//
//----------------------------------------------------------------------------

PDIRREC
LoadDirDB(
         LPSTR DirName
         )
{
    UINT i;
    PDIRREC DirDB, *DirDBNext;
    LPSTR s;

    AssertPathString(DirName);
    if (DirDB = LookupDirDB(DirName)) {
        return (DirDB);
    }

    if (ProbeFile(NULL, DirName) == -1) {
        return ( NULL );
    }

    DirDBNext = &AllDirs;
    while (DirDB = *DirDBNext) {
        DirDBNext = &DirDB->Next;
    }

    AllDirsModified = TRUE;

    DirDB = CreateNewDirDB(DirName);
    DirDB->DirFlags = DIRDB_NEW;
    DirDB->FindCount = 1;

    if (DEBUG_1) {
        BuildMsgRaw("LoadDirDB creating %s\n", DirDB->Name);
    }

    *DirDBNext = DirDB;
    return ( DirDB );
}

//+---------------------------------------------------------------------------
//
//  Debug helper functions to print parts of the database.
//
//----------------------------------------------------------------------------

#if DBG
VOID
PrintAllDirs(VOID)
{
    DIRREC **ppdr, *pdr;

    for (ppdr = &AllDirs; (pdr = *ppdr) != NULL; ppdr = &pdr->Next) {
        PrintDirDB(pdr, 1|2|4);
    }
}
#endif


VOID
PrintFlags(FILE *pf, ULONG Flags, FLAGSTRINGS *pfs)
{
    LPSTR p = ",";

    while (pfs->pszName != NULL) {
        if (pfs->Mask & Flags) {
            fprintf(pf, "%s %s", p, pfs->pszName);
            p = "";
        }
        pfs++;
    }
    fputs(szNewLine, pf);
}


BOOL
PrintIncludes(FILE *pf, FILEREC *pfr, BOOL fTree)
{
    INCLUDEREC *pir;
    BOOL fMatch = pfr->IncludeFilesTree == pfr->IncludeFiles;

    pir = fTree? pfr->IncludeFilesTree : pfr->IncludeFiles;
    while (pir != NULL) {
        LPSTR pszdir = "<No File Record>";
        char OpenQuote, CloseQuote;

        if (pir->IncFlags & INCLUDEDB_LOCAL) {
            OpenQuote = CloseQuote = '"';
        } else {
            OpenQuote = '<';
            CloseQuote = '>';
        }

        fprintf(
               pf,
               "   %c#include %c%s%c",
               fMatch? ' ' : fTree? '+' : '-',
               OpenQuote,
               pir->Name,
               CloseQuote);
        if (pir->Version != 0) {
            fprintf(pf, " (v%d)", pir->Version);
        }
        if (pir->pfrCycleRoot != NULL) {
            fprintf(
                   pf,
                   " (root=%s\\%s)",
                   pir->pfrCycleRoot->Dir->Name,
                   pir->pfrCycleRoot->Name);
        }
        if (pir->pfrInclude != NULL) {
            if (pir->pfrInclude->Dir == pfr->Dir) {
                pszdir = ".";
            } else {
                pszdir = pir->pfrInclude->Dir->Name;
            }
        }
        fprintf(pf, " %s", pszdir);
        PrintFlags(pf, pir->IncFlags, IncludeFlags);
        if (pir->NextTree != pir->Next) {
            fMatch = FALSE;
        }
        pir = fTree? pir->NextTree : pir->Next;
    }
    return (fMatch);
}


VOID
PrintSourceDBList(SOURCEREC *psr, int i)
{
    TARGET_MACHINE_INFO *pMachine;

    pMachine = i < 0 ? TargetMachines[0] : PossibleTargetMachines[i];

    for ( ; psr != NULL; psr = psr->psrNext) {
        assert(
              (psr->SourceSubDirMask & ~TMIDIR_PARENT) == 0 ||
              pMachine->SourceSubDirMask ==
              (psr->SourceSubDirMask & ~TMIDIR_PARENT));
        BuildMsgRaw(
                   "    %s%s%s%s%s",
                   (psr->SourceSubDirMask & TMIDIR_PARENT)? "..\\" : "",
                   (psr->SourceSubDirMask & ~TMIDIR_PARENT)?
                   pMachine->SourceDirectory : "",
                   (psr->SourceSubDirMask & ~TMIDIR_PARENT)? "\\" : "",
                   psr->pfrSource->Name,
                   (psr->SrcFlags & SOURCEDB_PCH)?
                   " (pch)" :
                   (psr->SrcFlags & SOURCEDB_SOURCES_LIST) == 0?
                   " (From exe list)" : "");
        PrintFlags(stderr, psr->SrcFlags, SourceFlags);
    }
}


VOID
PrintFileDB(FILE *pf, FILEREC *pfr, int DetailLevel)
{
    fprintf(pf, "  File: %s", pfr->Name);
    if (pfr->FileFlags & FILEDB_DIR) {
        fprintf(pf, " (Sub-Directory)");
    } else
        if (pfr->FileFlags & (FILEDB_SOURCE | FILEDB_HEADER)) {
        LPSTR pszType = (pfr->FileFlags & FILEDB_SOURCE)? "Source" : "Header";

        if (pfr->FileFlags & FILEDB_ASM) {
            fprintf(pf, " (Assembler (CPP) %s File)", pszType);
        } else
            if (pfr->FileFlags & FILEDB_MASM) {
            fprintf(pf, " (Assembler (MASM) %s File)", pszType);
        } else
            if (pfr->FileFlags & FILEDB_RC) {
            fprintf(pf, " (Resource Compiler (RC) %s File)", pszType);
        } else
            if (pfr->FileFlags & FILEDB_MIDL) {
            fprintf(pf, " (MIDL %s File)", pszType);
        } else
            if (pfr->FileFlags & FILEDB_ASN) {
            fprintf(pf, " (ASN %s File)", pszType);
        } else
            if (pfr->FileFlags & FILEDB_MKTYPLIB) {
            fprintf(pf, " (Type Library (MkTypLib) %s File)", pszType);
        } else {
            fprintf(pf, " (C %s File)", pszType);
        }
        if ((pfr->FileFlags & FILEDB_HEADER) && pfr->Version != 0) {
            fprintf(pf, " (v%d)", pfr->Version);
        }
        if (pfr->GlobalSequence != 0) {
            fprintf(pf, " (GlobalSeq=%d)", pfr->GlobalSequence);
        }
        if (pfr->LocalSequence != 0) {
            fprintf(pf, " (LocalSeq=%d)", pfr->LocalSequence);
        }
        fprintf(pf, " - %u lines", pfr->SourceLines);
    }
    PrintFlags(pf, pfr->FileFlags, FileFlags);

    if (pfr->IncludeFiles != NULL) {
        BOOL fMatch;

        fMatch = PrintIncludes(pf, pfr, FALSE);
        if (pfr->IncludeFilesTree != NULL) {
            fprintf(pf, "   IncludeTree %s\n", fMatch? "matches" : "differs:");
            if (!fMatch) {
                PrintIncludes(pf, pfr, TRUE);
            }
        }
    }
}


VOID
PrintDirDB(DIRREC *pdr, int DetailLevel)
{
    FILE *pf = stderr;
    FILEREC *pfr, **ppfr;

    if (DetailLevel & 1) {
        fprintf(pf, "Directory: %s", pdr->Name);
        if (pdr->DirFlags & DIRDB_DIRS) {
            fprintf(pf, " (Dirs Present)");
        }
        if (pdr->DirFlags & DIRDB_SOURCES) {
            fprintf(pf, " (Sources Present)");
        }
        if (pdr->DirFlags & DIRDB_MAKEFILE) {
            fprintf(pf, " (Makefile Present)");
        }
        PrintFlags(pf, pdr->DirFlags, DirFlags);
    }
    if (DetailLevel & 2) {
        if (pdr->TargetPath != NULL) {
            fprintf(pf, "  TargetPath: %s\n", pdr->TargetPath);
        }
        if (pdr->TargetName != NULL) {
            fprintf(pf, "  TargetName: %s\n", pdr->TargetName);
        }
        if (pdr->TargetExt != NULL) {
            fprintf(pf, "  TargetExt: %s\n", pdr->TargetExt);
        }
        if (pdr->KernelTest != NULL) {
            fprintf(pf, "  KernelTest: %s\n", pdr->KernelTest);
        }
        if (pdr->UserAppls != NULL) {
            fprintf(pf, "  UserAppls: %s\n", pdr->UserAppls);
        }
        if (pdr->UserTests != NULL) {
            fprintf(pf, "  UserTests: %s\n", pdr->UserTests);
        }
        if (pdr->PchObj != NULL) {
            fprintf(pf, "  PchObj: %s\n", pdr->PchObj);
        }
        if (pdr->Pch != NULL) {
            fprintf(pf, "  Pch: %s\n", pdr->Pch);
        }
    }
    if (DetailLevel & 4) {
        for (ppfr = &pdr->Files; (pfr = *ppfr) != NULL; ppfr = &pfr->Next) {
            PrintFileDB(pf, pfr, DetailLevel);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupFileDB
//
//  Synopsis:   Search the database for the given file.
//
//  Arguments:  [DirDB]    -- Directory containing the file
//              [FileName] -- File to look for
//
//  Returns:    FILEREC of file if found, NULL if not.
//
//  Notes:      The file will not be added to the database if not already
//              there.
//
//----------------------------------------------------------------------------

PFILEREC
LookupFileDB(
            PDIRREC DirDB,
            LPSTR FileName
            )
{
    PFILEREC FileDB, *FileDBNext;
    USHORT sum;

    AssertPathString(FileName);
    sum = CheckSum(FileName);
    if (DEBUG_4) {
        BuildMsgRaw("LookupFileDB(%s, %s) - ", DirDB->Name, FileName);
    }
    FileDBNext = &DirDB->Files;
    while (FileDB = *FileDBNext) {
        if (sum == FileDB->CheckSum && strcmp(FileName, FileDB->Name) == 0) {
            if (DEBUG_4) {
                BuildMsgRaw("success\n");
            }
            return (FileDB);
        }
        FileDBNext = &FileDB->Next;
    }

    if (DEBUG_4) {
        BuildMsgRaw("failure\n");
    }
    return (NULL);
}

//+---------------------------------------------------------------------------
//
//  FILEDESC
//
//  FileDesc is a table describing file names and patterns that we recognize
//  and handle specially.  WARNING:  This table is ordered so the patterns
//  at the front are necessarily more specific than those later on.
//
//----------------------------------------------------------------------------

char szMakefile[] = "#";
char szClang[]    = "//";
char szAsn[]      = "--";
char szMasm[]     = ";";
char szVBasic[]   = "'";

//
// N.B. The first entry in the file descriptor list is an entry that is
//      optionally filled with the name of the target dirs file for the
//      first build target.
//

FILEDESC FileDesc[] =
{   { "/0dirs",       szMakefile,  FALSE, 0,    DIRDB_DIRS},
    { "makefile",     szMakefile,  FALSE, 0,    DIRDB_MAKEFILE},
    { "makefil0",     szMakefile,  FALSE, 0,    DIRDB_MAKEFIL0 | DIRDB_PASS0},
    { "makefil1",     szMakefile,  FALSE, 0,    DIRDB_MAKEFIL1},
    { "sources",      szMakefile,  FALSE, 0,    DIRDB_SOURCES},
    { "dirs",         szMakefile,  FALSE, 0,    DIRDB_DIRS},
    { "mydirs",       szMakefile,  FALSE, 0,    DIRDB_DIRS},

    { "makefile.inc", szMakefile,  FALSE, 0,                            0},
    { "common.ver",   szClang,     TRUE,  FILEDB_HEADER,                0},

    { ".rc",          szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE},
    { ".rc2",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE},
    { ".rcs",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE},
    { ".rcv",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE},
    { ".ver",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE},
    { ".c",           szClang,     TRUE,  FILEDB_SOURCE | FILEDB_C,     0},
    { ".cxx",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_C,     0},
    { ".cpp",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_C,     0},
    { ".f",           szClang,     TRUE,  FILEDB_SOURCE,                0},
    { ".p",           szClang,     TRUE,  FILEDB_SOURCE,                0},
    { ".s",           szClang,     TRUE,  FILEDB_SOURCE | FILEDB_ASM,   0},
    { ".asm",         szMasm,      TRUE,  FILEDB_SOURCE | FILEDB_MASM,  0},
    { ".mc",          szMasm,      TRUE,  FILEDB_SOURCE | FILEDB_RC |
        FILEDB_PASS0, DIRDB_PASS0},
    { ".idl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MIDL |
        FILEDB_PASS0, DIRDB_PASS0},
    { ".asn",         szAsn,       TRUE,  FILEDB_SOURCE | FILEDB_ASN |
        FILEDB_MULTIPLEPASS | FILEDB_PASS0,
        DIRDB_PASS0},
    { ".tdl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MKTYPLIB | FILEDB_PASS0, 0},
    { ".odl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MKTYPLIB | FILEDB_PASS0, 0},
    { ".pdl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_PASS0, 0},
    { ".h",           szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0},
    { ".hxx",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0},
    { ".hpp",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0},
    { ".hmd",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0},
    { ".hdl",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0},
    { ".inl",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0},
    { ".rh",          szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0},
    { ".dlg",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_RC,    0},
    { ".inc",         szMasm,      TRUE,  FILEDB_HEADER | FILEDB_MASM,  0},
    { ".src",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0},  // see mvdm\softpc.new\obj.vdm\imlibdep.c
    { ".def",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0},
    { ".thk",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MULTIPLEPASS |
        FILEDB_PASS0, DIRDB_PASS0},
    { ".java",        szClang,     TRUE,  FILEDB_SOURCE | FILEDB_JAVA,  0},
    { ".mof",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MOF |
        FILEDB_PASS0, DIRDB_PASS0},
    { ".vbp",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_VBP,  0},

    { ".cs",          szClang,     TRUE,  FILEDB_SOURCE | FILEDB_CSHARP, 0},
    { ".lib",         szClang,     TRUE,  0 ,0},
    { ".vb",          szVBasic,    TRUE,  FILEDB_SOURCE | FILEDB_VB_NET, 0},
// MUST BE LAST
    { NULL,           "",          FALSE, 0,                            0}
};


//+---------------------------------------------------------------------------
//
//  Function:   MatchFileDesc
//
//  Synopsis:   Matches the given filename to an entry in FileDesc, if
//              possible.
//
//  Arguments:  [pszFile] -- File to match
//
//  Returns:    A FILEDESC structure.  If a match was not found the data
//              in the FILEDESC will be empty.
//
//----------------------------------------------------------------------------

FILEDESC *
MatchFileDesc(LPSTR pszFile)
{
    LPSTR pszExt = strrchr(pszFile, '.');
    FILEDESC *pfd;

    // treat extensionless file as .h
    // CONSIDER checking exactly for known files, new, memory, algorithm, vector, list, cstdio, cstdlib, etc.
    // CONSIDER also instead doing this where #include is parsed, to avoid doing it in
    // all cases (i.e., not from .rc or .c files). That'd presumably be in ScanFile.
    if (pszExt == NULL)
        pszExt = ".h";

    AssertPathString(pszFile);
    pfd = &FileDesc[0];

    while (pfd->pszPattern != NULL) {
        if (pfd->pszPattern[0] == '.') {
            if (pszExt != NULL && !strcmp(pszExt, pfd->pszPattern))
                break;
        } else
            if (!strcmp(pszFile, pfd->pszPattern))
            break;

        pfd++;
    }
    return pfd;
}


//+---------------------------------------------------------------------------
//
//  Function:   InsertFileDB
//
//  Synopsis:   Adds a file to the database.
//
//  Arguments:  [DirDB]     -- Directory containing the file
//              [FileName]  -- File to add
//              [DateTime]  -- Timestamp of file
//              [Attr]      -- File attributes (directory or file)
//              [FileFlags] -- FILEDB flags
//
//  Returns:    New FILEREC of file
//
//----------------------------------------------------------------------------

PFILEREC
InsertFileDB(
            PDIRREC DirDB,
            LPSTR FileName,
            ULONG DateTime,
            USHORT Attr,
            ULONG  FileFlags)
{
    PFILEREC FileDB, *FileDBNext;
    LPSTR pszCommentToEOL = NULL;

    AssertPathString(FileName);
    if (Attr & FILE_ATTRIBUTE_DIRECTORY) {
        if (!strcmp(FileName, ".")) {
            return (NULL);
        }
        if (!strcmp(FileName, "..")) {
            return (NULL);
        }
        assert(FileFlags == 0);
        FileFlags = FILEDB_DIR;
    } else {
        FILEDESC *pfd = MatchFileDesc(FileName);

        DirDB->DirFlags |= pfd->DirFlags;
        FileFlags |= pfd->FileFlags;

        if (!pfd->fNeedFileRec) {
            return (NULL);
        }
        pszCommentToEOL = pfd->pszCommentToEOL;
    }

    FileDBNext = &DirDB->Files;

    while ((FileDB = *FileDBNext) != NULL) {
        FileDBNext = &(*FileDBNext)->Next;
        if (strcmp(FileName, FileDB->Name) == 0) {
            BuildError(
                      "%s: ignoring second instance of %s\n",
                      DirDB->Name,
                      FileName);
            return (NULL);
        }
    }

    AllocMem(sizeof(FILEREC) + strlen(FileName), &FileDB, MT_FILEDB);
    memset(FileDB, 0, sizeof(*FileDB));
    SigCheck(FileDB->Sig = SIG_FILEREC);

    CopyString(FileDB->Name, FileName, TRUE);
    FileDB->CheckSum = CheckSum(FileDB->Name);

    FileDB->DateTime = DateTime;
    FileDB->Attr = Attr;
    FileDB->Dir = DirDB;
    FileDB->FileFlags = FileFlags;
    FileDB->NewestDependency = FileDB;
    FileDB->pszCommentToEOL = pszCommentToEOL;

    if ((FileFlags & FILEDB_FILE_MISSING) == 0) {
        AllDirsModified = TRUE;
    }
    *FileDBNext = FileDB;
    return (FileDB);
}



//+---------------------------------------------------------------------------
//
//  Function:   DeleteUnscannedFiles
//
//  Synopsis:   Removes unscanned files (leaving scanned files and directories)
//              from the Files list of the given directory
//
//  Arguments:  [DirDB] -- Directory to clean up
//
//----------------------------------------------------------------------------

VOID
DeleteUnscannedFiles(
                    PDIRREC DirDB
                    )
{
    PFILEREC FileDB, *FileDBNext;

    FileDBNext = &DirDB->Files;
    while (FileDB = *FileDBNext) {
        //
        // If a file has the missing flag set then it doesn't exist.  But for
        // it to be in the list of files it has to be listed in a SOURCES line
        // (or some equivalent).  This means there is a SOURCEREC somewhere
        // which is pointing to the FILEREC for that file, so we don't want to
        // free its memory.
        //
        if ( (FileDB->FileFlags & (FILEDB_SCANNED | FILEDB_FILE_MISSING | FILEDB_SOURCEREC_EXISTS)) ||
             (FileDB->Attr & FILE_ATTRIBUTE_DIRECTORY) ) {
            FileDBNext = &FileDB->Next;
        } else {
            FreeFileDB( FileDBNext );
            AllDirsModified = TRUE;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   InsertIncludeDB
//
//  Synopsis:   Inserts an include file into the database
//
//  Arguments:  [FileDB]          -- File which includes this file
//              [IncludeFileName] -- Name of include file
//              [IncFlags]        -- INCLUDEDB flags for this file
//
//  Returns:    INCLUDEREC of previously existing or new entry one.
//
//----------------------------------------------------------------------------

PINCLUDEREC
InsertIncludeDB(
               PFILEREC FileDB,
               LPSTR IncludeFileName,
               USHORT IncFlags
               )
{
    PINCLUDEREC IncludeDB, *IncludeDBNext;

    AssertPathString(IncludeFileName);

    IncludeDBNext = &FileDB->IncludeFiles;

    while (IncludeDB = *IncludeDBNext) {
        AssertCleanTree(IncludeDB, FileDB);      // Tree must be clean
        if (!strcmp(IncludeDB->Name, IncludeFileName)) {
            IncludeDB->IncFlags &= ~INCLUDEDB_GLOBAL;
            IncludeDB->pfrInclude = NULL;
            return (IncludeDB);
        }
        IncludeDBNext = &IncludeDB->Next;
    }

    AllocMem(
            sizeof(INCLUDEREC) + strlen(IncludeFileName),
            IncludeDBNext,
            MT_INCLUDEDB);

    IncludeDB = *IncludeDBNext;

    memset(IncludeDB, 0, sizeof(*IncludeDB));
    SigCheck(IncludeDB->Sig = SIG_INCLUDEREC);

    IncludeDB->IncFlags = IncFlags;
    CopyString(IncludeDB->Name, IncludeFileName, TRUE);

    AllDirsModified = TRUE;

    return (IncludeDB);
}


//+---------------------------------------------------------------------------
//
//  Function:   LinkToCycleRoot
//
//----------------------------------------------------------------------------

VOID
LinkToCycleRoot(INCLUDEREC *pirOrg, FILEREC *pfrCycleRoot)
{
    INCLUDEREC *pir;

    AllocMem(
            sizeof(INCLUDEREC) + strlen(pfrCycleRoot->Name),
            &pir,
            MT_INCLUDEDB);
    memset(pir, 0, sizeof(*pir));
    SigCheck(pir->Sig = SIG_INCLUDEREC);

    pir->IncFlags = INCLUDEDB_SNAPPED | INCLUDEDB_CYCLEALLOC;
    pir->pfrInclude = pfrCycleRoot;

    CopyString(pir->Name, pfrCycleRoot->Name, TRUE);
    if (DEBUG_1) {
        BuildMsgRaw(
                   "%x CycleAlloc  %s\\%s <- %s\\%s\n",
                   pir,
                   pir->pfrInclude->Dir->Name,
                   pir->pfrInclude->Name,
                   pirOrg->pfrInclude->Dir->Name,
                   pirOrg->pfrInclude->Name);
    }

    MergeIncludeFiles(pirOrg->pfrInclude, pir, NULL);

    assert((pir->IncFlags & INCLUDEDB_CYCLEORPHAN) == 0);
    assert(pir->IncFlags & INCLUDEDB_CYCLEROOT);
}


//+---------------------------------------------------------------------------
//
//  Function:   MergeIncludeFiles
//
//----------------------------------------------------------------------------

VOID
MergeIncludeFiles(FILEREC *pfr, INCLUDEREC *pirList, FILEREC *pfrRoot)
{
    INCLUDEREC *pirT;
    INCLUDEREC *pir, **ppir;

    while ((pirT = pirList) != NULL) {
        pirList = pirList->NextTree;
        pirT->NextTree = NULL;
        assert(pirT->pfrInclude != NULL);

        for (ppir = &pfr->IncludeFilesTree;
            (pir = *ppir) != NULL;
            ppir = &pir->NextTree) {

            if (pirT->pfrInclude == pir->pfrInclude) {
                if (pirT->IncFlags & INCLUDEDB_CYCLEROOT) {
                    RemoveFromCycleRoot(pirT, pfrRoot);
                }
                pirT->IncFlags |= INCLUDEDB_CYCLEORPHAN;
                if (DEBUG_1) {
                    BuildMsgRaw(
                               "%x CycleOrphan %s\\%s <- %s\\%s\n",
                               pirT,
                               pirT->pfrInclude->Dir->Name,
                               pirT->pfrInclude->Name,
                               pfr->Dir->Name,
                               pfr->Name);
                }
                break;
            }
        }
        if (*ppir == NULL) {
            *ppir = pirT;
            pirT->pfrCycleRoot = pfr;
            pirT->IncFlags |= INCLUDEDB_CYCLEROOT;
            if (DEBUG_1) {
                BuildMsgRaw(
                           "%x CycleRoot   %s\\%s <- %s\\%s\n",
                           pirT,
                           pirT->pfrInclude->Dir->Name,
                           pirT->pfrInclude->Name,
                           pirT->pfrCycleRoot->Dir->Name,
                           pirT->pfrCycleRoot->Name);
            }
        }
    }
    if (fDebug & 16) {
        PrintFileDB(stderr, pfr, 2);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   RemoveFromCycleRoot
//
//----------------------------------------------------------------------------

VOID
RemoveFromCycleRoot(INCLUDEREC *pir, FILEREC *pfrRoot)
{
    INCLUDEREC **ppir;

    assert(pir->pfrCycleRoot != NULL);

    // if pfrRoot was passed in, the caller knows it's on pfrRoot's list,
    // and is already dealing with the linked list without our help.

    if (pfrRoot != NULL) {
        assert((pir->IncFlags & INCLUDEDB_CYCLEALLOC) == 0);
        assert(pir->pfrCycleRoot == pfrRoot);
        pir->pfrCycleRoot = NULL;
        pir->IncFlags &= ~INCLUDEDB_CYCLEROOT;
        if (DEBUG_1) {
            BuildMsgRaw(
                       "%x CycleUnroot %s\\%s <- %s\\%s\n",
                       pir,
                       pir->pfrInclude->Dir->Name,
                       pir->pfrInclude->Name,
                       pfrRoot->Dir->Name,
                       pfrRoot->Name);
        }
        return;
    }
    ppir = &pir->pfrCycleRoot->IncludeFilesTree;
    while (*ppir != NULL) {
        if (*ppir == pir) {
            *ppir = pir->NextTree;      // remove from tree list
            pir->NextTree = NULL;
            pir->pfrCycleRoot = NULL;
            pir->IncFlags &= ~INCLUDEDB_CYCLEROOT;
            return;
        }
        ppir = &(*ppir)->NextTree;
    }
    BuildError(
              "%s\\%s: %x %s: not on cycle root's list\n",
              pir->pfrCycleRoot->Dir->Name,
              pir->pfrCycleRoot->Name,
              pir,
              pir->Name);

    assert(pir->pfrCycleRoot == NULL);  // always asserts if loop exhausted
}


//+---------------------------------------------------------------------------
//
//  Function:   UnsnapIncludeFiles
//
//  Synopsis:   Removes pointers from INCLUDEREC to the actual FILEREC of
//              the include file so we can 'resnap' them.
//
//  Arguments:  [pfr]           -- FILEREC to unsnap
//              [fUnsnapGlobal] -- If TRUE, global and local includes are
//                                 unsnapped. Otherwise, just local ones are.
//
//----------------------------------------------------------------------------

VOID
UnsnapIncludeFiles(FILEREC *pfr, BOOL fUnsnapGlobal)
{
    INCLUDEREC **ppir;
    INCLUDEREC *pir;

    // Dynamic Tree List:
    //  - no cycle orphans
    //  - cycle roots must belong to current file record
    //  - cycle allocs must be freed

    AssertFile(pfr);
    while (pfr->IncludeFilesTree != NULL) {
        pir = pfr->IncludeFilesTree;            // pick up next entry
        AssertInclude(pir);
        pfr->IncludeFilesTree = pir->NextTree;  // remove from tree list

        assert((pir->IncFlags & INCLUDEDB_CYCLEORPHAN) == 0);

        if (pir->IncFlags & (INCLUDEDB_CYCLEROOT | INCLUDEDB_CYCLEALLOC)) {

            // unsnap the record

            pir->IncFlags &= ~(INCLUDEDB_SNAPPED | INCLUDEDB_GLOBAL);
            pir->pfrInclude = NULL;
            pir->NextTree = NULL;
        }

        if (pir->IncFlags & INCLUDEDB_CYCLEROOT) {
            assert(pir->pfrCycleRoot == pfr);
            pir->pfrCycleRoot = NULL;
            pir->IncFlags &= ~INCLUDEDB_CYCLEROOT;
        }
        assert(pir->pfrCycleRoot == NULL);

        if (pir->IncFlags & INCLUDEDB_CYCLEALLOC) {
            pir->IncFlags &= ~INCLUDEDB_CYCLEALLOC;
            assert(pir->Next == NULL);
            FreeIncludeDB(&pir);
        }
    }

    // Static List:
    //  - no cycle allocs
    //  - cycle roots must be removed from a different file's Dynamic list
    //  - cycle orphans are nops

    for (ppir = &pfr->IncludeFiles; (pir = *ppir) != NULL; ppir = &pir->Next) {
        assert((pir->IncFlags & INCLUDEDB_CYCLEALLOC) == 0);
        if (pir->IncFlags & INCLUDEDB_CYCLEROOT) {
            assert(pir->pfrCycleRoot != pfr);
            RemoveFromCycleRoot(pir, NULL);
        }
        pir->IncFlags &= ~INCLUDEDB_CYCLEORPHAN;

        if (pir->pfrInclude != NULL &&
            (fUnsnapGlobal ||
             (pir->pfrInclude->Dir->DirFlags & DIRDB_GLOBAL_INCLUDES) == 0)) {

            // unsnap the record

            pir->IncFlags &= ~(INCLUDEDB_SNAPPED | INCLUDEDB_GLOBAL);
            pir->pfrInclude = NULL;
        }
        pir->NextTree = NULL;
    }
}

#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   AssertCleanTree
//
//  Synopsis:   Enforce that no include files are snapped.
//
//  Arguments:  [pir] - include record to test
//              [pfr] - optional containing file record
//
//----------------------------------------------------------------------------

VOID
AssertCleanTree(INCLUDEREC *pir, OPTIONAL FILEREC *pfr)
{
    if (IsCleanTree(pir)) {
        return;
    }
    if (fAssertCleanTree) {
        BuildMsgRaw("\n*************************************\n");
        BuildMsgRaw("Persistent Cycle: pir=%x: %s\n", pir, pir->Name);
        if (pfr != NULL) {
            BuildMsgRaw("    pfr=%x: %s\n", pfr, pfr->Name);
            if (pfr->Dir != NULL) {
                BuildMsgRaw("    pdr=%x: %s\n", pfr->Dir, pfr->Dir->Name);
            }
        }
        if (pir->pfrInclude != NULL) {
            BuildMsgRaw("    pfrInclude=%x: %s\n", pir->pfrInclude, pir->pfrInclude->Name);
            if (pir->pfrInclude->Dir != NULL) {
                BuildMsgRaw("    pdrInclude=%x: %s\n", pir->pfrInclude->Dir, pir->pfrInclude->Dir->Name);
            }
        }
        BuildMsgRaw("\n*************************************\n");
        fflush(stdout);
        fflush(stderr);

        PrintAllDirs();
        BuildMsgRaw("\n*************************************\n");
        fflush(stdout);
        fflush(stderr);
    }
    assert(IsCleanTree(pir));
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   UnsnapAllDirectories
//
//  Synopsis:   Removes pointers from all INCLUDERECs to the actual FILERECs
//              of include files so we can 'resnap' them.
//
//  Arguments:  None
//----------------------------------------------------------------------------

VOID
UnsnapAllDirectories(VOID)
{
    DIRREC *pdr;
    UINT   i;

    GlobalSequence = LocalSequence = 0;

    for (pdr = AllDirs; pdr != NULL; pdr = pdr->Next) {
        FILEREC *pfr;

        AssertDir(pdr);

        // Clear unwanted flags on each directory

        pdr->DirFlags &= ~(DIRDB_SCANNED |
                           DIRDB_PASS0NEEDED |
                           DIRDB_COMPILENEEDED |
                           DIRDB_NEW);

        pdr->CountOfFilesToCompile = 0;
        pdr->SourceLinesToCompile  = 0;
        pdr->CountOfPassZeroFiles = 0;
        pdr->PassZeroLines = 0;

        // Free all source records that point to missing files, because the
        // file records may be freed when rescanning directories after pass 0.

        if (pdr->pds != NULL) {
            for (i = 0; i < MAX_TARGET_MACHINES + 1; i++) {
                SOURCEREC **ppsr;
                SOURCEREC *psr;

                ppsr = &pdr->pds->psrSourcesList[i];
                while ((psr = *ppsr) != NULL) {
                    if (psr->SrcFlags & SOURCEDB_FILE_MISSING) {
                        FreeSourceDB(ppsr);
                    } else {
                        ppsr = &psr->psrNext;
                    }
                }
            }
        }

        // Clear out all snapped include files and sequence numbers

        for (pfr = pdr->Files; pfr != NULL; pfr = pfr->Next) {

            AssertFile(pfr);
            UnsnapIncludeFiles(pfr, TRUE);
            pfr->GlobalSequence = pfr->LocalSequence = 0;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   MarkIncludeFileRecords
//
//----------------------------------------------------------------------------

VOID
MarkIncludeFileRecords(
                      PFILEREC FileDB
                      )
{
    PINCLUDEREC IncludeDB, *IncludeDBNext;

    IncludeDBNext = &FileDB->IncludeFiles;
    while (IncludeDB = *IncludeDBNext) {
        AssertCleanTree(IncludeDB, FileDB);      // Tree must be clean
        IncludeDB->pfrInclude = (PFILEREC) -1;
        IncludeDBNext = &IncludeDB->Next;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteIncludeFileRecords
//
//----------------------------------------------------------------------------

VOID
DeleteIncludeFileRecords(
                        PFILEREC FileDB
                        )
{
    PINCLUDEREC IncludeDB, *IncludeDBNext;

    IncludeDBNext = &FileDB->IncludeFiles;
    while (IncludeDB = *IncludeDBNext) {
        AssertCleanTree(IncludeDB, FileDB);      // Tree must be clean
        if (IncludeDB->pfrInclude == (PFILEREC) -1) {
            FreeIncludeDB(IncludeDBNext);
        } else {
            IncludeDBNext = &IncludeDB->Next;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FindIncludeFileDB
//
//  Synopsis:   Find the FILEREC for an include file that our compiland
//              includes.
//
//  Arguments:  [pfrSource]          -- FILEREC of file which includes the one
//                                      we're looking for. Might be a header.
//              [pfrCompiland]       -- FILEREC of ultimate source file.
//              [pdrBuild]           -- DIRREC of directory being built
//              [pszSourceDirectory] -- Name of machine-specific dir
//              [IncludeDB]          -- INCLUDEDB of include file we're looking
//                                      for.
//
//  Returns:    FILEREC of include file, if found.
//
//----------------------------------------------------------------------------

PFILEREC
FindIncludeFileDB(
                 FILEREC *pfrSource,
                 FILEREC *pfrCompiland,
                 DIRREC *pdrBuild,
                 LPSTR pszSourceDirectory,
                 INCLUDEREC *IncludeDB)
{
    DIRREC *pdr;
    DIRREC *pdrMachine;
    FILEREC *pfr;
    UINT n;

    AssertFile(pfrSource);
    AssertFile(pfrCompiland);
    AssertDir(pfrSource->Dir);
    AssertDir(pfrCompiland->Dir);
    AssertDir(pdrBuild);
    assert(pfrSource->Dir->FindCount >= 1);
    assert(pfrCompiland->Dir->FindCount >= 1);
    assert(pdrBuild->FindCount >= 1);
    AssertInclude(IncludeDB);

    // The rules for #include "foo.h" and #include <foo.h> are:
    //  - "foo.h" searches in the directory of the source file that has the
    //    #include statement first, then falls into the INCLUDES= directories
    //  - <foo.h> simply searches the INCLUDES= directories
    //
    //  - since makefile.def *always* passes -I. -ITargetMachines[i] first,
    //    that has to be handled here as well.
    //
    //  - deal with #include <sys\types> and #include "..\foo\bar.h" by
    //    scanning those directories, too.

    n = CountIncludeDirs;
    pdrMachine = FindSourceDirDB(pdrBuild->Name, pszSourceDirectory, FALSE);

    // If local ("foo.h"), search the current file's directory, too.
    // The compiler also will search the directory of each higher level
    // file in the include hierarchy, but we won't get quite so fancy here.
    // Just search the directory of the current file and of the compiland.
    //
    // Skip these directories if they match the current build directory or
    // the machine subdirectory, because that's handled below.

    if (IncludeDB->IncFlags & INCLUDEDB_LOCAL) {
        if (pfrCompiland->Dir != pdrBuild &&
            pfrCompiland->Dir != pdrMachine &&
            pfrCompiland->Dir != pfrSource->Dir) {
            AddIncludeDir(pfrCompiland->Dir, &n);
        }
        if (pfrSource->Dir != pdrBuild && pfrSource->Dir != pdrMachine) {
            AddIncludeDir(pfrSource->Dir, &n);
        }
    }

    // Search the current target machine subdirectory of the build directory
    // -- as per makefile.def

    if (pdrMachine != NULL) {
        AddIncludeDir(pdrMachine, &n);
    }

    // Search the current build directory -- as per makefile.def.

    AddIncludeDir(pdrBuild, &n);

    while (n--) {
        pdr = IncludeDirs[n];
        if (pdr == NULL) {
            continue;
        }
        AssertDir(pdr);
        assert(pdr->FindCount >= 1);
        pfr = FindSourceFileDB(pdr, IncludeDB->Name, NULL);
        if (pfr != NULL) {
            if (DEBUG_1) {
                BuildMsgRaw(
                           "Found include file %s\\%s\n",
                           pfr->Dir->Name,
                           pfr->Name);
            }
            return (pfr);
        }
    }
    return (NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveMasterDB
//
//  Synopsis:   Save the database to disk in build.dat
//
//  Arguments:  (none)
//
//  Returns:    TRUE if successful
//
//----------------------------------------------------------------------------

BOOL
SaveMasterDB(VOID)
{
    PDIRREC DirDB, *DirDBNext;
    PFILEREC FileDB, *FileDBNext;
    PINCLUDEREC IncludeDB, *IncludeDBNext;
    FILE *fh;

    if (!AllDirsModified) {
        return (TRUE);
    }

    if (!(fh = fopen(DbMasterName, "wb"))) {
        return ( FALSE );
    }

    setvbuf(fh, NULL, _IOFBF, 0x7000);
    BuildMsg("Saving %s...", DbMasterName);

    AllDirsModified = FALSE;
    DirDBNext = &AllDirs;
    fprintf(fh, "V %x\r\n", BUILD_VERSION);
    while (DirDB = *DirDBNext) {
        fprintf(fh, "D \"%s\" %x\r\n", DirDB->Name, DirDB->DirFlags);
        FileDBNext = &DirDB->Files;
        while (FileDB = *FileDBNext) {
            if ((FileDB->FileFlags & FILEDB_FILE_MISSING) == 0) {
                fprintf(
                       fh,
                       " F \"%s\" %x %x %lx %u %u\r\n",
                       FileDB->Name,
                       FileDB->FileFlags,
                       FileDB->Attr,
                       FileDB->DateTime,
                       FileDB->SourceLines,
                       FileDB->Version);
            }
            IncludeDBNext = &FileDB->IncludeFiles;
            while (IncludeDB = *IncludeDBNext) {
                fprintf(
                       fh,
                       "  I \"%s\" %x %u\r\n",
                       IncludeDB->Name,
                       IncludeDB->IncFlags,
                       IncludeDB->Version);

                IncludeDBNext= &IncludeDB->Next;
            }
            FileDBNext = &FileDB->Next;
        }
        fprintf(fh, "\r\n");
        DirDBNext = &DirDB->Next;
    }
    fclose(fh);
    BuildMsgRaw(szNewLine);
    return (TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterDB
//
//  Synopsis:   Load the master database from build.dat
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

void
LoadMasterDB( void )
{
    PDIRREC DirDB, *DirDBNext;
    PFILEREC FileDB, *FileDBNext;
    PINCLUDEREC IncludeDB, *IncludeDBNext;
    FILE *fh;
    LPSTR s;
    char ch, ch2;
    BOOL fFirst = TRUE;
    UINT Version;
    LPSTR pszerr = NULL;

    AllDirs = NULL;
    AllDirsModified = FALSE;
    AllDirsInitialized = FALSE;

    if (!SetupReadFile("", DbMasterName, ";", &fh)) {
        return;
    }
    BuildMsg("Loading %s...", DbMasterName);

    DirDBNext = &AllDirs;
    FileDBNext = NULL;
    IncludeDBNext = NULL;

    while ((s = ReadLine(fh)) != NULL) {
        ch = *s++;
        if (ch == '\0') {
            continue;           // skip empty lines
        }
        ch2 = *s++;             // should be a blank
        if (ch2 == '\0') {
            pszerr = "missing field";
            break;              // fail on single character lines
        }
        if (fFirst) {
            if (ch != 'V' || ch2 != ' ' || !AToX(&s, &Version)) {
                pszerr = "bad version format";
                break;
            }
            if (Version != BUILD_VERSION) {
                break;
            }
            fFirst = FALSE;
            continue;
        }
        if (ch2 != ' ') {
            pszerr = "bad separator";
            break;
        }
        if (ch == 'D') {
            DirDB = LoadMasterDirDB(s);
            if (DirDB == NULL) {
                pszerr = "Directory error";
                break;
            }
            *DirDBNext = DirDB;
            DirDBNext = &DirDB->Next;
            FileDBNext = &DirDB->Files;
            IncludeDBNext = NULL;
        } else
            if (ch == 'F' && FileDBNext != NULL) {
            FileDB = LoadMasterFileDB(s);
            if (FileDB == NULL) {
                pszerr = "File error";
                break;
            }
            *FileDBNext = FileDB;
            FileDBNext = &FileDB->Next;
            FileDB->Dir = DirDB;
            IncludeDBNext = &FileDB->IncludeFiles;
        } else
            if (ch == 'I' && IncludeDBNext != NULL) {
            IncludeDB = LoadMasterIncludeDB(s);
            if (IncludeDB == NULL) {
                pszerr = "Include error";
                break;
            }
            *IncludeDBNext = IncludeDB;
            IncludeDBNext = &IncludeDB->Next;
        } else {
            pszerr = "bad entry type";
            break;
        }
    }

    if (s != NULL) {
        if (pszerr == NULL) {
            BuildMsgRaw(" - old version - recomputing.\n");
        } else {
            BuildMsgRaw(szNewLine);
            BuildError("corrupt database (%s)\n", pszerr);
        }
        FreeAllDirs();
    } else {
        BuildMsgRaw(szNewLine);
        AllDirsInitialized = TRUE;
    }
    CloseReadFile(NULL);
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterDirDB
//
//  Synopsis:   Load a directory entry from build.dat
//
//  Arguments:  [s] -- line containing text from file.
//
//  Returns:    DIRRECT
//
//----------------------------------------------------------------------------

PDIRREC
LoadMasterDirDB(
               LPSTR s
               )
{
    PDIRREC DirDB;
    LPSTR DirName;
    ULONG MyDirFlags;

    if (*s == '"') {
        s++;
        DirName = s;
        while (*s != '"') {
            s++;
        }
        *s++ = '\0';
    } else {
        DirName = s;
        while (*s > ' ') {
            s++;
        }
    }
    *s++ = '\0';

    if (!AToX(&s, &MyDirFlags)) {
        return (NULL);
    }

    DirDB = CreateNewDirDB(DirName);
    DirDB->DirFlags = MyDirFlags & DIRDB_DBPRESERVE;

    return (DirDB);
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterFileDB
//
//  Synopsis:   Load a file entry from build.dat
//
//  Arguments:  [s] -- line containing text from file
//
//  Returns:    FILEREC
//
//----------------------------------------------------------------------------

PFILEREC
LoadMasterFileDB(
                LPSTR s
                )
{
    PFILEREC FileDB;
    LPSTR FileName;
    ULONG Version;
    ULONG MyFileFlags;
    ULONG Attr;
    ULONG SourceLines;
    ULONG DateTime;
    FILEDESC *pfd;

    if (*s == '"') {
        s++;
        FileName = s;
        while (*s != '"') {
            s++;
        }
        *s++ = '\0';
    } else {
        FileName = s;
        while (*s > ' ') {
            s++;
        }
    }
    *s++ = '\0';

    if (!AToX(&s, &MyFileFlags) ||
        !AToX(&s, &Attr) ||
        !AToX(&s, &DateTime) ||
        !AToD(&s, &SourceLines) ||
        !AToD(&s, &Version) ||
        strchr(FileName, '/') != NULL ||
        strchr(FileName, '\\') != NULL) {
        return (NULL);
    }
    AllocMem(sizeof(FILEREC) + strlen(FileName), &FileDB, MT_FILEDB);
    memset(FileDB, 0, sizeof(*FileDB));
    SigCheck(FileDB->Sig = SIG_FILEREC);

    CopyString(FileDB->Name, FileName, TRUE);
    FileDB->CheckSum = CheckSum(FileDB->Name);

    FileDB->FileFlags = MyFileFlags & FILEDB_DBPRESERVE;
    FileDB->Attr = (USHORT) Attr;
    FileDB->DateTime = DateTime;
    FileDB->Version = (USHORT) Version;
    FileDB->SourceLines = SourceLines;
    FileDB->NewestDependency = FileDB;

    pfd = MatchFileDesc(FileDB->Name);
    FileDB->pszCommentToEOL = pfd->pszCommentToEOL;
    return (FileDB);
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterIncludeDB
//
//  Synopsis:   Loads an include file entry from build.dat
//
//  Arguments:  [s] -- line containing text from file.
//
//  Returns:    INCLUDEREC
//
//----------------------------------------------------------------------------

PINCLUDEREC
LoadMasterIncludeDB(
                   LPSTR s
                   )
{
    PINCLUDEREC IncludeDB;
    LPSTR FileName;
    ULONG Version;
    ULONG IncFlags;

    if (*s == '"') {
        s++;
        FileName = s;
        while (*s != '"') {
            s++;
        }
        *s++ = '\0';
    } else {
        FileName = s;
        while (*s > ' ') {
            s++;
        }
    }
    *s++ = '\0';

    if (!AToX(&s, &IncFlags) || !AToD(&s, &Version)) {
        return (NULL);
    }
    AllocMem(
            sizeof(INCLUDEREC) + strlen(FileName),
            &IncludeDB,
            MT_INCLUDEDB);
    memset(IncludeDB, 0, sizeof(*IncludeDB));
    SigCheck(IncludeDB->Sig = SIG_INCLUDEREC);

    IncludeDB->IncFlags = (USHORT) (IncFlags & INCLUDEDB_DBPRESERVE);
    IncludeDB->Version = (USHORT) Version;
    CopyString(IncludeDB->Name, FileName, TRUE);
    return (IncludeDB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\buildmak.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994.
//
//  File:       buildmak.c
//
//  Contents:   This is the Make module for the NT Build Tool (BUILD.EXE)
//
//              The Make module scans directories for file names and edits the
//              data base appropriately.
//
//  Functions:
//
//  History:    16-May-89     SteveWo      Created
//                  ... See SLM log
//              26-Jul-94     LyleC        Cleanup/Add Pass0 support
//              05-Dec-00     sbonev       See SD changelist 2317
//
//----------------------------------------------------------------------------

#include "build.h"


#define SCANFLAGS_CHICAGO       0x00000002
#define SCANFLAGS_OS2           0x00000004
#define SCANFLAGS_POSIX         0x00000008
#define SCANFLAGS_CRT           0x00000010

ULONG ScanFlagsLast;
ULONG ScanFlagsCurrent;

USHORT GlobalSequence;
USHORT LocalSequence;
ULONG idFileToCompile = 1;
BOOL fLineCleared = TRUE;

char szRecurse[] = " . . . . . . . . .";
char szAsterisks[] = " ********************";

char *pszSdkLibDest;
char *pszDdkLibDest;
char *pszIncOak;
char *pszIncDdk;
char *pszIncWdm;
char *pszIncSdk;
char *pszIncCrt;
char *pszIncMfc;
char *pszIncOs2;
char *pszIncPosix;
char *pszIncChicago;

char szCheckedAltDir[] = " CHECKED_ALT_DIR=1";

#ifndef ARRAY_SIZE
    #define ARRAY_SIZE(array, type) (sizeof(array)/sizeof(type))
#endif


extern CHAR szObjDir[];

//
// The following definitions are for the ObjectDirFlag entry in the TARGETDATA
// struct.
//

//
// TD_OBJECTDIR   maps to ObjectDirectory[iObjectDir]\foobar.tar
// TD_PASS0HDRDIR maps to $(PASS0_HEADERDIR)\foobar.tar
// TD_PASS0DIR1   maps to $(PASS0_SOURCEDIR)\foobar.tar or $(PASS0_CLIENTDIR)\foobar.tar
// TD_PASS0DIR2   maps to $(PASS0_UUIDDIR)\foobar.tar or $(PASS0_SERVERDIR)\foobar.tar
//
// where .tar is the given target extension, ObjectDirectory[iObjectDir] is the
// appropriate object directory for that platform, and the macros are expanded
// to the values given in the sources file.
//
#define TD_OBJECTDIR           1
#define TD_PASS0HDRDIR         2
#define TD_PASS0DIR1           3
#define TD_PASS0DIR2           4
#define TD_MCSOURCEDIR         5

typedef struct _tagTARGETDATA {
    UCHAR ObjectDirFlag;    // Indicates what object dir should be used.
    LPSTR pszTargetExt;     // Extension of target. (Including '.')
} TARGETDATA, *LPTARGETDATA;

typedef struct _tagOBJECTTARGETINFO {
    LPSTR        pszSourceExt;  // Extension of source file (including '.').
    UCHAR        NumData;       // Number of entries in [Data].
    LPTARGETDATA Data;          // Pointer to array of TARGETDATAs.
} OBJECTTARGETINFO, *LPOBJECTTARGETINFO;

typedef struct _tagOBJECTTARGETARRAY {
    int                cTargetInfo;
    OBJECTTARGETINFO **aTargetInfo;
} OBJECTTARGETARRAY;

typedef struct _waitConsumer {
    LIST_ENTRY List;
    PDIRREC DirDB;
    char MakeParameters[ MAKEPARAMETERS_MAX_LEN ];
}*PWAITING_CONSUMER , WAITING_CONSUMER ;

LIST_ENTRY Head;
BOOL IsHeadInitialized=FALSE;

//
// TARGETDATA information is used by both BuildCompileTarget() and
// WriteObjectsDefinition() via the GetTargetData() function.  Do not put
// extensions in this table whose TARGETDATA consists entirely of
// { TD_OBJECTDIR, ".obj" } because that is the default.  Instead you must
// modify the switch statement in WriteObjectsDefinition.
//
// The first target in each TARGETDATA array is considered the 'rule target'
// because that is the target for which the inference rule in makefile.def is
// written.  The 'rule target' will always be deleted in addition to the
// out-of-date target if *any* of the targets are out of date.
//


//
// The following data defines the *PASS0* mappings of source extensions
// to target files:
//
//              .idl -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_SOURCEDIR)\_p.c,
//                      $(PASS0_UUIDDIR)\_i.c
//              .asn -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_HEADERDIR)\.c
//              .mc  -> $(PASS0_HEADERDIR)\.h, $(PASS0_SOURCEDIR)\.rc
//              .odl -> obj\*\.tlb
//              .tdl -> obj\*\.tlb
//

//              .mc  -> $(PASS0_HEADERDIR)\.h, $(PASS0_HEADERDIR)\.rc
TARGETDATA MCData0[] = {
    { TD_PASS0HDRDIR, ".h"},
    { TD_MCSOURCEDIR, ".rc"}
};
OBJECTTARGETINFO MCInfo0 = { ".mc", ARRAY_SIZE(MCData0, TARGETDATA), MCData0};

//              .asn  -> $(PASS0_HEADERDIR)\.h, $(PASS0_SOURCEDIR)\.c
TARGETDATA AsnData0[] = {
    { TD_PASS0HDRDIR, ".h"},
    { TD_PASS0DIR1, ".c"},
};
OBJECTTARGETINFO AsnInfo0 =
{ ".asn", ARRAY_SIZE(AsnData0, TARGETDATA), AsnData0};


//         .odl/.tdl -> obj\*\.tlb
TARGETDATA TLBData0 = { TD_OBJECTDIR, ".tlb"};

OBJECTTARGETINFO TLBInfo0 =
{ ".tdl", ARRAY_SIZE(TLBData0, TARGETDATA), &TLBData0};

OBJECTTARGETINFO TLB2Info0 =
{ ".odl", ARRAY_SIZE(TLBData0, TARGETDATA), &TLBData0};

//         .thk -> obj\*\.asm
TARGETDATA THKData0 = { TD_OBJECTDIR, ".asm"};

OBJECTTARGETINFO THKInfo0 =
{ ".thk", ARRAY_SIZE(THKData0, TARGETDATA), &THKData0};


//              .mof -> obj\*\.mof, obj\*\.bmf
TARGETDATA MOFData0[] = {
    {TD_OBJECTDIR, ".mof"},
    {TD_OBJECTDIR, ".bmf"}
};
OBJECTTARGETINFO MOFInfo0 = { ".mof", ARRAY_SIZE(MOFData0, TARGETDATA),
    MOFData0};

//          ------
LPOBJECTTARGETINFO aTargetInfo0[] = {
    &MCInfo0,
    &AsnInfo0,
    &TLBInfo0,
    &TLB2Info0,
    &THKInfo0,
    &MOFInfo0,
};
#define CTARGETINFO0    ARRAY_SIZE(aTargetInfo0, LPOBJECTTARGETINFO)


//
// The following data defines the *PASS1* mappings of source extensions
// to target files:
//
//              .rc  -> obj\*\.res
//              .asn -> obj\*\.obj
//              .thk -> obj\*\.asm,
//              .java -> obj\*\.class,
//                      obj\*\.obj,
//              .vbp -> obj\*\.dll,
//

//              .rc  -> obj\*\.res
TARGETDATA RCData1 = { TD_OBJECTDIR, ".res"};
OBJECTTARGETINFO RCInfo1 = { ".rc", ARRAY_SIZE(RCData1, TARGETDATA), &RCData1};

//              .thk -> .asm -> .obj
TARGETDATA THKData1[] = {
    {TD_OBJECTDIR, ".obj"}
};
OBJECTTARGETINFO THKInfo1 =
{ ".thk", ARRAY_SIZE(THKData1, TARGETDATA), THKData1};

//              .java -> .class
TARGETDATA JAVAData1[] = {
    {TD_OBJECTDIR, ".class"}
};
OBJECTTARGETINFO JAVAInfo1 =
{ ".java", ARRAY_SIZE(JAVAData1, TARGETDATA), JAVAData1};

//              .vbp -> .dll
TARGETDATA VBPData1[] = {
    {TD_OBJECTDIR, ".dll"}
};
OBJECTTARGETINFO VBPInfo1 =
{ ".vbp", ARRAY_SIZE(VBPData1, TARGETDATA), VBPData1};




//          ------
LPOBJECTTARGETINFO aTargetInfo1[] = {
    &RCInfo1,
    &THKInfo1,
    &JAVAInfo1,
    &VBPInfo1,
};
#define CTARGETINFO1    ARRAY_SIZE(aTargetInfo1, LPOBJECTTARGETINFO)


OBJECTTARGETARRAY aTargetArray[] = {
    { CTARGETINFO0, aTargetInfo0},
    { CTARGETINFO1, aTargetInfo1},
};


//          ------
//   MIDL stuff -- IDL files have two potential sets of targets, depending
//   on if the IDL_TYPE flag was set to 'ole' in the sources file or not.
//   Note: only the .h file is guaranteed.  The .c, _p.c, _i.c, .tlb,
//     _c.c, _s.c files are all conditional on the contents of the idl file...
//
//         IDL_TYPE = ole
//              .idl -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_SOURCEDIR)\.c
//                      $(PASS0_PROXYDIR)\_p.c,
//                      $(PASS0_DLLDATADIR)\_d.c,
//                      $(PASS0_TLBDIR)\.c,
TARGETDATA IDLDataOle0[] = {
    { TD_PASS0HDRDIR, ".h"},   // Header File
//                         { TD_PASS0DIR2,   ".c" },   // UUID file
//                         { TD_PASS0DIR1,   "_p.c" }, // Proxy Stub File
};
OBJECTTARGETINFO IDLInfoOle0 =
{ ".idl", ARRAY_SIZE(IDLDataOle0, TARGETDATA), IDLDataOle0};

//         IDL_TYPE = rpc
//              .idl -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_CLIENTDIR)\_c.c,
//                      $(PASS0_SERVERDIR)\_s.c,
TARGETDATA IDLDataRpc0[] = {
    { TD_PASS0HDRDIR, ".h"},   // Header File
//                         { TD_PASS0DIR1,   "_c.c" }, // Client Stub File
//                         { TD_PASS0DIR2,   "_s.c" }, // Server Stub File
};
OBJECTTARGETINFO IDLInfoRpc0 =
{ ".idl", ARRAY_SIZE(IDLDataRpc0, TARGETDATA), IDLDataRpc0};

//          ------
LPOBJECTTARGETINFO aMidlTargetInfo0[] = {
    &IDLInfoOle0,
    &IDLInfoRpc0,
};
UCHAR cMidlTargetInfo0 = ARRAY_SIZE(aMidlTargetInfo0, LPOBJECTTARGETINFO);

//          ------
//
// Any extension not given in the above table is assumed to have a target in
// the ObjectDirectory[iObjectDir] (obj\*) & have a target extension of .obj.
//

TARGETDATA DefaultData = { TD_OBJECTDIR, ".obj"};


//*******

TARGET *
BuildCompileTarget(
                  FILEREC *pfr,
                  LPSTR    pszfile,
                  USHORT   TargetIndex,
                  LPSTR    pszConditionalIncludes,
                  DIRREC  *pdrBuild,
                  DIRSUP  *pdsBuild,
                  LONG     iPass,
                  LPSTR    *ppszObjectDir,
                  LPSTR    pszSourceDir);


//+---------------------------------------------------------------------------
//
//  Function:   ExpandObjAsterisk
//
//  Synopsis:   Expand an asterisk in a filename to a platform name
//
//  Arguments:  [pbuf]               -- Output buffer for new filename
//              [pszpath]            -- Input filename w/ asterisk
//              [ppszObjectDirectory] -- String[2] to replace asterisk with
//
//----------------------------------------------------------------------------

VOID
ExpandObjAsterisk(
                 LPSTR pbuf,
                 LPSTR pszpath,
                 LPSTR *ppszObjectDirectory)
{
    SplitToken(pbuf, '*', &pszpath);
    if (*pszpath == '*') {
        assert(strncmp(
                      pszObjDirSlash,
                      ppszObjectDirectory[iObjectDir],
                      strlen(pszObjDirSlash)) == 0);
        strcat(pbuf, ppszObjectDirectory[iObjectDir] + strlen(pszObjDirSlash));
        strcat(pbuf, pszpath + 1);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CountSourceLines
//
//  Synopsis:   Counts the source lines in a given file, including headers if
//              the '-S' option was given.
//
//  Arguments:  [idScan] -- Used to catch multiple inclusions
//              [pfr]    -- File to scan
//
//  Returns:    Number of lines
//
//----------------------------------------------------------------------------

LONG
CountSourceLines(USHORT idScan, FILEREC *pfr)
{
    INCLUDEREC *pir;

    AssertFile(pfr);

    // if we have already seen this file before, then assume
    // that #if guards prevent it's inclusion

    if (pfr->idScan == idScan) {
        return (0L);
    }

    pfr->idScan = idScan;

    //  Start off with the file itself
    pfr->TotalSourceLines = pfr->SourceLines;

    if (fStatusTree) {

        //
        // If the user asked for include file line counts, then walk include
        // tree, accruing nested include file line counts .
        //

        for (pir = pfr->IncludeFilesTree; pir != NULL; pir = pir->NextTree) {
            AssertInclude(pir);
            if (pir->pfrInclude != NULL) {
                AssertFile(pir->pfrInclude);
                pfr->TotalSourceLines +=
                CountSourceLines(idScan, pir->pfrInclude);
            }
        }
    }
    return (pfr->TotalSourceLines);
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanNTTargetFile0
//
//  Synopsis:   Parses pzFiles and deletes all files listed.
//               pzFile must have been allocated by MakeMacroString.
//               No asterisk expansion performed.
//
//              This is used when fClean is TRUE and SOURCES_OPTIONS
//               includes -c0. See ReadSourcesFile. Note that
//               SOURCES_OPTIONS must be defined before NTTARGETFILE0.
//              This is a mechanism to delete target files not
//               included in _objects.mac.
//
//  Arguments:  [pzFiles] -- List of files
//
//----------------------------------------------------------------------------
VOID
CleanNTTargetFile0 (char * pzFiles)
{
    BOOL fRestoreSep;
    char * pzDelete;

    while (*pzFiles != '\0') {
        pzDelete = pzFiles;

        // Find end of the next file name and NULL terminate it (if needed)
        fRestoreSep = FALSE;
        while (*pzFiles != '\0') {
            if (*pzFiles == ' ') {
                fRestoreSep = TRUE;
                *pzFiles = '\0';
                break;
            } else {
                pzFiles++;
            }
        }

        DeleteSingleFile (NULL, pzDelete, FALSE);

        if (fRestoreSep) {
            *pzFiles++ = ' ';
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessSourceDependencies
//
//  Synopsis:   Scan all source files in a given directory tree to determine
//              which files are out of date and need to be compiled and/or
//              linked.
//
//  Arguments:  [DirDB]           -- Directory to process
//              [pds]             -- Supplementary directory information
//              [DateTimeSources] -- Timestamp of 'sources' file
//
//----------------------------------------------------------------------------

VOID
ProcessSourceDependencies(DIRREC *DirDB, DIRSUP *pds, ULONG DateTimeSources)
{
    TARGET *Target;
    ULONG DateTimePch = 0;    // Actual timestamp of pch preserved here.
    UINT i;
    SOURCEREC *apsr[3];
    SOURCEREC **ppsr;
    char path[DB_MAX_PATH_LENGTH];
    static USHORT idScan = 0;

    AssertDir(DirDB);

    apsr[0] = pds->psrSourcesList[0];
    apsr[1] = pds->psrSourcesList[1];

    //
    // For a clean build, just delete all targets
    //
    if (fFirstScan && fClean && !fKeep) {
        DeleteMultipleFiles(szObjDir, "*.*");    // _objects.mac
        for (i = 0; i < CountTargetMachines; i++) {
            assert(strncmp(
                          pszObjDirSlash,
                          TargetMachines[i]->ObjectDirectory[iObjectDir],
                          strlen(pszObjDirSlash)) == 0);
            DeleteMultipleFiles(TargetMachines[i]->ObjectDirectory[iObjectDir], "*.*");

            apsr[2] = pds->psrSourcesList[TargetToPossibleTarget[i] + 2];

            //
            // Delete the pch file if we have one.
            //
            if (pds->PchTarget != NULL) {
                char TargetDir[DB_MAX_PATH_LENGTH];
                ExpandObjAsterisk(TargetDir,
                                  pds->PchTargetDir,
                                  TargetMachines[i]->ObjectDirectory);

                //
                // Kind of a cludgy way to do this, but we must ensure that
                // we don't delete a pch file that was built earlier on during
                // this same build.  We do this by comparing the timestamp of
                // the pch file against the time we started the build.
                //
                if ((*pDateTimeFile)(TargetDir, pds->PchTarget) <= BuildStartTime) {
                    DeleteSingleFile(TargetDir, pds->PchTarget, FALSE);
                    if (DirDB->PchObj != NULL) {
                        ExpandObjAsterisk(path,
                                          DirDB->PchObj,
                                          TargetMachines[i]->ObjectDirectory);
                        DeleteSingleFile(NULL, path, FALSE);
                    } else {
                        char *p;
                        strcpy(path, pds->PchTarget);
                        p = strrchr(path, '.');
                        if (p != NULL && strcmp(p, ".pch") == 0) {
                            strcpy(p, ".obj");
                            DeleteSingleFile(TargetDir, path, FALSE);
                        }
                    }
                }
            }

            if (DirDB->DirFlags & DIRDB_PASS0) {
                for (ppsr = apsr; ppsr < apsr + (sizeof(apsr)/sizeof(*apsr)); ppsr++) {
                    SOURCEREC *psr;

                    if (*ppsr == NULL) {
                        continue;
                    }

                    for (psr = *ppsr; psr != NULL; psr = psr->psrNext) {
                        FILEREC *pfr;

                        AssertSource(psr);

                        pfr = psr->pfrSource;

                        //
                        // Pass Zero files have different target directories.
                        //
                        if (pfr->FileFlags & FILEDB_PASS0) {
                            USHORT j;
                            //
                            // If the file has multiple targets, (e.g. .mc,
                            // .idl or .asn), then loop through all targets.
                            //
                            j = 0;
                            while (Target = BuildCompileTarget(
                                                              pfr,
                                                              pfr->Name,
                                                              j,
                                                              pds->ConditionalIncludes,
                                                              DirDB,
                                                              pds,
                                                              0,        // pass 0
                                                              TargetMachines[i]->ObjectDirectory,
                                                              TargetMachines[i]->SourceDirectory)) {

                                DeleteSingleFile(NULL, Target->Name, FALSE);

                                FreeMem(&Target, MT_TARGET);

                                j++;
                            }
                        }
                    }
                }
            }

            if ((DirDB->DirFlags & DIRDB_TARGETFILE0) && (DirDB->NTTargetFile0 != NULL)) {
                CleanNTTargetFile0 (DirDB->NTTargetFile0);
            }
        }
    }

    if (fFirstScan && (DirDB->DirFlags & DIRDB_TARGETFILE0)) {
        DirDB->DirFlags |= DIRDB_PASS0NEEDED;
    }

    if (!fQuickZero || !fFirstScan || !RecurseLevel) {
        GenerateObjectsDotMac(DirDB, pds, DateTimeSources);
    } else if (fFirstScan) {
        SOURCEREC *psr;
        USHORT j;
        USHORT k;
        BOOL fNeedCompile = FALSE;

        if ( !(DirDB->DirFlags & DIRDB_PASS0NEEDED)) {

            for (i = 0; i < CountTargetMachines; i++) {

                for (k = 0; k < 2; k++) {
                    for (psr = pds->psrSourcesList[k]; psr != NULL; psr = psr->psrNext) {
                        FILEREC *pfr;

                        AssertSource(psr);

                        pfr = psr->pfrSource;

                        AssertFile(pfr);

                        if (pfr->FileFlags & FILEDB_PASS0) {

                            for (j = 0;
                                Target = BuildCompileTarget(
                                                           pfr,
                                                           pfr->Name,
                                                           j,
                                                           pds->ConditionalIncludes,
                                                           DirDB,
                                                           pds,
                                                           0,
                                                           TargetMachines[i]->ObjectDirectory,
                                                           TargetMachines[i]->SourceDirectory);
                                j++) {

                                if ((psr->SrcFlags & SOURCEDB_FILE_MISSING) ||
                                    (Target->DateTime == 0) ||
                                    ((pfr->FileFlags & FILEDB_C) && Target->DateTime < DateTimePch)) {
                                    fNeedCompile = TRUE;
                                }

                                FreeMem(&Target, MT_TARGET);
                            }

                            if (fNeedCompile) {
                                DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                            }
                        }
                    }
                }
            }
        }

        if (DirDB->DirFlags & DIRDB_PASS0NEEDED) {
            GenerateObjectsDotMac(DirDB, pds, DateTimeSources);
        }
    }

    if ((DirDB->TargetExt != NULL) &&
        (DirDB->TargetName != NULL) &&
        (DirDB->TargetPath != NULL) &&
        (fClean && !fKeep)) {
        // If we haven't already deleted the final target, do so now.
        if (_memicmp(DirDB->TargetPath, pszObjDirSlash, strlen(pszObjDirSlash) -1)) {
            for (i = 0; i < CountTargetMachines; i++) {
                FormatLinkTarget(
                                path,
                                TargetMachines[i]->ObjectDirectory,
                                DirDB->TargetPath,
                                DirDB->TargetName,
                                DirDB->TargetExt);
                DeleteSingleFile(NULL, path, FALSE);
                FormatLinkTarget(
                                path,
                                TargetMachines[i]->ObjectDirectory,
                                DirDB->TargetPath,
                                DirDB->TargetName,
                                ".pdb");
                DeleteSingleFile(NULL, path, FALSE);
            }
        }
    }

    if (pds->fNoTarget) {
        if (apsr[0] || apsr[1] || !(DirDB->DirFlags & DIRDB_PASS0NEEDED) || fSemiQuicky) {
            // If there's sources to compile, mark as such then get out.
            DirDB->DirFlags |= DIRDB_COMPILENEEDED;
        }
        return;
    }

    if (fQuicky) {
        if (fSemiQuicky)
            DirDB->DirFlags |= DIRDB_COMPILENEEDED;
        else
            DirDB->DirFlags |= DIRDB_PASS0NEEDED;
        return;
    }

    //
    // For a DLL or LIB target, ensure that it will be rebuilt
    //
    if (DirDB->TargetPath != NULL &&
        DirDB->TargetName != NULL &&
        ((DirDB->DirFlags & DIRDB_DLLTARGET) ||
         (DirDB->TargetExt != NULL && strcmp(DirDB->TargetExt, ".lib") == 0))) {

        for (i = 0; i < CountTargetMachines; i++) {
            FormatLinkTarget(
                            path,
                            TargetMachines[i]->ObjectDirectory,
                            DirDB->TargetPath,
                            DirDB->TargetName,
                            ".lib");

            if (ProbeFile(NULL, path) == -1) {
                DirDB->DirFlags |= DIRDB_COMPILENEEDED;
            } else
                if (fFirstScan && (fCleanLibs || (fClean && !fKeep))) {
                DeleteSingleFile(NULL, path, FALSE);
                DirDB->DirFlags |= DIRDB_COMPILENEEDED;
            }
        }
    }

    //
    // If the scan flags have changed (or haven't been set), then indicate
    // that we should look for the actual location of global included files
    // instead of assuming it's in the same location as we last knew.  This is
    // because different directories my include the same file from different
    // places.
    //
    if (GlobalSequence == 0 ||
        ScanFlagsLast == 0 ||
        ScanFlagsLast != ScanFlagsCurrent) {

        GlobalSequence++;               // don't reuse snapped global includes
        if (GlobalSequence == 0) {
            GlobalSequence++;
        }
        ScanFlagsLast = ScanFlagsCurrent;
    }

    //
    // Do the same as above for locally included files.
    //
    LocalSequence++;                    // don't reuse snapped local includes
    if (LocalSequence == 0) {
        LocalSequence++;
    }

    for (i = 0; i < CountTargetMachines; i++) {

        //
        // Ensure that precompiled headers are rebuilt as necessary.
        //

        if (!fPassZero && (pds->PchInclude != NULL || pds->PchTarget != NULL)) {
            LPSTR p;

            ExpandObjAsterisk(
                             path,
                             pds->PchTargetDir != NULL?
                             pds->PchTargetDir : pszObjDirSlashStar,
                             TargetMachines[i]->ObjectDirectory);

            if (!CanonicalizePathName(path, CANONICALIZE_DIR, path)) {
                DateTimePch = ULONG_MAX;        // always out of date
                goto ProcessSourceList;
            }
            strcat(path, "\\");

            //
            // If they gave a target directory for the pch file, then use it,
            // otherwise assume it's in the same directory as the .h file.
            //
            if (pds->PchTarget != NULL) {
                strcat(path, pds->PchTarget);
            } else {
                assert(pds->PchInclude != NULL);
                p = path + strlen(path);
                if ( DirDB->Pch ) {
                    strcpy(p, DirDB->Pch);
                } else {
                    strcpy(p, pds->PchInclude);
                    if ((p = strrchr(p, '.')) != NULL) {
                        *p = '\0';
                    }
                    strcat(path, ".pch");
                }
            }

            //
            // 'path' now contains the (possibly relative) path name of
            // the PCH target: "..\path\foobar.pch"
            //
            Target = BuildCompileTarget(
                                       NULL,
                                       path,
                                       0,
                                       pds->ConditionalIncludes,
                                       DirDB,
                                       NULL,
                                       1,        // pass 1
                                       TargetMachines[i]->ObjectDirectory,
                                       TargetMachines[i]->SourceDirectory);

            DateTimePch = Target->DateTime;

            if (DateTimePch == 0) {             // Target doesn't exist
                DateTimePch = ULONG_MAX;        // Always out of date
            }

            if (fClean && !fKeep && fFirstScan) {
                // Target will be deleted later if it exists.
            } else if (pds->PchInclude == NULL) {

                //
                // The SOURCES file didn't indicate where the source file
                // for the .pch is, so assume the .pch binary is up to date
                // with respect to the source includes and with respect to
                // the pch source file itself.
                //
                // char szFullPath[DB_MAX_PATH_LENGTH];

                // CanonicalizePathName(DirDB->Name, CANONICALIZE_DIR, szFullPath);

                //BuildMsg("SOURCES file in %s gives PRECOMPILED_TARGET but not "
                //         "PRECOMPILED_INCLUDE.\r\n", szFullPath);
                Target->DateTime = 0;           // Don't delete pch target
            } else {
                FILEREC *pfrPch = NULL;

                path[0] = '\0';

                if (pds->PchIncludeDir != NULL) {
                    strcpy(path, pds->PchIncludeDir);
                    strcat(path, "\\");
                }
                strcat(path, pds->PchInclude);

                if ((pds->PchIncludeDir != NULL) &&
                    (IsFullPath(pds->PchIncludeDir))) {
                    DIRREC *DirDBPch;

                    DirDBPch = FindSourceDirDB(pds->PchIncludeDir,
                                               pds->PchInclude, TRUE);

                    if (DirDBPch) {
                        pfrPch = FindSourceFileDB(DirDBPch,
                                                  pds->PchInclude,
                                                  NULL);
                    }
                } else {
                    pfrPch = FindSourceFileDB(DirDB, path, NULL);
                }


                if (pfrPch != NULL) {
                    FILEREC *pfrRoot;
                    SOURCEREC *psr = NULL;

                    BOOL fCase1;
                    BOOL fCase2;
                    BOOL fCase3;
                    BOOL fNeedCompile;
                    BOOL fCheckDepends;

                    // Remote directory PCH files can't be found here

                    if (pfrPch->Dir == DirDB) {
                        psr = FindSourceDB(pds->psrSourcesList[0], pfrPch);
                        assert(psr != NULL);
                        psr->SrcFlags |= SOURCEDB_PCH;
                    }

                    Target->pfrCompiland = pfrPch;
                    assert((pfrRoot = NULL) == NULL);   // assign NULL

                    fNeedCompile = FALSE;
                    fCheckDepends = FALSE;

                    switch (0) {
                        default:
                            fCase1 = (fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfrPch, TRUE, &pfrRoot));
                            if ( fCase1 ) {
                                fNeedCompile = TRUE;
                                break;
                            }
                            fCase2 = (Target->DateTime == 0);
                            if ( fCase2 ) {
                                fNeedCompile = TRUE;
                                break;
                            }
                            fCase3 = (!fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfrPch, TRUE, &pfrRoot));
                            if ( fCase3 ) {
                                fNeedCompile = TRUE;
                                break;
                            }
                            break;
                    }

                    if (( fCheckIncludePaths ) && ( ! fCheckDepends )) {
                        CheckDependencies(Target, pfrPch, TRUE, &pfrRoot);
                    }

                    if (fNeedCompile) {

                        if (psr != NULL) {
                            if (fWhyBuild) {
                                BuildMsgRaw("\r\n");
                                if (fCase1) {
                                    BuildMsgRaw("Compiling %s because (Case 1) *1\r\n", psr->pfrSource->Name);
                                } else
                                    if (fCase2) {
                                    BuildMsgRaw("Compiling %s because Target date == 0 (Target->Compiland=%s) *1\r\n", psr->pfrSource->Name, Target->pfrCompiland->Name);
                                } else
                                    if (fCase3) {
                                    BuildMsgRaw("Compiling %s because (Case 3) *1\r\n", psr->pfrSource->Name);
                                }
                            }

                            psr->SrcFlags |= SOURCEDB_COMPILE_NEEDED;
                        } else {
                            if (fWhyBuild) {
                                BuildMsgRaw("\r\n");
                                BuildMsgRaw("Compiling %s because Target date == 0 (Target->Compiland=%s) *1\r\n", Target->Name, Target->pfrCompiland->Name);
                            }
                        }

                        pfrPch->Dir->DirFlags |= DIRDB_COMPILENEEDED;
                        DateTimePch = ULONG_MAX; // always out of date
                        if (fKeep) {
                            Target->DateTime = 0;  // don't delete pch target
                        }
                    } else {      // else it exists and is up to date...
                        Target->DateTime = 0;   // don't delete pch target
                    }

                    // No cycle possible at the root of the tree.
                    // 14-Jan-2000 Actually not true. See comments dated 22-Dec-1999
                    // by LeoN around line 2800.
                    // assert(pfrRoot == NULL);
                } else if (DEBUG_1) {
                    BuildError("Cannot locate precompiled header file: %s.\r\n",
                               path);
                }
            }

            //
            // Target->DateTime will be zero if the file is up to date (or we
            // don't want to delete it).  If Target->DateTime is non-zero,
            // delete the .pch and corresponding .obj file so they will be
            // rebuilt.
            //
            if (Target->DateTime != 0) {
                DeleteSingleFile(NULL, Target->Name, FALSE);
                if (DirDB->PchObj != NULL) {
                    ExpandObjAsterisk(
                                     path,
                                     DirDB->PchObj,
                                     TargetMachines[i]->ObjectDirectory);
                    DeleteSingleFile(NULL, path, FALSE);
                } else {
                    p = strrchr(Target->Name, '.');
                    if (p != NULL && strcmp(p, ".pch") == 0) {
                        strcpy(p, ".obj");
                        DeleteSingleFile(NULL, Target->Name, FALSE);
                    }
                }
            }
            FreeMem(&Target, MT_TARGET);
        }

        //
        // Check to see which files given in the SOURCES macro need to be
        // rebuilt, and delete their targets (.obj) if they're out of date.
        //

        ProcessSourceList:

        apsr[2] = pds->psrSourcesList[TargetToPossibleTarget[i] + 2];

        for (ppsr = apsr; ppsr < apsr + (sizeof(apsr)/sizeof(*apsr)); ppsr++) {
            SOURCEREC *psr;

            if (*ppsr == NULL) {
                continue;
            }


            for (psr = *ppsr; psr != NULL; psr = psr->psrNext) {
                FILEREC *pfr, *pfrRoot;

                AssertSource(psr);

                pfr = psr->pfrSource;

                AssertFile(pfr);

                if ((psr->SrcFlags & SOURCEDB_PCH) == 0) {

                    USHORT j;
                    LONG iPass, iPassEnd;

                    iPass = 1;
                    iPassEnd = 0;

                    if (pfr->FileFlags & FILEDB_PASS0)
                        iPass = 0;

                    if ((pfr->FileFlags & FILEDB_MULTIPLEPASS) ||
                        !(pfr->FileFlags & FILEDB_PASS0))
                        iPassEnd = 1;

                    assert(iPass <= iPassEnd);

                    //
                    // If we're doing a pass zero scan and the file is
                    // not a pass zero file, then continue because we
                    // don't care about it right now.
                    //
                    if (fFirstScan && fPassZero && iPass == 1) {
                        continue;
                    }

                    //
                    // Don't check dependencies of pass zero files on the
                    // second scan, because they're all supposed to be built
                    // by now.
                    //
                    if (!fFirstScan && iPassEnd == 0) {
                        continue;
                    }

                    //
                    // If the file was created during pass zero, then make sure
                    // we don't think it's still missing.
                    //
                    if (!fFirstScan &&
                        (psr->SrcFlags & SOURCEDB_FILE_MISSING) &&
                        !(pfr->FileFlags & FILEDB_FILE_MISSING)) {
                        psr->SrcFlags &= ~SOURCEDB_FILE_MISSING;
                    }

                    // If the file is a multiple pass file (e.g. .asn), loop
                    // through both passes.

                    for ( ; iPass <= iPassEnd; iPass++) {

                        //
                        // If the file has multiple targets (e.g. .mc, .idl or
                        // .asn), then loop through all the targets.
                        //
                        for (j = 0;
                            Target = BuildCompileTarget(
                                                       pfr,
                                                       pfr->Name,
                                                       j,
                                                       pds->ConditionalIncludes,
                                                       DirDB,
                                                       pds,
                                                       iPass,
                                                       TargetMachines[i]->ObjectDirectory,
                                                       TargetMachines[i]->SourceDirectory);
                            j++) {

                            BOOL fCase1;
                            BOOL fCase2;
                            BOOL fCase3;
                            BOOL fCase4;
                            BOOL fCase5;
                            BOOL fNeedCompile;
                            BOOL fCheckDepends;

                            if (DEBUG_4) {
                                BuildMsgRaw(szNewLine);
                            }
                            assert((pfrRoot = NULL) == NULL);   // assign NULL

                            //  Decide whether the target needs to be compiled.
                            //  Forcibly examine dependencies to get line count.

                            fNeedCompile = FALSE;
                            fCheckDepends = FALSE;

                            switch (0) {
                                default:
                                    fCase1 = (psr->SrcFlags & SOURCEDB_FILE_MISSING);
                                    if ( fCase1 ) {
                                        fNeedCompile = TRUE;
                                        break;
                                    }
                                    fCase2 = (fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfr, TRUE, &pfrRoot));
                                    if ( fCase2 ) {
                                        fNeedCompile = TRUE;
                                        break;
                                    }
                                    fCase3 = (Target->DateTime == 0);
                                    if ( fCase3 ) {
                                        fNeedCompile = TRUE;
                                        break;
                                    }
                                    fCase4 = ((pfr->FileFlags & FILEDB_C) && Target->DateTime < DateTimePch);
                                    if ( fCase4 ) {
                                        fNeedCompile = TRUE;
                                        break;
                                    }
                                    fCase5 = (!fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfr, TRUE, &pfrRoot));
                                    if ( fCase5 ) {
                                        fNeedCompile = TRUE;
                                        break;
                                    }
                                    break;
                            }

                            if (( fCheckIncludePaths ) && ( ! fCheckDepends )) {
                                CheckDependencies(Target, pfr, TRUE, &pfrRoot);
                            }

                            if ( fNeedCompile ) {
                                if (fWhyBuild) {
                                    BuildMsgRaw("\r\n");
                                    if (fCase1) {
                                        BuildMsgRaw("Compiling %s because filename is missing from build database *2\r\n", psr->pfrSource->Name);
                                    } else
                                        if (fCase2) {
                                        BuildMsgRaw("Compiling %s because (Case 2) *2\r\n", psr->pfrSource->Name);
                                    } else
                                        if (fCase3) {
                                        BuildMsgRaw("Compiling %s because Target date == 0 *2\r\n", psr->pfrSource->Name);
                                    } else
                                        if (fCase4) {
                                        BuildMsgRaw("Compiling %s because C file is later earlier than pch *2\r\n", psr->pfrSource->Name);
                                    } else
                                        if (fCase5) {
                                        BuildMsgRaw("Compiling %s because (Case 5) *2\r\n", psr->pfrSource->Name);
                                    }
                                }

                                psr->SrcFlags |= SOURCEDB_COMPILE_NEEDED;

                                if (pfr->FileFlags & FILEDB_PASS0) {
                                    DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                                } else
                                    DirDB->DirFlags |= DIRDB_COMPILENEEDED;

                                if (Target->DateTime != 0 && !fKeep) {
                                    DeleteSingleFile(NULL, Target->Name, FALSE);
                                }

                                FreeMem(&Target, MT_TARGET);

                                if (j != 0) {
                                    //
                                    // Delete the 'rule target' so nmake
                                    // doesn't complain about "don't know how
                                    // to make ..."
                                    //
                                    Target = BuildCompileTarget(
                                                               pfr,
                                                               pfr->Name,
                                                               0,
                                                               pds->ConditionalIncludes,
                                                               DirDB,
                                                               pds,
                                                               iPass,
                                                               TargetMachines[i]->ObjectDirectory,
                                                               TargetMachines[i]->SourceDirectory);
                                    if (Target) {
                                        DeleteSingleFile(
                                                        NULL,
                                                        Target->Name,
                                                        FALSE);

                                        FreeMem(&Target, MT_TARGET);
                                    }
                                }

                                // No need to check other targets,
                                // we know they all will be rebuilt.
                                break;
                            }

                            // No cycle possible at the root of the tree.

                            // 14-Jan-2000 Actually not true. See comments dated 22-Dec-1999
                            // by LeoN around line 2800.
                            // assert(pfrRoot == NULL);
                            FreeMem(&Target, MT_TARGET);
                        }
                    }
                }
                if (fClean || (psr->SrcFlags & SOURCEDB_COMPILE_NEEDED)) {
                    ULONG cline;

                    if (++idScan == 0) {
                        ++idScan;               // skip zero
                    }

                    if (fFirstScan && (pfr->FileFlags & FILEDB_PASS0)) {
                        cline = CountSourceLines(idScan, pfr);
                        DirDB->PassZeroLines += cline;
                        DirDB->CountOfPassZeroFiles++;
                    }

                    // For a multiple pass file, we really need to count the
                    // lines in the file compiled duing pass1 (and generated
                    // during pass 0).  Instead, we just count the pass 0
                    // source file all over again.  It's cheap, but the line
                    // count is inaccurate.

                    if (!fPassZero &&
                        ((pfr->FileFlags & FILEDB_MULTIPLEPASS) ||
                         !(pfr->FileFlags & FILEDB_PASS0))) {
                        cline = CountSourceLines(idScan, pfr);
                        DirDB->SourceLinesToCompile += cline;
                        DirDB->CountOfFilesToCompile++;
                    }
                }
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanSourceDirectories
//
//  Synopsis:   Scan a source directory to determine what files it
//              contains, whether it should be compiled or linked, and
//              whether it has subdirectories that we should process.
//
//  Arguments:  [DirName] -- Directory to scan
//
//----------------------------------------------------------------------------

VOID
ScanSourceDirectories(LPSTR DirName)
{
    char path[DB_MAX_PATH_LENGTH];
    PDIRREC DirDB;
    DIRSUP *pds = NULL;
    LPSTR SavedCurrentDirectory;
    BOOL DirsPresent;
    ULONG DateTimeSources = 0;
    UINT i;

    if (DEBUG_4) {
        BuildMsgRaw(
                   "ScanSourceDirectories(%s) level = %d\r\n",
                   DirName,
                   RecurseLevel);
    }

    // Change to the given directory
    SavedCurrentDirectory = PushCurrentDirectory(DirName);

    // Process all the files in this directory
    DirDB = ScanDirectory(DirName);

    AssertOptionalDir(DirDB);
    if (fCleanRestart && DirDB != NULL && !strcmp(DirDB->Name, RestartDir)) {
        fCleanRestart = FALSE;
        fClean = fRestartClean;
        fCleanLibs = fRestartCleanLibs;
    }

    if (!DirDB || !(DirDB->DirFlags & (DIRDB_DIRS | DIRDB_SOURCES))) {
        PopCurrentDirectory(SavedCurrentDirectory);
        return;
    }

    if (fShowTree && !(DirDB->DirFlags & DIRDB_SHOWN)) {
        AddShowDir(DirDB);
    }

    if (DirDB->DirFlags & DIRDB_SOURCES) {
        BOOL fSourcesRead = TRUE;

        SetObjDir((DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) != 0);

        //
        // This directory contains a SOURCES file
        //

        if (fFirstScan) {
            AllocMem(sizeof(DIRSUP), &pds, MT_DIRSUP);
            memset(pds, 0, sizeof(*pds));
            fSourcesRead = ReadSourcesFile(DirDB, pds, &DateTimeSources);

            DirDB->pds = pds;
        } else {
            pds = DirDB->pds;

            assert(pds);

            DateTimeSources = pds->DateTimeSources;

            //
            // We need to rebuild the sources list because
            // the previous scan was probably not complete.
            //
            if (pds)
                PostProcessSources(DirDB, pds);

        }

        assert(pds);

        if (DEBUG_4) {
            BuildMsgRaw("ScanSourceDirectories(%s) SOURCES\r\n", DirName);
        }

        ScanFlagsCurrent = 0;
        CountIncludeDirs = CountSystemIncludeDirs;

        //  Scan the include environments in the order that MAKEFILE.DEF
        //  processes them.  This order is:
        //
        //  1) Sources variable INCLUDE
        //  2) Cairo/Chicago directories
        //  3) System includes
        //  4) UMTYPE-derived includes
        //
        //  The subtlety is that we must do this in the reverse order
        //  since each of the processing routines pushes search directories
        //  onto the HEAD of the include search list.
        //
        //  Note: we come in here with the system includes already set.
        //  There's no way to stick the UMTYPE-derived ones ahead of the
        //  system includes

        //  4) UMTYPE-derived includes
        if (pds->TestType != NULL && !strcmp(pds->TestType, "os2")) {
            ScanGlobalIncludeDirectory(pszIncCrt);
            ScanGlobalIncludeDirectory(pszIncOs2);
            ScanFlagsCurrent |= SCANFLAGS_OS2;
        } else
            if (pds->TestType != NULL && !strcmp(pds->TestType, "posix")) {
            ScanGlobalIncludeDirectory(pszIncPosix);
            ScanFlagsCurrent |= SCANFLAGS_POSIX;
        } else {
            ScanGlobalIncludeDirectory(pszIncCrt);
            ScanFlagsCurrent |= SCANFLAGS_CRT;
        }

        if (DirDB->DirFlags & DIRDB_CHICAGO_INCLUDES) {
            ScanGlobalIncludeDirectory(pszIncChicago);
            ScanFlagsCurrent |= SCANFLAGS_CHICAGO;
        }

        //  Sources variable INCLUDES
        if (pds->LocalIncludePath)
            ScanIncludeEnv(pds->LocalIncludePath);

        //  Sources variable USER_INCLUDES
        if (pds->UserIncludePath)
            ScanIncludeEnv(pds->UserIncludePath);

        //  Sources variable LAST_INCLUDES
        if (pds->LastIncludePath)
            ScanIncludeEnv(pds->LastIncludePath);

        //  Sources variable NTINCLUDES
        if (pds->NTIncludePath)
            ScanIncludeEnv(pds->NTIncludePath);

        DirsPresent = FALSE;

    } else
        if (DirDB->DirFlags & DIRDB_DIRS) {
        //
        // This directory contains a DIRS or MYDIRS file
        //
        DirsPresent = ReadDirsFile(DirDB);

        if (DEBUG_4) {
            BuildMsgRaw("ScanSourceDirectories(%s) DIRS\r\n", DirName);
        }
    }

    if (!fQuicky || (fQuickZero && fFirstScan)) {
        if (!RecurseLevel) {
            BuildError(
                      "Examining %s directory%s for %s.%s\r\n",
                      DirDB->Name,
                      DirsPresent? " tree" : "",
                      fLinkOnly? "targets to link" : "files to compile",
                      fFirstScan ? "" : " (2nd Pass)"
                      );
        }
        ClearLine();
        BuildMsgRaw("    %s ", DirDB->Name);
        fLineCleared = FALSE;
        if (fDebug || !(BOOL) _isatty(_fileno(stderr))) {
            BuildMsgRaw(szNewLine);
            fLineCleared = TRUE;
        }
    }

    if (!fLinkOnly) {

        if (DirDB->DirFlags & DIRDB_SOURCESREAD) {
            //
            // Determine what files need to be compiled
            //
            ProcessSourceDependencies(DirDB, pds, DateTimeSources);
        } else
            if (fFirstScan && DirsPresent && (DirDB->DirFlags & DIRDB_MAKEFIL0)) {
            DirDB->DirFlags |= ((fSemiQuicky && (!fQuickZero || !fFirstScan)) ? DIRDB_COMPILENEEDED :
                                DIRDB_PASS0NEEDED);
        } else
            if (DirsPresent && (DirDB->DirFlags & DIRDB_MAKEFIL1)) {
            DirDB->DirFlags |= DIRDB_COMPILENEEDED;
        }

        if (fFirstScan && (DirDB->DirFlags & DIRDB_PASS0NEEDED)) {
            if (CountPassZeroDirs >= MAX_BUILD_DIRECTORIES) {
                BuildError(
                          "%s: Ignoring PassZero Directory table overflow, %u "
                          "entries allowed\r\n",
                          DirDB->Name,
                          MAX_BUILD_DIRECTORIES);
            } else {
                //
                // This directory needs to be compiled in pass zero.  Add it
                // to the list.
                //
                PassZeroDirs[CountPassZeroDirs++] = DirDB;
            }

            if (fQuicky && !fQuickZero) {
                if (!(fSemiQuicky && (DirDB->DirFlags & DIRDB_COMPILENEEDED))) {
                    // For -Z with compile needed anyway, CompileSourceDirectories do it.
                    CompilePassZeroDirectories();
                }
                CountPassZeroDirs = 0;
            } else {
                if (fFirstScan) {
                    fPassZero = TRUE;     // Limits scanning during pass zero.
                }

                if (DirDB->CountOfPassZeroFiles) {
                    if (fLineCleared) {
                        BuildMsgRaw("    %s ", DirDB->Name);
                    }
                    BuildMsgRaw(
                               "- %d Pass Zero files (%s lines)\r\n",
                               DirDB->CountOfPassZeroFiles,
                               FormatNumber(DirDB->PassZeroLines));
                }
            }
        }

        if ((DirDB->DirFlags & DIRDB_COMPILENEEDED) &&
            (!fFirstScan || !fPassZero)) {

            if (CountCompileDirs >= MAX_BUILD_DIRECTORIES) {
                BuildError(
                          "%s: Ignoring Compile Directory table overflow, %u "
                          "entries allowed\r\n",
                          DirDB->Name,
                          MAX_BUILD_DIRECTORIES);
            } else {
                //
                // This directory needs to be compiled.  Add it to the list.
                //
                CompileDirs[CountCompileDirs++] = DirDB;
            }

            if (fQuicky && (!fQuickZero || !fFirstScan)) {
                CompileSourceDirectories();
                CountCompileDirs = 0;
            } else
                if (DirDB->CountOfFilesToCompile) {
                if (fLineCleared) {
                    BuildMsgRaw("    %s ", DirDB->Name);
                }
                BuildMsgRaw(
                           "- %d source files (%s lines)\r\n",
                           DirDB->CountOfFilesToCompile,
                           FormatNumber(DirDB->SourceLinesToCompile));
            }
        }
    }

    if (DirsPresent && (DirDB->DirFlags & DIRDB_MAKEFILE)) {
        DirDB->DirFlags |= DIRDB_LINKNEEDED | DIRDB_FORCELINK;
    } else
        if (DirDB->DirFlags & DIRDB_TARGETFILES) {
        DirDB->DirFlags |= DIRDB_LINKNEEDED | DIRDB_FORCELINK;
    }

    if ((DirDB->DirFlags & DIRDB_LINKNEEDED) && (!fQuicky || fSemiQuicky)) {
        if (CountLinkDirs >= MAX_BUILD_DIRECTORIES) {
            BuildError(
                      "%s: Ignoring Link Directory table overflow, %u entries allowed\r\n",
                      DirDB->Name,
                      MAX_BUILD_DIRECTORIES);
        } else {
            LinkDirs[CountLinkDirs++] = DirDB;
        }
    }
    if ((DirDB->DirFlags & DIRDB_SOURCESREAD) && !fFirstScan) {
        FreeDirSupData(pds);        // free data that are no longer needed
        FreeMem(&pds, MT_DIRSUP);
        DirDB->pds = NULL;
    }

    //
    // Recurse into subdirectories
    //
    if (DirsPresent && !bBaselineFailure) {
        for (i = 1; i <= DirDB->CountSubDirs; i++) {
            FILEREC *FileDB, **FileDBNext;

            FileDBNext = &DirDB->Files;
            while (FileDB = *FileDBNext) {
                if (FileDB->SubDirIndex == (USHORT) i) {
                    GetCurrentDirectory(DB_MAX_PATH_LENGTH, path);
                    strcat(path, "\\");
                    strcat(path, FileDB->Name);
                    DirDB->RecurseLevel = (USHORT) ++RecurseLevel;
                    ScanSourceDirectories(path);
                    RecurseLevel--;
                    break;
                }
                FileDBNext = &FileDB->Next;
            }
        }
    }

    if (((fQuickZero && fFirstScan) || (!fQuicky)) && !RecurseLevel) {
        ClearLine();
    }

    PopCurrentDirectory(SavedCurrentDirectory);
}


//+---------------------------------------------------------------------------
//
//  Function:   CompilePassZeroDirectories
//
//  Synopsis:   Spawns the compiler on the directories in the PassZeroDirs
//              array.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
CompilePassZeroDirectories(
                          VOID
                          )
{
    PDIRREC DirDB;
    LPSTR SavedCurrentDirectory;
    UINT i;
    PCHAR s;

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    StartElapsedTime();
    for (i = 0; i < CountPassZeroDirs; i++) {

        DirDB = PassZeroDirs[ i ];
        AssertDir(DirDB);

        if (fQuicky && !fSemiQuicky)
            s = "Compiling and linking";
        else
            s = "Building generated files in";
        BuildColorMsg(COLOR_STATUS, "%s %s directory\r\n", s, DirDB->Name);
        LogMsg("%s %s%s\r\n", s, DirDB->Name, szAsterisks);

        if ((fQuickZero && fFirstScan) || !fQuicky) {
            SavedCurrentDirectory = PushCurrentDirectory( DirDB->Name );
        }

        if (DirDB->DirFlags & DIRDB_DIRS) {
            if (DirDB->DirFlags & DIRDB_MAKEFIL0) {
                strcpy( MakeParametersTail, " -f makefil0." );
                strcat( MakeParametersTail, " NOLINK=1" );
                if (fClean) {
                    strcat( MakeParametersTail, " clean" );
                }

                if (fQuery) {
                    BuildErrorRaw("'%s %s'\r\n", MakeProgram, MakeParameters);
                } else {
                    if (DEBUG_1) {
                        BuildMsg(
                                "Executing: %s %s\r\n",
                                MakeProgram,
                                MakeParameters);
                    }

                    CurrentCompileDirDB = NULL;
                    RecurseLevel = DirDB->RecurseLevel;
                    ExecuteProgram(MakeProgram, MakeParameters, MakeTargets, TRUE, DirDB->Name, s);
                }
            }
        } else {
            strcpy(MakeParametersTail, " NTTEST=");
            if (DirDB->KernelTest) {
                strcat(MakeParametersTail, DirDB->KernelTest);
            }

            strcat(MakeParametersTail, " UMTEST=");
            if (DirDB->UserTests) {
                strcat(MakeParametersTail, DirDB->UserTests);
            }

            if (DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) {
                strcat(MakeParametersTail, szCheckedAltDir);
            }
            if (fQuicky && !fSemiQuicky) {
                if (DirDB->DirFlags & DIRDB_DLLTARGET) {
                    strcat(MakeParametersTail, " MAKEDLL=1");
                }
                ProcessLinkTargets(DirDB, NULL);
            } else {
                strcat( MakeParametersTail, " NOLINK=1 PASS0ONLY=1");
            }

            if (fQuery) {
                BuildErrorRaw(
                             "'%s %s%s'\r\n",
                             MakeProgram,
                             MakeParameters,
                             MakeTargets);
            } else {
                if ((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                    (fParallel)) {
                    //
                    // Wait for all threads to complete before
                    // trying to compile this directory.
                    //
                    WaitForParallelThreads(DirDB);
                }
                if (DEBUG_1) {
                    BuildMsg("Executing: %s %s%s\r\n",
                             MakeProgram,
                             MakeParameters,
                             MakeTargets);
                }
                CurrentCompileDirDB = DirDB;
                RecurseLevel = DirDB->RecurseLevel;
                ExecuteProgram(
                              MakeProgram,
                              MakeParameters,
                              MakeTargets,
                              (DirDB->DirFlags & DIRDB_SYNCHRONIZE_BLOCK) != 0, DirDB->Name, s);
            }
        }
        PrintElapsedTime();
        if ((fQuickZero && fFirstScan) || !fQuicky) {
            PopCurrentDirectory(SavedCurrentDirectory);
        }

        DirDB->DirFlags &= ~DIRDB_PASS0NEEDED;
        DirDB->CountOfPassZeroFiles = 0;
        DirDB->PassZeroLines = 0;

        if (bBaselineFailure) {
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CompileSourceDirectories
//
//  Synopsis:   Spawns the compiler on the directories in the CompileDirs
//              array.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
CompileSourceDirectories(
                        VOID
                        )
{
    PDIRREC DirDB;
    LPSTR SavedCurrentDirectory;
    UINT i,j;
    PCHAR s;
    PWAITING_CONSUMER waitConsumer;
    char path[DB_MAX_PATH_LENGTH];
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
    StartElapsedTime();
    for (i = 0; i < CountCompileDirs; i++) {

        DirDB = CompileDirs[ i ];
        AssertDir(DirDB);

        if (fQuicky && !fSemiQuicky) {
            s = "Compiling and linking";
        } else {
            s = "Compiling";
        }
        BuildColorMsg(COLOR_STATUS, "%s %s directory\r\n", s, DirDB->Name);
        LogMsg("%s %s directory%s\r\n", s, DirDB->Name, szAsterisks);

        if (!fQuicky || (fQuickZero && (!fFirstScan || !RecurseLevel))) {
            SavedCurrentDirectory = PushCurrentDirectory( DirDB->Name );
            if (fQuickZero && !RecurseLevel && fFirstScan) {
                GenerateObjectsDotMac(DirDB, DirDB->pds, DirDB->pds->DateTimeSources);
            }
        }


        //In case a directory is both a consumer and block then the main thread waits 
        //for all the events this directory is waiting for. 

        if ((DirDB->DirFlags & DIRDB_SYNC_CONSUMES) && (DirDB->DirFlags & DIRDB_SYNCHRONIZE_BLOCK)) {
            PDEPENDENCY_WAIT Wait;
            PLIST_ENTRY List;

            List = DirDB->Consumes.Flink;
            while (List != &DirDB->Consumes) {
                Wait = CONTAINING_RECORD(List, DEPENDENCY_WAIT, ListEntry);
                while (!Wait->Dependency->Done) {
                    //Keep looping till the time the event is signalled.
                    CheckAllConsumer(FALSE);    
                    //Not sure if 5000 is optimum
                    WaitForSingleObject(Wait->Dependency->hEvent, 5000);
                }
                List = List->Flink;
            }
        }



        if (DirDB->DirFlags & DIRDB_DIRS) {
            if ((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                (fParallel)) {
                //
                // Wait for all threads to complete before
                // trying to compile this directory.
                //
                WaitForParallelThreads(DirDB);
            }
            if (fSemiQuicky && (DirDB->DirFlags & DIRDB_MAKEFIL0)) {
                strcpy( MakeParametersTail, " -f makefil0." );
                strcat( MakeParametersTail, " NOLINK=1" );
                if (fClean) {
                    strcat( MakeParametersTail, " clean" );
                }

                if (fQuery) {
                    BuildErrorRaw("'%s %s'\r\n", MakeProgram, MakeParameters);
                } else {
                    if (DEBUG_1) {
                        BuildMsg(
                                "Executing: %s %s\r\n",
                                MakeProgram,
                                MakeParameters);
                    }

                    CurrentCompileDirDB = NULL;
                    RecurseLevel = DirDB->RecurseLevel;
                    ExecuteProgram(MakeProgram, MakeParameters, MakeTargets, TRUE, DirDB->Name, s);
                }
            }

            if (DirDB->DirFlags & DIRDB_MAKEFIL1) {
                strcpy( MakeParametersTail, " -f makefil1." );
                strcat( MakeParametersTail, " NOLINK=1 NOPASS0=1" );
                if (fClean) {
                    strcat( MakeParametersTail, " clean" );
                }

                if (fQuery) {
                    BuildErrorRaw("'%s %s'\r\n", MakeProgram, MakeParameters);
                } else {
                    if (DEBUG_1) {
                        BuildMsg(
                                "Executing: %s %s\r\n",
                                MakeProgram,
                                MakeParameters);
                    }

                    CurrentCompileDirDB = NULL;
                    RecurseLevel = DirDB->RecurseLevel;
                    ExecuteProgram(MakeProgram, MakeParameters, MakeTargets, TRUE, DirDB->Name, s);
                }
            }
        } else {
            strcpy(MakeParametersTail, " NTTEST=");
            if (DirDB->KernelTest) {
                strcat(MakeParametersTail, DirDB->KernelTest);
            }

            strcat(MakeParametersTail, " UMTEST=");
            if (DirDB->UserTests) {
                strcat(MakeParametersTail, DirDB->UserTests);
            }

            if (fQuicky && DirDB->PchObj) {
                for (j = 0; j < CountTargetMachines; j++) {
                    FormatLinkTarget(
                                    path,
                                    TargetMachines[j]->ObjectDirectory,
                                    DirDB->TargetPath,
                                    DirDB->PchObj,
                                    "");

                    if (ProbeFile( NULL, path ) != -1) {
                        //
                        // the pch.obj file is present so we therefore
                        // must do this incremental build without pch
                        //
                        strcat( MakeParametersTail, " NTNOPCH=yes" );
                        break;
                    }
                }
            }

            if (DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) {
                strcat(MakeParametersTail, szCheckedAltDir);
            }
            if (fQuicky && !fSemiQuicky) {
                if (DirDB->DirFlags & DIRDB_DLLTARGET) {
                    strcat(MakeParametersTail, " MAKEDLL=1");
                }
                ProcessLinkTargets(DirDB, NULL);
            } else
                if (fQuicky && fSemiQuicky) {
                strcat(MakeParametersTail, " NOLINK=1");
            } else {
                strcat(MakeParametersTail, " NOLINK=1 NOPASS0=1");
            }

            if (fQuery) {
                BuildErrorRaw(
                             "'%s %s%s'\r\n",
                             MakeProgram,
                             MakeParameters,
                             MakeTargets);
            } else {
                if ((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                    (fParallel)) {
                    //
                    // Wait for all threads to complete before
                    // trying to compile this directory.
                    //
                    WaitForParallelThreads(DirDB);
                }
                if (DEBUG_1) {
                    BuildMsg("Executing: %s %s%s\r\n",
                             MakeProgram,
                             MakeParameters,
                             MakeTargets);
                }
                CurrentCompileDirDB = DirDB;
                RecurseLevel = DirDB->RecurseLevel;
                if (!(DirDB->DirFlags & DIRDB_SYNC_CONSUMES) || 
                    ((DirDB->DirFlags & DIRDB_SYNC_CONSUMES) && (DirDB->DirFlags & DIRDB_SYNCHRONIZE_BLOCK ))) {
                    ExecuteProgram(
                                  MakeProgram,
                                  MakeParameters,
                                  MakeTargets,
                                  (DirDB->DirFlags & DIRDB_SYNCHRONIZE_BLOCK) != 0, DirDB->Name, s);
                } else {
                    if ( !IsHeadInitialized ) {
                        IsHeadInitialized=TRUE;
                        InitializeListHead(&Head);
                    }

                    //add the dir to waiting list
                    waitConsumer=(PWAITING_CONSUMER) malloc( sizeof(WAITING_CONSUMER));
                    InitializeListHead(&waitConsumer->List);
                    waitConsumer->DirDB = DirDB;
                    memcpy(waitConsumer->MakeParameters , MakeParameters,MAKEPARAMETERS_MAX_LEN);
                    InsertTailList(&Head,&waitConsumer->List);
                }
            }
        }
        PrintElapsedTime();
        if (!fQuicky || (fQuickZero && (!fFirstScan || !RecurseLevel))) {
            PopCurrentDirectory(SavedCurrentDirectory);
        }
        if (bBaselineFailure) {
            break;
        }
        CheckAllConsumer(FALSE);
    }
}

VOID CheckAllConsumer ( BOOL finalCall)
{
    PLIST_ENTRY consumerListPtr,List;
    BOOL CanBeFired,checkAgain=TRUE,sync;
    PWAITING_CONSUMER waitingConsumer;
    PDEPENDENCY_WAIT Wait;
    LPSTR SavedCurrentDirectory;

    if ( IsHeadInitialized && !IsListEmpty(&Head)) {
        while (checkAgain) { //to check the waiting consumer list from the start in case even one of the consumer Directory fire
            checkAgain=FALSE;
            consumerListPtr = (&Head)->Flink;
            while (consumerListPtr != &Head ) {
                CanBeFired=TRUE;
                waitingConsumer = CONTAINING_RECORD(consumerListPtr, WAITING_CONSUMER, List);
                List = waitingConsumer->DirDB->Consumes.Flink;
                while (List != &waitingConsumer->DirDB->Consumes) {
                    Wait = CONTAINING_RECORD(List, DEPENDENCY_WAIT, ListEntry);
                    if (!Wait->Dependency->Done) {
                        if (finalCall) {
                            // In case this function is called from waitForParallel thread  
                            // we got to make sure that all the waiting consumers gets executed. For this the main thread 
                            //will wait indefinately for the Producer event to get signalled
                            if ( WaitForSingleObject(Wait->Dependency->hEvent, -1) != WAIT_OBJECT_0 ) {
                                BuildError("Fatal Error: waiting on  %s failed",Wait->Dependency->Name);
                                exit(1);
                            };
                        } else {
                            CanBeFired=FALSE;    
                            break;
                        }

                    }
                    List=List->Flink;
                }
                if (CanBeFired) {
                    SavedCurrentDirectory = PushCurrentDirectory( waitingConsumer->DirDB->Name );
                    CurrentCompileDirDB = waitingConsumer->DirDB;
                    ExecuteProgram(MakeProgram,
                                   waitingConsumer->MakeParameters,
                                   MakeTargets,
                                   FALSE, 
                                   CurrentCompileDirDB->Name, 
                                   "Building Consumer");
                    PopCurrentDirectory(SavedCurrentDirectory);                
                    RemoveEntryList(consumerListPtr);
                    free(waitingConsumer);
                    checkAgain=TRUE;
                    break;
                }
                consumerListPtr = consumerListPtr->Flink;
            }
        }

    }
}

static CountLinkTargets;

//+---------------------------------------------------------------------------
//
//  Function:   LinkSourceDirectories
//
//  Synopsis:   Link the directories given in the LinkDirs array.  This is
//              done by passing LINKONLY=1 to nmake.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
LinkSourceDirectories(VOID)
{
    PDIRREC DirDB;
    LPSTR SavedCurrentDirectory;
    UINT i;

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    CountLinkTargets = 0;
    StartElapsedTime();
    for (i = 0; i < CountLinkDirs; i++) {
        DirDB = LinkDirs[ i ];
        AssertDir(DirDB);
        SavedCurrentDirectory = PushCurrentDirectory(DirDB->Name);

        //
        // Deletes link targets as necessary
        //
        ProcessLinkTargets(DirDB, SavedCurrentDirectory);

        PopCurrentDirectory(SavedCurrentDirectory);
    }

    if (fPause && !fMTScriptSync) {
        BuildMsg("Press enter to continue with linking (or 'q' to quit)...");
        if (getchar() == 'q') {
            return;
        }
    }

    for (i = 0; i < CountLinkDirs; i++) {
        DirDB = LinkDirs[i];

        if (!fMTScriptSync &&
            (DirDB->DirFlags & DIRDB_COMPILEERRORS) &&
            (DirDB->DirFlags & DIRDB_FORCELINK) == 0) {
            BuildColorMsg(COLOR_ERROR, "Compile errors: not linking %s directory\r\n", DirDB->Name);
            LogMsg(
                  "Compile errors: not linking %s directory%s\r\n",
                  DirDB->Name,
                  szAsterisks);
            PrintElapsedTime();
            continue;
        }

        BuildColorMsg(COLOR_STATUS, "Linking %s directory\r\n", DirDB->Name);
        LogMsg("Linking %s directory%s\r\n", DirDB->Name, szAsterisks);

        SavedCurrentDirectory = PushCurrentDirectory(DirDB->Name);

        strcpy(MakeParametersTail, " LINKONLY=1 NOPASS0=1");
        strcat(MakeParametersTail, " NTTEST=");
        if (DirDB->KernelTest) {
            strcat(MakeParametersTail, DirDB->KernelTest);
        }

        strcat(MakeParametersTail, " UMTEST=");
        if (DirDB->UserTests) {
            strcat(MakeParametersTail, DirDB->UserTests);
        }

        if (DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) {
            strcat(MakeParametersTail, szCheckedAltDir);
        }

        if (DirDB->DirFlags & DIRDB_DLLTARGET) {
            strcat(MakeParametersTail, " MAKEDLL=1");
        }

        if ((DirDB->DirFlags & DIRDB_DIRS) &&
            (DirDB->DirFlags & DIRDB_MAKEFILE) &&
            fClean) {
            strcat(MakeParametersTail, " clean");
        }

        if (fQuery) {
            BuildErrorRaw(
                         "'%s %s%s'\r\n",
                         MakeProgram,
                         MakeParameters,
                         MakeTargets);
        } else {
            if ((fParallel) &&
                (((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                  (fSyncLink)) ||
                 (DirDB->DirFlags & DIRDB_SYNCHRONIZE_PASS2_DRAIN))) {

                //
                // Wait for all threads to complete before
                // trying to compile this directory.
                //
                WaitForParallelThreads(DirDB);
            }
            if (DEBUG_1) {
                BuildMsg("Executing: %s %s%s\r\n",
                         MakeProgram,
                         MakeParameters,
                         MakeTargets);
            }

            CurrentCompileDirDB = NULL;
            RecurseLevel = DirDB->RecurseLevel;
            ExecuteProgram(MakeProgram,
                           MakeParameters,
                           MakeTargets,
                           ((fSyncLink) && (DirDB->DirFlags & DIRDB_SYNCHRONIZE_BLOCK)) ||
                           (DirDB->DirFlags & DIRDB_SYNCHRONIZE_PASS2_BLOCK), 
                           DirDB->Name, 
                           "Linking");
        }
        PopCurrentDirectory(SavedCurrentDirectory);
        PrintElapsedTime();

        if (bBaselineFailure) {
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTargetData
//
//  Synopsis:   Searches aTargetInfo for an entry corresponding to the given
//              extension.
//
//  Arguments:  [ext]        -- Extension to look up (including '.').
//              [iPass]      -- 0 for pass zero; 1 for pass 1
//              [index]      -- Index used to differentiate multiple targets
//              [usMidlFlag] -- Indicates which set of MIDL targets should
//                              be used for MIDL source files.
//
//  Returns:    A TARGETDATA for the given extension and index. NULL if
//              Index is invalid.
//
//  History:    29-Jul-94     LyleC    Created
//
//  Notes:      If ext is not found in the aTargetInfo array, then a default
//              TARGETINFO is used which maps the extension to obj\*\.obj.
//
//----------------------------------------------------------------------------

LPTARGETDATA
GetTargetData(LPSTR ext, LONG iPass, USHORT index, ULONG usMidlIndex)
{
    int i;
    OBJECTTARGETINFO **aTargetInfo;
    int cTargetInfo;

    if (!ext || (ext[0] == '\0') || (ext[1] == '\0'))
        return &DefaultData;

    if ((ext[1] == aMidlTargetInfo0[usMidlIndex]->pszSourceExt[1]) &&
        (strcmp(ext, aMidlTargetInfo0[usMidlIndex]->pszSourceExt) == 0)) {
        if (index >= aMidlTargetInfo0[usMidlIndex]->NumData)
            return NULL;

        return &(aMidlTargetInfo0[usMidlIndex]->Data[index]);
    }

    assert(iPass == 0 || iPass == 1);
    cTargetInfo = aTargetArray[iPass].cTargetInfo;
    aTargetInfo = aTargetArray[iPass].aTargetInfo;

    for (i = 0; i < cTargetInfo; i++) {
        if ((ext[1] == aTargetInfo[i]->pszSourceExt[1]) &&
            (strcmp(ext, aTargetInfo[i]->pszSourceExt) == 0)) {
            if (index >= aTargetInfo[i]->NumData)
                return NULL;

            return (&aTargetInfo[i]->Data[index]);
        }
    }

    if (index)
        return NULL;

    return &DefaultData;
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildCompileTarget
//
//  Synopsis:   Fills a TARGET struct with data about the target of a given
//              source file.
//
//  Arguments:  [pfr]                    -- FileRec of source file
//              [pszfile]                -- Path of source file (compiland)
//              [TargetIndex]            -- Which target for a source file
//                                          with multiple targets.
//              [pszConditionalIncludes] -- List of conditional includes
//              [pdrBuild]               -- Build directory (with source file)
//              [iPass]                  -- 0 for pass zero; 1 for pass 1
//              [ppszObjectDir]          -- Names of target object directories
//              [pszSourceDir]           -- Name of machine specific source dir
//
//  Returns:    A filled TARGET struct.  NULL if TargetIndex is an invalid
//              value for the given file type.
//
//  Notes:      If [pfr] is NULL, then [pszfile] is not modified and is
//              used as the full pathname of the target file.
//              [pszObjectDir] is ignored in this case.  if [pfr] is not
//              NULL, the filename component of [pszfile] is taken, its
//              extension is modified, and it is appended to [pszObjectDir]
//              to obtain the pathname of the target.  The other data is
//              used to fill in the rest of the TARGET struct in all cases.
//
//              For source files with multiple targets, use the TargetIndex
//              parameter to indicate which target you want the path of.  For
//              instance, .idl files have two targets, so a TargetIndex of 0
//              will return the .h target and TargetIndex=1 will return the
//              .c target.  A TargetIndex of 2 or above in this case will
//              return NULL. TargetIndex is ignored if [pfr] is NULL.
//
//----------------------------------------------------------------------------

TARGET *
BuildCompileTarget(
                  FILEREC *pfr,
                  LPSTR    pszfile,
                  USHORT   TargetIndex,
                  LPSTR    pszConditionalIncludes,
                  DIRREC  *pdrBuild,
                  DIRSUP  *pdsBuild,
                  LONG     iPass,
                  LPSTR   *ppszObjectDir,
                  LPSTR    pszSourceDir)
{
    LPSTR p, p1;
    PTARGET Target;
    char path[DB_MAX_PATH_LENGTH];
    LPTARGETDATA pData;

    p = pszfile;
    if (pfr != NULL) {
        p1 = p;
        while (*p) {
            if (*p++ == '\\') {
                p1 = p;         // point to last component of pathname
            }
        }

        path[0] = '\0';
        strncat(path, p1, DB_MAX_PATH_LENGTH-1);


        p = strrchr(path, '.');

        pData = GetTargetData(p, iPass, TargetIndex, pdsBuild->IdlType);

        if (!pData) {
            if (DEBUG_1) {
                BuildMsg(
                        "BuildCompileTarget(\"%s\"[%u][%u], \"%s\") -> NULL\r\n",
                        pszfile,
                        iPass,
                        TargetIndex,
                        ppszObjectDir[iObjectDir]);
            }
            return NULL;
        }

        assert(pdsBuild);

        switch (pData->ObjectDirFlag) {
            case TD_OBJECTDIR:
                p = ppszObjectDir[iObjectDir];
                break;

            case TD_PASS0HDRDIR:
                p = pdsBuild->PassZeroHdrDir;
                break;

                p = pdsBuild->PassZeroSrcDir1;
                break;

            case TD_MCSOURCEDIR:
            case TD_PASS0DIR1:
                p = pdsBuild->PassZeroSrcDir1;
                break;

            case TD_PASS0DIR2:
                p = pdsBuild->PassZeroSrcDir2;
                break;

            default:
                assert(0 && "Invalid ObjectDirFlag");
                break;
        }

        if (!p) {
            // Make sure path ends in a period
            sprintf(path, "%s.", p1);
        } else
            if (p[0] == '.' && p[1] == '\0') {
            strcpy(path, p1);
        } else {
            sprintf(path, "%s\\%s", p, p1);
        }

        p = strrchr(path, '.');
        if (p == NULL) {
            BuildError("%s NoExtension specified.\r\n", pszfile);
            return NULL;
        }

        if (p) {
            strcpy(p, pData->pszTargetExt);
        }

        p = path;
    }

    AllocMem(sizeof(TARGET) + strlen(p), &Target, MT_TARGET);
    strcpy(Target->Name, p);
    Target->pdrBuild = pdrBuild;
    Target->DateTime = (*pDateTimeFile)(NULL, p);
    Target->pfrCompiland = pfr;
    Target->pszSourceDirectory = pszSourceDir;
    Target->ConditionalIncludes = pszConditionalIncludes;
    Target->DirFlags = pdrBuild->DirFlags;
    if (DEBUG_1) {
        BuildMsg(
                "BuildCompileTarget(\"%s\"[%u][%u], \"%s\") -> \"%s\"\r\n",
                pszfile,
                iPass,
                TargetIndex,
                ppszObjectDir[iObjectDir],
                Target->Name);
    }
    if (Target->DateTime == 0) {
        if (fShowOutOfDateFiles) {
            BuildError("%s target is missing.\r\n", Target->Name);
        }
    }
    return (Target);
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatLinkTarget
//
//  Synopsis:   Builds a link target path name.
//
//  Arguments:  [path]            -- Place to put constructed name
//              [ObjectDirectory] -- e.g. "obj\i386"
//              [TargetPath]      -- Path (w/o platfrom spec. name) for target
//              [TargetName]      -- Base name of target
//              [TargetExt]       -- Extension of target
//
//  Notes:      Sample input: (path, "obj\i386", "..\obj", "foobar", ".dll")
//
//                    output: path = "..\obj\i386\foobar.dll"
//
//----------------------------------------------------------------------------

VOID
FormatLinkTarget(
                LPSTR path,
                LPSTR *ObjectDirectory,
                LPSTR TargetPath,
                LPSTR TargetName,
                LPSTR TargetExt)
{
    LPSTR p, p1;

    p = ObjectDirectory[iObjectDir];
    assert(strncmp(pszObjDirSlash, p, strlen(pszObjDirSlash)) == 0);
    p1 = p + strlen(p);
    while (p1 > p) {
        if (*--p1 == '\\') {
            p1++;
            break;
        }
    }
    sprintf(path, "%s\\%s\\%s%s", TargetPath, p1, TargetName, TargetExt);
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessLinkTargets
//
//  Synopsis:   Deletes link targets for the given directory (.lib & .dll)
//
//  Arguments:  [DirDB]            -- Directory to process
//              [CurrentDirectory] -- Current directory
//
//----------------------------------------------------------------------------

VOID
ProcessLinkTargets(PDIRREC DirDB, LPSTR CurrentDirectory)
{
    UINT i;
    char path[DB_MAX_PATH_LENGTH];

    AssertDir(DirDB);
    for (i = 0; i < CountTargetMachines; i++) {
        //
        // Delete 'special' link targets
        //
        if (DirDB->KernelTest) {
            FormatLinkTarget(
                            path,
                            TargetMachines[i]->ObjectDirectory,
                            pszObjDir,
                            DirDB->KernelTest,
                            ".exe");
            if (fClean && !fKeep && fFirstScan) {
                DeleteSingleFile(NULL, path, FALSE);
            }
        } else {
            UINT j;

            for (j = 0; j < 2; j++) {
                LPSTR pNextName;

                pNextName = j == 0? DirDB->UserAppls : DirDB->UserTests;
                if (pNextName != NULL) {
                    char name[256];

                    while (SplitToken(name, '*', &pNextName)) {
                        FormatLinkTarget(
                                        path,
                                        TargetMachines[i]->ObjectDirectory,
                                        pszObjDir,
                                        name,
                                        ".exe");

                        if (fClean && !fKeep && fFirstScan) {
                            DeleteSingleFile(NULL, path, FALSE);
                        }
                    }
                }
            }
        }

        if (DirDB->TargetPath != NULL &&
            DirDB->TargetName != NULL &&
            DirDB->TargetExt != NULL &&
            strcmp(DirDB->TargetExt, ".lib")) {

            FormatLinkTarget(
                            path,
                            TargetMachines[i]->ObjectDirectory,
                            DirDB->TargetPath,
                            DirDB->TargetName,
                            DirDB->TargetExt);

            if (fClean && !fKeep && fFirstScan) {
                DeleteSingleFile(NULL, path, FALSE);
            }
        }
        if (DirDB->DirFlags & DIRDB_DIRS) {
            if (fDebug && (DirDB->DirFlags & DIRDB_MAKEFILE)) {
                BuildError(
                          "%s\\makefile. unexpected in directory with DIRS file\r\n",
                          DirDB->Name);
            }
            if ((DirDB->DirFlags & DIRDB_SOURCES)) {
                BuildError(
                          "%s\\sources. unexpected in directory with DIRS file\r\n",
                          DirDB->Name);
                BuildError("Ignoring %s\\sources.\r\n", DirDB->Name);
                DirDB->DirFlags &= ~DIRDB_SOURCES;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   IncludeError
//
//  Synopsis:   Print out the name of an include file and an error message
//              to the screen.
//
//  Arguments:  [pt]       -- Target of the file which includes the include
//                             file or [pfr].
//              [pfr]      -- File which includes the include file
//              [pir]      -- Include file at issue
//              [pszError] -- Error string
//
//  Notes:      If [pt]->pfrCompiland and [pfr] are different, then the names
//              of both are printed.
//
//----------------------------------------------------------------------------

VOID
IncludeError(TARGET *pt, FILEREC *pfr, INCLUDEREC *pir, LPSTR pszError)
{
    char c1, c2;

    AssertFile(pfr);
    AssertInclude(pir);
    if (pir->IncFlags & INCLUDEDB_LOCAL) {
        c1 = c2 = '"';
    } else {
        c1 = '<';
        c2 = '>';
    }
    BuildError("%s\\%s: ", pt->pfrCompiland->Dir->Name, pt->pfrCompiland->Name);
    if (pt->pfrCompiland != pfr) {
        if (pt->pfrCompiland->Dir != pfr->Dir) {
            BuildErrorRaw("%s\\", pfr->Dir->Name);
        }
        BuildErrorRaw("%s: ", pfr->Name);
    }
    BuildErrorRaw("%s %c%s%c\r\n", pszError, c1, pir->Name, c2);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsConditionalInc
//
//  Synopsis:   Returns TRUE if the given filename is a conditional include
//              for this directory.  (As given by the CONDITIONAL_INCLUDES
//              macro).
//
//  Arguments:  [pszFile] -- Name of file to check
//              [pt]      -- Target struct giving list of conditional includes
//
//  Returns:    TRUE if it's a conditional include
//
//----------------------------------------------------------------------------

BOOL
IsConditionalInc(LPSTR pszFile, TARGET *pt)
{
    AssertPathString(pszFile);

    if (pt->ConditionalIncludes != NULL) {
        LPSTR p;
        char name[DB_MAX_PATH_LENGTH];

        p = pt->ConditionalIncludes;
        while (SplitToken(name, ' ', &p)) {
            if (strcmp(name, pszFile) == 0) {
                return (TRUE);
            }
        }
    }
    return (FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsExcludedInc
//
//  Synopsis:   Returns TRUE if the given file is listed in the ExcludeIncs
//              array.
//
//  Arguments:  [pszFile] -- File to check
//
//----------------------------------------------------------------------------

BOOL
IsExcludedInc(LPSTR pszFile)
{
    ULONG i;

    AssertPathString(pszFile);
    for (i = 0; i < CountExcludeIncs; i++) {
        if (!strcmp(pszFile, ExcludeIncs[i])) {
            return (TRUE);
        }
    }
    return (FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckDependencies
//
//  Synopsis:   Process dependencies to see if a target is out of date
//
//  Arguments:  [Target]    -- Target to check date on (i.e. foo.obj)
//              [FileDB]    -- File which makes [Target] (i.e. foo.cpp, or bar.h)
//              [CheckDate] -- If FALSE, then the date check is bypassed.
//              [ppfrRoot]  -- Returns a cycle root if a cycle is encountered.
//                               Used only during recursion.
//
//  Returns:    TRUE if [Target] is out of date w/r/t [FileDB]
//
//----------------------------------------------------------------------------

BOOL
CheckDependencies(
                 PTARGET Target,
                 FILEREC *FileDB,
                 BOOL CheckDate,
                 FILEREC **ppfrRoot)
{
    BOOL fOutOfDate;
    BOOL CheckVersion;
    static ULONG ChkRecursLevel = 0;

    *ppfrRoot = NULL;
    ChkRecursLevel++;

    assert(FileDB != NULL);     // NULL FileDB should never happen.
    AssertFile(FileDB);

    if (FileDB->fDependActive) {

        // We have detected a loop in the graph of included files.
        // Just return, to terminate the recursion.

        if (DEBUG_1) {
            BuildMsgRaw(
                       "ChkDepend-1(%s, %s, %u) %s\r\n",
                       Target->Name,
                       FileDB->Name,
                       CheckDate,
                       "Target Match, *** ASSUME UP TO DATE ***");
        }
        if (DEBUG_4) {
            BuildMsgRaw(
                       "%lu-%hu/%hu: ChkDepend-2(%s %x, %4s%.*s%s, %u) %x %s\r\n",
                       ChkRecursLevel,
                       LocalSequence,
                       GlobalSequence,
                       Target->Name,
                       Target->DateTime,
                       "",
                       ChkRecursLevel,
                       szRecurse,
                       FileDB->Name,
                       CheckDate,
                       FileDB->DateTime,
                       "Target Match (recursive) Assume up to date");
        }

        // return the node at which the recursion begins
        *ppfrRoot = FileDB;
        ChkRecursLevel--;
        // we're "up to date" here, because another instance of the
        // file exists in our graph and dependancy will be checked there.
        return (FALSE);
    }
    if (DEBUG_4) {
        BuildMsgRaw(
                   "%lu-%hu/%hu: ChkDepend-3(%s %x, %4s%.*s%s, %u) %x\r\n",
                   ChkRecursLevel,
                   LocalSequence,
                   GlobalSequence,
                   Target->Name,
                   Target->DateTime,
                   "++",
                   ChkRecursLevel,
                   szRecurse,
                   FileDB->Name,
                   CheckDate,
                   FileDB->DateTime);
    }

    // We've decided to process this file. Mark it as being scanned.
    FileDB->fDependActive = TRUE;
    CheckVersion = fEnableVersionCheck;
    fOutOfDate = FALSE;

    if (FileDB->GlobalSequence != GlobalSequence ||
        FileDB->LocalSequence != LocalSequence) {
        if (FileDB->GlobalSequence != 0 || FileDB->LocalSequence != 0) {
            if (DEBUG_1) {
                BuildError(
                          "Include Sequence %hu/%hu -> %hu/%hu\r\n",
                          FileDB->LocalSequence,
                          FileDB->GlobalSequence,
                          LocalSequence,
                          GlobalSequence);
            }
            if (fDebug & 16) {
                PrintFileDB(stderr, FileDB, 0);
            }
            UnsnapIncludeFiles(
                              FileDB,
                              (FileDB->Dir->DirFlags & DIRDB_GLOBAL_INCLUDES) == 0 ||
                              FileDB->GlobalSequence != GlobalSequence);
        }
        FileDB->GlobalSequence = GlobalSequence;
        FileDB->LocalSequence = LocalSequence;
        FileDB->DateTimeTree = 0;
    }

    if (DEBUG_1) {
        BuildMsgRaw(
                   "ChkDepend-4(%s, %s, %u)\r\n",
                   Target->Name,
                   FileDB->Name,
                   CheckDate);
    }

    if (CheckDate &&
        (FileDB->FileFlags & FILEDB_HEADER) &&
        FileDB->DateTimeTree == 0 &&
        IsExcludedInc(FileDB->Name)) {

        if (DEBUG_1) {
            BuildMsg("Skipping date check for %s\r\n", FileDB->Name);
        }
        CheckVersion = FALSE;
        FileDB->DateTimeTree = 1;       // never out of date
    }

    if (FileDB->IncludeFiles == NULL && FileDB->DateTimeTree == 0) {
        FileDB->DateTimeTree = FileDB->DateTime;
        if (DEBUG_4) {
            BuildMsgRaw(
                       "%lu-%hu/%hu: ChkDepend-5(%s %x, %4s%.*s%s, %u) %x\r\n",
                       ChkRecursLevel,
                       LocalSequence,
                       GlobalSequence,
                       Target->Name,
                       Target->DateTime,
                       "t<-f",
                       ChkRecursLevel,
                       szRecurse,
                       FileDB->Name,
                       CheckDate,
                       FileDB->DateTime);
        }
    }
    if (CheckDate &&
        (Target->DateTime < FileDB->DateTime ||
         Target->DateTime < FileDB->DateTimeTree)) {
        if (Target->DateTime != 0) {
            if (DEBUG_1 || fShowOutOfDateFiles) {
                BuildMsg("%s is out of date with respect to %s\\%s.\r\n",
                         Target->Name,
                         FileDB->NewestDependency->Dir->Name,
                         FileDB->NewestDependency->Name);
            }
        }
        fOutOfDate = TRUE;
    }

    //
    // If FileDB->DateTimeTree is non-zero, then the field is equal to the
    // newest DateTime of this file or any of its dependants, so we don't
    // need to go through the dependency tree again.
    //

    if (FileDB->DateTimeTree == 0) {
        INCLUDEREC *IncludeDB, **IncludeDBNext, **ppirTree;

        //
        // Find the file records for all include files so that after cycles are
        // collapsed, we won't attempt to lookup an include file relative to
        // the wrong directory.
        //

        ppirTree = &FileDB->IncludeFilesTree;
        for (IncludeDBNext = &FileDB->IncludeFiles;
            (IncludeDB = *IncludeDBNext) != NULL;
            IncludeDBNext = &IncludeDB->Next) {

            AssertInclude(IncludeDB);
            AssertCleanTree(IncludeDB, FileDB);
            IncludeDB->IncFlags |= INCLUDEDB_SNAPPED;
            if (IncludeDB->pfrInclude == NULL) {
                IncludeDB->pfrInclude =
                FindIncludeFileDB(
                                 FileDB,
                                 Target->pfrCompiland,
                                 Target->pdrBuild,
                                 Target->pszSourceDirectory,
                                 IncludeDB);
                AssertOptionalFile(IncludeDB->pfrInclude);
                if (IncludeDB->pfrInclude != NULL &&
                    (IncludeDB->pfrInclude->Dir->DirFlags & DIRDB_GLOBAL_INCLUDES)) {
                    IncludeDB->IncFlags |= INCLUDEDB_GLOBAL;
                }

            }
            if (IncludeDB->pfrInclude == NULL) {
                if (!IsConditionalInc(IncludeDB->Name, Target)) {
                    if (DEBUG_1 || !(IncludeDB->IncFlags & INCLUDEDB_MISSING)) {
                        if (!fSilentDependencies) {
                            IncludeError(
                                        Target,
                                        FileDB,
                                        IncludeDB,
                                        "cannot find include file");
                        }
                        IncludeDB->IncFlags |= INCLUDEDB_MISSING;
                    }
                } else
                    if (DEBUG_1) {
                    if (!fSilentDependencies) {
                        IncludeError(
                                    Target,
                                    FileDB,
                                    IncludeDB,
                                    "Skipping missing conditional include file");
                    }
                }
                continue;
            }
            *ppirTree = IncludeDB;
            ppirTree = &IncludeDB->NextTree;
        }
        *ppirTree = NULL;       // truncate any links from previous sequence
        FileDB->DateTimeTree = FileDB->DateTime;

        //
        // Walk through the dynamic list.
        //
        rescan:
        for (IncludeDBNext = &FileDB->IncludeFilesTree;
            (IncludeDB = *IncludeDBNext) != NULL;
            IncludeDBNext = &IncludeDB->NextTree) {

            AssertInclude(IncludeDB);
            if (DEBUG_2) {
                BuildMsgRaw(
                           "%lu-%hu/%hu %s  %*s%-10s %*s%s\r\n",
                           ChkRecursLevel,
                           LocalSequence,
                           GlobalSequence,
                           Target->pfrCompiland->Name,
                           (ChkRecursLevel - 1) * 2,
                           "",
                           IncludeDB->Name,
                           max(0, 12 - ((int)ChkRecursLevel - 1) * 2),
                           "",
                           IncludeDB->pfrInclude != NULL?
                           IncludeDB->pfrInclude->Dir->Name : "not found");
            }

            //
            //  tommcg 5/21/98
            //
            //  If included file is not in "sanctioned" path, warn about it.
            //  Sanctioned paths are set in an environment variable named
            //  BUILD_ACCEPTABLE_INCLUDES which can contain wildcards and look
            //  something like this:
            //
            //  *\nt\public\*;*\nt\private\inc\*;*\..\inc\*;*\..\include\*
            //

            if (( fCheckIncludePaths ) && ( IncludeDB->pfrInclude != NULL )) {

                CheckIncludeForWarning(
                                      Target->pfrCompiland->Dir->Name,
                                      Target->pfrCompiland->Name,
                                      FileDB->Dir->Name,
                                      FileDB->Name,
                                      IncludeDB->pfrInclude->Dir->Name,
                                      IncludeDB->pfrInclude->Name
                                      );
            }

            assert(IncludeDB->IncFlags & INCLUDEDB_SNAPPED);
            if (IncludeDB->pfrInclude != NULL) {
                if (fEnableVersionCheck) {
                    CheckDate = (IncludeDB->pfrInclude->Version == 0);
                }

                if (IncludeDB->Version != IncludeDB->pfrInclude->Version) {
                    if (CheckVersion) {
                        if (DEBUG_1 || fShowOutOfDateFiles) {
                            BuildError(
                                      "%s (v%d) is out of date with "
                                      "respect to %s\\%s (v%d).\r\n",
                                      FileDB->Name,
                                      IncludeDB->Version,
                                      IncludeDB->pfrInclude->Dir->Name,
                                      IncludeDB->pfrInclude->Name,
                                      IncludeDB->pfrInclude->Version);
                        }
                        FileDB->DateTimeTree = ULONG_MAX; // always out of date
                        fOutOfDate = TRUE;
                    } else
                        if (!fClean && fEnableVersionCheck) {
                        BuildError(
                                  "%s - #include %s (v%d updated to v%d)\r\n",
                                  FileDB->Name,
                                  IncludeDB->pfrInclude->Name,
                                  IncludeDB->Version,
                                  IncludeDB->pfrInclude->Version);
                    }
                    IncludeDB->Version = IncludeDB->pfrInclude->Version;
                    AllDirsModified = TRUE;
                }
                if (CheckDependencies(Target,
                                      IncludeDB->pfrInclude,
                                      CheckDate,
                                      ppfrRoot)) {
                    fOutOfDate = TRUE;

                    // No cycle possible if recursive call returned TRUE.

                    // 29-Dec-1999 LeoN: commented out. See 22-Dec-1999
                    // comment below.
                    // assert(*ppfrRoot == NULL);
                }

                // if the include file is involved in a cycle, unwind the
                // recursion up to the root of the cycle while collpasing
                // the cycle, then process the tree again from cycle root.

                else if (*ppfrRoot != NULL) {

                    AssertFile(*ppfrRoot);

                    // Don't say the file is out of date, yet.

                    // 22-Dec-1999 LeoN: Why not? If the file we are
                    // processing is out of date with respect to it's parent,
                    // that gets lost here. The sebsequent rescan begins at
                    // this file and below, and the relationship to the parent
                    // is never checked again. Fact is, if a file has been
                    // detected as out of date, it's out of date. I'm only
                    // commenting out this reset of the flag. It's possible
                    // that one could avoid the rest of the include file scan
                    // and rescan, but I'm really concerned that there are
                    // important side effects that would miss.

                    // fOutOfDate = FALSE;

                    // Remove the current include file record from the list,
                    // because it participates in the cycle.

                    *IncludeDBNext = IncludeDB->NextTree;
                    if (IncludeDB->IncFlags & INCLUDEDB_CYCLEROOT) {
                        RemoveFromCycleRoot(IncludeDB, FileDB);
                    }
                    IncludeDB->NextTree = NULL;
                    IncludeDB->IncFlags |= INCLUDEDB_CYCLEORPHAN;

                    // If the included file is not the cycle root, add the
                    // cycle root to the included file's include file list.

                    if (*ppfrRoot != IncludeDB->pfrInclude) {
                        LinkToCycleRoot(IncludeDB, *ppfrRoot);
                    }

                    if (*ppfrRoot == FileDB) {

                        // We're at the cycle root; clear the root pointer.
                        // Then go rescan the list.

                        *ppfrRoot = NULL;
                        if (DEBUG_4) {
                            BuildMsgRaw(
                                       "%lu-%hu/%hu: ChkDepend-6(%s %x, %4s%.*s%s, %u) %x %s\r\n",
                                       ChkRecursLevel,
                                       LocalSequence,
                                       GlobalSequence,
                                       Target->Name,
                                       Target->DateTime,
                                       "^^",
                                       ChkRecursLevel,
                                       szRecurse,
                                       FileDB->Name,
                                       CheckDate,
                                       FileDB->DateTime,
                                       "ReScan");
                            BuildMsgRaw("^^\r\n");
                        }
                        goto rescan;
                    }

                    // Merge the list for the file involved in the
                    // cycle into the root file's include list.

                    MergeIncludeFiles(
                                     *ppfrRoot,
                                     FileDB->IncludeFilesTree,
                                     FileDB);
                    FileDB->IncludeFilesTree = NULL;

                    // Return immediately and reprocess the flattened
                    // tree, which now excludes the include files
                    // directly involved in the cycle.  First, make
                    // sure the files removed from the cycle have their file
                    // (not tree) time stamps reflected in the cycle root.

                    if ((*ppfrRoot)->DateTimeTree < FileDB->DateTime) {
                        (*ppfrRoot)->DateTimeTree = FileDB->DateTime;
                        (*ppfrRoot)->NewestDependency = FileDB;

                        if (DEBUG_4) {
                            BuildMsgRaw(
                                       "%lu-%hu/%hu: ChkDepend-7(%s %x, %4s%.*s%s, %u) %x\r\n",
                                       ChkRecursLevel,
                                       LocalSequence,
                                       GlobalSequence,
                                       Target->Name,
                                       Target->DateTime,
                                       "t<-c",
                                       ChkRecursLevel,
                                       szRecurse,
                                       (*ppfrRoot)->Name,
                                       CheckDate,
                                       (*ppfrRoot)->DateTimeTree);
                        }
                    }
                    break;
                }

                //
                // Propagate newest time up through the dependency tree.
                // This way, each parent will have the date of its newest
                // dependent, so we don't have to check through the whole
                // dependency tree for each file more than once.
                //
                // Note that similar behavior has not been enabled for
                // version checking.
                //

                if (FileDB->DateTimeTree < IncludeDB->pfrInclude->DateTimeTree) {
                    FileDB->DateTimeTree = IncludeDB->pfrInclude->DateTimeTree;
                    FileDB->NewestDependency =
                    IncludeDB->pfrInclude->NewestDependency;

                    if (DEBUG_4) {
                        BuildMsgRaw(
                                   "%lu-%hu/%hu: ChkDepend-8(%s %x, %4s%.*s%s, %u) %x\r\n",
                                   ChkRecursLevel,
                                   LocalSequence,
                                   GlobalSequence,
                                   Target->Name,
                                   Target->DateTime,
                                   "t<-s",
                                   ChkRecursLevel,
                                   szRecurse,
                                   FileDB->Name,
                                   CheckDate,
                                   FileDB->DateTimeTree);
                    }
                }
            } else {
                //
                // Couldn't find the FILEDB for the include file, but this
                // could be because the file is 'rcinclude'd, or 'importlib'd
                // and isn't considered a source file.  In this case, just get
                // the timestamp on the file if possible.
                //
                // Time will be zero if the file is not found.
                //
                ULONG Time = (*pDateTimeFile)(NULL, IncludeDB->Name);
                if (FileDB->DateTimeTree < Time) {
                    FileDB->DateTimeTree = Time;
                    //
                    // Since we don't have a FILEDB for this dependency, just
                    // set the pointer to itself and print a message.
                    //
                    FileDB->NewestDependency = FileDB;

                    if (DEBUG_1 || fShowOutOfDateFiles) {
                        BuildError(
                                  "%s (v%d) is out of date with respect to %s.\r\n",
                                  FileDB->Name,
                                  IncludeDB->Version,
                                  IncludeDB->Name);
                    }

                    if (DEBUG_4) {
                        BuildMsgRaw(
                                   "%lu-%hu/%hu: ChkDepend-9(%s %x, %4s%.*s%s, %u) %x\r\n",
                                   ChkRecursLevel,
                                   LocalSequence,
                                   GlobalSequence,
                                   Target->Name,
                                   Target->DateTime,
                                   "t<-s",
                                   ChkRecursLevel,
                                   szRecurse,
                                   FileDB->Name,
                                   CheckDate,
                                   FileDB->DateTimeTree);
                    }

                }
            }
        }
    }
    if (DEBUG_4) {
        BuildMsgRaw(
                   "%lu-%hu/%hu: ChkDepend-A(%s %x, %4s%.*s%s, %u) %x %s\r\n",
                   ChkRecursLevel,
                   LocalSequence,
                   GlobalSequence,
                   Target->Name,
                   Target->DateTime,
                   "--",
                   ChkRecursLevel,
                   szRecurse,
                   FileDB->Name,
                   CheckDate,
                   FileDB->DateTimeTree,
                   *ppfrRoot != NULL? "Collapse Cycle" :
                   fOutOfDate? "OUT OF DATE" : "up-to-date");
    }
    assert(FileDB->fDependActive);
    FileDB->fDependActive = FALSE;
    ChkRecursLevel--;
    return (fOutOfDate);
}



//+---------------------------------------------------------------------------
//
//  Function:   PickFirst
//
//  Synopsis:   When called iteratively, the set of returned values is
//              effectively a merge sort of the two source lists.
//
//  Effects:    The pointers given in [ppsr1] and [ppsr2] are modified to point
//              to the next appropriate item in the list.
//
//  Arguments:  [ppsr1] -- First SOURCEREC list
//              [ppsr2] -- Second SOURCEREC list
//
//  Returns:    The appropriate next item from either [ppsr1] or [ppsr2]
//
//  Notes:      [ppsr1] and [ppsr2] should each be appropriately sorted.
//
// InsertSourceDB maintains a sort order for PickFirst() based first on the
// filename extension, then on the subdirectory mask.  Two exceptions to the
// alphabetic sort are:
//             - No extension sorts last.
//             - .rc extension sorts first.
//
//----------------------------------------------------------------------------

#define PF_FIRST        -1
#define PF_SECOND       1

SOURCEREC *
PickFirst(SOURCEREC **ppsr1, SOURCEREC **ppsr2)
{
    SOURCEREC **ppsr;
    SOURCEREC *psr;
    int r = 0;

    AssertOptionalSource(*ppsr1);
    AssertOptionalSource(*ppsr2);
    if (*ppsr1 == NULL) {
        if (*ppsr2 == NULL) {
            return (NULL);               // both lists NULL -- no more
        }
        r = PF_SECOND;                  // 1st is NULL -- return 2nd
    } else if (*ppsr2 == NULL) {
        r = PF_FIRST;                   // 2nd is NULL -- return 1st
    } else {
        LPSTR pszext1, pszext2;

        pszext1 = strrchr((*ppsr1)->pfrSource->Name, '.');
        pszext2 = strrchr((*ppsr2)->pfrSource->Name, '.');
        if (pszext1 == NULL) {
            r = PF_SECOND;              // 1st has no extension -- return 2nd
        } else if (pszext2 == NULL) {
            r = PF_FIRST;               // 2nd has no extension -- return 1st
        } else if (strcmp(pszext1, ".rc") == 0) {
            r = PF_FIRST;               // 1st is .rc -- return 1st
        } else if (strcmp(pszext2, ".rc") == 0) {
            r = PF_SECOND;              // 2nd is .rc -- return 2nd
        } else {
            r = strcmp(pszext1, pszext2);
            if (r == 0 &&
                (*ppsr1)->SourceSubDirMask != (*ppsr2)->SourceSubDirMask) {
                if ((*ppsr1)->SourceSubDirMask > (*ppsr2)->SourceSubDirMask) {
                    r = PF_FIRST;       // 2nd subdir after 1st -- return 1st
                } else {
                    r = PF_SECOND;      // 1st subdir after 2nd -- return 2nd
                }
            }
        }
    }
    if (r <= 0) {
        ppsr = ppsr1;
    } else {
        ppsr = ppsr2;
    }
    psr = *ppsr;
    *ppsr = psr->psrNext;
    return (psr);
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteObjectsDefinition
//
//  Synopsis:   Writes out a single platform-specific section of the
//              _objects.mac file.
//
//  Arguments:  [OutFileHandle]   -- File handle to write to
//              [psrCommon]       -- List of common source files
//              [psrMachine]      -- List of machine-specific source files
//              [DirDB]           -- directory record
//              [ObjectVariable]  -- e.g.  386_SOURCES
//              [ObjectDirectory] -- name of machine obj dir (e.g. obj\i386)
//
//  Returns:
//
//  History:    26-Jul-94     LyleC    Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
WriteObjectsDefinition(
                      FILE *OutFileHandle,
                      SOURCEREC *psrMachine,
                      DIRSUP *pds,
                      LPSTR ObjectVariable,
                      LPSTR ObjectDirectory,
                      DIRREC *DirDB
                      )
{
    LPSTR        pbuf;
    LPSTR        pszextsrc;
    LPSTR        pszextdir;
    LPTARGETDATA pData;
    SOURCEREC   *psrComCopy;
    SOURCEREC   *psrMachCopy;
    SOURCEREC *psrCommon = pds->psrSourcesList[0];
    LPSTR DirName = DirDB->Name;

    SOURCEREC *psr;
    USHORT  i;
    LONG iPass;

    //
    // We loop twice - the first time writing out the non-pass-zero files
    // to the ObjectVariable, the second time writing out pass zero
    // files to the PASS0_ObjectVariable.
    //
    for (iPass = 1; iPass >= 0; iPass--) {
        pbuf = BigBuf;

        pbuf[0] = '\0';
        if (iPass == 0) {
            strcpy(pbuf, "PASS0_");
        }
        strcat(pbuf, ObjectVariable);
        strcat(pbuf, "=");
        pbuf += strlen(pbuf);

        psrComCopy = psrCommon;
        psrMachCopy = psrMachine;

        while ((psr = PickFirst(&psrComCopy, &psrMachCopy)) != NULL) {

            AssertSource(psr);
            if ((psr->SrcFlags & SOURCEDB_SOURCES_LIST) == 0) {
                continue;
            }

            // if pass 0 macro and not a pass 0 file, skip it.

            if (iPass == 0 && !(psr->pfrSource->FileFlags & FILEDB_PASS0))
                continue;

            // if pass 1 macro and not a pass 1 file, skip it.

            if (iPass == 1 &&
                (psr->pfrSource->FileFlags & FILEDB_PASS0) &&
                !(psr->pfrSource->FileFlags & FILEDB_MULTIPLEPASS))
                continue;

            pszextsrc = strrchr(psr->pfrSource->Name, '.');

            if (!pszextsrc) {
                BuildError("Bad sources extension: %s\r\n", psr->pfrSource->Name);
                continue;
            }

            i = 0;
            while (pData = GetTargetData(pszextsrc, iPass, i, pds->IdlType)) {
                if (pData == &DefaultData) {
                    //
                    // Check for implicitly 'known' extensions...
                    //
                    if (pszextsrc == NULL) {
                        BuildError(
                                  "%s: Interesting sources extension: %s\r\n",
                                  DirName,
                                  psr->pfrSource->Name);
                    } else {

                        switch (pszextsrc[1]) {
                            case 'f':      // Fortran
                            case 'h':      // Header file ?
                            case 'p':      // Pascal
                                BuildError(
                                          "%s: Interesting sources extension: %s\r\n",
                                          DirName,
                                          psr->pfrSource->Name);
                                // FALL THROUGH

                            case 'a':    // Assembly file (.asm)
                            case 'c':    // C file (.c, .cxx, or .cs)
                            case 'v':    // VB.NET
                            case 's':    // Assembly file (.s)
                                break;

                            default:
                                BuildError("Bad sources extension: %s\r\n",
                                           psr->pfrSource->Name);
                        }
                    }
                }

                switch (pData->ObjectDirFlag) {
                    case TD_OBJECTDIR:
                        pszextdir = ObjectDirectory;
                        break;

                    case TD_PASS0HDRDIR:
                        pszextdir = "$(PASS0_HEADERDIR)";
                        break;

                    case TD_MCSOURCEDIR:
                        pszextdir = "$(MC_SOURCEDIR)";
                        break;

                    case TD_PASS0DIR1:
                        pszextdir = pds->IdlType ? "$(PASS0_CLIENTDIR)" : "$(PASS0_SOURCEDIR)";
                        break;

                    case TD_PASS0DIR2:
                        pszextdir = pds->IdlType ? "$(PASS0_SERVERDIR)" : "$(PASS0_UUIDDIR)";
                        break;

                    default:
                        assert(0 && "Invalid ObjectDirFlag");
                        break;
                }
                assert(pszextdir);
                assert(pData->pszTargetExt);

                sprintf(
                       pbuf,
                       " \\\r\n    %s\\%.*s%s",
                       pszextdir,
                       pszextsrc - psr->pfrSource->Name,
                       psr->pfrSource->Name,
                       pData->pszTargetExt);
                pbuf += strlen(pbuf);

                i++;
            }
        }
        strcpy(pbuf, "\r\n\r\n");
        pbuf += 4;

        fwrite(BigBuf, 1, (UINT) (pbuf - BigBuf), OutFileHandle);
    }
}


DWORD
CreateDirectoriesOnPath(
                       LPTSTR                  pszPath,
                       LPSECURITY_ATTRIBUTES   psa)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pszPath && *pszPath) {
        LPTSTR pch = pszPath;

        // If the path is a UNC path, we need to skip the \\server\share
        // portion.
        //
        if ((TEXT('\\') == *pch) && (TEXT('\\') == *(pch+1))) {
            // pch now pointing at the server name.  Skip to the backslash
            // before the share name.
            //
            pch += 2;
            while (*pch && (TEXT('\\') != *pch)) {
                pch++;
            }

            if (!*pch) {
                // Just the \\server was specified.  This is bogus.
                //
                return ERROR_INVALID_PARAMETER;
            }

            // pch now pointing at the backslash before the share name.
            // Skip to the backslash that should come after the share name.
            //
            pch++;
            while (*pch && (TEXT('\\') != *pch)) {
                pch++;
            }

            if (!*pch) {
                // Just the \\server\share was specified.  No subdirectories
                // to create.
                //
                return ERROR_SUCCESS;
            }
        }

        // Loop through the path.
        //
        for (; *pch; pch++) {
            // Stop at each backslash and make sure the path
            // is created to that point.  Do this by changing the
            // backslash to a null-terminator, calling CreateDirecotry,
            // and changing it back.
            //
            if (TEXT('\\') == *pch) {
                BOOL fOk;

                *pch = 0;
                fOk = CreateDirectory (pszPath, psa);
                *pch = TEXT('\\');

                // Any errors other than path alredy exists and we should
                // bail out.  We also get access denied when trying to
                // create a root drive (i.e. c:) so check for this too.
                //
                if (!fOk) {
                    dwErr = GetLastError ();
                    if (ERROR_ALREADY_EXISTS == dwErr) {
                        dwErr = ERROR_SUCCESS;
                    } else if ((ERROR_ACCESS_DENIED == dwErr) &&
                               (pch - 1 > pszPath) && (TEXT(':') == *(pch - 1))) {
                        dwErr = ERROR_SUCCESS;
                    } else {
                        break;
                    }
                }
            }
        }

        if (ERROR_ALREADY_EXISTS == dwErr) {
            dwErr = ERROR_SUCCESS;
        }

        if (ERROR_SUCCESS == dwErr) {
            // All dirs up to the last are created.  Make the last one also.
            if (CreateDirectory(pszPath, psa)) {
                dwErr = GetLastError ();
                if (ERROR_ALREADY_EXISTS == dwErr) {
                    dwErr = ERROR_SUCCESS;
                }
            }
        }
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateBuildDirectory
//
//  Synopsis:   Creates a directory to hold generate object files.  SET the
//              FILE_ATTRIBUTE_ARCHIVE bit for the directory, since there is nothing
//              to backup.  We use SET since the default setting for a new directory
//              is clear.  Go figure.  DOS was such a well planned product.
//
//  Arguments:  [Name]            -- Directory to create
//
//  Returns:    TRUE if directory already exists or was created successfully.
//              FALSE otherwise.
//----------------------------------------------------------------------------

BOOL
CreateBuildDirectory(LPSTR Name)
{
    DWORD Attributes;

    Attributes = GetFileAttributes(Name);
    if (Attributes == -1) {
        CreateDirectoriesOnPath(Name, NULL);
        Attributes = GetFileAttributes(Name);
    }

    if (Attributes != -1 && ((Attributes & FILE_ATTRIBUTE_ARCHIVE) == 0)) {
        SetFileAttributes(Name, Attributes | FILE_ATTRIBUTE_ARCHIVE);
    }

    return ((BOOL)(Attributes != -1));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreatedBuildFile
//
//  Synopsis:   Called whenever BUILD creates a file.  Clears the FILE_ATTRIBUTE_ARCHIVE
//              bit for the file, since there is nothing to backup with a generated file.
//
//  Arguments:  [DirName]         -- DIRDB for directory
//              [FileName]        -- file name path relative to DirName
//
//----------------------------------------------------------------------------

VOID
CreatedBuildFile(LPSTR DirName, LPSTR FileName)
{
    char Name[ DB_MAX_PATH_LENGTH * 2 + 1] = {0}; // ensure we have enough space for "DirName" + "\\" + "FileName"
    DWORD Attributes;

    if (DirName == NULL || DirName[0] == '\0') {
        strncpy( Name, FileName, sizeof(Name) - 1 );
    } else {
        _snprintf( Name, sizeof(Name)-1, "%s\\%s", DirName, FileName );
    }

    Attributes = GetFileAttributes(Name);
    if (Attributes != -1 && (Attributes & FILE_ATTRIBUTE_ARCHIVE)) {
        SetFileAttributes(Name, Attributes & ~FILE_ATTRIBUTE_ARCHIVE);
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   GenerateObjectsDotMac
//
//  Synopsis:   Creates the _objects.mac file containing info for all platforms
//
//  Arguments:  [DirDB]           -- Directory to create file for
//              [pds]             -- Supplementary information on [DirDB]
//              [DateTimeSources] -- Timestamp of the SOURCES file
//
//----------------------------------------------------------------------------

VOID
GenerateObjectsDotMac(DIRREC *DirDB, DIRSUP *pds, ULONG DateTimeSources)
{
    FILE *OutFileHandle;
    UINT i;
    ULONG ObjectsDateTime;
    char szObjectsMac[_MAX_PATH];

    strcpy(szObjectsMac, pszObjDir);
    strcat(szObjectsMac, "\\_objects.mac");

    CreateBuildDirectory(pszObjDir);
    for (i = 0; i < CountTargetMachines; i++) {
        assert(strncmp(
                      pszObjDirSlash,
                      TargetMachines[i]->ObjectDirectory[iObjectDir],
                      strlen(pszObjDirSlash)) == 0);
        CreateBuildDirectory(TargetMachines[i]->ObjectDirectory[iObjectDir]);
    }

    if (ObjectsDateTime = (*pDateTimeFile)(DirDB->Name, szObjectsMac)) {

        if (DateTimeSources == 0) {
            BuildError("%s: no sources timestamp\r\n", DirDB->Name);
        }

        if (ObjectsDateTime >= DateTimeSources) {
            if (!fForce) {
                return;
            }
        }
    }
    if (!MyOpenFile(DirDB->Name, szObjectsMac, "wb", &OutFileHandle, TRUE)) {
        return;
    }

    if ((DirDB->DirFlags & DIRDB_SOURCES_SET) == 0) {
        BuildError("Missing SOURCES= definition in %s\r\n", DirDB->Name);
    } else {
        for (i = 0; i < MAX_TARGET_MACHINES; i++) {
            WriteObjectsDefinition(
                                  OutFileHandle,
                                  pds->psrSourcesList[i + 2],
                                  pds,
                                  PossibleTargetMachines[i]->ObjectVariable,
                                  PossibleTargetMachines[i]->ObjectMacro,
                                  DirDB);
        }
    }
    fclose(OutFileHandle);
    CreatedBuildFile(DirDB->Name, szObjectsMac);

    //
    // If the _objects.mac file was generated during the first pass, then we
    // want to regenerate it during the second scan because the first scan
    // wasn't complete and _objects.mac may not be correct for non-pass-zero
    // files.  We do this by setting the timestamp back to the old time.
    //
    if (fFirstScan && fPassZero) {
        HANDLE hf;
        FILETIME ft;

        hf = CreateFile(szObjectsMac, GENERIC_WRITE, 0,
                        (LPSECURITY_ATTRIBUTES)NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
                        (HANDLE)NULL);

        if (hf != INVALID_HANDLE_VALUE) {
            ULONG time;

            if (ObjectsDateTime) {
                time = ObjectsDateTime;
            } else if (DateTimeSources) {
                //
                // All we care about is that time time stamp on _objects.mac
                // is less than that of the sources file so it will get
                // regenerated during the second scan.
                //
                time = DateTimeSources;
                if (LOWORD(time) != 0)
                    time &= 0xFFFF0000;  // 00:00:00 on the same date
                else
                    time = 0x1421A000;       // 12:00:00 1/1/1990
            } else {
                time = 0x1421A000;       // 12:00:00 1/1/1990
            }

            DosDateTimeToFileTime(HIWORD(time), LOWORD(time), &ft);

            SetFileTime(hf, (LPFILETIME)NULL, (LPFILETIME)NULL, &ft);

            CloseHandle(hf);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\buildscn.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994
//
//  File:       buildscn.c
//
//  Contents:   Directory and File scanning functions for Build.exe
//
//
//  History:    16-May-89     SteveWo  Created
//                  ... see SLM logs
//              26-Jul-94     LyleC    Cleanup/Add pass0 support
//
//----------------------------------------------------------------------------

#include "build.h"

//+---------------------------------------------------------------------------
//
//  Function:   AddShowDir
//
//  Synopsis:   Add a directory to the ShowDir array
//
//----------------------------------------------------------------------------

VOID
AddShowDir(DIRREC *pdr)
{
    AssertDir(pdr);
    if (CountShowDirs >= MAX_BUILD_DIRECTORIES) {
        static BOOL fError = FALSE;

        if (!fError) {
            BuildError(
                      "Show Directory table overflow, using first %u entries\r\n",
                      MAX_BUILD_DIRECTORIES);
            fError = TRUE;
        }
    } else {
        ShowDirs[CountShowDirs++] = pdr;
    }
    pdr->DirFlags |= DIRDB_SHOWN;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddIncludeDir
//
//  Synopsis:   Add a directory to the IncludeDirs array
//
//----------------------------------------------------------------------------

VOID
AddIncludeDir(DIRREC *pdr, UINT *pui)
{
    AssertDir(pdr);
    assert(pdr->FindCount >= 1);
    assert(*pui <= MAX_INCLUDE_DIRECTORIES);
    if (*pui >= MAX_INCLUDE_DIRECTORIES) {
        BuildError(
                  "Include Directory table overflow, %u entries allowed\r\n",
                  MAX_INCLUDE_DIRECTORIES);
        exit(16);
    }
    IncludeDirs[(*pui)++] = pdr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanGlobalIncludeDirectory
//
//  Synopsis:   Scans a global include directory and adds it to the
//              IncludeDir array.
//
//----------------------------------------------------------------------------

VOID
ScanGlobalIncludeDirectory(LPSTR path)
{
    DIRREC *pdr;

    if ((pdr = ScanDirectory(path)) != NULL) {
        AddIncludeDir(pdr, &CountIncludeDirs);
        pdr->DirFlags |= DIRDB_GLOBAL_INCLUDES;
        if (fShowTreeIncludes && !(pdr->DirFlags & DIRDB_SHOWN)) {
            AddShowDir(pdr);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanIncludeEnv
//
//  Synopsis:   Scans all include directories specified in the INCLUDE
//              environment variable.
//
//  Arguments:  [IncludeEnv] -- value of the INCLUDE environment variable.
//
//  Notes:      The INCLUDE variable is a string with a list of directories
//              separated by semicolons (;).
//
//----------------------------------------------------------------------------

VOID
ScanIncludeEnv(
              LPSTR IncludeEnv
              )
{
    char path[DB_MAX_PATH_LENGTH] = {0};
    LPSTR IncDir, IncDirEnd;
    UINT cb;

    if (!IncludeEnv) {
        return;
    }

    if (DEBUG_1) {
        BuildMsgRaw("ScanIncludeEnv(%s)\r\n", IncludeEnv);
    }

    IncDir = IncludeEnv;
    while (*IncDir) {
        IncDir++;
    }

    while (IncDir > IncludeEnv) {
        IncDirEnd = IncDir;
        while (IncDir > IncludeEnv) {
            if (*--IncDir == ';') {
                break;
            }
        }

        if (*IncDir == ';') {
            if (cb = (UINT)(IncDirEnd-IncDir-1)) {
                strncpy( path, IncDir+1, cb );
            }
        } else {
            if (cb = (UINT)(IncDirEnd-IncDir)) {
                strncpy( path, IncDir, cb );
            }
        }
        if (cb) {
            path[ cb ] = '\0';
            while (path[ 0 ] == ' ') {
                strcpy( path, &path[ 1 ] );
                cb--;
            }

            while (cb && path[--cb] == ' ') {
                path[ cb ] = '\0';
            }
            if (path[0]) {
                ScanGlobalIncludeDirectory(path);
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanSubDir
//
//  Synopsis:   Scans all the files in the given directory, sets the
//              directory flags appropriately (e.g.  DIRDB_SOURCES, etc),
//              and adds a list of interesting files to the Files list in
//              the DirDB structure for the directory.
//
//  Arguments:  [pszDir] -- Name of directory to scan
//              [pdr]    -- [out] Filled in DIRREC on return
//
//  Notes:      An 'interesting' file is one which has a recognized
//              extension.  See the InsertFileDB and MatchFileDesc
//              functions for more info.
//
//----------------------------------------------------------------------------

VOID
ScanSubDir(LPSTR pszDir, DIRREC *pdr)
{
    char FileName[DB_MAX_PATH_LENGTH];
    FILEREC *FileDB, **FileDBNext;
    WIN32_FIND_DATA FindFileData;
    HDIR FindHandle;
    ULONG DateTime;
    USHORT Attr;

    strcat(pszDir, "\\");
    strcat(pszDir, "*.*");

    pdr->DirFlags |= DIRDB_SCANNED;
    FindHandle = FindFirstFile(pszDir, &FindFileData);
    if (FindHandle == (HDIR)INVALID_HANDLE_VALUE) {
        if (DEBUG_1) {
            BuildMsg("FindFirstFile(%s) failed.\r\n", pszDir);
        }
        return;
    }
    do {
        Attr = (USHORT)(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
        if ((Attr & FILE_ATTRIBUTE_DIRECTORY) &&
            (!strcmp(FindFileData.cFileName, ".") ||
             !strcmp(FindFileData.cFileName, ".."))) {
            continue;
        }

        CopyString(FileName, FindFileData.cFileName, TRUE);

        FileTimeToDosDateTime(&FindFileData.ftLastWriteTime,
                              ((LPWORD) &DateTime) + 1,
                              (LPWORD) &DateTime);

        if ((pdr->DirFlags & DIRDB_NEW) == 0 &&
            (FileDB = LookupFileDB(pdr, FileName)) != NULL) {

            if (FileDB->FileFlags & FILEDB_PASS0)
                pdr->DirFlags |= DIRDB_PASS0;

            //
            // Clear the file missing flag, since we know the file exists now.
            // This flag may be set if the file was generated during pass zero.
            //
            if (FileDB->FileFlags & FILEDB_FILE_MISSING)
                FileDB->FileFlags &= ~FILEDB_FILE_MISSING;

            //
            // The time we last stored for this file is different than the
            // actual time on the file, so force it to be rescanned.
            //
            if (FileDB->DateTime != DateTime) {
                if (FileDB->FileFlags & (FILEDB_SOURCE | FILEDB_HEADER)) {
                    FileDB->FileFlags &= ~FILEDB_SCANNED;
                } else {
                    FileDB->FileFlags |= FILEDB_SCANNED;
                }

                if (DEBUG_1) {
                    BuildMsg(
                            "%s  -  DateTime (%lx != %lx)\r\n",
                            FileDB->Name,
                            FileDB->DateTime,
                            DateTime);
                }

                FileDB->DateTime = DateTime;
                FileDB->Attr = Attr;
            } else {
                FileDB->FileFlags |= FILEDB_SCANNED;
            }
        } else {
            FileDB = InsertFileDB(pdr, FileName, DateTime, Attr, 0);
        }
    } while (FindNextFile(FindHandle, &FindFileData));

    FindClose(FindHandle);

    if ((pdr->DirFlags & DIRDB_DIRS) && (pdr->DirFlags & DIRDB_SOURCES)) {
        BuildError("%s\\sources. unexpected in directory with DIRS file\r\n",
                   pdr->Name);
        BuildError("Ignoring %s\\sources.\r\n", pdr->Name);

        pdr->DirFlags &= ~DIRDB_SOURCES;
    }
    //
    // Scan each file in this directory unless using QuickZero
    //
    if (fQuickZero && fFirstScan) {
        return;
    }
    FileDBNext = &pdr->Files;
    while (FileDB = *FileDBNext) {
        if (!(FileDB->FileFlags & (FILEDB_DIR | FILEDB_SCANNED))) {
            if (ScanFile(FileDB)) {
                AllDirsModified = TRUE;
            }
        }
        FileDBNext = &FileDB->Next;
    }
    DeleteUnscannedFiles(pdr);
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanDirectory
//
//  Synopsis:   Tries to find the given directory in the database, and if
//              not found calls ScanSubDir.
//
//  Arguments:  [pszDir] -- Directory to scan
//
//  Returns:    Filled in DIRREC structure for the directory.
//
//  Notes:      If fQuicky (-z or -Z options) are set, then instead of calling
//              ScanSubDir, which is long, it just checks for known files, like
//              'sources' for 'makefile' to determine whether or not the
//              directory should be compiled.
//
//----------------------------------------------------------------------------

PDIRREC
ScanDirectory(LPSTR pszDir)
{
    DIRREC *pdr;
    char FullPath[DB_MAX_PATH_LENGTH];

    if (DEBUG_1) {
        BuildMsgRaw("ScanDirectory(%s)\r\n", pszDir);
    }

    if (!pszDir) {
        return NULL;
    }

    if (!CanonicalizePathName(pszDir, CANONICALIZE_DIR, FullPath)) {
        if (DEBUG_1) {
            BuildMsgRaw("CanonicalizePathName failed\r\n");
        }
        return (NULL);
    }
    pszDir = FullPath;

    if ((pdr = LoadDirDB(pszDir)) == NULL) {
        return (NULL);
    }

    if (fQuicky && (!fQuickZero)) {

        if (!(pdr->DirFlags & DIRDB_SCANNED)) {
            pdr->DirFlags |= DIRDB_SCANNED;
            if (ProbeFile(pdr->Name, "sources") != -1) {
                pdr->DirFlags |= DIRDB_SOURCES | DIRDB_MAKEFILE;
            } else
                if (ProbeFile(pdr->Name, "mydirs") != -1 ||
                    ProbeFile(pdr->Name, "dirs") != -1 ||
                    ProbeFile(pdr->Name, pszTargetDirs) != -1) {

                pdr->DirFlags |= DIRDB_DIRS;
                if (ProbeFile(pdr->Name, "makefil0") != -1) {
                    pdr->DirFlags |= DIRDB_MAKEFIL0;
                }
                if (ProbeFile(pdr->Name, "makefil1") != -1) {
                    pdr->DirFlags |= DIRDB_MAKEFIL1;
                }
                if (ProbeFile(pdr->Name, "makefile") != -1) {
                    pdr->DirFlags |= DIRDB_MAKEFILE;
                }
            }
        }
        return (pdr);
    }

    if (pdr->DirFlags & DIRDB_SCANNED) {
        return (pdr);
    }

    if (!RecurseLevel && fNoisyScan) {
        ClearLine();
        BuildMsgRaw("    Scanning %s ", pszDir);
        if (fDebug || !(BOOL) _isatty(_fileno(stderr))) {
            BuildMsgRaw(szNewLine);
        }
    }

    ScanSubDir(pszDir, pdr);

    if (!RecurseLevel) {
        ClearLine();
    }
    return (pdr);
}


#define BUILD_TLIB_INCLUDE_STMT "importlib"
#define BUILD_TLIB_INCLUDE_STMT_LENGTH (sizeof( BUILD_TLIB_INCLUDE_STMT )-1)

#define BUILD_MIDL_INCLUDE_STMT "import"
#define BUILD_MIDL_INCLUDE_STMT_LENGTH (sizeof( BUILD_MIDL_INCLUDE_STMT )-1)

#define BUILD_RC_INCLUDE_STMT "rcinclude"
#define BUILD_RC_INCLUDE_STMT_LENGTH (sizeof( BUILD_RC_INCLUDE_STMT )-1)

#define BUILD_ASN_INCLUDE_STMT "--<"
#define BUILD_ASN_INCLUDE_STMT_LENGTH (sizeof( BUILD_ASN_INCLUDE_STMT )-1)

#define BUILD_INCLUDE_STMT "include"
#define BUILD_INCLUDE_STMT_LENGTH (sizeof( BUILD_INCLUDE_STMT )-1)

#define BUILD_VER_COMMENT "/*++ BUILD Version: "
#define BUILD_VER_COMMENT_LENGTH (sizeof( BUILD_VER_COMMENT )-1)

#define BUILD_MASM_VER_COMMENT ";;;; BUILD Version: "
#define BUILD_MASM_VER_COMMENT_LENGTH (sizeof( BUILD_MASM_VER_COMMENT )-1)


//+---------------------------------------------------------------------------
//
//  Function:   IsIncludeStatement
//
//  Synopsis:   Tries to determine whether or not a given line contains an
//              include statement (e.g. #include <foobar.h> ).
//
//  Arguments:  [pfr] -- FILEREC of file being scanned
//              [p]   -- Current line of file
//
//  Returns:    NULL if line is not an include statment.  Returns pointer to
//              beginning of filename if it is (e.g. <foobar.h> ).
//
//  Notes:      The returned filename includes the surrounding quotes or
//              brackets, if any.  Also, the pointer is just a pointer into
//              the given string, not a separate copy.
//
//              Supported statements are:
//              All file types: #include <filename> and #include "filename"
//              MIDL files:     import "filename"
//              RC files:       rcinclude filename
//              MKTYPLIB files: importlib("filename")
//
//----------------------------------------------------------------------------

#define IsTokenPrefix0(psz, szToken, cchToken)               \
            (strncmp((psz), (szToken), (cchToken)) == 0)

#define IsTokenPrefix(psz, szToken, cchToken)               \
            (IsTokenPrefix0((psz), (szToken), (cchToken)) && \
             (psz)[cchToken] != '\0')

#define IsTokenMatch(psz, szToken, cchToken) \
            (IsTokenPrefix((psz), (szToken), (cchToken)) && \
             !iscsym((psz)[cchToken]))

#define IsCiTokenPrefix0(psz, szToken, cchToken)             \
            (_strnicmp((psz), (szToken), (cchToken)) == 0)

#define IsCiTokenPrefix(psz, szToken, cchToken)             \
            (IsCiTokenPrefix0((psz), (szToken), (cchToken)) && \
             (psz)[cchToken] != '\0')

#define IsCiTokenMatch(psz, szToken, cchToken) \
            (IsCiTokenPrefix((psz), (szToken), (cchToken)) && \
             !iscsym((psz)[cchToken]))

LPSTR
IsIncludeStatement(FILEREC *pfr, LPSTR p)
{
    if (!p || *p == '\0')
        return NULL;

    if (!(pfr->FileFlags & (FILEDB_MASM | FILEDB_MIDL | FILEDB_MKTYPLIB | FILEDB_RC | FILEDB_ASN))) {
        if (*p != '#') {
            return (NULL);
        }
    }

    if (*p == '#')
        p++;

    while (isspace(*(BYTE*)p)) {
        p++;
    }

    if (IsTokenMatch(p, BUILD_INCLUDE_STMT, BUILD_INCLUDE_STMT_LENGTH)) {
        p += BUILD_INCLUDE_STMT_LENGTH;
    } else
        if ((pfr->FileFlags & FILEDB_MASM) &&
            IsCiTokenMatch(p, BUILD_INCLUDE_STMT, BUILD_INCLUDE_STMT_LENGTH)) {
        p += BUILD_INCLUDE_STMT_LENGTH;
    } else
        if ((pfr->FileFlags & FILEDB_MIDL) &&
            IsTokenMatch(p, BUILD_MIDL_INCLUDE_STMT, BUILD_MIDL_INCLUDE_STMT_LENGTH)) {
        p += BUILD_MIDL_INCLUDE_STMT_LENGTH;
    } else
        if ((pfr->FileFlags & FILEDB_RC) &&
            IsTokenMatch(p, BUILD_RC_INCLUDE_STMT, BUILD_RC_INCLUDE_STMT_LENGTH)) {

        p += BUILD_RC_INCLUDE_STMT_LENGTH;
    } else
        if ((pfr->FileFlags & FILEDB_ASN) &&
            IsTokenPrefix0(p, BUILD_ASN_INCLUDE_STMT, BUILD_ASN_INCLUDE_STMT_LENGTH)) {

        p += BUILD_ASN_INCLUDE_STMT_LENGTH;
    } else
        if ((pfr->FileFlags & FILEDB_MKTYPLIB) &&
            IsTokenMatch(p, BUILD_TLIB_INCLUDE_STMT, BUILD_TLIB_INCLUDE_STMT_LENGTH)) {
        p += BUILD_TLIB_INCLUDE_STMT_LENGTH;
        while (isspace(*(BYTE*)p)) {
            p++;
        }

        if (*p == '(')   // Skip the open paren and get to the quote.
            p++;
    } else {
        return (NULL);
    }

    while (isspace(*(BYTE*)p)) {
        p++;
    }
    return (p);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsPragmaHdrStop
//
//  Synopsis:   Determines if the given line is a #pragma hdrstop line
//
//  Arguments:  [p] -- String to analyze
//
//  Returns:    TRUE if the line is a pragma hdrstop
//
//----------------------------------------------------------------------------

BOOL
IsPragmaHdrStop(LPSTR p)
{
    static char szPragma[] = "pragma";
    static char szHdrStop[] = "hdrstop";

    if (*p == '#') {
        while (*++p == ' ') {
            ;
        }
        if (strncmp(p, szPragma, sizeof(szPragma) - 1) == 0 &&
            *(p += sizeof(szPragma) - 1) == ' ') {

            while (*p == ' ') {
                p++;
            }
            if (strncmp(p, szHdrStop, sizeof(szHdrStop) - 1) == 0 &&
                !iscsym(p[sizeof(szHdrStop) - 1])) {

                return (TRUE);
            }
        }
    }
    return (FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanFile
//
//  Synopsis:   Scans the given file to determine files which it includes.
//
//  Arguments:  [FileDB] -- File to scan.
//
//  Returns:    TRUE if successful
//
//  Notes:      This function is a nop if the given file does not have either
//              the FILEDB_SOURCE or FILEDB_HEADER flag set.
//              (see InsertSourceDB)
//
//              Note that the performance of this function is critical since
//              it is called for every file in each directory.
//
//----------------------------------------------------------------------------

#define ASN_NONE          0  // not in Asn INCLUDES statement
#define ASN_START         1  // expectimg "INCLUDES" token
#define ASN_FILENAME      2  // expecting a quoted "filename"
#define ASN_COMMA         3  // expecting end token (">--") or comma

#define ASN_CONTINUATION  8  // expecting comment token first

char *
AsnStateToString(UINT AsnState)
{
    static char buf[100];
    char *psz;

    switch (AsnState & ~ASN_CONTINUATION) {
        case ASN_NONE:      psz = "None"; break;
        case ASN_START:     psz = "Start"; break;
        case ASN_FILENAME:  psz = "Filename"; break;
        case ASN_COMMA:     psz = "Comma"; break;
        default:            psz = "???"; break;
    }
    sprintf(buf, "%s%s", psz, (AsnState & ASN_CONTINUATION)? "+Cont" : "");
    return (buf);
}


BOOL
ScanFile(
        PFILEREC FileDB
        )
{
    FILE *FileHandle;
    char CloseQuote;
    LPSTR p;
    LPSTR IncludeFileName, TextLine;
    BOOL fFirst = TRUE;
    USHORT IncFlags = 0;
    UINT i, cline;
    UINT AsnState = ASN_NONE;

    if ((FileDB->FileFlags & (FILEDB_SOURCE | FILEDB_HEADER)) == 0) {
        FileDB->FileFlags |= FILEDB_SCANNED;
        return (TRUE);
    }

    //
    // Don't scan non-pass-zero files if we're doing pass zero.
    //
    if (fPassZero && (FileDB->FileFlags & FILEDB_PASS0) == 0)
        return TRUE;

    if (!SetupReadFile(
                      FileDB->Dir->Name,
                      FileDB->Name,
                      FileDB->pszCommentToEOL,
                      &FileHandle)) {
        return (FALSE);
    }

    if (!RecurseLevel && fNoisyScan) {
        ClearLine();
        BuildMsgRaw(
                   "    Scanning %s ",
                   FormatPathName(FileDB->Dir->Name, FileDB->Name));
        if (!(BOOL) _isatty(_fileno(stderr))) {
            BuildMsgRaw(szNewLine);
        }
    }

    FileDB->SourceLines = 0;
    FileDB->Version = 0;

    MarkIncludeFileRecords( FileDB );
    FileDB->FileFlags |= FILEDB_SCANNED;

    AllDirsModified = TRUE;

    while ((TextLine = ReadLine(FileHandle)) != NULL) {
        if (fFirst) {
            fFirst = FALSE;
            if (FileDB->FileFlags & FILEDB_HEADER) {
                if (FileDB->FileFlags & FILEDB_MASM) {
                    if (!strncmp( TextLine,
                                  BUILD_MASM_VER_COMMENT,
                                  BUILD_MASM_VER_COMMENT_LENGTH)) {
                        FileDB->Version = (USHORT)
                                          atoi( TextLine + BUILD_MASM_VER_COMMENT_LENGTH);
                    }
                } else
                    if (!strncmp( TextLine,
                                  BUILD_VER_COMMENT,
                                  BUILD_VER_COMMENT_LENGTH)) {
                    FileDB->Version = (USHORT)
                                      atoi( TextLine + BUILD_VER_COMMENT_LENGTH);
                }
            }
        }

        if (AsnState != ASN_NONE) {
            p = TextLine;
        } else {
            p = IsIncludeStatement(FileDB, TextLine);
        }

        if (p != NULL) {
            USHORT IncFlagsNew = IncFlags;

            if (FileDB->FileFlags & FILEDB_ASN) {
                if (AsnState & ASN_CONTINUATION) {
                    if (p[0] != '-' || p[1] != '-') {
                        AsnState = ASN_NONE;    // ignore includes and ...
                        p = NULL;
                        break;                  // get next line
                    }
                    p += 2;
                    AsnState &= ~ASN_CONTINUATION;
                }
                moreasn:
                while (p != NULL) {
                    while (isspace(*(BYTE*)p)) {
                        p++;
                    }
                    if (*p == '\0') {
                        AsnState |= ASN_CONTINUATION;
                        goto nextline;          // get next line
                    }
                    switch (AsnState) {
                        case ASN_NONE:
                            AsnState = ASN_START;
                            continue;                // re-enter state machine

                        case ASN_START:
                            if (!IsTokenPrefix0(
                                               p,
                                               "INCLUDES",
                                               sizeof("INCLUDES") - 1)) {
                                goto terminate;
                            }
                            AsnState = ASN_FILENAME;
                            p += sizeof("INCLUDES") - 1;
                            continue;                // re-enter state machine

                        case ASN_FILENAME:
                            if (*p != '"') {
                                goto terminate;
                            }
                            AsnState = ASN_COMMA;
                            goto parsefilename;

                        case ASN_COMMA:
                            if (*p == '>' && p[1] == '-' && p[2] == '-') {
                                goto terminate;
                            }
                            if (*p != ',') {
                                goto terminate;
                            }
                            p++;
                            AsnState = ASN_FILENAME;
                            continue;                // re-enter state machine
                    }
                    assert(FALSE);            // Bad AsnState
                    terminate:
                    AsnState = ASN_NONE;    // ignore includes statement, & ...
                    nextline:
                    p = NULL;               // get next line
                    break;
                }
            }

            parsefilename:
            if (p != NULL) {
                CloseQuote = (UCHAR) 0xff;
                if (*p == '<') {
                    p++;
                    CloseQuote = '>';
                } else
                    if (*p == '"') {
                    p++;
                    IncFlagsNew |= INCLUDEDB_LOCAL;
                    CloseQuote = '"';
                } else
                    if (FileDB->FileFlags & FILEDB_MASM) {
                    IncFlagsNew |= INCLUDEDB_LOCAL;
                    CloseQuote = ';';
                }

                IncludeFileName = p;
                while (*p != '\0' && *p != CloseQuote && *p != ' ') {
                    p++;
                }
                if (CloseQuote == ';' && (*p == ' ' || *p == '\0')) {
                    CloseQuote = *p;
                }

                if (*p != CloseQuote || CloseQuote == (UCHAR) 0xff) {
                    if (!fSilentDependencies) {
                        BuildError(
                                  "%s - invalid include statement: %s\r\n",
                                  FormatPathName(FileDB->Dir->Name, FileDB->Name),
                                  TextLine);
                    }
                    break;
                }

                *p = '\0';
                CopyString(IncludeFileName, IncludeFileName, TRUE);
                for (i = 0; i < CountExcludeIncs; i++) {
                    if (!strcmp(IncludeFileName, ExcludeIncs[i])) {
                        IncludeFileName = NULL;
                        break;
                    }
                }

                if (IncludeFileName != NULL) {
                    InsertIncludeDB(FileDB, IncludeFileName, IncFlagsNew);
                }
                if (FileDB->FileFlags & FILEDB_ASN) {
                    p++;
                    goto moreasn;
                }
            }
        } else
            if (IncFlags == 0 &&
                (FileDB->FileFlags & (FILEDB_ASM | FILEDB_MASM | FILEDB_MIDL | FILEDB_ASN | FILEDB_RC | FILEDB_HEADER)) == 0 &&
                IsPragmaHdrStop(TextLine)) {

            IncFlags = INCLUDEDB_POST_HDRSTOP;
        }
    }
    CloseReadFile(&cline);
    FileDB->SourceLines = cline;

    DeleteIncludeFileRecords( FileDB );

    if (!RecurseLevel) {
        ClearLine();
    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\buildscr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       buildscr.cpp
//
//  Contents:   Implementation of the code which talks to the MTScript engine
//              when doing a distributed build using the build console.
//
//----------------------------------------------------------------------------

#include "scrproc.h"

#include "build.h"
#include "buildscr.h"

#define INITGUID
#include <guiddef.h>

DEFINE_GUID(CLSID_LocalScriptedProcess, 0x854c316f,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xe4,0x39,0x1b);
DEFINE_GUID(IID_IScriptedProcess, 0x854c3171,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xe4,0x39,0x1b);
DEFINE_GUID(IID_IScriptedProcessSink, 0x854c3172,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xe4,0x39,0x1b);

DEFINE_GUID(CLSID_ObjectDaemon,0x854c3184,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xE4,0x39,0x1b);
DEFINE_GUID(IID_IConnectedMachine,0x854c316c,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xe4,0x39,0x1b);
DEFINE_GUID(IID_IObjectDaemon,0x854c3183,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xE4,0x39,0x1b);

#define MAX_RETRIES 2

HANDLE g_hMTEvent  = NULL;
HANDLE g_hMTThread = NULL;
DWORD  g_dwMTThreadId = 0;

//+---------------------------------------------------------------------------
//
//  Function:   WaitForResume
//
//  Synopsis:   Sends a "phase complete" message to the script engine and then
//              waits for it to tell us to resume (if specified).
//
//  Arguments:  [fPause] -- If TRUE, we wait for a resume command
//              [pe]     -- Message to send to the script engine
//
//----------------------------------------------------------------------------

void
WaitForResume(BOOL fPause, PROC_EVENTS pe)
{
    if (g_hMTEvent)
    {
        HANDLE aHandles[2] = { g_hMTEvent, g_hMTThread };

        ResetEvent(g_hMTEvent);

        PostThreadMessage(g_dwMTThreadId, pe, 0, 0);

        if (fPause)
        {
            // Wait until either the event object is signaled or the thread dies
            WaitForMultipleObjects(2, aHandles, FALSE, INFINITE);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ExitMTScriptThread
//
//  Synopsis:   Tells the thread talking to the MTScript engine to exit.
//
//----------------------------------------------------------------------------

void
ExitMTScriptThread()
{
    if (g_hMTEvent)
    {
        PostThreadMessage(g_dwMTThreadId, PE_EXIT, 0, 0);

        WaitForSingleObject(g_hMTThread, INFINITE);

        CloseHandle(g_hMTThread);
        CloseHandle(g_hMTEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SendStatus
//
//  Synopsis:   Sends a status message to the MTScript engine with the
//              current number of errors, warnings, and completed files.
//
//  Arguments:  [pSP] -- Pointer to MTScript engine interface
//
//----------------------------------------------------------------------------

void
SendStatus(IScriptedProcess *pSP)
{
    wchar_t achBuf[300];
    long    lRet;

    static ULONG cErrorsPrev = MAXDWORD;
    static ULONG cWarnPrev   = MAXDWORD;
    static ULONG cFilesPrev  = MAXDWORD;

    ULONG cErrors = RunningTotals.NumberCompileErrors + 
                    RunningTotals.NumberLibraryErrors + 
                    RunningTotals.NumberLinkErrors + 
                    RunningTotals.NumberBinplaceErrors;
    ULONG   cWarn = RunningTotals.NumberCompileWarnings + 
                    RunningTotals.NumberLibraryWarnings + 
                    RunningTotals.NumberLinkWarnings + 
                    RunningTotals.NumberBinplaceWarnings;
    ULONG  cFiles = RunningTotals.NumberCompiles + 
                    RunningTotals.NumberLibraries + 
                    RunningTotals.NumberLinks;
               /* + RunningTotals.NumberBinplaces */;

    // Only send status if it's changed since last time we did it.
    if (   cErrors != cErrorsPrev
        || cWarn   != cWarnPrev
        || cFiles  != cFilesPrev)
    {
        cErrorsPrev = cErrors;
        cWarnPrev   = cWarn;
        cFilesPrev  = cFiles;

        wsprintfW(achBuf, L"errors=%d,warnings=%d,files=%d", cErrors, cWarn, cFiles);

        pSP->SendData(L"status", achBuf, &lRet);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HandleMessage
//
//  Synopsis:   Handles a message that has come across our message queue.
//
//  Arguments:  [pmsg] -- Message
//              [pSP]  -- Pointer to MTScript engine interface
//
//----------------------------------------------------------------------------

BOOL
HandleMessage(MSG *pmsg, IScriptedProcess *pSP)
{
    long    lRet;
    HRESULT hr = S_OK;

    switch (pmsg->message)
    {
    case PE_PASS0_COMPLETE:
        SendStatus(pSP);

        hr = pSP->SendData(L"pass 0 complete", L"", &lRet);

        break;

    case PE_PASS1_COMPLETE:
        SendStatus(pSP);

        hr = pSP->SendData(L"pass 1 complete", L"", &lRet);

        break;

    case PE_PASS2_COMPLETE:
        SendStatus(pSP);

        hr = pSP->SendData(L"pass 2 complete", L"", &lRet);

        break;

    case PE_EXIT:
        SendStatus(pSP);

        hr = pSP->SendData(L"build complete", L"", &lRet);

        return TRUE;
        break;
    }

    if (hr != S_OK)
    {
        BuildErrorRaw("\nBUILD: Communication with script engine failed: %x", hr);
    }

    return (hr != S_OK) ? TRUE : FALSE;
}

const DWORD UPDATE_INTERVAL = 2 * 1000;  // Update every 2 seconds

//+---------------------------------------------------------------------------
//
//  Function:   MTScriptThread
//
//  Synopsis:   Thread entrypoint.  Initializes and then sits around
//              handling various events.
//
//  Arguments:  [pv] -- Not used.
//
//----------------------------------------------------------------------------

DWORD WINAPI
MTScriptThread(LPVOID pv)
{
    HRESULT            hr;
    IScriptedProcess * pSP = NULL;
    wchar_t            achBuf[100];
    MSG                msg;
    DWORD              dwRet;
    CProcessSink       cps;
    BOOL               fExit = FALSE;
    int                cRetries = 0;

    BuildMsg("Establishing connection with Script engine...\n");
    LogMsg("Establishing connection with Script engine...\n");

    // Force Windows to create a message queue for this thread, since we will
    // be communicated to via PostThreadMessage.

    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

    // If anything fails we just quit this thread and communication with
    // the MTScript engine won't happen.

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    if (hr != S_OK)
    {
        BuildErrorRaw("BUILD: CoInitializeEx failed with %x\n", hr);
        goto Cleanup;
    }

    hr = S_FALSE;

    while (hr != S_OK)
    {
        pSP = NULL;
        IObjectDaemon *pIObjectDaemon;
        hr = CoCreateInstance(CLSID_ObjectDaemon, NULL, CLSCTX_SERVER, 
                             IID_IObjectDaemon, (LPVOID*)&pIObjectDaemon);    

        if (hr == S_OK)
        {
            IDispatch *pIDispatch;
            BSTR bstrProgID = SysAllocString(L"MTScript.Remote");
            BSTR bstrIdentity = SysAllocString(_wgetenv(L"__MTSCRIPT_ENV_IDENTITY"));
            hr = pIObjectDaemon->OpenInterface(bstrIdentity, bstrProgID, (BOOL)FALSE, (IDispatch**)&pIDispatch);
            if (hr == S_OK)
            {
                IConnectedMachine *pIConnectedMachine;
                hr = pIDispatch->QueryInterface(IID_IConnectedMachine, (LPVOID*)&pIConnectedMachine);
                if (hr == S_OK)
                {
                    hr = pIConnectedMachine->CreateIScriptedProcess(GetCurrentProcessId(), (wchar_t *)_wgetenv(L"__MTSCRIPT_ENV_ID"), (IScriptedProcess **)&pSP);
                    pIConnectedMachine->Release();
                }
                else
                {
                    BuildMsg("CreateIScriptedProcess failed with %x.\n", hr);
                    LogMsg("CreateIScriptedProcess failed with %x.\n", hr);
                }
                pIDispatch->Release();
            }
            else
            {
                BuildMsg("OpenInterface failed with %x.\n", hr);
                LogMsg("OpenInterface failed with %x.\n", hr);
            }
            SysFreeString(bstrProgID);
            SysFreeString(bstrIdentity);
            pIObjectDaemon->Release();
        }
        else
        {
            BuildMsg("CoCreateInstance failed with %x.\n", hr);
            LogMsg("CoCreateInstance failed with %x.\n", hr);
        }

        
        if (hr == S_OK)
        {
            hr = pSP->SetProcessSink(&cps);
            if (hr != S_OK)
            {
                BuildMsg("SetProcessSink failed with %x.\n", hr);
                LogMsg("SetProcessSink failed with %x.\n", hr);
            }
        }

        if (hr != S_OK)
        {
            if (cRetries >= MAX_RETRIES)
            {
                BuildErrorRaw("BUILD: FATAL: Connection to script engine could not be established. (%x)\n", hr);

                goto Cleanup;
            }

            if (pSP)
            {
                pSP->Release();
                pSP = NULL;
            }

            BuildMsg("Connection to script engine failed with %x, retries=%d...\n", hr, cRetries);
            LogMsg("Connection to script engine failed with %x, retries=%d...\n", hr, cRetries);

            Sleep(500);

            cRetries++;
        }
    }

    BuildMsg("Connection to script engine established...\n");
    LogMsg("Connection to script engine established...\r\n");

    // Tell build.c that it can continue
    SetEvent(g_hMTEvent);

    while (TRUE)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (HandleMessage(&msg, pSP))
            {
                fExit = TRUE;
            }
        }

        if (fExit)
        {
            break;
        }

        dwRet = MsgWaitForMultipleObjects(0,
                                          NULL,
                                          FALSE,
                                          UPDATE_INTERVAL,
                                          QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0)
        {
            // A message is coming through on our message queue. Just loop
            // around.
        }
        else if (dwRet == WAIT_TIMEOUT)
        {
            SendStatus(pSP);
        }
        else
        {
            // MWFMO failed. Just bail out.
            break;
        }
    }

Cleanup:
    if (pSP)
    {
        pSP->SetProcessSink(NULL);
        pSP->Release();
    }

    CoUninitialize();

    if (hr != S_OK)
    {
        g_hMTThread = NULL;
    }

    SetEvent(g_hMTEvent);

    return 0;
}

// ***********************************************************************
//
// CProcessSink implementation
//
// We hand this class to the MTScript engine so it can communicate back
// to us.
//
// ***********************************************************************

CProcessSink::CProcessSink()
{
    _ulRefs = 1;
}

HRESULT
CProcessSink::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (riid == IID_IUnknown || riid == IID_IScriptedProcessSink)
    {
        *ppv = (IScriptedProcessSink*)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

ULONG
CProcessSink::AddRef()
{
    return InterlockedIncrement((long*)&_ulRefs);
}

ULONG
CProcessSink::Release()
{
    if (InterlockedDecrement((long*)&_ulRefs) == 0)
    {
        _ulRefs = 0xFF;
        delete this;
        return 0;
    }

    return _ulRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessSink::RequestExit, public
//
//  Synopsis:   Called when the MTScript engine wants us to quit. If we don't,
//              it will terminate us.
//
//----------------------------------------------------------------------------

HRESULT
CProcessSink::RequestExit()
{
    // There is no easy way to tell build.exe to abort. We'll just let
    // MTScript terminate us.

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessSink::ReceiveData, public
//
//  Synopsis:   Called when the MTScript engine wants to send us a message.
//
//  Arguments:  [pszType]  -- String giving the message
//              [pszData]  -- String giving data associated with the message.
//              [plReturn] -- A place we can return a value back.
//
//----------------------------------------------------------------------------

HRESULT
CProcessSink::ReceiveData(wchar_t *pszType, wchar_t *pszData, long *plReturn)
{
    *plReturn = 0;

    if (wcscmp(pszType, L"resume") == 0)
    {
        SetEvent(g_hMTEvent);
    }
    else
    {
        *plReturn = -1;   // Signals an error
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\buildscr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       buildscr.h
//
//  Contents:   Header file defining the objects needed to interface with
//              the MTScript engine.
//
//----------------------------------------------------------------------------

class CProcessSink : public IScriptedProcessSink
{
public:
    CProcessSink();
   ~CProcessSink() {}

    // IUnknown methods

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    // IScriptedProcessSink methods

    STDMETHOD(RequestExit)();
    STDMETHOD(ReceiveData)(wchar_t *pszType,
                           wchar_t *pszData,
                           long *plReturn);

private:
    ULONG _ulRefs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\buildsrc.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       buildsrc.c
//
//  Contents:   Functions used to process SOURCES and DIRS files
//
//  History:    16-May-89     SteveWo    Created
//              26-Jul-94     LyleC      Split out from buildmak.c
//              05-Dec-00     sbonev     See SD changelist 2317
//
//----------------------------------------------------------------------------

#include "build.h"

//
// Definitions used by the macro functions
//

#define LPAREN  '('
#define RPAREN  ')'

// Legal character for a macro name.
#define MACRO_CHAR(ch) iscsym(ch)

#define CMACROMAX       1000     // maximum unique macros per sources/dirs file

typedef struct _MACRO {
    LPSTR  pszValue;
    UCHAR  szName[1];
} MACRO;


MACRO *apMacro[CMACROMAX];
UINT cMacro = 0;

LPSTR *ppCurrentDirsFileName;
DWORD StartTime;
DWORD DirectoryStartTime;

#define SOURCES_TARGETNAME              0
#define SOURCES_TARGETPATH              1
#define SOURCES_TARGETPATHLIB           2
#define SOURCES_TARGETTYPE              3
#define SOURCES_TARGETEXT               4
#define SOURCES_INCLUDES                5
#define SOURCES_NTTEST                  6
#define SOURCES_UMTYPE                  7
#define SOURCES_UMTEST                  8
#define SOURCES_OPTIONAL_UMTEST         9
#define SOURCES_UMAPPL                  10
#define SOURCES_UMAPPLEXT               11
#define SOURCES_NTTARGETFILE0           12
#define SOURCES_NTTARGETFILES           13
#define SOURCES_PRECOMPILED_INCLUDE     14
#define SOURCES_PRECOMPILED_PCH         15
#define SOURCES_PRECOMPILED_OBJ         16
#define SOURCES_PRECOMPILED_TARGET      17
#define SOURCES_CHICAGO_PRODUCT         18
#define SOURCES_CONDITIONAL_INCLUDES    19
#define SOURCES_SYNCHRONIZE_BLOCK       20
#define SOURCES_SYNCHRONIZE_DRAIN       21
#define SOURCES_PASS0_SOURCEDIR         22
#define SOURCES_PASS0_HEADERDIR         23
#define SOURCES_PASS0_UUIDDIR           24
#define SOURCES_PASS0_CLIENTDIR         25
#define SOURCES_PASS0_SERVERDIR         26
#define SOURCES_IDLTYPE                 27
#define SOURCES_SOURCES_OPTIONS         28
#define SOURCES_MFC_INCLUDES            29
#define SOURCES_SDK_LIB_DEST            30
#define SOURCES_DDK_LIB_DEST            31
#define SOURCES_SDK_INC_PATH            32
#define SOURCES_CRT_INC_PATH            33
#define SOURCES_OAK_INC_PATH            34
#define SOURCES_DDK_INC_PATH            35
#define SOURCES_WDM_INC_PATH            36
#define SOURCES_PRIVATE_INC_PATH        37
#define SOURCES_CHECKED_ALT_DIR         38
#define SOURCES_PROJECT_NAME            39
#define SOURCES_PASS0_PUBLISH           40
#define SOURCES_USER_INCLUDES           41
#define SOURCES_LAST_INCLUDES           42
#define SOURCES_MIDL_UUIDDIR            43
#define SOURCES_SYNCHRONIZE_PASS2_BLOCK 44
#define SOURCES_SYNCHRONIZE_PASS2_DRAIN 45
#define SOURCES_MANAGED_CODE            46
#define SOURCES_SYNC_PRODUCES           47
#define SOURCES_SYNC_CONSUMES           48
#define SOURCES_MANAGED_VB              49
#define SOURCES_PASS0_BINPLACE          50
#define SOURCES_PASS1_LINK              51


LPSTR RelevantSourcesMacros[] = {
    "TARGETNAME",
    "TARGETPATH",
    "TARGETPATHLIB",
    "TARGETTYPE",
    "TARGETEXT",
    "INCLUDES",
    "NTTEST",
    "UMTYPE",
    "UMTEST",
    "OPTIONAL_UMTEST",
    "UMAPPL",
    "UMAPPLEXT",
    "NTTARGETFILE0",
    "NTTARGETFILES",
    "PRECOMPILED_INCLUDE",
    "PRECOMPILED_PCH",
    "PRECOMPILED_OBJ",
    "PRECOMPILED_TARGET",
    "CHICAGO_PRODUCT",
    "CONDITIONAL_INCLUDES",
    "SYNCHRONIZE_BLOCK",
    "SYNCHRONIZE_DRAIN",
    "PASS0_SOURCEDIR",
    "PASS0_HEADERDIR",
    "PASS0_UUIDDIR",
    "PASS0_CLIENTDIR",
    "PASS0_SERVERDIR",
    "IDL_TYPE",
    "SOURCES_OPTIONS",
    "MFC_INCLUDES",
    "SDK_LIB_DEST",
    "DDK_LIB_DEST",
    "SDK_INC_PATH",
    "CRT_INC_PATH",
    "OAK_INC_PATH",
    "DDK_INC_PATH",
    "WDM_INC_PATH",
    "PRIVATE_INC_PATH",
    "CHECKED_ALT_DIR",
    "_PROJECT_",
    "PASS0_PUBLISH",
    "USER_INCLUDES",
    "LAST_INCLUDES",
    "MIDL_UUIDDIR",
    "SYNCHRONIZE_PASS2_BLOCK",
    "SYNCHRONIZE_PASS2_DRAIN",
    "MANAGED_CODE",
    "BUILD_PRODUCES",
    "BUILD_CONSUMES",
    "MANAGED_VB",
    "PASS0_BINPLACE",
    "PASS1_LINK",
    NULL
};

#define SOURCES_MAX (ARRAY_SIZE(RelevantSourcesMacros) - 1)

VOID
MarkDirNames(PDIRREC DirDB, LPSTR TextLine, BOOL Required);

//+---------------------------------------------------------------------------
//
//  Function:   CompressBlanks
//
//  Synopsis:   Compress multiple blank characters out of macro value, in
//              place.
//
//  Arguments:  [psrc] -- String to compress
//
//  Notes:      Note that tabs, CRs, continuation lines (and their line
//              breaks) have already been replaced with blanks.
//
//----------------------------------------------------------------------------

VOID
CompressBlanks(LPSTR psrc)
{
    LPSTR pdst = psrc;

    while (*psrc == ' ') {
        psrc++;                 // skip leading macro value blanks
    }
    while (*psrc != '\0') {
        if (*psrc == '#') {             // stop at comment
            break;
        }
        if ((*pdst++ = *psrc++) == ' ') {
            while (*psrc == ' ') {
                psrc++;         // skip multiple blanks
            }
        }
    }
    *pdst = '\0';                       // terminate the compressed copy
    if (*--pdst == ' ') {
        *pdst = '\0';           // trim trailing macro value blanks
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   GetBaseDir
//
//  Synopsis:   Return the value of BASEDIR, the base NT directory, if
//              appropriate.
//
//  Arguments:  [pname] -- path to split
//
//----------------------------------------------------------------------------

LPSTR
GetBaseDir(LPSTR pname)
{
    if (_stricmp("BASEDIR", pname) == 0) {
        return (NtRoot);
    }
    return (NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   FindMacro
//
//  Synopsis:   Returns the value of a given macro by name.
//
//  Arguments:  [pszName] -- Name of macro who's value is desired.
//
//  Returns:    String containing the value of the macro
//
//----------------------------------------------------------------------------

LPSTR
FindMacro(LPSTR pszName)
{
    MACRO **ppm;

    for (ppm = apMacro; ppm < &apMacro[cMacro]; ppm++) {
        if (_stricmp(pszName, (*ppm)->szName) == 0) {
            return ((*ppm)->pszValue);
        }
    }
    return (NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveMacro
//
//  Synopsis:   Save the value of a macro
//
//  Arguments:  [pszName]  -- Name of macro to save
//              [pszValue] -- Value of macro
//
//  Notes:      A new string must be allocated and initialized prior to
//              freeing the old string when updating a macro value.
//
//----------------------------------------------------------------------------

VOID
SaveMacro(LPSTR pszName, LPSTR pszValue)
{
    MACRO **ppm;

    for (ppm = apMacro; ppm < &apMacro[cMacro]; ppm++) {
        if (_stricmp(pszName, (*ppm)->szName) == 0) {
            break;
        }
    }
    if (ppm == &apMacro[CMACROMAX]) {
        BuildError("Macro table full, ignoring: %s = %s\r\n", pszName, pszValue);
        return;
    }
    if (ppm == &apMacro[cMacro]) {
        cMacro++;
        AllocMem(sizeof(MACRO) + strlen(pszName), ppm, MT_MACRO);
        strcpy((*ppm)->szName, pszName);
        (*ppm)->pszValue = NULL;
    }
    MakeMacroString(&(*ppm)->pszValue, pszValue);
    if (DEBUG_1) {
        BuildMsg(
                "SaveMacro(%s = %s)\r\n",
                (*ppm)->szName,
                (*ppm)->pszValue == NULL? "NULL" : (*ppm)->pszValue);
    }
    if ((*ppm)->pszValue == NULL) {
        FreeMem(ppm, MT_MACRO);
        *ppm = apMacro[--cMacro];
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeMacros
//
//  Synopsis:   Free all macros
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
FreeMacros(VOID)
{
    MACRO **ppm;

    for (ppm = apMacro; ppm < &apMacro[cMacro]; ppm++) {
        FreeString(&(*ppm)->pszValue, MT_DIRSTRING);
        FreeMem(ppm, MT_MACRO);
        assert(*ppm == NULL);
    }
    cMacro = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   SplitMacro
//
//  Synopsis:   Take a string containing "MACRONAME = VALUE" and return
//              the target and value.
//
//  Arguments:  [pline] -- String to split and target return.
//
//  Returns:    Value of macro.
//
//----------------------------------------------------------------------------

LPSTR
SplitMacro(LPSTR *pszTarget)
{
    LPSTR pvalue, p, pline;

    pvalue = NULL;
    pline = *pszTarget;

    // Quickly reject comments and ! directives.
    if (*pline == '#' || *pline == '!') {
        return NULL;
    }

    if ((p = strchr(pline, '=')) != NULL) {
        pvalue = p + 1;                 // point past old '='
        while (p > pline && p[-1] == ' ') {
            p--;                        // point to start of trailing blanks
        }

        // Check for missing target.
        if (p == pline) {
            return NULL;
        }

        *p = '\0';                      // trim trailing blanks & '='

        // Perform macro substitution on target.
        *pszTarget = NULL;
        if (!MakeMacroString(pszTarget, pline)) {
            return NULL;
        }

        // Validate target name.  If must be a non-empty string of
        // valid macro name characters.
        if (**pszTarget == 0) {
            FreeString(pszTarget, MT_DIRSTRING);
            return NULL;
        }
        for (p = *pszTarget; *p != 0; p++) {
            if (!MACRO_CHAR(*p)) {
                FreeString(pszTarget, MT_DIRSTRING);
                return NULL;
            }
        }

        CompressBlanks(pvalue);
    }
    return (pvalue);
}


//+---------------------------------------------------------------------------
//
//  Function:   SubstituteString
//
//  Synopsis:   Perform any macro substitution.  This code was copied from the
//              nmake source.
//
//  Arguments:
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

void
SubstituteString(
                char **result,
                char **name,
                char **dest,
                char **end,
                char *source,
                unsigned *length
                )
{

#define ESCH  '^'

    PVOID pReallocResult;
    char *oldString, *newString;
    char *pEq, *pPar, *t;
    char *s;
    unsigned i;

    ++*name;
    for (pEq = *name; *pEq && *pEq != '='; pEq++)
        if (*pEq == ESCH)
            pEq++;

        // Did we find the '=' sign?
    if (*pEq != '=')
        printf("Error1\n");

    // Did the user forget the initial string?
    if (pEq == *name)
        printf("Error2\n");

    for (pPar = pEq; *pPar && *pPar != ')'; pPar++)
        if (*pPar == ESCH)
            pPar++;

    if (*pPar != ')')
        printf("Error3\n");

    oldString = (char *)malloc((UINT)((pEq - *name) + 1));
    if (!oldString) {
        BuildError("(Fatal Error) Out Of Memory: SubstituteString()\r\n");
        exit(16);
    }
    for (s = oldString, t = *name; *t != '='; *s++ = *t++)
        if (*t == ESCH)
            ++t;

    *s = '\0';
    i = strlen(oldString);
    newString = (char *)malloc((UINT)(pPar - pEq));
    if (!newString) {
        BuildError("(Fatal Error) Out Of Memory: SubstituteString()\r\n");
        exit(16);
    }
    for (s = newString, t++; *t != ')'; *s++ = *t++)
        if (*t == ESCH)
            ++t;

    *s = '\0';
    *name = pPar + 1;
    while (*source) {
        if ((*source == *oldString)                     // check for match
            && !strncmp(source, oldString, i)) {       // copy new in for
            for (s = newString; *s; *(*dest)++ = *s++)  //  old string
                if (*dest == *end) {
                    pReallocResult = realloc(*result, *length+100);
                    if (!pReallocResult) {
                        BuildError("(Fatal Error) Out Of Memory: SubstituteString()\r\n");
                        exit(16);
                    }
                    *result = pReallocResult;
                    *dest = *result + *length;
                    *length += 100;
                    *end = *result + *length;
                }
            source += i;
            continue;
        }
        if (*dest == *end) {

            pReallocResult = realloc(*result, *length+100);
            if (!pReallocResult) {
                BuildError("(Fatal Error) Out Of Memory: SubstituteString()\r\n");
                exit(16);
            }
            *result = pReallocResult;
            *dest = *result + *length;
            *length += 100;
            *end = *result + *length;
        }
        *(*dest)++ = *source++;         // else copy 1 char
    }
    free(oldString);
    free(newString);
}


//+---------------------------------------------------------------------------
//
//  Function:   MakeMacroString
//
//  Synopsis:   Take a string, and expand any macros in it.  (e.g.
//              "$(BASEDIR)\foobar\myfile.lib" is expanded to
//              "f:\nt\private\foobar\myfile.lib" if $(BASEDIR) has a value of
//              "f:\nt\private".
//
//  Arguments:  [pp]   -- Output string
//              [psrc] -- Input string
//
//  Returns:
//
//  Notes:      Any previous string value in [pp] is freed before updating it.
//
//----------------------------------------------------------------------------

char MMSBuffer[64*1024];
BOOL
MakeMacroString(LPSTR *pp, LPSTR psrc)
{
    LPSTR pname, p2, pdst, p3;
    int cb;
    char chTerminator;
    int cNameChars;
    int cChars;

    pdst = MMSBuffer;
    cb = strlen(psrc);
    if (cb > sizeof(MMSBuffer) - 1) {
        BuildError(
                  "(Fatal Error) Buffer overflow: MakeMacroString(%s)\r\n",
                  psrc);
        exit(16);
    }
    while ((pname = strchr(psrc, '$')) != NULL &&
           ((pname[1] == LPAREN &&
             (p2 = strchr(pname, RPAREN)) != NULL) ||
            (MACRO_CHAR(pname[1]) &&
             !MACRO_CHAR(pname[2])))) {

        LPSTR pszvalue;

        // Handle one-character non-paren macro usage.
        if (pname[1] == LPAREN) {
            // Initialize cNameChars with the number of chars to
            // skip to get to the first name character.
            cNameChars = 2;
        } else {
            p2 = pname + 2;
            cNameChars = 1;
        }

        chTerminator = *p2;
        *pname = *p2 = '\0';

        // copy up to macro name
        cChars = strlen(psrc);
        memcpy(pdst, psrc, cChars + 1);
        psrc += cChars;
        pdst += cChars;

        *pname = '$';
        pname += cNameChars;
        cNameChars += strlen(pname) + (chTerminator == RPAREN ? 1 : 0);

        p3 = NULL;
        if (chTerminator == RPAREN &&
            (p3 = strchr(pname, ':')) != NULL) {
            // macro substitution exists.  ie: $(foo:old=new)
            *p3 = '\0';
        }

        if ((pszvalue = FindMacro(pname)) == NULL &&
            (pszvalue = getenv(pname)) == NULL &&
            (pszvalue = GetBaseDir(pname)) == NULL) {

            pszvalue = "";              // can't find macro name -- ignore it
        }

        if (p3) {
            char *pNew = malloc(10);
            char *pResult = pNew;
            char *pEnd = pNew+10;
            unsigned Len = 10;

            if (!pNew) {
                BuildError("(Fatal Error) Internal buffer overflow: MakeMacroString(%s[%s = %s]%s)\r\n",
                           MMSBuffer,
                           pname,
                           pszvalue,
                           p2 + 1);
                exit(16);
            }

            *p3 = ':';
            *p2=RPAREN;
            SubstituteString(&pResult, &p3, &pNew, &pEnd, pszvalue, &Len);
            *pNew = '\0';
            *p2='\0';
            pszvalue = pResult;
        }

        cb += strlen(pszvalue) - cNameChars;
        assert(cb >= 0);
        if (cb > sizeof(MMSBuffer) - 1) {
            BuildError(
                      "(Fatal Error) Internal buffer overflow: MakeMacroString(%s[%s = %s]%s)\r\n",
                      MMSBuffer,
                      pname,
                      pszvalue,
                      p2 + 1);
            exit(16);
        }
        strcpy(pdst, pszvalue);         // copy expanded value

        if (p3) {
            free(pszvalue);
        }

        pdst += strlen(pdst);
        *p2 = chTerminator;
        psrc += cNameChars;
    }
    strcpy(pdst, psrc);                 // copy rest of string
    if (pdst != MMSBuffer) {
        CompressBlanks(MMSBuffer);
    }
    p2 = *pp;
    *pp = NULL;
    if (MMSBuffer[0] != '\0') {
        MakeString(pp, MMSBuffer, TRUE, MT_DIRSTRING);
    }
    if (p2 != NULL) {
        FreeMem(&p2, MT_DIRSTRING);
    }

    return (MMSBuffer[0] != '\0');
}


//+---------------------------------------------------------------------------
//
//  Function:   SetMacroString
//
//  Synopsis:   If the two macro names are the same, store the value in that
//              macro
//
//  Arguments:  [pMacro1] -- Name of first macro
//              [pMacro2] -- Name of second macro
//              [pValue]  -- Unexpanded value to store.
//              [ppValue] -- Expanded value of macro.
//
//  Returns:    BOOL
//
//----------------------------------------------------------------------------

BOOL
SetMacroString(LPSTR pMacro1, LPSTR pMacro2, LPSTR pValue, LPSTR *ppValue)
{
    if (_stricmp(pMacro1, pMacro2) == 0) {
        MakeMacroString(ppValue, pValue);
        return (TRUE);   // return TRUE even if MakeMacroString stored a NULL
    }
    return (FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   SplitToken
//
//  Synopsis:   Split the string at the given separator character or space.
//
//  Arguments:  [pbuf]  -- First part of split string returned here.
//              [chsep] -- Separator character.
//              [ppstr] -- Source string to split.  Becomes the second half.
//
//  Returns:    TRUE if the split was successful.  FALSE if it wasn't split.
//
//  Notes:      If *ppstr = "path\filename" and chsep = '\' on input, then
//              pbuf = "path" and *ppstr = "\filename" on output.
//
//----------------------------------------------------------------------------

BOOL
SplitToken(LPSTR pbuf, char chsep, LPSTR *ppstr)
{
    LPSTR psrc, pdst;

    psrc = *ppstr;
    pdst = pbuf;
    //BuildError("SplitToken('%c', '%s') ==> ", chsep, psrc);
    while (*psrc == chsep || *psrc == ' ') {
        psrc++;
    }
    while (*psrc != '\0' && *psrc != chsep && *psrc != ' ') {
        *pdst = *psrc++;
        if (*pdst == '/') {
            *pdst = '\\';
        }
        pdst++;
    }
    *pdst = '\0';
    *ppstr = psrc;
    //BuildErrorRaw("('%s', '%s')\r\n", psrc, pbuf);
    return (pdst != pbuf);
}

//+---------------------------------------------------------------------------
//
//  Function:   CrackSources
//
//  Synopsis:   Parse the SOURCES= line in a sources file and adds those source
//              files to the list of sources in the DIRREC struct.
//
//  Arguments:  [pdr] -- Directory record
//              [pds] -- Supplemental directory information
//              [i]   -- Which platform we're parsing
//
//----------------------------------------------------------------------------

VOID
CrackSources(
            DIRREC *pdr,
            DIRSUP *pds,
            int i)
{
    LPSTR pszsubdir, plist;
    LPSTR pszfile, pszpath;
    FILEREC *pfr;
    DIRREC *pdrAssociate;
    DIRREC *pdrParent;
    DIRREC *pdrMachine;
    DIRREC *pdrParentMachine;
    DIRREC *pdrTarget;
    DIRREC **ppdr;
    LPSTR pszSources;
    char path[DB_MAX_PATH_LENGTH];
    TARGET_MACHINE_INFO *pMachine;

    switch (i) {
        case 0:
            pMachine = TargetMachines[0];
            pszSources = "SOURCES";
            break;
        case 1:
            pMachine = TargetMachines[0];
            pszSources = "OBJLIBFILES";
            break;
        default:
            pMachine = PossibleTargetMachines[i - 2];
            pszSources = pMachine->SourceVariable;
            break;

    }

    pdrAssociate = pdrParent = pdrMachine = pdrParentMachine = pdrTarget = NULL;
    plist = pds->SourcesVariables[i];
    while (SplitToken(path, ' ', &plist)) {
        UCHAR SubDirMask, SrcFlags;

        SubDirMask = 0;
        ppdr = &pdr;                    // assume current directory
        pszsubdir = path;
        if (pszsubdir[0] == '.' && pszsubdir[1] == '\\') {
            BuildError(
                      "%s: Ignoring current directory prefix in %s= entry: %s\r\n",
                      pdr->Name,
                      pszSources,
                      path);
            pszsubdir += 2;
        }

        if (pszsubdir[0] == '.' &&
            pszsubdir[1] == '.' &&
            pszsubdir[2] == '\\') {

            SubDirMask = TMIDIR_PARENT;
            ppdr = &pdrParent;          // assume parent directory
            pszsubdir += 3;
        }

        pszpath = path;
        pszfile = strchr(pszsubdir, '\\');
        if (pszfile == NULL) {
            pszfile = pszsubdir;

        } else {
            LPSTR pszSecondSlash;
            LPSTR pszAssociateDir;
            LPSTR pszMachineDir;

            // Check for second slash and handle $O\.  If there is
            // no second slash, check for a machine specific directory name.
            // Second slashes are not legal if there's already been
            // a '..'.

            if ((SubDirMask & TMIDIR_PARENT) == 0) {
                pszSecondSlash = strchr(pszfile + 1, '\\');
                if (pszSecondSlash != NULL) {
                    pszfile = pszSecondSlash;
                }

            } else {
                pszSecondSlash = NULL;
            }


            *pszfile = '\0';
            if (pszSecondSlash != NULL) {
                pszMachineDir = pMachine->ObjectDirectory[iObjectDir];
                pszAssociateDir = pszMachineDir;

            } else {
                pszMachineDir = pMachine->SourceDirectory;
                pszAssociateDir = pMachine->AssociateDirectory;
            }

            if (((_stricmp(pszsubdir, pszAssociateDir) != 0) &&
                 (_stricmp(pszsubdir, pszMachineDir) != 0)) ||
                strchr(pszfile + 1, '\\') != NULL) {

                *pszfile = '\\';

                /*
                 * Managed code such as C# and VB.NET builds fine with a
                 * "prefix" directory, so don't complain in that case.
                 */
                if (!(pdr->DirFlags & DIRDB_MANAGED_CODE) && strcmp(pszSources, "OBJLIBFILES")) {
                    BuildError(
                              "%s: Ignoring invalid directory prefix in %s= entry: %s\r\n",
                              pdr->Name,
                              pszSources,
                              path);
                }

                pszpath = strrchr(path, '\\');
                assert(pszpath != NULL);
                pszpath++;
                SubDirMask = 0;
                ppdr = &pdr;            // default to current direcory

            } else {
                SubDirMask |= pMachine->SourceSubDirMask;
                *pszfile++ = '\\';
                if (SubDirMask & TMIDIR_PARENT) {
                    ppdr = &pdrParentMachine;

                } else if (pszSecondSlash != NULL) {
                    // Must have matched $O.
                    ppdr = &pdrTarget;

                } else {
                    if (_stricmp(pszsubdir, pszMachineDir) != 0) {
                        ppdr = &pdrMachine;

                    } else {
                        ppdr = &pdrAssociate;
                    }
                }
            }
        }

        NewDirectory:
        if (*ppdr == NULL) {
            pfr = FindSourceFileDB(pdr, pszpath, ppdr);

        } else {
            pfr = LookupFileDB(*ppdr, pszfile);
        }

        SrcFlags = SOURCEDB_SOURCES_LIST;
        if ((pfr == NULL) && !fPassZero) {
            if (fDebug) {
                BuildError("%s: Missing source file: %s\r\n", pdr->Name, path);
            }
            if (*ppdr == NULL) {
                if (fDebug || pszpath == path) {
                    BuildError(
                              "%s: Directory does not exist: %s\r\n",
                              pdr->Name,
                              path);
                }

                // Probably an error in the subordinate sources file.
                // since old versions of build managed to get these entries
                // into the objects lists, we have to do the same...
                //
                // If ..\ prefix exists, strip it off and try again.
                // Else try again with the current directory.

                if (SubDirMask & TMIDIR_PARENT) {
                    SubDirMask &= ~TMIDIR_PARENT;       // strip off "..\\"
                } else {
                    SubDirMask = 0;             // use current direcory
                }
                if (SubDirMask == 0) {
                    ppdr = &pdr;                // current direcory
                    pszpath = pszfile;
                } else {
                    ppdr = &pdrMachine;         // machine sub dir
                    pszpath = pszsubdir;
                }
                goto NewDirectory;
            }
            pfr = InsertFileDB(*ppdr, pszfile, 0, 0, FILEDB_FILE_MISSING);
            if (pfr == NULL && strcmp(pszSources, "OBJLIBFILES")) {
                BuildError(
                          "%s: Ignoring invalid %s= entry: %s\r\n",
                          pdr->Name,
                          pszSources,
                          path);
            }
        }
        if (pfr != NULL) {
            AssertFile(pfr);
            if (SubDirMask == 0) {
                pfr->FileFlags |= FILEDB_OBJECTS_LIST;
            }
            if (pfr->FileFlags & FILEDB_FILE_MISSING) {
                SrcFlags |= SOURCEDB_FILE_MISSING;
            }
            InsertSourceDB(&pds->psrSourcesList[i], pfr, SubDirMask, SrcFlags);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveUserTests
//
//  Synopsis:   Save the value of the UMTEST macro into the DIRREC struct.
//
//  Arguments:  [DirDB]    -- Dir struct to save into
//              [TextLine] -- String from UMTEST= line in sources file
//
//----------------------------------------------------------------------------

VOID
SaveUserTests(
             PDIRREC DirDB,
             LPSTR TextLine)
{
    UINT i;
    BOOL fSave = FALSE;
    char name[DB_MAX_PATH_LENGTH];
    char buf[512];

    buf[0] = '\0';
    if (DirDB->UserTests != NULL) {
        strcpy(buf, DirDB->UserTests);
    }
    CopyString(TextLine, TextLine, TRUE);
    while (SplitToken(name, '*', &TextLine)) {
        for (i = 0; i < CountOptionalDirs; i++) {
            if (!strcmp(name, OptionalDirs[i])) {
                if (buf[0] != '\0') {
                    strcat(buf, "*");
                    DirDB->DirFlags |= DIRDB_FORCELINK; // multiple targets
                }
                strcat(buf, name);
                fSave = TRUE;
                break;
            }
        }
    }
    if (fSave) {
        MakeMacroString(&DirDB->UserTests, buf);
        DirDB->DirFlags |= DIRDB_LINKNEEDED;
    }
}

void
AddProduceDependency(
                    DIRREC *DirDB,
                    LPSTR Value
                    )
{
    char produces[DB_MAX_PATH_LENGTH];
    PDEPENDENCY Dependency;

    while (SplitToken(produces, ' ',&Value)) {
        AllocMem(sizeof(DEPENDENCY)+strlen(produces), &Dependency, MT_DEPENDENCY);
        InitializeListHead(&Dependency->WaitList);
        InsertTailList(&DirDB->Produces, &Dependency->DependencyList);
        Dependency->Producer = DirDB;
        strcpy(Dependency->Name, produces);
        Dependency->CheckSum = CheckSum(Dependency->Name);
        Dependency->Next = AllDependencies;
        Dependency->Done = FALSE;
        Dependency->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (Dependency->hEvent == NULL) {
            BuildMsg("Failed to create dependency hEvent for dependency %s in directory %s\n",
                     Dependency, DirDB->Name);
        }
        AllDependencies = Dependency;
    }
}

void
AddConsumeDependency(
                    DIRREC *DirDB,
                    LPSTR Value
                    )
{
    char consumes[DB_MAX_PATH_LENGTH];
    PDEPENDENCY Dependency;
    PDEPENDENCY_WAIT Wait;
    USHORT sum;

    while (SplitToken(consumes, ' ',&Value)) {

        //
        // Find the dependency, which must have already been created by the
        // producer.
        //
        sum = CheckSum(consumes);
        Dependency = AllDependencies;
        while (Dependency) {
            if ((Dependency->CheckSum == sum) &&
                (strcmp(Dependency->Name, consumes)==0)) {
                break;
            }
            Dependency = Dependency->Next;
        }
        if (Dependency != NULL) {
            AllocMem(sizeof(DEPENDENCY_WAIT), &Wait, MT_DEPENDENCY_WAIT);
            InsertTailList(&DirDB->Consumes, &Wait->ListEntry);
            Wait->Consumer = DirDB;
            Wait->Dependency = Dependency;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessSourcesFileLine
//
//  Synopsis:   Given a line from a sources file, do the right thing.
//
//  Arguments:  [DirDB]    -- Directory containing sources file
//              [pds]      -- Supplementary info on directory
//              [TextLine] -- Line to process
//
//  Returns:    void
//
//----------------------------------------------------------------------------

void
ProcessSourcesFileLine(
                      DIRREC *DirDB,          // Current Directory record
                      DIRSUP *pds,            // Supplemental Directory record
                      LPSTR TextLine,         // Line to process
                      int iTarget             // Index into target machine array.
                      )
{
    LPSTR MacroName, p1;
    UINT i, iMacro;
    char path[DB_MAX_PATH_LENGTH];
    BOOL fCleanNTTargetFile0 = FALSE;
    LPSTR pValue;           // right side of equal sign
    LPSTR pszTemp=NULL;

    pValue = SplitMacro(&TextLine);
    if (pValue == NULL) {
        return;
    }

    // Note: TextLine is now the left side of the equal sign.  See if it's interesting.

    //
    // This sets pds->SourcesVariables[0] to the value of SOURCES= if
    // the current line is SOURCES=...
    //
    if (SetMacroString(
                      "SOURCES",
                      TextLine,
                      pValue,
                      &pds->SourcesVariables[0])) {

        DirDB->DirFlags |= DIRDB_SOURCES_SET;
        goto SaveAndFreeMacro;
    } else if (SetMacroString(
                             "OBJLIBFILES",
                             TextLine,
                             pValue,
                             &pds->SourcesVariables[1])) {
        DirDB->DirFlags |= DIRDB_SOURCES_SET;
        goto SaveAndFreeMacro;
    } else {
        for (i = 0; i < MAX_TARGET_MACHINES; i++) {
            //
            // This sets pds->SourcesVariables[0] to the value of
            // PLAT_SOURCES= if the current line is PLAT_SOURCES=...
            //
            if (SetMacroString(
                              PossibleTargetMachines[i]->SourceVariable,
                              TextLine,
                              pValue,
                              &pds->SourcesVariables[i + 2])) {

                DirDB->DirFlags |= DIRDB_SOURCES_SET;
                goto SaveAndFreeMacro;
            }
        }
    }

    // Not a SOURCES or xxx_SOURCES macro, check against all the other interesting
    // macro names.

    iMacro = 0;

    while ((MacroName = RelevantSourcesMacros[iMacro]) != NULL) {
        if (_stricmp(TextLine, MacroName) == 0) {
            break;
        }
        iMacro++;
    }
    if (MacroName != NULL) {    // if macro name found in list
        switch (iMacro) {
            case SOURCES_TARGETNAME:
                MakeMacroString(&DirDB->TargetName, pValue);
                break;

            case SOURCES_TARGETPATH:
                if (strcmp(pValue, "obj") == 0) {
                    pValue = pszObjDir;
                }
                MakeMacroString(&DirDB->TargetPath, pValue);
                if (DirDB->TargetPath != NULL) {
                    CreateBuildDirectory(DirDB->TargetPath);
                    for (i = 0; i < CountTargetMachines; i++) {
                        p1 = TargetMachines[i]->ObjectDirectory[iObjectDir];
                        assert(strncmp(pszObjDirSlash, p1, strlen(pszObjDirSlash)) == 0);
                        p1 += strlen(pszObjDirSlash);
                        sprintf(path, "%s\\%s", DirDB->TargetPath, p1);
                        CreateBuildDirectory(path);
                    }
                }
                break;

            case SOURCES_TARGETPATHLIB:
                if (strcmp(pValue, "obj") == 0) {
                    pValue = pszObjDir;
                }
                MakeMacroString(&DirDB->TargetPathLib, pValue);
                if (DirDB->TargetPathLib != NULL) {
                    CreateBuildDirectory(DirDB->TargetPathLib);
                    for (i = 0; i < CountTargetMachines; i++) {
                        p1 = TargetMachines[i]->ObjectDirectory[iObjectDir];
                        assert(strncmp(pszObjDirSlash, p1, strlen(pszObjDirSlash)) == 0);
                        p1 += strlen(pszObjDirSlash);
                        sprintf(path, "%s\\%s", DirDB->TargetPathLib, p1);
                        CreateBuildDirectory(path);
                    }
                }
                break;

            case SOURCES_TARGETTYPE:
                if (!_stricmp(pValue, "PROGRAM") || !_stricmp(pValue, "PROGLIB")) {
                    MakeMacroString(&DirDB->TargetExt, ".exe");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "OBJLIB")) {
                    MakeMacroString(&DirDB->TargetExt, ".olb");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "DRIVER") || !_stricmp(pValue, "MINIPORT")) {
                    MakeMacroString(&DirDB->TargetExt, ".sys");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "GDI_DRIVER")) {
                    MakeMacroString(&DirDB->TargetExt, ".dll");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "EXPORT_DRIVER")) {
                    MakeMacroString(&DirDB->TargetExt, ".sys");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                    DirDB->DirFlags |= DIRDB_DLLTARGET;
                } else if (!_stricmp(pValue, "DYNLINK") || !_stricmp(pValue, "HAL")) {
                    MakeMacroString(&DirDB->TargetExt, ".dll");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                    DirDB->DirFlags |= DIRDB_DLLTARGET;
                } else if ((!_stricmp(pValue, "LIBRARY")) || (!_stricmp(pValue, "DRIVER_LIBRARY"))) {
                    MakeMacroString(&DirDB->TargetExt, ".lib");
                    DirDB->DirFlags &= ~DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "UMAPPL_NOLIB")) {
                    DirDB->DirFlags &= ~DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "NOTARGET")) {
                    //
                    // Used to indicate no target for a directory,
                    // e.g. if only pass0 files are generated
                    pds->fNoTarget = TRUE;
                    if (!fQuicky || (fQuickZero && fFirstScan)) {
                        DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                    }
                } else {
                    BuildError( "Unsupported TARGETTYPE value - %s\r\n", pValue);
                }
                break;

            case SOURCES_TARGETEXT:
                {
                    char TargetExt[_MAX_EXT] = ".";
                    strcat(TargetExt, pValue);
                    MakeMacroString(&DirDB->TargetExt, TargetExt);
                }
                break;

            case SOURCES_INCLUDES:
                MakeMacroString(&pds->LocalIncludePath, pValue);
                if (DEBUG_1) {
                    BuildMsg(
                            "        Found local INCLUDES=%s\r\n",
                            pds->LocalIncludePath);
                }
                break;

            case SOURCES_USER_INCLUDES:
                MakeMacroString(&pds->UserIncludePath, pValue);
                if (DEBUG_1) {
                    BuildMsg(
                            "        Found local USER_INCLUDES=%s\r\n",
                            pds->UserIncludePath);
                }
                break;

            case SOURCES_LAST_INCLUDES:
                MakeMacroString(&pds->LastIncludePath, pValue);
                if (DEBUG_1) {
                    BuildMsg(
                            "        Found local LAST_INCLUDES=%s\r\n",
                            pds->LastIncludePath);
                }
                break;

            case SOURCES_MFC_INCLUDES:
                // MFC_INCLUDES/SDK_INC/CRT_INC/OAK_INC really can't be changed
                // in the sources file (yet) since we've already processed the
                // system includes.  Lay the groundwork for now.
                MakeMacroString((char **)&pszIncMfc, pValue);
                break;

            case SOURCES_SDK_LIB_DEST:
                MakeMacroString((char **)&pszSdkLibDest, pValue);
                break;

            case SOURCES_DDK_LIB_DEST:
                MakeMacroString((char **)&pszDdkLibDest, pValue);
                break;

            case SOURCES_SDK_INC_PATH:
                MakeMacroString((char **)&pszIncSdk, pValue);
                break;

            case SOURCES_CRT_INC_PATH:
                MakeMacroString((char **)&pszIncCrt, pValue);
                break;

            case SOURCES_OAK_INC_PATH:
                MakeMacroString((char **)&pszIncOak, pValue);
                break;

            case SOURCES_DDK_INC_PATH:
                MakeMacroString((char **)&pszIncDdk, pValue);
                break;

            case SOURCES_WDM_INC_PATH:
                MakeMacroString((char **)&pszIncWdm, pValue);
                break;

            case SOURCES_PRIVATE_INC_PATH:
                MakeMacroString((char **)&pszIncPri, pValue);
                break;

            case SOURCES_PRECOMPILED_PCH:
                MakeMacroString(&DirDB->Pch, pValue);
                break;

            case SOURCES_PRECOMPILED_OBJ:
                MakeMacroString(&DirDB->PchObj, pValue);
                break;

            case SOURCES_PRECOMPILED_INCLUDE:
            case SOURCES_PRECOMPILED_TARGET:
                {
                    LPSTR *ppszPath, *ppszFile, p;
                    if (iMacro == SOURCES_PRECOMPILED_INCLUDE) {
                        ppszPath = &pds->PchIncludeDir;
                        ppszFile = &pds->PchInclude;
                    } else {
                        ppszPath = &pds->PchTargetDir;
                        ppszFile = &pds->PchTarget;
                    }

                    MakeMacroString(ppszPath, "");  // free old string
                    if (!MakeMacroString(ppszFile, pValue)) {
                        break;
                    }
                    p = *ppszFile + strlen(*ppszFile);
                    while (p > *ppszFile && *--p != '\\')
                        ;

                    if (p > *ppszFile) {
                        *p = '\0';
                        MakeMacroString(ppszPath, *ppszFile);
                        MakeMacroString(ppszFile, p + 1);
                    }

                    if (DEBUG_1) {
                        BuildMsg(
                                "Precompiled header%s is %s in directory %s\r\n",
                                iMacro == SOURCES_PRECOMPILED_INCLUDE?
                                "" : " target",
                                *ppszFile,
                                *ppszPath != NULL?
                                *ppszPath : "'.'");
                    }
                }

                if (iMacro == SOURCES_PRECOMPILED_INCLUDE ||
                    pds->PchTargetDir == NULL) {

                    break;
                }

                EnsureDirectoriesExist(pds->PchTargetDir);
                break;

            case SOURCES_PASS0_HEADERDIR:
                MakeMacroString(&pds->PassZeroHdrDir, pValue);
                EnsureDirectoriesExist(pds->PassZeroHdrDir);
                if (DEBUG_1) {
                    BuildMsg("Pass Zero Header Directory is '%s'\r\n",
                             pds->PassZeroHdrDir);
                }
                break;

            case SOURCES_PASS0_SOURCEDIR:
                // SOURCES_PASS0_SOURCEDIR and SOURCES_PASS0_CLIENTDIR
                // are mutually exclusive - enforced by makefile.def
                DirDB->DirFlags &= ~DIRDB_IDLTYPERPC;
                MakeMacroString(&pds->PassZeroSrcDir1, pValue);
                EnsureDirectoriesExist(pds->PassZeroSrcDir1);
                if (DEBUG_1) {
                    BuildMsg("Pass Zero Source Directory is '%s'\r\n",
                             pds->PassZeroSrcDir1);
                }
                break;

            case SOURCES_PASS0_CLIENTDIR:
                // SOURCES_PASS0_SOURCEDIR and SOURCES_PASS0_CLIENTDIR
                // are mutually exclusive - enforced by makefile.def
                DirDB->DirFlags |= DIRDB_IDLTYPERPC;
                MakeMacroString(&pds->PassZeroSrcDir1, pValue);
                EnsureDirectoriesExist(pds->PassZeroSrcDir1);
                if (DEBUG_1) {
                    BuildMsg("Pass Zero Client Directory is '%s'\r\n",
                             pds->PassZeroSrcDir1);
                }
                break;

            case SOURCES_MIDL_UUIDDIR:
            case SOURCES_PASS0_UUIDDIR:
                // SOURCES_PASS0_UUIDDIR and SOURCES_PASS0_SERVERDIR
                // are mutually exclusive - enforced by makefile.def
                DirDB->DirFlags &= ~DIRDB_IDLTYPERPC;
                MakeMacroString(&pds->PassZeroSrcDir2, pValue);
                EnsureDirectoriesExist(pds->PassZeroSrcDir2);
                if (DEBUG_1) {
                    BuildMsg("Pass Zero UUID Source Directory is '%s'\r\n",
                             pds->PassZeroSrcDir2);
                }
                break;

            case SOURCES_PASS0_SERVERDIR:
                // SOURCES_PASS0_UUIDDIR and SOURCES_PASS0_SERVERDIR
                // are mutually exclusive - enforced by makefile.def
                DirDB->DirFlags |= DIRDB_IDLTYPERPC;
                MakeMacroString(&pds->PassZeroSrcDir2, pValue);
                EnsureDirectoriesExist(pds->PassZeroSrcDir2);
                if (DEBUG_1) {
                    BuildMsg("Pass Zero Server Directory is '%s'\r\n",
                             pds->PassZeroSrcDir2);
                }
                break;

            case SOURCES_NTTEST:
                if (MakeMacroString(&DirDB->KernelTest, pValue)) {
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                }
                break;

            case SOURCES_UMTYPE:
                MakeMacroString(&pds->TestType, pValue);
                if (DEBUG_1) {
                    BuildMsg(
                            "        Found UMTYPE=%s\r\n",
                            pds->TestType);
                }
                break;

            case SOURCES_UMTEST:
            case SOURCES_OPTIONAL_UMTEST:
                SaveUserTests(DirDB, pValue);
                break;

            case SOURCES_UMAPPL:
                if (MakeMacroString(&DirDB->UserAppls, pValue)) {
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                }
                break;

            case SOURCES_UMAPPLEXT:
                if (!_stricmp(pValue, ".exe")) {
                    MakeMacroString(&DirDB->TargetExt, ".exe");
                } else
                    if (!_stricmp(pValue, ".com")) {
                    MakeMacroString(&DirDB->TargetExt, ".com");
                } else
                    if (!_stricmp(pValue, ".scr")) {
                    MakeMacroString(&DirDB->TargetExt, ".scr");
                } else {
                    BuildError(
                              "Unsupported UMAPPLEXT value - %s\r\n",
                              pValue);
                }
                break;

            case SOURCES_IDLTYPE:
                if (!_stricmp(pValue, "ole")) {
                    pds->IdlType = 0;
                } else
                    if (!_stricmp(pValue, "rpc")) {
                    pds->IdlType = 1;
                } else {
                    BuildError(
                              "Unsupported IDL_TYPE value - %s\r\n",
                              pValue);
                }
                break;

            case SOURCES_SOURCES_OPTIONS:
                fCleanNTTargetFile0 = fClean && strstr(pValue, "-c0");
                break;

            case SOURCES_NTTARGETFILE0:
                DirDB->DirFlags |= DIRDB_TARGETFILE0;
                if (fCleanNTTargetFile0) {
                    MakeMacroString(&DirDB->NTTargetFile0, pValue);
                }
                break;

            case SOURCES_NTTARGETFILES:
                DirDB->DirFlags |= DIRDB_TARGETFILES;
                break;

            case SOURCES_CHICAGO_PRODUCT:
                DirDB->DirFlags |= DIRDB_CHICAGO_INCLUDES;
                break;

            case SOURCES_CONDITIONAL_INCLUDES:
                MakeMacroString(&pds->ConditionalIncludes, pValue);
                break;

            case SOURCES_SYNCHRONIZE_BLOCK:
                //if ((!fIgnoreSync) && !(DirDB->DirFlags & (DIRDB_SYNC_PRODUCES | DIRDB_SYNC_CONSUMES))) {
                if (!fIgnoreSync) {
                    DirDB->DirFlags |= DIRDB_SYNCHRONIZE_BLOCK;
                }
                break;

            case SOURCES_SYNCHRONIZE_PASS2_BLOCK:
                DirDB->DirFlags |= DIRDB_SYNCHRONIZE_PASS2_BLOCK;
                break;

            case SOURCES_SYNCHRONIZE_DRAIN:
                // if ((!fIgnoreSync) && !(DirDB->DirFlags & (DIRDB_SYNC_PRODUCES | DIRDB_SYNC_CONSUMES))) {
                if ((!fIgnoreSync) && !(DirDB->DirFlags & DIRDB_SYNC_CONSUMES)) {
                    DirDB->DirFlags |= DIRDB_SYNCHRONIZE_DRAIN;
                }
                break;

            case SOURCES_SYNCHRONIZE_PASS2_DRAIN:
                DirDB->DirFlags |= DIRDB_SYNCHRONIZE_PASS2_DRAIN;
                break;

            case SOURCES_CHECKED_ALT_DIR:
                if (!fBuildAltDirSet) {
                    DirDB->DirFlags |= DIRDB_CHECKED_ALT_DIR;
                    if (DEBUG_1) {
                        BuildMsg("Found CHECKED_ALT_DIR\r\n");
                    }
                    SetObjDir(TRUE);
                    if (fCheckedBuild) {
                        SaveMacro("_OBJ_DIR", pszObjDir);
                        if (iTarget < 0) {
                            SaveMacro("O", TargetMachines[0]->
                                      ObjectDirectory[iObjectDir]);
                        } else {
                            SaveMacro("O",
                                      PossibleTargetMachines[iTarget/2]->
                                      ObjectDirectory[iObjectDir]);
                        }
                    }
                }
                break;

            case SOURCES_PROJECT_NAME:
                sprintf(path, "%s\\%s", NtRoot, pValue);
                SaveMacro("PROJECT_ROOT", path);
                break;

            case SOURCES_PASS0_PUBLISH:
                DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                break;

            case SOURCES_MANAGED_CODE:
            case SOURCES_MANAGED_VB:
                DirDB->DirFlags |= DIRDB_MANAGED_CODE;
                break;

            case SOURCES_SYNC_PRODUCES:
                DirDB->DirFlags |= DIRDB_SYNC_PRODUCES;
                //A producer directory can be a BLOCK or a DRAIN.
                //DirDB->DirFlags &= ~(DIRDB_SYNCHRONIZE_BLOCK | DIRDB_SYNCHRONIZE_DRAIN);
                MakeMacroString(&pszTemp, pValue);
                AddProduceDependency(DirDB, pszTemp);
                break;

            case SOURCES_SYNC_CONSUMES:
                DirDB->DirFlags |= DIRDB_SYNC_CONSUMES;
                //Changed so that the same directory can be the consumer as well as a block...
                //DirDB->DirFlags &= ~(DIRDB_SYNCHRONIZE_BLOCK | DIRDB_SYNCHRONIZE_DRAIN);
                DirDB->DirFlags &= ~(DIRDB_SYNCHRONIZE_DRAIN);
                MakeMacroString(&pszTemp, pValue);
                AddConsumeDependency(DirDB, pszTemp);
                break;

            case SOURCES_PASS0_BINPLACE:
                DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                break;

            case SOURCES_PASS1_LINK:
                DirDB->DirFlags &= ~DIRDB_LINKNEEDED;
                break;
        }
    }

    SaveAndFreeMacro:
    SaveMacro(TextLine, pValue);

    // Make sure we cleanup from the SplitMacro call at the top.
    FreeString(&TextLine, MT_DIRSTRING);
}

void
ReadProjectsInfo(
                DIRREC *DirDB,
                DIRSUP *pds
                )
{
    FILE *FileHandle;
    LPSTR TextLine, pBackSlash, pszProject;
    BOOL Found;

    char pszProjectMkPath[DB_MAX_PATH_LENGTH];
    char path[DB_MAX_PATH_LENGTH];

    // First load project.mk for this project.

    strcpy(pszProjectMkPath, DirDB->Name);
    strcpy(path, pszProjectMkPath);
    strcat(path, "\\project.mk");
    Found = !_access(path, 0);
    while (!Found && strlen(pszProjectMkPath)) {
        pBackSlash=strrchr(pszProjectMkPath, '\\');
        if (pBackSlash) {
            *pBackSlash = '\0';
        } else {
            return;
        }
        strcpy(path, pszProjectMkPath);
        strcat(path, "\\project.mk");
        Found = !_access(path, 0);
    }

    if (!Found) {
        return;
    }

    if (!OpenFilePush(pszProjectMkPath, "project.mk", "#", &FileHandle)) {
        return;
    }

    SaveMacro("_PROJECT_MK_PATH", pszProjectMkPath);
    while ((TextLine = ReadLine(FileHandle)) != NULL) {
        ProcessSourcesFileLine(DirDB, pds, TextLine, -1);
    }
    CloseReadFile(NULL);

    // Load the optional myproject.mk

    if (OpenFilePush(pszProjectMkPath, "myproject.mk", "#", &FileHandle)) {

        while ((TextLine = ReadLine(FileHandle)) != NULL) {
            ProcessSourcesFileLine(DirDB, pds, TextLine, -1);
        }
        CloseReadFile(NULL);
    }

    // Then load ntmakeenv\projects.inc to get the other magic macro names.

    if (!OpenFilePush(getenv("NTMAKEENV"), "projects.inc", "#", &FileHandle)) {
        return;
    }

    while ((TextLine = ReadLine(FileHandle)) != NULL) {
        ProcessSourcesFileLine(DirDB, pds, TextLine, -1);
    }
    CloseReadFile(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadSourcesFile
//
//  Synopsis:   Parses the sources files (common and platform specific)
//
//  Arguments:  [DirDB]            -- Directory containing sources file
//              [pds]              -- Supplementary info on directory
//              [pDateTimeSources] -- Timestamp of Sources file
//
//  Returns:    TRUE if read successfully
//
//----------------------------------------------------------------------------

#define SAVE_STATIC_MACRO(MacroName, InitialValue) \
{                                                  \
    static char sz[] = InitialValue;               \
    SaveMacro(MacroName, sz);                      \
}                                                  \

BOOL
ReadSourcesFile(DIRREC *DirDB, DIRSUP *pds, ULONG *pDateTimeSources)
{
    FILE *InFileHandle;
    LPSTR p, TextLine;
    UINT i;
    int iTarget;
    ULONG DateTime;
    char path[DB_MAX_PATH_LENGTH];
    char temp[DB_MAX_PATH_LENGTH];

    memset(pds, 0, sizeof(*pds));
    pds->fNoTarget=FALSE;
    assert(DirDB->TargetPath == NULL);
    assert(DirDB->TargetPathLib == NULL);
    assert(DirDB->TargetName == NULL);
    assert(DirDB->TargetExt == NULL);
    assert(DirDB->KernelTest == NULL);
    assert(DirDB->UserAppls == NULL);
    assert(DirDB->UserTests == NULL);
    assert(DirDB->NTTargetFile0 == NULL);
    assert(DirDB->Pch == NULL);
    assert(DirDB->PchObj == NULL);
    assert(cMacro == 0);
    *pDateTimeSources = 0;

    //
    // Read the information in each of the target specific directories
    // and simulate concatenation of all of the sources files.
    //
    // Possible sources files are read from DirDB->Name | target-source
    // and DirDb->Name | ..\target-source.
    //
    // iTarget values, and the corresponding files processed are:
    //  -1      sources.
    //   0      PossibleTargetMachines[0]\sources.
    //   1      ..\PossibleTargetMachines[0]\sources.
    //   2      PossibleTargetMachines[1]\sources.
    //   3      ..\PossibleTargetMachines[1]\sources.
    //   4      PossibleTargetMachines[2]\sources.
    //   5      ..\PossibleTargetMachines[2]\sources.

    SaveMacro("MAKEDIR", DirDB->Name);
    SaveMacro("SDK_LIB_DEST", pszSdkLibDest);
    SaveMacro("DDK_LIB_DEST", pszDdkLibDest);
    SaveMacro("PUBLIC_INTERNAL_PATH", pszPublicInternalPath);
    // Use the default architecture for now
    SaveMacro("TARGET_DIRECTORY", TargetMachines[0]->SourceDirectory);

    SetObjDir(FALSE);
    SaveMacro("_OBJ_DIR", pszObjDir);
    // Define a default CONDITIONAL_INCLUDES line to deal with the mac hdrs in windows/rpc/ole32.h.
    MakeMacroString(&pds->ConditionalIncludes, "winwlm.h rpcmac.h rpcerr.h macapi.h macname1.h macname2.h macocidl.h macpub.h macwin32.h");

    // Before processing the sources file, see if there's a projects.mk in the tree.
    ReadProjectsInfo(DirDB, pds);

    SAVE_STATIC_MACRO("PROJECT_PUBLIC_PATH", "$(PUBLIC_INTERNAL_PATH)\\$(_PROJECT_)");
    SAVE_STATIC_MACRO("PROJECT_INC_PATH", "$(PROJECT_PUBLIC_PATH)\\inc");

    strcpy(temp,"$(PROJECT_ROOT)\\inc;$(PROJECT_ROOT)\\inc\\$(O);$(PROJECT_INC_PATH)");
    MakeMacroString(&pds->NTIncludePath, temp);

    for (iTarget = -1; iTarget < 2*MAX_TARGET_MACHINES; iTarget++) {
        path[0] = '\0';
        if (iTarget >= 0) {
            if (iTarget & 1) {
                strcat(path, "..\\");
            }
            strcat(path, PossibleTargetMachines[iTarget/2]->SourceDirectory);
            strcat(path, "\\");
        }
        strcat(path, "sources");
        if (!OpenFilePush(DirDB->Name, path, "#", &InFileHandle)) {
            if (iTarget == -1) {
                FreeMacros();
                return (FALSE);
            }
            continue;           // skip non-existent subordinate sources files
        }
        if (DEBUG_1) {
            BuildMsg(
                    "    Scanning%s file %s\r\n",
                    iTarget >= 0 ? " subordinate" : "",
                    FormatPathName(DirDB->Name, path));
        }

        // Update per-target macros.
        if (iTarget < 0) {
            SaveMacro("TARGET_DIRECTORY",
                      TargetMachines[0]->SourceDirectory);
            SaveMacro("O", TargetMachines[0]->
                      ObjectDirectory[iObjectDir]);
        } else {
            SaveMacro("TARGET_DIRECTORY",
                      PossibleTargetMachines[iTarget/2]->SourceDirectory);
            SaveMacro("O", PossibleTargetMachines[iTarget/2]->
                      ObjectDirectory[iObjectDir]);
        }

        SAVE_STATIC_MACRO("SDK_LIB_PATH", "$(SDK_LIB_DEST)\\$(TARGET_DIRECTORY)");
        SAVE_STATIC_MACRO("PROJECT_LIB_PATH", "$(PROJECT_PUBLIC_PATH)\\lib\\$(TARGET_DIRECTORY)");

        DirDB->DirFlags |= DIRDB_SOURCESREAD;

        while ((TextLine = ReadLine(InFileHandle)) != NULL) {
            ProcessSourcesFileLine(DirDB, pds, TextLine, iTarget);
        }

        // Subordinate files close themselves at EOF.  Timestamps
        // are propagated in CloseReadFile so the primary
        // file's timestamp is automatically updated.
    }

    // Close the primary file.
    DateTime = CloseReadFile(NULL);
    if (*pDateTimeSources < DateTime) {
        *pDateTimeSources = DateTime;       // keep newest timestamp
    }

    if (!pds->fNoTarget && (DirDB->TargetPath == NULL)) {
        strcpy(path, "sources");
        SetupReadFile(DirDB->Name, path, "#", &InFileHandle);
        BuildError(
                  "Unknown TARGETPATH value\r\n",
                  NULL);
        CloseReadFile(NULL);
    }

    FreeMacros();

    if (fChicagoProduct) {
        DirDB->DirFlags |= DIRDB_CHICAGO_INCLUDES;
    }

    //
    // Directory has pass0 files in it (.idl, .mc, .asn, etc), check to make
    // sure they specified where the generated files should go.  Default to the
    // obj subdirectories if they didn't.  These always need to be non-null.
    //
    if (!pds->PassZeroHdrDir) {
        MakeString(&pds->PassZeroHdrDir, ".", TRUE, MT_DIRSTRING);
    }

    if (!pds->PassZeroSrcDir1) {
        MakeString(&pds->PassZeroSrcDir1, ".", TRUE, MT_DIRSTRING);
    }

    if (!pds->PassZeroSrcDir2)
        MakeString(&pds->PassZeroSrcDir2, pds->PassZeroSrcDir1, TRUE, MT_DIRSTRING);

    if (DirDB->UserTests != NULL) {
        _strlwr(DirDB->UserTests);
    }
    if (DirDB->UserAppls != NULL) {
        if (DirDB->UserTests != NULL || strchr(DirDB->UserAppls, '*') != NULL) {
            DirDB->DirFlags |= DIRDB_FORCELINK; // multiple targets
        }
    }

    PostProcessSources(DirDB, pds);

    if (DEBUG_1) {
        PrintDirDB(DirDB, 1|2);
        PrintDirSupData(pds);
        PrintDirDB(DirDB, 4);
    }

    pds->DateTimeSources = *pDateTimeSources;

    return (TRUE);
}

#undef SAVE_STATIC_MACRO
//+---------------------------------------------------------------------------
//
//  Function:   PostProcessSources
//
//  Synopsis:   Scan the files in the given directory and add files to the
//              directory's list of source files (SOURCEREC), including PCH
//              files, UMTEST files, etc.
//
//  Arguments:  [pdr] -- Directory to process
//              [pds] -- Directory supplemental information
//
//----------------------------------------------------------------------------

void
PostProcessSources(DIRREC *pdr, DIRSUP *pds)
{
    PFILEREC FileDB, *FileDBNext;
    char path[DB_MAX_PATH_LENGTH];
    LPSTR p, p1;
    UINT i;

    for (i = 0; i < MAX_TARGET_MACHINES + 2; i++) {
        if (pds->SourcesVariables[i] != NULL) {
            CrackSources(pdr, pds, i);
        }
    }

    FileDBNext = &pdr->Files;
    while (FileDB = *FileDBNext) {

        if (pds->PchInclude && strcmp(FileDB->Name, pds->PchInclude) == 0) {
            InsertSourceDB(&pds->psrSourcesList[0], FileDB, 0, SOURCEDB_PCH);
            if (DEBUG_1) {
                BuildMsg("Adding PCH file to Sources List: %s.\r\n", FileDB->Name);
            }
        }

        if ((FileDB->FileFlags & (FILEDB_SOURCE | FILEDB_OBJECTS_LIST)) ==
            FILEDB_SOURCE) {

            p = FileDB->Name;
            p1 = path;
            while (*p != '\0' && *p != '.') {
                *p1++ = *p++;
            }
            *p1 = '\0';
            _strlwr(path);
            if (pdr->KernelTest != NULL &&
                !strcmp(path, pdr->KernelTest)) {

                FileDB->FileFlags |= FILEDB_OBJECTS_LIST;
            } else
                if (pdr->UserAppls != NULL &&
                    (p = strstr(pdr->UserAppls, path)) &&
                    (p == pdr->UserAppls || p[-1] == '*' || p[-1] == ' ')) {
                FileDB->FileFlags |= FILEDB_OBJECTS_LIST;
            } else
                if (pdr->UserTests != NULL &&
                    (p = strstr(pdr->UserTests, path)) &&
                    (p == pdr->UserTests || p[-1] == '*' || p[-1] == ' ')) {

                FileDB->FileFlags |= FILEDB_OBJECTS_LIST;
            }
            if (FileDB->FileFlags & FILEDB_OBJECTS_LIST) {
                InsertSourceDB(&pds->psrSourcesList[0], FileDB, 0, 0);
            }
        }
        FileDBNext = &FileDB->Next;
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadDirsFile
//
//  Synopsis:   Parse the DIRS file
//
//  Arguments:  [DirDB] -- Directory to look in
//
//  Returns:    TRUE if parsed
//
//  Notes:      The existence of a file named 'mydirs' or the name of the
//              target specific dirs will override the normal 'dirs' file.
//
//----------------------------------------------------------------------------

BOOL
ReadDirsFile(
            PDIRREC DirDB
            )

{
    FILE *InFileHandle;
    LPSTR TextLine, pValue;
    LPSTR apszDirs[] = { "mydirs", NULL, "dirs", NULL};
    CHAR TargetName[16];

    strcpy(&TargetName[0], pszTargetDirs);
    strcat(&TargetName[0], ".");
    apszDirs[1] = &TargetName[0];

    for (ppCurrentDirsFileName = apszDirs;
        *ppCurrentDirsFileName != NULL;
        ppCurrentDirsFileName++) {
        if (SetupReadFile(DirDB->Name, *ppCurrentDirsFileName, "#", &InFileHandle)) {
            break;
        }
    }

    if (*ppCurrentDirsFileName == NULL || !InFileHandle) {
        FreeMacros();
        return (FALSE);
    }

    if (fFirstScan && (ppCurrentDirsFileName <= &apszDirs[1])) {
        BuildMsg("Using .\\%s instead of DIRS...\r\n",
                 FormatPathName(DirDB->Name, *ppCurrentDirsFileName));
    }

    if (DEBUG_1) {
        BuildMsg(
                "    Scanning file %s\r\n",
                FormatPathName(DirDB->Name, *ppCurrentDirsFileName));
    }

    assert(cMacro == 0);
    while ((TextLine = ReadLine(InFileHandle)) != NULL) {
        if ((pValue = SplitMacro(&TextLine)) != NULL) {
            SaveMacro(TextLine, pValue);
            FreeString(&TextLine, MT_DIRSTRING);
        }
    }
    CloseReadFile(NULL);
    if ((pValue = FindMacro("DIRS")) != NULL) {
        MarkDirNames(DirDB, pValue, TRUE);
    }
    if ((pValue = FindMacro("OPTIONAL_DIRS")) != NULL) {
        MarkDirNames(DirDB, pValue, BuildAllOptionalDirs);
    }
    if ((FindMacro("SYNCHRONIZE_DRAIN")) != NULL) {
        if (!fIgnoreSync) {
            DirDB->DirFlags |= DIRDB_SYNCHRONIZE_DRAIN;
        }
    }
    FreeMacros();
    return ( TRUE );
}


//
// Debugging and Utility Functions
//

VOID
PrintDirSupData(DIRSUP *pds)
{
    int i;

    if (pds->LocalIncludePath != NULL) {
        BuildMsgRaw("  LocalIncludePath: %s\r\n", pds->LocalIncludePath);
    }
    if (pds->UserIncludePath != NULL) {
        BuildMsgRaw("  UserIncludePath: %s\r\n", pds->UserIncludePath);
    }
    if (pds->LastIncludePath != NULL) {
        BuildMsgRaw("  LastIncludePath: %s\r\n", pds->LastIncludePath);
    }
    if (pds->TestType != NULL) {
        BuildMsgRaw("  TestType: %s\r\n", pds->TestType);
    }
    if (pds->PchIncludeDir != NULL) {
        BuildMsgRaw("  PchIncludeDir: %s\r\n", pds->PchIncludeDir);
    }
    if (pds->PchInclude != NULL) {
        BuildMsgRaw("  PchInclude: %s\r\n", pds->PchInclude);
    }
    if (pds->PchTargetDir != NULL) {
        BuildMsgRaw("  PchTargetDir: %s\r\n", pds->PchTargetDir);
    }
    if (pds->PchTarget != NULL) {
        BuildMsgRaw("  PchTarget: %s\r\n", pds->PchTarget);
    }
    if (pds->ConditionalIncludes != NULL) {
        BuildMsgRaw("  ConditionalIncludes: %s\r\n", pds->ConditionalIncludes);
    }
    for (i = 0; i < MAX_TARGET_MACHINES + 2; i++) {
        if (pds->SourcesVariables[i] != NULL) {
            BuildMsgRaw(
                       "  SourcesVariables[%d]: %s\r\n",
                       i,
                       pds->SourcesVariables[i]);
        }
        if (pds->psrSourcesList[i] != NULL) {
            BuildMsgRaw("  SourcesList[%d]:\r\n", i);
            PrintSourceDBList(pds->psrSourcesList[i], i);
        }
    }
}


VOID
FreeDirSupData(DIRSUP *pds)
{
    int i;

    if (pds->LocalIncludePath != NULL) {
        FreeMem(&pds->LocalIncludePath, MT_DIRSTRING);
    }
    if (pds->UserIncludePath != NULL) {
        FreeMem(&pds->UserIncludePath, MT_DIRSTRING);
    }
    if (pds->LastIncludePath != NULL) {
        FreeMem(&pds->LastIncludePath, MT_DIRSTRING);
    }
    if (pds->NTIncludePath != NULL) {
        FreeMem(&pds->NTIncludePath, MT_DIRSTRING);
    }
    if (pds->TestType != NULL) {
        FreeMem(&pds->TestType, MT_DIRSTRING);
    }
    if (pds->PchInclude != NULL) {
        FreeMem(&pds->PchInclude, MT_DIRSTRING);
    }
    if (pds->PchIncludeDir != NULL) {
        FreeMem(&pds->PchIncludeDir, MT_DIRSTRING);
    }
    if (pds->PchTargetDir != NULL) {
        FreeMem(&pds->PchTargetDir, MT_DIRSTRING);
    }
    if (pds->PchTarget != NULL) {
        FreeMem(&pds->PchTarget, MT_DIRSTRING);
    }
    if (pds->ConditionalIncludes != NULL) {
        FreeMem(&pds->ConditionalIncludes, MT_DIRSTRING);
    }
    if (pds->PassZeroHdrDir != NULL) {
        FreeMem(&pds->PassZeroHdrDir, MT_DIRSTRING);
    }
    if (pds->PassZeroSrcDir1 != NULL) {
        FreeMem(&pds->PassZeroSrcDir1, MT_DIRSTRING);
    }
    if (pds->PassZeroSrcDir2 != NULL) {
        FreeMem(&pds->PassZeroSrcDir2, MT_DIRSTRING);
    }
    for (i = 0; i < MAX_TARGET_MACHINES + 2; i++) {
        if (pds->SourcesVariables[i] != NULL) {
            FreeMem(&pds->SourcesVariables[i], MT_DIRSTRING);
        }
        while (pds->psrSourcesList[i] != NULL) {
            FreeSourceDB(&pds->psrSourcesList[i]);
        }
    }
}


VOID
FreeDirData(DIRREC *pdr)
{
    if (pdr->TargetPath != NULL) {
        FreeMem(&pdr->TargetPath, MT_DIRSTRING);
    }
    if (pdr->TargetPathLib != NULL) {
        FreeMem(&pdr->TargetPathLib, MT_DIRSTRING);
    }
    if (pdr->TargetName != NULL) {
        FreeMem(&pdr->TargetName, MT_DIRSTRING);
    }
    if (pdr->TargetExt != NULL) {
        FreeMem(&pdr->TargetExt, MT_DIRSTRING);
    }
    if (pdr->KernelTest != NULL) {
        FreeMem(&pdr->KernelTest, MT_DIRSTRING);
    }
    if (pdr->UserAppls != NULL) {
        FreeMem(&pdr->UserAppls, MT_DIRSTRING);
    }
    if (pdr->UserTests != NULL) {
        FreeMem(&pdr->UserTests, MT_DIRSTRING);
    }
    if (pdr->NTTargetFile0 != NULL) {
        FreeMem(&pdr->NTTargetFile0, MT_DIRSTRING);
    }
    if (pdr->Pch != NULL) {
        FreeMem(&pdr->Pch, MT_DIRSTRING);
    }
    if (pdr->PchObj != NULL) {
        FreeMem(&pdr->PchObj, MT_DIRSTRING);
    }
    if (pdr->pds != NULL) {
        FreeDirSupData(pdr->pds);
        FreeMem(&pdr->pds, MT_DIRSUP);
        pdr->pds = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MarkDirNames
//
//  Synopsis:   Parses a DIRS= or OPTIONAL_DIRS line and marks the directories
//              appropriately.
//
//  Arguments:  [DirDB]    -- Directory containing DIRS file
//              [TextLine] -- DIRS= or OPTIONAL_DIRS= line
//              [Required] -- Indicates if directories are optional or not.
//
//----------------------------------------------------------------------------

VOID
MarkDirNames(PDIRREC DirDB, LPSTR TextLine, BOOL Required)
{
    UINT i;
    LPSTR p, token;
    PFILEREC FileDB, *FileDBNext;
    char dirbuf[DB_MAX_PATH_LENGTH];
    ULONG DirInclude;

    AssertPathString(TextLine);
    while (SplitToken(dirbuf, '*', &TextLine)) {
        // Assume all platforms are included for this dir.
        DirInclude = DIR_INCLUDE_ALL;
        for (p = dirbuf; *p != '\0'; p++) {
            if ( dirbuf != p && *p == '{' ) {
                // An explicit include path was listed.
                DirInclude = DIR_INCLUDE_NONE;
                *p = '\0';
                token = strtok(p+1, ",}");
                while (token) {
                    if (!_stricmp(token, "X86") ||
                        !_stricmp(token, "I386") ||
                        !_stricmp(token, "386")) {
                        DirInclude |= DIR_INCLUDE_X86;
                    } else if (!_stricmp(token, "32") ||
                               !_stricmp(token, "Win32")) {
                        DirInclude |= DIR_INCLUDE_WIN32;
                    } else if (!_stricmp(token, "64") ||
                               !_stricmp(token, "Win64")) {
                        DirInclude |= DIR_INCLUDE_WIN64;
                    } else if (!_stricmp(token, "IA64")) {
                        DirInclude |= DIR_INCLUDE_IA64;
                    } else if (!_stricmp(token, "AMD64")) {
                        DirInclude |= DIR_INCLUDE_AMD64;
                    } else if (!_stricmp(token, "RISC")) {
                        DirInclude |= DIR_INCLUDE_RISC;
                    } else if (!_stricmp(token, "ARM")) {
                        DirInclude |= DIR_INCLUDE_ARM;
                    }
                    token = strtok(NULL, ",}");
                }
                break;
            } else {
                if (!iscsym(*p) && *p != '.' && *p != '-' ) {
                    BuildError(
                              "%s: ignoring bad subdirectory: %s\r\n",
                              DirDB->Name,
                              dirbuf);
                    p = NULL;
                    break;
                }
            }
        }

        if (!(DirInclude & TargetMachines[0]->DirIncludeMask)) {
            continue;
        }

        if (p != NULL) {
            if (!Required) {
                for (i = 0; i < CountOptionalDirs; i++) {
                    if (!strcmp(dirbuf, OptionalDirs[i])) {
                        OptionalDirsUsed[i] = TRUE;
                        break;
                    }
                }
                if (i >= CountOptionalDirs) {
                    p = NULL;
                }
            } else {
                for (i = 0; i < CountExcludeDirs; i++) {
                    if (!strcmp(dirbuf, ExcludeDirs[i])) {
                        ExcludeDirsUsed[i] = TRUE;
                        p = NULL;
                        break;
                    }
                }
            }
        }
        if (p != NULL) {
            if ((fQuicky || fSemiQuicky) && (!fQuickZero)) {
                FileDB = InsertFileDB(
                                     DirDB,
                                     dirbuf,
                                     0,
                                     FILE_ATTRIBUTE_DIRECTORY,
                                     0);
                if (FileDB != NULL) {
                    FileDB->SubDirIndex = ++DirDB->CountSubDirs;
                }
            } else {
                FileDBNext = &DirDB->Files;
                while (FileDB = *FileDBNext) {
                    if (FileDB->FileFlags & FILEDB_DIR) {
                        if (!strcmp(dirbuf, FileDB->Name)) {
                            FileDB->SubDirIndex = ++DirDB->CountSubDirs;
                            break;
                        }
                    }
                    FileDBNext = &FileDB->Next;
                }
                if (FileDB == NULL) {
                    BuildError(
                              "%s found in %s, is not a subdirectory of %s\r\n",
                              dirbuf,
                              FormatPathName(DirDB->Name, *ppCurrentDirsFileName),
                              DirDB->Name);
                }
            }

        }
    }
}

VOID
StartElapsedTime(VOID)
{
    // we don't want to check for fElapsedTime since if we want XML file, we need it anyway 
    // and single GetTickCount() call is not a perf hit
    if (StartTime == 0) {
        StartTime = GetTickCount();
    }
}

VOID
StartDirectoryElapsedTime(VOID)
{
    DirectoryStartTime = GetTickCount();
}

VOID
PrintElapsedTime(VOID)
{
    DWORD ElapsedTime;
    DWORD ElapsedHours;
    DWORD ElapsedMinutes;
    DWORD ElapsedSeconds;
    DWORD ElapsedMilliseconds;

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    if (fPrintElapsed) {
        ElapsedTime = GetTickCount() - StartTime;
        ElapsedHours = ElapsedTime/(1000 * 60 * 60);
        ElapsedTime = ElapsedTime % (1000 * 60 * 60);
        ElapsedMinutes = ElapsedTime/(1000 * 60);
        ElapsedTime = ElapsedTime % (1000 * 60);
        ElapsedSeconds = ElapsedTime/1000;
        ElapsedMilliseconds = ElapsedTime % 1000;
        BuildColorMsg(
                     COLOR_STATUS,
                     "Elapsed time [%d:%02d:%02d.%03d]\r\n",
                     ElapsedHours,
                     ElapsedMinutes,
                     ElapsedSeconds,
                     ElapsedMilliseconds);
        LogMsg(
              "Elapsed time [%d:%02d:%02d.%03d]%s\r\n",
              ElapsedHours,
              ElapsedMinutes,
              ElapsedSeconds,
              ElapsedMilliseconds,
              szAsterisks);
    }
}

LPSTR
FormatElapsedTime(DWORD dwStartTime)
{
    static char FormatElapsedTimeBuffer[16];

    DWORD ElapsedTime;
    DWORD ElapsedHours;
    DWORD ElapsedMinutes;
    DWORD ElapsedSeconds;
    DWORD ElapsedMilliseconds;

    ElapsedTime = GetTickCount() - dwStartTime;
    ElapsedHours = ElapsedTime/(1000 * 60 * 60);
    ElapsedTime = ElapsedTime % (1000 * 60 * 60);
    ElapsedMinutes = ElapsedTime/(1000 * 60);
    ElapsedTime = ElapsedTime % (1000 * 60);
    ElapsedSeconds = ElapsedTime/1000;
    ElapsedMilliseconds = ElapsedTime % 1000;

    sprintf(
           FormatElapsedTimeBuffer, 
           "%d:%02d:%02d.%03d",
           ElapsedHours,
           ElapsedMinutes,
           ElapsedSeconds,
           ElapsedMilliseconds);

    return ( FormatElapsedTimeBuffer );
}

LPSTR
FormatCurrentDateTime()
{
    static char FormatCurrentDateTimeBuffer[18];
    SYSTEMTIME st;

    GetLocalTime(&st);
    sprintf(
           FormatCurrentDateTimeBuffer,
           "%04d%02d%02d%02d%02d%02d%03d",
           st.wYear, st.wMonth, st.wDay, 
           st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
    return ( FormatCurrentDateTimeBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\makefile.inc ===
build.c : $(SDK_INC_PATH)\ntverp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\buildnum\buildnum.c ===
#define UNICODE 1
#include <windows.h>
#include <lm.h>
#include <stdio.h>
#include <string.h>

#define BUILD_NUMBER_KEY L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION"
#define BUILD_NUMBER_BUFFER_LENGTH 80
#define BUILD_LAB_BUFFER_LENGTH 80

DWORD GetBuildNumber(LPWSTR Server, LPWSTR BuildNumber, LPWSTR BuildLab);

int __cdecl
main(
    int argc,
    char ** argv
    )
{
    DWORD error;
    DWORD cb;
    WCHAR server[MAX_COMPUTERNAME_LENGTH + 3];
    WCHAR buildNumber[BUILD_NUMBER_BUFFER_LENGTH];
    WCHAR buildLab[BUILD_LAB_BUFFER_LENGTH];
    BOOLEAN bBrief = FALSE;

    //
    // All server names start with \\.
    //

    server[0] = L'\\';
    server[1] = L'\\';

    //
    // Get the build number for each server requested.
    //

    argc--;
    argv++;

    if (argc > 0) {
        if ( (*argv[0]=='-' || *argv[0]=='/') &&  (argv[0][1]=='b' || argv[0][1]=='B') ) {
            bBrief=TRUE;
            argc--;
            argv++;
        }
    }

    //
    // Get the build number of the local machine
    //

    if (argc == 0 ) {
        cb = MAX_COMPUTERNAME_LENGTH + 1;
        if ( !GetComputerName( &server[2], &cb ) ) {
            wcscpy( &server[2], L"Local Machine" );
        }

        error = GetBuildNumber( NULL, buildNumber, buildLab );
        if ( error != ERROR_SUCCESS ) {

            printf( "Error %d querying build number for %ws\n", error, server);

        } else if (bBrief) {
            printf( "%ws", buildNumber );
        } else {
            if (buildLab[0])
                printf( "%ws is running build %ws (%ws)\n", server, buildNumber, buildLab );
            else 
                printf( "%ws is running build %ws\n", server, buildNumber );
        }

    } else {

    while ( argc ) {
        CHAR *p = *argv;

        if ( !_stricmp( p, "/?" ) || !_stricmp( p, "-?" ) ) {
            puts( "Usage: BUILDNUM [-b] [ServerName [servername]...]\n"
                  "   If no servername, then local machine is assumed.\n"
                  "   -b prints only the build number digits (must be 1st arg if used).\n" );
            return 0;
        }

        if ( !strncmp( "\\\\", p, 2 ) ) {
            p += 2;
        }

        if ( strlen( p ) > MAX_COMPUTERNAME_LENGTH ) {

            printf( "Computer name \\\\%s is too long\n", *argv );

        } else {

            WCHAR *q = &server[2];

            while ( *p ) {
                *q++ = *p++;
            }
            *q = 0;

            error = GetBuildNumber( server, buildNumber, buildLab );
            if ( error != ERROR_SUCCESS ) {

                printf( "Error %d querying build number for %ws\n", error, server );

            } else if (bBrief) {
                printf( "%ws", buildNumber );
            } else {
                if (buildLab[0])
                    printf( "%ws is running build %ws (%ws)\n", server, buildNumber, buildLab );
                else 
                    printf( "%ws is running build %ws\n", server, buildNumber );
            }
        }

        argc--;
        argv++;

    }
    }
    return 0;

} // main

DWORD
GetBuildNumber(
    LPWSTR Server,
    LPWSTR BuildNumber,
    LPWSTR BuildLab
    )
{
    DWORD error;
    HKEY key;
    HKEY keyBuildNumber;
    DWORD buildNumberLength;
    DWORD keyType;

    if ( Server == NULL ) {
        key = HKEY_LOCAL_MACHINE;
    }

    error = RegConnectRegistry( Server, HKEY_LOCAL_MACHINE, &key );
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = RegOpenKeyEx( key, BUILD_NUMBER_KEY, 0, KEY_READ, &keyBuildNumber );
    if ( error != ERROR_SUCCESS) {
        return error;
    }

    buildNumberLength = BUILD_NUMBER_BUFFER_LENGTH * sizeof(WCHAR);
    error = RegQueryValueEx(
                keyBuildNumber,
                L"CurrentBuildNumber",
                NULL,
                &keyType,
                (LPBYTE)BuildNumber,
                &buildNumberLength
                );
    if ( error != ERROR_SUCCESS ) {
        error = RegQueryValueEx(
                    keyBuildNumber,
                    L"CurrentBuild",
                    NULL,
                    &keyType,
                    (LPBYTE)BuildNumber,
                    &buildNumberLength
                    );
    }

    buildNumberLength = BUILD_LAB_BUFFER_LENGTH * sizeof(WCHAR);
    if (RegQueryValueEx(
                keyBuildNumber,
                L"BuildLab",
                NULL,
                &keyType,
                (LPBYTE)BuildLab,
                &buildNumberLength
                ) != ERROR_SUCCESS )
    {
        *BuildLab = 0;
    }

    RegCloseKey( keyBuildNumber );
    RegCloseKey( key );

    return error;

} // GetBuildNumber
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\buildutl.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994
//
//  File:       buildutl.c
//
//  Contents:   Utility functions for Build.exe
//
//  History:    16-May-89     SteveWo  Created
//                 ... See SLM log
//              26-Jul-94     LyleC    Cleanup/Add pass0 support
//              05-Dec-00     sbonev   See SD changelist 2317
//
//----------------------------------------------------------------------------

#include "build.h"

#if DBG
//+---------------------------------------------------------------------------
//
//  Memory Allocation/Deallocation functions
//
//  These functions provide leak tracking on a debug build.
//
//----------------------------------------------------------------------------

typedef struct _MEMHEADER {
    MemType mt;
    ULONG cbRequest;
    struct _MEMHEADER *pmhPrev;
    struct _MEMHEADER *pmhNext;
} MEMHEADER;

    #define CBHEADER        sizeof(MEMHEADER)
    #define CBTAIL          sizeof(ULONG)

char patternFree[CBTAIL] = { 'M', 'E', 'M', 'D'};
char patternBusy[CBTAIL] = { 'm', 'e', 'm', 'd'};

__inline MEMHEADER *
GetHeader(VOID *pvblock)
{
    return ((MEMHEADER *) (pvblock) - 1);
}

__inline VOID *
GetBlock(MEMHEADER *pmh)
{
    return ((VOID *) (pmh + 1));
}

__inline VOID
FillTailBusy(LPSTR p)
{
    memcpy(p, patternBusy, sizeof(patternBusy));
}

__inline VOID
FillTailFree(LPSTR p)
{
    memcpy(p, patternFree, sizeof(patternFree));
}

__inline BOOL
CheckTail(LPSTR p)
{
    return (memcmp(p, patternBusy, sizeof(patternBusy)) == 0);
}


typedef struct _MEMTAB {
    LPSTR pszType;
    ULONG cbAlloc;
    ULONG cAlloc;
    ULONG cbAllocTotal;
    ULONG cAllocTotal;
    MEMHEADER mh;
} MEMTAB;

ULONG cbAllocMax;
ULONG cAllocMax;

MEMTAB MemTab[] = {
    { "Totals",},              // MT_TOTALS
    { "Unknown",},             // MT_UNKNOWN

    { "ChildData",},           // MT_CHILDDATA
    { "CmdString",},           // MT_CMDSTRING
    { "DirDB",},               // MT_DIRDB
    { "DirSup",},              // MT_DIRSUP
    { "DirPath",},             // MT_DIRPATH
    { "DirString",},           // MT_DIRSTRING
    { "EventHandles",},        // MT_EVENTHANDLES
    { "FileDB",},              // MT_FILEDB
    { "FileReadBuf",},         // MT_FILEREADBUF
    { "FrbString",},           // MT_FRBSTRING
    { "IncludeDB",},           // MT_INCLUDEDB
    { "IoBuffer",},            // MT_IOBUFFER
    { "Macro",},               // MT_MACRO
    { "SourceDB",},            // MT_SOURCEDB
    { "Target",},              // MT_TARGET
    { "ThreadFilter",},        // MT_THREADFILTER
    { "ThreadHandles",},       // MT_THREADHANDLES
    { "ThreadState",},         // MT_THREADSTATE
    { "Dependency",},          // MT_DEPENDENCY
    { "DependencyWait",},      // MT_DEPENDENCY_WAIT
    { "XMLThreadState",},      // MT_XMLTHREADSTATE
    { "PXMLThreadState",},     // MT_PXMLTHREADSTATE
};
    #define MT_MAX  (sizeof(MemTab)/sizeof(MemTab[0]))


VOID
InitMem(VOID)
{
    MEMTAB *pmt;
    for (pmt = MemTab; pmt < &MemTab[MT_MAX]; pmt++) {
        assert(pmt->cAllocTotal == 0);
        pmt->mh.mt = MT_INVALID;
        pmt->mh.pmhNext = &pmt->mh;
        pmt->mh.pmhPrev = &pmt->mh;
    }
}


#else

    #define CBHEADER        0
    #define CBTAIL          0

#endif


//+---------------------------------------------------------------------------
//
//  Function:   AllocMem
//
//  Synopsis:   Allocate memory
//
//  Arguments:  [cb]  -- Requested Size
//              [ppv] -- [out] allocated memory
//              [mt]  -- Type of memory being allocated (MT_XXX)
//
//----------------------------------------------------------------------------

VOID
AllocMem(size_t cb, VOID **ppv, MemType mt)
{
    *ppv = malloc(cb + CBHEADER + CBTAIL);
    if (*ppv == NULL) {
        BuildError("(Fatal Error) malloc(%u) failed\r\n", cb);
        exit(16);
    }
#if DBG
    {
        MEMTAB *pmt;
        MEMHEADER *pmh;

        pmh = *ppv;
        *ppv = GetBlock(pmh);

        if (mt >= MT_MAX) {
            mt = MT_UNKNOWN;
        }
        pmt = &MemTab[MT_TOTALS];
        if (pmt->cAllocTotal == 0) {
            InitMem();
        }
        pmt->cAlloc++;
        pmt->cAllocTotal++;
        pmt->cbAlloc += cb;
        pmt->cbAllocTotal += cb;
        if (cbAllocMax < pmt->cbAlloc) {
            cbAllocMax = pmt->cbAlloc;
        }
        if (cAllocMax < pmt->cAlloc) {
            cAllocMax = pmt->cAlloc;
        }

        pmt = &MemTab[mt];
        pmt->cAlloc++;
        pmt->cAllocTotal++;
        pmt->cbAlloc += cb;
        pmt->cbAllocTotal += cb;

        pmh->mt = mt;
        pmh->cbRequest = cb;

        pmh->pmhNext = pmt->mh.pmhNext;
        pmt->mh.pmhNext = pmh;
        pmh->pmhPrev = pmh->pmhNext->pmhPrev;
        pmh->pmhNext->pmhPrev = pmh;

        FillTailBusy((char *) *ppv + cb);

        if (DEBUG_4 && DEBUG_1) {
            BuildError("AllocMem(%d, mt=%s) -> %lx\r\n", cb, pmt->pszType, *ppv);
        }
    }
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   FreeMem
//
//  Synopsis:   Free memory allocated by AllocMem
//
//  Arguments:  [ppv] -- Memory pointer
//              [mt]  -- Type of memory (MT_XXX)
//
//  Notes:      Sets the memory pointer to null after freeing it.
//
//----------------------------------------------------------------------------

VOID
FreeMem(VOID **ppv, MemType mt)
{
    assert(*ppv != NULL);
#if DBG
    {
        MEMTAB *pmt;
        MEMHEADER *pmh;

        pmh = GetHeader(*ppv);
        if (mt == MT_DIRDB ||
            mt == MT_FILEDB ||
            mt == MT_INCLUDEDB ||
            mt == MT_SOURCEDB) {

            SigCheck(assert(((DIRREC *) (*ppv))->Sig == 0));
        }
        if (mt >= MT_MAX) {
            mt = MT_UNKNOWN;
        }
        pmt = &MemTab[MT_TOTALS];
        pmt->cAlloc--;
        pmt->cbAlloc -= pmh->cbRequest;
        pmt = &MemTab[mt];
        pmt->cAlloc--;
        pmt->cbAlloc -= pmh->cbRequest;

        if (DEBUG_4 && DEBUG_1) {
            BuildError(
                      "FreeMem(%d, mt=%s) <- %lx\r\n",
                      pmh->cbRequest,
                      pmt->pszType,
                      *ppv);
        }
        assert(CheckTail((char *) *ppv + pmh->cbRequest));
        FillTailFree((char *) *ppv + pmh->cbRequest);
        assert(mt == pmh->mt);

        pmh->pmhNext->pmhPrev = pmh->pmhPrev;
        pmh->pmhPrev->pmhNext = pmh->pmhNext;
        pmh->pmhNext = pmh->pmhPrev = NULL;

        pmh->mt = MT_INVALID;
        *ppv = pmh;
    }
#endif
    free(*ppv);
    *ppv = NULL;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReportMemoryUsage
//
//  Synopsis:   Report current memory usage (if any) on a debug build.  If
//              called just before termination, memory leaks will be
//              displayed.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
ReportMemoryUsage(VOID)
{
#if DBG
    MEMTAB *pmt;
    UINT i;

    if (DEBUG_1) {
        BuildErrorRaw(
                     "Maximum memory usage: %5lx bytes in %4lx blocks\r\n",
                     cbAllocMax,
                     cAllocMax);
        for (pmt = MemTab; pmt < &MemTab[MT_MAX]; pmt++) {
            BuildErrorRaw(
                         "%5lx bytes in %4lx blocks, %5lx bytes in %4lx blocks Total (%s)\r\n",
                         pmt->cbAlloc,
                         pmt->cAlloc,
                         pmt->cbAllocTotal,
                         pmt->cAllocTotal,
                         pmt->pszType);
        }
    }
    FreeMem(&BigBuf, MT_IOBUFFER);
    if (fDebug & 8) {
        PrintAllDirs();
    }
    FreeAllDirs();
    if (DEBUG_1 || MemTab[MT_TOTALS].cbAlloc != 0) {
        BuildErrorRaw(szNewLine);
        if (MemTab[MT_TOTALS].cbAlloc != 0) {
            BuildError("Internal memory leaks detected:\r\n");
        }
        for (pmt = MemTab; pmt < &MemTab[MT_MAX]; pmt++) {
            BuildErrorRaw(
                         "%5lx bytes in %4lx blocks, %5lx bytes in %4lx blocks Total (%s)\r\n",
                         pmt->cbAlloc,
                         pmt->cAlloc,
                         pmt->cbAllocTotal,
                         pmt->cAllocTotal,
                         pmt->pszType);
        }
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   MyOpenFile
//
//  Synopsis:   Open a file
//
//----------------------------------------------------------------------------

BOOL
MyOpenFile(
          LPSTR DirName,
          LPSTR FileName,
          LPSTR Access,
          FILE **ppf,
          BOOL BufferedIO)
{
    char path[ DB_MAX_PATH_LENGTH * 2 + 1] = {0}; // ensure we have enough space for "DirName" + "\\" + "FileName"

    if (DirName == NULL || DirName[0] == '\0') {
        strncpy( path, FileName, sizeof(path) - 1 );
    } else {
        _snprintf( path, sizeof(path) - 1, "%s\\%s", DirName, FileName );
    }

    *ppf = fopen( path, Access );
    if (*ppf == NULL) {
        if (*Access == 'w') {
            BuildError("%s: create file failed\r\n", path);
        }
        return (FALSE);
    }
    if (!BufferedIO) {
        setvbuf(*ppf, NULL, _IONBF, 0);      // Clear buffering on the stream.
    }
    return (TRUE);
}


typedef struct _FILEREADBUF {
    struct _FILEREADBUF *pfrbNext;
    LPSTR pszFile;
    LPSTR pbBuffer;
    LPSTR pbNext;
    size_t cbBuf;
    size_t cbBuffer;
    size_t cbTotal;
    size_t cbFile;
    USHORT cLine;
    USHORT cNull;
    ULONG DateTime;
    FILE *pf;
    LPSTR pszCommentToEOL;
    size_t cbCommentToEOL;
    BOOLEAN fEof;
    BOOLEAN fOpen;
    BOOLEAN fMakefile;
} FILEREADBUF;

static FILEREADBUF Frb;
char achzeros[16];


//+---------------------------------------------------------------------------
//
//  Function:   OpenFilePush
//
//----------------------------------------------------------------------------

BOOL
OpenFilePush(
            LPSTR pszdir,
            LPSTR pszfile,
            LPSTR pszCommentToEOL,
            FILE **ppf
            )
{
    FILEREADBUF *pfrb;

    if (Frb.fOpen) {
        AllocMem(sizeof(*pfrb), &pfrb, MT_FILEREADBUF);
        memcpy(pfrb, &Frb, sizeof(*pfrb));
        memset(&Frb, 0, sizeof(Frb));
        Frb.pfrbNext = pfrb;
    } else {
        pfrb = NULL;
    }

    if (!SetupReadFile(
                      pszdir,
                      pszfile,
                      pszCommentToEOL,
                      ppf)) {

        if (pfrb != NULL) {
            memcpy(&Frb, pfrb, sizeof(*pfrb));
            FreeMem(&pfrb, MT_FILEREADBUF);
        }

        return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadFilePush
//
//----------------------------------------------------------------------------

LPSTR
ReadFilePush(LPSTR pszfile)
{
    FILE *pf;

    assert(Frb.fOpen);
    OpenFilePush(IsFullPath(pszfile) ? "" : Frb.pszFile, pszfile,
                 Frb.pszCommentToEOL, &pf);
    return (ReadLine(Frb.pf));
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadFilePop
//
//----------------------------------------------------------------------------

LPSTR
ReadFilePop(VOID)
{
    if (Frb.pfrbNext == NULL) {
        return (NULL);
    }
    CloseReadFile(NULL);
    return (ReadLine(Frb.pf));
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadBuf
//
//----------------------------------------------------------------------------

BOOL
ReadBuf(FILE *pf)
{
    LPSTR p, p2;

    assert(pf == Frb.pf);
    assert(!Frb.fEof);
    Frb.pbNext = Frb.pbBuffer;
    Frb.cbBuf = fread(Frb.pbBuffer, 1, Frb.cbBuffer - 1, Frb.pf);
    if (Frb.cbTotal == 0 &&
        Frb.cbBuf > sizeof(achzeros) &&
        memcmp(Frb.pbBuffer, achzeros, sizeof(achzeros)) == 0) {

        BuildError("ignoring binary file\r\n");
        Frb.fEof = TRUE;
        return (FALSE);
    }
    p = &Frb.pbBuffer[Frb.cbBuf - 1];
    if (Frb.cbTotal + Frb.cbBuf < Frb.cbFile) {
        do {
            while (p > Frb.pbBuffer && *p != '\n') {
                p--;
            }
            p2 = p;             // save end of last complete line
            if (p > Frb.pbBuffer && *p == '\n') {
                p--;
                if (p > Frb.pbBuffer && *p == '\r') {
                    p--;
                }
                while (p > Frb.pbBuffer && (*p == '\t' || *p == ' ')) {
                    p--;
                }
            }
        } while (*p == '\\');
        if (p == Frb.pbBuffer) {
            BuildError("(Fatal Error) too many continuation lines\r\n");
            exit(8);
        }
        p = p2;                 // restore end of last complete line
        Frb.cbBuf = p - Frb.pbBuffer + 1;
    } else {
        Frb.fEof = TRUE;        // no more to read
    }
    p[1] = '\0';
    Frb.cbTotal += Frb.cbBuf;

    return (TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsNmakeInclude
//
//----------------------------------------------------------------------------

LPSTR
IsNmakeInclude(LPSTR pinc)
{
    static char szInclude[] = "include";
    LPSTR pnew, p;

    while (*pinc == ' ') {
        pinc++;
    }
    if (_strnicmp(pinc, szInclude, sizeof(szInclude) - 1) == 0 &&
        pinc[sizeof(szInclude) - 1] == ' ') {

        pnew = NULL;
        pinc += sizeof(szInclude);
        while (*pinc == ' ') {
            pinc++;
        }

        if (MakeMacroString(&pnew, pinc)) {
            p = strchr(pnew, ' ');
            if (p != NULL) {
                *p = '\0';
            }
            return (pnew);
        }
    }
    return (NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadLine
//
//  Synopsis:   Read a line from the input file.
//
//  Arguments:  [pf] -- File to read from
//
//  Returns:    Line read from file
//
//  Notes:      ReadLine returns a canonical line from the input file.
//              This involves:
//
//              1)  Converting tab to spaces.  Various editors/users change
//                      tabbing.
//              2)  Uniformly terminate lines.  Some editors drop CR in
//                      CRLF or add extras.
//              3)  Handle file-type-specific continuations.
//
//----------------------------------------------------------------------------

LPSTR
ReadLine(FILE *pf)
{
    LPSTR p, pend, pline;
    LPSTR pcont;
    LPSTR pcomment;
    UCHAR chComment0 = Frb.pszCommentToEOL[0];
    BOOL fInComment, fWhiteSpace;

    assert(pf == Frb.pf || (pf != NULL && Frb.pfrbNext != NULL));
    if (Frb.cbBuf == 0) {
        if (Frb.fEof) {
            return (ReadFilePop());
        }
        if (fseek(Frb.pf, Frb.cbTotal, SEEK_SET) == -1) {
            return (ReadFilePop());
        }
        if (!ReadBuf(Frb.pf)) {
            return (ReadFilePop());
        }
    }
    pline = p = Frb.pbNext;
    pend = &p[Frb.cbBuf];
    pcont = NULL;
    pcomment = NULL;

    //  scan through line forward

    fInComment = FALSE;
    while (p < pend) {
        switch (*p) {

            case ' ':
            case '\t':
            case '\r':
                *p = ' ';
                break;

            case '\\':
                pcont = p;          // remember continuation character
                break;

            case '\n':                      //  Are we at an end of line?
            case '\0':
                if (*p == '\n') {
                    Frb.cLine++;
                }

                if (fInComment) {
                    memset(pcomment, ' ', p-pcomment-1);        
                    fInComment = FALSE;
                }

                if (pcont == NULL) {
                    goto eol;               // bail out if single line
                }                           // else combine multiple lines...

                *pcont = ' ';               // remove continuation char
                pcont = NULL;               // eat only one line per continuation

                *p = ' ';                   // join the lines with blanks
                break;

            default:

                //  See if the character we're examining begins the
                //  comment-to-EOL string.

                if (*p == chComment0 &&
                    !strncmp(p, Frb.pszCommentToEOL, Frb.cbCommentToEOL) &&
                    !fInComment) {
                    fInComment = TRUE;
                    pcomment = p;
                }
                pcont = NULL;               // not a continuation character
                break;
        }
        p++;
    }

    eol:
    assert(Frb.cbBuf >= p - Frb.pbNext);
    Frb.cbBuf -= p - Frb.pbNext;
    Frb.pbNext = p;

    if (pcont != NULL) {
        *pcont = ' ';                   // file ended with backslash...
    }
    assert(*p == '\0' || *p == '\n');
    if (p < pend) {
        if (*p == '\0') {
            if (Frb.cNull++ == 0) {
                BuildError("null byte at offset %lx\r\n",
                           Frb.cbTotal - Frb.cbBuf + p - Frb.pbNext);
            }
        }
        *p = '\0';                      // terminate line
        assert(Frb.cbBuf >= 1);
        Frb.cbBuf--;                    // account for newline (or null)
        Frb.pbNext++;
    } else {
        assert(p == pend && *p == '\0');
        if (*pline == 'Z' - 64 && p == &pline[1] && Frb.cbBuf == 0) {
            pline = NULL;                       // found CTL-Z at end of file
        } else {
//            BuildError( "last line incomplete\r\n");
        }
    }
    fWhiteSpace = FALSE;
    if (pline != NULL) {
        while (*pline == ' ') {
            pline++;                    // skip leading whitespace
            fWhiteSpace = TRUE;
        }
        if (*p != '\0') {
            BuildError( "\"*p != '\\0'\" at offset %lx\r\n",
                        Frb.cbTotal - Frb.cbBuf + p - Frb.pbNext);
            BuildError(
                      "pline=%x(%s) p=%x(%s)\r\n",
                      pline,
                      pline,
                      p,
                      p,
                      Frb.cbTotal - Frb.cbBuf + p - Frb.pbNext);
        }
        assert(*p == '\0');
        while (p > pline && *--p == ' ') {
            *p = '\0';                  // truncate trailing whitespace
        }
    }
    if (pline == NULL) {
        return (ReadFilePop());
    }
    if (Frb.fMakefile && !fWhiteSpace && *pline == '!') {
        p = IsNmakeInclude(pline + 1);
        if (p != NULL) {
            if (Frb.fMakefile && DEBUG_4) {
                BuildError("!include(%s)\r\n", p);
            }
            pline = ReadFilePush(p);
            FreeMem(&p, MT_DIRSTRING);
        }
    }
    return (pline);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetupReadFile
//
//  Synopsis:   Open a file and prepare to read from it.
//
//  Arguments:  [pszdir]          -- Directory name
//              [pszfile]         -- Filename
//              [pszCommentToEOL] -- Comment to EOL string
//              [ppf]             -- [out] Open file handle
//
//  Returns:    TRUE if opened successfully
//
//  Notes:      This function, in order to minimize disk hits, reads the
//              entire file into a buffer, which is then used by the ReadLine
//              function.
//
//----------------------------------------------------------------------------

BOOL
SetupReadFile(
             LPSTR pszdir,
             LPSTR pszfile,
             LPSTR pszCommentToEOL,
             FILE **ppf
             )
{
    char path[DB_MAX_PATH_LENGTH] = {0};

    assert(!Frb.fOpen);
    assert(Frb.pf == NULL);
    assert(Frb.pszFile == NULL);
    Frb.fMakefile = strcmp(pszCommentToEOL, "#") == 0;
    Frb.DateTime = 0;

    if (strlen(pszdir) > sizeof(path)-1) {
        BuildError("Path: %s too long - rebuild build.exe with longer DB_MAX_PATH_LENGTH\n", pszdir);
    }
    strncpy(path, pszdir, sizeof(path));
    if (Frb.pfrbNext != NULL) {         // if a nested open
        LPSTR p;

        if (Frb.fMakefile && !IsFullPath(pszfile)) {

            // nmake handles relative includes in makefiles by
            // attempting to locate the file relative to each makefile
            // in the complete include chain.

            FILEREADBUF *pfrb;

            for (pfrb = Frb.pfrbNext; pfrb != NULL; pfrb = pfrb->pfrbNext) {
                assert(pfrb->pszFile != NULL);

                strcpy(path, pfrb->pszFile);
                p = strrchr(path, '\\');
                if (p != NULL) {
                    *p = '\0';
                }

                if (ProbeFile(path, pszfile) != -1) {
                    break;
                }
            }

            if (pfrb == NULL) {
                // Unable to find file anywhere along path.
                return FALSE;
            }
        } else {
            p = strrchr(path, '\\');
            if (p != NULL) {
                *p = '\0';
            }
        }
    }

    if (!MyOpenFile(path, pszfile, "rb", ppf, TRUE)) {
        *ppf = NULL;
        return (FALSE);
    }
    if (Frb.fMakefile) {
        Frb.DateTime = (*pDateTimeFile)(path, pszfile);
    }
    Frb.cLine = 0;
    Frb.cNull = 0;
    Frb.cbTotal = 0;
    Frb.pf = *ppf;
    Frb.fEof = FALSE;
    Frb.pszCommentToEOL = pszCommentToEOL;
    Frb.cbCommentToEOL = strlen(pszCommentToEOL);

    if (fseek(Frb.pf, 0L, SEEK_END) != -1) {
        Frb.cbFile = ftell(Frb.pf);
        if (fseek(Frb.pf, 0L, SEEK_SET) == -1) {
            Frb.cbFile = 0;
        }
    } else {
        Frb.cbFile = 0;
    }

    Frb.cbBuffer = BigBufSize;
    if (Frb.pfrbNext != NULL) {
        if (Frb.cbBuffer > Frb.cbFile + 1) {
            Frb.cbBuffer = Frb.cbFile + 1;
        }
        AllocMem(Frb.cbBuffer, &Frb.pbBuffer, MT_IOBUFFER);
    } else {
        Frb.pbBuffer = BigBuf;
    }
    if (!ReadBuf(Frb.pf)) {
        fclose(Frb.pf);
        Frb.pf = *ppf = NULL;
        if (Frb.pfrbNext != NULL) {
            FreeMem(&Frb.pbBuffer, MT_IOBUFFER);
        }
        return (FALSE);          // zero byte file
    }
    if (path[0] != '\0') {
        strcat(path, "\\");
    }
    strcat(path, pszfile);
    MakeString(&Frb.pszFile, path, TRUE, MT_FRBSTRING);
    Frb.fOpen = TRUE;
    if (Frb.fMakefile && DEBUG_4) {
        BuildError(
                  "Opening file: cbFile=%Iu cbBuf=%lu\r\n",
                  Frb.cbTotal,
                  Frb.cbBuffer);
    }
    return (TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   CloseReadFile
//
//  Synopsis:   Close the open file buffer.
//
//  Arguments:  [pcline] -- [out] Count of lines in file.
//
//  Returns:    Timestamp of file
//
//----------------------------------------------------------------------------

ULONG
CloseReadFile(
             UINT *pcline
             )
{
    assert(Frb.fOpen);
    assert(Frb.pf != NULL);
    assert(Frb.pszFile != NULL);

    if (Frb.fMakefile && DEBUG_4) {
        BuildError("Closing file\r\n");
    }
    if (Frb.cNull > 1) {
        BuildError("%hu null bytes in file\r\n", Frb.cNull);
    }
    fclose(Frb.pf);
    Frb.fOpen = FALSE;
    Frb.pf = NULL;
    FreeString(&Frb.pszFile, MT_FRBSTRING);
    if (Frb.pfrbNext != NULL) {
        FILEREADBUF *pfrb;

        FreeMem(&Frb.pbBuffer, MT_IOBUFFER);
        pfrb = Frb.pfrbNext;
        if (pfrb->DateTime < Frb.DateTime) {
            pfrb->DateTime = Frb.DateTime;  // propagate subordinate timestamp
        }
        memcpy(&Frb, pfrb, sizeof(*pfrb));
        FreeMem(&pfrb, MT_FILEREADBUF);
    }
    if (pcline != NULL) {
        *pcline = Frb.cLine;
    }
    return (Frb.DateTime);
}


//+---------------------------------------------------------------------------
//
//  Function:   ProbeFile
//
//  Synopsis:   Determine if a file exists
//
//----------------------------------------------------------------------------

UINT
ProbeFile(
         LPSTR DirName,
         LPSTR FileName
         )
{
    char path[ DB_MAX_PATH_LENGTH ];

    if (DirName != NULL) {
        sprintf(path, "%s\\%s", DirName, FileName);
        FileName = path;
    }
    return (GetFileAttributes(FileName));
}

//+---------------------------------------------------------------------------
//
//  Function:   EnsureDirectoriesExist
//
//  Synopsis:   Ensures the given directory exists. If the path contains
//              an asterisk, it will be expanded into all current machine
//              target names.
//
//  Arguments:  [DirName] -- Name of directory to create if necessary
//
//  Returns:    FALSE if the directory could not be created, TRUE if it
//              already exists or it could be created.
//
//----------------------------------------------------------------------------

BOOL
EnsureDirectoriesExist(
                      LPSTR DirName
                      )
{
    char path[ DB_MAX_PATH_LENGTH ];
    char *p;
    UINT i;

    if (!DirName || DirName[0] == '\0')
        return FALSE;

    for (i = 0; i < CountTargetMachines; i++) {

        // Replace '*' with appropriate name

        ExpandObjAsterisk(
                         path,
                         DirName,
                         TargetMachines[i]->ObjectDirectory);

        if (ProbeFile(NULL, path) != -1) {
            continue;
        }
        p = path;
        while (TRUE) {
            p = strchr(p, '\\');
            if (p != NULL) {
                *p = '\0';
            }
            if (!CreateBuildDirectory(path)) {
                return FALSE;
            }
            if (p == NULL) {
                break;
            }
            *p++ = '\\';
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DateTimeFile
//
//  Synopsis:   Get the timestamp on a file
//
//----------------------------------------------------------------------------

ULONG
DateTimeFile(
            LPSTR DirName,
            LPSTR FileName
            )
{
    char path[ DB_MAX_PATH_LENGTH ];
    WIN32_FIND_DATA FindFileData;
    HDIR FindHandle;
    ULONG FileDateTime;

    if (DirName == NULL || DirName[0] == '\0') {
        FindHandle = FindFirstFile( FileName, &FindFileData );
    } else {
        _snprintf( path, sizeof(path)-1, "%s\\%s", DirName, FileName );
        FindHandle = FindFirstFile( path, &FindFileData );
    }

    if (FindHandle == (HDIR)INVALID_HANDLE_VALUE) {
        return ( 0L );
    } else {
        FindClose( FindHandle );
        FileDateTime = 0L;
        FileTimeToDosDateTime( &FindFileData.ftLastWriteTime,
                               ((LPWORD)&FileDateTime)+1,
                               (LPWORD)&FileDateTime
                             );

        return ( FileDateTime );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DateTimeFile2
//
//  Synopsis:   Get the timestamp on a file using the new GetFileAttributesExA
//
//----------------------------------------------------------------------------

ULONG
DateTimeFile2(
             LPSTR DirName,
             LPSTR FileName
             )
{
    char path[ DB_MAX_PATH_LENGTH ] = {0};
    WIN32_FILE_ATTRIBUTE_DATA FileData;
    ULONG FileDateTime;
    BOOL rc;

    if (DirName == NULL || DirName[0] == '\0') {
        strncpy( path, FileName, sizeof(path) - 1 );
    } else {
        _snprintf( path, sizeof(path)-1, "%s\\%s", DirName, FileName );
    }

    rc = (*pGetFileAttributesExA) (path, GetFileExInfoStandard, (LPVOID)&FileData);

    if (!rc) {
        return ( 0L );
    } else {
        FILETIME ftSystemTime;
        SYSTEMTIME stSystemTime;
        unsigned __int64 ui64Local, ui64File;
        GetSystemTime(&stSystemTime);
        SystemTimeToFileTime(&stSystemTime, &ftSystemTime);

        ui64Local = (((unsigned __int64) ftSystemTime.dwHighDateTime) << 32) +
                    (unsigned __int64) ftSystemTime.dwLowDateTime;

        ui64File = (((unsigned __int64) FileData.ftLastWriteTime.dwHighDateTime) << 32) +
                   (unsigned __int64) FileData.ftLastWriteTime.dwLowDateTime;

        // Take into account that file times may have two second intervals (0x989680 = 1 second)
        // for FAT drives.
        if (ui64File > (ui64Local + (0x989680*2))) {
            BuildError("ERROR - \"%s\" file time is in the future.\r\n", path);
        }

        FileDateTime = 0L;
        FileTimeToDosDateTime( &FileData.ftLastWriteTime,
                               ((LPWORD)&FileDateTime)+1,
                               (LPWORD)&FileDateTime
                             );
        return ( FileDateTime );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteSingleFile
//
//  Synopsis:   Delete the given file
//
//----------------------------------------------------------------------------

BOOL
DeleteSingleFile(
                LPSTR DirName,
                LPSTR FileName,
                BOOL QuietFlag
                )
{
    char path[ DB_MAX_PATH_LENGTH * 2 + 1]; // ensure we have enough space for "DirName" + "\\" + "FileName"

    if (DirName) {
        sprintf( path, "%s\\%s", DirName, FileName );
    } else {
        strcpy( path, FileName );
    }
    if (!QuietFlag && fQuery) {
        BuildMsgRaw("'erase %s'\r\n", path);
        return ( TRUE );
    }

    return ( DeleteFile( path ) );
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteMultipleFiles
//
//  Synopsis:   Delete one or more files matching a pattern.
//
//----------------------------------------------------------------------------

BOOL
DeleteMultipleFiles(
                   LPSTR DirName,
                   LPSTR FilePattern
                   )
{
    char path[ DB_MAX_PATH_LENGTH ];
    WIN32_FIND_DATA FindFileData;
    HDIR FindHandle;

    sprintf( path, "%s\\%s", DirName, FilePattern );

    if (fQuery) {
        BuildMsgRaw("'erase %s'\r\n", path);
        return ( TRUE );
    }

    FindHandle = FindFirstFile( path, &FindFileData );
    if (FindHandle == (HDIR)INVALID_HANDLE_VALUE) {
        return ( FALSE );
    }

    do {
        if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            DeleteSingleFile( DirName, FindFileData.cFileName, TRUE );
        }
    }
    while (FindNextFile( FindHandle, &FindFileData ));

    FindClose( FindHandle );
    return ( TRUE );
}


//+---------------------------------------------------------------------------
//
//  Function:   CloseOrDeleteFile
//
//----------------------------------------------------------------------------

BOOL
CloseOrDeleteFile(
                 FILE **ppf,
                 LPSTR DirName,
                 LPSTR FileName,
                 ULONG SizeThreshold
                 )
{
    ULONG Temp;

    if (*ppf == NULL) {
        return TRUE;
    }

    Temp = ftell( *ppf );
    fclose( *ppf );
    *ppf = NULL;
    if (Temp <= SizeThreshold) {
        return ( DeleteSingleFile( DirName, FileName, TRUE ) );
    } else {
        CreatedBuildFile(DirName, FileName);
        return ( TRUE );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   PushCurrentDirectory
//
//----------------------------------------------------------------------------

LPSTR
PushCurrentDirectory(
                    LPSTR NewCurrentDirectory
                    )
{
    LPSTR OldCurrentDirectory;
    char path[DB_MAX_PATH_LENGTH];

    GetCurrentDirectory(sizeof(path), path);
    AllocMem(strlen(path) + 1, &OldCurrentDirectory, MT_DIRPATH);
    strcpy(OldCurrentDirectory, path);
    SetCurrentDirectory(NewCurrentDirectory);
    return (OldCurrentDirectory);
}


//+---------------------------------------------------------------------------
//
//  Function:   PopCurrentDirectory
//
//----------------------------------------------------------------------------

VOID
PopCurrentDirectory(
                   LPSTR OldCurrentDirectory
                   )
{
    if (OldCurrentDirectory) {
        SetCurrentDirectory(OldCurrentDirectory);
        FreeMem(&OldCurrentDirectory, MT_DIRPATH);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CanonicalizePathName
//
//  Synopsis:   Take the given relative pathname and the current directory
//              and obtain the full absolute path of the file.
//
//  Arguments:  [SourcePath] -- Relative path
//              [Action]     -- Canonicalizing flags
//              [FullPath]   -- [out] Full path of file or directory
//
//  Returns:    TRUE if canonicalization succeeded.
//
//  Notes:      [Action] indicates whether the function will fail if the
//              resulting path is not of the correct type.  CANONICALIZE_ONLY
//              never fails, and CANON..._FILE or CANON..._DIR will fail if
//              the resulting path is not of the specified type.
//
//----------------------------------------------------------------------------

BOOL
CanonicalizePathName(
                    LPSTR SourcePath,
                    UINT Action,
                    LPSTR FullPath
                    )
{
    char   PathBuffer[DB_MAX_PATH_LENGTH] = {0},
    *FilePart;
    char *psz;
    DWORD  attr;

    if (!GetFullPathName(
                        SourcePath,
                        sizeof(PathBuffer),
                        PathBuffer,
                        &FilePart)) {
        BuildError(
                  "CanonicalizePathName: GetFullPathName(%s) failed - rc = %d.\r\n",
                  SourcePath,
                  GetLastError());
        return ( FALSE );
    }
    CopyString(FullPath, PathBuffer, TRUE);

    if (Action == CANONICALIZE_ONLY) {
        return ( TRUE );
    }

    if ((attr = GetFileAttributes( PathBuffer )) == -1) {
        UINT rc = GetLastError();

        if (DEBUG_1 ||
            (rc != ERROR_FILE_NOT_FOUND && rc != ERROR_PATH_NOT_FOUND)) {
            BuildError(
                      "CanonicalizePathName: GetFileAttributes(%s --> %s) failed - rc = %d.\r\n",
                      SourcePath,
                      PathBuffer,
                      rc);
        }
        return ( FALSE );
    }

    if (Action == CANONICALIZE_DIR) {
        if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
            return (TRUE);
        }
        psz = "directory";
    } else {
        if ((attr & FILE_ATTRIBUTE_DIRECTORY) == 0) {
            return (TRUE);
        }
        psz = "file";
    }
    BuildError(
              "CanonicalizePathName: %s --> %s is not a %s\r\n",
              SourcePath,
              PathBuffer,
              psz);
    return (FALSE);
}

static char FormatPathBuffer[ DB_MAX_PATH_LENGTH ];

//+---------------------------------------------------------------------------
//
//  Function:   FormatPathName
//
//  Synopsis:   Take a directory name and relative pathname and merges the
//              two into a correctly formatted path.  If the resulting path
//              has the current directory as a component, the current
//              directory part is removed.
//
//  Arguments:  [DirName]  -- Directory
//              [FileName] -- Pathname relative to [DirName]
//
//  Returns:    Resulting string (should not be freed).
//
//  Notes:      Example: DirName="f:\nt\private\foo\subdir1\subdir2"
//                       FileName="..\..\bar.c"
//                       CurrentDirectory="f:\nt\private"
//                       Result="foo\bar.c"
//
//----------------------------------------------------------------------------

LPSTR
FormatPathName(
              LPSTR DirName,
              LPSTR FileName
              )
{
    UINT cb;
    LPSTR p;

    CopyString(FormatPathBuffer, CurrentDirectory, TRUE);
    if (DirName && *DirName) {
        if (DirName[1] == ':') {
            p = FormatPathBuffer;
        } else
            if (DirName[0] == '\\') {
            p = FormatPathBuffer + 2;
        } else {
            p = FormatPathBuffer + strlen(FormatPathBuffer);
            *p++ = '\\';
        }
        CopyString(p, DirName, TRUE);
    }
    p = FormatPathBuffer + strlen(FormatPathBuffer);
    if (p[-1] != '\\') {
        *p++ = '\\';
        *p = '\0';
    }

    if (FileName[1] == ':') {
        p = FormatPathBuffer;
    } else
        if (FileName[0] == '\\') {
        p = FormatPathBuffer + 2;
    } else
        if (!strncmp(FileName, ".\\", 2)) {
        FileName += 2;
    } else
        if (!strncmp(FileName, "..\\", 3)) {
        do {
            p--;
            while (*--p != '\\') {
                if (p <= FormatPathBuffer) {
                    p = FormatPathBuffer;
                    break;
                }
            }
            p++;
            FileName += 3;

        }
        while (!strncmp(FileName, "..\\", 3) && (p != FormatPathBuffer));
    }
    CopyString(p, FileName, TRUE);

    cb = strlen(CurrentDirectory);
    p = FormatPathBuffer + cb;
    if (!fAlwaysPrintFullPath) {
        if (!_strnicmp(CurrentDirectory, FormatPathBuffer, cb) && *p == '\\') {
            return (p + 1);
        }
    }
    return (FormatPathBuffer);
}

//+---------------------------------------------------------------------------
//
//  Function:   AppendString
//
//----------------------------------------------------------------------------

LPSTR
AppendString(
            LPSTR Destination,
            LPSTR Source,
            BOOL PrefixWithSpace
            )
{
    if (Source != NULL) {
        while (*Destination) {
            Destination++;
        }
        if (PrefixWithSpace) {
            *Destination++ = ' ';
        }
        while (*Destination = *Source++) {
            Destination++;
        }
    }
    return (Destination);
}


#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   AssertPathString
//
//----------------------------------------------------------------------------

VOID
AssertPathString(LPSTR pszPath)
{
    LPSTR p = pszPath;

    while (*p != '\0') {
        if ((*p >= 'A' && *p <= 'Z') || *p == '/') {
            BuildError("Bad Path string: '%s'\r\n", pszPath);
            assert(FALSE);
        }
        p++;
    }
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   CopyString
//
//----------------------------------------------------------------------------

LPSTR
CopyString(
          LPSTR Destination,
          LPSTR Source,
          BOOL fPath)
{
    UCHAR ch;
    LPSTR Result;

    Result = Destination;
    while ((ch = *Source++) != '\0') {
        if (fPath) {
            if (ch >= 'A' && ch <= 'Z') {
                ch -= (UCHAR) ('A' - 'a');
            } else if (ch == '/') {
                ch = '\\';
            }
        }
        *Destination++ = ch;
    }
    *Destination = ch;
    return (Result);
}


//+---------------------------------------------------------------------------
//
//  Function:   MakeString
//
//----------------------------------------------------------------------------

VOID
MakeString(
          LPSTR *Destination,
          LPSTR Source,
          BOOL fPath,
          MemType mt
          )
{
    if (Source == NULL) {
        Source = "";
    }
    AllocMem(strlen(Source) + 1, Destination, mt);
    *Destination = CopyString(*Destination, Source, fPath);
}


//+---------------------------------------------------------------------------
//
//  Function:   MakeExpandedString
//
//----------------------------------------------------------------------------

VOID
MakeExpandedString(
                  LPSTR *Destination,
                  LPSTR Source
                  )
{
    AllocMem(strlen(Source) + strlen(NtRoot) + 1, Destination, MT_DIRSTRING);
    sprintf(*Destination, "%s%s", NtRoot, Source);
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeString
//
//----------------------------------------------------------------------------

VOID
FreeString(LPSTR *ppsz, MemType mt)
{
    if (*ppsz != NULL) {
        FreeMem(ppsz, mt);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatNumber
//
//----------------------------------------------------------------------------

LPSTR
FormatNumber(
            ULONG Number
            )
{
    USHORT i;
    LPSTR p;
    static char FormatNumberBuffer[16];

    p = FormatNumberBuffer + sizeof( FormatNumberBuffer ) - 1;
    *p = '\0';
    i = 0;
    do {
        if (i != 0 && (i % 3) == 0) {
            *--p = ',';
        }
        i++;
        *--p = (UCHAR) ((Number % 10) + '0');
        Number /= 10;
    } while (Number != 0);
    return ( p );
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatTime
//
//----------------------------------------------------------------------------

LPSTR
FormatTime(
          ULONG Seconds
          )
{
    ULONG Hours, Minutes;
    static char FormatTimeBuffer[16];

    Hours = Seconds / 3600;
    Seconds = Seconds % 3600;
    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    sprintf( FormatTimeBuffer,
             "%2ld:%02ld:%02ld",
             Hours,
             Minutes,
             Seconds
           );

    return ( FormatTimeBuffer );
}


//+---------------------------------------------------------------------------
//
//  Function:   AToX
//
//  Synopsis:   Hex atoi with pointer bumping and success flag
//
//  Arguments:  [pp]  -- String to convert
//              [pul] -- [out] Result
//
//  Returns:    TRUE if success
//
//----------------------------------------------------------------------------

BOOL
AToX(LPSTR *pp, ULONG *pul)
{
    LPSTR p = *pp;
    int digit;
    ULONG r;
    BOOL fRet = FALSE;

    while (*p == ' ') {
        p++;
    }
    for (r = 0; isxdigit(digit = *p); p++) {
        fRet = TRUE;
        if (isdigit(digit)) {
            digit -= '0';
        } else if (isupper(digit)) {
            digit -= 'A' - 10;
        } else {
            digit -= 'a' - 10;
        }
        r = (r << 4) + digit;
    }
    *pp = p;
    *pul = r;
    return (fRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   AToD
//
//  Synopsis:   Decimal atoi with pointer bumping and success flag
//
//  Arguments:  [pp]  -- String to convert
//              [pul] -- [out] Result
//
//  Returns:    TRUE if success
//
//----------------------------------------------------------------------------

BOOL
AToD(LPSTR *pp, ULONG *pul)
{
    LPSTR p = *pp;
    int digit;
    ULONG r;
    BOOL fRet = FALSE;

    while (*p == ' ') {
        p++;
    }
    for (r = 0; isdigit(digit = *p); p++) {
        fRet = TRUE;
        r = (r * 10) + digit - '0';
    }
    *pp = p;
    *pul = r;
    return (fRet);
}

//+---------------------------------------------------------------------------
//
//  Logging and Display Functions
//
//----------------------------------------------------------------------------

VOID
__cdecl
LogMsg(const char *pszfmt, ...)
{
    va_list va;

    if (LogFile != NULL) {
        va_start(va, pszfmt);
        vfprintf(LogFile, pszfmt, va);
        va_end(va);
    }
}


VOID
EnterMessageMode(VOID)
{
    EnterCriticalSection(&TTYCriticalSection);
    if (fConsoleInitialized &&
        (NewConsoleMode & ENABLE_WRAP_AT_EOL_OUTPUT) == 0) {

        SetConsoleMode(
                      GetStdHandle(STD_ERROR_HANDLE),
                      NewConsoleMode | ENABLE_WRAP_AT_EOL_OUTPUT);
    }
}


VOID
LeaveMessageMode(VOID)
{
    if (fConsoleInitialized &&
        (NewConsoleMode & ENABLE_WRAP_AT_EOL_OUTPUT) == 0) {

        SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), NewConsoleMode);
    }
    LeaveCriticalSection(&TTYCriticalSection);
}

void
__stdcall
WriteMsgStdErr(
              WORD wAttributes, 
              BOOL fBuildPrefix, 
              BOOL fPrintFrbInfo,
              const char *pszFormat, 
              va_list *vaArgs)
{
    EnterMessageMode();

    if (fBuildPrefix)
        ClearLine();

    if (fColorConsole && wAttributes)
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), wAttributes);

    if (fBuildPrefix)
        fprintf(stderr, "BUILD: ");

    if (fPrintFrbInfo && Frb.fOpen) {
        fprintf (stderr, "%s(%hu): ", Frb.pszFile, Frb.cLine);
    }

    vfprintf(stderr, pszFormat, *vaArgs);
    fflush(stderr);

    if (fColorConsole && wAttributes)
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), DefaultConsoleAttributes);

    LeaveMessageMode();
}

VOID
__cdecl
BuildMsg(const char *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);
    WriteMsgStdErr(0, TRUE, FALSE, pszfmt, &va);
}


void
__cdecl
BuildColorMsg(WORD wAttributes, const char *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);
    WriteMsgStdErr(wAttributes, TRUE, FALSE, pszfmt, &va);
}

VOID
__cdecl
BuildMsgRaw(const char *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);
    WriteMsgStdErr(0, FALSE, FALSE, pszfmt, &va);
}


VOID
__cdecl
BuildColorMsgRaw(WORD wAttributes, const char *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);
    WriteMsgStdErr(wAttributes, FALSE, FALSE, pszfmt, &va);
}


VOID
__cdecl
BuildError(const char *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);
    WriteMsgStdErr(0, TRUE, TRUE, pszfmt, &va);

    if (LogFile != NULL) {
        va_start(va, pszfmt);
        fprintf(LogFile, "BUILD: ");

        if (Frb.fOpen) {
            fprintf (LogFile, "%s(%hu): ", Frb.pszFile, Frb.cLine);
        }

        vfprintf(LogFile, pszfmt, va);
        va_end(va);
        fflush(LogFile);
    }
}

VOID
__cdecl
BuildColorError(WORD wAttributes, const char *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);
    WriteMsgStdErr(wAttributes, TRUE, TRUE, pszfmt, &va);

    if (LogFile != NULL) {
        va_start(va, pszfmt);
        fprintf(LogFile, "BUILD: ");

        if (Frb.fOpen) {
            fprintf (LogFile, "%s(%hu): ", Frb.pszFile, Frb.cLine);
        }

        vfprintf(LogFile, pszfmt, va);
        va_end(va);
        fflush(LogFile);
    }
}


VOID
__cdecl
BuildErrorRaw(const char *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);
    WriteMsgStdErr(0, FALSE, FALSE, pszfmt, &va);

    if (LogFile != NULL) {
        va_start(va, pszfmt);
        vfprintf(LogFile, pszfmt, va);
        va_end(va);
        fflush(LogFile);
    }
}

VOID
__cdecl
BuildColorErrorRaw(WORD wAttributes, const char *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);
    WriteMsgStdErr(wAttributes, FALSE, FALSE, pszfmt, &va);

    if (LogFile != NULL) {
        va_start(va, pszfmt);
        vfprintf(LogFile, pszfmt, va);
        va_end(va);
        fflush(LogFile);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   memfind
//
//  Synopsis:   Finds a sub-string by length (can contain nulls)
//
//  Arguments:  [pvWhere]   -- String to search (can contain nulls)
//              [cbWhere]   -- Length in bytes of the string to search
//              [pvWhat]    -- String to search for (can contain nulls)
//              [cbWhat]    -- Length in bytes of the string to search for
//
//  Returns:    Pointer to the first occurence of pvWhat in pvWhere
//              NULL, if not found or if the input parameters are not valid
//
//----------------------------------------------------------------------------

VOID*
memfind(VOID* pvWhere, DWORD cbWhere, VOID* pvWhat, DWORD cbWhat)
{
    DWORD dwWhat = 0;
    DWORD dwWhere = 0;
    DWORD dwFoundStart = 0;

    // input validation
    if (cbWhere < cbWhat || pvWhere == NULL || pvWhat == NULL)
        return NULL;

    while (dwFoundStart <= cbWhere - cbWhat && dwWhat < cbWhat) {
        if ( ((BYTE*)pvWhat)[dwWhat] != ((BYTE*)pvWhere)[dwWhere]) {
            dwWhat = 0;
            dwFoundStart++;
            dwWhere = dwFoundStart;
        } else {
            dwWhat++;
            dwWhere++;
        }
    }

    if (dwWhat == cbWhat)
        return (BYTE*)pvWhere + dwFoundStart;
    return NULL;
}

//
// XML Logging
//

//#define MAX_XML_BUFFER_SIZE 2048
char szXMLPrivateBuffer[2048];//MAX_XML_BUFFER_SIZE];

BOOL
XMLInit(VOID)
{
    UINT i;

    if (fXMLOutput) {
        // copy the XML schema to the log directory
        char buffer[MAX_PATH];
        char* psz = buffer + GetModuleFileName(NULL, buffer, sizeof(buffer));

        while (psz > buffer && *psz != '\\') {
            --psz;
        }
        ++psz;
        strcpy(psz, XML_SCHEMA);

        // check if there is a schema file in the current directory
        if (GetFileAttributes(XML_SCHEMA) == 0xFFFFFFFF) {
            // copy the schema to the current directory
            if (!CopyFile(buffer, XML_SCHEMA, FALSE)) {
                BuildError("(Fatal Error) Unable to copy the XML schema file\n");
                return FALSE;
            }
        }
    }

    if (fXMLOutput || fXMLFragment) {
        // initialize the memory structures
        AllocMem(sizeof(PXMLTHREADSTATE)*(NumberProcesses+1), (VOID**)&PXMLThreadStates, MT_PXMLTHREADSTATE);

        for (i = 0; i < NumberProcesses+1; i++) {
            AllocMem(sizeof(XMLTHREADSTATE), (VOID**)&(PXMLThreadStates[i]), MT_XMLTHREADSTATE);
            memset(PXMLThreadStates[i], 0, sizeof(XMLTHREADSTATE));
            PXMLThreadStates[i]->iXMLFileStart = -1;
        }
        AllocMem(sizeof(XMLTHREADSTATE), (VOID**)&(PXMLGlobalState), MT_XMLTHREADSTATE);
        memset(PXMLGlobalState, 0, sizeof(XMLTHREADSTATE));
        PXMLGlobalState->iXMLFileStart = 0;
        InitializeCriticalSection(&XMLCriticalSection);
        fXMLInitialized = TRUE;
    }

    return TRUE;
}

VOID
XMLUnInit(VOID)
{
    if (fXMLInitialized) {
        UINT i;
        for (i = 0; i < NumberProcesses+1; i++) {
            FreeMem((VOID**)&(PXMLThreadStates[i]), MT_XMLTHREADSTATE);
        }
        FreeMem((VOID**)&PXMLGlobalState, MT_XMLTHREADSTATE);
        FreeMem((VOID**)&PXMLThreadStates, MT_PXMLTHREADSTATE);
        DeleteCriticalSection(&XMLCriticalSection);

        fXMLInitialized = FALSE;
    }
}

VOID _cdecl
XMLThreadWrite(PTHREADSTATE ThreadState, LPCSTR pszFmt, ...)
{
    va_list va;
    DWORD dwBufferLen;
    SIZE_T dwCurrentFilePos;
    PXMLTHREADSTATE OtherXMLState;
    PXMLTHREADSTATE XMLState;
    UINT i;

    if (!fXMLInitialized)
        return;

    XMLEnterCriticalSection();

    XMLState = PXMLThreadStates[ThreadState->XMLThreadIndex];
    XMLThreadInitBuffer(ThreadState);

    ZeroMemory(szXMLPrivateBuffer, sizeof(szXMLPrivateBuffer));

    // build the string to write out
    va_start(va, pszFmt);
    _vsnprintf(szXMLPrivateBuffer, sizeof(szXMLPrivateBuffer)-1, pszFmt, va);
    va_end(va);
    dwBufferLen = strlen(szXMLPrivateBuffer);

    dwCurrentFilePos = XMLState->iXMLFileStart + XMLState->iXMLBufferPos;
    if (fXMLOutput) {
        // write it into the file
        if (fseek(XMLFile, (long)dwCurrentFilePos, SEEK_SET) != -1) {
            fwrite(szXMLPrivateBuffer, 1, dwBufferLen, XMLFile);
            // put back the thread tail
            fwrite(XMLState->XMLBuffer + XMLState->iXMLBufferPos, 1, XMLState->iXMLBufferLen - XMLState->iXMLBufferPos, XMLFile);
        }
    }
    dwCurrentFilePos += dwBufferLen + XMLState->iXMLBufferLen - XMLState->iXMLBufferPos;

    // insert the string into the thread buffer
    memmove(XMLState->XMLBuffer + XMLState->iXMLBufferPos + dwBufferLen, XMLState->XMLBuffer + XMLState->iXMLBufferPos, XMLState->iXMLBufferLen - XMLState->iXMLBufferPos + 1); // include the null terminator
    memmove(XMLState->XMLBuffer + XMLState->iXMLBufferPos, szXMLPrivateBuffer, dwBufferLen);
    XMLState->iXMLBufferPos += dwBufferLen;
    XMLState->iXMLBufferLen += dwBufferLen;

    // write back the threads that got overwritten
    // will reorder them but it doesn't really matter since the final order is 
    // the one in they finish

    for (i = 0; i < NumberProcesses+1; i++) {
        if (i != ThreadState->XMLThreadIndex) {
            OtherXMLState = PXMLThreadStates[i];
            if (OtherXMLState->iXMLFileStart < XMLState->iXMLFileStart) {
                continue;
            }

            OtherXMLState->iXMLFileStart = dwCurrentFilePos;
            if (fXMLOutput) {
                fwrite(OtherXMLState->XMLBuffer, 1, OtherXMLState->iXMLBufferLen, XMLFile);
            }
            dwCurrentFilePos += OtherXMLState->iXMLBufferLen;
        }
    }

    // update the global tail position
    PXMLGlobalState->iXMLFileStart = dwCurrentFilePos;
    if (fXMLOutput) {
        // write back the global tail
        fwrite(PXMLGlobalState->XMLBuffer,  1, PXMLGlobalState->iXMLBufferLen, XMLFile);
        fflush(XMLFile);    
    }
    XMLLeaveCriticalSection();
}

VOID _cdecl
XMLThreadOpenTag(PTHREADSTATE ThreadState, LPCSTR pszTag, LPCSTR pszFmt, ...)
{
    va_list va;
    DWORD dwMidBufferLen;
    DWORD dwBufferLen;
    SIZE_T dwCurrentFilePos;
    DWORD dwTagLen = strlen(pszTag);
    PXMLTHREADSTATE OtherXMLState;
    PXMLTHREADSTATE XMLState;
    UINT i;

    if (!fXMLInitialized)
        return;

    XMLEnterCriticalSection();

    XMLState = PXMLThreadStates[ThreadState->XMLThreadIndex];
    XMLThreadInitBuffer(ThreadState);

    // build the string to write out
    szXMLPrivateBuffer[0] = '<';
    strcpy(szXMLPrivateBuffer + 1, pszTag);

    if (pszFmt != NULL) {
        va_start(va, pszFmt);
        strcat(szXMLPrivateBuffer, " ");
        vsprintf(szXMLPrivateBuffer + strlen(szXMLPrivateBuffer), pszFmt, va);
        va_end(va);
    }

    strcat(szXMLPrivateBuffer, ">");

    dwMidBufferLen = strlen(szXMLPrivateBuffer);

    szXMLPrivateBuffer[dwMidBufferLen] = '<';
    szXMLPrivateBuffer[dwMidBufferLen + 1] = '/';
    memcpy(szXMLPrivateBuffer + dwMidBufferLen + 2, pszTag, dwTagLen);
    szXMLPrivateBuffer[dwMidBufferLen + dwTagLen + 2] = '>';

    dwBufferLen = dwMidBufferLen + dwTagLen + 3;

    // write it into the file
    dwCurrentFilePos = XMLState->iXMLFileStart + XMLState->iXMLBufferPos;
    if (fXMLOutput) {
        if (fseek(XMLFile, (long)dwCurrentFilePos, SEEK_SET) != -1) {
            fwrite(szXMLPrivateBuffer, 1, dwBufferLen, XMLFile);
            // put back the thread tail
            fwrite(XMLState->XMLBuffer + XMLState->iXMLBufferPos, 1, XMLState->iXMLBufferLen - XMLState->iXMLBufferPos, XMLFile);
        }
    }
    dwCurrentFilePos += dwBufferLen + XMLState->iXMLBufferLen - XMLState->iXMLBufferPos;

    // insert the string into the thread buffer
    memmove(XMLState->XMLBuffer + XMLState->iXMLBufferPos + dwBufferLen, XMLState->XMLBuffer + XMLState->iXMLBufferPos, XMLState->iXMLBufferLen - XMLState->iXMLBufferPos + 1); // include the null terminator
    memmove(XMLState->XMLBuffer + XMLState->iXMLBufferPos, szXMLPrivateBuffer, dwBufferLen);
    // don't increase the buffer pos with the full string length but until the end of the open tag only
    XMLState->iXMLBufferPos += dwMidBufferLen;
    XMLState->iXMLBufferLen += dwBufferLen;

    // write back the threads that got overwritten
    // will reorder them but it doesn't really matter since the final order is 
    // the one in they finish

    for (i = 0; i < NumberProcesses+1; i++) {
        if (i != ThreadState->XMLThreadIndex) {
            OtherXMLState = PXMLThreadStates[i];
            if (OtherXMLState->iXMLFileStart < XMLState->iXMLFileStart) {
                continue;
            }

            OtherXMLState->iXMLFileStart = dwCurrentFilePos;
            if (fXMLOutput) {
                fwrite(OtherXMLState->XMLBuffer, 1, OtherXMLState->iXMLBufferLen, XMLFile);
            }
            dwCurrentFilePos += OtherXMLState->iXMLBufferLen;
        }
    }

    // update the global tail position
    PXMLGlobalState->iXMLFileStart = dwCurrentFilePos;
    if (fXMLOutput) {
        // write back the global tail
        fwrite(PXMLGlobalState->XMLBuffer,  1, PXMLGlobalState->iXMLBufferLen, XMLFile);
        fflush(XMLFile);    
    }
    XMLLeaveCriticalSection();
}

VOID
XMLThreadCloseTag(PTHREADSTATE ThreadState, LPCSTR pszTag)
{
    PXMLTHREADSTATE XMLState;
    char* psz;

    if (!fXMLInitialized)
        return;

    XMLEnterCriticalSection();

    XMLState = PXMLThreadStates[ThreadState->XMLThreadIndex];
    psz = XMLState->XMLBuffer + XMLState->iXMLBufferPos;

    if (XMLState->iXMLFileStart == -1) {
        XMLLeaveCriticalSection();
        return;
    }

    assert(*psz == '<');
    assert(strncmp(psz+2, pszTag, strlen(pszTag))==0);
    while (*psz != '>')
        psz++;
    psz++;
    XMLState->iXMLBufferPos += psz - (XMLState->XMLBuffer + XMLState->iXMLBufferPos);
    XMLLeaveCriticalSection();
}

VOID
XMLThreadReleaseBuffer(PTHREADSTATE ThreadState)
{
    // this op may cause the other thread blocks to move towards the end of the file
    // but we can't keep more than one block per thread so we have to live with it

    UINT i;
    SIZE_T iMinFileStart = LONG_MAX;
    int iMinThreadIndex = -1;
    PXMLTHREADSTATE OtherXMLState;
    PXMLTHREADSTATE XMLState;
    SIZE_T dwCurrentFilePos;

    if (!fXMLInitialized)
        return;

    XMLEnterCriticalSection();

    XMLState = PXMLThreadStates[ThreadState->XMLThreadIndex];
    if (XMLState->iXMLFileStart == -1) {
        XMLLeaveCriticalSection();
        return;
    }

    assert(XMLState->iXMLBufferPos == XMLState->iXMLBufferLen);

    // find the thread with the smallest file position

    for (i = 0; i < NumberProcesses+1; i++) {
        OtherXMLState = PXMLThreadStates[i];
        if (OtherXMLState->iXMLFileStart != -1 && OtherXMLState->iXMLFileStart < iMinFileStart) {
            iMinFileStart = OtherXMLState->iXMLFileStart;
            iMinThreadIndex = i;
        }
    }

    if (iMinThreadIndex == ThreadState->XMLThreadIndex) {
        // got lucky - this thread is the first one, so we don't need to do anything
        XMLState->iXMLFileStart = -1;
        XMLLeaveCriticalSection();
        return; 
    }

    // dump out all threads starting with ours - not sure if the order matters
    // got the seek pos at the prev step
    dwCurrentFilePos = iMinFileStart;
    if (fXMLOutput) {
        if (fseek(XMLFile, (long)dwCurrentFilePos, SEEK_SET) != -1) {
            fwrite(XMLState->XMLBuffer, 1, XMLState->iXMLBufferLen, XMLFile);
        }
    }
    dwCurrentFilePos += XMLState->iXMLBufferLen;

    XMLState->iXMLFileStart = -1;

    for (i = 0; i < NumberProcesses+1; i++) {
        if (i != ThreadState->XMLThreadIndex) {
            OtherXMLState = PXMLThreadStates[i];
            if (OtherXMLState->iXMLFileStart != -1) {
                OtherXMLState->iXMLFileStart = dwCurrentFilePos;
                if (fXMLOutput) {
                    fwrite(OtherXMLState->XMLBuffer, 1, OtherXMLState->iXMLBufferLen, XMLFile);
                }
                dwCurrentFilePos += OtherXMLState->iXMLBufferLen;
            }
        }
    }

    // no need to write out the global tail because it didn't move
    if (fXMLOutput) {
        fflush(XMLFile);
    }
    XMLLeaveCriticalSection();
}

VOID
XMLThreadInitBuffer(PTHREADSTATE ThreadState)
{
    PXMLTHREADSTATE XMLState;

    if (!fXMLInitialized)
        return;

    XMLEnterCriticalSection();

    XMLState = PXMLThreadStates[ThreadState->XMLThreadIndex];
    if (XMLState->iXMLFileStart == -1) {
        XMLState->iXMLFileStart = PXMLGlobalState->iXMLFileStart;
        XMLState->iXMLBufferLen = 0;
        XMLState->iXMLBufferPos = 0;
        XMLState->fXMLInAction = FALSE;
    }

    XMLLeaveCriticalSection();
}

VOID _cdecl
XMLGlobalWrite(LPCSTR pszFmt, ...)
{
    va_list va;
    SIZE_T dwBufferLen;
    SIZE_T dwCurrentFilePos;
    UINT i;

    if (!fXMLInitialized)
        return;

    XMLEnterCriticalSection();

    for (i = 0; i < NumberProcesses+1; i++) {
        if (PXMLThreadStates[i]->iXMLFileStart != -1) {
            XMLLeaveCriticalSection();
            return;
        }
    }

    ZeroMemory(szXMLPrivateBuffer, sizeof(szXMLPrivateBuffer));

    // build the string to write out
    va_start(va, pszFmt);
    _vsnprintf(szXMLPrivateBuffer, sizeof(szXMLPrivateBuffer)-1, pszFmt, va);
    va_end(va);
    dwBufferLen = strlen(szXMLPrivateBuffer);

    // write it out
    dwCurrentFilePos = PXMLGlobalState->iXMLFileStart;
    if (fXMLOutput) {
        if (fseek(XMLFile, (long)dwCurrentFilePos, SEEK_SET) != -1) {
            fwrite(szXMLPrivateBuffer, 1, dwBufferLen, XMLFile);
        }
    }
    dwCurrentFilePos += dwBufferLen;

    // write out the global tail
    if (fXMLOutput) {
        fwrite(PXMLGlobalState->XMLBuffer, 1, PXMLGlobalState->iXMLBufferLen, XMLFile);
        fflush(XMLFile);
    }
    // and update the tail position
    PXMLGlobalState->iXMLFileStart += dwBufferLen;

    XMLLeaveCriticalSection();
}

VOID _cdecl
XMLGlobalOpenTag(LPCSTR pszTag, LPCSTR pszFmt, ...)
{
    va_list va;
    SIZE_T dwBufferLen;
    DWORD dwTagLen = strlen(pszTag);
    SIZE_T dwCurrentFilePos;
    UINT i;

    if (!fXMLInitialized)
        return;

    XMLEnterCriticalSection();

    for (i = 0; i < NumberProcesses+1; i++) {
        PXMLTHREADSTATE OtherXMLState = PXMLThreadStates[i];
        if (OtherXMLState->iXMLFileStart != -1) {
            XMLLeaveCriticalSection();
            return;
        }
    }

    // build the string to write out
    szXMLPrivateBuffer[0] = '<';
    strcpy(szXMLPrivateBuffer + 1, pszTag);

    if (pszFmt != NULL) {
        va_start(va, pszFmt);
        strcat(szXMLPrivateBuffer, " ");
        vsprintf(szXMLPrivateBuffer + strlen(szXMLPrivateBuffer), pszFmt, va);
        va_end(va);
    }

    strcat(szXMLPrivateBuffer, ">");

    dwBufferLen = strlen(szXMLPrivateBuffer);

    // insert the closing tag in the global tail
    memmove(PXMLGlobalState->XMLBuffer + dwTagLen + 3, PXMLGlobalState->XMLBuffer, PXMLGlobalState->iXMLBufferLen+1);   // include the null terminator
    PXMLGlobalState->XMLBuffer[0] = '<';
    PXMLGlobalState->XMLBuffer[1] = '/';
    memcpy(PXMLGlobalState->XMLBuffer + 2, pszTag, dwTagLen);
    PXMLGlobalState->XMLBuffer[dwTagLen + 2] = '>';
    PXMLGlobalState->iXMLBufferLen += dwTagLen + 3;

    // write out the string
    dwCurrentFilePos = PXMLGlobalState->iXMLFileStart;
    if (fXMLOutput) {
        if (fseek(XMLFile, (long)dwCurrentFilePos, SEEK_SET) != -1) {
            fwrite(szXMLPrivateBuffer, 1, dwBufferLen, XMLFile);
        }
    }
    dwCurrentFilePos += dwBufferLen;

    // put back the global tail
    PXMLGlobalState->iXMLFileStart += dwBufferLen;
    if (fXMLOutput) {
        fwrite(PXMLGlobalState->XMLBuffer, 1, PXMLGlobalState->iXMLBufferLen, XMLFile);
        fflush(XMLFile);
    }

    XMLLeaveCriticalSection();
}

VOID
XMLGlobalCloseTag()
{
    char* psz;
    SIZE_T dwTagLen;

    if (!fXMLInitialized)
        return;

    XMLEnterCriticalSection();

    if (PXMLGlobalState->iXMLBufferLen == 0) {
        XMLLeaveCriticalSection();
        return;
    }

    psz = PXMLGlobalState->XMLBuffer;
    while (*psz != '>')
        psz++;
    psz++;
    dwTagLen = psz - PXMLGlobalState->XMLBuffer;
    memmove(PXMLGlobalState->XMLBuffer, psz, PXMLGlobalState->iXMLBufferLen - dwTagLen + 1);    // include the null terminator
    PXMLGlobalState->iXMLBufferLen -= dwTagLen;
    PXMLGlobalState->iXMLFileStart += dwTagLen;
    XMLLeaveCriticalSection();
}

VOID
XMLUpdateEndTag(BOOL fCompleted)
{
    char* pszBuild;
    char* pszEnd;
    DWORD cbBufferLen;
    time_t ltime;

    if (!fXMLInitialized)
        return;

    XMLEnterCriticalSection();

    pszBuild = strstr(PXMLGlobalState->XMLBuffer, "</BUILD>");
    if (pszBuild == NULL) {
        // no build tag is open yet
        XMLLeaveCriticalSection();
        return;
    }

    // remove the existing end tag
    pszEnd = strstr(PXMLGlobalState->XMLBuffer, "<END ");
    if (pszEnd != NULL) {
        memmove(pszEnd, pszBuild, strlen(pszBuild)+1);
        PXMLGlobalState->iXMLBufferLen -= (pszBuild - pszEnd);
        pszBuild = pszEnd;
    }

    // generate the new end tag
    time(&ltime);
    sprintf(szXMLPrivateBuffer, "<END TIME=\"%s\" ELAPSED=\"%s\" PASSES=\"%d\" COMPLETED=\"%d\" ", ctime(&ltime), FormatElapsedTime(XMLStartTicks), NumberPasses, fCompleted);
    strcat(szXMLPrivateBuffer, XMLBuildMetricsString(&RunningTotals));
    strcat(szXMLPrivateBuffer, "/>");
    cbBufferLen = strlen(szXMLPrivateBuffer);

    // insert the new end tag into the buffer
    memmove(pszBuild + cbBufferLen, pszBuild, strlen(pszBuild)+1);
    memmove(pszBuild, szXMLPrivateBuffer, cbBufferLen);
    PXMLGlobalState->iXMLBufferLen += cbBufferLen;

    // write it out
    if (fXMLOutput) {
        if (fseek(XMLFile, (long)PXMLGlobalState->iXMLFileStart, SEEK_SET) != -1) {
            fwrite(PXMLGlobalState->XMLBuffer, 1, PXMLGlobalState->iXMLBufferLen, XMLFile);
            fflush(XMLFile);
        }
    }
    XMLLeaveCriticalSection();
}

static char cEntity[5] = { "<&>\"'"};
static char* pszEntityEncoding[5] = { 
    "&lt;",
    "&amp;",
    "&gt;",
    "&quot;",
    "&apos;"
};

LPSTR
XMLEncodeBuiltInEntities(LPSTR pszString, DWORD cbStringSize)
{
    DWORD cbStringLen = strlen(pszString);
    char* psz = pszString;
    DWORD cbExtraLen = 0;
    int pos = 0;
    char* pszTarget = NULL;
    char* pszSource = NULL;
    DWORD cbSourceLen = 0;

    cbStringSize -= 1;  // remove the null char

    while ((pos = strcspn(psz, cEntity)) != strlen(psz)) {
        cbExtraLen += strlen(pszEntityEncoding[strchr(cEntity, psz[pos])-cEntity])-1;
        psz += pos+1;
    }

    if (cbExtraLen + cbStringLen > cbStringSize)
        return NULL;

    if (0 == cbExtraLen)
        return pszString;

    psz = pszString + cbStringSize - cbStringLen;
    memmove(psz, pszString, cbStringLen+1);

    pszTarget = pszString;

    while ((pos = strcspn(psz, cEntity)) != strlen(psz)) {
        memmove(pszTarget, psz, pos);
        pszTarget += pos;
        psz += pos;

        pszSource = pszEntityEncoding[strchr(cEntity, *psz)-cEntity];
        cbSourceLen = strlen(pszSource);
        memmove(pszTarget, pszSource, cbSourceLen);
        pszTarget += cbSourceLen;
        psz++;
    }
    memmove(pszTarget, psz, pos);
    pszTarget += pos;
    *pszTarget = 0;

    return pszString;
}

LPSTR
XMLEncodeBuiltInEntitiesCopy(LPSTR pszString, LPSTR pszTarget)
{
    int pos = 0;
    char* pszSource;
    DWORD cbSourceLen;
    char* psz = pszTarget;

    while ((pos = strcspn(pszString, cEntity)) != strlen(pszString)) {
        memmove(psz, pszString, pos);
        psz += pos;
        pszString += pos;

        pszSource = pszEntityEncoding[strchr(cEntity, *pszString)-cEntity];
        cbSourceLen = strlen(pszSource);
        memmove(psz, pszSource, cbSourceLen);
        psz += cbSourceLen;
        pszString++;
    }
    memmove(psz, pszString, pos);
    psz += pos;
    *psz = 0;
    return pszTarget;
}

BOOL
XMLScanBackTag(LPSTR pszEnd, LPSTR pszSentinel, LPSTR* ppszStart)
{
    int nOpen = 0;
    LPSTR pszClosing = NULL;
    while (pszEnd != pszSentinel) {
        --pszEnd;
        if (*pszEnd == '>') {
            pszClosing = pszEnd;
        } else if (*pszEnd == '<') {
            if (NULL == pszClosing) {
                // found '<' before '>' - bad string
                return FALSE;
            }
            if (*(pszEnd+1) == '/') {
                if (*(pszClosing-1) == '/') {
                    // "</...../>" - bad string
                    return FALSE;
                } else {
                    // "</....>" - closing tag
                    ++nOpen;
                }
            } else {
                if (*(pszClosing-1) != '/') {
                    // "<....>" - opening tag
                    --nOpen;
                }
                // else
                // "<..../>" - neutral tag
            }
            if (0 == nOpen) {
                *ppszStart = pszEnd;
                return TRUE;
            }
        }
    }
    return FALSE;
}

LPSTR
XMLBuildMetricsString(PBUILDMETRICS Metrics)
{
    static char buffer[512];

    buffer[0] = 0;

    if (0 != Metrics->NumberCompiles)
        sprintf(buffer + strlen(buffer), "FILESCOMPILED=\"%d\" ", Metrics->NumberCompiles);
    if (0 != Metrics->NumberCompileErrors)
        sprintf(buffer + strlen(buffer), "COMPILEERRORS=\"%d\" ", Metrics->NumberCompileErrors);
    if (0 != Metrics->NumberCompileWarnings)
        sprintf(buffer + strlen(buffer), "COMPILEWARNINGS=\"%d\" ", Metrics->NumberCompileWarnings);
    if (0 != Metrics->NumberLibraries)
        sprintf(buffer + strlen(buffer), "LIBRARIESBUILT=\"%d\" ", Metrics->NumberLibraries);
    if (0 != Metrics->NumberLibraryErrors)
        sprintf(buffer + strlen(buffer), "LIBRARYERRORS=\"%d\" ", Metrics->NumberLibraryErrors);
    if (0 != Metrics->NumberLibraryWarnings)
        sprintf(buffer + strlen(buffer), "LIBRARYWARNINGS=\"%d\" ", Metrics->NumberLibraryWarnings);
    if (0 != Metrics->NumberLinks)
        sprintf(buffer + strlen(buffer), "EXECUTABLESBUILT=\"%d\" ", Metrics->NumberLinks);
    if (0 != Metrics->NumberLinkErrors)
        sprintf(buffer + strlen(buffer), "LINKERRORS=\"%d\" ", Metrics->NumberLinkErrors);
    if (0 != Metrics->NumberLinkWarnings)
        sprintf(buffer + strlen(buffer), "LINKWARNINGS=\"%d\" ", Metrics->NumberLinkWarnings);
    if (0 != Metrics->NumberBSCMakes)
        sprintf(buffer + strlen(buffer), "BROWSERDBS=\"%d\" ", Metrics->NumberBSCMakes);
    if (0 != Metrics->NumberBSCErrors)
        sprintf(buffer + strlen(buffer), "BSCERRORS=\"%d\" ", Metrics->NumberBSCErrors);
    if (0 != Metrics->NumberBSCWarnings)
        sprintf(buffer + strlen(buffer), "BSCWARNINGS=\"%d\" ", Metrics->NumberBSCWarnings);
    if (0 != Metrics->NumberVSToolErrors)
        sprintf(buffer + strlen(buffer), "VSTOOLERRORS=\"%d\" ", Metrics->NumberVSToolErrors);
    if (0 != Metrics->NumberVSToolWarnings)
        sprintf(buffer + strlen(buffer), "VSTOOLWARNINGS=\"%d\" ", Metrics->NumberVSToolWarnings);

    return buffer;
}

VOID _cdecl
XMLWriteFragmentFile(LPCSTR pszBaseFileName, LPCSTR pszFmt, ...)
{
    va_list va;
    FILE* PFile;

    char szFileName[DB_MAX_PATH_LENGTH];
    sprintf(szFileName, "%s\\%s_%s.xml", XMLFragmentDirectory, FormatCurrentDateTime(), pszBaseFileName);

    XMLEnterCriticalSection();

    va_start(va, pszFmt);
    vsprintf(szXMLPrivateBuffer, pszFmt, va);
    va_end(va);

    PFile = fopen(szFileName, "wb");
    if (PFile) {
        fwrite(szXMLPrivateBuffer, 1, strlen(szXMLPrivateBuffer), PFile);
        fclose(PFile);
    }

    XMLLeaveCriticalSection();
}

VOID _cdecl
XMLWriteDirFragmentFile(LPCSTR pszRelPath, PVOID pvBlock, SIZE_T cbCount)
{
    FILE* PFile;
    char* psz;

    char szFileName[DB_MAX_PATH_LENGTH];
    sprintf(szFileName, "%s\\%s_DIR_%s", XMLFragmentDirectory, FormatCurrentDateTime(), pszRelPath);
    psz = szFileName+strlen(szFileName)-1;
    if (*psz == '\\') {
        *psz = 0;
    }
    strcat(szFileName, ".xml");
    psz = szFileName+strlen(XMLFragmentDirectory)+1;
    while (*psz) {
        if (*psz == '\\') {
            *psz = '_';
        }
        ++psz;
    }

    PFile = fopen(szFileName, "wb");
    if (PFile) {
        fwrite(pvBlock, 1, cbCount, PFile);
        fclose(PFile);
    }
}

VOID
AddBuildMetrics(PBUILDMETRICS TargetMetrics, PBUILDMETRICS SourceMetrics)
{
    TargetMetrics->NumberCompileWarnings += SourceMetrics->NumberCompileWarnings;
    TargetMetrics->NumberCompileErrors += SourceMetrics->NumberCompileErrors;
    TargetMetrics->NumberCompiles += SourceMetrics->NumberCompiles;
    TargetMetrics->NumberLibraries += SourceMetrics->NumberLibraries;
    TargetMetrics->NumberLibraryWarnings += SourceMetrics->NumberLibraryWarnings;
    TargetMetrics->NumberLibraryErrors += SourceMetrics->NumberLibraryErrors;
    TargetMetrics->NumberLinks += SourceMetrics->NumberLinks;
    TargetMetrics->NumberLinkWarnings += SourceMetrics->NumberLinkWarnings;
    TargetMetrics->NumberLinkErrors += SourceMetrics->NumberLinkErrors;
    TargetMetrics->NumberBSCMakes += SourceMetrics->NumberBSCMakes;
    TargetMetrics->NumberBSCWarnings += SourceMetrics->NumberBSCWarnings;
    TargetMetrics->NumberBSCErrors += SourceMetrics->NumberBSCErrors;
    TargetMetrics->NumberVSToolErrors += SourceMetrics->NumberVSToolErrors;
    TargetMetrics->NumberVSToolWarnings += SourceMetrics->NumberVSToolWarnings;
    TargetMetrics->NumberDirActions += SourceMetrics->NumberDirActions;
    TargetMetrics->NumberActWarnings += SourceMetrics->NumberActWarnings;
    TargetMetrics->NumberActErrors += SourceMetrics->NumberActErrors;
}

VOID
XMLEnterCriticalSection()
{
    if (fXMLInitialized) {
        EnterCriticalSection(&XMLCriticalSection);
    }
}

VOID
XMLLeaveCriticalSection()
{
    if (fXMLInitialized) {
        LeaveCriticalSection(&XMLCriticalSection);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\browse.c ===
//
// Browse.C
//
#include "sigverif.h"

// Global browse buffer that is used until user click OK or Cancel
TCHAR g_szBrowsePath[MAX_PATH];

//
// This callback function handles the initialization of the browse dialog and when
// the user changes the selection in the tree-view.  We want to keep updating the 
// g_szBrowsePath buffer with selection changes until the user clicks OK.
//
int CALLBACK BrowseCallbackProc(
    HWND hwnd, 
    UINT uMsg, 
    LPARAM lParam, 
    LPARAM lpData 
    )
{
    TCHAR PathName[MAX_PATH];
    LPITEMIDLIST lpid;

    UNREFERENCED_PARAMETER(lpData);

    switch (uMsg) {
    
    case BFFM_INITIALIZED:
        //
        // Initialize the dialog with the OK button and g_szBrowsePath
        //
        SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM) 1);
        SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) TRUE, (LPARAM) g_szBrowsePath);
        break;

    case BFFM_SELCHANGED:   
        lpid = (LPITEMIDLIST) lParam;
        
        if (SHGetPathFromIDList(lpid, PathName) &&
            (SUCCEEDED(StringCchCopy(g_szBrowsePath, cA(g_szBrowsePath), PathName)))) {
        
            SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM) 1);
        }
        
        break;
    }

    return 0;
}  

//
// This uses SHBrowseForFolder to get the directory the user wants to search.
// We specify a callback function that updates g_szBrowsePath until the user clicks OK or Cancel.
// If they clicked OK, then we update the string passed in to us as lpszBuf.
// 
//
BOOL BrowseForFolder(HWND hwnd, LPTSTR lpszBuf, DWORD BufCchSize) {

    BROWSEINFO          bi;
    TCHAR               szBuffer[MAX_PATH], szMessage[MAX_PATH];
    LPITEMIDLIST        lpid;

    //
    // Check if the lpszBuf path is valid, if so use that as the browse dialog's initial directory.
    // If it isn't valid, initialize g_szBrowsePath with the Windows directory.
    //
    if (!SetCurrentDirectory(lpszBuf) ||
        FAILED(StringCchCopy(g_szBrowsePath, cA(g_szBrowsePath), lpszBuf))) {
        
        MyGetWindowsDirectory(g_szBrowsePath, cA(g_szBrowsePath));
    }

    //
    // Start the root of the browse dialog in the CSIDL_DRIVES namespace
    //
    if (!SUCCEEDED(SHGetSpecialFolderLocation(hwnd, CSIDL_DRIVES, &lpid))) {
    
        return FALSE;
    }

    //
    // This loads in the "Please select a directory" text into the dialog.
    //
    MyLoadString(szMessage, cA(szMessage), IDS_SELECTDIR);

    //
    // Setup the BrowseInfo struct.
    //
    bi.hwndOwner        = hwnd;
    bi.pidlRoot         = lpid;
    bi.pszDisplayName   = szBuffer;
    bi.lpszTitle        = szMessage;
    bi.ulFlags          = BIF_RETURNONLYFSDIRS;
    bi.lpfn             = (BFFCALLBACK) BrowseCallbackProc;
    bi.lParam           = 0x123;

    if (SHBrowseForFolder(&bi) == NULL) {
    
        return FALSE;
    }

    //
    // The user must have clicked OK, so we can update lpszBuf with g_szBrowsePath!
    //
    return (SUCCEEDED(StringCchCopy(lpszBuf, BufCchSize, g_szBrowsePath)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\advanced.c ===
//
// Advanced.C
//
#include "sigverif.h"

//
//  Initialization of search dialog.
//
BOOL Search_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{   
    TCHAR szBuffer[MAX_PATH];

    UNREFERENCED_PARAMETER(hwndFocus);
    UNREFERENCED_PARAMETER(lParam);

    g_App.hSearch = hwnd;

    //
    // Since the "check system files" option is faster, check that option by 
    // default.
    //
    if (!g_App.bUserScan) {
        CheckRadioButton(hwnd, IDC_SCAN, IDC_NOTMS, IDC_SCAN);
    } else {
        CheckRadioButton(hwnd, IDC_SCAN, IDC_NOTMS, IDC_NOTMS);
    }

    //
    // Pre-load the user's search path with the Windows directory
    //
    if (!*g_App.szScanPath) {
        MyGetWindowsDirectory(g_App.szScanPath, cA(g_App.szScanPath));
    }

    //
    // Display the current search folder
    //
    SetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath);

    //
    // Pre-load the user's search pattern with "*.*"
    //
    if (!*g_App.szScanPattern) {
        MyLoadString(g_App.szScanPattern, cA(g_App.szScanPattern), IDS_ALL);
    }

    //
    // Display the current search pattern.
    //
    SetDlgItemText(hwnd, IDC_TYPE, szBuffer);

    //
    // Now disable all the dialog items associated with IDS_NOTMS
    //
    if (!g_App.bUserScan) {
        EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TYPE), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), FALSE);
        EnableWindow(GetDlgItem(hwnd, ID_BROWSE), FALSE);
    }

    //
    // If we are searching subdirectories, check the SubFolders checkbox
    //
    if (g_App.bSubFolders) {
        CheckDlgButton(hwnd, IDC_SUBFOLDERS, BST_CHECKED);
    } else {
        CheckDlgButton(hwnd, IDC_SUBFOLDERS, BST_UNCHECKED);
    }

    //
    // Set the combobox value to g_App.szScanPattern
    //
    SetDlgItemText(hwnd, IDC_TYPE, g_App.szScanPattern);

    //
    // Initialize the combobox with several pre-defined extension types
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_EXE);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, cA(szBuffer), IDS_DLL);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, cA(szBuffer), IDS_SYS);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, cA(szBuffer), IDS_DRV);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, cA(szBuffer), IDS_OCX);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, cA(szBuffer), IDS_ALL);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);

    return TRUE;
}

//
//  Handle any WM_COMMAND messages sent to the search dialog
//
void Search_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    UNREFERENCED_PARAMETER(hwndCtl);
    UNREFERENCED_PARAMETER(codeNotify);

    switch(id) {
    
    case ID_BROWSE:
        // 
        // The user clicked the ID_BROWSE button, so call BrowseForFolder and 
        // update IDC_FOLDER
        //
        if (BrowseForFolder(hwnd, g_App.szScanPath, cA(g_App.szScanPath))) {
            SetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath);
        }
        break;

    case IDC_SCAN:
        //
        //  The user clicked IDC_SCAN, so disable all the IDC_NOTMS controls
        //
        if (!g_App.bScanning) {
            EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_TYPE), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), FALSE);
            EnableWindow(GetDlgItem(hwnd, ID_BROWSE), FALSE);
        }
        break;

    case IDC_NOTMS:
        //
        //  The user clicked IDC_NOTMS, so make sure all the controls are enabled
        //
        if (!g_App.bScanning) {
            EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_TYPE), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), TRUE);
            EnableWindow(GetDlgItem(hwnd, ID_BROWSE), TRUE);
        }
        break;
    }
}

//
// This function handles any notification messages for the Search page.
//
LRESULT Search_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnmhdr = (NMHDR *) lParam;

    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);

    switch(lpnmhdr->code) {
    
    case PSN_APPLY:         
        g_App.bUserScan = (IsDlgButtonChecked(hwnd, IDC_NOTMS) == BST_CHECKED);
        if (g_App.bUserScan) {

            if (GetWindowTextLength(GetDlgItem(hwnd, IDC_FOLDER)) > cA(g_App.szScanPath)) {
                //
                // The folder path that was entered is too long to fit into our
                // buffer, so tell the user the path is invalid and stay on
                // the property page.
                //
                MyErrorBoxId(IDS_INVALID_FOLDER);
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                return TRUE;
            } else {
                //
                // Get the search pattern from the combobox and update g_App.szScanPattern
                //
                GetDlgItemText(hwnd, IDC_TYPE, g_App.szScanPattern, cA(g_App.szScanPattern));
                
                //
                // Get the path from the edit control and update g_App.szScanPath
                //
                GetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath, cA(g_App.szScanPath));
                
                //
                // Get the checked/unchecked state of the "SubFolders" checkbox
                //
                g_App.bSubFolders = (IsDlgButtonChecked(hwnd, IDC_SUBFOLDERS) == BST_CHECKED);
            }
        }
    }

    return 0;
}


//
//  The search dialog procedure.  Needs to handle WM_INITDIALOG, WM_COMMAND, and WM_CLOSE/WM_DESTROY.
//
INT_PTR CALLBACK Search_DlgProc(HWND hwnd, UINT uMsg,
                                WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
        
    HANDLE_MSG(hwnd, WM_INITDIALOG, Search_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, Search_OnCommand);

    case WM_NOTIFY:
        return Search_NotifyHandler(hwnd, uMsg, wParam, lParam);

    case WM_HELP:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, FALSE);
        break;

    case WM_CONTEXTMENU:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, TRUE);
        break;

    default: fProcessed = FALSE;
    }

    return fProcessed;
}

void AdvancedPropertySheet(HWND hwnd)
{
    PROPSHEETPAGE   psp[NUM_PAGES];
    PROPSHEETHEADER psh;
    TCHAR           szCaption[MAX_PATH];
    TCHAR           szPage1[MAX_PATH];
    TCHAR           szPage2[MAX_PATH];
    
    ZeroMemory(&psp[0], sizeof(PROPSHEETPAGE));
    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = PSP_USEHICON | PSP_USETITLE;
    psp[0].hInstance = g_App.hInstance;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_SEARCH);
    psp[0].hIcon = g_App.hIcon;
    psp[0].pfnDlgProc = Search_DlgProc;
    MyLoadString(szPage1, cA(szPage1), IDS_SEARCHTAB);
    psp[0].pszTitle = szPage1;
    psp[0].lParam = 0;
    psp[0].pfnCallback = NULL;

    ZeroMemory(&psp[1], sizeof(PROPSHEETPAGE));
    psp[1].dwSize = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags = PSP_USEHICON | PSP_USETITLE;
    psp[1].hInstance = g_App.hInstance;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_SETTINGS);
    psp[1].hIcon = g_App.hIcon;
    psp[1].pfnDlgProc = LogFile_DlgProc;
    MyLoadString(szPage2, cA(szPage2), IDS_LOGGINGTAB);
    psp[1].pszTitle = szPage2;
    psp[1].lParam = 0;
    psp[1].pfnCallback = NULL;

    ZeroMemory(&psh, sizeof(PROPSHEETHEADER));
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_USEHICON | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwnd;
    psh.hInstance = g_App.hInstance;
    psh.hIcon = g_App.hIcon;
    MyLoadString(szCaption, cA(szCaption), IDS_ADVANCED_SETTINGS);
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = 0;
    psh.ppsp = (LPCPROPSHEETPAGE)psp;
    psh.pfnCallback = NULL;

    PropertySheet(&psh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\build\scrproc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for scrproc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __scrproc_h__
#define __scrproc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IScriptedProcess_FWD_DEFINED__
#define __IScriptedProcess_FWD_DEFINED__
typedef interface IScriptedProcess IScriptedProcess;
#endif 	/* __IScriptedProcess_FWD_DEFINED__ */


#ifndef __IScriptedProcessSink_FWD_DEFINED__
#define __IScriptedProcessSink_FWD_DEFINED__
typedef interface IScriptedProcessSink IScriptedProcessSink;
#endif 	/* __IScriptedProcessSink_FWD_DEFINED__ */


#ifndef __LocalScriptedProcess_FWD_DEFINED__
#define __LocalScriptedProcess_FWD_DEFINED__

#ifdef __cplusplus
typedef class LocalScriptedProcess LocalScriptedProcess;
#else
typedef struct LocalScriptedProcess LocalScriptedProcess;
#endif /* __cplusplus */

#endif 	/* __LocalScriptedProcess_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_scrproc_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_scrproc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_scrproc_0000_v0_0_s_ifspec;

#ifndef __IScriptedProcess_INTERFACE_DEFINED__
#define __IScriptedProcess_INTERFACE_DEFINED__

/* interface IScriptedProcess */
/* [uuid][object] */ 


EXTERN_C const IID IID_IScriptedProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c3171-c854-4a77-b189-606859e4391b")
    IScriptedProcess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProcessID( 
            /* [in] */ long lProcessID,
            /* [string][in] */ wchar_t *pszEnvID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendData( 
            /* [string][in] */ wchar_t *pszType,
            /* [string][in] */ wchar_t *pszData,
            /* [out] */ long *plReturn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExitCode( 
            /* [in] */ long lExitCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProcessSink( 
            /* [in] */ IScriptedProcessSink *pSPS) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptedProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScriptedProcess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScriptedProcess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScriptedProcess * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProcessID )( 
            IScriptedProcess * This,
            /* [in] */ long lProcessID,
            /* [string][in] */ wchar_t *pszEnvID);
        
        HRESULT ( STDMETHODCALLTYPE *SendData )( 
            IScriptedProcess * This,
            /* [string][in] */ wchar_t *pszType,
            /* [string][in] */ wchar_t *pszData,
            /* [out] */ long *plReturn);
        
        HRESULT ( STDMETHODCALLTYPE *SetExitCode )( 
            IScriptedProcess * This,
            /* [in] */ long lExitCode);
        
        HRESULT ( STDMETHODCALLTYPE *SetProcessSink )( 
            IScriptedProcess * This,
            /* [in] */ IScriptedProcessSink *pSPS);
        
        END_INTERFACE
    } IScriptedProcessVtbl;

    interface IScriptedProcess
    {
        CONST_VTBL struct IScriptedProcessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptedProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptedProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptedProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptedProcess_SetProcessID(This,lProcessID,pszEnvID)	\
    (This)->lpVtbl -> SetProcessID(This,lProcessID,pszEnvID)

#define IScriptedProcess_SendData(This,pszType,pszData,plReturn)	\
    (This)->lpVtbl -> SendData(This,pszType,pszData,plReturn)

#define IScriptedProcess_SetExitCode(This,lExitCode)	\
    (This)->lpVtbl -> SetExitCode(This,lExitCode)

#define IScriptedProcess_SetProcessSink(This,pSPS)	\
    (This)->lpVtbl -> SetProcessSink(This,pSPS)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IScriptedProcess_SetProcessID_Proxy( 
    IScriptedProcess * This,
    /* [in] */ long lProcessID,
    /* [string][in] */ wchar_t *pszEnvID);


void __RPC_STUB IScriptedProcess_SetProcessID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptedProcess_SendData_Proxy( 
    IScriptedProcess * This,
    /* [string][in] */ wchar_t *pszType,
    /* [string][in] */ wchar_t *pszData,
    /* [out] */ long *plReturn);


void __RPC_STUB IScriptedProcess_SendData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptedProcess_SetExitCode_Proxy( 
    IScriptedProcess * This,
    /* [in] */ long lExitCode);


void __RPC_STUB IScriptedProcess_SetExitCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptedProcess_SetProcessSink_Proxy( 
    IScriptedProcess * This,
    /* [in] */ IScriptedProcessSink *pSPS);


void __RPC_STUB IScriptedProcess_SetProcessSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptedProcess_INTERFACE_DEFINED__ */


#ifndef __IScriptedProcessSink_INTERFACE_DEFINED__
#define __IScriptedProcessSink_INTERFACE_DEFINED__

/* interface IScriptedProcessSink */
/* [uuid][object] */ 


EXTERN_C const IID IID_IScriptedProcessSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c3172-c854-4a77-b189-606859e4391b")
    IScriptedProcessSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestExit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveData( 
            /* [string][in] */ wchar_t *pszType,
            /* [string][in] */ wchar_t *pszData,
            /* [out] */ long *plReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptedProcessSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScriptedProcessSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScriptedProcessSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScriptedProcessSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestExit )( 
            IScriptedProcessSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveData )( 
            IScriptedProcessSink * This,
            /* [string][in] */ wchar_t *pszType,
            /* [string][in] */ wchar_t *pszData,
            /* [out] */ long *plReturn);
        
        END_INTERFACE
    } IScriptedProcessSinkVtbl;

    interface IScriptedProcessSink
    {
        CONST_VTBL struct IScriptedProcessSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptedProcessSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptedProcessSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptedProcessSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptedProcessSink_RequestExit(This)	\
    (This)->lpVtbl -> RequestExit(This)

#define IScriptedProcessSink_ReceiveData(This,pszType,pszData,plReturn)	\
    (This)->lpVtbl -> ReceiveData(This,pszType,pszData,plReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IScriptedProcessSink_RequestExit_Proxy( 
    IScriptedProcessSink * This);


void __RPC_STUB IScriptedProcessSink_RequestExit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptedProcessSink_ReceiveData_Proxy( 
    IScriptedProcessSink * This,
    /* [string][in] */ wchar_t *pszType,
    /* [string][in] */ wchar_t *pszData,
    /* [out] */ long *plReturn);


void __RPC_STUB IScriptedProcessSink_ReceiveData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptedProcessSink_INTERFACE_DEFINED__ */



#ifndef __MTScriptedProcessLib_LIBRARY_DEFINED__
#define __MTScriptedProcessLib_LIBRARY_DEFINED__

/* library MTScriptedProcessLib */
/* [uuid] */ 


EXTERN_C const IID LIBID_MTScriptedProcessLib;

EXTERN_C const CLSID CLSID_LocalScriptedProcess;

#ifdef __cplusplus

class DECLSPEC_UUID("854c316f-c854-4a77-b189-606859e4391b")
LocalScriptedProcess;
#endif
#endif /* __MTScriptedProcessLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for od.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __od_h__
#define __od_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IObjectDaemon_FWD_DEFINED__
#define __IObjectDaemon_FWD_DEFINED__
typedef interface IObjectDaemon IObjectDaemon;
#endif 	/* __IObjectDaemon_FWD_DEFINED__ */


#ifndef __ObjectDaemon_FWD_DEFINED__
#define __ObjectDaemon_FWD_DEFINED__

#ifdef __cplusplus
typedef class ObjectDaemon ObjectDaemon;
#else
typedef struct ObjectDaemon ObjectDaemon;
#endif /* __cplusplus */

#endif 	/* __ObjectDaemon_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IObjectDaemon_INTERFACE_DEFINED__
#define __IObjectDaemon_INTERFACE_DEFINED__

/* interface IObjectDaemon */
/* [object][dual][uuid] */ 


EXTERN_C const IID IID_IObjectDaemon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c3183-c854-4a77-b189-606859e4391b")
    IObjectDaemon : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMaximumIndex( 
            /* [retval][out] */ DWORD *dwMaxIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIdentity( 
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pbstrIdentity) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProgID( 
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pbstrProgId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OpenInterface( 
            /* [in] */ BSTR bstrIdentity,
            /* [in] */ BSTR bstrProgId,
            /* [in] */ BOOL fCreate,
            /* [retval][out] */ IDispatch **ppDisp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveInterface( 
            /* [in] */ BSTR bstrIdentity,
            /* [in] */ BSTR bstrProgId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IdentifyInterface( 
            /* [in] */ IDispatch *pDisp,
            /* [out] */ BSTR *pbstrIdentity,
            /* [retval][out] */ BSTR *pbstrProgId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IdentifyInterfaceIndex( 
            /* [in] */ IDispatch *pDisp,
            /* [retval][out] */ DWORD *pdwIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectDaemonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectDaemon * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectDaemon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectDaemon * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IObjectDaemon * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IObjectDaemon * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IObjectDaemon * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IObjectDaemon * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMaximumIndex )( 
            IObjectDaemon * This,
            /* [retval][out] */ DWORD *dwMaxIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIdentity )( 
            IObjectDaemon * This,
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pbstrIdentity);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProgID )( 
            IObjectDaemon * This,
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pbstrProgId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OpenInterface )( 
            IObjectDaemon * This,
            /* [in] */ BSTR bstrIdentity,
            /* [in] */ BSTR bstrProgId,
            /* [in] */ BOOL fCreate,
            /* [retval][out] */ IDispatch **ppDisp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveInterface )( 
            IObjectDaemon * This,
            /* [in] */ BSTR bstrIdentity,
            /* [in] */ BSTR bstrProgId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IdentifyInterface )( 
            IObjectDaemon * This,
            /* [in] */ IDispatch *pDisp,
            /* [out] */ BSTR *pbstrIdentity,
            /* [retval][out] */ BSTR *pbstrProgId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IdentifyInterfaceIndex )( 
            IObjectDaemon * This,
            /* [in] */ IDispatch *pDisp,
            /* [retval][out] */ DWORD *pdwIndex);
        
        END_INTERFACE
    } IObjectDaemonVtbl;

    interface IObjectDaemon
    {
        CONST_VTBL struct IObjectDaemonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectDaemon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectDaemon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectDaemon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectDaemon_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IObjectDaemon_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IObjectDaemon_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IObjectDaemon_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IObjectDaemon_GetMaximumIndex(This,dwMaxIndex)	\
    (This)->lpVtbl -> GetMaximumIndex(This,dwMaxIndex)

#define IObjectDaemon_GetIdentity(This,dwIndex,pbstrIdentity)	\
    (This)->lpVtbl -> GetIdentity(This,dwIndex,pbstrIdentity)

#define IObjectDaemon_GetProgID(This,dwIndex,pbstrProgId)	\
    (This)->lpVtbl -> GetProgID(This,dwIndex,pbstrProgId)

#define IObjectDaemon_OpenInterface(This,bstrIdentity,bstrProgId,fCreate,ppDisp)	\
    (This)->lpVtbl -> OpenInterface(This,bstrIdentity,bstrProgId,fCreate,ppDisp)

#define IObjectDaemon_RemoveInterface(This,bstrIdentity,bstrProgId)	\
    (This)->lpVtbl -> RemoveInterface(This,bstrIdentity,bstrProgId)

#define IObjectDaemon_IdentifyInterface(This,pDisp,pbstrIdentity,pbstrProgId)	\
    (This)->lpVtbl -> IdentifyInterface(This,pDisp,pbstrIdentity,pbstrProgId)

#define IObjectDaemon_IdentifyInterfaceIndex(This,pDisp,pdwIndex)	\
    (This)->lpVtbl -> IdentifyInterfaceIndex(This,pDisp,pdwIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_GetMaximumIndex_Proxy( 
    IObjectDaemon * This,
    /* [retval][out] */ DWORD *dwMaxIndex);


void __RPC_STUB IObjectDaemon_GetMaximumIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_GetIdentity_Proxy( 
    IObjectDaemon * This,
    /* [in] */ DWORD dwIndex,
    /* [retval][out] */ BSTR *pbstrIdentity);


void __RPC_STUB IObjectDaemon_GetIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_GetProgID_Proxy( 
    IObjectDaemon * This,
    /* [in] */ DWORD dwIndex,
    /* [retval][out] */ BSTR *pbstrProgId);


void __RPC_STUB IObjectDaemon_GetProgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_OpenInterface_Proxy( 
    IObjectDaemon * This,
    /* [in] */ BSTR bstrIdentity,
    /* [in] */ BSTR bstrProgId,
    /* [in] */ BOOL fCreate,
    /* [retval][out] */ IDispatch **ppDisp);


void __RPC_STUB IObjectDaemon_OpenInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_RemoveInterface_Proxy( 
    IObjectDaemon * This,
    /* [in] */ BSTR bstrIdentity,
    /* [in] */ BSTR bstrProgId);


void __RPC_STUB IObjectDaemon_RemoveInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_IdentifyInterface_Proxy( 
    IObjectDaemon * This,
    /* [in] */ IDispatch *pDisp,
    /* [out] */ BSTR *pbstrIdentity,
    /* [retval][out] */ BSTR *pbstrProgId);


void __RPC_STUB IObjectDaemon_IdentifyInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_IdentifyInterfaceIndex_Proxy( 
    IObjectDaemon * This,
    /* [in] */ IDispatch *pDisp,
    /* [retval][out] */ DWORD *pdwIndex);


void __RPC_STUB IObjectDaemon_IdentifyInterfaceIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectDaemon_INTERFACE_DEFINED__ */



#ifndef __ObjectDaemonLib_LIBRARY_DEFINED__
#define __ObjectDaemonLib_LIBRARY_DEFINED__

/* library ObjectDaemonLib */
/* [uuid] */ 


EXTERN_C const IID LIBID_ObjectDaemonLib;

EXTERN_C const CLSID CLSID_ObjectDaemon;

#ifdef __cplusplus

class DECLSPEC_UUID("854c3184-c854-4a77-b189-606859e4391b")
ObjectDaemon;
#endif
#endif /* __ObjectDaemonLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for mtscript.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __mtscript_h__
#define __mtscript_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRemoteMTScriptProxy_FWD_DEFINED__
#define __IRemoteMTScriptProxy_FWD_DEFINED__
typedef interface IRemoteMTScriptProxy IRemoteMTScriptProxy;
#endif 	/* __IRemoteMTScriptProxy_FWD_DEFINED__ */


#ifndef __IConnectedMachine_FWD_DEFINED__
#define __IConnectedMachine_FWD_DEFINED__
typedef interface IConnectedMachine IConnectedMachine;
#endif 	/* __IConnectedMachine_FWD_DEFINED__ */


#ifndef __IGlobalMTScript_FWD_DEFINED__
#define __IGlobalMTScript_FWD_DEFINED__
typedef interface IGlobalMTScript IGlobalMTScript;
#endif 	/* __IGlobalMTScript_FWD_DEFINED__ */


#ifndef __DLocalMTScriptEvents_FWD_DEFINED__
#define __DLocalMTScriptEvents_FWD_DEFINED__
typedef interface DLocalMTScriptEvents DLocalMTScriptEvents;
#endif 	/* __DLocalMTScriptEvents_FWD_DEFINED__ */


#ifndef __DRemoteMTScriptEvents_FWD_DEFINED__
#define __DRemoteMTScriptEvents_FWD_DEFINED__
typedef interface DRemoteMTScriptEvents DRemoteMTScriptEvents;
#endif 	/* __DRemoteMTScriptEvents_FWD_DEFINED__ */


#ifndef __LocalMTScript_FWD_DEFINED__
#define __LocalMTScript_FWD_DEFINED__

#ifdef __cplusplus
typedef class LocalMTScript LocalMTScript;
#else
typedef struct LocalMTScript LocalMTScript;
#endif /* __cplusplus */

#endif 	/* __LocalMTScript_FWD_DEFINED__ */


#ifndef __RemoteMTScript_FWD_DEFINED__
#define __RemoteMTScript_FWD_DEFINED__

#ifdef __cplusplus
typedef class RemoteMTScript RemoteMTScript;
#else
typedef struct RemoteMTScript RemoteMTScript;
#endif /* __cplusplus */

#endif 	/* __RemoteMTScript_FWD_DEFINED__ */


#ifndef __RemoteMTScriptProxy_FWD_DEFINED__
#define __RemoteMTScriptProxy_FWD_DEFINED__

#ifdef __cplusplus
typedef class RemoteMTScriptProxy RemoteMTScriptProxy;
#else
typedef struct RemoteMTScriptProxy RemoteMTScriptProxy;
#endif /* __cplusplus */

#endif 	/* __RemoteMTScriptProxy_FWD_DEFINED__ */


/* header files for imported files */

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __MTScriptEngine_LIBRARY_DEFINED__
#define __MTScriptEngine_LIBRARY_DEFINED__

/* library MTScriptEngine */
/* [version][uuid] */ 

#define	IConnectedMachine_lVersionMajor	( 0 )

#define	IConnectedMachine_lVersionMinor	( 0 )


EXTERN_C const IID LIBID_MTScriptEngine;

#ifndef __IRemoteMTScriptProxy_INTERFACE_DEFINED__
#define __IRemoteMTScriptProxy_INTERFACE_DEFINED__

/* interface IRemoteMTScriptProxy */
/* [object][dual][uuid] */ 


EXTERN_C const IID IID_IRemoteMTScriptProxy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c3181-c854-4a77-b189-606859e4391b")
    IRemoteMTScriptProxy : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [defaultvalue][in] */ BSTR bstrMachine = L"") = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ConnectToMTScript( 
            /* [defaultvalue][in] */ BSTR bstrMachine = L"",
            /* [defaultvalue][in] */ BSTR bstrIdentity = L"Build",
            /* [defaultvalue][in] */ BOOL fCreate = FALSE) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ConnectToObjectDaemon( 
            /* [defaultvalue][in] */ BSTR bstrMachine,
            /* [retval][out] */ IObjectDaemon **ppIOD) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DownloadFile( 
            /* [in] */ BSTR bstrUrl,
            /* [retval][out] */ BSTR *bstrFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteMTScriptProxyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteMTScriptProxy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteMTScriptProxy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteMTScriptProxy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRemoteMTScriptProxy * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRemoteMTScriptProxy * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRemoteMTScriptProxy * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRemoteMTScriptProxy * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IRemoteMTScriptProxy * This,
            /* [defaultvalue][in] */ BSTR bstrMachine);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ConnectToMTScript )( 
            IRemoteMTScriptProxy * This,
            /* [defaultvalue][in] */ BSTR bstrMachine,
            /* [defaultvalue][in] */ BSTR bstrIdentity,
            /* [defaultvalue][in] */ BOOL fCreate);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ConnectToObjectDaemon )( 
            IRemoteMTScriptProxy * This,
            /* [defaultvalue][in] */ BSTR bstrMachine,
            /* [retval][out] */ IObjectDaemon **ppIOD);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IRemoteMTScriptProxy * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DownloadFile )( 
            IRemoteMTScriptProxy * This,
            /* [in] */ BSTR bstrUrl,
            /* [retval][out] */ BSTR *bstrFile);
        
        END_INTERFACE
    } IRemoteMTScriptProxyVtbl;

    interface IRemoteMTScriptProxy
    {
        CONST_VTBL struct IRemoteMTScriptProxyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteMTScriptProxy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteMTScriptProxy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteMTScriptProxy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteMTScriptProxy_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRemoteMTScriptProxy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRemoteMTScriptProxy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRemoteMTScriptProxy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRemoteMTScriptProxy_Connect(This,bstrMachine)	\
    (This)->lpVtbl -> Connect(This,bstrMachine)

#define IRemoteMTScriptProxy_ConnectToMTScript(This,bstrMachine,bstrIdentity,fCreate)	\
    (This)->lpVtbl -> ConnectToMTScript(This,bstrMachine,bstrIdentity,fCreate)

#define IRemoteMTScriptProxy_ConnectToObjectDaemon(This,bstrMachine,ppIOD)	\
    (This)->lpVtbl -> ConnectToObjectDaemon(This,bstrMachine,ppIOD)

#define IRemoteMTScriptProxy_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IRemoteMTScriptProxy_DownloadFile(This,bstrUrl,bstrFile)	\
    (This)->lpVtbl -> DownloadFile(This,bstrUrl,bstrFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRemoteMTScriptProxy_Connect_Proxy( 
    IRemoteMTScriptProxy * This,
    /* [defaultvalue][in] */ BSTR bstrMachine);


void __RPC_STUB IRemoteMTScriptProxy_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRemoteMTScriptProxy_ConnectToMTScript_Proxy( 
    IRemoteMTScriptProxy * This,
    /* [defaultvalue][in] */ BSTR bstrMachine,
    /* [defaultvalue][in] */ BSTR bstrIdentity,
    /* [defaultvalue][in] */ BOOL fCreate);


void __RPC_STUB IRemoteMTScriptProxy_ConnectToMTScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRemoteMTScriptProxy_ConnectToObjectDaemon_Proxy( 
    IRemoteMTScriptProxy * This,
    /* [defaultvalue][in] */ BSTR bstrMachine,
    /* [retval][out] */ IObjectDaemon **ppIOD);


void __RPC_STUB IRemoteMTScriptProxy_ConnectToObjectDaemon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRemoteMTScriptProxy_Disconnect_Proxy( 
    IRemoteMTScriptProxy * This);


void __RPC_STUB IRemoteMTScriptProxy_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRemoteMTScriptProxy_DownloadFile_Proxy( 
    IRemoteMTScriptProxy * This,
    /* [in] */ BSTR bstrUrl,
    /* [retval][out] */ BSTR *bstrFile);


void __RPC_STUB IRemoteMTScriptProxy_DownloadFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteMTScriptProxy_INTERFACE_DEFINED__ */


#ifndef __IConnectedMachine_INTERFACE_DEFINED__
#define __IConnectedMachine_INTERFACE_DEFINED__

/* interface IConnectedMachine */
/* [object][version][dual][uuid] */ 


EXTERN_C const IID IID_IConnectedMachine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c316c-c854-4a77-b189-606859e4391b")
    IConnectedMachine : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Exec( 
            /* [in] */ BSTR bstrCmd,
            /* [in] */ BSTR bstrParams,
            /* [retval][out] */ VARIANT *pvData) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PublicData( 
            /* [retval][out] */ VARIANT *pvData) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *name) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Platform( 
            /* [retval][out] */ BSTR *platform) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OS( 
            /* [retval][out] */ BSTR *os) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVer( 
            /* [retval][out] */ long *majorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVer( 
            /* [retval][out] */ long *minorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BuildNum( 
            /* [retval][out] */ long *buildnum) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PlatformIsNT( 
            /* [retval][out] */ VARIANT_BOOL *pfIsNT) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServicePack( 
            /* [retval][out] */ BSTR *servicepack) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostMajorVer( 
            /* [retval][out] */ long *majorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostMinorVer( 
            /* [retval][out] */ long *minorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StatusValue( 
            /* [in] */ long nIndex,
            /* [retval][out] */ long *pnStatus) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateIScriptedProcess( 
            /* [in] */ long lProcessID,
            /* [string][in] */ wchar_t *pszEnvID,
            /* [retval][out] */ IScriptedProcess **pISP) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConnectedMachineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConnectedMachine * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConnectedMachine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConnectedMachine * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IConnectedMachine * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IConnectedMachine * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IConnectedMachine * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IConnectedMachine * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Exec )( 
            IConnectedMachine * This,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ BSTR bstrParams,
            /* [retval][out] */ VARIANT *pvData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PublicData )( 
            IConnectedMachine * This,
            /* [retval][out] */ VARIANT *pvData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IConnectedMachine * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Platform )( 
            IConnectedMachine * This,
            /* [retval][out] */ BSTR *platform);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OS )( 
            IConnectedMachine * This,
            /* [retval][out] */ BSTR *os);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVer )( 
            IConnectedMachine * This,
            /* [retval][out] */ long *majorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVer )( 
            IConnectedMachine * This,
            /* [retval][out] */ long *minorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BuildNum )( 
            IConnectedMachine * This,
            /* [retval][out] */ long *buildnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlatformIsNT )( 
            IConnectedMachine * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsNT);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServicePack )( 
            IConnectedMachine * This,
            /* [retval][out] */ BSTR *servicepack);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostMajorVer )( 
            IConnectedMachine * This,
            /* [retval][out] */ long *majorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostMinorVer )( 
            IConnectedMachine * This,
            /* [retval][out] */ long *minorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusValue )( 
            IConnectedMachine * This,
            /* [in] */ long nIndex,
            /* [retval][out] */ long *pnStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateIScriptedProcess )( 
            IConnectedMachine * This,
            /* [in] */ long lProcessID,
            /* [string][in] */ wchar_t *pszEnvID,
            /* [retval][out] */ IScriptedProcess **pISP);
        
        END_INTERFACE
    } IConnectedMachineVtbl;

    interface IConnectedMachine
    {
        CONST_VTBL struct IConnectedMachineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConnectedMachine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConnectedMachine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConnectedMachine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConnectedMachine_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IConnectedMachine_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IConnectedMachine_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IConnectedMachine_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IConnectedMachine_Exec(This,bstrCmd,bstrParams,pvData)	\
    (This)->lpVtbl -> Exec(This,bstrCmd,bstrParams,pvData)

#define IConnectedMachine_get_PublicData(This,pvData)	\
    (This)->lpVtbl -> get_PublicData(This,pvData)

#define IConnectedMachine_get_Name(This,name)	\
    (This)->lpVtbl -> get_Name(This,name)

#define IConnectedMachine_get_Platform(This,platform)	\
    (This)->lpVtbl -> get_Platform(This,platform)

#define IConnectedMachine_get_OS(This,os)	\
    (This)->lpVtbl -> get_OS(This,os)

#define IConnectedMachine_get_MajorVer(This,majorver)	\
    (This)->lpVtbl -> get_MajorVer(This,majorver)

#define IConnectedMachine_get_MinorVer(This,minorver)	\
    (This)->lpVtbl -> get_MinorVer(This,minorver)

#define IConnectedMachine_get_BuildNum(This,buildnum)	\
    (This)->lpVtbl -> get_BuildNum(This,buildnum)

#define IConnectedMachine_get_PlatformIsNT(This,pfIsNT)	\
    (This)->lpVtbl -> get_PlatformIsNT(This,pfIsNT)

#define IConnectedMachine_get_ServicePack(This,servicepack)	\
    (This)->lpVtbl -> get_ServicePack(This,servicepack)

#define IConnectedMachine_get_HostMajorVer(This,majorver)	\
    (This)->lpVtbl -> get_HostMajorVer(This,majorver)

#define IConnectedMachine_get_HostMinorVer(This,minorver)	\
    (This)->lpVtbl -> get_HostMinorVer(This,minorver)

#define IConnectedMachine_get_StatusValue(This,nIndex,pnStatus)	\
    (This)->lpVtbl -> get_StatusValue(This,nIndex,pnStatus)

#define IConnectedMachine_CreateIScriptedProcess(This,lProcessID,pszEnvID,pISP)	\
    (This)->lpVtbl -> CreateIScriptedProcess(This,lProcessID,pszEnvID,pISP)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_Exec_Proxy( 
    IConnectedMachine * This,
    /* [in] */ BSTR bstrCmd,
    /* [in] */ BSTR bstrParams,
    /* [retval][out] */ VARIANT *pvData);


void __RPC_STUB IConnectedMachine_Exec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_PublicData_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ VARIANT *pvData);


void __RPC_STUB IConnectedMachine_get_PublicData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_Name_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ BSTR *name);


void __RPC_STUB IConnectedMachine_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_Platform_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ BSTR *platform);


void __RPC_STUB IConnectedMachine_get_Platform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_OS_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ BSTR *os);


void __RPC_STUB IConnectedMachine_get_OS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_MajorVer_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ long *majorver);


void __RPC_STUB IConnectedMachine_get_MajorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_MinorVer_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ long *minorver);


void __RPC_STUB IConnectedMachine_get_MinorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_BuildNum_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ long *buildnum);


void __RPC_STUB IConnectedMachine_get_BuildNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_PlatformIsNT_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ VARIANT_BOOL *pfIsNT);


void __RPC_STUB IConnectedMachine_get_PlatformIsNT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_ServicePack_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ BSTR *servicepack);


void __RPC_STUB IConnectedMachine_get_ServicePack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_HostMajorVer_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ long *majorver);


void __RPC_STUB IConnectedMachine_get_HostMajorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_HostMinorVer_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ long *minorver);


void __RPC_STUB IConnectedMachine_get_HostMinorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_StatusValue_Proxy( 
    IConnectedMachine * This,
    /* [in] */ long nIndex,
    /* [retval][out] */ long *pnStatus);


void __RPC_STUB IConnectedMachine_get_StatusValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_CreateIScriptedProcess_Proxy( 
    IConnectedMachine * This,
    /* [in] */ long lProcessID,
    /* [string][in] */ wchar_t *pszEnvID,
    /* [retval][out] */ IScriptedProcess **pISP);


void __RPC_STUB IConnectedMachine_CreateIScriptedProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConnectedMachine_INTERFACE_DEFINED__ */


#ifndef __IGlobalMTScript_INTERFACE_DEFINED__
#define __IGlobalMTScript_INTERFACE_DEFINED__

/* interface IGlobalMTScript */
/* [object][local][dual][uuid] */ 


EXTERN_C const IID IID_IGlobalMTScript;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c316b-c854-4a77-b189-606859e4391b")
    IGlobalMTScript : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostMajorVer( 
            /* [retval][out] */ long *majorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostMinorVer( 
            /* [retval][out] */ long *minorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PublicData( 
            /* [retval][out] */ VARIANT *pvData) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PublicData( 
            /* [in] */ VARIANT vData) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PrivateData( 
            /* [retval][out] */ VARIANT *pvData) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PrivateData( 
            /* [in] */ VARIANT vData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ExitProcess( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Restart( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocalMachine( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Identity( 
            /* [retval][out] */ BSTR *pbstrIdentity) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Include( 
            BSTR bstrPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CallScript( 
            /* [in] */ BSTR Path,
            /* [in][optional] */ VARIANT *Param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SpawnScript( 
            /* [in] */ BSTR Path,
            /* [in][optional] */ VARIANT *Param) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptParam( 
            /* [retval][out] */ VARIANT *Param) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptPath( 
            /* [retval][out] */ BSTR *pbstrPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CallExternal( 
            /* [in] */ BSTR bstrDLLName,
            /* [in] */ BSTR bstrFunctionName,
            /* [optional][in] */ VARIANT *pParam,
            /* [retval][out] */ long *pdwRetVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResetSync( 
            /* [in] */ const BSTR bstrName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WaitForSync( 
            /* [in] */ BSTR bstrName,
            /* [in] */ long nTimeout,
            /* [retval][out] */ VARIANT_BOOL *pfSignaled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WaitForMultipleSyncs( 
            /* [in] */ const BSTR bstrNameList,
            /* [in] */ VARIANT_BOOL fWaitForAll,
            /* [in] */ long nTimeout,
            /* [retval][out] */ long *plSignal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SignalThreadSync( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TakeThreadLock( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReleaseThreadLock( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DoEvents( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MessageBoxTimeout( 
            /* [in] */ BSTR bstrMessage,
            /* [in] */ long cButtons,
            /* [in] */ BSTR bstrButtonText,
            /* [in] */ long lTimeout,
            /* [in] */ long lEventInterval,
            /* [in] */ VARIANT_BOOL fCanCancel,
            /* [in] */ VARIANT_BOOL fConfirm,
            /* [retval][out] */ long *plSelected) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RunLocalCommand( 
            /* [in] */ BSTR bstrCommand,
            /* [in] */ BSTR bstrDir,
            /* [defaultvalue][in] */ BSTR bstrTitle,
            /* [defaultvalue][in] */ VARIANT_BOOL fMinimize,
            /* [defaultvalue][in] */ VARIANT_BOOL fGetOutput,
            /* [defaultvalue][in] */ VARIANT_BOOL fWait,
            /* [defaultvalue][in] */ VARIANT_BOOL fNoCrashPopup,
            /* [defaultvalue][in] */ VARIANT_BOOL fNoEnviron,
            /* [retval][out] */ long *plProcessID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLastRunLocalError( 
            /* [retval][out] */ long *plErrorCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProcessOutput( 
            /* [in] */ long lProcessID,
            /* [retval][out] */ BSTR *pbstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProcessExitCode( 
            /* [in] */ long lProcessID,
            /* [retval][out] */ long *plExitCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TerminateProcess( 
            /* [in] */ long lProcessID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendToProcess( 
            /* [in] */ long lProcessID,
            /* [in] */ BSTR bstrType,
            /* [in] */ BSTR bstrData,
            /* [retval][out] */ long *plReturn) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendMail( 
            /* [in] */ BSTR bstrTo,
            /* [in] */ BSTR bstrCC,
            /* [in] */ BSTR bstrBCC,
            /* [in] */ BSTR bstrSubject,
            /* [in] */ BSTR bstrMessage,
            /* [defaultvalue][in] */ BSTR bstrAttachmentPath,
            /* [defaultvalue][in] */ BSTR bstrUsername,
            /* [defaultvalue][in] */ BSTR bstrPassword,
            /* [retval][out] */ long *plErrorCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendSMTPMail( 
            /* [in] */ BSTR bstrFrom,
            /* [in] */ BSTR bstrTo,
            /* [in] */ BSTR bstrCC,
            /* [in] */ BSTR bstrSubject,
            /* [in] */ BSTR bstrMessage,
            /* [in] */ BSTR bstrSMTPHost,
            /* [retval][out] */ long *plErrorCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ASSERT( 
            /* [in] */ VARIANT_BOOL Assertion,
            /* [in] */ BSTR Message) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OUTPUTDEBUGSTRING( 
            /* [in] */ BSTR Message) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnevalString( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *bstrOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CopyOrAppendFile( 
            /* [in] */ BSTR bstrSrc,
            /* [in] */ BSTR bstrDst,
            /* [in] */ long nSrcOffset,
            /* [in] */ long nSrcLength,
            /* [in] */ VARIANT_BOOL fAppend,
            /* [retval][out] */ long *nSrcFilePosition) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Sleep( 
            /* [in] */ int nTimeout) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reboot( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyScript( 
            BSTR bstrEvent,
            VARIANT vData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterEventSource( 
            /* [in] */ IDispatch *pDisp,
            /* [defaultvalue][in] */ BSTR bstrProgID = L"") = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterEventSource( 
            /* [in] */ IDispatch *pDisp) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StatusValue( 
            /* [in] */ long nIndex,
            /* [retval][out] */ long *pnStatus) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_StatusValue( 
            /* [in] */ long nIndex,
            /* [in] */ long nStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGlobalMTScriptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGlobalMTScript * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGlobalMTScript * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGlobalMTScript * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGlobalMTScript * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGlobalMTScript * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGlobalMTScript * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGlobalMTScript * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostMajorVer )( 
            IGlobalMTScript * This,
            /* [retval][out] */ long *majorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostMinorVer )( 
            IGlobalMTScript * This,
            /* [retval][out] */ long *minorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PublicData )( 
            IGlobalMTScript * This,
            /* [retval][out] */ VARIANT *pvData);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PublicData )( 
            IGlobalMTScript * This,
            /* [in] */ VARIANT vData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateData )( 
            IGlobalMTScript * This,
            /* [retval][out] */ VARIANT *pvData);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrivateData )( 
            IGlobalMTScript * This,
            /* [in] */ VARIANT vData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExitProcess )( 
            IGlobalMTScript * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Restart )( 
            IGlobalMTScript * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalMachine )( 
            IGlobalMTScript * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Identity )( 
            IGlobalMTScript * This,
            /* [retval][out] */ BSTR *pbstrIdentity);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Include )( 
            IGlobalMTScript * This,
            BSTR bstrPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CallScript )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR Path,
            /* [in][optional] */ VARIANT *Param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SpawnScript )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR Path,
            /* [in][optional] */ VARIANT *Param);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScriptParam )( 
            IGlobalMTScript * This,
            /* [retval][out] */ VARIANT *Param);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScriptPath )( 
            IGlobalMTScript * This,
            /* [retval][out] */ BSTR *pbstrPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CallExternal )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrDLLName,
            /* [in] */ BSTR bstrFunctionName,
            /* [optional][in] */ VARIANT *pParam,
            /* [retval][out] */ long *pdwRetVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ResetSync )( 
            IGlobalMTScript * This,
            /* [in] */ const BSTR bstrName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WaitForSync )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ long nTimeout,
            /* [retval][out] */ VARIANT_BOOL *pfSignaled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WaitForMultipleSyncs )( 
            IGlobalMTScript * This,
            /* [in] */ const BSTR bstrNameList,
            /* [in] */ VARIANT_BOOL fWaitForAll,
            /* [in] */ long nTimeout,
            /* [retval][out] */ long *plSignal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SignalThreadSync )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TakeThreadLock )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReleaseThreadLock )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DoEvents )( 
            IGlobalMTScript * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MessageBoxTimeout )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrMessage,
            /* [in] */ long cButtons,
            /* [in] */ BSTR bstrButtonText,
            /* [in] */ long lTimeout,
            /* [in] */ long lEventInterval,
            /* [in] */ VARIANT_BOOL fCanCancel,
            /* [in] */ VARIANT_BOOL fConfirm,
            /* [retval][out] */ long *plSelected);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RunLocalCommand )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrCommand,
            /* [in] */ BSTR bstrDir,
            /* [defaultvalue][in] */ BSTR bstrTitle,
            /* [defaultvalue][in] */ VARIANT_BOOL fMinimize,
            /* [defaultvalue][in] */ VARIANT_BOOL fGetOutput,
            /* [defaultvalue][in] */ VARIANT_BOOL fWait,
            /* [defaultvalue][in] */ VARIANT_BOOL fNoCrashPopup,
            /* [defaultvalue][in] */ VARIANT_BOOL fNoEnviron,
            /* [retval][out] */ long *plProcessID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLastRunLocalError )( 
            IGlobalMTScript * This,
            /* [retval][out] */ long *plErrorCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProcessOutput )( 
            IGlobalMTScript * This,
            /* [in] */ long lProcessID,
            /* [retval][out] */ BSTR *pbstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProcessExitCode )( 
            IGlobalMTScript * This,
            /* [in] */ long lProcessID,
            /* [retval][out] */ long *plExitCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TerminateProcess )( 
            IGlobalMTScript * This,
            /* [in] */ long lProcessID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendToProcess )( 
            IGlobalMTScript * This,
            /* [in] */ long lProcessID,
            /* [in] */ BSTR bstrType,
            /* [in] */ BSTR bstrData,
            /* [retval][out] */ long *plReturn);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendMail )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrTo,
            /* [in] */ BSTR bstrCC,
            /* [in] */ BSTR bstrBCC,
            /* [in] */ BSTR bstrSubject,
            /* [in] */ BSTR bstrMessage,
            /* [defaultvalue][in] */ BSTR bstrAttachmentPath,
            /* [defaultvalue][in] */ BSTR bstrUsername,
            /* [defaultvalue][in] */ BSTR bstrPassword,
            /* [retval][out] */ long *plErrorCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendSMTPMail )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrFrom,
            /* [in] */ BSTR bstrTo,
            /* [in] */ BSTR bstrCC,
            /* [in] */ BSTR bstrSubject,
            /* [in] */ BSTR bstrMessage,
            /* [in] */ BSTR bstrSMTPHost,
            /* [retval][out] */ long *plErrorCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ASSERT )( 
            IGlobalMTScript * This,
            /* [in] */ VARIANT_BOOL Assertion,
            /* [in] */ BSTR Message);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OUTPUTDEBUGSTRING )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR Message);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnevalString )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *bstrOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CopyOrAppendFile )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrSrc,
            /* [in] */ BSTR bstrDst,
            /* [in] */ long nSrcOffset,
            /* [in] */ long nSrcLength,
            /* [in] */ VARIANT_BOOL fAppend,
            /* [retval][out] */ long *nSrcFilePosition);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Sleep )( 
            IGlobalMTScript * This,
            /* [in] */ int nTimeout);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reboot )( 
            IGlobalMTScript * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NotifyScript )( 
            IGlobalMTScript * This,
            BSTR bstrEvent,
            VARIANT vData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventSource )( 
            IGlobalMTScript * This,
            /* [in] */ IDispatch *pDisp,
            /* [defaultvalue][in] */ BSTR bstrProgID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterEventSource )( 
            IGlobalMTScript * This,
            /* [in] */ IDispatch *pDisp);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusValue )( 
            IGlobalMTScript * This,
            /* [in] */ long nIndex,
            /* [retval][out] */ long *pnStatus);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StatusValue )( 
            IGlobalMTScript * This,
            /* [in] */ long nIndex,
            /* [in] */ long nStatus);
        
        END_INTERFACE
    } IGlobalMTScriptVtbl;

    interface IGlobalMTScript
    {
        CONST_VTBL struct IGlobalMTScriptVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGlobalMTScript_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGlobalMTScript_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGlobalMTScript_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGlobalMTScript_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGlobalMTScript_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGlobalMTScript_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGlobalMTScript_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGlobalMTScript_get_HostMajorVer(This,majorver)	\
    (This)->lpVtbl -> get_HostMajorVer(This,majorver)

#define IGlobalMTScript_get_HostMinorVer(This,minorver)	\
    (This)->lpVtbl -> get_HostMinorVer(This,minorver)

#define IGlobalMTScript_get_PublicData(This,pvData)	\
    (This)->lpVtbl -> get_PublicData(This,pvData)

#define IGlobalMTScript_put_PublicData(This,vData)	\
    (This)->lpVtbl -> put_PublicData(This,vData)

#define IGlobalMTScript_get_PrivateData(This,pvData)	\
    (This)->lpVtbl -> get_PrivateData(This,pvData)

#define IGlobalMTScript_put_PrivateData(This,vData)	\
    (This)->lpVtbl -> put_PrivateData(This,vData)

#define IGlobalMTScript_ExitProcess(This)	\
    (This)->lpVtbl -> ExitProcess(This)

#define IGlobalMTScript_Restart(This)	\
    (This)->lpVtbl -> Restart(This)

#define IGlobalMTScript_get_LocalMachine(This,pbstrName)	\
    (This)->lpVtbl -> get_LocalMachine(This,pbstrName)

#define IGlobalMTScript_get_Identity(This,pbstrIdentity)	\
    (This)->lpVtbl -> get_Identity(This,pbstrIdentity)

#define IGlobalMTScript_Include(This,bstrPath)	\
    (This)->lpVtbl -> Include(This,bstrPath)

#define IGlobalMTScript_CallScript(This,Path,Param)	\
    (This)->lpVtbl -> CallScript(This,Path,Param)

#define IGlobalMTScript_SpawnScript(This,Path,Param)	\
    (This)->lpVtbl -> SpawnScript(This,Path,Param)

#define IGlobalMTScript_get_ScriptParam(This,Param)	\
    (This)->lpVtbl -> get_ScriptParam(This,Param)

#define IGlobalMTScript_get_ScriptPath(This,pbstrPath)	\
    (This)->lpVtbl -> get_ScriptPath(This,pbstrPath)

#define IGlobalMTScript_CallExternal(This,bstrDLLName,bstrFunctionName,pParam,pdwRetVal)	\
    (This)->lpVtbl -> CallExternal(This,bstrDLLName,bstrFunctionName,pParam,pdwRetVal)

#define IGlobalMTScript_ResetSync(This,bstrName)	\
    (This)->lpVtbl -> ResetSync(This,bstrName)

#define IGlobalMTScript_WaitForSync(This,bstrName,nTimeout,pfSignaled)	\
    (This)->lpVtbl -> WaitForSync(This,bstrName,nTimeout,pfSignaled)

#define IGlobalMTScript_WaitForMultipleSyncs(This,bstrNameList,fWaitForAll,nTimeout,plSignal)	\
    (This)->lpVtbl -> WaitForMultipleSyncs(This,bstrNameList,fWaitForAll,nTimeout,plSignal)

#define IGlobalMTScript_SignalThreadSync(This,bstrName)	\
    (This)->lpVtbl -> SignalThreadSync(This,bstrName)

#define IGlobalMTScript_TakeThreadLock(This,bstrName)	\
    (This)->lpVtbl -> TakeThreadLock(This,bstrName)

#define IGlobalMTScript_ReleaseThreadLock(This,bstrName)	\
    (This)->lpVtbl -> ReleaseThreadLock(This,bstrName)

#define IGlobalMTScript_DoEvents(This)	\
    (This)->lpVtbl -> DoEvents(This)

#define IGlobalMTScript_MessageBoxTimeout(This,bstrMessage,cButtons,bstrButtonText,lTimeout,lEventInterval,fCanCancel,fConfirm,plSelected)	\
    (This)->lpVtbl -> MessageBoxTimeout(This,bstrMessage,cButtons,bstrButtonText,lTimeout,lEventInterval,fCanCancel,fConfirm,plSelected)

#define IGlobalMTScript_RunLocalCommand(This,bstrCommand,bstrDir,bstrTitle,fMinimize,fGetOutput,fWait,fNoCrashPopup,fNoEnviron,plProcessID)	\
    (This)->lpVtbl -> RunLocalCommand(This,bstrCommand,bstrDir,bstrTitle,fMinimize,fGetOutput,fWait,fNoCrashPopup,fNoEnviron,plProcessID)

#define IGlobalMTScript_GetLastRunLocalError(This,plErrorCode)	\
    (This)->lpVtbl -> GetLastRunLocalError(This,plErrorCode)

#define IGlobalMTScript_GetProcessOutput(This,lProcessID,pbstrData)	\
    (This)->lpVtbl -> GetProcessOutput(This,lProcessID,pbstrData)

#define IGlobalMTScript_GetProcessExitCode(This,lProcessID,plExitCode)	\
    (This)->lpVtbl -> GetProcessExitCode(This,lProcessID,plExitCode)

#define IGlobalMTScript_TerminateProcess(This,lProcessID)	\
    (This)->lpVtbl -> TerminateProcess(This,lProcessID)

#define IGlobalMTScript_SendToProcess(This,lProcessID,bstrType,bstrData,plReturn)	\
    (This)->lpVtbl -> SendToProcess(This,lProcessID,bstrType,bstrData,plReturn)

#define IGlobalMTScript_SendMail(This,bstrTo,bstrCC,bstrBCC,bstrSubject,bstrMessage,bstrAttachmentPath,bstrUsername,bstrPassword,plErrorCode)	\
    (This)->lpVtbl -> SendMail(This,bstrTo,bstrCC,bstrBCC,bstrSubject,bstrMessage,bstrAttachmentPath,bstrUsername,bstrPassword,plErrorCode)

#define IGlobalMTScript_SendSMTPMail(This,bstrFrom,bstrTo,bstrCC,bstrSubject,bstrMessage,bstrSMTPHost,plErrorCode)	\
    (This)->lpVtbl -> SendSMTPMail(This,bstrFrom,bstrTo,bstrCC,bstrSubject,bstrMessage,bstrSMTPHost,plErrorCode)

#define IGlobalMTScript_ASSERT(This,Assertion,Message)	\
    (This)->lpVtbl -> ASSERT(This,Assertion,Message)

#define IGlobalMTScript_OUTPUTDEBUGSTRING(This,Message)	\
    (This)->lpVtbl -> OUTPUTDEBUGSTRING(This,Message)

#define IGlobalMTScript_UnevalString(This,bstrIn,bstrOut)	\
    (This)->lpVtbl -> UnevalString(This,bstrIn,bstrOut)

#define IGlobalMTScript_CopyOrAppendFile(This,bstrSrc,bstrDst,nSrcOffset,nSrcLength,fAppend,nSrcFilePosition)	\
    (This)->lpVtbl -> CopyOrAppendFile(This,bstrSrc,bstrDst,nSrcOffset,nSrcLength,fAppend,nSrcFilePosition)

#define IGlobalMTScript_Sleep(This,nTimeout)	\
    (This)->lpVtbl -> Sleep(This,nTimeout)

#define IGlobalMTScript_Reboot(This)	\
    (This)->lpVtbl -> Reboot(This)

#define IGlobalMTScript_NotifyScript(This,bstrEvent,vData)	\
    (This)->lpVtbl -> NotifyScript(This,bstrEvent,vData)

#define IGlobalMTScript_RegisterEventSource(This,pDisp,bstrProgID)	\
    (This)->lpVtbl -> RegisterEventSource(This,pDisp,bstrProgID)

#define IGlobalMTScript_UnregisterEventSource(This,pDisp)	\
    (This)->lpVtbl -> UnregisterEventSource(This,pDisp)

#define IGlobalMTScript_get_StatusValue(This,nIndex,pnStatus)	\
    (This)->lpVtbl -> get_StatusValue(This,nIndex,pnStatus)

#define IGlobalMTScript_put_StatusValue(This,nIndex,nStatus)	\
    (This)->lpVtbl -> put_StatusValue(This,nIndex,nStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_HostMajorVer_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ long *majorver);


void __RPC_STUB IGlobalMTScript_get_HostMajorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_HostMinorVer_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ long *minorver);


void __RPC_STUB IGlobalMTScript_get_HostMinorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_PublicData_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ VARIANT *pvData);


void __RPC_STUB IGlobalMTScript_get_PublicData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_put_PublicData_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ VARIANT vData);


void __RPC_STUB IGlobalMTScript_put_PublicData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_PrivateData_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ VARIANT *pvData);


void __RPC_STUB IGlobalMTScript_get_PrivateData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_put_PrivateData_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ VARIANT vData);


void __RPC_STUB IGlobalMTScript_put_PrivateData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_ExitProcess_Proxy( 
    IGlobalMTScript * This);


void __RPC_STUB IGlobalMTScript_ExitProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_Restart_Proxy( 
    IGlobalMTScript * This);


void __RPC_STUB IGlobalMTScript_Restart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_LocalMachine_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB IGlobalMTScript_get_LocalMachine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_Identity_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ BSTR *pbstrIdentity);


void __RPC_STUB IGlobalMTScript_get_Identity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_Include_Proxy( 
    IGlobalMTScript * This,
    BSTR bstrPath);


void __RPC_STUB IGlobalMTScript_Include_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_CallScript_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR Path,
    /* [in][optional] */ VARIANT *Param);


void __RPC_STUB IGlobalMTScript_CallScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_SpawnScript_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR Path,
    /* [in][optional] */ VARIANT *Param);


void __RPC_STUB IGlobalMTScript_SpawnScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_ScriptParam_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ VARIANT *Param);


void __RPC_STUB IGlobalMTScript_get_ScriptParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_ScriptPath_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ BSTR *pbstrPath);


void __RPC_STUB IGlobalMTScript_get_ScriptPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_CallExternal_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrDLLName,
    /* [in] */ BSTR bstrFunctionName,
    /* [optional][in] */ VARIANT *pParam,
    /* [retval][out] */ long *pdwRetVal);


void __RPC_STUB IGlobalMTScript_CallExternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_ResetSync_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ const BSTR bstrName);


void __RPC_STUB IGlobalMTScript_ResetSync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_WaitForSync_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ long nTimeout,
    /* [retval][out] */ VARIANT_BOOL *pfSignaled);


void __RPC_STUB IGlobalMTScript_WaitForSync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_WaitForMultipleSyncs_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ const BSTR bstrNameList,
    /* [in] */ VARIANT_BOOL fWaitForAll,
    /* [in] */ long nTimeout,
    /* [retval][out] */ long *plSignal);


void __RPC_STUB IGlobalMTScript_WaitForMultipleSyncs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_SignalThreadSync_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IGlobalMTScript_SignalThreadSync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_TakeThreadLock_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IGlobalMTScript_TakeThreadLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_ReleaseThreadLock_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IGlobalMTScript_ReleaseThreadLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_DoEvents_Proxy( 
    IGlobalMTScript * This);


void __RPC_STUB IGlobalMTScript_DoEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_MessageBoxTimeout_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrMessage,
    /* [in] */ long cButtons,
    /* [in] */ BSTR bstrButtonText,
    /* [in] */ long lTimeout,
    /* [in] */ long lEventInterval,
    /* [in] */ VARIANT_BOOL fCanCancel,
    /* [in] */ VARIANT_BOOL fConfirm,
    /* [retval][out] */ long *plSelected);


void __RPC_STUB IGlobalMTScript_MessageBoxTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_RunLocalCommand_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrCommand,
    /* [in] */ BSTR bstrDir,
    /* [defaultvalue][in] */ BSTR bstrTitle,
    /* [defaultvalue][in] */ VARIANT_BOOL fMinimize,
    /* [defaultvalue][in] */ VARIANT_BOOL fGetOutput,
    /* [defaultvalue][in] */ VARIANT_BOOL fWait,
    /* [defaultvalue][in] */ VARIANT_BOOL fNoCrashPopup,
    /* [defaultvalue][in] */ VARIANT_BOOL fNoEnviron,
    /* [retval][out] */ long *plProcessID);


void __RPC_STUB IGlobalMTScript_RunLocalCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_GetLastRunLocalError_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ long *plErrorCode);


void __RPC_STUB IGlobalMTScript_GetLastRunLocalError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_GetProcessOutput_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long lProcessID,
    /* [retval][out] */ BSTR *pbstrData);


void __RPC_STUB IGlobalMTScript_GetProcessOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_GetProcessExitCode_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long lProcessID,
    /* [retval][out] */ long *plExitCode);


void __RPC_STUB IGlobalMTScript_GetProcessExitCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_TerminateProcess_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long lProcessID);


void __RPC_STUB IGlobalMTScript_TerminateProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_SendToProcess_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long lProcessID,
    /* [in] */ BSTR bstrType,
    /* [in] */ BSTR bstrData,
    /* [retval][out] */ long *plReturn);


void __RPC_STUB IGlobalMTScript_SendToProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_SendMail_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrTo,
    /* [in] */ BSTR bstrCC,
    /* [in] */ BSTR bstrBCC,
    /* [in] */ BSTR bstrSubject,
    /* [in] */ BSTR bstrMessage,
    /* [defaultvalue][in] */ BSTR bstrAttachmentPath,
    /* [defaultvalue][in] */ BSTR bstrUsername,
    /* [defaultvalue][in] */ BSTR bstrPassword,
    /* [retval][out] */ long *plErrorCode);


void __RPC_STUB IGlobalMTScript_SendMail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_SendSMTPMail_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrFrom,
    /* [in] */ BSTR bstrTo,
    /* [in] */ BSTR bstrCC,
    /* [in] */ BSTR bstrSubject,
    /* [in] */ BSTR bstrMessage,
    /* [in] */ BSTR bstrSMTPHost,
    /* [retval][out] */ long *plErrorCode);


void __RPC_STUB IGlobalMTScript_SendSMTPMail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_ASSERT_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ VARIANT_BOOL Assertion,
    /* [in] */ BSTR Message);


void __RPC_STUB IGlobalMTScript_ASSERT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_OUTPUTDEBUGSTRING_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR Message);


void __RPC_STUB IGlobalMTScript_OUTPUTDEBUGSTRING_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_UnevalString_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR *bstrOut);


void __RPC_STUB IGlobalMTScript_UnevalString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_CopyOrAppendFile_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrSrc,
    /* [in] */ BSTR bstrDst,
    /* [in] */ long nSrcOffset,
    /* [in] */ long nSrcLength,
    /* [in] */ VARIANT_BOOL fAppend,
    /* [retval][out] */ long *nSrcFilePosition);


void __RPC_STUB IGlobalMTScript_CopyOrAppendFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_Sleep_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ int nTimeout);


void __RPC_STUB IGlobalMTScript_Sleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_Reboot_Proxy( 
    IGlobalMTScript * This);


void __RPC_STUB IGlobalMTScript_Reboot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_NotifyScript_Proxy( 
    IGlobalMTScript * This,
    BSTR bstrEvent,
    VARIANT vData);


void __RPC_STUB IGlobalMTScript_NotifyScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_RegisterEventSource_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ IDispatch *pDisp,
    /* [defaultvalue][in] */ BSTR bstrProgID);


void __RPC_STUB IGlobalMTScript_RegisterEventSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_UnregisterEventSource_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ IDispatch *pDisp);


void __RPC_STUB IGlobalMTScript_UnregisterEventSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_StatusValue_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long nIndex,
    /* [retval][out] */ long *pnStatus);


void __RPC_STUB IGlobalMTScript_get_StatusValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_put_StatusValue_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long nIndex,
    /* [in] */ long nStatus);


void __RPC_STUB IGlobalMTScript_put_StatusValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGlobalMTScript_INTERFACE_DEFINED__ */


#ifndef __DLocalMTScriptEvents_DISPINTERFACE_DEFINED__
#define __DLocalMTScriptEvents_DISPINTERFACE_DEFINED__

/* dispinterface DLocalMTScriptEvents */
/* [uuid] */ 


EXTERN_C const IID DIID_DLocalMTScriptEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("854c316a-c854-4a77-b189-606859e4391b")
    DLocalMTScriptEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DLocalMTScriptEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DLocalMTScriptEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DLocalMTScriptEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DLocalMTScriptEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DLocalMTScriptEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DLocalMTScriptEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DLocalMTScriptEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DLocalMTScriptEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DLocalMTScriptEventsVtbl;

    interface DLocalMTScriptEvents
    {
        CONST_VTBL struct DLocalMTScriptEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DLocalMTScriptEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DLocalMTScriptEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DLocalMTScriptEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DLocalMTScriptEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DLocalMTScriptEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DLocalMTScriptEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DLocalMTScriptEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DLocalMTScriptEvents_DISPINTERFACE_DEFINED__ */


#ifndef __DRemoteMTScriptEvents_DISPINTERFACE_DEFINED__
#define __DRemoteMTScriptEvents_DISPINTERFACE_DEFINED__

/* dispinterface DRemoteMTScriptEvents */
/* [uuid] */ 


EXTERN_C const IID DIID_DRemoteMTScriptEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("854c3170-c854-4a77-b189-606859e4391b")
    DRemoteMTScriptEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DRemoteMTScriptEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DRemoteMTScriptEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DRemoteMTScriptEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DRemoteMTScriptEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DRemoteMTScriptEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DRemoteMTScriptEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DRemoteMTScriptEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DRemoteMTScriptEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DRemoteMTScriptEventsVtbl;

    interface DRemoteMTScriptEvents
    {
        CONST_VTBL struct DRemoteMTScriptEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DRemoteMTScriptEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DRemoteMTScriptEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DRemoteMTScriptEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DRemoteMTScriptEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DRemoteMTScriptEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DRemoteMTScriptEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DRemoteMTScriptEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DRemoteMTScriptEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_LocalMTScript;

#ifdef __cplusplus

class DECLSPEC_UUID("854c316e-c854-4a77-b189-606859e4391b")
LocalMTScript;
#endif

EXTERN_C const CLSID CLSID_RemoteMTScript;

#ifdef __cplusplus

class DECLSPEC_UUID("854c316d-c854-4a77-b189-606859e4391b")
RemoteMTScript;
#endif

EXTERN_C const CLSID CLSID_RemoteMTScriptProxy;

#ifdef __cplusplus

class DECLSPEC_UUID("854c3182-c854-4a77-b189-606859e4391b")
RemoteMTScriptProxy;
#endif
#endif /* __MTScriptEngine_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\devnode.c ===
//


//  DEVNODE.C
//
#include "sigverif.h"
#include <initguid.h>
#include <devguid.h>

//
// Given the full path to a driver, add it to the file list.
//
LPFILENODE 
AddDriverFileToList(
    LPTSTR lpDirName, 
    LPTSTR lpFullPathName
    )
{
    DWORD                       Err = ERROR_SUCCESS;
    LPFILENODE                  lpFileNode = NULL;
    TCHAR                       szDirName[MAX_PATH];
    TCHAR                       szFileName[MAX_PATH];
    LPTSTR                      lpFilePart;

    *szDirName  = 0;
    *szFileName = 0;

    //
    // If no directory is passed in, try to get the full path
    //
    if (!lpDirName || !*lpDirName) {

        if (GetFullPathName(lpFullPathName, cA(szDirName), szDirName, &lpFilePart)) {

            if (lpFilePart && *lpFilePart) {
                
                if (SUCCEEDED(StringCchCopy(szFileName, cA(szFileName), lpFilePart))) {
                
                    *lpFilePart = 0;
                    
                    if (lstrlen(szDirName) > 3) {
                    
                        *(lpFilePart - 1) = 0;
                    }
                } else {
                    *szFileName = 0;
                }
            }
        } else {
            *szDirName = 0;
        }

    } else { 
        
        //
        // Use the directory and filename that was passed in to us
        // Expand out lpDirName in case there are any ".." entries
        //
        if (!GetFullPathName(lpDirName, cA(szDirName), szDirName, NULL)) {
            //
            // If we can't get the full path, then just use the one
            // that was passed in. This could happen if the directory
            // is missing for instance.
            //
            if (FAILED(StringCchCopy(szDirName, cA(szDirName), lpDirName))) {
                //
                // If we can't fit the directory name into our buffer then
                // clear szDirName so this node won't be added to the list.
                //
                *szDirName = 0;
            }
        }

        if (FAILED(StringCchCopy(szFileName, cA(szFileName), lpFullPathName))) {
            //
            // If we can't fit the file name into our buffer then
            // clear szFileName so this node won't be added to the list.
            //
            *szFileName = 0;
        }
    }

    if (*szDirName && *szFileName && !IsFileAlreadyInList(szDirName, szFileName)) {
        //
        // Create a filenode, based on the directory and filename
        //
        lpFileNode = CreateFileNode(szDirName, szFileName);

        if (lpFileNode) { 

            InsertFileNodeIntoList(lpFileNode);

            //
            // Increment the total number of files we've found that meet the 
            // search criteria.
            //
            g_App.dwFiles++;
        
        } else {
            
            Err = GetLastError();
        }
    }

    SetLastError(Err);
    return lpFileNode;
}

BOOL
GetFullPathFromImagePath(
    LPCTSTR ImagePath,
    LPTSTR  FullPath,
    UINT    FullPathLength
    )
{
    TCHAR OriginalCurrentDirectory[MAX_PATH];
    LPTSTR pRelativeString;
    LPTSTR lpFilePart;

    if (!ImagePath || (ImagePath[0] == TEXT('\0'))) {
        return FALSE;
    }

    //
    // First check if the ImagePath happens to be a valid full path.
    //
    if (GetFileAttributes(ImagePath) != 0xFFFFFFFF) {
        GetFullPathName(ImagePath, FullPathLength, FullPath, &lpFilePart);
        return TRUE;
    }

    pRelativeString = (LPTSTR)ImagePath;

    //
    // If the ImagePath starts with "\SystemRoot" or "%SystemRoot%" then
    // remove those values.
    //
    if (StrCmpNI(ImagePath, TEXT("\\SystemRoot\\"), lstrlen(TEXT("\\SystemRoot\\"))) == 0) {
        pRelativeString += lstrlen(TEXT("\\SystemRoot\\"));
    } else if (StrCmpNI(ImagePath, TEXT("%SystemRoot%\\"), lstrlen(TEXT("%SystemRoot%\\"))) == 0) {
        pRelativeString += lstrlen(TEXT("%SystemRoot%\\"));
    }

    //
    // At this point pRelativeString should point to the image path relative to
    // the windows directory.
    //
    if (!GetSystemWindowsDirectory(FullPath, FullPathLength)) {
        return FALSE;
    }

    if (!GetCurrentDirectory(cA(OriginalCurrentDirectory), OriginalCurrentDirectory)) {
        OriginalCurrentDirectory[0] = TEXT('\0');
    }

    if (!SetCurrentDirectory(FullPath)) {
        return FALSE;
    }

    GetFullPathName(pRelativeString, FullPathLength, FullPath, &lpFilePart);

    if (OriginalCurrentDirectory[0] != TEXT('\0')) {
        SetCurrentDirectory(OriginalCurrentDirectory);
    }

    return TRUE;
}

DWORD
CreateFromService(
    SC_HANDLE hscManager,
    PCTSTR ServiceName
    )
{
    DWORD Err = ERROR_SUCCESS;
    SC_HANDLE hscService = NULL;
    DWORD BytesRequired, Size;
    TCHAR FullPath[MAX_PATH];
    LPQUERY_SERVICE_CONFIG pqsc;
    PBYTE BufferPtr = NULL;

    if (hscManager == NULL) {
        //
        // This should never happen.
        //
        goto clean0;
    }

    if (!ServiceName ||
        (ServiceName[0] == TEXT('\0'))) {
        //
        // This should also never happen.
        //
        goto clean0;
    }

    hscService =  OpenService(hscManager, ServiceName, GENERIC_READ);
    if (NULL == hscService) {
        //
        // This service does not exist.  We won't return an error in this case
        // since if the service doesn't exist then the driver won't get
        // loaded.
        //
        goto clean0;
    }

    //
    // First, probe for buffer size
    //
    if (!QueryServiceConfig(hscService, NULL, 0, &BytesRequired) &&
        ERROR_INSUFFICIENT_BUFFER == GetLastError()) {

        BufferPtr = MALLOC(BytesRequired);
        
        if (!BufferPtr) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        pqsc = (LPQUERY_SERVICE_CONFIG)(PBYTE)BufferPtr;

        if (QueryServiceConfig(hscService, pqsc, BytesRequired, &Size) &&
            pqsc->lpBinaryPathName &&
            (TEXT('\0') != pqsc->lpBinaryPathName[0])) {
            //
            // Make sure we have a valid full path.
            //
            if (GetFullPathFromImagePath(pqsc->lpBinaryPathName,
                                         FullPath,
                                         cA(FullPath))) {

                AddDriverFileToList(NULL, FullPath);
            }
        }

        FREE(BufferPtr);
    }

clean0:

    if (hscService) {
        CloseServiceHandle(hscService);
        hscService = NULL;
    }

    if (BufferPtr) {
        FREE(BufferPtr);
    }

    return Err;
}

UINT
ScanQueueCallback(
    PVOID Context,
    UINT Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    )
{
    LPFILENODE  lpFileNode;
    TCHAR       szBuffer[MAX_PATH];
    LPTSTR      lpFilePart;
    ULONG       BufCbSize;
    HRESULT     hr;

    UNREFERENCED_PARAMETER(Param2);

    if ((Notification == SPFILENOTIFY_QUEUESCAN_SIGNERINFO) &&
        Param1) {
        //
        // Special case for printers:
        // After setupapi copies files from the file queue into their destination
        // location, the printer class installer moves some of these files into
        // other 'special' locations.  This can lead to the callback Win32Error
        // returning ERROR_FILE_NOT_FOUND or ERROR_PATH_NOT_FOUND since the file 
        // is not present in the location where setupapi put it.  So, we will 
        // catch this case for printers and not add the file to our list of 
        // files to scan.  These 'special' printer files will get added later 
        // when we call the spooler APIs.
        // Also note that we can't just skip getting the list of files for printers
        // altogether since the printer class installer only moves some of the 
        // files that setupapi copies and not all of them.
        //
        if (Context &&
            (IsEqualGUID((LPGUID)Context, &GUID_DEVCLASS_PRINTER)) &&
            ((((PFILEPATHS_SIGNERINFO)Param1)->Win32Error == ERROR_FILE_NOT_FOUND) ||
             (((PFILEPATHS_SIGNERINFO)Param1)->Win32Error == ERROR_PATH_NOT_FOUND))) {
            //
            // Assume this was a file moved by the printer class installer.  Don't
            // add it to the list of files to be scanned at this time.
            //
            return NO_ERROR;
        }

        lpFileNode = AddDriverFileToList(NULL, 
                                         (LPTSTR)((PFILEPATHS_SIGNERINFO)Param1)->Target);

        //
        // Fill in some information into the FILENODE structure since we already
        // scanned the file.
        //
        if (lpFileNode) {
        
            lpFileNode->bScanned = TRUE;
            lpFileNode->bSigned = (((PFILEPATHS_SIGNERINFO)Param1)->Win32Error == NO_ERROR);

            if (lpFileNode->bSigned) {
        
                if (((PFILEPATHS_SIGNERINFO)Param1)->CatalogFile) {
                
                    GetFullPathName(((PFILEPATHS_SIGNERINFO)Param1)->CatalogFile, cA(szBuffer), szBuffer, &lpFilePart);
    
                    BufCbSize = (lstrlen(lpFilePart) + 1) * sizeof(TCHAR);
                    lpFileNode->lpCatalog = MALLOC(BufCbSize);
            
                    if (lpFileNode->lpCatalog) {
            
                        hr = StringCbCopy(lpFileNode->lpCatalog, BufCbSize, lpFilePart);
                    
                        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                            //
                            // If we fail for some reason other than insufficient
                            // buffer, then free the string and set the pointer
                            // to NULL, since the string is undefined.
                            //
                            FREE(lpFileNode->lpCatalog);
                            lpFileNode->lpCatalog = NULL;
                        }
                    }
                }
        
                if (((PFILEPATHS_SIGNERINFO)Param1)->DigitalSigner) {
                
                    BufCbSize = (lstrlen(((PFILEPATHS_SIGNERINFO)Param1)->DigitalSigner) + 1) * sizeof(TCHAR);
                    lpFileNode->lpSignedBy = MALLOC(BufCbSize);
            
                    if (lpFileNode->lpSignedBy) {
            
                        hr = StringCbCopy(lpFileNode->lpSignedBy, BufCbSize, ((PFILEPATHS_SIGNERINFO)Param1)->DigitalSigner);
                    
                        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                            //
                            // If we fail for some reason other than insufficient
                            // buffer, then free the string and set the pointer
                            // to NULL, since the string is undefined.
                            //
                            FREE(lpFileNode->lpSignedBy);
                            lpFileNode->lpSignedBy = NULL;
                        }
                    }
                }
        
                if (((PFILEPATHS_SIGNERINFO)Param1)->Version) {
                
                    BufCbSize = (lstrlen(((PFILEPATHS_SIGNERINFO)Param1)->Version) + 1) * sizeof(TCHAR);
                    lpFileNode->lpVersion = MALLOC(BufCbSize);
            
                    if (lpFileNode->lpVersion) {
            
                        hr = StringCbCopy(lpFileNode->lpVersion, BufCbSize, ((PFILEPATHS_SIGNERINFO)Param1)->Version);
                    
                        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                            //
                            // If we fail for some reason other than insufficient
                            // buffer, then free the string and set the pointer
                            // to NULL, since the string is undefined.
                            //
                            FREE(lpFileNode->lpVersion);
                            lpFileNode->lpVersion = NULL;
                        }
                    }
                }
    
            } else {
                // 
                // Get the icon (if the file isn't signed) so we can display it in the listview faster.
                //
                MyGetFileInfo(lpFileNode);
            }
        }
    }

    return NO_ERROR;
}

void
AddClassInstallerToList(
    LPCTSTR ClassInstallerString
    )
{
    DWORD BufferSize;
    TCHAR ModulePath[MAX_PATH];
    TCHAR TempBuffer[MAX_PATH];
    PTSTR StringPtr;

    if ((ClassInstallerString == NULL) ||
        (ClassInstallerString[0] == TEXT('\0'))) {
        return;
    }

    if (FAILED(StringCchCopy(TempBuffer, cA(TempBuffer), ClassInstallerString))) {
        return;
    }

    //
    // Class/Co-installers are always based under the %windir%\system32 
    // directory.
    //
    if (GetSystemDirectory(ModulePath, cA(ModulePath)) == 0) {
        return;
    }

    //
    // Find the beginning of the entry point name, if present.
    //
    BufferSize = (lstrlen(TempBuffer) + 1) * sizeof(TCHAR);
    for(StringPtr = TempBuffer + ((BufferSize / sizeof(TCHAR)) - 2);
        StringPtr >= TempBuffer;
        StringPtr--) {

        if(*StringPtr == TEXT(',')) {
            *(StringPtr++) = TEXT('\0');
            break;
        }
        //
        // If we hit a double-quote mark, then set the character pointer
        // to the beginning of the string so we'll terminate the search.
        //
        if(*StringPtr == TEXT('\"')) {
            StringPtr = TempBuffer;
        }
    }

    if (pSetupConcatenatePaths(ModulePath, TempBuffer, MAX_PATH, NULL)) {
        AddDriverFileToList(NULL, ModulePath);
    }
}

DWORD 
BuildDriverFileList(
    void
    )
{
    DWORD Err = ERROR_SUCCESS;
    HDEVINFO hDeviceInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DeviceInfoData;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD DeviceMemberIndex;
    HSPFILEQ hFileQueue;
    DWORD ScanResult;
    DWORD Status, Problem;
    SC_HANDLE hscManager = NULL;
    TCHAR Buffer[MAX_PATH];
    ULONG BufferSize;
    DWORD dwType;
    HKEY hKey = INVALID_HANDLE_VALUE, hKeyClassCoInstallers = INVALID_HANDLE_VALUE;
    PTSTR pItemList = NULL, pSingleItem;
    LPGUID ClassGuidList = NULL;
    DWORD i, NumberClassGuids, CurrentClassGuid;
    TCHAR GuidString[MAX_GUID_STRING_LEN];

    //
    // Build up a list of all the devices in the system.
    //
    hDeviceInfo = SetupDiGetClassDevs(NULL,
                                      NULL,
                                      NULL,
                                      DIGCF_ALLCLASSES
                                      );
    
    if (hDeviceInfo == INVALID_HANDLE_VALUE) {
        Err = GetLastError();
        goto clean0;
    }

    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    DeviceMemberIndex = 0;

    //
    // Enumerate through the list of devices and get a list of all 
    // the files they copy, if they are signed or not, and which catalog
    // signed them.
    //
    while (SetupDiEnumDeviceInfo(hDeviceInfo,
                                 DeviceMemberIndex++,
                                 &DeviceInfoData
                                 ) &&
           !g_App.bStopScan) {

        //
        // We will only build up a driver list for swenum phantoms. All other
        // phantoms will be skipped.
        //
        if (CM_Get_DevNode_Status(&Status, 
                                  &Problem, 
                                  DeviceInfoData.DevInst, 
                                  0) == CR_NO_SUCH_DEVINST) {
            //
            // This device is a phantom, if it is not a swenum device, then
            // skip it.
            //
            if (!SetupDiGetDeviceRegistryProperty(hDeviceInfo,
                                                  &DeviceInfoData,
                                                  SPDRP_ENUMERATOR_NAME,
                                                  NULL,
                                                  (PBYTE)Buffer,
                                                  sizeof(Buffer),
                                                  NULL) ||
                (_wcsicmp(Buffer, TEXT("SW")) != 0)) {
                //
                // Either we couldn't get the enumerator name, or it is not 
                // SW.
                //
                continue;
            }
        }
    
        DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);

        //
        // Before we call SetupDiBuildDriverInfoList to build up a list of drivers
        // for this device we first need to set the DI_FLAGSEX_INSTALLEDDRIVER flag
        // (which tells the API to only include the currently installed driver in
        // the list) and the DI_FLAGSEX_ALLOWEXCLUDEDRVS (allow ExcludeFromSelect
        // devices in the list).
        //
        if (SetupDiGetDeviceInstallParams(hDeviceInfo,
                                          &DeviceInfoData,
                                          &DeviceInstallParams
                                          )) {
            
            DeviceInstallParams.FlagsEx = (DI_FLAGSEX_INSTALLEDDRIVER |
                                           DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

            if (SetupDiSetDeviceInstallParams(hDeviceInfo,
                                              &DeviceInfoData,
                                              &DeviceInstallParams
                                              ) &&
                SetupDiBuildDriverInfoList(hDeviceInfo,
                                           &DeviceInfoData,
                                           SPDIT_CLASSDRIVER
                                           )) {

                //
                // Now we will get the one driver node that is in the list that
                // was just built and make it the selected driver node.
                //
                DriverInfoData.cbSize = sizeof(DriverInfoData);

                if (SetupDiEnumDriverInfo(hDeviceInfo,
                                          &DeviceInfoData,
                                          SPDIT_CLASSDRIVER,
                                          0,
                                          &DriverInfoData
                                          ) &&
                    SetupDiSetSelectedDriver(hDeviceInfo,
                                             &DeviceInfoData,
                                             &DriverInfoData
                                             )) {

                    hFileQueue = SetupOpenFileQueue();

                    if (hFileQueue != INVALID_HANDLE_VALUE) {

                        //
                        // Set the FileQueue parameter to the file queue we just 
                        // created and set the DI_NOVCP flag.
                        //
                        // The call SetupDiCallClassInstaller with DIF_INSTALLDEVICEFILES
                        // to build up a queue of all the files that are copied for
                        // this driver node.
                        //
                        DeviceInstallParams.FileQueue = hFileQueue;
                        DeviceInstallParams.Flags |= DI_NOVCP;

                        if (SetupDiSetDeviceInstallParams(hDeviceInfo,
                                                          &DeviceInfoData,
                                                          &DeviceInstallParams
                                                          ) &&
                            SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                                      hDeviceInfo,
                                                      &DeviceInfoData
                                                      )) {

                            //
                            // Scan the file queue and have it call our callback
                            // function for each file in the queue.
                            //
                            SetupScanFileQueue(hFileQueue,
                                               SPQ_SCAN_USE_CALLBACK_SIGNERINFO,
                                               NULL,
                                               ScanQueueCallback,
                                               (PVOID)&(DeviceInfoData.ClassGuid),
                                               &ScanResult
                                               );

                                                            
                            //
                            // Dereference the file queue so we can close it.
                            //
                            DeviceInstallParams.FileQueue = NULL;
                            DeviceInstallParams.Flags &= ~DI_NOVCP;
                            SetupDiSetDeviceInstallParams(hDeviceInfo,
                                                          &DeviceInfoData,
                                                          &DeviceInstallParams
                                                          );
                        }

                        SetupCloseFileQueue(hFileQueue);
                    }
                }

                SetupDiDestroyDriverInfoList(hDeviceInfo,
                                             &DeviceInfoData,
                                             SPDIT_CLASSDRIVER
                                             );
            }
        }
    }

    //
    // Enumerate through the list of devices and add any function, device 
    // upper/lower filters, and class upper/lower filter drivers to the list
    // that aren't already in the list.
    // We are doing this after we get all the files copied by the INF, because
    // these files can only be validated globally, where the INF copied files
    // can be validated using the catalog associated with their package.
    //
    hscManager = OpenSCManager(NULL, NULL, GENERIC_READ);

    if (hscManager) {
        DeviceInfoData.cbSize = sizeof(DeviceInfoData);
        DeviceMemberIndex = 0;
        while (SetupDiEnumDeviceInfo(hDeviceInfo,
                                     DeviceMemberIndex++,
                                     &DeviceInfoData
                                     ) &&
               !g_App.bStopScan) {
            //
            // Only look at SWENUM phantoms
            //
            if (CM_Get_DevNode_Status(&Status, 
                                      &Problem, 
                                      DeviceInfoData.DevInst, 
                                      0) == CR_NO_SUCH_DEVINST) {
                //
                // This device is a phantom, if it is not a swenum device, then
                // skip it.
                //
                if (!SetupDiGetDeviceRegistryProperty(hDeviceInfo,
                                                      &DeviceInfoData,
                                                      SPDRP_ENUMERATOR_NAME,
                                                      NULL,
                                                      (PBYTE)Buffer,
                                                      sizeof(Buffer),
                                                      NULL) ||
                    (_wcsicmp(Buffer, TEXT("SW")) != 0)) {
                    //
                    // Either we couldn't get the enumerator name, or it is not 
                    // SW.
                    //
                    continue;
                }
            }
    
            if (g_App.bStopScan) {
                continue;
            }
    
            //
            // Function driver.
            //
            if (SetupDiGetDeviceRegistryProperty(hDeviceInfo,
                                                 &DeviceInfoData,
                                                 SPDRP_SERVICE,
                                                 NULL,
                                                 (PBYTE)Buffer,
                                                 sizeof(Buffer),
                                                 NULL)) {
                CreateFromService(hscManager, Buffer);
            }
    
            if (g_App.bStopScan) {
                continue;
            }
    
            //
            // Upper and Lower device filters
            //
            for (i=0; i<2; i++) {
                BufferSize = 0;
                SetupDiGetDeviceRegistryProperty(hDeviceInfo,
                                                 &DeviceInfoData,
                                                 i ? SPDRP_LOWERFILTERS : SPDRP_UPPERFILTERS,
                                                 NULL,
                                                 NULL,
                                                 BufferSize,
                                                 &BufferSize);
            
                if (BufferSize > 0) {
                    pItemList = MALLOC(BufferSize + (2 * sizeof(TCHAR)));
        
                    if (!pItemList) {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
        
                    if (SetupDiGetDeviceRegistryProperty(hDeviceInfo,
                                                         &DeviceInfoData,
                                                         i ? SPDRP_LOWERFILTERS : SPDRP_UPPERFILTERS,
                                                         NULL,
                                                         (PBYTE)pItemList,
                                                         BufferSize,
                                                         &BufferSize)) {
                        for (pSingleItem=pItemList;
                             *pSingleItem;
                             pSingleItem += (lstrlen(pSingleItem) + 1)) {
    
                            CreateFromService(hscManager, pSingleItem);
                        }
                    }
    
                    FREE(pItemList);
                }
            }
    
            if (g_App.bStopScan) {
                continue;
            }
    
            //
            // Device co-installers.
            //
            hKey = SetupDiOpenDevRegKey(hDeviceInfo,
                                        &DeviceInfoData,
                                        DICS_FLAG_GLOBAL,
                                        0,
                                        DIREG_DRV,
                                        KEY_READ);
            
            if (hKey != INVALID_HANDLE_VALUE) {

                BufferSize = 0;
                RegQueryValueEx(hKey,
                                REGSTR_VAL_COINSTALLERS_32,
                                NULL,
                                &dwType,
                                NULL,
                                &BufferSize);

                if (BufferSize > 0) {
                    pItemList = MALLOC(BufferSize + (2 * sizeof(TCHAR)));
    
                    if (!pItemList) {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
    
                    dwType = REG_MULTI_SZ;
                    if (RegQueryValueEx(hKey,
                                        REGSTR_VAL_COINSTALLERS_32,
                                        NULL,
                                        &dwType,
                                        (PBYTE)pItemList,
                                        &BufferSize) == ERROR_SUCCESS) {

                        for (pSingleItem=pItemList;
                             *pSingleItem;
                             pSingleItem += (lstrlen(pSingleItem) + 1)) {
                            
                            AddClassInstallerToList(pSingleItem);
                        }
                    }

                    FREE(pItemList);
                }

                RegCloseKey(hKey);
                hKey = INVALID_HANDLE_VALUE;
            }
        }

        //
        // Enumerate through the classes so we can get the class upper and
        // lower filters and the class installers.
        //
        NumberClassGuids = 0;
        SetupDiBuildClassInfoList(0, NULL, 0, &NumberClassGuids);

        if (NumberClassGuids > 0) {
        
            ClassGuidList = MALLOC(NumberClassGuids * sizeof(GUID));

            if (!ClassGuidList) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            if (SetupDiBuildClassInfoList(0, ClassGuidList, NumberClassGuids, &NumberClassGuids)) {
                //
                // Open the class co-installer key since we will go through that
                // list while we have the class guids handy.
                //
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 REGSTR_PATH_CODEVICEINSTALLERS,
                                 0,
                                 KEY_READ,
                                 &hKeyClassCoInstallers) != ERROR_SUCCESS) {
                    hKeyClassCoInstallers = INVALID_HANDLE_VALUE;
                }
    
    
                for (CurrentClassGuid=0; CurrentClassGuid<NumberClassGuids; CurrentClassGuid++) {
                    //
                    // Open the class key.
                    //
                    hKey = SetupDiOpenClassRegKey(&(ClassGuidList[CurrentClassGuid]),
                                                  KEY_READ);
    
                    if (hKey != INVALID_HANDLE_VALUE) {
    
                        //
                        // Upper and Lower class filters
                        //
                        for (i=0; i<2; i++) {
                            BufferSize = 0;
                            RegQueryValueEx(hKey,
                                            i ? REGSTR_VAL_LOWERFILTERS : REGSTR_VAL_UPPERFILTERS,
                                            NULL,
                                            &dwType,
                                            NULL,
                                            &BufferSize);
    
                            if (BufferSize > 0) {
                                pItemList = MALLOC(BufferSize + (2 * sizeof(TCHAR)));
        
                                if (!pItemList) {
                                    Err = ERROR_NOT_ENOUGH_MEMORY;
                                    goto clean0;
                                }
        
                                dwType = REG_MULTI_SZ;
                                if (RegQueryValueEx(hKey,
                                                    i ? REGSTR_VAL_LOWERFILTERS : REGSTR_VAL_UPPERFILTERS,
                                                    NULL,
                                                    &dwType,
                                                    (PBYTE)pItemList,
                                                    &BufferSize) == ERROR_SUCCESS) {
    
                                    for (pSingleItem=pItemList;
                                         *pSingleItem;
                                         pSingleItem += (lstrlen(pSingleItem) + 1)) {
    
                                        CreateFromService(hscManager, pSingleItem);
                                    }
                                }
    
                                FREE(pItemList);
                            }
                        }
    
                        //
                        // Class installer
                        //
                        dwType = REG_SZ;
                        BufferSize = sizeof(Buffer);
                        if (RegQueryValueEx(hKey,
                                            REGSTR_VAL_INSTALLER_32,
                                            NULL,
                                            &dwType,
                                            (PBYTE)Buffer,
                                            &BufferSize) == ERROR_SUCCESS) {
                            
                            AddClassInstallerToList(Buffer);
                        }
    
                        RegCloseKey(hKey);
                        hKey = INVALID_HANDLE_VALUE;
                    }
    
                    //
                    // Class co-installers.
                    //
                    if (hKeyClassCoInstallers != INVALID_HANDLE_VALUE) {
                        if (pSetupStringFromGuid(&(ClassGuidList[CurrentClassGuid]),
                                                 GuidString,
                                                 cA(GuidString)) == ERROR_SUCCESS) {
                            BufferSize = 0;
                            RegQueryValueEx(hKeyClassCoInstallers,
                                            GuidString,
                                            NULL,
                                            &dwType,
                                            NULL,
                                            &BufferSize);
            
                            if (BufferSize > 0) {
                                pItemList = MALLOC(BufferSize + (2 * sizeof(TCHAR)));
                
                                if (!pItemList) {
                                    Err = ERROR_NOT_ENOUGH_MEMORY;
                                    goto clean0;
                                }
                
                                dwType = REG_MULTI_SZ;
                                if (RegQueryValueEx(hKeyClassCoInstallers,
                                                    GuidString,
                                                    NULL,
                                                    &dwType,
                                                    (PBYTE)pItemList,
                                                    &BufferSize) == ERROR_SUCCESS) {
            
                                    for (pSingleItem=pItemList;
                                         *pSingleItem;
                                         pSingleItem += (lstrlen(pSingleItem) + 1)) {
                                        
                                        AddClassInstallerToList(pSingleItem);
                                    }
                                }
            
                                FREE(pItemList);
                            }
                        }
                    }
                }
            }

            if (hKeyClassCoInstallers != INVALID_HANDLE_VALUE) {
                RegCloseKey(hKeyClassCoInstallers);
                hKeyClassCoInstallers = INVALID_HANDLE_VALUE;
            }

            FREE(ClassGuidList);
        }

        CloseServiceHandle(hscManager);
    }

clean0:
    if (hscManager) {
        CloseServiceHandle(hscManager);
    }

    if (pItemList) {
        FREE(pItemList);
    }

    if (ClassGuidList) {
        FREE(ClassGuidList);
    }

    if (hDeviceInfo != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(hDeviceInfo);
    }

    if (hKeyClassCoInstallers != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyClassCoInstallers);
        hKeyClassCoInstallers = INVALID_HANDLE_VALUE;
    }
    
    if (hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
        hKey = INVALID_HANDLE_VALUE;
    }

    return Err;
}

DWORD 
BuildPrinterFileList(
    void
    )
{
    DWORD           Err = ERROR_SUCCESS;
    BOOL            bRet;
    DWORD           dwBytesNeeded = 0;
    DWORD           dwDrivers = 0;
    LPBYTE          lpBuffer = NULL, lpTemp = NULL;
    LPTSTR          lpFileName;
    DRIVER_INFO_3   DriverInfo;
    PDRIVER_INFO_3  lpDriverInfo;
    TCHAR           szBuffer[MAX_PATH];
    LPFILENODE      lpFileNode = NULL;

    ZeroMemory(&DriverInfo, sizeof(DRIVER_INFO_3));
    bRet = EnumPrinterDrivers(  NULL,
                                SIGVERIF_PRINTER_ENV,
                                3,
                                (LPBYTE) &DriverInfo,
                                sizeof(DRIVER_INFO_3),
                                &dwBytesNeeded,
                                &dwDrivers);

    if (!bRet && dwBytesNeeded > 0) {
        
        lpBuffer = MALLOC(dwBytesNeeded);

        //
        // If we can't get any memory then just bail out of this function
        //
        if (!lpBuffer) {

            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
        
        bRet = EnumPrinterDrivers(  NULL,
                                    SIGVERIF_PRINTER_ENV,
                                    3,
                                    (LPBYTE) lpBuffer,
                                    dwBytesNeeded,
                                    &dwBytesNeeded,
                                    &dwDrivers);
    }

    if (dwDrivers > 0) {
        
        //
        // By default, go into the System directory, since Win9x doesn't give full paths to drivers.
        //
        GetSystemDirectory(szBuffer, cA(szBuffer));
        SetCurrentDirectory(szBuffer);

        for (lpTemp = lpBuffer; dwDrivers > 0; dwDrivers--) {
            
            lpDriverInfo = (PDRIVER_INFO_3) lpTemp;
            
            if (lpDriverInfo->pName) {
                
                if (lpDriverInfo->pDriverPath && *lpDriverInfo->pDriverPath) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pDriverPath);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }
                
                if (lpDriverInfo->pDataFile && *lpDriverInfo->pDataFile) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pDataFile);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }
                
                if (lpDriverInfo->pConfigFile && *lpDriverInfo->pConfigFile) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pConfigFile);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }
                
                if (lpDriverInfo->pHelpFile && *lpDriverInfo->pHelpFile) {
                    lpFileNode = AddDriverFileToList(NULL, lpDriverInfo->pHelpFile);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }
                }

                lpFileName = lpDriverInfo->pDependentFiles;
                
                while (lpFileName && *lpFileName) {
                    
                    lpFileNode = AddDriverFileToList(NULL, lpFileName);

                    if (lpFileNode) {
                        lpFileNode->bValidateAgainstAnyOs = TRUE;
                    }

                    for (;*lpFileName;lpFileName++);
                    lpFileName++;
                }
            }
            
            lpTemp += sizeof(DRIVER_INFO_3);
        }
    }

clean0:
    if (lpBuffer) {
    
        FREE(lpBuffer);
    }

    return Err;
}

DWORD 
BuildCoreFileList(
    void
    )
{
    DWORD Err = ERROR_SUCCESS;
    PROTECTED_FILE_DATA pfd;

    pfd.FileNumber = 0;

    while (SfcGetNextProtectedFile(NULL, &pfd)) {

        if (g_App.bStopScan) {
            Err = ERROR_CANCELLED;
            break;
        }

        AddDriverFileToList(NULL, pfd.FileName);
    }

    //
    // See if SfcGetNextProtectedFile failed from some reason other than
    // ERROR_NO_MORE_FILES.
    //
    if ((Err == ERROR_SUCCESS) &&
        (GetLastError() != ERROR_NO_MORE_FILES)) {
        //
        // SfcGetNextProtectedFile failed before we reached then end of the
        // list of protected file list. This means we won't scan all the 
        // protected files, so we should fail up front!
        //
        Err = GetLastError();
    }

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\filelist.c ===
//
//  FILELIST.C
//
#include "sigverif.h"

LPTSTR 
MyStrStr(
    LPTSTR lpString, 
    LPTSTR lpSubString
    )
{
    if (!lpString || !lpSubString) {
        return NULL;
    }

    return (StrStrI(lpString, lpSubString));
}

void 
InsertFileNodeIntoList(
    LPFILENODE lpFileNode
    )
{
    LPFILENODE  lpTempNode = g_App.lpFileList;
    LPFILENODE  lpPrevNode = NULL;
    INT         iRet;

    if (!lpFileNode) {
        return;
    }

    if (!g_App.lpFileList) {
        //
        // Initialize the global file lists
        //
        g_App.lpFileList = lpFileNode;
        g_App.lpFileLast = lpFileNode;
    
    } else {
        
        for(lpTempNode=g_App.lpFileList;lpTempNode;lpTempNode=lpTempNode->next) {
            //
            // Insert items sorted by directory and then filename
            //
            iRet = lstrcmp(lpTempNode->lpDirName, lpFileNode->lpDirName);
            if (iRet == 0) {
                //
                // If the directory names match, key off the filename
                //
                iRet = lstrcmp(lpTempNode->lpFileName, lpFileNode->lpFileName);
            }

            if (iRet >= 0) {
                
                if (!lpPrevNode) {
                    //
                    // Insert at the head of the list
                    //
                    lpFileNode->next = lpTempNode;
                    g_App.lpFileList = lpFileNode;
                    return;
                
                } else {
                    //
                    // Inserting between lpPrevNode and lpTempNode
                    //
                    lpFileNode->next = lpTempNode;
                    lpPrevNode->next = lpFileNode;
                    return;
                }
            }

            lpPrevNode = lpTempNode;
        }

        //
        // There were no matches, so insert this item at the end of the list
        //
        g_App.lpFileLast->next = lpFileNode;
        g_App.lpFileLast = lpFileNode;
    }
}

BOOL 
IsFileAlreadyInList(
    LPTSTR lpDirName, 
    LPTSTR lpFileName
    )
{
    LPFILENODE lpFileNode;

    CharLowerBuff(lpDirName, lstrlen(lpDirName));
    CharLowerBuff(lpFileName, lstrlen(lpFileName));

    for(lpFileNode=g_App.lpFileList;lpFileNode;lpFileNode=lpFileNode->next) {

        if (!lstrcmp(lpFileNode->lpFileName, lpFileName) && !lstrcmp(lpFileNode->lpDirName, lpDirName)) {
            return TRUE;
        }
    }

    return FALSE;
}

//
// Free all the memory allocated in a single File Node.
//
void 
DestroyFileNode(
    LPFILENODE lpFileNode
    )
{
    if (!lpFileNode) {
        return;
    }

    if (lpFileNode->lpFileName) {
        FREE(lpFileNode->lpFileName);
    }

    if (lpFileNode->lpDirName) {
        FREE(lpFileNode->lpDirName);
    }

    if (lpFileNode->lpVersion) {
        FREE(lpFileNode->lpVersion);
    }

    if (lpFileNode->lpCatalog) {
        FREE(lpFileNode->lpCatalog);
    }

    if (lpFileNode->lpSignedBy) {
        FREE(lpFileNode->lpSignedBy);
    }

    if (lpFileNode->lpTypeName) {
        FREE(lpFileNode->lpTypeName);
    }

    if (lpFileNode) {
        FREE(lpFileNode);
        lpFileNode = NULL;
    }
}

//
// Free all the memory allocated in the g_App.lpFileList.
//
void 
DestroyFileList(
    BOOL bClear
    )
{
    LPFILENODE lpFileNode;

    while(g_App.lpFileList) {

        lpFileNode = g_App.lpFileList->next;
        DestroyFileNode(g_App.lpFileList);
        g_App.lpFileList = lpFileNode;
    }

    g_App.lpFileLast = NULL;

    if (bClear) {
        g_App.dwFiles    = 0;
        g_App.dwSigned   = 0;
        g_App.dwUnsigned = 0;
    }
}

LPFILENODE 
CreateFileNode(
    LPTSTR lpDirectory, 
    LPTSTR lpFileName
    )
{
    DWORD                       Err = ERROR_SUCCESS;
    LPFILENODE                  lpFileNode;
    TCHAR                       szDirName[MAX_PATH];
    TCHAR                       szFullPathName[MAX_PATH];
    FILETIME                    ftLocalTime;
    WIN32_FILE_ATTRIBUTE_DATA   faData;
    BOOL                        bRet;
    ULONG                       BufCbSize;
    
    lpFileNode = (LPFILENODE) MALLOC(sizeof(FILENODE));

    if (!lpFileNode) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    BufCbSize = (lstrlen(lpFileName) + 1) * sizeof(TCHAR);
    lpFileNode->lpFileName = (LPTSTR)MALLOC(BufCbSize);

    if (!lpFileNode->lpFileName) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }
    
    StringCbCopy(lpFileNode->lpFileName, BufCbSize, lpFileName);
    CharLowerBuff(lpFileNode->lpFileName, lstrlen(lpFileNode->lpFileName));

    if (lpDirectory) {

        BufCbSize = (lstrlen(lpDirectory) + 1) * sizeof(TCHAR);
        lpFileNode->lpDirName = (LPTSTR)MALLOC(BufCbSize);
        
        if (!lpFileNode->lpDirName) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
            
        StringCbCopy(lpFileNode->lpDirName, BufCbSize, lpDirectory);
        CharLowerBuff(lpFileNode->lpDirName, lstrlen(lpFileNode->lpDirName));
    
    } else {

        if (GetCurrentDirectory(cA(szDirName), szDirName) == 0) {
            Err = GetLastError();
            goto clean0;
        }

        CharLowerBuff(szDirName, lstrlen(szDirName));

        BufCbSize = (lstrlen(szDirName) + 1) * sizeof(TCHAR);
        lpFileNode->lpDirName = (LPTSTR)MALLOC(BufCbSize);

        if (!lpFileNode->lpDirName) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
        
        StringCbCopy(lpFileNode->lpDirName, BufCbSize, szDirName);
        CharLowerBuff(lpFileNode->lpDirName, lstrlen(lpFileNode->lpDirName));
    }

    //
    // Store away the last access time for logging purposes.
    //
    if (SUCCEEDED(StringCchCopy(szFullPathName, cA(szFullPathName), lpFileNode->lpDirName)) &&
        pSetupConcatenatePaths(szFullPathName, lpFileName, cA(szFullPathName), NULL)) {
    
        ZeroMemory(&faData, sizeof(WIN32_FILE_ATTRIBUTE_DATA));

        bRet = GetFileAttributesEx(szFullPathName, GetFileExInfoStandard, &faData);
        if (bRet) {
            
            FileTimeToLocalFileTime(&faData.ftLastWriteTime, &ftLocalTime);
            FileTimeToSystemTime(&ftLocalTime, &lpFileNode->LastModified);
        }
    }

clean0:

    if (Err != ERROR_SUCCESS) {
        //
        // If we get here then we weren't able to allocate all of the memory needed
        // for this structure, so free up any memory we were able to allocate and
        // reutrn NULL.
        //
        if (lpFileNode) {
    
            if (lpFileNode->lpFileName) {
                FREE(lpFileNode->lpFileName);
            }
    
            if (lpFileNode->lpDirName) {
                FREE(lpFileNode->lpDirName);
            }
    
            FREE(lpFileNode);
        }

        lpFileNode = NULL;
    }

    SetLastError(Err);
    return lpFileNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\listview.c ===
//
// LISTVIEW.C
//
#include "sigverif.h"

HWND    g_hListView         = NULL;
HWND    g_hStatus           = NULL;
BOOL    g_bSortOrder[]      = { FALSE, FALSE, FALSE, FALSE, FALSE};
RECT    g_Rect;

//
// Initialize the image lists for the icons in the listview control.
//
BOOL WINAPI ListView_SetImageLists(HWND hwndList)
{
    SHFILEINFO      sfi;
    HIMAGELIST      himlSmall;
    HIMAGELIST      himlLarge;
    BOOL            bSuccess = TRUE;
    TCHAR           szDriveRoot[MAX_PATH];

    MyGetWindowsDirectory(szDriveRoot, cA(szDriveRoot));
    szDriveRoot[3] = 0;
    himlSmall = (HIMAGELIST)SHGetFileInfo((LPCTSTR)szDriveRoot, 
                                          0,
                                          &sfi, 
                                          sizeof(SHFILEINFO), 
                                          SHGFI_SYSICONINDEX | SHGFI_SMALLICON);

    himlLarge = (HIMAGELIST)SHGetFileInfo((LPCTSTR)szDriveRoot, 
                                          0,
                                          &sfi, 
                                          sizeof(SHFILEINFO), 
                                          SHGFI_SYSICONINDEX | SHGFI_LARGEICON);

    if (himlSmall && himlLarge) {
        ListView_SetImageList(hwndList, himlSmall, LVSIL_SMALL);
        ListView_SetImageList(hwndList, himlLarge, LVSIL_NORMAL);
    } else {
        bSuccess = FALSE;
    }

    return bSuccess;
}

//
// Insert everything from the g_App.lpFileList into the listview control.
//
void ListView_InsertItems(void)
{
    LPFILENODE  lpFileNode;
    LV_ITEM     lvi;
    TCHAR       szBuffer[MAX_PATH];
    LPTSTR      lpString;
    int         iRet;
    BOOL        bMirroredApp;
    HRESULT     hr;

    bMirroredApp = (GetWindowLong(g_App.hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    for (lpFileNode=g_App.lpFileList;lpFileNode;lpFileNode=lpFileNode->next) {

        if (lpFileNode->bScanned &&
            !lpFileNode->bSigned) {

            SetCurrentDirectory(lpFileNode->lpDirName);

            //
            // Initialize lvi and insert the filename and icon into the first column.
            //
            ZeroMemory(&lvi, sizeof(LV_ITEM));
            lvi.mask = LVIF_TEXT;
            lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvi.iImage = lpFileNode->iIcon;
            lvi.lParam = (LPARAM) lpFileNode;
            lvi.iSubItem = 0;
            lvi.pszText = lpFileNode->lpFileName;
            lvi.iItem = MAX_INT;
            lvi.iItem = ListView_InsertItem(g_hListView, &lvi);

            //
            // Insert the directory name into the second column.
            //
            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 1;
            lvi.pszText = lpFileNode->lpDirName;
            ListView_SetItem(g_hListView, &lvi);

            //
            // Get the date format, so we are localizable...
            //
            MyLoadString(szBuffer, cA(szBuffer), IDS_UNKNOWN);

            iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT, 
                                 bMirroredApp ? 
                                    DATE_RTLREADING | DATE_SHORTDATE :
                                    DATE_SHORTDATE,
                                 &lpFileNode->LastModified,
                                 NULL,
                                 NULL,
                                 0);

            if (iRet) {

                lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

                if (lpString) {

                    iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                         bMirroredApp ?
                                            DATE_RTLREADING | DATE_SHORTDATE :
                                            DATE_SHORTDATE,
                                         &lpFileNode->LastModified,
                                         NULL,
                                         lpString,
                                         iRet);

                    if (iRet) {
                        hr = StringCchCopy(szBuffer, cA(szBuffer), lpString);

                        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                            //
                            // If we failed to copy the date into our buffer for
                            // some reason other than insufficient buffer space,
                            // then set the date to the empty string.
                            //
                            szBuffer[0] = TEXT('\0');
                        }
                    }

                    FREE(lpString);
                }
            }

            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 2;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);

            //
            // Insert the filetype string into the fourth column.
            //
            if (lpFileNode->lpTypeName) {
                //
                // Since this string is just being displayed in the UI, it
                // is OK if it gets truncated.
                //
                hr = StringCchCopy(szBuffer, cA(szBuffer), lpFileNode->lpTypeName);

                if (FAILED(hr) &&
                    (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    //
                    // We encountered some error other than insufficient 
                    // buffer, so just set the buffer to the empty string, 
                    // since it value is not determined with this type of
                    // failure.
                    //
                    szBuffer[0] = TEXT('\0');
                }

            } else {
                
                MyLoadString(szBuffer, cA(szBuffer), IDS_UNKNOWN);
            }

            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 3;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);

            //
            // Insert the version string into the fifth column.
            //
            if (lpFileNode->lpVersion) {
                //
                // Since this string is just being displayed in the UI, it
                // is OK if it gets truncated.
                //
                hr = StringCchCopy(szBuffer, cA(szBuffer), lpFileNode->lpVersion);

                if (FAILED(hr) &&
                    (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    //
                    // We encountered some error other than insufficient 
                    // buffer, so just set the buffer to the empty string, 
                    // since it value is not determined with this type of
                    // failure.
                    //
                    szBuffer[0] = TEXT('\0');
                }

            } else {
                
                MyLoadString(szBuffer, cA(szBuffer), IDS_NOVERSION);
            }

            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 4;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);
        }
    }
}

//
// Initialize the listview dialog.  First, we are going to load the global icon resource.
// Then we are going to create a status window and the actual listview control.
// Then we need to add the four columns and work out their default widths.
//
BOOL ListView_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{   
    LV_COLUMN   lvc;
    RECT        rect, rectResultsText, rectStatusBar, rectCancelButton, rectClient;
    TCHAR       szBuffer[MAX_PATH];
    TCHAR       szBuffer2[MAX_PATH];
    INT         iCol = 0, iWidth = 0;
    HRESULT     hr;

    UNREFERENCED_PARAMETER(hwndFocus);
    UNREFERENCED_PARAMETER(lParam);

    //
    // Load the global icon resource
    //
    if (g_App.hIcon) {

        SetClassLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon); 
    }

    //
    // Create the status window at the bottom of the dialog
    //
    g_hStatus = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
                                   NULL,
                                   hwnd,
                                   (UINT) IDC_STATUSWINDOW);

    //
    // Load the status string and fill it in with the correct values.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_NUMFILES);
    hr = StringCchPrintf(szBuffer2, 
                         cA(szBuffer2), 
                         szBuffer,   
                         g_App.dwFiles, 
                         g_App.dwSigned, 
                         g_App.dwUnsigned, 
                         g_App.dwFiles - g_App.dwSigned - g_App.dwUnsigned);
    
    if (FAILED(hr) &&
        (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
        //
        // We encountered some error other than insufficient 
        // buffer, so just set the buffer to the empty string, 
        // since it value is not determined with this type of
        // failure.
        //
        szBuffer2[0] = TEXT('\0');
    }

    SendMessage(g_hStatus, WM_SETTEXT, (WPARAM) 0, (LPARAM) szBuffer2);

    GetWindowRect(hwnd, &g_Rect);
    GetClientRect(hwnd, &rectClient);

    //
    // Get the windows RECT values for the dialog, the static text, and the status window.
    // We will use these values to figure out where to put the listview and the columns.
    //
    GetWindowRect(hwnd, &rect);
    GetWindowRect(GetDlgItem(hwnd, IDC_RESULTSTEXT), &rectResultsText);
    GetWindowRect(g_hStatus, &rectStatusBar);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);

    MoveWindow(GetDlgItem(hwnd, IDCANCEL), 
               (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                 ? (rect.right - rect.left) - (rectCancelButton.right - rectCancelButton.left) - (rect.right - rectResultsText.right)
                 : (rect.right - rectResultsText.left) - (rectCancelButton.right - rectCancelButton.left) - (( 2 * (rectResultsText.left - rect.left)) / 3),
               (rectClient.bottom - rectClient.top) - (rectStatusBar.bottom - rectStatusBar.top) - (rectCancelButton.bottom - rectCancelButton.top) - 10,
               rectCancelButton.right - rectCancelButton.left,
               rectCancelButton.bottom - rectCancelButton.top,
               TRUE);

    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);

    //
    // Create the listview window!  I am using some really screwey logic to figure out how
    // big to make the listview and where to put it, but it seems to work.
    //
    g_hListView = CreateWindowEx(WS_EX_CLIENTEDGE, 
                                 WC_LISTVIEW, TEXT(""), 
                                 WS_TABSTOP | WS_VSCROLL | WS_VISIBLE | WS_CHILD | WS_BORDER | 
                                 LVS_SINGLESEL | LVS_REPORT | LVS_AUTOARRANGE | LVS_SHAREIMAGELISTS,
                                 ((rectResultsText.left - rect.left) * 2) / 3,
                                 (rectResultsText.bottom - rectResultsText.top) * 2,
                                 (rect.right - rect.left) - 2 * (rectResultsText.left - rect.left),
                                 rectCancelButton.top - rectResultsText.bottom - 20,
                                 hwnd, 
                                 (HMENU) IDC_LISTVIEW, 
                                 g_App.hInstance, 
                                 NULL);


    //
    // If the CreateWindowEx failed, then bail.
    //
    if (!g_hListView) {
    
        return FALSE;
    }

    //
    // Initialize the icon lists
    //
    ListView_SetImageLists(g_hListView);

    //
    // Create the first listview column for the icon and the file name.
    //
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 5;
    lvc.pszText = szBuffer;
    MyLoadString(szBuffer, cA(szBuffer), IDS_COL_NAME);
    lvc.cchTextMax = MAX_PATH;
    ListView_InsertColumn(g_hListView, iCol++, &lvc);   

    //
    // Create the second listview column for the directory name.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 4;
    MyLoadString(szBuffer, cA(szBuffer), IDS_COL_FOLDER);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Create the third listview column for the date name.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 6;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, cA(szBuffer), IDS_COL_DATE);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Create the fourth listview column for the filetype string.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) / 6;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, cA(szBuffer), IDS_COL_TYPE);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Create the fifth listview column for the version string.
    //
    iWidth += lvc.cx;
    lvc.cx = (rectResultsText.right - rectResultsText.left) - iWidth - 5;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, cA(szBuffer), IDS_COL_VERSION);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    //
    // Now that the columns are set up, insert all the files in g_App.lpFileList!
    //
    ListView_InsertItems();

    //
    // Initialize the sorting order array to all FALSE.
    //
    g_bSortOrder[0] = FALSE;
    g_bSortOrder[1] = FALSE;
    g_bSortOrder[2] = FALSE;
    g_bSortOrder[3] = FALSE;

    SetForegroundWindow(g_App.hDlg);
    SetForegroundWindow(hwnd);
    SetFocus(GetDlgItem(hwnd, IDCANCEL));

    return TRUE;
}

//
// This function checks to see how big the sizing rectangle will be.  If the user is trying
// to size the dialog to less than the values in g_Rect, then we will fix the rectangle values
//
BOOL ListView_OnSizing(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    RECT    rect;
    LPRECT  lpRect = (LPRECT) lParam;
    BOOL    bRet = FALSE;

    UNREFERENCED_PARAMETER(wParam);

    GetWindowRect(hwnd, &rect);

    if ((lpRect->right - lpRect->left) < (g_Rect.right - g_Rect.left)) {
        lpRect->left = rect.left;
        lpRect->right = lpRect->left + (g_Rect.right - g_Rect.left);
        bRet = TRUE;
    }

    if ((lpRect->bottom - lpRect->top) < (g_Rect.bottom - g_Rect.top)) {
        lpRect->top = rect.top;
        lpRect->bottom = lpRect->top + (g_Rect.bottom - g_Rect.top);
        bRet = TRUE;
    }

    return bRet;
}

//
// This function allows us to resize the listview control and status windows when the
// user resizes the results dialog.  Thankfully, we can make everything relative using
// the RECT values for the main dialog, the static text, and the status window.
//
void ListView_ResizeWindow(HWND hwnd)
{
    RECT    rect, rectResultsText, rectStatusBar, rectCancelButton, rectClient;
    BOOL    bMirroredApp;

    bMirroredApp = (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    GetWindowRect(hwnd, &rect);

    if ((rect.right - rect.left) < (g_Rect.right - g_Rect.left)) {
        
        MoveWindow(hwnd,
                   rect.left,
                   rect.top,
                   g_Rect.right - g_Rect.left,
                   rect.bottom - rect.top,
                   TRUE);
    }

    if ((rect.bottom - rect.top) < (g_Rect.bottom - g_Rect.top)) {
        
        MoveWindow(hwnd,
                   rect.left,
                   rect.top,
                   rect.right - rect.left,
                   g_Rect.bottom - g_Rect.top,
                   TRUE);
    }

    GetClientRect(hwnd, &rectClient);
    GetWindowRect(GetDlgItem(hwnd, IDC_RESULTSTEXT), &rectResultsText);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);
    GetWindowRect(g_hStatus, &rectStatusBar);


    MoveWindow(g_hStatus,
               0,
               (rect.bottom - rect.top) - (rectStatusBar.bottom - rectStatusBar.top),
               rect.right - rect.left,
               rectStatusBar.bottom - rectStatusBar.top,
               TRUE);

    MoveWindow(GetDlgItem(hwnd, IDCANCEL), 
               (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                 ? (rect.right - rect.left) - (rectCancelButton.right - rectCancelButton.left) - (rect.right - rectResultsText.right)
                 : (rect.right - rectResultsText.left) - (rectCancelButton.right - rectCancelButton.left) - (( 2 * (rectResultsText.left - rect.left)) / 3),
               (rectClient.bottom - rectClient.top) - (rectStatusBar.bottom - rectStatusBar.top) - (rectCancelButton.bottom - rectCancelButton.top) - 10,
               rectCancelButton.right - rectCancelButton.left,
               rectCancelButton.bottom - rectCancelButton.top,
               TRUE);

    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancelButton);

    MoveWindow(g_hListView,
               bMirroredApp
                 ? ((rect.right - rectResultsText.right) * 2) / 3
                 : ((rectResultsText.left - rect.left) * 2) / 3,
               (rectResultsText.bottom - rectResultsText.top) * 2,
               bMirroredApp
                 ? (rect.right - rect.left) - 2 * (rect.right - rectResultsText.right)
                 : (rect.right - rect.left) - 2 * (rectResultsText.left - rect.left),
               rectCancelButton.top - rectResultsText.bottom - 20,
               TRUE);

}

//
// This function is a callback that returns a value for ListView_SortItems.
// ListView_SortItems wants a negative, zero, or positive number.
// Since CompareString returns 1,2,3 we just subtract 2 from the return value.
//
// We use the g_bSortOrder array to figure out which way we have sorted in the past.
//
// Warning: we don't check for error values from CompareString
//
int CALLBACK ListView_CompareNames(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    LPFILENODE  lpFileNode1;
    LPFILENODE  lpFileNode2;
    FILETIME    FileTime1, FileTime2;
    int         iResult = 2;

    //
    // Depending on the sort order, we swap the order of comparison
    //
    if (g_bSortOrder[lParamSort]) {
        lpFileNode2 = (LPFILENODE) lParam1;
        lpFileNode1 = (LPFILENODE) lParam2;
    } else {
        lpFileNode1 = (LPFILENODE) lParam1;
        lpFileNode2 = (LPFILENODE) lParam2;
    }

    switch (lParamSort) {
    
    case 0: 
        //
        // We are comparing the file names
        //
        iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                lpFileNode1->lpFileName, 
                                -1, 
                                lpFileNode2->lpFileName,
                                -1);
        break;

    case 1: 
        //
        // We are comparing the directory names
        //
        iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                lpFileNode1->lpDirName, 
                                -1, 
                                lpFileNode2->lpDirName,
                                -1);
        break;

    case 2: 
        //
        // We are comparing the LastWriteTime's between the two files.
        //
        SystemTimeToFileTime(&lpFileNode1->LastModified, &FileTime1);
        SystemTimeToFileTime(&lpFileNode2->LastModified, &FileTime2);
        iResult = CompareFileTime(&FileTime1, &FileTime2);
        return iResult;

        break;

    case 3: 
        //
        // We are comparing the filetype strings
        //
        iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                lpFileNode1->lpTypeName, 
                                -1, 
                                lpFileNode2->lpTypeName,
                                -1);
        break;

    case 4: 
        //
        // We are comparing the version strings
        //
        iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                lpFileNode1->lpVersion, 
                                -1, 
                                lpFileNode2->lpVersion,
                                -1);
        break;
    }

    return(iResult - 2);
}

//
// This function handles the clicks on the column headers and calls ListView_SortItems with the
// ListView_CompareNames callback previously defined.  It then toggles the sortorder for that column.
//
LRESULT ListView_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR       *lpnmhdr = (NMHDR *) lParam;
    NM_LISTVIEW *lpnmlv = (NM_LISTVIEW *) lParam;

    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);

    switch (lpnmhdr->code) {
    
    case LVN_COLUMNCLICK:
        switch (lpnmlv->iSubItem) {
        case 0: 
        case 1:
        case 2: 
        case 3: 
        case 4: ListView_SortItems(lpnmlv->hdr.hwndFrom, ListView_CompareNames, (LPARAM) lpnmlv->iSubItem);
            g_bSortOrder[lpnmlv->iSubItem] = !(g_bSortOrder[lpnmlv->iSubItem]);
            break;
        }
        break;
    }

    return 0;
}

//
// The only thing we look for here is the IDCANCEL if the user hit ESCAPE
//
void ListView_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    UNREFERENCED_PARAMETER(hwndCtl);
    UNREFERENCED_PARAMETER(codeNotify);

    switch (id) {
    case IDCANCEL:
        SendMessage(hwnd, WM_CLOSE, 0, 0);
        break;
    }
}

INT_PTR CALLBACK ListView_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
    
    HANDLE_MSG(hwnd, WM_INITDIALOG, ListView_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, ListView_OnCommand);

    case WM_NOTIFY:
        return ListView_NotifyHandler(hwnd, uMsg, wParam, lParam);

    case WM_CLOSE:
        if (g_hStatus) {

            DestroyWindow(g_hStatus);
            g_hStatus = NULL;
        }

        if (g_hListView) {

            DestroyWindow(g_hListView);
            g_hListView = NULL;
        }

        EndDialog(hwnd, ID_CLOSE);
        break;

    case WM_SIZING:
        fProcessed = ListView_OnSizing(hwnd, wParam, lParam);
        break;

    case WM_SIZE:
        ListView_ResizeWindow(hwnd);
        break;

    default: fProcessed = FALSE;
    }

    return fProcessed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\logfile.c ===
//
// LOGFILE.C
//
#include "sigverif.h"

//
// We need to remember the previous logging state when we do toggling.
//
BOOL    g_bPrevLoggingEnabled = FALSE;

BOOL 
LogFile_OnInitDialog(
    HWND hwnd, 
    HWND hwndFocus, 
    LPARAM lParam
    )
{   
    TCHAR   szBuffer[MAX_PATH];

    UNREFERENCED_PARAMETER(hwndFocus);
    UNREFERENCED_PARAMETER(lParam);

    if (g_App.hIcon) {
        
        SetWindowLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon); 
    }

    g_App.hLogging = hwnd;

    g_bPrevLoggingEnabled = g_App.bLoggingEnabled;

    if (*g_App.szLogDir) {
        SetCurrentDirectory(g_App.szLogDir);
    } else {
        if (GetWindowsDirectory(szBuffer, cA(szBuffer))) {
            SetCurrentDirectory(szBuffer);
        }
    }
    
    SetDlgItemText(hwnd, IDC_LOGNAME, g_App.szLogFile);

    CheckDlgButton(hwnd, IDC_ENABLELOG, g_App.bLoggingEnabled ? BST_CHECKED : BST_UNCHECKED);

    EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), g_App.bLoggingEnabled && EXIST(g_App.szLogFile));

    CheckRadioButton(hwnd, IDC_OVERWRITE, IDC_APPEND, g_App.bOverwrite ? IDC_OVERWRITE : IDC_APPEND);
    EnableWindow(GetDlgItem(hwnd, IDC_APPEND), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_OVERWRITE), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_LOGNAME), g_App.bLoggingEnabled);

    SetForegroundWindow(g_App.hDlg);
    SetForegroundWindow(hwnd);

    return TRUE;
}

void 
LogFile_UpdateDialog(
    HWND hwnd
    )
{
    TCHAR szBuffer[MAX_PATH];

    if (GetDlgItemText(hwnd, IDC_LOGNAME, szBuffer, cA(szBuffer))) {

        EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), g_App.bLoggingEnabled && EXIST(szBuffer));

    } else {

        EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), FALSE);
    }

    EnableWindow(GetDlgItem(hwnd, IDC_APPEND), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_OVERWRITE), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_LOGNAME), g_App.bLoggingEnabled);
}

void 
LogFile_OnViewLog(
    HWND hwnd
    )
{
    TCHAR szDirName[MAX_PATH];
    TCHAR szFileName[MAX_PATH];

    if (!GetWindowsDirectory(szDirName, cA(szDirName))) {

        szDirName[0] = TEXT('\0');
    }

    if (*g_App.szLogDir) {
        if (FAILED(StringCchCopy(szDirName, cA(szDirName), g_App.szLogDir))) {
            szDirName[0] = TEXT('\0');
        }
    } else {
        if (!GetWindowsDirectory(szDirName, cA(szDirName))) {
            szDirName[0] = TEXT('\0');
        }
    }

    if (!GetDlgItemText(hwnd, IDC_LOGNAME, szFileName, cA(szFileName))) {
        
        MyErrorBoxId(IDS_BADLOGNAME);
        return;
    }

    ShellExecute(hwnd, NULL, szFileName, NULL, szDirName, SW_SHOW);
}

BOOL 
LogFile_VerifyLogFile(
    HWND hwnd, 
    LPTSTR lpFileName, 
    ULONG FileNameCchSize, 
    BOOL bNoisy
    )
{
    TCHAR   szFileName[MAX_PATH];
    HANDLE  hFile;
    BOOL    bRet;
    HWND    hTemp;

    ZeroMemory(szFileName, sizeof(szFileName));

    bRet = GetDlgItemText(hwnd, IDC_LOGNAME, szFileName, cA(szFileName));
    
    if (bRet) {
        
        hFile = CreateFile( szFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL, 
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        if (hFile != INVALID_HANDLE_VALUE) {
            
            CloseHandle(hFile);

        } else {
            
            hFile = CreateFile( szFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL, 
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

            if (hFile != INVALID_HANDLE_VALUE) {
                
                CloseHandle(hFile);
                DeleteFile(szFileName);

            } else {
                
                //
                // If we couldn't open an existing file and we couldn't create a new one, then we fail.
                //
                bRet = FALSE;
            }
        }
    }

    if (!bRet && bNoisy) {
        
        //
        // Since we don't want to lose focus, we are going to temporarily change g_App.hDlg.  JasKey, I apologize.
        //
        hTemp = g_App.hDlg;
        g_App.hDlg = hwnd;
        MyErrorBoxId(IDS_BADLOGNAME);
        g_App.hDlg = hTemp;
    }

    //
    // If everything worked and the user wants the file name, copy it into lpFileName
    //
    if (bRet && lpFileName && *szFileName) {
        
        if (FAILED(StringCchCopy(lpFileName, FileNameCchSize, szFileName))) {
            //
            // If we failed to copy the entire string into the callers buffer,
            // so set the callers buffer to the empty string and set the return
            // value to FALSE.
            //
            if (FileNameCchSize >= 1) {
                lpFileName[0] = TEXT('\0');
            }

            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL 
LogFile_OnOK(
    HWND hwnd
    )
{
    HKEY    hKey;
    LONG    lRes;
    DWORD   dwDisp, dwType, dwFlags, cbData;

    if (!LogFile_VerifyLogFile(hwnd, g_App.szLogFile, cA(g_App.szLogFile), FALSE)) {
        //
        // The log file could not be created.
        //
        return FALSE;
    }

    g_App.bOverwrite = IsDlgButtonChecked(hwnd, IDC_OVERWRITE);

    //
    // Look in the registry for any settings from the last SigVerif session
    //
    lRes = RegCreateKeyEx(  HKEY_CURRENT_USER,
                            SIGVERIF_KEY,
                            0,
                            NULL,
                            0,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisp);

    if (lRes == ERROR_SUCCESS) {
        
        cbData = sizeof(DWORD);
        dwFlags = 0;
        
        if (g_App.bLoggingEnabled) {
        
            dwFlags = 0x1;
        }

        if (g_App.bOverwrite) {
        
            dwFlags |= 0x2;
        }

        dwType = REG_DWORD;
        
        lRes = RegSetValueEx(   hKey,
                                SIGVERIF_FLAGS,
                                0,
                                dwType,
                                (LPBYTE) &dwFlags,
                                cbData);

        dwType = REG_SZ;
        cbData = MAX_PATH;
        
        lRes = RegSetValueEx(   hKey,
                                SIGVERIF_LOGNAME,
                                0,
                                dwType,
                                (LPBYTE) g_App.szLogFile,
                                cbData);

        RegCloseKey(hKey);
    }

    return TRUE;
}

void 
LogFile_OnCommand(
    HWND hwnd, 
    int id, 
    HWND hwndCtl, 
    UINT codeNotify
    )
{
    UNREFERENCED_PARAMETER(hwndCtl);
    UNREFERENCED_PARAMETER(codeNotify);

    switch (id) {
    
    case IDC_VIEWLOG:
        LogFile_OnViewLog(hwnd);
        break;

    case IDC_ENABLELOG:
        g_App.bLoggingEnabled = !g_App.bLoggingEnabled;
        
        //
        // Fall through to update...
        //

    default: 
        LogFile_UpdateDialog(hwnd);
    }
}

//
// This function handles any notification messages for the Search page.
//
LRESULT 
LogFile_NotifyHandler(
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    NMHDR   *lpnmhdr = (NMHDR *) lParam;
    LRESULT lResult;
    BOOL    bRet;

    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);

    switch (lpnmhdr->code) {
    
    case PSN_APPLY:         
        if (LogFile_OnOK(hwnd)) {
        
            lResult = PSNRET_NOERROR;
        
        } else {
            
            lResult = PSNRET_INVALID_NOCHANGEPAGE;
        }

        SetWindowLongPtr(hwnd,
                         DWLP_MSGRESULT,
                         (LONG_PTR) lResult);
        
        return lResult;

    case PSN_KILLACTIVE:    
        bRet = !LogFile_VerifyLogFile(hwnd, NULL, 0, TRUE);
        
        if (bRet) {
            
            SetForegroundWindow(g_App.hLogging);
            SetFocus(GetDlgItem(g_App.hLogging, IDC_LOGNAME));
        }

        SetWindowLongPtr(hwnd,
                         DWLP_MSGRESULT,
                         (LONG_PTR) bRet);
        return bRet;
    }

    return 0;
}

INT_PTR 
CALLBACK LogFile_DlgProc(
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
    HANDLE_MSG(hwnd, WM_INITDIALOG, LogFile_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, LogFile_OnCommand);

    case WM_NOTIFY:
        return LogFile_NotifyHandler(hwnd, uMsg, wParam, lParam);

    case WM_HELP:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, FALSE);
        break;

    case WM_CONTEXTMENU:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, TRUE);
        break;

    default: fProcessed = FALSE;
    }

    return fProcessed;
}

BOOL
PrintUnscannedFileListItems(
    HANDLE hFile
    )
{
    DWORD       Err = ERROR_SUCCESS;
    LPFILENODE  lpFileNode;
    TCHAR       szDirectory[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH * 2];
    TCHAR       szBuffer2[MAX_PATH];
    DWORD       dwBytesWritten;
    HRESULT     hr;

    *szDirectory = 0;

    for (lpFileNode = g_App.lpFileList;lpFileNode;lpFileNode = lpFileNode->next) {

        //
        // Make sure we only log files that have NOT been scanned.
        //
        if (!lpFileNode->bScanned) {

            //
            // Write out the directory name
            //
            if (lstrcmp(szDirectory, lpFileNode->lpDirName)) {

                hr = StringCchCopy(szDirectory, cA(szDirectory), lpFileNode->lpDirName);
                if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    
                    MyLoadString(szBuffer2, cA(szBuffer2), IDS_DIR);
                    hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szDirectory);
                    
                    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                        
                        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                            Err = GetLastError();
                        }
                    }
                }
            }

            MyLoadString(szBuffer2, cA(szBuffer2), IDS_STRING);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, lpFileNode->lpFileName);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            //
            // Print out the reason that the file was not scanned.
            //
            if (lpFileNode->LastError != ERROR_SUCCESS) {

                //
                // We will special case the error ERROR_FILE_NOT_FOUND and display
                // the text "The file is not installed." in the log file instead of
                // the default ERROR_FILE_NOT_FOUND text "The system cannot find the
                // file specified."
                //
                if (lpFileNode->LastError == ERROR_FILE_NOT_FOUND) {

                    MyLoadString(szBuffer, cA(szBuffer), IDS_FILENOTINSTALLED);
                    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                        Err = GetLastError();
                    }

                } else {
                
                    LPVOID lpLastError = NULL;
    
                    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                      FORMAT_MESSAGE_FROM_SYSTEM |
                                      FORMAT_MESSAGE_IGNORE_INSERTS,
                                      NULL,
                                      lpFileNode->LastError,
                                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                      (LPTSTR)&lpLastError,
                                      0,
                                      NULL) != 0) {
    
                        if (lpLastError) {
    
                            if (!WriteFile(hFile, (LPTSTR)lpLastError, lstrlen((LPTSTR)lpLastError) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                                Err = GetLastError();
                            }
    
                            LocalFree(lpLastError);
                        }
                    }
                }
            }
        }
    }

    MyLoadString(szBuffer, cA(szBuffer), IDS_LINEFEED);
    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }

    SetLastError(Err);
    return (Err == ERROR_SUCCESS);
}

BOOL
PrintFileListItems(
    HANDLE hFile
    )
{
    DWORD       Err = ERROR_SUCCESS;
    LPFILENODE  lpFileNode;
    TCHAR       szDirectory[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH * 2];
    TCHAR       szBuffer2[MAX_PATH];
    TCHAR       szBuffer3[MAX_PATH];
    DWORD       dwBytesWritten;
    LPTSTR      lpString;
    int         iRet;
    BOOL        bMirroredApp;
    HRESULT     hr;

    bMirroredApp = (GetWindowLong(g_App.hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    *szDirectory = 0;

    for (lpFileNode = g_App.lpFileList;lpFileNode;lpFileNode = lpFileNode->next) {
        
        //
        // Make sure we only log files that have actually been scanned.
        //
        if (lpFileNode->bScanned) {
            
            if (lstrcmp(szDirectory, lpFileNode->lpDirName)) {
                
                hr = StringCchCopy(szDirectory, cA(szDirectory), lpFileNode->lpDirName);
                if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    
                    MyLoadString(szBuffer2, cA(szBuffer2), IDS_DIR);
                    
                    hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szDirectory);
                    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                        
                        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                            Err = GetLastError();
                        }
                    }
                }
            }

            MyLoadString(szBuffer2, cA(szBuffer2), IDS_STRING);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, lpFileNode->lpFileName);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            MyLoadString(szBuffer, cA(szBuffer), IDS_SPACES);
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }

            //
            // Get the date format, so we are localizable...
            //
            MyLoadString(szBuffer2, cA(szBuffer2), IDS_UNKNOWN);
            iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT, 
                                 bMirroredApp ?
                                     DATE_RTLREADING | DATE_SHORTDATE :
                                     DATE_SHORTDATE,
                                 &lpFileNode->LastModified,
                                 NULL,
                                 NULL,
                                 0);
            if (iRet) {
                
                lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

                if (lpString) {
                    
                    iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                         bMirroredApp ?
                                             DATE_RTLREADING | DATE_SHORTDATE :
                                             DATE_SHORTDATE,
                                         &lpFileNode->LastModified,
                                         NULL,
                                         lpString,
                                         iRet);

                    if (iRet) {
                        hr = StringCchCopy(szBuffer2, cA(szBuffer2), lpString);

                        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                            //
                            // If we failed to copy the date into our buffer for
                            // some reason other than insufficient buffer space,
                            // then set the date to the empty string.
                            //
                            szBuffer2[0] = TEXT('\0');
                        }
                    }

                    FREE(lpString);
                }
            }

            MyLoadString(szBuffer3, cA(szBuffer3), IDS_STRING2);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer3, szBuffer2);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            MyLoadString(szBuffer, cA(szBuffer), IDS_SPACES);
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }

            szBuffer3[0] = TEXT('\0');
            if (lpFileNode->lpVersion && *lpFileNode->lpVersion) {
                
                hr = StringCchCopy(szBuffer3, cA(szBuffer3), lpFileNode->lpVersion);
                if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    szBuffer3[0] = TEXT('\0');
                }
            }

            if (szBuffer3[0] == TEXT('\0')) {
                //
                // We were unable to get the version of the file, or the
                // string copy routine failed for some reason, so just show
                // No version.
                //
                MyLoadString(szBuffer3, cA(szBuffer3), IDS_NOVERSION);
            }

            MyLoadString(szBuffer2, cA(szBuffer2), IDS_STRING);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szBuffer3);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            MyLoadString(szBuffer2, cA(szBuffer2), IDS_STRING);
            MyLoadString(szBuffer3, cA(szBuffer3), lpFileNode->bSigned ? IDS_SIGNED : IDS_NOTSIGNED);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szBuffer3);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            szBuffer3[0] = TEXT('\0');
            if (lpFileNode->lpCatalog) {
                
                hr = StringCchCopy(szBuffer3, cA(szBuffer3), lpFileNode->lpCatalog);
                if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    szBuffer3[0] = TEXT('\0');
                }
            }

            if (szBuffer3[0] == TEXT('\0')) {
                //
                // We were unable to get the version of the file, or the
                // string copy routine failed for some reason, so just show
                // NA.
                //
                MyLoadString(szBuffer3, cA(szBuffer3), IDS_NA);
            }

            MyLoadString(szBuffer2, cA(szBuffer2), IDS_STRING);
            hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szBuffer3);
            if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            if (lpFileNode->lpSignedBy) {
                
                if (!WriteFile(hFile, lpFileNode->lpSignedBy, lstrlen(lpFileNode->lpSignedBy) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                    Err = GetLastError();
                }
            }

            MyLoadString(szBuffer, cA(szBuffer), IDS_LINEFEED);
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }
        }
    }

    SetLastError(Err);
    return (Err == GetLastError());
}

BOOL
PrintFileList(void)
{
    DWORD           Err = ERROR_SUCCESS;
    HANDLE          hFile;
    DWORD           dwBytesWritten;
    TCHAR           szBuffer[MAX_PATH*2];
    TCHAR           szBuffer2[MAX_PATH];
    TCHAR           szBuffer3[MAX_PATH];
    LPTSTR          lpString = NULL;
    OSVERSIONINFO   osinfo;
    SYSTEM_INFO     sysinfo;
    int             iRet;
    BOOL            bMirroredApp;
    HRESULT         hr;

    bMirroredApp = (GetWindowLong(g_App.hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    //
    // Bail if logging is disabled or there's no file list
    //
    if (!g_App.bLoggingEnabled || !g_App.lpFileList) {

        SetLastError(ERROR_SUCCESS);
        return FALSE;
    }

    if (*g_App.szLogDir) {
        SetCurrentDirectory(g_App.szLogDir);
    } else {
        if (GetWindowsDirectory(szBuffer, cA(szBuffer))) {
            SetCurrentDirectory(szBuffer);
        }
    }

    hFile = CreateFile( g_App.szLogFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        
        Err = GetLastError();
        MyErrorBoxId(IDS_CANTOPENLOGFILE);
        return FALSE;
    }

    //
    // If the overwrite flag is set, truncate the file.
    //
    if (g_App.bOverwrite) {
        
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        SetEndOfFile(hFile);
    
    } else SetFilePointer(hFile, 0, NULL, FILE_END);

#ifdef UNICODE
    //
    // If we are using UNICODE, then write the 0xFF and 0xFE bytes at the beginning of the file.
    //
    if (g_App.bOverwrite || (GetFileSize(hFile, NULL) == 0)) {
        
        szBuffer[0] = 0xFEFF;
        if (!WriteFile(hFile, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }
    }
#endif

    //
    // Write the header to the logfile.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_LOGHEADER1);
    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }

    //
    // Get the date format, so we are localizable...
    //
    MyLoadString(szBuffer2, cA(szBuffer2), IDS_UNKNOWN);
    iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                         bMirroredApp ?
                             DATE_RTLREADING | DATE_SHORTDATE :
                             DATE_SHORTDATE,
                         NULL,
                         NULL,
                         NULL,
                         0
                         );
    
    if (iRet) {
        
        lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

        if (lpString) {
            
            iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                 bMirroredApp ?
                                     DATE_RTLREADING | DATE_SHORTDATE :
                                     DATE_SHORTDATE,
                                 NULL,
                                 NULL,
                                 lpString,
                                 iRet
                                 );

            if (iRet) {
                hr = StringCchCopy(szBuffer2, cA(szBuffer2), lpString);

                if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    //
                    // If we failed to copy the date into our buffer for
                    // some reason other than insufficient buffer space,
                    // then set the date to the empty string.
                    //
                    szBuffer2[0] = TEXT('\0');
                }
            }

            FREE(lpString);
        }
    }

    //
    // Get the time format, so we are localizable...
    //
    iRet = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,TIME_NOSECONDS,NULL,NULL,NULL,0);
    
    if (iRet) {
        
        lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

        if (lpString) {
            
            iRet = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,TIME_NOSECONDS,NULL,NULL,lpString,iRet);
        }
    }

    MyLoadString(szBuffer3, cA(szBuffer3), IDS_LOGHEADER2);

    if (lpString) {

        hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer3, szBuffer2, lpString);
        FREE(lpString);

    } else {
        
        hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer3, szBuffer2, szBuffer2);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }
    }

    //
    // Get the OS Platform string for the log file.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_OSPLATFORM);
    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }

    ZeroMemory(&osinfo, sizeof(OSVERSIONINFO));
    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osinfo);

    switch (osinfo.dwPlatformId) {
    
    case VER_PLATFORM_WIN32_NT:         
        MyLoadString(szBuffer, cA(szBuffer), IDS_WINNT); 
        break;

    default:                            
        MyLoadString(szBuffer, cA(szBuffer), IDS_UNKNOWN);
        break;
    }

    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }

    //
    // If this is NT, then get the processor architecture and log it
    //
    if (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        
        ZeroMemory(&sysinfo, sizeof(SYSTEM_INFO));
        GetSystemInfo(&sysinfo);
        
        //
        // Initialize szBuffer to zeroes in case of an unknown architecture
        //
        ZeroMemory(szBuffer, sizeof(szBuffer));
        
        switch (sysinfo.wProcessorArchitecture) {
        
        case PROCESSOR_ARCHITECTURE_INTEL:  
            MyLoadString(szBuffer, cA(szBuffer), IDS_X86); 
            break;

        case PROCESSOR_ARCHITECTURE_IA64:
            MyLoadString(szBuffer, cA(szBuffer), IDS_IA64);
            break;
        }

        if (*szBuffer) {
            //
            // Now write the processor type to the file
            //
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }
        }
    }

    //
    // Get the OS Version, Build, and CSD information and log it.
    //
    MyLoadString(szBuffer2, cA(szBuffer2), IDS_OSVERSION);
    
    hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, osinfo.dwMajorVersion, osinfo.dwMinorVersion, (osinfo.dwBuildNumber & 0xFFFF), osinfo.szCSDVersion);
    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
        
        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }
    }

    //
    // Print out the total/signed/unsigned results right before the file list
    //
    MyLoadString(szBuffer2, cA(szBuffer2), IDS_TOTALS);
    hr = StringCchPrintf(szBuffer, 
                         cA(szBuffer), 
                         szBuffer2,   
                         g_App.dwFiles, 
                         g_App.dwSigned, 
                         g_App.dwUnsigned, 
                         g_App.dwFiles - g_App.dwSigned - g_App.dwUnsigned);
    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
        
        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }
    }

    //
    // If we are doing a user-defined search, then log the parameters.
    //
    if (g_App.bUserScan) {
        //
        // Write the user-specified directory
        //
        MyLoadString(szBuffer2, cA(szBuffer2), IDS_LOGHEADER3);
        
        hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, g_App.szScanPattern);
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
            
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }
        }

        //
        // Write the user-specified search pattern
        //
        MyLoadString(szBuffer2, cA(szBuffer2), IDS_LOGHEADER4);
        
        hr = StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, g_App.szScanPath);
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
            
            if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
                Err = GetLastError();
            }
        }
    }

    //
    // Write the column headers to the log file
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_LOGHEADER5);
    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }
    
    MyLoadString(szBuffer, cA(szBuffer), IDS_LOGHEADER6);
    if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
        Err = GetLastError();
    }
    
    if (!PrintFileListItems(hFile)) {
        Err = GetLastError();
    }

    //
    // Write the unscanned file headers to the log file
    //
    if (g_App.dwFiles > (g_App.dwSigned + g_App.dwUnsigned)) {
        
        MyLoadString(szBuffer, cA(szBuffer), IDS_LOGHEADER7);
        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }
        
        MyLoadString(szBuffer, cA(szBuffer), IDS_LOGHEADER8);
        if (!WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL)) {
            Err = GetLastError();
        }

        if (!PrintUnscannedFileListItems(hFile)) {
            Err = GetLastError();
        }
    }

    CloseHandle(hFile);

    SetLastError(Err);
    return (Err == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\progress.c ===
/*****************************************************************************
 *
 *  Progress.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Our private progress control (because commctrl might be damanged)
 *
 *  Contents:
 *
 *      Progress_Init
 *
 *****************************************************************************/
#include "sigverif.h"

/***************************************************************************
 *
 *  GWL_* for Progress goo.
 *
 ***************************************************************************/

#define GWL_CUR             GWLP_USERDATA

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | Progress_GetRectPos |
 *
 *          Compute the position within the drawing rectangle that
 *          corresponds to the current position.
 *
 *          This is basically a MulDiv, except that we don't let the
 *          bar get all the way to 100% unless it really means it.
 *
 *
 ***************************************************************************/

int 
Progress_GetRectPos(
    int cx, 
    int iCur, 
    int iMax
    )
{
    int iRc;

    if (iCur != iMax) {
        iRc = MulDiv(cx, iCur, iMax);
    } else {
        iRc = cx;
    }

    return iRc;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_OnPaint |
 *
 *          Draw the first part in the highlight colors.
 *
 *          Draw the second part in the 3dface colors.
 *
 ***************************************************************************/

void 
Progress_OnPaint(
    HWND hwnd
    )
{
    HDC hdc;
    PAINTSTRUCT ps;
    HRESULT hr;

    hdc = BeginPaint(hwnd, &ps);
    if (hdc) {
        UINT taPrev;
        RECT rc;
        int cx;
        COLORREF clrTextPrev, clrBackPrev;
        int iCur, iMax, iPct;
        int ctch;
        HFONT hfPrev;
        TCHAR tsz[256];
        SIZE size;

        //
        //  Set up the DC generically.
        //
        taPrev = SetTextAlign(hdc, TA_CENTER | TA_TOP);
        hfPrev = SelectFont(hdc, GetWindowFont(GetParent(hwnd)));

        //
        //  Set up the colors for the left-hand side.
        //
        clrTextPrev = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        clrBackPrev = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));

        //
        //  Now do some math.
        //
        GetClientRect(hwnd, &rc);

        cx = rc.right;

        iCur = LOWORD(GetWindowLong(hwnd, GWL_CUR));
        iMax = HIWORD(GetWindowLong(hwnd, GWL_CUR));

        if (iMax == 0) {
            iMax = 1;           /* Avoid divide by zero */
        }

        if (iCur > 0) {

            iPct = (iCur * 100) / iMax;
            if (iPct < 1) {
                iPct = 1;
            }
        } else {
            iPct = 0;
        }

        rc.right = Progress_GetRectPos(cx, iCur, iMax);

        //
        // Update the percentage text in the progress bar.
        //
        hr = StringCchPrintf(tsz, cA(tsz), TEXT("%d%%"), iPct);
        if (FAILED(hr) && (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
            tsz[0] = TEXT('\0');
        }
        
        for(ctch=0;tsz[ctch];ctch++);

        //
        //  Draw the left-hand side.
        //
        if (!GetTextExtentPoint32(hdc, tsz, ctch, &size)) {

            ExtTextOut( hdc, cx/2, 1, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        
        } else {
            
            ExtTextOut( hdc, cx/2, (rc.bottom - rc.top - size.cy + 1) / 2, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        }

        //
        //  Now set up for the right-hand side.
        //
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

        rc.left = rc.right;
        rc.right = cx;

        //
        //  Draw the right-hand side.
        //
        if (!GetTextExtentPoint32(hdc, tsz, ctch, &size)) {

            ExtTextOut( hdc, cx/2, 1, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        
        } else {

            ExtTextOut( hdc, cx/2, (rc.bottom - rc.top - size.cy + 1) / 2, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        }

        SetBkColor(hdc, clrBackPrev);
        SetTextColor(hdc, clrTextPrev);
        SelectFont(hdc, hfPrev);
        SetTextAlign(hdc, taPrev);

        EndPaint(hwnd, &ps);
    }
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_OnSetPos |
 *
 *          Update the state and invalidate the section that is affected.
 *
 ***************************************************************************/

void 
Progress_OnSetPos(
    HWND hwnd, 
    WPARAM wp
    )
{
    int iCur, iMax;
    RECT rc;
    LONG lState = GetWindowLong(hwnd, GWL_CUR);


    GetClientRect(hwnd, &rc);

    iCur = LOWORD(GetWindowLong(hwnd, GWL_CUR));
    iMax = HIWORD(GetWindowLong(hwnd, GWL_CUR));

    if (iMax == 0) {
        iMax = 1;           /* Avoid divide by zero */
    }

    rc.left = Progress_GetRectPos(rc.right, iCur, iMax);
    rc.right = Progress_GetRectPos(rc.right, (int)wp, iMax);

    InvalidateRect(hwnd, 0, 0);

    SetWindowLong(hwnd, GWL_CUR, MAKELONG(wp,HIWORD(lState)));
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_WndProc |
 *
 *          There really isn't much to do.
 *
 *          The string is our window text (which Windows manages for us).
 *
 *          The progress bar itself is kept in the high/low words of
 *          our GWL_USERDATA.
 *
 *          HIWORD(GetWindowLong(GWL_USERDATA)) = maximum
 *          LOWORD(GetWindowLong(GWL_USERDATA)) = current value
 *
 ***************************************************************************/

LRESULT CALLBACK
Progress_WndProc(
    HWND hwnd, 
    UINT wm, 
    WPARAM wp, 
    LPARAM lp
    )
{
    switch (wm) {

    case WM_PAINT:
        Progress_OnPaint(hwnd);
        return 0;

    //
    //  When the range resets, invalidate so we repaint.
    //
    //  wp = new current pos
    //  lp = new range
    //
    case PBM_SETRANGE:
        lp = HIWORD(lp);
        SetWindowLong(hwnd, GWL_CUR, MAKELONG(wp, lp));
        /* FALLTHROUGH */

    case PBM_SETPOS:
        Progress_OnSetPos(hwnd, wp);
        break;

    case PBM_DELTAPOS:
        lp = LOWORD(GetWindowLong(hwnd, GWL_CUR));
        Progress_OnSetPos(hwnd, wp + lp);
        break;

    case WM_ERASEBKGND:
        return 0;
    }

    return DefWindowProc(hwnd, wm, wp, lp);
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Progress_InitRegisterClass |
 *
 *          Register our window classes.
 *
 ***************************************************************************/

void 
Progress_InitRegisterClass(void)
{
    WNDCLASS wc;

    //
    //  Progress control.
    //
    wc.style = 0;
    wc.lpfnWndProc = Progress_WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = cbX(DWORD);
    wc.hInstance = g_App.hInstance;
    wc.hIcon = 0;
    wc.hCursor = LoadCursor(0, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BACKGROUND);
    wc.lpszMenuName = 0;
    wc.lpszClassName = TEXT("progress");

    RegisterClass(&wc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\resource.h ===
#define IDS_COL_NAME                    1
#define IDS_COL_FOLDER                  2
#define IDS_COL_TYPE                    4
#define IDS_COL_VERSION                 5
#define IDS_COL_SIGNEDBY                6
#define IDS_COL_DATE                    7
#define IDS_NOPROBLEMS                  9
#define IDS_ALLSIGNED                   10
#define IDS_MSGBOX                      11
#define IDS_ERRORBOX                    12
#define IDS_NUMFILES                    13
#define IDS_SIGNED                      14
#define IDS_NOTSIGNED                   15
#define IDS_NOFILES                     16
#define IDS_STOP                        17
#define IDS_START                       18
#define IDS_ALL                         19
#define IDS_EXE                         20
#define IDS_SYS                         21
#define IDS_OCX                         22
#define IDS_DLL                         23
#define IDS_DRV                         24
#define IDS_BADDIR                      25
#define IDS_FILENOTINSTALLED            26
#define IDS_SELECTDIR                   29
#define IDS_SCANSTOPPED                 30
#define IDS_NOVERSION                   31
#define IDS_LOGNAME                     32
#define IDS_BADLOGNAME                  33
#define IDS_CANTOPENLOGFILE             34
#define IDS_LOGHEADER1                  35
#define IDS_LOGHEADER2                  36
#define IDS_LOGHEADER3                  37
#define IDS_LOGHEADER4                  38
#define IDS_LOGHEADER5                  39
#define IDS_LOGHEADER6                  40
#define IDS_LOGHEADER7                  41
#define IDS_DIR                         42
#define IDS_VERSION                     43
#define IDS_STRING                      44
#define IDS_OSPLATFORM                  45
#define IDS_OSVERSION                   46
#define IDS_WINNT                       47
#define IDS_UNKNOWN                     50
#define IDS_NA                          51
#define IDS_LINEFEED                    52
#define IDS_SPACES                      53
#define IDS_FILETYPE                    54
#define IDS_FILE                        55
#define IDS_NOSYSTEMFILES               59
#define IDS_COPYFILES                   65
#define IDS_MASTERFILELIST              68
#define IDS_LOGHEADER8                  69
#define IDS_STRING_LINEFEED             70
#define IDS_TOTALS                      73
#define IDS_SIGVERIF                    76
#define IDS_STRING2                     80
#define IDS_STATUS_BUILD                83
#define IDS_STATUS_FREE                 84
#define IDS_STATUS_LOG                  85
#define IDS_STATUS_SCAN                 86
#define IDS_ADVANCED_SETTINGS           87
#define IDS_SEARCHTAB                   88
#define IDS_LOGGINGTAB                  89
#define IDS_X86                         90
#define IDS_IA64                        91
#define IDS_FULLSCAN                    98
#define IDS_DEFSCAN                     99
#define IDS_LOGDIR                      100
#define IDD_DIALOG                      101
#define IDI_ICON1                       102
#define IDB_BITMAP1                     102
#define IDD_DETAILS                     103
#define IDD_RESULTS                     104
#define IDD_SETTINGS                    105
#define IDD_ADVANCED                    106
#define IDD_SEARCH                      107
#define IDS_INVALID_FOLDER              108
#define IDS_LOGERROR                    109
#define IDS_LOGDIRERROR                 110
#define IDS_FULLSCANERROR               111
#define IDS_BUILDLISTERROR              112
#define ID_VIEWLOG                      1000
#define IDC_BITMAP                      1000
#define IDC_FOLDER                      1001
#define IDC_TEXT                        1001
#define IDC_SCAN                        1002
#define IDC_NOTMS                       1003
#define IDC_SUBFOLDERS                  1004
#define ID_CLOSE                        1005
#define ID_START                        1006
#define ID_BROWSE                       1007
#define IDC_PROGRESS                    1008
#define IDC_LISTVIEW                    1009
#define IDC_STATUSWINDOW                1010
#define ID_SETTINGS                     1011
#define ID_ADVANCED                     1011
#define IDC_TYPE                        1013
#define IDC_FREELIST                    1014
#define ID_DETAILS_OK                   1015
#define ID_DETAILS                      1016
#define IDC_RESULTSTEXT                 1017
#define IDC_LOGNAME                     1018
#define IDC_OVERWRITE                   1019
#define IDC_APPEND                      1020
#define IDC_ENABLELOG                   1021
#define IDC_VIEWLOG                     1022
#define IDC_TAB1                        1023
#define IDC_STATUS                      1024
#define IDC_INFOTEXT                    1025


//
// Version Information
//
#include <winver.h>
#include <ntverp.h>
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "File Signature Verification"
#define VER_INTERNALNAME_STR            "sigverif.exe"
#define VER_ORIGINALFILENAME_STR        "sigverif.exe"
#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\sigverif.h ===
//
//  SIGVERIF.H
//
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#pragma warning( disable : 4115 ) // named type definition in parentheses

#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <commctrl.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <spapip.h>
#include <sputils.h>
#include <tchar.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <winspool.h>
#include <imagehlp.h>
#include <capi.h>
#include <softpub.h>
#include <sfc.h>
#include <regstr.h>
#include <strsafe.h>
#include "resource.h"

#pragma warning( default : 4115 )
#pragma warning( default : 4201 )

// Macros and pre-defined values
#define     cbX(X)      sizeof(X)
#define     cA(a)       (cbX(a)/cbX(a[0]))
#define     MALLOC(x)   HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (x))
#define     FREE(x)     if (x) { HeapFree(GetProcessHeap(), 0, (x)); x = NULL; }
#define     EXIST(x)    (GetFileAttributes(x) != 0xFFFFFFFF)
#define     MAX_INT     0x7FFFFFFF
#define     HASH_SIZE   100
#define     NUM_PAGES   2

// Registry key/value names for storing previous settings
#define     SIGVERIF_KEY        TEXT("Software\\Microsoft\\Sigverif")
#define     SIGVERIF_FLAGS      TEXT("Flags")
#define     SIGVERIF_LOGNAME    TEXT("Logname")

#define SIGVERIF_PRINTER_ENV	TEXT("All")

// This structure holds all the information for a specific file.
typedef struct tagFileNode
{
    LPTSTR          lpFileName;
    LPTSTR          lpDirName;
    LPTSTR          lpVersion;
    LPTSTR          lpCatalog;
    LPTSTR          lpSignedBy;
    LPTSTR          lpTypeName;
    INT             iIcon;
    BOOL            bSigned;
    BOOL            bScanned;
    BOOL            bValidateAgainstAnyOs;
    DWORD           LastError;
    SYSTEMTIME      LastModified;
    struct  tagFileNode *next;
} FILENODE, *LPFILENODE;

// This structure is used by walkpath to keep track of subdirectories
typedef struct tagDirNode {
    TCHAR   DirName[MAX_PATH];
    struct  tagDirNode *next;
} DIRNODE, *LPDIRNODE;

// This structure is used when we walk the devicemanager list.
typedef struct _DeviceTreeNode 
{
    struct _DeviceTreeNode *Child;
    struct _DeviceTreeNode *Sibling;
    DEVINST    DevInst;
    TCHAR      Driver[MAX_PATH];
} DEVTREENODE, *PDEVTREENODE;

typedef struct _DeviceTreeData 
{
    HDEVINFO hDeviceInfo;
    DEVTREENODE RootNode;
} DEVICETREE, *PDEVICETREE;

// This is our global data structure that hold our global variables.
typedef struct tagAppData
{
    HWND        hDlg;
    HWND        hLogging;
    HWND        hSearch;
    HICON       hIcon;
    HINSTANCE   hInstance;
    TCHAR       szScanPath[MAX_PATH];
    TCHAR       szScanPattern[MAX_PATH];
    TCHAR       szLogFile[MAX_PATH];
    TCHAR       szLogDir[MAX_PATH];
    TCHAR       szWinDir[MAX_PATH];
    LPFILENODE  lpFileList;
    LPFILENODE  lpFileLast;
    HCATADMIN   hCatAdmin;
    DWORD       dwFiles;
    DWORD       dwSigned;
    DWORD       dwUnsigned;
    BOOL        bOverwrite;
    BOOL        bLoggingEnabled;
    BOOL        bAutomatedScan;
    BOOL        bScanning;
    BOOL        bStopScan;
    BOOL        bUserScan;
    BOOL        bSubFolders;
    DWORD       LastError;
} GAPPDATA, *LPGAPPDATA;

// Global function prototypes
BOOL BrowseForFolder(HWND hwnd, LPTSTR lpszBuf, DWORD BufCchSize);
DWORD BuildFileList(LPTSTR lpPathName);
BOOL VerifyFileList(void);
BOOL VerifyFileNode(LPFILENODE lpFileNode);
void MyLoadString(LPTSTR lpString, ULONG CchStringSize, UINT uId);
void MyMessageBox(LPTSTR lpString);
void MyErrorBox(LPTSTR lpString);
void MyErrorBoxId(UINT uId);
void MyMessageBoxId(UINT uId);
UINT MyGetWindowsDirectory(LPTSTR lpDirName, UINT DirNameCchSize);
LPTSTR MyStrStr(LPTSTR lpString, LPTSTR lpSubString);
INT_PTR CALLBACK Details_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ListView_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LogFile_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LPFILENODE CreateFileNode(LPTSTR lpDirectory, LPTSTR lpFileName);
BOOL IsFileAlreadyInList(LPTSTR lpDirName, LPTSTR lpFileName);
void SigVerif_Help(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL bContext);
void AdvancedPropertySheet(HWND hwnd);
void InsertFileNodeIntoList(LPFILENODE lpFileNode);
void DestroyFileList(BOOL bClear);
void DestroyFileNode(LPFILENODE lpFileNode);
BOOL PrintFileList(void);
void Progress_InitRegisterClass(void);
DWORD BuildDriverFileList(void);
DWORD BuildPrinterFileList(void);
DWORD BuildCoreFileList(void);
void MyGetFileInfo(LPFILENODE lpFileInfo);


//
// Context-Sensitive Help/Identifiers specific to SigVerif
//
#define SIGVERIF_HELPFILE                       TEXT("SIGVERIF.HLP")
#define WINDOWS_HELPFILE                        TEXT("WINDOWS.HLP")
#define IDH_SIGVERIF_SEARCH_CHECK_SYSTEM        1000
#define IDH_SIGVERIF_SEARCH_LOOK_FOR            1010
#define IDH_SIGVERIF_SEARCH_SCAN_FILES          1020
#define IDH_SIGVERIF_SEARCH_LOOK_IN_FOLDER      1030
#define IDH_SIGVERIF_SEARCH_INCLUDE_SUBFOLDERS  1040
#define IDH_SIGVERIF_LOGGING_ENABLE_LOGGING     1050
#define IDH_SIGVERIF_LOGGING_APPEND             1060
#define IDH_SIGVERIF_LOGGING_OVERWRITE          1070
#define IDH_SIGVERIF_LOGGING_FILENAME           1080
#define IDH_SIGVERIF_LOGGING_VIEW_LOG           1090

//
// Context-Sensitive Help Identifiers for Browse button
//
#define IDH_BROWSE  28496

//
// g_App is allocated in SIGVERIF.C, so everywhere else we want to make it extern
//
#ifndef SIGVERIF_DOT_C
extern GAPPDATA g_App;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cabs\symbolcd\place.inc ===
SYMBASEDIR=$(PROJECT_ROOT)\cabs\symbolcd

BINPLACE_PLACEFILE=$(SYMBASEDIR)\placefil.txt

ALT_PROJECT_TARGET=symbolcd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\walkpath.c ===
//
// WALKPATH.C
//
#include "sigverif.h"

BOOL        g_bRecurse  = TRUE;

//
// This function takes a directory name and a search pattern and looks for all 
// files mathching the pattern.
// If bRecurse is set, then it will add subdirectories to the end of the 
// g_lpDirList for subsequent traversal.
// 
// In this routine we allocate and fill in some of the lpFileNode values that 
// we know about.
//
DWORD 
FindFile(
    TCHAR *lpDirName, 
    TCHAR *lpFileName
    )
{
    DWORD           Err = ERROR_SUCCESS;
    HANDLE          hFind = INVALID_HANDLE_VALUE;
    LPFILENODE      lpFileNode;
    WIN32_FIND_DATA FindFileData;
    TCHAR           szFullPathName[MAX_PATH];

    //
    // If the user clicked STOP, then bail immediately!
    // If the directory is bogus, then skip to the next one.
    //
    if (!g_App.bStopScan) {
        
        if (g_bRecurse) {
            //
            // The user wants to get all the subdirectories as well, so first 
            // process all of the directories under this path.
            //
            if (FAILED(StringCchCopy(szFullPathName, cA(szFullPathName), lpDirName)) ||
                !pSetupConcatenatePaths(szFullPathName, TEXT("*.*"), cA(szFullPathName), NULL)) {
            
                Err = ERROR_BAD_PATHNAME;
                goto clean0;
            }
            
            hFind = FindFirstFile(szFullPathName, &FindFileData);
            
            if (hFind != INVALID_HANDLE_VALUE) {

                do {

                    if (lstrcmp(FindFileData.cFileName, TEXT(".")) &&
                        lstrcmp(FindFileData.cFileName, TEXT("..")) &&
                        (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

    
                        if (SUCCEEDED(StringCchCopy(szFullPathName, cA(szFullPathName), lpDirName)) &&
                            pSetupConcatenatePaths(szFullPathName, FindFileData.cFileName, cA(szFullPathName), NULL)) {

                            Err = FindFile(szFullPathName, lpFileName);
                        
                        } else {
                            
                            Err = ERROR_BAD_PATHNAME;
                        }
                    }
                    
                } while (!g_App.bStopScan && 
                         (Err == ERROR_SUCCESS) &&
                         FindNextFile(hFind, &FindFileData));

                FindClose(hFind);
                hFind = INVALID_HANDLE_VALUE;
            }
        }

        //
        // If we failed to process one of the directories then just bail out
        // now.
        //
        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Process the files in this directory.
        //
        if (FAILED(StringCchCopy(szFullPathName, cA(szFullPathName), lpDirName)) ||
            !pSetupConcatenatePaths(szFullPathName, lpFileName, cA(szFullPathName), NULL)) {

            Err = ERROR_BAD_PATHNAME;
            goto clean0;
        }

        hFind = FindFirstFile(szFullPathName, &FindFileData);
        if (hFind != INVALID_HANDLE_VALUE) {
            
            do {
                //
                // While there are more files to be found, keep looking in the 
                // directory...
                //
                if (lstrcmp(FindFileData.cFileName, TEXT(".")) &&
                    lstrcmp(FindFileData.cFileName, TEXT("..")) &&
                    !(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    
                    //
                    // Allocate an lpFileNode, fill it in, and add it to the end 
                    // of g_App.lpFileList
                    //
                    // We need to call CharLowerBuff on the file and dir names 
                    // because the catalog files all contain lower-case names 
                    // for the files.
                    //
                    lpFileNode = CreateFileNode(lpDirName, FindFileData.cFileName);

                    if (lpFileNode) {
                        
                        if (!g_App.lpFileList) {
                            g_App.lpFileList = lpFileNode;
                        } else { 
                            g_App.lpFileLast->next = lpFileNode;
                        }

                        g_App.lpFileLast = lpFileNode;

                        //
                        // Increment the total number of files we've found that 
                        // meet the search criteria.
                        //
                        g_App.dwFiles++;
                    } else {

                        Err = GetLastError();
                    }
                }

            } while (!g_App.bStopScan && 
                     (Err == ERROR_SUCCESS) &&
                     FindNextFile(hFind, &FindFileData));

            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }

clean0:

    if (hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }

    return Err;
}

//
// Build an g_App.lpFileList given the user settings in the main dialog.
//
DWORD 
BuildFileList(
    LPTSTR lpPathName
    )
{
    DWORD       Err = ERROR_SUCCESS;
    TCHAR       FileName[MAX_PATH];

    //
    // Check if this is a valid starting directory.
    // If not, then pop up an error message.
    //
    if (!SetCurrentDirectory(lpPathName)) {
        Err = ERROR_BAD_PATHNAME;
        goto clean0;
    }

    //
    // If the "Include Subdirectories" is checked, then bRecurse is TRUE.
    //
    if (g_App.bSubFolders) {
        g_bRecurse = TRUE;
    } else {
        g_bRecurse = FALSE;
    }

    //
    // Get the search pattern from the resource or the user-specified string
    //
    if (g_App.bUserScan) {
        if (FAILED(StringCchCopy(FileName, cA(FileName), g_App.szScanPattern))) {
            //
            // This shouldn't happen since we should check the size of
            // szScanPattern at the time we read it in from the UI.
            //
            goto clean0;
        }
    } else {
        MyLoadString(FileName, cA(FileName), IDS_ALL);
    }

    //
    // Process the g_lpDirList as long as the user doesn't click STOP!
    //
    Err = FindFile(lpPathName, FileName);

clean0:

    //
    // If there weren't any files found, then let the user know about it.
    //
    if (!g_App.lpFileList && (Err == ERROR_SUCCESS)) {
        MyMessageBoxId(IDS_NOFILES);
    }

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\sigverif.c ===
//
//  SIGVERIF.C
//
#define SIGVERIF_DOT_C
#include "sigverif.h"

// Allocate our global data structure
GAPPDATA    g_App;

//
//  Load a resource string into a buffer that is assumed to be MAX_PATH bytes.
//
void 
MyLoadString(
    LPTSTR lpString, 
    ULONG CchStringSize, 
    UINT uId
    )
{
    LoadString(g_App.hInstance, uId, lpString, CchStringSize);
}

//
//  Pop an OK messagebox with a specific string
//
void 
MyMessageBox(
    LPTSTR lpString
    )
{
    TCHAR szBuffer[MAX_PATH];

    MyLoadString(szBuffer, cA(szBuffer), IDS_MSGBOX);
    MessageBox(g_App.hDlg, lpString, szBuffer, MB_OK);
}

//
//  Pop an OK messagebox with a resource string ID
//
void 
MyMessageBoxId(
    UINT uId
    )
{
    TCHAR szBuffer[MAX_PATH];

    MyLoadString(szBuffer, cA(szBuffer), uId);
    MyMessageBox(szBuffer);
}

//
//  Pop an error messagebox with a specific string
//
void 
MyErrorBox(
    LPTSTR lpString
    )
{
    TCHAR szBuffer[MAX_PATH];

    MyLoadString(szBuffer, cA(szBuffer), IDS_ERRORBOX);
    MessageBox(g_App.hDlg, lpString, szBuffer, MB_OK);
}

//
//  Pop an error messagebox with a resource string ID
//
void 
MyErrorBoxId(
    UINT uId
    )
{
    TCHAR szBuffer[MAX_PATH];

    MyLoadString(szBuffer, cA(szBuffer), uId);
    MyErrorBox(szBuffer);
}

void 
MyErrorBoxIdWithErrorCode(
    UINT uId,
    DWORD ErrorCode
    )
{
    TCHAR szBuffer[MAX_PATH];
    ULONG cchSize;
    HRESULT hr;
    PTSTR errorMessage = NULL;
    LPVOID lpLastError = NULL;

    //
    // Get the error text for the error code.
    //
    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_SYSTEM |
                      FORMAT_MESSAGE_IGNORE_INSERTS,
                      NULL,
                      ErrorCode,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (LPTSTR)&lpLastError,
                      0,
                      NULL) != 0) {

        if (lpLastError) {

            MyLoadString(szBuffer, cA(szBuffer), uId);

            cchSize = lstrlen(szBuffer) + lstrlen(lpLastError) + 1;

            errorMessage = MALLOC(cchSize * sizeof(TCHAR));

            if (errorMessage) {

                hr = StringCchCopy(errorMessage, cchSize, szBuffer);

                if (SUCCEEDED(hr)) {
                    hr = StringCchCat(errorMessage, cchSize, lpLastError);
                }

                // 
                // We want to show the error message, even if the
                // buffer was truncated.
                //
                if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {
                    MyMessageBox(errorMessage);
                }

                FREE(errorMessage);
            }

            LocalFree(lpLastError);
        }
    }
}

//
// Since Multi-User Windows will give me back a Profile directory, I need to get the real Windows directory
// Dlg_OnInitDialog initializes g_App.szWinDir with the real Windows directory, so I just use that.
//
UINT 
MyGetWindowsDirectory(
    LPTSTR lpDirName, 
    UINT DirNameCchSize
    )
{
    UINT  uRet = 0;

    if (lpDirName) {

        if (SUCCEEDED(StringCchCopy(lpDirName, DirNameCchSize, g_App.szWinDir))) {
            uRet = lstrlen(lpDirName);
        } else {
            //
            // If the directory name can't fit in the buffer that the caller
            // provided, then set it to 0 (if they provided a buffer of at
            // least size 1) since we don't want to return a truncated 
            // directory to the caller.
            //
            if (DirNameCchSize > 0) {
                *lpDirName = 0;
            }

            uRet = 0;
        }
    }

    return uRet;
}

//
//  Initialization of main dialog.
//
BOOL 
Dlg_OnInitDialog(
    HWND hwnd
    )
{
    DWORD   Err = ERROR_SUCCESS;
    HKEY    hKey;
    LONG    lRes;
    DWORD   dwType, dwFlags, cbData;
    TCHAR   szBuffer[MAX_PATH];
    LPTSTR  lpCommandLine, lpStart, lpEnd;
    ULONG   cchSize;

    //
    // Initialize global hDlg to current hwnd.
    //
    g_App.hDlg = hwnd;

    //
    // Set the window class to have the icon in the resource file
    //
    if (g_App.hIcon) {
        SetClassLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon);
    }

    //
    // Make sure the IDC_STATUS control is hidden until something happens.
    //
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_HIDE);

    //
    // Set the range for the custom progress bar to 0-100.
    //
    SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETRANGE, (WPARAM) 0, (LPARAM) MAKELPARAM(0, 100));

    //
    // Set the global lpLogName to the one that's given in the resource file
    //
    MyLoadString(g_App.szLogFile, cA(g_App.szLogFile), IDS_LOGNAME);

    //
    // Figure out what the real Windows directory is and store it in g_App.szWinDir
    // This is required because Hydra makes GetWindowsDirectory return a PROFILE directory
    //
    // We store the original CurrentDirectory in szBuffer so we can restore it after this hack.
    // Next we switch into the SYSTEM/SYSTEM32 directory and then into its parent directory.
    // This is what we want to store in g_App.szWinDir.
    //
    GetCurrentDirectory(cA(szBuffer), szBuffer);
    GetSystemDirectory(g_App.szWinDir, cA(g_App.szWinDir));
    SetCurrentDirectory(g_App.szWinDir);
    SetCurrentDirectory(TEXT(".."));
    GetCurrentDirectory(cA(g_App.szWinDir), g_App.szWinDir);
    SetCurrentDirectory(szBuffer);

    //
    // Set the global search folder to %WinDir%
    //
    MyGetWindowsDirectory(g_App.szScanPath, cA(g_App.szScanPath));

    //
    // Set the global search pattern to "*.*"
    //
    MyLoadString(g_App.szScanPattern, cA(g_App.szScanPattern), IDS_ALL);

    //
    // Reset the progress bar back to zero percent
    //
    SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 0, (LPARAM) 0);

    //
    // By default, we want to turn logging and set the logging mode to OVERWRITE
    //
    g_App.bLoggingEnabled   = TRUE;
    g_App.bOverwrite        = TRUE;
    
    //
    // Look in the registry for any settings from the last SigVerif session
    //
    lRes = RegOpenKeyEx(HKEY_CURRENT_USER,
                        SIGVERIF_KEY,
                        0,
                        KEY_READ,
                        &hKey);

    if (lRes == ERROR_SUCCESS) {

        cbData = sizeof(DWORD);
        lRes = RegQueryValueEx( hKey,
                                SIGVERIF_FLAGS,
                                NULL,
                                &dwType,
                                (LPBYTE) &dwFlags,
                                &cbData);
        if (lRes == ERROR_SUCCESS) {

            g_App.bLoggingEnabled   = (dwFlags & 0x1);
            g_App.bOverwrite        = (dwFlags & 0x2);
        }

        cbData = sizeof(szBuffer);
        lRes = RegQueryValueEx( hKey,
                                SIGVERIF_LOGNAME,
                                NULL,
                                &dwType,
                                (LPBYTE) szBuffer,
                                &cbData);
        if (lRes == ERROR_SUCCESS && dwType == REG_SZ) {
            //
            // This should never happen unless the code is changed
            // so that szBuffer is larger then g_App.szLogFile, but
            // for safety if we can't copy szBuffer fully into
            // g_App.szLogFile, then set g_App.szLogFile to 0 so we
            // don't log to a truncated location.
            //
            if (FAILED(StringCchCopy(g_App.szLogFile, cA(g_App.szLogFile), szBuffer))) {
                g_App.szLogFile[0] = 0;
            }
        }

        RegCloseKey(hKey);
    }

    //
    // If the user specified the LOGDIR flag, we want to create the log
    // file in that directory.
    //
    //
    // SECURITY: Verify that LOGDIR exists and the user has the correct access
    // to it, and if they don't then fail up front.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_LOGDIR);
    if (SUCCEEDED(StringCchCat(szBuffer, cA(szBuffer), TEXT(":"))) &&
        ((lpStart = MyStrStr(GetCommandLine(), szBuffer)) != NULL)) {

        lpStart += lstrlen(szBuffer);

        if (lpStart && *lpStart) {
            //
            // The string in lpStart is the directory that we want to log
            // into.
            //
            cchSize = lstrlen(lpStart) + 1;
            lpCommandLine = MALLOC(cchSize * sizeof(TCHAR));

            if (lpCommandLine) {

                if (SUCCEEDED(StringCchCopy(lpCommandLine, cchSize, lpStart))) {

                    lpStart = lpCommandLine;

                    //
                    // First skip any white space.
                    //

                    while (*lpStart && (isspace(*lpStart))) {
                    
                        lpStart++;
                    }

                    //
                    // We will deal with two cases, one where the path
                    // starts with a quote, and the other where it does 
                    // not.
                    //
                    if (*lpStart) {
                    
                        if (*lpStart == TEXT('\"')) {
                            //
                            // The log path starts with a quote.  This means that
                            // we will use all of the string until we either hit 
                            // the end of the string, or we find another quote.
                            //
                            lpStart++;

                            lpEnd = lpStart;

                            while (*lpEnd && (*lpEnd != TEXT('\"'))) {

                                lpEnd++;
                            }
                        
                        } else {
                            //
                            // The log path does NOT start with a quote, so 
                            // use the characters until we come to the end
                            // of the string or a space.
                            //
                            lpEnd = lpStart;

                            while (*lpEnd && (isspace(*lpEnd))) {

                                lpEnd++;
                            }
                        }

                        *lpEnd = TEXT('\0');

                        if (FAILED(StringCchCopy(g_App.szLogDir, cA(g_App.szLogDir), lpStart))) {
                            //
                            // The user probably typed in too many characters for
                            // the log dir.
                            //
                            Err = ERROR_DIRECTORY;
                        
                        } else {
                            //
                            // Verify that the log dir exists and is a directory.
                            //
                            DWORD attributes;

                            attributes = GetFileAttributes(g_App.szLogDir);

                            if (attributes == INVALID_FILE_ATTRIBUTES) {
                                Err = ERROR_DIRECTORY;
                            } else if (!(attributes & FILE_ATTRIBUTE_DIRECTORY)) {
                                Err = ERROR_DIRECTORY;
                            }
                        }
                    }
                }

                FREE(lpCommandLine);
            }
        }

        if (Err != ERROR_SUCCESS) {
            MyMessageBoxId(IDS_LOGDIRERROR);
        }
    }

    //
    // If the user specified the FULLSCAN flag we want to scan the specified
    // directory and all of its subdirectories.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_FULLSCAN);
    if (SUCCEEDED(StringCchCat(szBuffer, cA(szBuffer), TEXT(":"))) &&
        ((lpStart = MyStrStr(GetCommandLine(), szBuffer)) != NULL)) {

        Err = ERROR_SUCCESS;

        lpStart += lstrlen(szBuffer);

        if (lpStart && *lpStart) {
            //
            // The string in lpStart is the directory that we want to scan.
            //
            cchSize = lstrlen(lpStart) + 1;
            lpCommandLine = MALLOC(cchSize * sizeof(TCHAR));

            if (lpCommandLine) {

                if (SUCCEEDED(StringCchCopy(lpCommandLine, cchSize, lpStart))) {

                    lpStart = lpCommandLine;

                    //
                    // First skip any white space.
                    //

                    while (*lpStart && (isspace(*lpStart))) {
                    
                        lpStart++;
                    }

                    //
                    // We will deal with two cases, one where the path
                    // starts with a quote, and the other where it does 
                    // not.
                    //
                    if (*lpStart) {
                    
                        if (*lpStart == TEXT('\"')) {
                            //
                            // The scan path starts with a quote.  This means that
                            // we will use all of the string until we either hit 
                            // the end of the string, or we find another quote.
                            //
                            lpStart++;

                            lpEnd = lpStart;

                            while (*lpEnd && (*lpEnd != TEXT('\"'))) {

                                lpEnd++;
                            }
                        
                        } else {
                            //
                            // The scan path does NOT start with a quote, so 
                            // use the characters until we come to the end
                            // of the string or a space.
                            //
                            lpEnd = lpStart;

                            while (*lpEnd && (!isspace(*lpEnd))) {

                                lpEnd++;
                            }
                        }

                        *lpEnd = TEXT('\0');

                        if (FAILED(StringCchCopy(g_App.szScanPath, cA(g_App.szScanPath), lpStart))) {
                            //
                            // The user probably typed in too many characters for
                            // the scan dir.
                            //
                            Err = ERROR_DIRECTORY;
                        
                        } else {
                            //
                            // Verify that the scan dir exists and is a directory.
                            //
                            DWORD attributes;

                            attributes = GetFileAttributes(g_App.szScanPath);

                            if (attributes == INVALID_FILE_ATTRIBUTES) {
                                Err = ERROR_DIRECTORY;
                            } else if (!(attributes & FILE_ATTRIBUTE_DIRECTORY)) {
                                Err = ERROR_DIRECTORY;
                            }
                        }
                    }
                }

                FREE(lpCommandLine);
            }
        }

        if (Err == ERROR_SUCCESS) {
            
            g_App.bAutomatedScan = TRUE;
            g_App.bLoggingEnabled = TRUE;
            g_App.bUserScan = TRUE;
            g_App.bSubFolders = TRUE;

            //
            // Now that everything is set up, simulate a click to the START button...
            //
            PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(ID_START, 0), (LPARAM)0);

        } else {
            MyMessageBoxId(IDS_FULLSCANERROR);
        }
    }

    //
    // If the user specified the DEFSCAN flag, we want to automatically do a 
    // default scan and log the results.
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_DEFSCAN);
    if (MyStrStr(GetCommandLine(), szBuffer)) {

        g_App.bAutomatedScan      = TRUE;
        g_App.bLoggingEnabled     = TRUE;
        
        //
        // Now that everything is set up, simulate a click to the START button...
        //
        PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(ID_START, 0), (LPARAM) 0);
    }

    if (Err == ERROR_SUCCESS) {
        return TRUE;
    
    } else {

        g_App.LastError = Err;
        return FALSE;
    }
}

//
//  Build file list according to dialog settings, then verify the files in the list
//
void WINAPI 
ProcessFileList(void)
{
    DWORD Err = ERROR_SUCCESS;
    TCHAR szBuffer[MAX_PATH];

    //
    // Set the scanning flag to TRUE, so we don't double-scan
    //
    g_App.bScanning = TRUE;

    // Assume a successfull scan.
    g_App.LastError = ERROR_SUCCESS;

    //
    // Change the "Start" to "Stop"
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_STOP);
    SetDlgItemText(g_App.hDlg, ID_START, szBuffer);

    EnableWindow(GetDlgItem(g_App.hDlg, ID_ADVANCED), FALSE);
    EnableWindow(GetDlgItem(g_App.hDlg, IDCANCEL), FALSE);

    //
    // Display the text that says "Building file list..."
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_STATUS_BUILD);
    SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

    //
    // Make sure the IDC_STATUS text item visible
    //
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_SHOW);

    //
    // Free any memory that we may have allocated for the g_App.lpFileList
    //
    DestroyFileList(TRUE);

    //
    // Now actually build the g_App.lpFileList list given the dialog settings
    //
    if (g_App.bUserScan) {
        
        Err = BuildFileList(g_App.szScanPath);
    
    } else {
        if (!g_App.bStopScan && (Err == ERROR_SUCCESS)) {
            Err = BuildDriverFileList();
        }

        if (!g_App.bStopScan && (Err == ERROR_SUCCESS)) {
            Err = BuildPrinterFileList();
        }

        if (!g_App.bStopScan && (Err == ERROR_SUCCESS)) {
            Err = BuildCoreFileList();
        }
    }

    if (!g_App.bAutomatedScan &&
        (Err != ERROR_SUCCESS) && 
        (Err != ERROR_CANCELLED)) {

        g_App.LastError = Err;
        MyErrorBoxIdWithErrorCode(IDS_BUILDLISTERROR, Err);
    }

    //
    // If we encountered an error building the file list then don't bother
    // scanning the files.
    //
    if (Err == ERROR_SUCCESS) {
        //
        // Check if there is even a file list to verify.
        //
        if (g_App.lpFileList) {
    
            if (!g_App.bStopScan) {
                //
                // Display the "Scanning File List..." text
                //
                MyLoadString(szBuffer, cA(szBuffer), IDS_STATUS_SCAN);
                SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);
    
                //
                // Reset the progress bar back to zero percent while it's invisible.
                //
                SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 0, (LPARAM) 0);
    
                //
                // WooHoo! Let's display the progress bar and start cranking on the file list!
                //
                ShowWindow(GetDlgItem(g_App.hDlg, IDC_PROGRESS), SW_SHOW);
                VerifyFileList();
                ShowWindow(GetDlgItem(g_App.hDlg, IDC_PROGRESS), SW_HIDE);
            }
        } else {
            //
            // The IDC_NOTMS code displays it's own error message, so only display
            // an error dialog if we are doing a System Integrity Scan
            //
            if (!g_App.bStopScan && !g_App.bUserScan)  {
                MyMessageBoxId(IDS_NOSYSTEMFILES);
            }
        }
    
        //
        // Disable the start button while we clean up the g_App.lpFileList
        //
        EnableWindow(GetDlgItem(g_App.hDlg, ID_START), FALSE);
    
        //
        // Log the results.  Note that sigverif will do this even if we encountered
        // an error building or scanning the list, since the logfile may help 
        // figure out which file is causing the problem. Only log the results
        // if we found any files to scan.
        //
        if (!g_App.bStopScan) {
            //
            // Display the text that says "Writing Log File..."
            //
            MyLoadString(szBuffer, cA(szBuffer), IDS_STATUS_LOG);
            SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);
    
            //
            // Write the results to the log file
            //
            if (!PrintFileList()) {
                //
                // We failed while logging for some reason, probably permissions
                // or out of disk space. Let the user know that we could not finish
                // logging all of the files.  
                //
                Err = GetLastError();
    
                if (Err != ERROR_SUCCESS) {
                    
                    MyErrorBoxIdWithErrorCode(IDS_LOGERROR, Err);
                }
            }
        } else {
            //
            // If the user clicked STOP, let them know about it.
            //
            MyMessageBoxId(IDS_SCANSTOPPED);
        }
    }

    //
    // Display the text that says "Freeing File List..."
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_STATUS_FREE);
    SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

    //
    // Hide the IDC_STATUS text item so it doesn't cover IDC_STATUS
    //
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_HIDE);

    //
    // Change the "Stop" button back to "Start"
    //
    MyLoadString(szBuffer, cA(szBuffer), IDS_START);
    SetDlgItemText(g_App.hDlg, ID_START, szBuffer);

    EnableWindow(GetDlgItem(g_App.hDlg, ID_START), TRUE);
    EnableWindow(GetDlgItem(g_App.hDlg, ID_ADVANCED), TRUE);
    EnableWindow(GetDlgItem(g_App.hDlg, IDCANCEL), TRUE);

    //
    // Free all the memory that we allocated for the g_App.lpFileList
    //
    DestroyFileList(FALSE);

    //
    // Clear the scanning flag
    //
    g_App.bScanning = FALSE;
    g_App.bStopScan = FALSE;

    //
    // If the user started SigVerif with the /DEFSCAN flag, then we exit.
    //
    if (g_App.bAutomatedScan) {
        PostMessage(g_App.hDlg, WM_CLOSE, (WPARAM) 0, (LPARAM) 0);
    }
}

//
//  Spawns a thread to do the scan so the GUI remains responsive.
//
void 
Dlg_OnPushStartButton(
    HWND hwnd
    )
{
    HANDLE hThread;
    DWORD dwThreadId;

    UNREFERENCED_PARAMETER(hwnd);

    //
    // Check if we are already scanning... if so, bail.
    //
    if (g_App.bScanning) {
        return;
    }

    //
    // Create a thread where Search_ProcessFileList can go without tying up the GUI thread.
    //
    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE) ProcessFileList,
                           0,
                           0,
                           &dwThreadId);
}

//
//  Handle any WM_COMMAND messages sent to the search dialog
//
void 
Dlg_OnCommand(
    HWND hwnd, 
    int id, 
    HWND hwndCtl, 
    UINT codeNotify
    )
{
    UNREFERENCED_PARAMETER(hwndCtl);
    UNREFERENCED_PARAMETER(codeNotify);

    switch(id) {
        //
        //  The user clicked ID_START, so if we aren't scanning start scanning.
        //  If we are scanning, then stop the tests because the button actually says "Stop"
        //
        case ID_START:
            if (!g_App.bScanning) {

                Dlg_OnPushStartButton(hwnd);
            
            } else if (!g_App.bStopScan) {

                g_App.bStopScan = TRUE;
                g_App.LastError = ERROR_CANCELLED;
            }
            break;

        //
        //  The user clicked IDCANCEL, so if the tests are running try to stop them before exiting.
        //
        case IDCANCEL:
            if (g_App.bScanning) {

                g_App.bStopScan = TRUE;
                g_App.LastError = ERROR_CANCELLED;
            
            } else {

                SendMessage(hwnd, WM_CLOSE, 0, 0);
            }
            break;

        //  Pop up the IDD_SETTINGS dialog so the user can change their log settings.
        case ID_ADVANCED:
            if (!g_App.bScanning) {

                AdvancedPropertySheet(hwnd);
            }
            break;
    }
}

void 
SigVerif_Help(
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    BOOL bContext
    )
{
    static DWORD SigVerif_HelpIDs[] =
    {
        IDC_SCAN,           IDH_SIGVERIF_SEARCH_CHECK_SYSTEM,
        IDC_NOTMS,          IDH_SIGVERIF_SEARCH_LOOK_FOR,
        IDC_TYPE,           IDH_SIGVERIF_SEARCH_SCAN_FILES,
        IDC_FOLDER,         IDH_SIGVERIF_SEARCH_LOOK_IN_FOLDER,
        IDC_SUBFOLDERS,     IDH_SIGVERIF_SEARCH_INCLUDE_SUBFOLDERS,
        IDC_ENABLELOG,      IDH_SIGVERIF_LOGGING_ENABLE_LOGGING,
        IDC_APPEND,         IDH_SIGVERIF_LOGGING_APPEND,
        IDC_OVERWRITE,      IDH_SIGVERIF_LOGGING_OVERWRITE,
        IDC_LOGNAME,        IDH_SIGVERIF_LOGGING_FILENAME,
        IDC_VIEWLOG,        IDH_SIGVERIF_LOGGING_VIEW_LOG,
        0,0
    };

    static DWORD Windows_HelpIDs[] =
    {
        ID_BROWSE,      IDH_BROWSE,
        0,0
    };

    HWND hItem = NULL;
    LPHELPINFO lphi = NULL;
    POINT point;

    switch (uMsg) {
        
    case WM_HELP:
        lphi = (LPHELPINFO) lParam;
        if (lphi && (lphi->iContextType == HELPINFO_WINDOW)) {
            hItem = (HWND) lphi->hItemHandle;
        }
        break;

    case WM_CONTEXTMENU:
        hItem = (HWND) wParam;
        point.x = GET_X_LPARAM(lParam);
        point.y = GET_Y_LPARAM(lParam);
        if (ScreenToClient(hwnd, &point)) {
            hItem = ChildWindowFromPoint(hwnd, point);
        }
        break;
    }

    if (hItem) {
        if (GetWindowLong(hItem, GWL_ID) == ID_BROWSE) {
            WinHelp(hItem,
                    (LPCTSTR) WINDOWS_HELPFILE,
                    (bContext ? HELP_CONTEXTMENU : HELP_WM_HELP),
                    (ULONG_PTR) Windows_HelpIDs);
        } else {
            WinHelp(hItem,
                    (LPCTSTR) SIGVERIF_HELPFILE,
                    (bContext ? HELP_CONTEXTMENU : HELP_WM_HELP),
                    (ULONG_PTR) SigVerif_HelpIDs);
        }
    }
}

//
//  The main dialog procedure.  Needs to handle WM_INITDIALOG, WM_COMMAND, and WM_CLOSE/WM_DESTROY.
//
INT_PTR CALLBACK 
DlgProc(
    HWND hwnd, 
    UINT uMsg,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
        
    HANDLE_MSG(hwnd, WM_COMMAND, Dlg_OnCommand);

    case WM_INITDIALOG:
        fProcessed = Dlg_OnInitDialog(hwnd);
        break;

    case WM_CLOSE:
        if (g_App.bScanning) {
            g_App.bStopScan = TRUE;
            g_App.LastError = ERROR_CANCELLED;
        
        } else { 
            EndDialog(hwnd, IDCANCEL);
        }
        break;

    default: 
        fProcessed = FALSE;
    }

    return fProcessed;
}

//
//  Program entry point.  Set up for creation of IDD_DIALOG.
//
WINAPI 
WinMain(
    HINSTANCE hInstance, 
    HINSTANCE hPrevInstance,
    LPSTR lpszCmdParam, 
    int nCmdShow
    )
{
    HWND hwnd;
    TCHAR szAppName[MAX_PATH];

    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpszCmdParam);
    UNREFERENCED_PARAMETER(nCmdShow);

    ZeroMemory(&g_App, sizeof(GAPPDATA));

    g_App.hInstance = hInstance;

    //
    // Look for any existing instances of SigVerif...
    //
    MyLoadString(szAppName, cA(szAppName), IDS_SIGVERIF);
    hwnd = FindWindow(NULL, szAppName);
    if (!hwnd) {
        //
        // We definitely need this for the progress bar, and maybe other stuff too.
        //
        InitCommonControls();

        //
        // Register the custom control we use for the progress bar
        //
        Progress_InitRegisterClass();

        //
        // Load the icon from the resource file that we will use everywhere
        //
        g_App.hIcon = LoadIcon(g_App.hInstance, MAKEINTRESOURCE(IDI_ICON1));

        //
        // Create the IDD_DIALOG and use DlgProc as the main procedure
        //
        DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG), NULL, DlgProc);

        if (g_App.hIcon) {
            DestroyIcon(g_App.hIcon);
            g_App.hIcon = NULL;
        }
    } else {
        //
        // If there is already an instance of SigVerif running, make that one 
        // foreground and we exit.
        //
        SetForegroundWindow(hwnd);
    }

    //
    // If we encountered any errors during our scan, then return the error code,
    // otherwise return 0 if all the files are signed or 1 if we found any
    // unsigned files.
    //
    if (g_App.LastError != ERROR_SUCCESS) {
        return g_App.LastError;
    } else {
        return ((g_App.dwUnsigned > 0) ? 1 : 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\bvtsigvf\verify.c ===
//
// VERIFY.C
//
#include "sigverif.h"

//
// Find the file extension and place it in the lpFileNode->lpTypeName field
//
void
MyGetFileTypeName(
    LPFILENODE lpFileInfo
    )
{
    TCHAR szBuffer[MAX_PATH];
    TCHAR szBuffer2[MAX_PATH];
    TCHAR szExt[MAX_PATH];
    LPTSTR lpExtension;
    ULONG BufCbSize;
    HRESULT hr;

    //
    // Initialize szBuffer to be an empty string.
    //
    szBuffer[0] = TEXT('\0');

    //
    // Walk to the end of lpFileName
    //
    for (lpExtension = lpFileInfo->lpFileName; *lpExtension; lpExtension++);

    //
    // Walk backwards until we hit a '.' and we'll use that as our extension
    //
    for (lpExtension--; *lpExtension && lpExtension >= lpFileInfo->lpFileName; lpExtension--) {

        if (lpExtension[0] == TEXT('.')) {
            //
            // Since the file extension is just used for display and logging purposes, if
            // it is too large to fit in our local buffer then just truncate it.
            //
            if (SUCCEEDED(StringCchCopy(szExt, cA(szExt), lpExtension + 1))) {
                CharUpperBuff(szExt, lstrlen(szExt));
                MyLoadString(szBuffer2, cA(szBuffer2), IDS_FILETYPE);

                if (FAILED(StringCchPrintf(szBuffer, cA(szBuffer), szBuffer2, szExt))) {
                    //
                    // There is no point in displaying a partial extension so
                    // just set szBuffer to the empty string so we show the
                    // generic extension.
                    //
                    szBuffer[0] = TEXT('\0');
                }
            }
        }
    }

    //
    // If there's no extension, then just call this a "File".
    //
    if (szBuffer[0] == 0) {

        MyLoadString(szBuffer, cA(szBuffer), IDS_FILE);
    }

    BufCbSize = (lstrlen(szBuffer) + 1) * sizeof(TCHAR);
    lpFileInfo->lpTypeName = MALLOC(BufCbSize);

    if (lpFileInfo->lpTypeName) {

        hr = StringCbCopy(lpFileInfo->lpTypeName, BufCbSize, szBuffer);

        if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
            //
            // If we fail for some reason other than insufficient
            // buffer, then free the string and set the pointer
            // to NULL, since the string is undefined.
            //
            FREE(lpFileInfo->lpTypeName);
            lpFileInfo->lpTypeName = NULL;
        }
    }
}

//
// Use SHGetFileInfo to get the icon index for the specified file.
//
void
MyGetFileInfo(
    LPFILENODE lpFileInfo
    )
{
    SHFILEINFO  sfi;
    ULONG       BufCbSize;
    HRESULT     hr;

    ZeroMemory(&sfi, sizeof(SHFILEINFO));
    SHGetFileInfo(  lpFileInfo->lpFileName,
                    0,
                    &sfi,
                    sizeof(SHFILEINFO),
                    SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_TYPENAME);

    lpFileInfo->iIcon = sfi.iIcon;

    if (*sfi.szTypeName) {

        BufCbSize = (lstrlen(sfi.szTypeName) + 1) * sizeof(TCHAR);
        lpFileInfo->lpTypeName = MALLOC(BufCbSize);

        if (lpFileInfo->lpTypeName) {

            hr = StringCbCopy(lpFileInfo->lpTypeName, BufCbSize, sfi.szTypeName);

            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                //
                // If we fail for some reason other than insufficient
                // buffer, then free the string and set the pointer
                // to NULL, since the string is undefined.
                //
                FREE(lpFileInfo->lpTypeName);
                lpFileInfo->lpTypeName = NULL;
            }
        }

    } else {

        MyGetFileTypeName(lpFileInfo);
    }
}

void
GetFileVersion(
    LPFILENODE lpFileInfo
    )
{
    DWORD               dwHandle, dwRet;
    UINT                Length;
    BOOL                bRet;
    LPVOID              lpData = NULL;
    LPVOID              lpBuffer;
    VS_FIXEDFILEINFO    *lpInfo;
    TCHAR               szBuffer[MAX_PATH];
    TCHAR               szBuffer2[MAX_PATH];
    ULONG               BufCbSize;
    HRESULT             hr;

    dwRet = GetFileVersionInfoSize(lpFileInfo->lpFileName, &dwHandle);

    if (dwRet) {

        lpData = MALLOC(dwRet + 1);

        if (lpData) {

            bRet = GetFileVersionInfo(lpFileInfo->lpFileName, dwHandle, dwRet, lpData);

            if (bRet) {

                lpBuffer = NULL;
                Length = 0;
                bRet = VerQueryValue(lpData, TEXT("\\"), &lpBuffer, &Length);

                if (bRet) {

                    lpInfo = (VS_FIXEDFILEINFO *) lpBuffer;

                    MyLoadString(szBuffer2, cA(szBuffer2), IDS_VERSION);

                    hr = StringCchPrintf(szBuffer,
                                         cA(szBuffer),
                                         szBuffer2,
                                         HIWORD(lpInfo->dwFileVersionMS),
                                         LOWORD(lpInfo->dwFileVersionMS),
                                         HIWORD(lpInfo->dwFileVersionLS),
                                         LOWORD(lpInfo->dwFileVersionLS));

                    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER)) {

                        BufCbSize = (lstrlen(szBuffer) + 1) * sizeof(TCHAR);
                        lpFileInfo->lpVersion = MALLOC(BufCbSize);

                        if (lpFileInfo->lpVersion) {

                            hr = StringCbCopy(lpFileInfo->lpVersion, BufCbSize, szBuffer);

                            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                                //
                                // If we fail for some reason other than insufficient
                                // buffer, then free the string and set the pointer
                                // to NULL, since the string is undefined.
                                //
                                FREE(lpFileInfo->lpVersion);
                                lpFileInfo->lpVersion = NULL;
                            }
                        }
                    }
                }
            }

            FREE(lpData);
        }
    }

    if (!lpFileInfo->lpVersion) {

        MyLoadString(szBuffer, cA(szBuffer), IDS_NOVERSION);
        BufCbSize = (lstrlen(szBuffer) + 1) * sizeof(TCHAR);
        lpFileInfo->lpVersion = MALLOC(BufCbSize);

        if (lpFileInfo->lpVersion) {

            hr = StringCbCopy(lpFileInfo->lpVersion, BufCbSize, szBuffer);

            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                //
                // If we fail for some reason other than insufficient
                // buffer, then free the string and set the pointer
                // to NULL, since the string is undefined.
                //
                FREE(lpFileInfo->lpVersion);
                lpFileInfo->lpVersion = NULL;
            }
        }
    }
}

/*************************************************************************
*   Function : VerifyIsFileSigned
*   Purpose : Calls WinVerifyTrust with Policy Provider GUID to
*   verify if an individual file is signed.
**************************************************************************/
BOOL
VerifyIsFileSigned(
    LPTSTR pcszMatchFile,
    PDRIVER_VER_INFO lpVerInfo
    )
{
    HRESULT             hRes;
    WINTRUST_DATA       WinTrustData;
    WINTRUST_FILE_INFO  WinTrustFile;
    GUID                gOSVerCheck = DRIVER_ACTION_VERIFY;
    GUID                gPublishedSoftware = WINTRUST_ACTION_GENERIC_VERIFY_V2;

    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pFile = &WinTrustFile;
    WinTrustData.pPolicyCallbackData = (LPVOID)lpVerInfo;
    WinTrustData.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT |
                               WTD_CACHE_ONLY_URL_RETRIEVAL;

    ZeroMemory(lpVerInfo, sizeof(DRIVER_VER_INFO));
    lpVerInfo->cbStruct = sizeof(DRIVER_VER_INFO);

    ZeroMemory(&WinTrustFile, sizeof(WINTRUST_FILE_INFO));
    WinTrustFile.cbStruct = sizeof(WINTRUST_FILE_INFO);

    WinTrustFile.pcwszFilePath = pcszMatchFile;

    hRes = WinVerifyTrust(g_App.hDlg, &gOSVerCheck, &WinTrustData);
    if (hRes != ERROR_SUCCESS) {

        hRes = WinVerifyTrust(g_App.hDlg, &gPublishedSoftware, &WinTrustData);
    }

    //
    // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
    // that was allocated in our call to WinVerifyTrust.
    //
    if (lpVerInfo && lpVerInfo->pcSignerCertContext) {

        CertFreeCertificateContext(lpVerInfo->pcSignerCertContext);
        lpVerInfo->pcSignerCertContext = NULL;
    }

    return(hRes == ERROR_SUCCESS);
}

//
// Given a specific LPFILENODE, verify that the file is signed or unsigned.
// Fill in all the necessary structures so the listview control can display properly.
//
BOOL
VerifyFileNode(
    LPFILENODE lpFileNode
    )
{
    HANDLE                  hFile;
    BOOL                    bRet;
    HCATINFO                hCatInfo = NULL;
    HCATINFO                PrevCat;
    WINTRUST_DATA           WinTrustData;
    WINTRUST_CATALOG_INFO   WinTrustCatalogInfo;
    DRIVER_VER_INFO         VerInfo;
    GUID                    gSubSystemDriver = DRIVER_ACTION_VERIFY;
    HRESULT                 hRes, hr;
    DWORD                   cbHash = HASH_SIZE;
    BYTE                    szHash[HASH_SIZE];
    LPBYTE                  lpHash = szHash;
    CATALOG_INFO            CatInfo;
    LPTSTR                  lpFilePart;
    TCHAR                   szBuffer[MAX_PATH];
    static TCHAR            szCurrentDirectory[MAX_PATH];
    OSVERSIONINFO           OsVersionInfo;
    ULONG                   BufCbSize;

    //
    // If this is the first item we are verifying, then initialize the static buffer.
    //
    if (lpFileNode == g_App.lpFileList) {

        ZeroMemory(szCurrentDirectory, sizeof(szCurrentDirectory));
    }

    //
    // Check the current directory against the one in the lpFileNode.
    // We only want to call SetCurrentDirectory if the path is different.
    //
    if (lstrcmp(szCurrentDirectory, lpFileNode->lpDirName)) {

        if (!SetCurrentDirectory(lpFileNode->lpDirName) ||
            FAILED(StringCchCopy(szCurrentDirectory, cA(szCurrentDirectory), lpFileNode->lpDirName))) {
            //
            // Well, if we fail to set the current directory, then the code below
            // won't work since it just deals with filenames and not full paths.
            //
            lpFileNode->LastError = ERROR_DIRECTORY;
            return FALSE;
        }
    }

    //
    // Get the handle to the file, so we can call CryptCATAdminCalcHashFromFileHandle
    //
    hFile = CreateFile( lpFileNode->lpFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == INVALID_HANDLE_VALUE) {

        lpFileNode->LastError = GetLastError();

        return FALSE;
    }

    //
    // Initialize the hash buffer
    //
    ZeroMemory(lpHash, HASH_SIZE);

    //
    // Generate the hash from the file handle and store it in lpHash
    //
    if (!CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, lpHash, 0)) {
        //
        // If we couldn't generate a hash, it might be an individually signed catalog.
        // If it's a catalog, zero out lpHash and cbHash so we know there's no hash to check.
        //
        if (IsCatalogFile(hFile, NULL)) {

            lpHash = NULL;
            cbHash = 0;

        } else {  // If it wasn't a catalog, we'll bail and this file will show up as unscanned.

            CloseHandle(hFile);
            return FALSE;
        }
    }

    //
    // Close the file handle
    //
    CloseHandle(hFile);

    //
    // Now we have the file's hash.  Initialize the structures that
    // will be used later on in calls to WinVerifyTrust.
    //
    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;
    WinTrustData.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT |
                               WTD_CACHE_ONLY_URL_RETRIEVAL;

    ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
    VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);

    //
    // Only validate against the current OS Version, unless the bValidateAgainstAnyOs
    // parameter was TRUE.  In that case we will just leave the sOSVersionXxx fields
    // 0 which tells WinVerifyTrust to validate against any OS.
    //
    if (!lpFileNode->bValidateAgainstAnyOs) {
        OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
        if (GetVersionEx(&OsVersionInfo)) {
            VerInfo.sOSVersionLow.dwMajor = OsVersionInfo.dwMajorVersion;
            VerInfo.sOSVersionLow.dwMinor = OsVersionInfo.dwMinorVersion;
            VerInfo.sOSVersionHigh.dwMajor = OsVersionInfo.dwMajorVersion;
            VerInfo.sOSVersionHigh.dwMinor = OsVersionInfo.dwMinorVersion;
        }
    }


    WinTrustData.pCatalog = &WinTrustCatalogInfo;

    ZeroMemory(&WinTrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
    WinTrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
    WinTrustCatalogInfo.pbCalculatedFileHash = lpHash;
    WinTrustCatalogInfo.cbCalculatedFileHash = cbHash;
    WinTrustCatalogInfo.pcwszMemberTag = lpFileNode->lpFileName;

    //
    // Now we try to find the file hash in the catalog list, via CryptCATAdminEnumCatalogFromHash
    //
    PrevCat = NULL;

    if (g_App.hCatAdmin) {
        hCatInfo = CryptCATAdminEnumCatalogFromHash(g_App.hCatAdmin, lpHash, cbHash, 0, &PrevCat);
    } else {
        hCatInfo = NULL;
    }

    //
    // We want to cycle through the matching catalogs until we find one that matches both hash and member tag
    //
    bRet = FALSE;
    while (hCatInfo && !bRet) {

        ZeroMemory(&CatInfo, sizeof(CATALOG_INFO));
        CatInfo.cbStruct = sizeof(CATALOG_INFO);

        if (CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)) {

            WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

            //
            // Now verify that the file is an actual member of the catalog.
            //
            hRes = WinVerifyTrust(g_App.hDlg, &gSubSystemDriver, &WinTrustData);

            if (hRes == ERROR_SUCCESS) {
                GetFullPathName(CatInfo.wszCatalogFile, cA(szBuffer), szBuffer, &lpFilePart);
                BufCbSize = (lstrlen(lpFilePart) + 1) * sizeof(TCHAR);
                lpFileNode->lpCatalog = MALLOC(BufCbSize);

                if (lpFileNode->lpCatalog) {

                    hr = StringCbCopy(lpFileNode->lpCatalog, BufCbSize, lpFilePart);

                    if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                        //
                        // If we fail for some reason other than insufficient
                        // buffer, then free the string and set the pointer
                        // to NULL, since the string is undefined.
                        //
                        FREE(lpFileNode->lpCatalog);
                        lpFileNode->lpCatalog = NULL;
                    }
                }

                bRet = TRUE;
            }

            //
            // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
            // that was allocated in our call to WinVerifyTrust.
            //
            if (VerInfo.pcSignerCertContext != NULL) {

                CertFreeCertificateContext(VerInfo.pcSignerCertContext);
                VerInfo.pcSignerCertContext = NULL;
            }
        }

        if (!bRet) {
            //
            // The hash was in this catalog, but the file wasn't a member...
            // so off to the next catalog
            //
            PrevCat = hCatInfo;
            hCatInfo = CryptCATAdminEnumCatalogFromHash(g_App.hCatAdmin, lpHash, cbHash, 0, &PrevCat);
        }
    }

    //
    // Mark this file as having been scanned.
    //
    lpFileNode->bScanned = TRUE;

    if (!hCatInfo) {
        //
        // If it wasn't found in the catalogs, check if the file is individually
        // signed.
        //
        bRet = VerifyIsFileSigned(lpFileNode->lpFileName, (PDRIVER_VER_INFO)&VerInfo);

        if (bRet) {
            //
            // If so, mark the file as being signed.
            //
            lpFileNode->bSigned = TRUE;
        }

    } else {
        //
        // The file was verified in the catalogs, so mark it as signed and free
        // the catalog context.
        //
        lpFileNode->bSigned = TRUE;
        CryptCATAdminReleaseCatalogContext(g_App.hCatAdmin, hCatInfo, 0);
    }

    if (lpFileNode->bSigned) {

        BufCbSize = (lstrlen(VerInfo.wszVersion) + 1) * sizeof(TCHAR);
        lpFileNode->lpVersion = MALLOC(BufCbSize);

        if (lpFileNode->lpVersion) {

            hr = StringCbCopy(lpFileNode->lpVersion, BufCbSize, VerInfo.wszVersion);

            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                //
                // If we fail for some reason other than insufficient
                // buffer, then free the string and set the pointer
                // to NULL, since the string is undefined.
                //
                FREE(lpFileNode->lpVersion);
                lpFileNode->lpVersion = NULL;
            }
        }

        BufCbSize = (lstrlen(VerInfo.wszSignedBy) + 1) * sizeof(TCHAR);
        lpFileNode->lpSignedBy = MALLOC(BufCbSize);

        if (lpFileNode->lpSignedBy) {

            hr = StringCbCopy(lpFileNode->lpSignedBy, BufCbSize, VerInfo.wszSignedBy);

            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                //
                // If we fail for some reason other than insufficient
                // buffer, then free the string and set the pointer
                // to NULL, since the string is undefined.
                //
                FREE(lpFileNode->lpSignedBy);
                lpFileNode->lpSignedBy = NULL;
            }
        }
    } else {
        //
        // Get the icon (if the file isn't signed) so we can display it in the
        // listview faster.
        //
        MyGetFileInfo(lpFileNode);
    }

    return lpFileNode->bSigned;
}

//
// This function loops through g_App.lpFileList to verify each file.  We want to make this loop as tight
// as possible and keep the progress bar updating as we go.  When we are done, we want to pop up a
// dialog that allows the user to choose "Details" which will give them the listview control.
//
BOOL
VerifyFileList(void)
{
    LPFILENODE lpFileNode;
    DWORD       dwCount = 0;
    DWORD       dwPercent = 0;
    DWORD       dwCurrent = 0;

    //
    // Initialize the signed and unsigned counts
    //
    g_App.dwSigned    = 0;
    g_App.dwUnsigned  = 0;

    //
    // If we don't already have an g_App.hCatAdmin handle, acquire one.
    //
    if (!g_App.hCatAdmin) {
        CryptCATAdminAcquireContext(&g_App.hCatAdmin, NULL, 0);
    }

    //
    // Start looping through each file and update the progress bar if we cross
    // a percentage boundary.
    //
    for (lpFileNode=g_App.lpFileList;lpFileNode && !g_App.bStopScan;lpFileNode=lpFileNode->next,dwCount++) {
        //
        // Figure out the current percentage and update if it has increased.
        //
        dwPercent = (dwCount * 100) / g_App.dwFiles;

        if (dwPercent > dwCurrent) {

            dwCurrent = dwPercent;
            SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) dwCurrent, (LPARAM) 0);
        }

        //
        // Verify the file node if it hasn't already been scanned.
        //
        if (!lpFileNode->bScanned) {

            VerifyFileNode(lpFileNode);
        }

        //
        // In case something went wrong, make sure the version information gets
        // filled in.
        //
        if (!lpFileNode->lpVersion) {

            GetFileVersion(lpFileNode);
        }

        if (lpFileNode->bScanned) {
            //
            // If the file was signed, increment the g_App.dwSigned or
            // g_App.dwUnsigned counter.
            //
            if (lpFileNode->bSigned) {

                g_App.dwSigned++;

            } else {

                g_App.dwUnsigned++;
            }
        }
    }

    //
    // If we had an g_App.hCatAdmin, free it and set it to zero so we can
    // acquire a new one in the future.
    //
    if (g_App.hCatAdmin) {

        CryptCATAdminReleaseContext(g_App.hCatAdmin,0);
        g_App.hCatAdmin = NULL;
    }

    if (!g_App.bStopScan && !g_App.bAutomatedScan) {
        //
        // If the user never clicked STOP, then make sure the progress bar hits
        // 100%
        //
        if (!g_App.bStopScan) {

            SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 100, (LPARAM) 0);
        }

        if (!g_App.dwUnsigned) {
            //
            // If there weren't any unsigned files, then we want to tell the
            // user that everything is dandy!
            //
            if (g_App.dwSigned) {

                MyMessageBoxId(IDS_ALLSIGNED);

            } else {

                MyMessageBoxId(IDS_NOPROBLEMS);
            }

        } else {
            // Show the user the results by going directly to IDD_RESULTS
            //
            DialogBox(g_App.hInstance, MAKEINTRESOURCE(IDD_RESULTS), g_App.hDlg, ListView_DlgProc);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cabs\symbolcd\symsetup\resource.h ===
#define IDD_LICENSE         4000
#define IDC_EDIT_LICENSE    4002
#define IDC_UNUSED          -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cabs\symbolcd\symmake\symmake.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include "dbghelp.h"
#include "strsafe.h"

#define X86INF      200
#define ALPHAINF    201

// Prototypes
typedef struct _COMMAND_ARGS { 
    DWORD   dwCabSize;           // Default size of cab 
    LPTSTR  szInputFileName;     // Name of the list of files to put into cabs 
    LPTSTR  szOutDir;            // Directory to place the makefile and DDF's 
    LPTSTR  szDDFHeader;         // Header for the DDF 
    LPTSTR  szSymDir;            // Root of symbols directory
    LPTSTR  szCabDir;            // Directory to write cabs to
    LPTSTR  szInfDir;            // Directory to write infs to
    LPTSTR  szSymCabName;        // Symbol cab name
    BOOL    MergeIntoOne;        // Will cabs all be merged into one cab?
} COM_ARGS, *PCOM_ARGS; 

typedef struct _SYM_FILE {
    TCHAR szCabName     [_MAX_FNAME + 1];  // Final destination cab for this file
    TCHAR szTmpCabName  [_MAX_FNAME + 1];  // Original cab this file is in before it
                                           // is combined into a bigger cab
    TCHAR szExeName     [_MAX_PATH + 1];
    TCHAR szSymName     [_MAX_PATH + 1];
    TCHAR szSymReName   [_MAX_PATH + 1];
    TCHAR szSymSrcPath  [_MAX_PATH + 1];
    TCHAR szInstallPath [_MAX_PATH + 1];
    TCHAR szInstallPathX [_MAX_PATH + 1];  // This is the install path with
                                           // the /'s changed to .'s
    BOOL  Duplicate;                       // Duplicate File, ignore it
    BOOL  ReName;                          // Two different files have the same
                                           // name.  Example, exe\dcpromo.dbg,
                                           // dll\dcpromo.dbg
    DWORD dwCabNumber;                     // Number of the cab in symbols.inf
} SYM_FILE, *PSYM_FILE;

typedef struct _SYM_LIST {
    DWORD       dwSize;      // Number of Entries
    PSYM_FILE*  pSymList;    // list of symbol files
} SYM_LIST, *PSYM_LIST; 


BOOL PrintFullSymbolPath(
    IN FILE* OutputFile,
    IN OPTIONAL LPTSTR SymbolRoot,
    IN LPTSTR SymbolPath
);

PCOM_ARGS GetCommandLineArgs(
    int argc,
    char **argv
);

PSYM_LIST
GetList(
    LPTSTR szFileName
);

VOID
Usage (
    VOID
);

int __cdecl
SymComp(
      const void *e1,
      const void *e2
);

int __cdecl
SymSortBySymbolName(
      const void *e1,
      const void *e2
);

int __cdecl
SymSortByInstallPath(
      const void *e1,
      const void *e2
);

int __cdecl
SymSortByCabNumber(
      const void *e1,
      const void *e2
);

BOOL
ComputeCabNames(
        PSYM_LIST pList,
        DWORD dwCabSize,
        LPTSTR szSymCabName
);

BOOL
CreateMakefile(
    PSYM_LIST pList,
    LPTSTR szOutDir,    
    LPTSTR szSymDir,
    LPTSTR szCabDir
);

BOOL
CreateDDFs(
    PSYM_LIST pList,
    LPTSTR szOutDir,   // Directory to write the DDFs to
    LPTSTR szSymDir,   // Root of the symbols tree
    LPTSTR szCabDir    // Directory where cabs are written to
);

BOOL
CreateCDF(
    PSYM_LIST pList,
    LPTSTR szOutDir,   // Directory to write the CDF to
    LPTSTR szSymDir,   // Root of the symbols tree
    LPTSTR szSymCabName,
    LPTSTR szInfDir    // Destination for the CAT file
);

BOOL
CreateCabList(
    PSYM_LIST pList,
    LPTSTR szOutDir
);

BOOL
FindDuplicatesAndFilesToReName(
    PSYM_LIST pList
);

BOOL
RenameAllTheFiles(
    PSYM_LIST pList
);

BOOL
ComputeFinalCabNames(
    PSYM_LIST pList,
    LPTSTR szSymCabName,
    BOOL MergeIntoOne
);

BOOL
CreateInf(
    PSYM_LIST pList,
    LPTSTR szInfDir,
    LPTSTR szSymCabName
);

BOOL FreePList(PSYM_LIST pList);


int
_cdecl
main( int argc, char **argv)
{
PCOM_ARGS pArgs;
PSYM_LIST pList;

DWORD i;

    pArgs = GetCommandLineArgs(argc, argv);

    pList = GetList(pArgs->szInputFileName);

    if (pList)
    {
        if ( pList->dwSize < 1 ) {
            FreePList(pList);
            exit(1);
        }

        // First, sort the list by Symbol name
        qsort( (void*)pList->pSymList, (size_t)pList->dwSize,
               (size_t)sizeof(PSYM_FILE), SymSortBySymbolName );

        FindDuplicatesAndFilesToReName(pList);
        RenameAllTheFiles(pList);

        // Compute Temporary cab names ...
        // Make a bunch of small cabs and then combine them to
        // make symbol cabbing more efficient.

        // all functions must return TRUE
        if ( ComputeCabNames(pList, pArgs->dwCabSize, pArgs->szSymCabName)              &&
             CreateMakefile( pList, pArgs->szOutDir,  pArgs->szSymDir, pArgs->szCabDir) &&
             CreateCabList(  pList, pArgs->szOutDir )                                   &&
             CreateDDFs(     pList, pArgs->szOutDir, pArgs->szSymDir,  pArgs->szCabDir) &&
             CreateCDF(      pList, pArgs->szOutDir, pArgs->szSymDir,  pArgs->szSymCabName,
                                    pArgs->szInfDir )                                   &&
             ComputeFinalCabNames(pList, pArgs->szSymCabName, pArgs->MergeIntoOne)      &&
             // Creates symbols.inf that is used to install the symbols
             CreateInf(pList, pArgs->szInfDir, pArgs->szSymCabName) ) {
            return(0);
        } else {
            return(1);
        }
    }

    return 0;
}


VOID
Usage (
    VOID
    )

{

    printf("\n");
    printf("Usage:  symmake [/m] /c CabName /d DDFHeader /i InfFile /o OutDir \n");
    printf("                /s CabSize /t SymbolPath\n");
    printf("    /c cabname      Name to give the cabs\n");
    printf("    /d DDFHeader    File with common DDF header formatting\n");
    printf("    /i InfFile      File with list of symbol files to copy\n");
    printf("    /m Merge        Merge the cabs into one cab\n");
    printf("    /o OutDir       Directory to place DDF files and makefile\n");
    printf("    /s CabSize      Number of files per cab\n");
    printf("    /t SymPath      Root of the symbol tree (i.e., d:\\binaries)\n");
    printf("                    SymPath is ignored if the symbol path in InfFile\n");
    printf("                    is already fully qualified.\n");
    printf("    /x CabDest      Full destination path for the cabs\n");
    printf("    /y InfDest      Full destination for the infs\n");
    printf("\n");
    exit(1);
}


PCOM_ARGS
GetCommandLineArgs(
    int argc,
    char **argv
)

{
   PCOM_ARGS pArgs;
   int i,cur,length;
   TCHAR c;
   BOOL NeedSecond = FALSE;

   if (argc == 1) Usage();

   pArgs = (PCOM_ARGS)malloc(sizeof(COM_ARGS));
   if ( pArgs == NULL ) {
       printf("Not enough memory to allocate pArgs\n");
       exit(1);
   }

   memset( pArgs, 0, sizeof(COM_ARGS) );
   pArgs->MergeIntoOne = FALSE;
   pArgs->szSymDir     = NULL; // expect this to be NULL or a valid string

   for (i=1; i<argc; i++) {

     if (!NeedSecond) {
        if ( (argv[i][0] == '/') || (argv[i][0] == '-') ) {
          length = _tcslen(argv[i]) -1;

          for (cur=1; cur <= length; cur++) {
            c = argv[i][cur];

            switch (c) {
                case 'c':   NeedSecond = TRUE;
                            break;
                case 'd':   NeedSecond = TRUE;
                            break;
                case 'i':   NeedSecond = TRUE;
                            break;
                case 'm':   NeedSecond = FALSE;
                            pArgs->MergeIntoOne = TRUE;
                            break;
                case 'o':   NeedSecond = TRUE;
                            break;
                case 's':   NeedSecond = TRUE;
                            break;
                case 't':   NeedSecond = TRUE;
                            break;
                case 'x':   NeedSecond = TRUE;
                            break;
                case 'y':   NeedSecond = TRUE;
                            break;
                default:    Usage();
            }
          }
        }
     }
     else {
        NeedSecond = FALSE;
        switch (c) {
            case 'c':   pArgs->szSymCabName = argv[i];
                        break;
            case 'd':   pArgs->szDDFHeader = argv[i];
                        break;
            case 'i':   pArgs->szInputFileName = argv[i];
                        break;
            case 'o':   pArgs->szOutDir = argv[i];
                        break;
            case 's':   pArgs->dwCabSize = atoi(argv[i]);
                        break;
            case 't':   pArgs->szSymDir = argv[i];
                        break;
            case 'x':   pArgs->szCabDir = argv[i];
                        break;
            case 'y':   pArgs->szInfDir = argv[i];
                        break;
            default:    Usage();

        }
     }
   }

   return (pArgs);

}


PSYM_LIST
GetList(
    LPTSTR szFileName
)

{

    PSYM_LIST pList;
    FILE  *fFile;
    DWORD i;
    TCHAR szEntry[_MAX_PATH * 4];
    TCHAR *token, *c, *x;
    LPTSTR seps=_T(",");
    PTCHAR pCh;
    
    pList = (PSYM_LIST)malloc(sizeof(SYM_LIST));
    if (pList == NULL )
    {
        return NULL;
    }

    if (  (fFile = _tfopen(szFileName,_T("r") )) == NULL )
    {
        printf( "Cannot open the symbol inf input file %s\n",szFileName );
        free(pList);
        return NULL;
    }

    // Figure out the number of entries and allocate the list accordingly
    pList->dwSize = 0;
    while ( _fgetts(szEntry,_MAX_FNAME,fFile) )
    {
        (pList->dwSize)++;
    }

    // Go back to the beginning of the file and read the entries in
    if ( fseek(fFile,0,0) != 0 )
    {
        free(pList);
        pList = NULL;
    }
    else
    {
        pList->pSymList = NULL;
        pList->pSymList = (PSYM_FILE*)malloc( sizeof(PSYM_FILE) *
                                               (pList->dwSize));
        if (pList->pSymList == NULL)
        {
            free(pList);
            pList = NULL;
        }
        else
        {
            for (i=0; i<pList->dwSize; i++)
            {
                // Allocate the List element
                pList->pSymList[i] = (PSYM_FILE)malloc( sizeof(SYM_FILE) );
                if (pList->pSymList[i] == NULL)
                {
                    pList->dwSize=i;
                    FreePList(pList);
                    pList = NULL;
                    break;
                }
                memset(pList->pSymList[i],0,sizeof(SYM_FILE) );

                // Get the next list element from input file
                memset(szEntry,0,_MAX_PATH*4);
                if ( _fgetts(szEntry,_MAX_PATH*4,fFile) == NULL )
                {
                    FreePList(pList);
                    pList = NULL;
                    break;
                }
                _tcslwr(szEntry);

                // Replace the \n with \0
                c = NULL;
                c  = _tcschr(szEntry, '\n');
                if ( c != NULL )
                {
                    *c  = _T('\0');
                }

                // Fill in the four entry values
                token = _tcstok( szEntry, seps);
                if (token)
                {
                    StringCbCopy(pList->pSymList[i]->szExeName, sizeof(pList->pSymList[i]->szExeName), token);
                }
                token = _tcstok( NULL, seps);
                if (token)
                {
                    StringCbCopy(pList->pSymList[i]->szSymName, sizeof(pList->pSymList[i]->szSymName), token);
                }
                token = _tcstok( NULL, seps);
                if (token)
                {
                    StringCbCopy(pList->pSymList[i]->szSymSrcPath, sizeof(pList->pSymList[i]->szSymSrcPath), token);
                }
                token = _tcstok( NULL, seps);
                if (token)
                {
                    StringCbCopy(pList->pSymList[i]->szInstallPath, sizeof(pList->pSymList[i]->szInstallPath), token);

                    // Create an install path that has any /'s changed to .'s
                    StringCbCopy(pList->pSymList[i]->szInstallPathX, sizeof(pList->pSymList[i]->szInstallPathX), token);
                    while ( (pCh = _tcschr(pList->pSymList[i]->szInstallPathX,'\\')) != NULL) {
                        *pCh = '.';
                    }
                }

                // Initialize other fields to NULL
                StringCbCopy(pList->pSymList[i]->szSymReName, sizeof(pList->pSymList[i]->szSymReName), _T("") );
            }
        }
    }

    fclose(fFile);
    return (pList);
}


int __cdecl
SymComp(
      const void *e1,
      const void *e2
      )
{
    PSYM_FILE p1;
    PSYM_FILE p2;
    int rc;

    p1 = *((PSYM_FILE*)e1);
    p2 = *((PSYM_FILE*)e2);

    rc = _tcsicmp(p1->szCabName,p2->szCabName);
    if ( rc == 0 ) {
        rc = _tcsicmp(p1->szExeName, p2->szExeName);
        if (rc == 0) {
            rc = _tcsicmp(p1->szSymName, p2->szSymName);
        }
    }
    return ( rc );
}

int __cdecl
SymSortBySymbolName(
      const void *e1,
      const void *e2
      )
{

    PSYM_FILE p1;
    PSYM_FILE p2;
    int rc;

    p1 = *((PSYM_FILE*)e1);
    p2 = *((PSYM_FILE*)e2);

    rc = _tcsicmp(p1->szSymName, p2->szSymName);
    if (rc == 0) {
        rc = _tcsicmp(p1->szSymSrcPath, p2->szSymSrcPath);
    }
    return ( rc );
}

int __cdecl
SymSortByInstallPath(
      const void *e1,
      const void *e2
      )
{

    PSYM_FILE p1;
    PSYM_FILE p2;
    int rc;

    p1 = *((PSYM_FILE*)e1);
    p2 = *((PSYM_FILE*)e2);

    rc = _tcsicmp(p1->szInstallPath, p2->szInstallPath);
    if (rc == 0) {
        rc = _tcsicmp(p1->szSymName, p2->szSymName);
    }
    return ( rc );
}


int __cdecl
SymSortByCabNumber(
      const void *e1,
      const void *e2
      )
{

    PSYM_FILE p1;
    PSYM_FILE p2;
    int rc;

    p1 = *((PSYM_FILE*)e1);
    p2 = *((PSYM_FILE*)e2);

    if ( p1->dwCabNumber < p2->dwCabNumber) return(-1);
    if ( p1->dwCabNumber > p2->dwCabNumber) return(1);

    rc = _tcsicmp(p1->szSymName, p2->szSymName);
    return ( rc );
}





BOOL
ComputeCabNames(
        PSYM_LIST pList,
        DWORD dwCabSize,
        LPTSTR szSymCabName
)

{
    // This divides the files into cabs of dwCabSize files.
    // It appends a number to the end of each cab so they all
    // have different names
    // szTmpCabName is the name of the cab that each file is in
    // originally.  These may get combined into bigger cabs later.
    // If they do, then the final cab name is in szCabName.

    TCHAR szCurCabName[_MAX_PATH];
    TCHAR szCurAppend[10];
    DWORD i,dwCurCount,dwCurAppend;

    if (dwCabSize <= 0 ) return 1;
    if (szSymCabName == NULL) return FALSE;

    // Get the Cab name of the first one
    StringCbCopy(szCurCabName, sizeof(szCurCabName), szSymCabName );
    StringCbCat( szCurCabName, sizeof(szCurCabName), _T("1") );
    StringCbCopy(pList->pSymList[0]->szTmpCabName, sizeof(pList->pSymList[0]->szTmpCabName), szCurCabName);

    dwCurCount = 1;             // Number of files in this cab so far
    dwCurAppend = 1;            // Current number to append to the cab name
    

    for ( i=1; i<pList->dwSize; i++ ) {

        // Always put symbols for the same exe in the same cab
        if ( (_tcsicmp( pList->pSymList[i-1]->szExeName,
                       pList->pSymList[i]->szExeName ) != 0) &&
             (dwCurCount >= dwCabSize) ) {

            dwCurAppend++;
            dwCurCount = 0;
            _itot(dwCurAppend, szCurAppend, 10);
            
            StringCbCopy(szCurCabName, sizeof(szCurCabName), szSymCabName );
            StringCbCat (szCurCabName, sizeof(szCurCabName), szCurAppend );
        }

        // Add the file to the current cab
        StringCbCopy(pList->pSymList[i]->szTmpCabName, sizeof(pList->pSymList[i]->szTmpCabName), szCurCabName);
        dwCurCount++;
    }
    return TRUE;
}

BOOL
ComputeFinalCabNames(
        PSYM_LIST pList,
        LPTSTR szSymCabName,
        BOOL MergeIntoOne
)

{
    DWORD i;
    DWORD dwCabNumber, dwSkip;

    // For right now, the final cab name is the same as the 
    // temporary cab name.

    for ( i=0; i<pList->dwSize; i++ ) {

        // Get the final cab name and number

        if (MergeIntoOne) {
            StringCbCopy(pList->pSymList[i]->szCabName, sizeof(pList->pSymList[i]->szCabName), szSymCabName);
            pList->pSymList[i]->dwCabNumber = 1;

        } else {
            StringCbCopy(pList->pSymList[i]->szCabName,
                         sizeof(pList->pSymList[i]->szCabName),
                         pList->pSymList[i]->szTmpCabName);

            // Also, get the number of the cab
            dwSkip = _tcslen( szSymCabName );
            dwCabNumber = atoi(pList->pSymList[i]->szTmpCabName + dwSkip);
            pList->pSymList[i]->dwCabNumber = dwCabNumber;
        }
    }
    return TRUE;
}


BOOL
CreateMakefile(
    PSYM_LIST pList,
    LPTSTR szOutDir,
    LPTSTR szSymDir,
    LPTSTR szCabDir
)
{

    FILE  *fFile;
    TCHAR buf[_MAX_PATH * 2];
    TCHAR buf2[_MAX_PATH];
    BOOL  newcab,rc;
    DWORD i;
    PCHAR ch;

    if (szOutDir == NULL) return FALSE;

    rc = TRUE;
    StringCbCopy(buf, sizeof(buf), szOutDir);
    MakeSureDirectoryPathExists(szOutDir); 
    StringCbCat(buf, sizeof(buf), "\\");
    StringCbCat(buf, sizeof(buf), "makefile");
    
    if (  (fFile = _tfopen(buf, _T("w") )) == NULL ) {
        printf( "Cannot open the makefile %s for writing.\n",buf);
        return (FALSE);
    }

    if (pList->dwSize <= 0 ) {
        rc = FALSE;
        goto cleanup;
    }

    // Print the lists for the individual cabs
    newcab = TRUE;

    for (i=0; i<pList->dwSize; i++) {

        // Test for printing a new cab to the makefile
        if ( newcab) {
            StringCbPrintf(buf, sizeof(buf), "%s\\%s.cab:", 
                        szCabDir,
                        pList->pSymList[i]->szTmpCabName);
            _fputts(buf, fFile);
        }

        // Print the file, print the continuation mark first
        if ( !(pList->pSymList[i]->Duplicate) ) {
            _fputts("\t\\\n\t", fFile);
            PrintFullSymbolPath(fFile, szSymDir, pList->pSymList[i]->szSymSrcPath);
        }

        // Decide if this is the end of this cab
        if ( (i != pList->dwSize-1) &&
             (_tcsicmp(pList->pSymList[i]->szTmpCabName,
                       pList->pSymList[i+1]->szTmpCabName) == 0) ) {
            newcab = FALSE;
        }
        else {
            newcab = TRUE;
            StringCbPrintf(buf, sizeof(buf), "\n\t!echo $?>>%s.txt\n\n",
                            pList->pSymList[i]->szTmpCabName);
            _fputts(buf, fFile);
        }
    }

cleanup:
    fflush(fFile);
    fclose(fFile);
    return rc;
}


BOOL
CreateDDFs(
    PSYM_LIST pList,
    LPTSTR szOutDir,   // Directory to write the DDFs to
    LPTSTR szSymDir,
    LPTSTR szCabDir
)
{
    BOOL newddf;
    FILE *fFile;
    TCHAR szCabName[_MAX_PATH*2];
    TCHAR buf[_MAX_PATH*2];
    DWORD i;

    if (szOutDir == NULL) return FALSE;

    newddf = TRUE;

    for (i=0; i<pList->dwSize; i++) {

        if (newddf) {
            newddf = FALSE;

            StringCbCopy(szCabName, sizeof(szCabName), szOutDir);
            StringCbCat(szCabName, sizeof(szCabName), _T("\\") );
            StringCbCat(szCabName, sizeof(szCabName), pList->pSymList[i]->szTmpCabName);
            StringCbCat(szCabName, sizeof(szCabName), _T(".ddf") );

            if (  (fFile = _tfopen(szCabName, _T("w") )) == NULL ) {
                printf( "Cannot open the ddf file %s for writing.\n",szCabName);
                return FALSE;
            }

            //
            // Write the header
            //

            // .option explicit will complain if you make a spelling error
            // in any of the other .set commands
            _fputts(".option explicit\n", fFile);
           

            // Tell what directory to write the cabs to:
            StringCbPrintf(buf, sizeof(buf), ".Set DiskDirectoryTemplate=%s\n", szCabDir);
            _fputts(buf, fFile);

            _fputts(".Set RptFileName=nul\n", fFile);
            _fputts(".Set InfFileName=nul\n", fFile);

            StringCbPrintf(buf, sizeof(buf), ".Set CabinetNameTemplate=%s.cab\n",
                           pList->pSymList[i]->szTmpCabName);
            _fputts(buf, fFile);

            _fputts(".Set CompressionType=MSZIP\n", fFile);
            _fputts(".Set MaxDiskSize=CDROM\n", fFile);
            _fputts(".Set ReservePerCabinetSize=0\n", fFile);
            _fputts(".Set Compress=on\n", fFile);
            _fputts(".Set CompressionMemory=21\n", fFile);
            _fputts(".Set Cabinet=ON\n", fFile);
            _fputts(".Set MaxCabinetSize=999999999\n", fFile);
            _fputts(".Set FolderSizeThreshold=1000000\n", fFile);
        }

        // Write the file to the DDF
        if ( !pList->pSymList[i]->Duplicate) {
            fputs("\"",fFile); // begin quote
            PrintFullSymbolPath(fFile, szSymDir, pList->pSymList[i]->szSymSrcPath);
            fputs("\"",fFile); // end quote

            // optional rename and \n
            if ( pList->pSymList[i]->ReName) {
                StringCbPrintf( buf, sizeof(buf), " \"%s\"\n", 
                        pList->pSymList[i]->szSymReName);

            } else {
                StringCbPrintf(buf, sizeof(buf), "\n");
            }
            _fputts(buf, fFile);
        }

        // Check if this is the end of this DDF
        if ( i == pList->dwSize-1) {
            fflush(fFile);
            fclose(fFile);
            break;
        } 

        // See if the next file in the list starts a new DDF
        if ( _tcsicmp(pList->pSymList[i]->szTmpCabName,
                      pList->pSymList[i+1]->szTmpCabName) != 0 ) {
            fflush(fFile);
            fclose(fFile);
            newddf = TRUE;
        } 
    }
    return TRUE;
}

BOOL
CreateCDF(
    PSYM_LIST pList,
    LPTSTR szOutDir,   // Directory to write the CDF to
    LPTSTR szSymDir,   // Root of the symbols tree
    LPTSTR szSymCabName,
    LPTSTR szInfDir
)
{

    FILE *fFile;
    FILE *fFile2;
    TCHAR buf[_MAX_PATH*2];
    DWORD i;
    TCHAR szCDFName[_MAX_PATH];
    TCHAR szCDFMakefile[_MAX_PATH];

    if (szOutDir == NULL) return FALSE;
    if (szSymCabName == NULL) return FALSE;

    StringCbCopy(szCDFName, sizeof(szCDFName), szOutDir);
    StringCbCat( szCDFName, sizeof(szCDFName), _T("\\") );
    StringCbCat( szCDFName, sizeof(szCDFName), szSymCabName);

    // Create a makefile for this, so we can do incremental
    // adds to the CAT file.
    StringCbCopy(szCDFMakefile, sizeof(szCDFMakefile), szCDFName);
    StringCbCat( szCDFMakefile, sizeof(szCDFMakefile), _T(".CDF.makefile") );
    StringCbCat( szCDFName, sizeof(szCDFName), _T(".CDF.noheader") );

    if (  (fFile = _tfopen(szCDFName, _T("w") )) == NULL ) {
        printf( "Cannot open the CDF file %s for writing.\n",szCDFName);
        return FALSE;
    }

    if (  (fFile2 = _tfopen(szCDFMakefile, _T("w") )) == NULL ) {
        printf( "Cannot open the CDF file %s for writing.\n",szCDFMakefile);
        return FALSE;
    }

    // Write the first line of the makefile for the Catalog
    StringCbPrintf( buf, sizeof(buf), "%s\\%s.CAT:", szInfDir, szSymCabName );
    _fputts( buf, fFile2);


    for (i=0; i<pList->dwSize; i++) {

        // Write the file to the DDF
        if ( !pList->pSymList[i]->Duplicate) {
            _fputts("<HASH>", fFile );
            PrintFullSymbolPath(fFile, szSymDir, pList->pSymList[i]->szSymSrcPath);
            _fputts( "=", fFile);           
            PrintFullSymbolPath(fFile, szSymDir, pList->pSymList[i]->szSymSrcPath);
            _fputts("\n", fFile);
            _fputts( "  \\\n    ", fFile2 );
            PrintFullSymbolPath(fFile2, szSymDir, pList->pSymList[i]->szSymSrcPath);
        }

    }
   
    // Write the last line of the makefile
    StringCbPrintf(buf, sizeof(buf), "\n\t!echo $? >> %s\\%s.update\n", 
                   szOutDir,
                   szSymCabName );
    _fputts( buf, fFile2 );

    fflush(fFile);
    fclose(fFile);

    fflush(fFile2);
    fclose(fFile2);

    return TRUE;

}


BOOL
CreateCabList(
    PSYM_LIST pList,
    LPTSTR szOutDir
)
{
    
   
    FILE  *fFile;
    TCHAR buf[_MAX_PATH*2];
    DWORD i;
    BOOL rc;

    rc = TRUE;

    if (szOutDir == NULL) return FALSE;

    StringCbCopy(buf, sizeof(buf), szOutDir);
    MakeSureDirectoryPathExists(szOutDir);
    StringCbCat( buf, sizeof(buf), "\\");
    StringCbCat( buf, sizeof(buf), "symcabs.txt");

    if (  (fFile = _tfopen(buf, _T("w") )) == NULL ) {
        printf( "Cannot open %s for writing.\n",buf);
        return(FALSE);
    }

    if (pList->dwSize <= 0 ) {
        rc = FALSE;
        goto cleanup;
    }

    // First, print a list of all the targets
    StringCbPrintf(buf, sizeof(buf), "%s.cab\n",
                   pList->pSymList[0]->szTmpCabName);
    _fputts(buf, fFile);

    for (i=1; i<pList->dwSize; i++) {
        if ( _tcsicmp(pList->pSymList[i]->szTmpCabName,
                      pList->pSymList[i-1]->szTmpCabName) != 0 ) {

            StringCbPrintf(buf,sizeof(buf), "%s.cab\n",
                        pList->pSymList[i]->szTmpCabName);
            _fputts(buf, fFile);
        }
    } 
  
cleanup:
 
    fflush(fFile);
    fclose(fFile);
    return (rc);
}

BOOL
RenameAllTheFiles(
    PSYM_LIST pList
)
{
    DWORD i;
    PTCHAR pCh;

    // Rename all the files so that there is consistency in
    // file naming.  This will help the transition to building
    // slip-streamed service packs.

    for (i=0; i<pList->dwSize; i++) {

        pList->pSymList[i]->ReName = TRUE;
        StringCbCopy(pList->pSymList[i]->szSymReName,
                     sizeof(pList->pSymList[i]->szSymReName), 
                     pList->pSymList[i]->szSymName);
        StringCbCat(pList->pSymList[i]->szSymReName,
                    sizeof(pList->pSymList[i]->szSymReName),
                    _T("."));
        StringCbCat(pList->pSymList[i]->szSymReName, 
                    sizeof(pList->pSymList[i]->szSymReName),
                    pList->pSymList[i]->szInstallPathX);

    }
    return (TRUE);
}


BOOL
FindDuplicatesAndFilesToReName(
    PSYM_LIST pList
)
{

    DWORD i;
    PTCHAR pCh;

    // Its a duplicate if the symbol file has the same name and its
    // exe has the same extension (i.e., it has the same cab name

    pList->pSymList[0]->Duplicate = FALSE;
    pList->pSymList[0]->ReName = FALSE;
    for (i=1; i<pList->dwSize; i++) {

        // See if file name is duplicate
        if ( _tcsicmp(pList->pSymList[i]->szSymName,
                      pList->pSymList[i-1]->szSymName) == 0) {

            // These two symbol files have the same name.  See if
            // they get installed to the same directory.
            if (_tcsicmp(pList->pSymList[i]->szInstallPath,
                      pList->pSymList[i-1]->szInstallPath) == 0) {

                // We will ignore this file later
                pList->pSymList[i]->Duplicate = TRUE;

            } else {

                // There are two versions of this file, but they
                // are each different and get installed to different
                // directories.  One of them will need to be renamed
                // since the names inside cabs and infs need to be
                // unique.
                pList->pSymList[i]->ReName = TRUE;
                StringCbCopy(pList->pSymList[i]->szSymReName,
                             sizeof(pList->pSymList[i]->szSymReName),
                             pList->pSymList[i]->szSymName);
                StringCbCat( pList->pSymList[i]->szSymReName,
                             sizeof(pList->pSymList[i]->szSymReName),
                             _T("."));
                StringCbCat( pList->pSymList[i]->szSymReName, 
                             sizeof(pList->pSymList[i]->szSymReName),
                             pList->pSymList[i]->szInstallPathX);
            }
        }
        else {
            pList->pSymList[i]->Duplicate = FALSE;
            pList->pSymList[i]->ReName = FALSE;
        }
  }
  return (TRUE);
}

//
// defines and structure for CreateInf
//
#define _MAX_STRING             40 // max length for strings
#define INSTALL_SECTION_COUNT    6 // number of install sections
typedef struct _INSTALL_SECTION_INFO {
    CHAR SectionName[      _MAX_STRING+1];  // required
    CHAR CustomDestination[_MAX_STRING+1];  // required
    CHAR BeginPrompt[      _MAX_STRING+1];  // optional
    CHAR EndPrompt[        _MAX_STRING+1];  // optional
} INSTALL_SECTION_INFO;


BOOL
CreateInf(
    PSYM_LIST pList,
    LPTSTR szInfDir,
    LPTSTR szSymCabName
)
{
    FILE  *fFile;
    TCHAR buf[_MAX_PATH*2];
    TCHAR szCurInstallPathX[_MAX_PATH+1];
    DWORD i, dwCurDisk;

    INSTALL_SECTION_INFO InstallSections[INSTALL_SECTION_COUNT];
    INT iLoop;

    if (szInfDir == NULL) return FALSE;
    if (szSymCabName == NULL) return FALSE;


    // make all strings empty by default
    ZeroMemory(InstallSections, sizeof(InstallSections));

    // setup the variable data for each section
    StringCbCopy(InstallSections[0].SectionName,       sizeof(InstallSections[0].SectionName),       "DefaultInstall");
    StringCbCopy(InstallSections[0].CustomDestination, sizeof(InstallSections[0].CustomDestination), "CustDest");
    StringCbCopy(InstallSections[0].BeginPrompt,       sizeof(InstallSections[0].BeginPrompt),       "BeginPromptSection");
    StringCbCopy(InstallSections[0].EndPrompt,         sizeof(InstallSections[0].EndPrompt),         "EndPromptSection");

    StringCbCopy(InstallSections[1].SectionName,       sizeof(InstallSections[1].SectionName),       "DefaultInstall.Quiet");
    StringCbCopy(InstallSections[1].CustomDestination, sizeof(InstallSections[1].CustomDestination), "CustDest.2");

    StringCbCopy(InstallSections[2].SectionName,       sizeof(InstallSections[2].SectionName),       "DefaultInstall.Chained.1");
    StringCbCopy(InstallSections[2].CustomDestination, sizeof(InstallSections[2].CustomDestination), "CustDest");
    StringCbCopy(InstallSections[2].BeginPrompt,       sizeof(InstallSections[2].BeginPrompt),       "BeginPromptSection");

    StringCbCopy(InstallSections[3].SectionName,       sizeof(InstallSections[3].SectionName),       "DefaultInstall.Chained.1.Quiet");
    StringCbCopy(InstallSections[3].CustomDestination, sizeof(InstallSections[3].CustomDestination), "CustDest.2");

    StringCbCopy(InstallSections[4].SectionName,       sizeof(InstallSections[4].SectionName),       "DefaultInstall.Chained.2");
    StringCbCopy(InstallSections[4].CustomDestination, sizeof(InstallSections[4].CustomDestination), "CustDest.2");
    StringCbCopy(InstallSections[4].EndPrompt,         sizeof(InstallSections[4].EndPrompt),         "EndPromptSection");

    StringCbCopy(InstallSections[5].SectionName,       sizeof(InstallSections[5].SectionName),       "DefaultInstall.Chained.2.Quiet");
    StringCbCopy(InstallSections[5].CustomDestination, sizeof(InstallSections[5].CustomDestination), "CustDest.2");


    StringCbCopy(buf, sizeof(buf), szInfDir);

    MakeSureDirectoryPathExists(szInfDir);

    // Get the name of the inf ... name it the same as the cabs
    // with an .inf extension
    StringCbCat(buf, sizeof(buf), _T("\\"));
    StringCbCat(buf, sizeof(buf), szSymCabName);
    StringCbCat(buf, sizeof(buf), _T(".inf") );

    if (  (fFile = _tfopen(buf, _T("w") )) == NULL ) {
        printf( "Cannot open %s for writing.\n",buf);
        return FALSE;
    }

    // Write the header for the inf
    _fputts("[Version]\n", fFile);
    _fputts("AdvancedInf= 2.5\n", fFile);
    _fputts("Signature= \"$CHICAGO$\"\n", fFile);
    StringCbPrintf(buf, sizeof(buf), "CatalogFile= %s.CAT\n", szSymCabName);
    _fputts(buf, fFile);
    _fputts("\n", fFile);

    //
    // Do the default installs 
    // This inf has options for how it will be called.  It has
    // provision for a chained incremental install.
    //
    // DefaultInstall -- standalone install.
    // DefaultInstall.Quiet -- standalone with no UI intervention
    // DefaultInstall.Chained.1 -- first part of a chained install
    // DefaultInstall.Chained.1.Quiet -- first part of a chained install with no UI intervention
    // DefaultInstall.Chained.2 -- second part of a chained install
    // DefaultInstall.Chained.2.Quiet -- second part of a chained install with no UI intervention
    //

    //
    // Do the install sections
    //
    for (iLoop = 0; iLoop < INSTALL_SECTION_COUNT; iLoop++) {
        fprintf(fFile, "[%s]\n"                , InstallSections[iLoop].SectionName);
        fprintf(fFile, "CustomDestination=%s\n", InstallSections[iLoop].CustomDestination);

        // BeginPrompt is optional
        if (strlen(InstallSections[iLoop].BeginPrompt) > 0) {
            fprintf(fFile, "BeginPrompt=%s\n", InstallSections[iLoop].BeginPrompt);
        }

        // EndPrompt is optional
        if (strlen(InstallSections[iLoop].EndPrompt) > 0) {
            fprintf(fFile, "EndPrompt=%s\n", InstallSections[iLoop].EndPrompt);
        }

        // from here to end of loop, output is identical for all sections

        _fputts("AddReg= RegVersion\n", fFile);
        _fputts("RequireEngine= Setupapi;\n", fFile);

        // 
        // Print the Copyfiles line
        //

        _fputts("CopyFiles= ", fFile);

        // First, sort the list by Install Path
        qsort( (void*)pList->pSymList, (size_t)pList->dwSize,
               (size_t)sizeof(PSYM_FILE), SymSortByInstallPath);

        // Print the files sections that need to be installed
        StringCbPrintf(  buf, sizeof(buf), "Files.%s", 
                    pList->pSymList[0]->szInstallPathX);
        _fputts(buf, fFile);
        StringCbCopy(szCurInstallPathX, sizeof(szCurInstallPathX), pList->pSymList[0]->szInstallPathX);

        for (i=0; i<pList->dwSize; i++) {

            if ( pList->pSymList[i]->Duplicate) continue;

            // See if we have a new files section
            if ( _tcsicmp(  pList->pSymList[i]->szInstallPathX,
                            szCurInstallPathX) != 0 ) {

                // Print the files sections
                StringCbPrintf(buf, sizeof(buf), ", Files.%s",
                               pList->pSymList[i]->szInstallPathX);
                _fputts(buf, fFile);
                StringCbCopy(szCurInstallPathX, sizeof(szCurInstallPathX), pList->pSymList[i]->szInstallPathX);
            }

        }
        _fputts("\n\n", fFile);
    } // end of install sections loop

    // Print the Default Uninstall line
    //
    _fputts("[DefaultUninstall]\n", fFile);
    _fputts("CustomDestination= CustDest\n", fFile);
    _fputts("BeginPrompt= DelBeginPromptSection\n", fFile);
    _fputts("DelFiles= ", fFile);

    // Print the files sections that need to be installed
    StringCbPrintf(buf, sizeof(buf), "Files.%s", pList->pSymList[0]->szInstallPathX);
    _fputts(buf, fFile);
    StringCbCopy(szCurInstallPathX, sizeof(szCurInstallPathX), pList->pSymList[0]->szInstallPathX);

    for (i=0; i<pList->dwSize; i++) {

       if ( pList->pSymList[i]->Duplicate) continue;

       // See if we have a new files section
       if ( _tcsicmp(  pList->pSymList[i]->szInstallPathX,
                       szCurInstallPathX) != 0 ) {

           // Print the files sections
           StringCbPrintf(buf, sizeof(buf), ", Files.%s",
                          pList->pSymList[i]->szInstallPathX);
           _fputts(buf, fFile);
           StringCbCopy(szCurInstallPathX, sizeof(szCurInstallPathX), pList->pSymList[i]->szInstallPathX);
       }

    }
    _fputts("\n", fFile);
    _fputts("DelDirs= DelDirsSection\n", fFile);
    _fputts("DelReg= RegVersion\n", fFile);
    _fputts("EndPrompt= DelEndPromptSection\n", fFile);
    _fputts("RequireEngine= Setupapi;\n\n", fFile);

    //
    // Print the [BeginPromptSection]
    //

    _fputts("[BeginPromptSection]\n", fFile);
    _fputts("Title= \"Microsoft Windows Symbols\"\n", fFile);
    _fputts("\n", fFile);

    //
    // Print the [DelBeginPromptSection]
    //

    _fputts("[DelBeginPromptSection]\n", fFile);
    _fputts("Title= \"Microsoft Windows Symbol Uninstall\"\n", fFile);
    _fputts("ButtonType= YESNO\n", fFile);
    _fputts("Prompt= \"Do you want to remove Microsoft Windows Symbols?\"\n", fFile); 
    _fputts("\n", fFile);

    //
    // Print the [EndPromptSection]
    //

    _fputts("[EndPromptSection]\n", fFile);
    _fputts("Title= \"Microsoft Windows Symbols\"\n", fFile);
    _fputts("Prompt= \"Installation is complete\"\n", fFile);
    _fputts("\n", fFile);

    //
    // Print the [DelEndPromptSection]
    //
   
    _fputts("[DelEndPromptSection]\n", fFile); 
    _fputts("Prompt= \"Uninstall is complete\"\n", fFile);
    _fputts("\n", fFile);
   
    //
    // Print the [RegVersion] Section
    //
    _fputts("[RegVersion]\n", fFile);
    _fputts("\"HKLM\",\"SOFTWARE\\Microsoft\\Symbols\\Directories\",\"Symbol Dir\",0,\"%49100%\"\n", fFile);
    _fputts("\"HKCU\",\"SOFTWARE\\Microsoft\\Symbols\\Directories\",\"Symbol Dir\",0,\"%49100%\"\n", fFile);
    _fputts("\"HKCU\",\"SOFTWARE\\Microsoft\\Symbols\\SymbolInstall\",\"Symbol Install\",,\"1\"\n", fFile);
    _fputts(";\"HKLM\",\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Symbols\",\"DisplayName\",,\"Microsoft Windows Symbols\"\n", fFile);
    _fputts(";\"HKLM\",\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Symbols\",\"UninstallString\",,\"RunDll32.exe advpack.dll,LaunchINFSection symusa.inf,DefaultUninstall\"\n", fFile);
    _fputts(";\"HKLM\",\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Symbols\",\"RequiresIESysFile\",,\"4.71\"\n", fFile);
    _fputts("\n", fFile);

    // 
    // Print the Custom Destination Section
    //
    
    _fputts("[SymCust]\n", fFile);
    _fputts("\"HKCU\", \"Software\\Microsoft\\Symbols\\Directories\",\"Symbol Dir\",\"Symbols install directory\",\"%25%\\Symbols\"\n", fFile);
    _fputts("\n", fFile);

    // 
    // Print the CustDest section
    //
    _fputts("[CustDest]\n", fFile);
    _fputts("49100=SymCust,1\n", fFile);
    _fputts("\n", fFile);

    // 
    // Print the CustDest section
    // Don't prompt the user for where to install, just read
    // it out of the registry
    //
    _fputts("[CustDest.2]\n", fFile);
    _fputts("49100=SymCust,5\n", fFile);
    _fputts("\n", fFile);

    //
    // Print the DestinationDirs section
    //

    StringCbCopy(szCurInstallPathX, sizeof(szCurInstallPathX), "");
    _fputts("[DestinationDirs]\n", fFile);
    _fputts(";49100 is %systemroot%\\symbols\n", fFile);
    _fputts("\n", fFile);
    _fputts("Files.inf\t\t\t= 17\n", fFile);
    _fputts("Files.system32\t\t\t= 11\n", fFile);

    for (i=0; i<pList->dwSize; i++) {

        if ( pList->pSymList[i]->Duplicate) continue;

        // See if we have a new files section
        if ( _tcsicmp(  pList->pSymList[i]->szInstallPathX,
                    szCurInstallPathX) != 0 ) {

            // Print the files sections
            StringCbPrintf(buf,  sizeof(buf), "Files.%s\t\t\t= 49100,\"%s\"\n",
                          pList->pSymList[i]->szInstallPathX,
                          pList->pSymList[i]->szInstallPath
                         );
            _fputts(buf, fFile);
            StringCbCopy(szCurInstallPathX, sizeof(szCurInstallPathX), pList->pSymList[i]->szInstallPathX);
        }
    } 
    _fputts("\n", fFile);

    //
    // Print the DelDirsSection
    //

    StringCbCopy(szCurInstallPathX, sizeof(szCurInstallPathX), pList->pSymList[0]->szInstallPathX);
    _fputts("[DelDirsSection]\n", fFile);

    for (i=0; i<pList->dwSize; i++) {
        if ( pList->pSymList[i]->Duplicate) continue;

        // See if we have a new files section
        if ( _tcsicmp(  pList->pSymList[i]->szInstallPathX,
                    szCurInstallPathX) != 0 ) {

            // Print the files sections
            _fputts("%49100%\\", fFile);
            _fputts(pList->pSymList[i]->szInstallPath, fFile);
            _fputts("\n", fFile);

            StringCbCopy(szCurInstallPathX, sizeof(szCurInstallPathX), pList->pSymList[i]->szInstallPathX);
        }
    }


    _fputts("%49100%\n\n", fFile);
 

    //
    // Print the files section
    //

    _fputts("[Files.inf]\n", fFile);

    StringCbPrintf(buf, sizeof(buf), "%s.inf,,,4\n\n", szSymCabName);
    _fputts(buf, fFile);

    _fputts("[Files.system32.x86]\n", fFile);
    _fputts("advpack.dll,,,96\n\n", fFile);

    _fputts("[Files.system32.alpha]\n", fFile);
    _fputts("advpack.dll, advpacka.dll,,96\n\n", fFile);

    StringCbPrintf(buf, sizeof(buf), "[Files.%s]\n", pList->pSymList[0]->szInstallPathX);
    _fputts(buf, fFile);
    StringCbCopy(szCurInstallPathX, sizeof(szCurInstallPathX), pList->pSymList[0]->szInstallPathX);

    
    for (i=0; i<pList->dwSize; i++) {

        if ( pList->pSymList[i]->Duplicate) continue;

        // See if we have a new files section
        if ( _tcsicmp(  pList->pSymList[i]->szInstallPathX,
                        szCurInstallPathX) != 0 ) {

            // Print the files sections
            StringCbPrintf(buf, sizeof(buf), "\n[Files.%s]\n", 
                            pList->pSymList[i]->szInstallPathX);
            _fputts(buf, fFile);
            StringCbCopy(szCurInstallPathX, sizeof(szCurInstallPathX), pList->pSymList[i]->szInstallPathX);
        } 

        // Print the file name inside the cab
        StringCbPrintf(buf, sizeof(buf), "%s,%s,,4\n", pList->pSymList[i]->szSymName,
                        pList->pSymList[i]->szSymReName);
        _fputts(buf, fFile);
    }

    // Print the SourceDisksNames section

    // First sort the list by the final cab name
    qsort( (void*)pList->pSymList, (size_t)pList->dwSize,
           (size_t)sizeof(PSYM_FILE), SymSortByCabNumber); 


    _fputts("\n[SourceDisksNames]\n", fFile);
    dwCurDisk = -1;

    // Print the SourceDisks section
    for (i=0; i<pList->dwSize; i++) {

        if ( pList->pSymList[i]->dwCabNumber != dwCurDisk ) {

            // New cab name
            dwCurDisk = pList->pSymList[i]->dwCabNumber;
            StringCbPrintf(buf, sizeof(buf), "%1d=\"%s.cab\",%s.cab,0\n", 
                                             dwCurDisk,
                                             pList->pSymList[i]->szCabName, 
                                             pList->pSymList[i]->szCabName);

            _fputts(buf, fFile);
        }
    }

    // Print the SourceDisksFiles section
    _fputts("\n[SourceDisksFiles]\n", fFile);
    
    for (i=0; i<pList->dwSize; i++) {

        if ( pList->pSymList[i]->ReName ) {
            StringCbPrintf(buf, sizeof(buf), "%s=%1d\n",
                           pList->pSymList[i]->szSymReName,
                           pList->pSymList[i]->dwCabNumber );
        } else {
            StringCbPrintf(buf, sizeof(buf), "%s=%1d\n",
                           pList->pSymList[i]->szSymName,
                           pList->pSymList[i]->dwCabNumber );
        }
        _fputts(buf, fFile);
    }

    fflush(fFile);
    fclose(fFile);

    return TRUE;
}



BOOL FreePList(
    PSYM_LIST pList
)
{
   DWORD i;

   if ( pList==NULL ) return TRUE;
   if ( pList->pSymList == NULL ) {
       free(pList);
       return (TRUE);
   }

   for (i=0; i<pList->dwSize; i++) {
        free(pList->pSymList[i]);
   } 

   free(pList->pSymList);
   free(pList);
   return (TRUE);
}

/* ------------------------------------------------------------------------------------------------

Prints the fully qualified path to a symbol using the following logic:
    - if SymbolRoot is NULL, assume SymbolPath is a fully qualified path and print it
    - if SymbolPath begins with "%c:\" or "\\", assume SymbolPath is fully qualified and print it
    - assume the concatenation "SymbolRoot\\SymbolPath" is the fully qualified path and print it

------------------------------------------------------------------------------------------------ */
BOOL PrintFullSymbolPath(IN FILE* OutputFile, IN OPTIONAL LPTSTR SymbolRoot, IN LPTSTR SymbolPath) {

    if ( (OutputFile == NULL) || (SymbolPath == NULL) ) {
        return(FALSE);
    }

    if (SymbolRoot == NULL) {
        fprintf(OutputFile, "%s", SymbolPath);
    } else if (isalpha(SymbolPath[0]) && SymbolPath[1] == ':' && SymbolPath[2] == '\\') {
        fprintf(OutputFile, "%s", SymbolPath);
    } else if (SymbolPath[0] == '\\' && SymbolPath[1] == '\\') {
        fprintf(OutputFile, "%s", SymbolPath);
    } else {
        fprintf(OutputFile, "%s\\%s", SymbolRoot, SymbolPath);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cabs\symbolcd\symsetup\commandline.c ===
#include "CommandLine.h"
#include <malloc.h>

BOOL WINAPI MakeSureDirectoryPathExistsW(LPCWSTR DirPath);

DWORD WINAPI CheckCommandLineOptions(INT ArgC, LPWSTR* ArgVW) {
    DWORD  dwReturnFlags = 0;
    INT    i;
    WCHAR* cp;
    WCHAR  wszInstallPath[MAX_PATH+1];

    for (i = 1; i < ArgC && wcschr(L"/-",ArgVW[i][0]) != NULL; ++i) {

        for (cp = &ArgVW[i][1]; *cp != L'\0'; ++cp) {
            switch (towupper(*cp)) {
                case L'U': {
                            HKEY  hKey;

                            LONG  lStatus          = 0;
                            LONG  lCreatedOrOpened = 0;
                            SET_FLAG(dwReturnFlags, FLAG_UNATTENDED_INSTALL);

                            // next param isn't a flag (or NULL), so it *must* be the path to install to
                            if ( (i+1 < ArgC) && wcschr(L"/-",ArgVW[i+1][0]) == NULL ) {
                                i++; // account for the parameter removed

                                SET_FLAG(dwReturnFlags, FLAG_UNATTENDED_PATH_PROVIDED);
                                StringCchCopyW(wszInstallPath, MAX_PATH+1, ArgVW[i]);

                                // make sure path ends in '\'
                                if (wszInstallPath[wcslen(wszInstallPath)]!=L'\\')
                                    StringCchCatW(wszInstallPath,MAX_PATH+1,L"\\");

                                // make sure the directory exists!
                                if (! MakeSureDirectoryPathExistsW(wszInstallPath) ) {
                                    SET_FLAG(dwReturnFlags, FLAG_FATAL_ERROR);
                                } else {
                                    // Either create the regkey (if it doesn't exist) or open it (if it
                                    // does exist). lCreatedOrOpened can be tested against
                                    // REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY to determine which
                                    // occurred.
                                    lStatus = RegCreateKeyExW(SYMBOLS_REGKEY_ROOT,
                                                              SYMBOLS_REGKEY_PATH,
                                                              0,
                                                              NULL,
                                                              REG_OPTION_NON_VOLATILE,
                                                              KEY_ALL_ACCESS,
                                                              NULL,
                                                              &hKey,
                                                              &lCreatedOrOpened);

                                    if (lStatus != ERROR_SUCCESS) {
                                        SET_FLAG(dwReturnFlags, FLAG_FATAL_ERROR);
                                    } else {
                                        // Write the value of the path to SYMBOLS_REGKEY
                                        lStatus = RegSetValueExW( hKey, SYMBOLS_REGKEY, 0, REG_SZ, (BYTE*)wszInstallPath, ((wcslen(wszInstallPath) + 1) * sizeof(WCHAR)));
                                        if (lStatus != ERROR_SUCCESS) {
                                            SET_FLAG(dwReturnFlags, FLAG_FATAL_ERROR);
                                        }
                                        // close the regkey
                                        lStatus = RegCloseKey( hKey );
                                        if (lStatus != ERROR_SUCCESS) {
                                            SET_FLAG(dwReturnFlags, FLAG_ERROR);
                                        }

                                    }
                                } // else ...
                                // couldn't set the path requests, so use what's
                                // already in the registry.

                            } // else ...
                            // no path provided, so don't set anything- setupapi will
                            // nicely use the existing key or default to the value
                            // specified in the INF
                            // StringCchCopyW(wszInstallPath, MAX_PATH+1, DEFAULT_INSTALL_PATH);
                        }
                        break;

                case L'Q': 
                        SET_FLAG(dwReturnFlags, FLAG_TOTALLY_QUIET);
                        break;

                case L'?': // explicit fall through
                case L'H': // explicit fall through
                default:
                        SET_FLAG(dwReturnFlags, FLAG_USAGE);
                        break;
            }
        }
    }

	if ( IS_FLAG_SET(dwReturnFlags, FLAG_USAGE) ) {
		WCHAR UsageBuffer[1024];

		StringCchPrintfW(UsageBuffer,
		                sizeof(UsageBuffer)/sizeof(WCHAR),
		                L"Usage: %s [ /u [<path>] [/q] ]\n\n"
						L"/u [<path>] \n"
						L"   Unattended install.  If <path> is specified install\n"
						L"   symbols to <path>. If no path is specified, symbols\n"
						L"   are installed to the default location.\n"
						L"   NOTE: USING UNATTENDED INSTALL MEANS YOU\n"
						L"   HAVE READ AND AGREED TO THE END USER LICENSE\n"
						L"   AGREEMENT FOR THIS PRODUCT.\n"
						L"/q\n"
						L"    Valid only when using unattended install. Prevents\n"
						L"    error messages from being display if unattended\n"
						L"    install fails.\n"
						L"/?\n"
						L"    Show this dialog box.\n\n"
						L"If no options are specified, the interactive installation\n"
						L" is started.",
						ArgVW[0]);


        MessageBoxW( NULL,
  					UsageBuffer,
                    L"Microsoft Windows Symbols",
                     0 );

	}

    return(dwReturnFlags);
}

// Modified from MakeSureDirectoryPathExists from dbghelp.h
// The same caveats apply. (see MSDN)
BOOL WINAPI MakeSureDirectoryPathExistsW(LPCWSTR DirPath) {
    LPWSTR p, DirCopy;
    DWORD  dw;

    // Make a copy of the string for editing.

    __try {
        DirCopy = (LPWSTR)malloc((wcslen(DirPath) + 1) * sizeof(WCHAR));

        if (!DirCopy) {
            return FALSE;
        }

        StringCchCopyW(DirCopy, wcslen(DirPath)+1, DirPath);

        p = DirCopy;

        //  If the second character in the path is "\", then this is a UNC
        //  path, and we should skip forward until we reach the 2nd \ in the path.

        if ((*p == L'\\') && (*(p+1) == L'\\')) {
            p++;            // Skip over the first \ in the name.
            p++;            // Skip over the second \ in the name.

            //  Skip until we hit the first "\" (\\Server\).

            while (*p && *p != L'\\') {
                p = CharNextW(p);
            }

            // Advance over it.

            if (*p) {
                p++;
            }

            //  Skip until we hit the second "\" (\\Server\Share\).

            while (*p && *p != L'\\') {
                p = CharNextW(p);
            }

            // Advance over it also.

            if (*p) {
                p++;
            }

        } else
        // Not a UNC.  See if it's <drive>:
        if (*(p+1) == L':' ) {

            p++;
            p++;

            // If it exists, skip over the root specifier

            if (*p && (*p == L'\\')) {
                p++;
            }
        }

        while( *p ) {
            if ( *p == '\\' ) {
                *p = '\0';
                dw = GetFileAttributesW(DirCopy);
                // Nothing exists with this name.  Try to make the directory name and error if unable to.
                if ( dw == 0xffffffff ) {
                    if ( !CreateDirectoryW(DirCopy,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            free(DirCopy);
                            return FALSE;
                        }
                    }
                } else {
                    if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                        // Something exists with this name, but it's not a directory... Error
                        free(DirCopy);
                        return FALSE;
                    }
                }

                *p = L'\\';
            }
            p = CharNextW(p);
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( GetExceptionCode() );
        free(DirCopy);
        return(FALSE);
    }

    free(DirCopy);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cabs\symbolcd\symsetup\commandline.h ===
#include <windows.h>
#include <Shellapi.h>
#include <strsafe.h>

// flag values for CheckCommandLineOptions return value
#define FLAG_USAGE                      (0x0001)
#define FLAG_UNATTENDED_INSTALL         (0x0002)
#define FLAG_UNATTENDED_PATH_PROVIDED   (0x0004)
#define FLAG_TOTALLY_QUIET              (0x0008)
#define FLAG_ERROR                      (0x7000)
#define FLAG_FATAL_ERROR                (0x8000)

// macros to set/check/clear flag values
#define SET_FLAG(x,y)                   (x |= y)
#define CLEAR_FLAG(x,y)                 (x &= (~y))
#define IS_FLAG_SET(x,y)                (x & y)

// regkey and default value
#define SYMBOLS_REGKEY_ROOT             HKEY_CURRENT_USER
#define SYMBOLS_REGKEY_PATH             L"SOFTWARE\\Microsoft\\Symbols\\Directories"
#define SYMBOLS_REGKEY                  L"Symbol Dir"
#define DEFAULT_INSTALL_PATH            L"%WINDIR%\\symbols"

// function for parsing the command line parameters
DWORD WINAPI CheckCommandLineOptions(INT ArgC, LPWSTR* ArgVW);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cabs\symbolcd\symsetup\csd\runmyinf.h ===
// For Customer Support CD, the second inf is called symbols_sp.inf

TCHAR  szInfName2[_MAX_PATH*2] = _T("symbols_sp");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cabs\symbolcd\symsetup\runmyinf.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    runmyinf.c

Abstract:
    This windows app is the setup program for installing symbols off of
    the Customer Support Diagnostics CD.  It calls LaunchInfSection in
    advpack.dll to run "symbols.inf" that is sitting in the same directory.

    By default it launches DefaultInstall. 

    The setup is designed to be used with a chained install for the Customer
    Support CD for Service Packs.  If the Service Pack inf (symbols_sp.inf)
    is present in the same directory as symbols.inf, then the program launches
    DefaultInstall.Chained.1 in symbols.inf and DefaultInstall.Chained.2 
    in symbols_sp.inf.

Author:

    Barb Kess (barbkess) 19-July-1999

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "dbghelp.h"
#include "advpub.h"
#include "setupapi.h"
#include "spapip.h"
#include "winbase.h"
#include "tchar.h"
#include "resource.h"
#include "runmyinf.h"

#include "strsafe.h"

// header for CheckCommandLineOptions()
#include "CommandLine.h"

#define MAX_FILENAME        (300)

// Global variables
LPTSTR szEulaFile = _T("eula.txt");
TCHAR  szEulaFullPath[_MAX_PATH*2];
TCHAR  szInfName1[_MAX_PATH*2];
BOOL   ChainedInstall=FALSE;

// dwInstallOptions is global so all subs can test for FLAG_TOTALLY_QUIET and FLAG_UNATTENDED_INSTALL
DWORD  dwInstallOptions; 

//
// Call back procedure for displaying the license agreement
//

INT_PTR
CALLBACK
DlgProcDisplayLicense(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
);

BOOL
CopyFilesToTempDir(
    LPTSTR szSrcDir,
    LPTSTR szInfDir
);

BOOL
CopySomeFiles(
    LPTSTR szSrcDir,
    LPTSTR szDestDir,
    LPTSTR szFileName
);


BOOL
DeleteFilesAndTempDir(
    LPTSTR szTempDir
);

BOOL
GetTempDirName(
    LPTSTR szTempDir
);

BOOL
MyMakeSureDirectoryPathExists(
    LPCSTR DirPath
);

BOOL
DeleteAllFilesInDirectory(
    LPTSTR szDir
);

BOOL
DeleteSymbolInstallKey(
);

BOOL
SymbolInstallKeyExists(
);

//
// Procedure taken from wextract.c code that centers the window
//

BOOL 
CenterWindow(
    HWND hwndChild,
    HWND hwndParent
);

//
// Procedure that reads the license agreement into a buffer
//

DWORD
GetMyBuffer(
    LPTSTR* pszBuf,
    LPTSTR  szFileName
);

//
// This setupapi function is only available on Windows 2000.
// Therefore it is getting loaded manually so NT4 installs won't
// throw up a pop-up saying it can't find this function
//

#define pSetupSetGlobalFlags ppSetupSetGlobalFlags
#define pSetupGetGlobalFlags ppSetupGetGlobalFlags

typedef VOID ( * PPSETUPSETGLOBALFLAGS )( DWORD );

typedef DWORD ( * PPSETUPGETGLOBALFLAGS )( VOID );

PPSETUPSETGLOBALFLAGS ppSetupSetGlobalFlags;
PPSETUPGETGLOBALFLAGS ppSetupGetGlobalFlags;

int WINAPI WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPTSTR lpszCmdLine,
        int nCmdShow
)
{
    HMODULE hdll = NULL;
    HRESULT hr = E_FAIL;

    TCHAR szCommand[_MAX_PATH*2]=_T("");      // Full path (including filename) of this exe
    int cchFileName;                          // Index into szCommand of the \ before the filename
    int cchNameOnly;                   
    TCHAR szInf2FullPath[_MAX_PATH*2]=_T(""); // Full path (including filename) of the 
                                              // international inf, if one exists
    TCHAR szSrcDir[_MAX_PATH*2]=_T("");       // Directory where symbols.exe was launched
    TCHAR szInfDir[_MAX_PATH*2]=_T("");       // Directory to Launch the Inf from
    TCHAR szInstallCommand1[_MAX_PATH * 2]=_T("");  // Command sent to LaunchINFSection.  If this
                                                    // is a chained install, this is the
                                                    // command sent to LaunchINFSection for the
                                                    // first part of the chained install. 
    TCHAR szInstallCommand2[_MAX_PATH * 2]=_T("");  // Command sent to LaunchINFSection for the
                                                    // second part of the chained install

    TCHAR  szDefaultInstall[_MAX_PATH*2] = _T("");
    TCHAR  szDefaultInstallChained1[_MAX_PATH*2] = _T("");
    TCHAR  szDefaultInstallChained2[_MAX_PATH*2] = _T("");

    DWORD rc;
    BOOL  ThisIsNT4=FALSE;             // Is this being installed on NT4?

    INT nAcceptLicense;
    WIN32_FIND_DATA FindFileData;

    OSVERSIONINFO VersionInfo;

    // Variables for handling command line flags
    //   Get lpszCmndLine as an array instead of as a flat string.  This means
    //   we don't have to roll our own logic for handling long and/or quoted file
    //   names- it gets done for us.
    //   No such API as CommandLineToArgvA, so this work is always done in Unicode.
    INT              iArgC;
    LPWSTR           cmdLine          = GetCommandLineW();
    LPWSTR *         lpArgVW          = CommandLineToArgvW(cmdLine, &iArgC);

    dwInstallOptions = CheckCommandLineOptions(iArgC, lpArgVW);
	if ( IS_FLAG_SET(dwInstallOptions, FLAG_USAGE) ) {
		// usage message is printed in CheckCommandLineOptions(), so just exit
		exit(0);
	}

    // don't allow FLAG_TOTALLY_QUIET unless doing an unattended install
    if ( IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
        if (! IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL) ) {
            CLEAR_FLAG(dwInstallOptions, FLAG_TOTALLY_QUIET);
            MessageBox( NULL,
                        "It is not possible to do a quiet install without doing an unattended\ninstall. Defaulting to a normal install.",
                        "Microsoft Windows Symbols",
                        0 );

        }
	}

    // FLAG_FATAL_ERROR indicates that writing the registry key for FLAG_UNATTENDED_INSTALL failed
    if ( IS_FLAG_SET(dwInstallOptions,FLAG_UNATTENDED_INSTALL) && 
         IS_FLAG_SET(dwInstallOptions,FLAG_FATAL_ERROR)                 ) {

        // if FLAG_TOTALLY_QUIET, just exit
        if ( IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
            exit(1);
        } else {
            // otherwise, default to an anttended install
            CLEAR_FLAG(dwInstallOptions, FLAG_UNATTENDED_INSTALL);
            CLEAR_FLAG(dwInstallOptions, FLAG_FATAL_ERROR);
            MessageBox( NULL,
                        "Microsoft Windows Symbols encountered an error doing the unattended\ninstall. Defaulting to a normal install.",
                        "Microsoft Windows Symbols",
                        0 );
        }
    }

    VersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &VersionInfo );

    //
    // Give a friendly pop-up message if this is Win9x or NT 3.51
    //
    if ( (VersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT ) ||
         (VersionInfo.dwMajorVersion < 4.0 ) )  {
        if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
            MessageBox( NULL,
                        "Microsoft Windows Symbols does not install on this Operating System.",
                        "Microsoft Windows Symbols",
                        0 );
		}
        exit(0);
    }

    //
    // For NT 5 RC1 and greater, use pSetupSetGlobalFlags to keep old
    // symbol files from filling up people's hard drives with backed up symbols
    //
    // Not sure which build this was introduced in, but I know its broken if this
    // pSetupSetGlobalFlags procedure tries to load on NT4.
    //

    if (VersionInfo.dwBuildNumber >= 2072 ) {
        hdll = (HMODULE)LoadLibrary("setupapi.dll");
        if (hdll != NULL) {
            ppSetupSetGlobalFlags = ( PPSETUPSETGLOBALFLAGS )
                                GetProcAddress(
                                    hdll,
                                    "pSetupSetGlobalFlags"
                                );

            if (ppSetupSetGlobalFlags==NULL) {
                if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
                    MessageBox( NULL,
                                "The install cannot finish because the function pSetupSetGlobalFlags is not in setupapi.dll",
                                "Microsoft Windows 2000 Symbols",
                                0 );
				}
                exit(0);
            }

            ppSetupGetGlobalFlags = ( PPSETUPGETGLOBALFLAGS )
                                GetProcAddress(
                                    hdll,
                                    "pSetupGetGlobalFlags"
                                );

            if (ppSetupGetGlobalFlags==NULL) {
                if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
                    MessageBox( NULL,
                                "The install cannot finish because the function pSetupGetGlobalFlags is not in setupapi.dll",
                                "Microsoft Windows 2000 Symbols",
                                0 );
				}
                exit(0);
            }
        }

        //
        // Fix it so it doesn't try to keep old symbol files
        // and fill up people's hard drives with backed up symbols
        //

        pSetupSetGlobalFlags( pSetupGetGlobalFlags() | PSPGF_NO_BACKUP);
    }

    // Get this exe's full path name

    if (GetModuleFileName( NULL, szCommand, MAX_FILENAME ) == 0) {
        goto done;
    }

    // Get the index of the beginning of the filename by moving
    // backwards to the \ before the executable name.

    cchFileName = _tcslen( szCommand );
    while ( szCommand[cchFileName] != '\\'  && cchFileName >= 0 ) {
        cchFileName--;
    }
    if ( cchFileName < 0 ) exit(1);

    // Create a string for the InfName

    StringCbCopy ( szInfName1, _MAX_PATH*2*sizeof(TCHAR), szCommand+cchFileName+1 );

    cchNameOnly = _tcslen( szInfName1 );
    while ( szInfName1[cchNameOnly] != '.'  && cchNameOnly >= 0 ) {
        cchNameOnly--;
    }
    if ( cchNameOnly < 0 ) exit(1);
    szInfName1[cchNameOnly] = _T('\0');

    // Create a string containing the Default Install command
    StringCbCopy ( szDefaultInstall, _MAX_PATH*2*sizeof(TCHAR), szInfName1 );
    StringCbCat ( szDefaultInstall, _MAX_PATH*2*sizeof(TCHAR), _T(".inf, DefaultInstall") );

    if (IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL)) {
        StringCbCat ( szDefaultInstall, _MAX_PATH*2*sizeof(TCHAR), _T(".Quiet") );
    }

    // Make this work for the way Windows 2000 SRP has the names
    // of the sections in their infs
    if ( (_tcscmp(szInfName1, _T("symbols_srp")) == 0) ||
         (_tcscmp(szInfName1, _T("symbols_sp")) == 0) ) {
        StringCbCat ( szDefaultInstall, _MAX_PATH*2*sizeof(TCHAR), _T(".x86") );
    }

    // Create a string for the DefaultInstall.Chained.1
    StringCbCopy ( szDefaultInstallChained1, _MAX_PATH*2*sizeof(TCHAR), szInfName1 );
    StringCbCat ( szDefaultInstallChained1, _MAX_PATH*2*sizeof(TCHAR), _T(".inf, DefaultInstall.Chained.1") );

    if (IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL)) {
        StringCbCat ( szDefaultInstallChained1, _MAX_PATH*2*sizeof(TCHAR), _T(".Quiet") );
    }

    // Create a string for the DefaultInstall.Chained.2
    StringCbCopy ( szDefaultInstallChained2, _MAX_PATH*2*sizeof(TCHAR), szInfName2 );
    StringCbCat ( szDefaultInstallChained2, _MAX_PATH*2*sizeof(TCHAR), _T(".inf, DefaultInstall.Chained.2") );

    if (IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL)) {
        StringCbCat ( szDefaultInstallChained2, _MAX_PATH*2*sizeof(TCHAR), _T(".Quiet") );
    }

    // Create a string containing the directory where the inf is
    StringCbCopy( szInfDir, _MAX_PATH*2*sizeof(TCHAR), szCommand);
    szInfDir[cchFileName+1] = _T('\0');

    // Create a string containing this install directory
    StringCbCopy ( szSrcDir, _MAX_PATH*2*sizeof(TCHAR), szCommand);
    szSrcDir[cchFileName+1] = _T('\0');

    StringCbCopy ( szEulaFullPath, _MAX_PATH*2*sizeof(TCHAR), szCommand);
    StringCbCopy ( &szEulaFullPath[cchFileName+1], _MAX_PATH*2*sizeof(TCHAR), szEulaFile);


    // Unattended install implies the EULA has already been agreed to
    if (! IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL)) {
        DWORD  dwSize = 0;
        LPTSTR szBuf;
        
        //
        // Make sure the EULA exists
        //
        dwSize = GetMyBuffer(&szBuf, szEulaFullPath);
        if (dwSize == 0) {
            if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
                MessageBox( NULL,
                            "The End User License Agreement could not be found.",
                            "Windows Symbols",
                            0 );
			}
            exit(1);
        }

        free(&szBuf);

        // Display license agreement
        nAcceptLicense = (INT) DialogBox( hInstance,
                                          MAKEINTRESOURCE(IDD_LICENSE),
                                          NULL,
                                          DlgProcDisplayLicense
                                        );

        if ( nAcceptLicense != IDYES ) {
            MessageBox( NULL,
                        "You need to accept the license agreement in order to install Windows Symbols.",
                        "Windows Symbols",
                        0 );
            exit(1);
        }
    }

    //
    // Decide if this is a chained install or not.
    //

    StringCbCopy ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), szSrcDir);
    StringCbCat ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), szInfName2);
    StringCbCat ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), _T(".inf") );

    ChainedInstall=TRUE;

    if ( _tcscmp( szInfName1, szInfName2 ) == 0 ) {
        ChainedInstall=FALSE;

    } else if (FindFirstFile( szInf2FullPath, &FindFileData) == INVALID_HANDLE_VALUE) {
        ChainedInstall=FALSE;
    } 

    //
    // If this is NT4, do a work around for a bug in setupapi
    // Setupapi can't get the name of the cab correctly unless it is in
    // the root of the CD.
    // Workaround is to copy the files to a temp directory.
    // If this is NT4 and the setup isn't being run from a CD-ROM, we don't have to
    // copy the files to a temp directory.


    if ( (GetDriveType(NULL) == DRIVE_CDROM) &&
         (VersionInfo.dwMajorVersion < 5.0 ) ) {
        ThisIsNT4 = TRUE;

        if (! IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL)) {
            MessageBox( NULL,
                        "The installer needs to copy some files to a temporary directory.  This may take several minutes.",
                        "Windows Symbols",
                        0 );
        }

        rc = CopyFilesToTempDir(szSrcDir,szInfDir);
        if (!rc) {
            if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
                MessageBox( NULL,
                            "Setup failed to copy all the files to a temporary directory",
                            "Windows Symbols",
                            0 );
			}
            DeleteFilesAndTempDir(szInfDir);
            exit(1);
        }
    }

    //
    // See if the second inf exists in this directory.  If it does then
    // call the chained installs. Otherwise call the section that only 
    // installs the US file.
    //

    StringCbCopy ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), szInfDir);
    StringCbCat ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), szInfName2);
    StringCbCat ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), _T(".inf") );

    if (FindFirstFile( szInf2FullPath, &FindFileData) == INVALID_HANDLE_VALUE) {

        StringCbCopy( szInstallCommand1, _MAX_PATH*2*sizeof(TCHAR), szInfDir );
        StringCbCat( szInstallCommand1, _MAX_PATH*2*sizeof(TCHAR), szDefaultInstall );

    } else {

        StringCbCopy( szInstallCommand1, _MAX_PATH*2*sizeof(TCHAR), szInfDir );
        StringCbCat( szInstallCommand1, _MAX_PATH*2*sizeof(TCHAR), szDefaultInstallChained1 );

        StringCbCopy( szInstallCommand2, _MAX_PATH*2*sizeof(TCHAR), szInfDir );
        StringCbCat( szInstallCommand2, _MAX_PATH*2*sizeof(TCHAR), szDefaultInstallChained2 );
    }

    /* tell AdvPack to process this INF */
    DeleteSymbolInstallKey();

    hr = LaunchINFSection( NULL, hInstance, szInstallCommand1, 0 );

    if ( ChainedInstall && SymbolInstallKeyExists() ) {
        hr = LaunchINFSection( NULL, hInstance, szInstallCommand2, 0 );
    }

    if ( ThisIsNT4) {
        DeleteFilesAndTempDir( szInfDir );
    } 

done:
    return( (int) hr );
}



INT_PTR
CALLBACK
DlgProcDisplayLicense(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{

    //
    // This is the callback procedure for displaying the
    // license agreement.
    //

    DWORD dwSize;
    LPTSTR szBuf;
    HWND hwndCtrl;

    // Get the license agreement text and store it in szBuf
    dwSize = GetMyBuffer(&szBuf, szEulaFullPath);
    if (dwSize == 0) {
        return FALSE;
    }

    switch (uMsg) {

        case WM_INITDIALOG:
            CenterWindow( hwndDlg, GetDesktopWindow() );
            SetDlgItemText( hwndDlg, IDC_EDIT_LICENSE, szBuf );
            hwndCtrl = GetDlgItem(hwndDlg, IDC_EDIT_LICENSE);
            PostMessage(hwndCtrl, EM_SETSEL, -1, -1);
            return TRUE;

        case WM_CLOSE:
            EndDialog( hwndDlg, IDNO );
            return TRUE;

        case WM_COMMAND:
            switch ( LOWORD (wParam) )
            {
                case IDYES: EndDialog( hwndDlg, IDYES );
                            return (TRUE);

                case IDNO:  EndDialog( hwndDlg, IDNO );
                            return (TRUE);
            }
            break;
    }
    return FALSE;
}


BOOL CenterWindow( HWND hwndChild, HWND hwndParent )
{
    RECT rChild;
    RECT rParent;
    int  wChild;
    int  hChild;
    int  wParent;
    int  hParent;
    int  wScreen;
    int  hScreen;
    int  xNew;
    int  yNew;
    HDC  hdc;

    //
    // This is a procedure I got from the wextract.c code -- it centers the
    // window.
    //
    // Returns: BOOL
    //          True if successful,
    //          False otherwise
    //

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect (hwndParent, &rParent);
    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    hdc = GetDC (hwndChild);
    if (hdc == NULL) {
        return FALSE;
    }
    wScreen = GetDeviceCaps (hdc, HORZRES);
    hScreen = GetDeviceCaps (hdc, VERTRES);
    ReleaseDC (hwndChild, hdc);

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0) {
        xNew = 0;
    } else if ((xNew+wChild) > wScreen) {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0) {
        yNew = 0;
    } else if ((yNew+hChild) > hScreen) {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return( SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER));
}



DWORD
GetMyBuffer(
    LPTSTR* pszBuf,
    LPTSTR  szFileName
)
{
    //
    // Reads contents of szFileName into a buffer.
    //
    // OUT pszBuf
    // IN  szFileName
    //
    // Return Value: size of the buffer
    //

    HANDLE hFile;
    DWORD dwSize;
    DWORD NumBytesRead;

    hFile = CreateFile( (LPCTSTR) szFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    // handle a missing EULA
    if (hFile == INVALID_HANDLE_VALUE ) {
        return(0);
    }

    dwSize = GetFileSize( hFile, NULL );

    *pszBuf = (LPTSTR)malloc( dwSize * sizeof(TCHAR) );

    if ( *pszBuf == NULL ) {
        return(0);
    }

    if (!ReadFile( hFile,
                   (LPVOID)*pszBuf,
                   dwSize,
                   &NumBytesRead,
                   NULL )
                   ) {
        free(*pszBuf);
        return(0);
    }

    return (dwSize);

}

BOOL
CopyFilesToTempDir(
    LPTSTR szSrcDir,
    LPTSTR szInfDir
)
{                  

    /* szSrcDir - IN - Directory that symbols.exe was launched from
       szInfDir - OUT - Directory that INF is copied to

       Purpose: Copy files to a temporary directory

     */

    BOOL rc;

    HINF hInf;
    PVOID Context;
    TCHAR szInfFile[_MAX_PATH * 2];
    TCHAR buf[_MAX_PATH * 2];
    

    GetTempDirName(szInfDir);    

    // Create the Temporary Install Directory
    rc = MyMakeSureDirectoryPathExists( szInfDir );
    if (!rc) {
        StringCbPrintf( buf, 
                       _MAX_PATH*2*sizeof(TCHAR),
                        "Installation failed because it can't create the temporary directory %s.", szInfDir );
        if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
            MessageBox( NULL,
                        buf,
                        "Microsoft Windows 2000 Symbols",
                        0 );
		}
        return FALSE;
    }

    // Copy the 3 files associated with szInfName1

    StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName1 );
    StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".cab") );
   
    rc = CopySomeFiles(szSrcDir, szInfDir, buf );
    if (!rc) return FALSE;

    StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName1 );
    StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".cat") );

    rc = CopySomeFiles(szSrcDir, szInfDir, buf );
    if (!rc) return FALSE;

    StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName1 );
    StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".inf") );

    rc = CopySomeFiles(szSrcDir, szInfDir, buf );
    if (!rc) return FALSE;

    // If this is a chained install, copy the 3 files associated
    // with szInfName2

    if (ChainedInstall) {

      StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName2 );
      StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".cab") );
   
      rc = CopySomeFiles(szSrcDir, szInfDir, buf );
      if (!rc) return FALSE;

      StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName2 );
      StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".cat") );

      rc = CopySomeFiles(szSrcDir, szInfDir, buf );
      if (!rc) return FALSE;

      StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName2 );
      StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".inf") );

      rc = CopySomeFiles(szSrcDir, szInfDir, buf );
      if (!rc) return FALSE;

    }

    // Copy the other two files that are needed for the install
    // onto NT4

    rc = CopySomeFiles(szSrcDir, szInfDir, _T("eula.txt") );
    if (!rc) return FALSE;

    rc = CopySomeFiles(szSrcDir, szInfDir, _T("advpack.dll") );
    if (!rc) return FALSE;

    return (TRUE);
}

BOOL
DeleteFilesAndTempDir(
    LPTSTR szTempDir
)
{

    /*
       szTempDir -IN - Directory to delete

       Purpose: Delete the files in the temporary directory.

    */
    BOOL rc;

    DeleteAllFilesInDirectory(szTempDir);
    rc = RemoveDirectory(szTempDir);
    RemoveDirectory(szTempDir);
    return (TRUE);
}



BOOL
GetTempDirName( 
    LPTSTR szTempDir
)
{

    DWORD dwPathLength;
    BOOL rc, Finished;
    UINT Num;
    TCHAR szNum[20];
    DWORD Length;

    HINF hInf;
    PVOID Context;
    LPSECURITY_ATTRIBUTES lpSecurityAttributes;
    TCHAR szInfDir[_MAX_PATH];
    TCHAR buf[_MAX_PATH * 2];
    HANDLE hFile;

    dwPathLength = GetTempPath( _MAX_PATH, szTempDir);

    if ( dwPathLength == 0 ) return FALSE;
    if ( dwPathLength > _MAX_PATH) return FALSE;

    // Append the symbol install temp dir
    StringCbCat(szTempDir, _MAX_PATH*2*sizeof(TCHAR), _T("sym") );

    Finished = FALSE;
    Length = _tcslen(szTempDir);
    Num = 0;
    while ( !Finished) {
        Num++;
        _itoa( Num, szNum, 10 );
       
        StringCbCopy( szTempDir+Length, (_MAX_PATH*2 - Length) * sizeof(TCHAR), szNum );
        StringCbCat( szTempDir, _MAX_PATH*2*sizeof(TCHAR), _T("\\") );

        hFile = CreateFile( szTempDir,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL, 
                     OPEN_EXISTING,
                     FILE_FLAG_BACKUP_SEMANTICS,
                     NULL );

        if ( hFile == INVALID_HANDLE_VALUE ) {
            Finished = TRUE;    
        }
    }

    // Create the Temporary Install Directory
    rc = MyMakeSureDirectoryPathExists( szTempDir );
    if (!rc) {
        StringCbPrintf( buf, 
                        _MAX_PATH*2*sizeof(TCHAR),
                        "Installation failed because it can't create the temporary directory %s.", szTempDir );
        if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
            MessageBox( NULL,
                        buf,
                        "Microsoft Windows 2000 Symbols",
                        0 );
		}
        return FALSE;
    }
    return TRUE;
}



BOOL
MyMakeSureDirectoryPathExists(
    LPCSTR DirPath
    )
{
    LPTSTR p, DirCopy;
    DWORD dw;

    // Make a copy of the string for editing.

    __try {
        DirCopy = (LPTSTR) malloc(_tcslen(DirPath) + 1);

        if (!DirCopy) {
            return FALSE;
        }

        StringCbCopy( DirCopy, 
                      (_tcslen(DirPath) + 1) * sizeof(TCHAR), 
                      DirPath );

        p = DirCopy;

        //  If the second character in the path is "\", then this is a UNC
        //  path, and we should skip forward until we reach the 2nd \ in the path.

        if ((*p == '\\') && (*(p+1) == '\\')) {
            p++;            // Skip over the first \ in the name.
            p++;            // Skip over the second \ in the name.

            //  Skip until we hit the first "\" (\\Server\).

            while (*p && *p != '\\') {
                p = CharNext(p);
            }

            // Advance over it.

            if (*p) {
                p++;
            }

            //  Skip until we hit the second "\" (\\Server\Share\).

            while (*p && *p != '\\') {
                p = CharNext(p);
            }

            // Advance over it also.

            if (*p) {
                p++;
            }

        } else
        // Not a UNC.  See if it's <drive>:
        if (*(p+1) == ':' ) {

            p++;
            p++;

            // If it exists, skip over the root specifier

            if (*p && (*p == '\\')) {
                p++;
            }
        }

        while( *p ) {
            if ( *p == '\\' ) {
                *p = '\0';
                dw = GetFileAttributes(DirCopy);
                // Nothing exists with this name.  Try to make the directory name 
                // and error if unable to.
                if ( dw == 0xffffffff ) {
                    if ( !CreateDirectory(DirCopy,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            free(DirCopy);
                            return FALSE;
                        }
                    }
                } else {
                    if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                        // Something exists with this name, 
                        // but it's not a directory... Error
                        free(DirCopy);
                        return FALSE;
                    }
                }

                *p = '\\';
            }
            p = CharNext(p);
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // ImagepSetLastErrorFromStatus( GetExceptionCode() );
        free(DirCopy);
        return(FALSE);
    }

    free(DirCopy);
    return TRUE;
}


BOOL
CopySomeFiles(
    LPTSTR szSrcDir,
    LPTSTR szDestDir,
    LPTSTR szFileName
)
{

TCHAR szSearchFileName[_MAX_PATH * 2];
TCHAR szDestFileName[_MAX_PATH * 2];
TCHAR szFoundFileName[_MAX_PATH * 2];
TCHAR szBuf[_MAX_PATH * 3];

WIN32_FIND_DATA Win32FindData;
HANDLE hFindFile;
BOOL Found;
BOOL rc;

    // Copy the catalog files
    StringCbCopy(szSearchFileName, _MAX_PATH*2*sizeof(TCHAR), szSrcDir);
    StringCbCat(szSearchFileName, _MAX_PATH*2*sizeof(TCHAR), szFileName );

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szSearchFileName, &Win32FindData);
    if ( hFindFile == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    while ( Found ) {
        StringCbCopy(szFoundFileName, _MAX_PATH*2*sizeof(TCHAR), szSrcDir);
        StringCbCat(szFoundFileName, _MAX_PATH*2*sizeof(TCHAR), Win32FindData.cFileName);

        StringCbCopy(szDestFileName, _MAX_PATH*2*sizeof(TCHAR), szDestDir);
        StringCbCat(szDestFileName, _MAX_PATH*2*sizeof(TCHAR), Win32FindData.cFileName);

        rc = CopyFile(szFoundFileName, szDestFileName, FALSE);
        if (!rc) {
            if ( GetLastError() == ERROR_HANDLE_DISK_FULL ) {
                StringCbPrintf( szBuf, 
                                _MAX_PATH*2*sizeof(TCHAR),
                                _T("There is not enough disk space in the temporary directory %s %s"),
                                szDestDir, 
                                _T("to complete the install.") );

                if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
                    MessageBox( NULL,
                                szBuf,
                                "Microsoft Windows 2000 Symbols",
                                0 );
				}

            }
            RemoveDirectory(szDestDir);
            return (FALSE);
        }

        Found = FindNextFile( hFindFile, &Win32FindData );

    }
    return (TRUE);
}


BOOL
DeleteAllFilesInDirectory(
    LPTSTR szDir
)
{

    HANDLE hFindFile;
    BOOL Found = FALSE;
    BOOL rc = TRUE;
    LPTSTR szBuf;
    LPTSTR szDir2;
    LPWIN32_FIND_DATA lpFindFileData;

    szDir2 = (LPTSTR)malloc( (_tcslen(szDir) + 4) * sizeof(TCHAR) );
    if (szDir2 == NULL) return (FALSE);
    StringCbCopy( szDir2, (_tcslen(szDir) + 4) * sizeof(TCHAR), szDir);
    StringCbCat( szDir2, (_tcslen(szDir) + 4) * sizeof(TCHAR), _T("*.*") );

    szBuf = (LPTSTR)malloc( ( _tcslen(szDir) + _MAX_FNAME + _MAX_EXT + 2 )
                            * sizeof(TCHAR) );
    if (szBuf == NULL) return(FALSE);


    lpFindFileData = (LPWIN32_FIND_DATA) malloc (sizeof(WIN32_FIND_DATA) );
    if (!lpFindFileData) return(FALSE);

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szDir2, lpFindFileData);
    if ( hFindFile == INVALID_HANDLE_VALUE) {
        Found = FALSE;
    }

    while ( Found ) {

        if ( !(lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
            StringCbPrintf( szBuf, (_tcslen(szDir) + _MAX_FNAME + _MAX_EXT + 2) * sizeof(TCHAR), 
                            _T("%s%s"), 
                            szDir, 
                            lpFindFileData->cFileName);
            if (!DeleteFile(szBuf)) {
                rc = FALSE;
            }
        }
        Found = FindNextFile(hFindFile, lpFindFileData);
    }
    free(lpFindFileData);
    FindClose(hFindFile);
    free(szDir2);
    free(szBuf);
    return(rc);
}



BOOL DeleteSymbolInstallKey()
{
    DWORD rc;
    LONG  rc2;
    HKEY  hKeySymbols;

    rc = RegOpenKeyEx( HKEY_CURRENT_USER,
                       _T("software\\microsoft\\Symbols"),
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE |
                       KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                       &hKeySymbols
                     );

    if (rc == ERROR_SUCCESS) {
        rc2 = RegDeleteKey( hKeySymbols,
                            _T("SymbolInstall")
                          );
    }

    if (rc) {
      RegCloseKey(hKeySymbols);
    }

    return (TRUE);

}

BOOL SymbolInstallKeyExists ()
{

    DWORD rc;
    LONG  rc2;
    HKEY  hKeySymbols;

    rc = RegOpenKeyEx( HKEY_CURRENT_USER,
                       _T("software\\microsoft\\Symbols\\SymbolInstall"),
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE |
                       KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                       &hKeySymbols
                     );

    if (rc == ERROR_SUCCESS) {
        RegCloseKey(hKeySymbols);
        return(TRUE);
    } else {
        return (FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cabs\symbolcd\symsetup\srp\runmyinf.h ===
// For Customer Support CD, the second inf is called symbols_sp.inf

TCHAR  szInfName2[_MAX_PATH*2] = _T("symbols_sp");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cacls\daclwrap.cxx ===
//+-------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
//  File:        daclwrap.cxx
//
//  Contents:    class encapsulating file security.
//
//  Classes:     CDaclWrap
//
//  History:     Nov-93        Created         DaveMont
//
//--------------------------------------------------------------------
#include <t2.hxx>
#include <daclwrap.hxx>

#if DBG
extern ULONG Debug;
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap::CDaclWrap, public
//
//  Synopsis:   initialize data members, constructor will not throw
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CDaclWrap::CDaclWrap()
      : _ccaa(0)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   cleanup allocated data
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CDaclWrap::~CDaclWrap()
{
    for (ULONG j = 0; j < _ccaa; j++)
        delete _aaa[j].pcaa;
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap::SetAccess, public
//
//  Synopsis:   caches data for a new ACE
//
//  Arguments:  IN [option] - rePlace, Revoke, Grant, Deny
//              IN [Name] - principal (username)
//              IN [System] - server/machine where Name is defined
//              IN [access] - access mode (Read Change None All)
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::SetAccess(ULONG option, WCHAR *Name, WCHAR *System, ULONG access)
{
    ULONG ret;

    // sorry, static number of ACCESSes can be set at one time

    if (_ccaa >= CMAXACES)
        return(ERROR_BUFFER_OVERFLOW);

    // allocate a new account access class

    if (NULL == (_aaa[_ccaa].pcaa = new CAccountAccess(Name, System)))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // to fix the bug where someone asks to both grant and deny under
    // the /p option (the deny is thru access = N)

    if ((GENERIC_NONE == access) && (OPTION_REPLACE == option))
    {
        _aaa[_ccaa].option = OPTION_DENY;
    } else
    {
        _aaa[_ccaa].option = option;
    }

    SID *psid;

    if (ERROR_SUCCESS == ( ret = _aaa[_ccaa].pcaa->Init(access)))
    {
        // get the sid to make sure the username is valid

        if (ERROR_SUCCESS == ( ret =_aaa[_ccaa].pcaa->Sid(&psid)))
        {
            // loop thru the existing sids, making sure the new one is not a duplicate

            SID *poldsid;
            for (ULONG check = 0;check < _ccaa ; check++)
            {
                if (ERROR_SUCCESS == ( ret =_aaa[check].pcaa->Sid(&poldsid)))
                {
                    if (EqualSid(psid,poldsid))
                    {
                        VERBOSE((stderr, "SetAccess found matching new sids\n"))
                        delete _aaa[_ccaa].pcaa;
                        return(ERROR_BAD_ARGUMENTS);
                    }
                }
            }
            _ccaa++;
        }
        else
        {
            delete _aaa[_ccaa].pcaa;
        }
    }
    else
    {
        delete _aaa[_ccaa].pcaa;
    }
    return(ret);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:BuildAcl, public
//
//  Synopsis:   merges cached new aces with the input ACL
//
//  Arguments:  OUT [pnewdacl] - Address of new ACL to build
//              IN  [poldacl]  - (OPTIONAL) old ACL that is to be merged
//              IN  [revision] - ACL revision
//              IN  [fdir]     - True = directory
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::BuildAcl(ACL **pnewdacl, ACL *poldacl, UCHAR revision, BOOL fdir)
{
    ULONG ret, caclsize;

    // get the size of the new ACL we are going to create

    if (ERROR_SUCCESS == (ret =  _GetNewAclSize(&caclsize, poldacl, fdir)))
    {
        // allocate the new ACL

        if (ERROR_SUCCESS == (ret =  _AllocateNewAcl(pnewdacl, caclsize, revision)))
        {
            // and fill it up

            if (ERROR_SUCCESS != (ret =  _FillNewAcl(*pnewdacl, poldacl, fdir)))
            {
                // free the buffer if we failed

                LocalFree(*pnewdacl);
            }

        }
    }
    return(ret);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_GetNewAclSize, private
//
//  Synopsis:   returns the size need to merge the new ACEs with the old ACL,
//              this is an ugly algorithm:
//
//if (old aces exist)
//   for (new aces)
//      if (new ace option == GRANT)
//         for (old aces)
//            if (new ace SID == old ace SID)
//               do inheritance check
//               found = true
//               if (old ace type == ALLOWED)
//                  old ace mask |= new ace mask
//               else
//                  old ace mask &= ~new ace mask
//         if (!found)
//            add size of new ace
//         else
//            new ace mask = 0
//      else
//         add size of new ace
//
//   for (old aces)
//      for (new aces)
//         if (new ace option == DENY, REPLACE, REVOKE)
//            if (new ace SID == old ace SID)
//               found = true
//               break
//      if (!found)
//         add size of old ace
//      else
//         old ace mask = 0
//else
//   for (new aces)
//      add size of new ace
//
//
//  Arguments:  OUT [caclsize] - returns size
//              IN  [poldacl]  - (OPTIONAL) old ACL that is to be merged
//              IN  [fdir]     - True = directory
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_GetNewAclSize(ULONG *caclsize, ACL *poldacl, BOOL fdir)
{
    ULONG ret;

    // the size for the ACL header

    *caclsize = sizeof(ACL);

    // initialize the access requests
    for (ULONG j = 0; j < _ccaa; j++)
       _aaa[j].pcaa->ReInit();

    // if we are merging, calculate the merge size

    if (poldacl && (poldacl->AceCount != 0))
    {
        // first the grant options

        for (j = 0; j < _ccaa; j++)
        {
            SID *psid;
            if (OPTION_GRANT == _aaa[j].option)
            {
                BOOL ffound = FALSE;
                ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));

                for (ULONG cace = 0; cace < poldacl->AceCount;
                     cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
                {
                    if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                    {
                        if (EqualSid(psid,
                                     (SID *)&((ACCESS_ALLOWED_ACE *)
                                     pah)->SidStart) )
                        {
                            // if old and new types are the same, just and with the old

                            if (fdir && (pah->AceType == _aaa[j].pcaa->AceType()))
                            {
                                // make sure that we can handle the inheritance
                                _aaa[j].pcaa->AddInheritance(pah->AceFlags);

                                ffound = TRUE;
                            } else if (pah->AceType == _aaa[j].pcaa->AceType())
                            {
                                ffound = TRUE;
                            }

                            if (ACCESS_ALLOWED_ACE_TYPE == pah->AceType)
                            {
                                (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)
                                pah)->Mask |= _aaa[j].pcaa->AccessMask();
                            } else if (ACCESS_DENIED_ACE_TYPE == pah->AceType)
                            {
                                (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)
                                pah)->Mask &= ~_aaa[j].pcaa->AccessMask();
                            } else
                            {
                                VERBOSE((stderr, "_GetNewAclSize found an ace that was not allowed or denied\n"))
                                return(ERROR_INVALID_DATA);
                            }
                        }
                    } else
                    {
                        return(ret);
                    }
                }
                if (!ffound)
                {
                    // bugbug allowed/denied sizes currently the same

                    *caclsize += sizeof(ACCESS_ALLOWED_ACE) -
                                 sizeof(DWORD) +
                                 GetLengthSid(psid);

                    SIZE((stderr, "adding on size of an new ACE (to the new ACL) = %d\n",*caclsize))
                } else
                {
                    if (fdir && (ERROR_SUCCESS != (ret = _aaa[j].pcaa->TestInheritance())))
                        return(ret);
                    _aaa[j].pcaa->ClearAccessMask();
                }
            } else if ( (OPTION_REPLACE == _aaa[j].option) ||
                        (OPTION_DENY == _aaa[j].option) )
            {
                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                {
                    // bugbug allowed/denied sizes currently the same

                    *caclsize += sizeof(ACCESS_ALLOWED_ACE) -
                                 sizeof(DWORD) +
                                 GetLengthSid(psid);

                    SIZE((stderr, "adding on size of an new ACE (to the new ACL) = %d\n",*caclsize))
                } else
                    return(ret);
            }
        }
        // now for the deny, replace & revoke options

        ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));
        SID *psid;

        // loop thru the old ACL

        for (ULONG cace = 0; cace < poldacl->AceCount;
            cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
        {
            BOOL ffound = FALSE;

            // and thru the new ACEs looking for matching SIDs

            for (ULONG j = 0; j < _ccaa; j++)
            {
                if ( (_aaa[j].option & OPTION_DENY ) ||
                     (_aaa[j].option & OPTION_REPLACE ) ||
                     (_aaa[j].option & OPTION_REVOKE ) )
                {
                    if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                    {
                        if (EqualSid(psid,
                                     (SID *)&((ACCESS_ALLOWED_ACE *)
                                     pah)->SidStart) )
                        {
                            ffound = TRUE;
                        }
                    } else
                        return(ret);
                }
            }
            if (!ffound)
            {
                // if we did not find a match, add the size of the old ACE

                *caclsize += ((ACE_HEADER *)pah)->AceSize;

                SIZE((stderr, "adding on size of an old ACE (to the new ACL) = %d\n",*caclsize))
            } else
            {
                (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask = 0;
            }
        }
        SIZE((stderr, "final size for new ACL = %d\n",*caclsize))
    } else
    {
        // no old ACL, just add up the sizes of the new aces

        for (j = 0; j < _ccaa; j++)
        {
            // need to know the size of the sid

            SID *psid;
            if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
            {
                // bugbug allowed/denied sizes currently the same

                *caclsize += sizeof(ACCESS_ALLOWED_ACE) -
                             sizeof(DWORD) +
                             GetLengthSid(psid);

                SIZE((stderr, "adding on size of an new ACE (to the new ACL) = %d\n",*caclsize))
            } else
            {
                return(ret);
            }
        }
        SIZE((stderr, "final size for new ACL = %d\n",*caclsize))
    }
    return(ERROR_SUCCESS);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_AllocateNewAcl, private
//
//  Synopsis:   allocates and initializes the new ACL
//
//  Arguments:  OUT [pnewdacl] - address of new ACL to allocate
//              IN  [caclsize] - size to allocate for the new ACL
//              IN  [revision] - revision of the new ACL
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_AllocateNewAcl(ACL **pnewdacl, ULONG caclsize, ULONG revision)
{
    if (NULL == (*pnewdacl = (ACL *) LocalAlloc(LMEM_FIXED, caclsize)))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (!InitializeAcl(*pnewdacl,caclsize, revision))
    {
        ULONG ret = GetLastError();
        LocalFree(*pnewdacl);
        return(ret);

    }

    return(ERROR_SUCCESS);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_SetAllowedAce, private
//
//  Synopsis:   appends an allowed ACE to the input ACL
//
//  Arguments:  IN [dacl] - ACL to add the ACE to
//              IN [mask] - access mask to add
//              IN [psid] - SID to add
//              IN [fdir] - if a Dir add inherit ACE as well
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_SetAllowedAce(ACL *dacl, ACCESS_MASK mask, SID *psid, BOOL fdir)
{
    ULONG ret = ERROR_SUCCESS;

    // compute the size of the ACE we are making

    USHORT acesize = (USHORT)(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(psid));

    SIZE((stderr, "adding allowed ace, size = %d\n",fdir ? acesize*2 : acesize))

    // static buffer in the hopes we won't have to allocate memory

    BYTE buf[1024];

    // allocator either uses buf or allocates a new buffer if size is not enough

    FastAllocator fa(buf, 1024);

    // get the buffer for the ACE

    ACCESS_ALLOWED_ACE *paaa = (ACCESS_ALLOWED_ACE *)fa.GetBuf(acesize);
    if (!paaa) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    // fill in the ACE

    memcpy(&paaa->SidStart,psid,GetLengthSid(psid));
    paaa->Mask = mask;

    paaa->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    paaa->Header.AceFlags = fdir ? CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE : 0;
    paaa->Header.AceSize = acesize;

    // put the ACE into the ACL

    if (!AddAce(dacl,
                dacl->AclRevision,
                0xffffffff,
                paaa,
                paaa->Header.AceSize))
        ret = GetLastError();
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_SetDeniedAce, private
//
//  Synopsis:   appends a denied ACE to the input ACL
//
//  Arguments:  IN [dacl] - ACL to add the ACE to
//              IN [mask] - access mask to add
//              IN [psid] - SID to add
//              IN [fdir] - if a Dir add inherit ACE as well
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_SetDeniedAce(ACL *dacl, ACCESS_MASK mask, SID *psid, BOOL fdir)
{
    ULONG ret = ERROR_SUCCESS;

    // compute the size of the ACE we are making

    USHORT acesize = (USHORT)(sizeof(ACCESS_DENIED_ACE) -
                              sizeof(DWORD) +
                              GetLengthSid(psid));

    SIZE((stderr, "adding denied ace, size = %d\n",acesize))

    // static buffer in the hopes we won't have to allocate memory

    BYTE buf[1024];

    // allocator either uses buf or allocates a new buffer if size is not enough

    FastAllocator fa(buf, 1024);

    // get the buffer for the ACE

    ACCESS_DENIED_ACE *paaa = (ACCESS_DENIED_ACE *)fa.GetBuf(acesize);
    if (!paaa)
        return (ERROR_NOT_ENOUGH_MEMORY);

    // fill in the ACE

    memcpy(&paaa->SidStart,psid,GetLengthSid(psid));
    paaa->Mask = mask;

    paaa->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    paaa->Header.AceFlags = fdir ? CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE : 0;
    paaa->Header.AceSize = acesize;

    // put the ACE into the ACL

    if (!AddAce(dacl,
                dacl->AclRevision,
                0xffffffff,
                paaa,
                paaa->Header.AceSize))
        ret = GetLastError();
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_FillNewAcl, private
//
//  Synopsis:   The worker routine that actually fills the ACL, it adds the
//              new denied ACEs, then if the new ACEs are being merged with
//              an existing ACL, the existing ACL's ACE's (that don't
//              conflict) are added, finally the new allowed ACEs are added.
//              another ugly algorithm:
//
//for (new aces)
//   if (new ace option == DENY)
//      add new ace
//
//if (old aces)
//   for (old aces)
//      if (old ace mask != 0)
//         add old ace
//
//   for (new aces)
//      if (new ace option != DENY)
//         if ( new ace option != REVOKE)
//            if (new ace mask != 0
//                add new ace
//
//else
//   for (new aces)
//      if (new ace option != DENY)
//         add new ace
//
//  Arguments:  IN [pnewdacl] - the new ACL to be filled
//              IN [poldacl]  - (OPTIONAL) old ACL that is to be merged
//              IN [fdir]     - TRUE = directory
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_FillNewAcl(ACL *pnewdacl, ACL *poldacl, BOOL fdir)
{
    SID *psid = NULL;
    ULONG ret;

    // set new denied aces

    VERBOSE((stderr, "start addr of new ACL %p\n",pnewdacl))

    for (ULONG j = 0; j < _ccaa; j++)
    {
        if (_aaa[j].option & OPTION_DENY)
        {
            if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
            {
                if (!psid) {
                    return (ERROR_INVALID_DATA);
                }
                if (ERROR_SUCCESS != (ret = _SetDeniedAce(pnewdacl,
                                                           _aaa[j].pcaa->AccessMask(),
                                                           psid,
                                                           fdir )))
                    return(ret);
            } else
                return(ret);
        }
    }

    // check and see if the ACL from from the file is in correct format

    if (poldacl)
    {
        SIZE((stderr, "old ACL size = %d, acecount = %d\n",poldacl->AclSize,
              poldacl->AceCount))

        ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));

		//
        // loop thru the old ACL, and add all explicit aces
		//

        BOOL fallowedacefound = FALSE;
        for (ULONG cace = 0; cace < poldacl->AceCount;
            cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
        {
            // error exit if the old ACL is incorrectly formated

			if(pah->AceFlags & INHERITED_ACE)
				continue;


            if (pah->AceType == ACCESS_DENIED_ACE_TYPE && fallowedacefound)
            {
                VERBOSE((stderr, "_FillNewAcl found an denied ACE after an allowed ACE\n"))
                return(ERROR_INVALID_DATA);
            }
            else if (pah->AceType == ACCESS_ALLOWED_ACE_TYPE)
                fallowedacefound = TRUE;

            // add the old ace to the new ACL if the old ace's mask is not zero

            if ( 0 != (ACCESS_MASK)((ACCESS_ALLOWED_ACE *)pah)->Mask)
            {
                // add the old ace
                if (!AddAce(pnewdacl,
                            pnewdacl->AclRevision,
                            0xffffffff,
                            pah,
                            pah->AceSize))
                    return(GetLastError());
            }
        }

        // now for the new aces

        for (ULONG j = 0; j < _ccaa; j++)
        {
            if ( (_aaa[j].option != OPTION_DENY) &&
                 (_aaa[j].option != OPTION_REVOKE) &&
                 (_aaa[j].pcaa->AccessMask() != 0) )
            {
                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                {
                    if (!psid) {
                        return (ERROR_INVALID_DATA);
                    }
                    if (ERROR_SUCCESS != (ret = _SetAllowedAce(pnewdacl,
                                                               _aaa[j].pcaa->AccessMask(),
                                                               psid,
                                                               fdir )))
                        return(ret);
                } else
                    return(ret);
            }

        }

		//
        // loop thru the old ACL, and add all the inherited aces
		//
		pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));

        for (ULONG cace = 0; cace < poldacl->AceCount;
            cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
        {
			if(pah->AceFlags & INHERITED_ACE)
			{
				// add the old ace to the new ACL if the old ace's mask is not zero

				if ( 0 != (ACCESS_MASK)((ACCESS_ALLOWED_ACE *)pah)->Mask)
				{
					// add the old ace
					if (!AddAce(pnewdacl,
								pnewdacl->AclRevision,
								0xffffffff,
								pah,
								pah->AceSize))
						return(GetLastError());
				}
			}
        }

    } else
    {
        // no old acl, just add the (rest) of the new aces
        for (ULONG j = 0; j < _ccaa; j++)
        {
            if (_aaa[j].option != OPTION_DENY)
            {
                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                {
                    if (!psid) {
                        return (ERROR_INVALID_DATA);
                    }
                    if (ERROR_SUCCESS != (ret = _SetAllowedAce(pnewdacl,
                                                               _aaa[j].pcaa->AccessMask(),
                                                               psid,
                                                               fdir )))
                        return(ret);
                } else
                    return(ret);
            }
        }
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cacls\fileenum.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        FileEnum.cxx
//
// Contents:    class encapsulating file enumeration, including a deep option
//
// Classes:     CFileEnumeration
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------

#include <t2.hxx>
#include <FileEnum.hxx>
#if DBG
extern ULONG Debug;
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::CFileEnumerate, public
//
//  Synopsis:   initializes data members, constructor will not throw
//
//  Arguments:  IN [fdeep] - TRUE = go into sub-directories
//
//----------------------------------------------------------------------------
CFileEnumerate::CFileEnumerate(BOOL fdeep)
    : _fdeep(fdeep),
      _findeep(FALSE),
      _froot(FALSE),
      _fcannotaccess(FALSE),
      _pcfe(NULL),
      _pwfileposition(NULL),
      _handle(INVALID_HANDLE_VALUE)
{
    ENUMERATE_RETURNS((stderr, "CFileEnumerate ctor\n"))
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   closes handles
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CFileEnumerate::~CFileEnumerate()
{
    if (_handle != INVALID_HANDLE_VALUE)
        FindClose(_handle);
    ENUMERATE_RETURNS((stderr, "CFileEnumerate dtor (%ws)\n", _wpath))
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::Init, public
//
//  Synopsis:   Init must be called before any other methods - this
//              is not enforced. converts a ASCII file/path to a UNICODE
//              file/path, and gets the first file in the enumeration
//
//  Arguments:  IN  [filename]  - the path/file to enumerate
//              OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::Init(CHAR *filename, WCHAR **wfilename, BOOL *fdir)
{
    // Initialize the file name

    if (filename && (strlen(filename) < MAX_PATH))
    {
        // make it wchar
        WCHAR winfilename[MAX_PATH];

        if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                filename, -1,
                                winfilename, sizeof(winfilename) / sizeof(winfilename[0])) == 0)
            return(ERROR_INVALID_NAME);

        // finish initialization

        return(_ialize(winfilename, wfilename, fdir));
    }
    ENUMERATE_FAIL((stderr, "Init bad file name: %ld\n",ERROR_INVALID_NAME))
    return(ERROR_INVALID_NAME);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::Init, public
//
//  Synopsis:   Same as previous, except takes UNICODE file/path as input
//
//  Arguments:  IN  [filename]  - the path/file to enumerate
//              OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::Init(WCHAR *filename, WCHAR **wfilename, BOOL *fdir)
{
    // Initialize the file name

    if (filename && (wcslen(filename) < MAX_PATH))
    {
        return(_ialize(filename, wfilename, fdir));
    }
    ENUMERATE_FAIL((stderr, "Init bad file name: %ld\n",ERROR_INVALID_NAME))
    return(ERROR_INVALID_NAME);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_ialize, private
//
//  Synopsis:   finishes initialization and starts search for first file in
//              the enumeration
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_ialize(WCHAR *winfilename, WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "Init start, path =  %ws\n", winfilename))
    ULONG ret = ERROR_SUCCESS;

    ENUMERATE_STAT((stderr, "start path = %ws\n",winfilename))

    // save the location of the filename or wildcards

    ULONG cwcharcount;

    if (!(cwcharcount = GetFullPathName(winfilename,
                                       MAX_PATH,
                                       _wpath,
                                       &_pwfileposition)))
    {
        return(ERROR_INVALID_NAME);
    }

    ENUMERATE_STAT((stderr, "got full path name = %ws, filename = (%ws), total chars = %d\n",_wpath, _pwfileposition, cwcharcount))

    // if the filepart (_pwfileposition) is NULL, then the name must end in a slash.
    // add a *

    if (NULL == _pwfileposition)
    {
       _pwfileposition = (WCHAR *)Add2Ptr(_wpath,wcslen(_wpath)*sizeof(WCHAR));
    }

    // save the filename/wildcards

    wcscpy(_wwildcards, _pwfileposition);

    ENUMERATE_EXTRA((stderr, "wild cards = %ws\n",_wwildcards))

    // if we are at a root (path ends in :\)

    if ( (_wpath[wcslen(_wpath) - 1] == L'\\') &&
         (wcslen(_wpath) > 1) &&
         (_wpath[wcslen(_wpath) - 2] == L':') )
    {
        _wfd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        _wfd.cFileName[0] = L'\0';
        *wfilename = _wpath;
        *fdir = TRUE;
        _froot = TRUE;
    } else
    {
    // check to see if we can iterate through files
        if ( (INVALID_HANDLE_VALUE == ( _handle = FindFirstFile(_wpath, &_wfd) ) ) )
        {
            ret = GetLastError();
            _fcannotaccess = (ERROR_ACCESS_DENIED == ret);

            ENUMERATE_FAIL((stderr, "find first returned: %ld\n",ret))
        }
        if (ERROR_SUCCESS == ret)
        {
            // reject . & .. filenames (go on to next file )

            if ( (0 == wcscmp(_wfd.cFileName, L".")) ||
                 (0 == wcscmp(_wfd.cFileName, L"..")) )
            {
                ret = _NextLocal(wfilename,fdir);
            } else
            {
                // return the current directory

                if (_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    *fdir = TRUE;
                else
                    *fdir = FALSE;

                // add the filename to the path so the whole thing is returned

                //_pwfileposition is pointer to postion of file in _wpath. _wpath is 
                //MAX_PATH long. MAX_PATH - (_pwfileposition - _wpath) is the length of 
                //buffer _pwfileposition
                //
                HRESULT hr = StringCchCopy((LPWSTR)_pwfileposition,MAX_PATH - (_pwfileposition- _wpath), (LPCWSTR )_wfd.cFileName);
                if(FAILED(hr))
                {
                    return HRESULT_CODE(hr);
                }

                *wfilename = _wpath;
            }
        }

        ENUMERATE_STAT((stderr, "next filename = %ws\n", *wfilename))
    }

    // if we are going deep and we did not find a file yet:

    if ( _fdeep && ( ( ERROR_NO_MORE_FILES == ret ) ||
                     ( ERROR_FILE_NOT_FOUND == ret ) ) )
    {
        if (_handle != INVALID_HANDLE_VALUE)
        {
            FindClose(_handle);
            _handle = INVALID_HANDLE_VALUE;
        }
        ret = _InitDir(wfilename, fdir);
    }

    ENUMERATE_RETURNS((stderr, "Init returning  =  %ws(%ld)\n\n", *wfilename, ret))
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::Next, public
//
//  Synopsis:   finds the next file in the enumeration
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::Next(WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "Next start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_NO_MORE_FILES;

    // if we failed to initialize with an ERROR_ACCESS_DENIED, then exit
    if (_fcannotaccess)
        return(ERROR_NO_MORE_FILES);

    // if we are not in deep

    if (!_findeep)
    {
        if (!_froot)
           ret = _NextLocal(wfilename, fdir);

        // if we ran out of files and we are going deep:

        if ( _fdeep &&
             ( ( ERROR_NO_MORE_FILES == ret ) ||
               ( ERROR_FILE_NOT_FOUND == ret ) || _froot ) )
        {
            if (_handle != INVALID_HANDLE_VALUE)
            {
                FindClose(_handle);
                _handle = INVALID_HANDLE_VALUE;
            }
            ret = _InitDir(wfilename, fdir);
            _froot = FALSE; // (we are past the root now)
        }

    } else
    {
        // if we are already down a directory (and in deep)

        if (_pcfe)
        {
            if (ERROR_SUCCESS != (ret = _pcfe->Next(wfilename, fdir)))
            {
                if (ERROR_ACCESS_DENIED != ret)
                {
                    delete _pcfe;
                    _pcfe = NULL;
                }
            }
        }

        // we need to go to the next directory in the current dir

        if (ERROR_NO_MORE_FILES == ret)
        {
            ret = _NextDir(wfilename, fdir);
        }
    }
    ENUMERATE_RETURNS((stderr, "Next returning  =  %ws(%ld)\n\n", *wfilename, ret))
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_NextLocal, private
//
//  Synopsis:   searchs for the next file in the current directory
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_NextLocal(WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "_NextLocal start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_SUCCESS;

    // ensure that we have a valid handle for a findnextfile

    if (INVALID_HANDLE_VALUE == _handle)
    {
        ret = ERROR_INVALID_HANDLE;
    } else
    {
        do
        {
            if (!FindNextFile(_handle, &_wfd))
            {
                ret = GetLastError();
                ENUMERATE_FAIL((stderr, "find next returned: %ld\n",ret))
            } else
                ret = ERROR_SUCCESS;
        }
        while ( (ERROR_SUCCESS == ret) &&
                ( (0 == wcscmp(_wfd.cFileName, L".")) ||
                  (0 == wcscmp(_wfd.cFileName, L"..")) ) );


        // if we found a file

        if (ERROR_SUCCESS == ret)
        {
            // return the directory attrib.

            if (_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                *fdir = TRUE;
            else
                *fdir = FALSE;

            // add the filename to the path so the whole thing is returned

			//_pwfileposition is pointer to postion of file in _wpath. _wpath is 
			//MAX_PATH long. MAX_PATH - (_pwfileposition - _wpath) is the length of 
			//buffer _pwfileposition
			//
			HRESULT hr = StringCchCopy((LPWSTR)_pwfileposition,
									   MAX_PATH - (_pwfileposition- _wpath), 
									   (const wchar_t*)_wfd.cFileName);
			if(FAILED(hr))
			{
				return HRESULT_CODE(hr);
			}

            *wfilename = _wpath;

            ENUMERATE_STAT((stderr, "next filename = %ws\n", *wfilename))
        }
    }
    ENUMERATE_RETURNS((stderr, "_NextLocal returning  =  %ws(%ld)\n", *wfilename, ret))

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_InitDir, private
//
//  Synopsis:   (only called if going deep)
//              goes down a directory (and thus causing a new CFileEnumerator
//              to be created, or re-initializies
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_InitDir(WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "_InitDir start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_SUCCESS;

    // check and see if a directory was entered as the filename

    if ( (0 == _wcsicmp(_wwildcards, _wfd.cFileName)) &&
         (_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
    {
        ENUMERATE_EXTRA((stderr, "first file matched directory = %ws\n", _wpath))
        _pwfileposition += wcslen(_wfd.cFileName);

		//_pwfileposition is pointer to postion of file in _wpath. _wpath is 
		//MAX_PATH long. MAX_PATH - (_pwfileposition - _wpath) is the length of 
		//buffer _pwfileposition
		//
		HRESULT hr = StringCchCopy((LPWSTR)_pwfileposition,
									   MAX_PATH - (_pwfileposition- _wpath), 
									   L"\\*.*");
		if(FAILED(hr))
		{
			return HRESULT_CODE(hr);
		}

        _pwfileposition++;
        wcscpy(_wwildcards, L"*.*");
        ENUMERATE_EXTRA((stderr, "      path = %ws\n",_wpath))
        ENUMERATE_EXTRA((stderr, "wild cards = %ws\n",_wwildcards))

        WCHAR winfilename[MAX_PATH];
		hr = StringCchCopy((LPWSTR)winfilename,
							MAX_PATH, 
							_wpath);
		if(FAILED(hr))
		{
			return HRESULT_CODE(hr);
		}

        ret = _ialize(winfilename, wfilename, fdir);
    } else
    {

        // we are in deep

        _findeep = TRUE;

        // search thru all directories

        //_pwfileposition is pointer to postion of file in _wpath. _wpath is 
		//MAX_PATH long. MAX_PATH - (_pwfileposition - _wpath) is the length of 
		//buffer _pwfileposition
		//
		HRESULT hr = StringCchCopy((LPWSTR)_pwfileposition,
								   MAX_PATH - (_pwfileposition- _wpath), 
								   L"*.*");
		if(FAILED(hr))
		{
			return HRESULT_CODE(hr);
		}


        if (INVALID_HANDLE_VALUE == ( _handle = FindFirstFile(_wpath, &_wfd) ))
        {
            ret = GetLastError();
            ENUMERATE_FAIL((stderr, "find first (dir) returned: %ld\n",ret))
        } else
        {
            if ( !(_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                 (0 == wcscmp(_wfd.cFileName, L".")) ||
                 (0 == wcscmp(_wfd.cFileName, L"..")) )
            {
                ret = _NextDir(wfilename, fdir);
            } else
            {
                // if we have a sub directory, go down it

                ret = _DownDir(wfilename, fdir);

                // if we found nothing in that first sub directory, go the the next one

                if ( (ERROR_NO_MORE_FILES == ret ) ||
                     (ERROR_FILE_NOT_FOUND == ret ) )
                {
                    ret = _NextDir(wfilename, fdir);
                }
            }
        }
    }
    ENUMERATE_RETURNS((stderr, "_InitDir returning  =  %ws(%ld)\n", *wfilename, ret))

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_NextDir, private
//
//  Synopsis:   (only called if going deep)
//              finds the next sub-directory from the current directory,
//              and then goes down into that directory
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_NextDir(WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "_NextDir start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_SUCCESS;

    // skip the . & .. & files we cannot access

    if (INVALID_HANDLE_VALUE == _handle)
    {
        ret = ERROR_INVALID_HANDLE;
    } else
    {
        do
        {
            do
            {
                if (!FindNextFile(_handle, &_wfd))
                {
                    ret = GetLastError();
                    ENUMERATE_FAIL((stderr, "find next returned: %ld\n",ret))
                } else
                    ret = ERROR_SUCCESS;
            }
            while ( (ERROR_SUCCESS == ret) &&
                    ( !(_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                      (0 == wcscmp(_wfd.cFileName, L".")) ||
                      (0 == wcscmp(_wfd.cFileName, L"..")) ) );

            // if we found a directory

            if (ERROR_SUCCESS == ret)
            {
                ret = _DownDir(wfilename, fdir);
            } else
            {
                // out of subdirectories to search, break out of the loop
                break;
            }
        }
        while (( ERROR_NO_MORE_FILES == ret) || (ERROR_FILE_NOT_FOUND == ret));
    }
    ENUMERATE_RETURNS((stderr, "_NextDir returning  =  %ws(%ld)\n", *wfilename, ret))

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_DownDir, private
//
//  Synopsis:   (only called if going deep)
//              creates a new CFileEnumerator for a sub-directory
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_DownDir(WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "_DownDir start, path =  %ws\n", _wpath))
    ULONG ret;

    // make a new file enumerator class (this one) We should only go down
    // 8 directories at most.

    _pcfe = new CFileEnumerate(_fdeep);
    if (!_pcfe)
        return ERROR_NOT_ENOUGH_MEMORY;

    // add the wildcards to the end of the directory we are going down

	//_pwfileposition is pointer to postion of file in _wpath. _wpath is 
	//MAX_PATH long. MAX_PATH - (_pwfileposition - _wpath) is the length of 
	//buffer _pwfileposition
	//
	HRESULT hr = StringCchCopy((LPWSTR)_pwfileposition,
								MAX_PATH - (_pwfileposition- _wpath), 
								( const wchar_t *)_wfd.cFileName);
	if(FAILED(hr))
	{
		return HRESULT_CODE(hr);
	}

	hr = StringCchCat(_wpath,MAX_PATH,L"\\");
	if(FAILED(hr))
	{
		return HRESULT_CODE(hr);
	}

    hr = StringCchCat(_wpath,MAX_PATH, _wwildcards);
	if(FAILED(hr))
	{
		return HRESULT_CODE(hr);
	}

    // start it up and see if we find a match

    if (ERROR_SUCCESS != (ret = _pcfe->Init(_wpath, wfilename, fdir)))
    {
        if (ERROR_ACCESS_DENIED != ret)
        {
            delete _pcfe;
            _pcfe = NULL;
        }
    }
    ENUMERATE_RETURNS((stderr, "_DownDir returning  =  %ws(%ld)\n", *wfilename, ret))
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cacls\accacc.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        accacc.cxx
//
// Classes:     CAccountAccess
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------
#include <accacc.hxx>
#if DBG
extern ULONG Debug;
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::CAccountAccess, public
//
//  Synopsis:   initializes data members, constructor will not throw
//
//  Arguments:  IN - [Name]   - principal
//              IN - [System] - server/domain
//
//----------------------------------------------------------------------------
CAccountAccess::CAccountAccess(WCHAR *Name, WCHAR *System)
    : _mask(0),
      _savemask(0),
      _foundinheritance(0),
      _acetype(0xff),
      CAccount(Name, System)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::Init, public
//
//  Synopsis:   initializes access mask
//
//  Arguments:  IN [access] - access mask
//
//----------------------------------------------------------------------------
ULONG CAccountAccess::Init(ULONG access)
{
    if (access == 0)
    {
        _savemask = GENERIC_ALL;
        _mask = GENERIC_ALL;
        _acetype = ACCESS_DENIED_ACE_TYPE;
    } else
    {
        _acetype = ACCESS_ALLOWED_ACE_TYPE;
        _savemask = access;
        _mask = access;
    }
    return(ERROR_SUCCESS);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::AddInheritance, public
//
//  Synopsis:   accumulates inheritance of ACEs with matching SIDS
//
//  Arguments:  inheritance flags
//
//--------------------------------------------------------------------
void CAccountAccess::AddInheritance(BYTE Flags)
{
    if (!(Flags & NO_PROPAGATE_INHERIT_ACE))
    {
        if (Flags & INHERIT_ONLY_ACE)
        {
            if (Flags & CONTAINER_INHERIT_ACE)
                _foundinheritance |= CONTAINER_INHERIT_ACE;
            if (Flags & OBJECT_INHERIT_ACE)
                _foundinheritance |= OBJECT_INHERIT_ACE;
        } else
        {
           _foundinheritance |= APPLIES_TO_CONTAINER;
           if (Flags & CONTAINER_INHERIT_ACE)
              _foundinheritance |= CONTAINER_INHERIT_ACE;
           if (Flags & OBJECT_INHERIT_ACE)
              _foundinheritance |= OBJECT_INHERIT_ACE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cacls\dumpsec.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        DumpSec.cxx
//
// Contents:    class to dump file security ACL
//
// Classes:     CDumpSecurity
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------

#include <DumpSec.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::CDumpSecurity, public
//
//  Synopsis:   initialized data members, constructor will not throw
//
//  Arguments:  IN [pfilename] - name of file to dump security for
//
//----------------------------------------------------------------------------
CDumpSecurity::CDumpSecurity(WCHAR *pfilename)
    : _psd(NULL),
      _pwfilename(pfilename),
      _pdacl(NULL),
      _pah(NULL),
      _psid(NULL),
      _cacethissid(0),
      _bNullDacl(FALSE)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::Init, public
//
//  Synopsis:   Init must be called before any other methods - this
//              is not enforced.  Init gets the security descriptor and
//              ACL for the file
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
ULONG CDumpSecurity::Init()
{
    ULONG ret;
    ULONG cpsd;

    // get the size of the security buffer

    if (!GetFileSecurity(_pwfilename,
                         DACL_SECURITY_INFORMATION |
                         GROUP_SECURITY_INFORMATION |
                         OWNER_SECURITY_INFORMATION,
                         NULL,
                         0,
                         &cpsd) )
    {
        if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
        {
            if ( NULL == ( _psd = (BYTE *)LocalAlloc(LPTR, cpsd)))
            {
                 return(ERROR_NOT_ENOUGH_MEMORY);
            }

            // actually get the buffer this time

            if ( GetFileSecurity(_pwfilename,
                                 DACL_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION |
                                 OWNER_SECURITY_INFORMATION,
                                 _psd,
                                 cpsd,
                                 &cpsd) )
            {
                BOOL fdaclpresent;
                BOOL cod;

                // get the ACL

                if ( GetSecurityDescriptorDacl(_psd,
                                           &fdaclpresent,
                                           &_pdacl,
                                           &cod) )

                {
                    if (!fdaclpresent)
                    {
                        _pdacl = NULL;
                        return(ERROR_NO_SECURITY_ON_OBJECT);
                    }
                    // save the ACL location
                    if(!_pdacl)
                    {
                        _bNullDacl = TRUE;
                    }
                    else
                    {
                        _pah = (ACE_HEADER *)Add2Ptr(_pdacl, sizeof(ACL));
                    }
                    return(ERROR_SUCCESS);

                } else
                   return(GetLastError());
            } else
               return(GetLastError());
        }
    } else
        return(ERROR_NO_SECURITY_ON_OBJECT);

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   frees the security descriptor
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CDumpSecurity::~CDumpSecurity()
{
    if (_psd)
    {
        LocalFree(_psd);
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::GetSDOwner, public
//
//  Synopsis:   returns the owner of the file
//
//  Arguments:  OUT [psid] - address of the returned sid
//
//----------------------------------------------------------------------------
ULONG CDumpSecurity::GetSDOwner(SID **psid)
{
    BOOL cod;
    if ( GetSecurityDescriptorOwner(_psd, (void **)psid, &cod) )
        return(0);
    else
        return(GetLastError());
}

//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::GetSDGroup, public
//
//  Synopsis:   returns the group from the file
//
//  Arguments:  OUT [pgsid] - address of the returned group sid
//
//----------------------------------------------------------------------------
ULONG CDumpSecurity::GetSDGroup(SID **pgsid)
{
    BOOL cod;
    if ( GetSecurityDescriptorGroup(_psd, (void **)pgsid, &cod) )
        return(0);
    else
        return(GetLastError());
}

//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::ResetAce, public
//
//  Synopsis:   sets the 'ace' index to the start of the DACL
//
//  Arguments:  IN - [psid] - the SID to find aces for
//
//----------------------------------------------------------------------------
VOID CDumpSecurity::ResetAce(SID *psid)
{

    _psid = psid;
    _cacethissid = 0;
    if (_pdacl)
        _pah = (ACE_HEADER *)Add2Ptr(_pdacl, sizeof(ACL));
}
//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::GetNextAce, public
//
//  Synopsis:   gets the next ACE from the DACL for the specified SID
//
//  Arguments:  OUT  [pace] - pointer to the next ace for the SID passed
//                            in at the last reset.
//
//  Returns:    the number of the ACE
//
//----------------------------------------------------------------------------
LONG CDumpSecurity::GetNextAce(ACE_HEADER **paceh)
{
    LONG ret = -1;

    if (_pdacl)
    {
        for (;_cacethissid < _pdacl->AceCount;
            _cacethissid++, _pah = (ACE_HEADER *)Add2Ptr(_pah, _pah->AceSize))
        {
            if (!_psid || EqualSid(_psid,(SID *)&((ACCESS_ALLOWED_ACE *)_pah)->SidStart) )
            {
               *paceh = _pah;
                ret = _cacethissid++;
                _pah = (ACE_HEADER *)Add2Ptr(_pah, _pah->AceSize);
                break;
            }
        }
    }
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cacls\account.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        account.cxx
//
// Contents:    Class wrapping account sid and name
//
// Classes:     CAccount
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------

#include <account.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::CAccount, public
//
//  Synopsis:   initializes data members
//
//  Arguments:  IN [Name]   - principal
//              IN [System] - server/domain
//
//----------------------------------------------------------------------------
CAccount::CAccount(WCHAR *Name, WCHAR *System)
    : _name(Name),
      _system(System),
      _domain(NULL),
      _psid(NULL),
      _fsid(TRUE)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::CAccount, public
//
//  Synopsis:   Initializes data members
//
//  Arguments:  IN [pSid]   - SID of principal
//              IN [System] - server/domain
//
//----------------------------------------------------------------------------
CAccount::CAccount(SID *pSid, WCHAR *System)
    : _name(NULL),
      _system(System),
      _domain(NULL),
      _psid(pSid),
      _fsid(FALSE)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   frees sid or name and domain
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CAccount::~CAccount()
{
    if (_fsid)
    {
        if (_psid)
        {
            LocalFree(_psid);
        }
    } else if (_name)
    {
        LocalFree(_name);
    }
    if (_domain)
        LocalFree(_domain);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::GetAccountName, public
//
//  Synopsis:   returns the Name associated with the instance of the class
//
//  Arguments:  OUT [name] address of the principal name
//
//----------------------------------------------------------------------------
ULONG CAccount::GetAccountName(WCHAR **name)
{

    ULONG ret = ERROR_SUCCESS;

    if (_name == NULL)
    {
        DWORD can = 0, crd = 0;
        SID_NAME_USE esnu;

        if (!LookupAccountSid( NULL,
                               _psid,
                               NULL,
                               &can,
                               NULL,
                               &crd,
                               &esnu))
        {
            if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
            {
                ret = ERROR_SUCCESS;
                if (NULL == (_name = (WCHAR *)LocalAlloc(LMEM_FIXED, can * sizeof(WCHAR))))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                if (NULL == (_domain = (WCHAR *)LocalAlloc(LMEM_FIXED, crd * sizeof(WCHAR))))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }

                if ( !LookupAccountSid( NULL,
                                       _psid,
                                       _name,
                                       &can,
                                       _domain,
                                       &crd,
                                       &esnu) )
                {
                   ret = GetLastError();
                }
            }
        }
     }
     *name = _name;
     return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::GetAccountSid, public
//
//  Synopsis:   returns the Sid
//
//  Arguments:  OUT [psid] - sid associated with instance of the class
//
//----------------------------------------------------------------------------
ULONG CAccount::GetAccountSid(SID **psid)
{

    ULONG ret = ERROR_SUCCESS;

    if (_psid == NULL && _name != NULL)
    {
        DWORD cusid = 0, crd = 0;
        SID_NAME_USE esnu;

        if (!LookupAccountName( _system,
                                _name,
                               NULL,
                               &cusid,
                               NULL,
                               &crd,
                               &esnu))
        {
            if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
            {

                ret = ERROR_SUCCESS;
                if (NULL == (_psid = (SID *)LocalAlloc(LMEM_FIXED, cusid)))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                if (NULL == (_domain = (WCHAR *)LocalAlloc(LMEM_FIXED, crd * sizeof(WCHAR))))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }

                if ( !LookupAccountName( _system,
                                         _name,
                                         _psid,
                                         &cusid,
                                         _domain,
                                         &crd,
                                         &esnu) )

                {
                   ret = GetLastError();
                }
            }
        }
     }
     *psid = _psid;
     return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::GetAccountDomain, public
//
//  Synopsis:   returns the domain for the class
//
//  Arguments:  [domain] - returns the domain associated with the instance of
//                         the class
//
//----------------------------------------------------------------------------
ULONG CAccount::GetAccountDomain(WCHAR **domain)
{
    ULONG ret = ERROR_SUCCESS;

    if (_domain == NULL)
    {
        if (_fsid)
        {
            SID *psid;
            ret = GetAccountSid(&psid);
        } else
        {
            WCHAR *name;
            ret = GetAccountName(&name);
        }
    }
    *domain = _domain;
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cacls\filesec.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        filesec.cxx
//
// Classes:     CFileSecurity class encapsulating SECURITY_DESCRIPTOR
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------

#include <filesec.hxx>
//+---------------------------------------------------------------------------
// Function:    Add2Ptr
//
// Synopsis:    Add an unscaled increment to a ptr regardless of type.
//
// Arguments:   [pv]    -- Initial ptr.
//              [cb]    -- Increment
//
// Returns:     Incremented ptr.
//
//----------------------------------------------------------------------------
VOID * Add2Ptr(VOID *pv, ULONG cb)
{
    return((BYTE *) pv + cb);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileSecurity::CFileSecurity, public
//
//  Synopsis:   initializes data members
//              constructor will not throw
//
//  Arguments:  [filename] - name of file to apply security descriptor to
//
//----------------------------------------------------------------------------
CFileSecurity::CFileSecurity(WCHAR *filename)
    : _psd(NULL),
      _pwfilename(filename)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileSecurity::Init, public
//
//  Synopsis:   Init must be called before any other methods - this
//              is not enforced.  gets security descriptor from file
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
ULONG CFileSecurity::Init()
{
    ULONG ret;
    ULONG cpsd;

    // get the size of the security buffer

    if (!GetFileSecurity(_pwfilename,
                         DACL_SECURITY_INFORMATION |
                         GROUP_SECURITY_INFORMATION |
                         OWNER_SECURITY_INFORMATION,
                         NULL,
                         0,
                         &cpsd) )
    {
        if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
        {
            if (NULL == (_psd = (BYTE *)LocalAlloc(LPTR, cpsd)))
            {
                 return(ERROR_NOT_ENOUGH_MEMORY);
            }

            // actually get the buffer this time

            if ( GetFileSecurity(_pwfilename,
                                 DACL_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION |
                                 OWNER_SECURITY_INFORMATION,
                                 _psd,
                                 cpsd,
                                 &cpsd) )
                ret = ERROR_SUCCESS;
            else
                ret = GetLastError();

        }
    } else
        return(ERROR_NO_SECURITY_ON_OBJECT);
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   frees security descriptor if allocated
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CFileSecurity::~CFileSecurity()
{
    if (_psd)
    {
        LocalFree(_psd);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSecurity::SetFS, public
//
//  Synopsis:   sets or modifies the security descriptor DACL on the specified file
//
//  Arguments:  IN - [fmodify] - TRUE = modify ACL, FALSE = replace ACL
//              IN - [pcdw]    - wrapper around new ACEs
//              IN - [fdir]    - TRUE = directory
//
//  Returns:    status
//
//----------------------------------------------------------------------------
ULONG CFileSecurity::SetFS(BOOL fmodify, CDaclWrap *pcdw, BOOL fdir)
{
   BOOL fdaclpresent;
   BOOL cod;
   ACL *pdacl;
   ULONG ret;

   // get the ACL from the security descriptor

   if ( GetSecurityDescriptorDacl(_psd,
                                  &fdaclpresent,
                                  &pdacl,
                                  &cod) )

   {
       if (fdaclpresent)
       {
           // build the new ACL (from the new ACEs and the old ACL)

           PACL pnewdacl = NULL;

           if (ERROR_SUCCESS == (ret = pcdw->BuildAcl(&pnewdacl,
                                                      fmodify ? pdacl : NULL,
                                                      pdacl ? pdacl->AclRevision : ACL_REVISION,
                                                      fdir)
                                                      ))
           {
               // make a new security descriptor

               SECURITY_DESCRIPTOR newsd;
					//NTRAID#NTBUG9-547532-2002/03/28-hiteshr
               if(!InitializeSecurityDescriptor( &newsd, SECURITY_DESCRIPTOR_REVISION ))
					{
						LocalFree(pnewdacl);
						return GetLastError();
					}

               if(!SetSecurityDescriptorDacl( &newsd, TRUE, pnewdacl, FALSE ))
					{
						LocalFree(pnewdacl);
						return GetLastError();
					}

               //
               // apply it to the file
               //

               if (!SetFileSecurity(_pwfilename,
                                    DACL_SECURITY_INFORMATION,
                                    &newsd))
               {
                   ret = GetLastError();
               }
               LocalFree(pnewdacl);
           }
       }
       else
           return(ERROR_NO_SECURITY_ON_OBJECT);
    } else
    {
        ret = GetLastError();
    }

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cacls\makefile.inc ===
caclsmsg.rc: msg00001.bin

caclsmsg.h msg00001.bin: caclsmsg.mc
    mc -v -h .\ caclsmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cacls\utest\main.cxx ===
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

//+----------------------------------------------------------------------------
ULONG GetAcl(WCHAR *filename, WCHAR *outfile);
//+----------------------------------------------------------------------------
#define RESULTS(a) if (fdebug & 1)  {printf a;}
#define VERBOSE(a) if (fdebug & 2)  {printf a;}

//+----------------------------------------------------------------------------
VOID Usage()
{
    printf("USAGE veracl <filename> [/d] [name permission[...]]\n");
}
//+----------------------------------------------------------------------------
ULONG fdebug;

VOID _cdecl main(INT argc, char *argv[])
{
    if ( (argc < 2) ||
         ( (argc > 2) && ( (argv[2][0] != '/') && ((argc % 2) != 0) ) ) )
    {
        Usage();
        exit(1);
    } else if ((argc > 2) && (argv[2][0] == '/') )
    {
        if (0 == _stricmp(&argv[2][1],"r") )
        {
            fdebug = 1;
        } else if (0 == _stricmp(&argv[2][1],"d") )
        {
            fdebug = 2;
        } else
        {
            Usage();
            exit(1);
        }
    } else
    {
        fdebug = 0;
    }

    ULONG ret;
    CHAR db[1024];
    FILE *pf;

    WCHAR wch[256];
    WCHAR *pwch;
    CHAR *pch;

    for ( pwch = wch, pch = argv[1]; *pwch = (WCHAR)(*pch);pwch++,pch++);

    if ( ERROR_SUCCESS == (ret = GetAcl(wch, L"DinkWink.cmp")))
    {
        if (NULL != (pf = fopen("DinkWink.cmp","r")))
        {
            CHAR *ptok = NULL;
            for (int k = fdebug ? 3 : 2; k < argc; k+=2)
            {
                if (NULL != fgets(db,1024, pf))
                {
                    VERBOSE(("GetAcl returned: %s[%d]\n",db,k))
                    
                    if (k <= 3)
                    {
                        if ( NULL == ( ptok = strtok(db, " ")))
                        {
                            VERBOSE(("no file name found\n"))
                            ret = ERROR_INVALID_DATA;
                            break;
                        }
                        VERBOSE(("ptok (1st) [%s]\n",ptok))
                    }
                    if (NULL != ( ptok = strtok(k <= 3 ? NULL : db, ":\n")))
                    {
                        // this ugly little mess should strip off the leading spaces
                        for (; *ptok == ' ';ptok++);
                        
                        VERBOSE(("ptok (2nd) [%s]\n",ptok))
                        if (0 == _stricmp(ptok, argv[k]))
                        {
                            if (NULL != (ptok = strtok(NULL, " ")))
                            {
                                VERBOSE(("ptok (3rd) [%s]\n",ptok))
                                if ((argc <= k) || (0 != _stricmp(ptok, argv[k+1])))
                                {
                                    VERBOSE(("mismatch type %s != %s\n",ptok))
                                    ret = ERROR_INVALID_DATA;
                                    break;
                                }
                            } else
                            {
                                VERBOSE(("access type not found in\n"))
                                ret = ERROR_INVALID_DATA;
                                break;
                            }
                        } else
                        {
                            VERBOSE(("mismatch %s != %s\n",ptok, argv[k]))
                            ret = ERROR_INVALID_DATA;
                            break;
                        }
                    } else
                    {
                        VERBOSE((": not found in CACLs output\n"))
                        ret = ERROR_INVALID_DATA;
                        break;
                    }
                } else
                {
                    VERBOSE(("End of CACLs output\n"))
                    ret = ERROR_INVALID_DATA;
                    break;
                }
            }
            if (k != argc)
            {
                VERBOSE(("not all name:permissions found on file\n"))
                for (int j = k; j < argc ;j+=2 )
                    VERBOSE(("    %s:%s\n",argv[j], argv[j+1]))
                ret = ERROR_INVALID_DATA;

            }
            fclose(pf);
        } else
        {
            ret = GetLastError();
            VERBOSE(("fopen failed, %ld\n", ret))
        }
        DeleteFile(L"DinkWink.cmp");
    } else
    {
        VERBOSE(("GetAcl failed, %ld\n", ret))
    }
    if (ret == ERROR_SUCCESS)
    {
        RESULTS(("PASSED\n"))
    }
    else
    {
        RESULTS(("FAILED\n"))
    }
    exit(ret);
}
//+----------------------------------------------------------------------------
ULONG GetAcl(WCHAR *filename, WCHAR *outfile)
{

    ULONG ret = ERROR_SUCCESS;
    WCHAR cmdline[1024];

    wsprintf(cmdline, L"cmd /c CACLS.EXE %ws > %ws",
             filename,
             outfile);

    VERBOSE(("CMD: %ws\n",cmdline))

    STARTUPINFO sui;
    memset(&sui,0,sizeof(STARTUPINFO));
    sui.cb = sizeof(STARTUPINFO);

    PROCESS_INFORMATION pi;

    if (CreateProcess(NULL,
                      cmdline,
                      NULL,
                      NULL,
                      TRUE,
                      NORMAL_PRIORITY_CLASS,
                      NULL,
                      NULL,
                      &sui,
                      &pi))
    {
        ULONG ec;
        CloseHandle(pi.hThread);
        DWORD dw = WaitForSingleObject(pi.hProcess, INFINITE);

        if (!GetExitCodeProcess(pi.hProcess, &ec))
            ret = GetLastError();

        CloseHandle(pi.hProcess);
        if (ret == ERROR_SUCCESS)
            ret = ec;
    } else
        ret = GetLastError();

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cat\cat.cpp ===
/* cat - conCATenate STDIN to STDOUT
 *
 * 24-Apr 1998 hiroyama
 *
 */

#include "precomp.h"
#pragma hdrstop

#include "fnreg.h"

#if !defined(UNICODE)
#error please compile me for UNICODE
#endif

#ifndef _T
#define _T      TEXT
#endif

#define LINENUMBER          0x0001
#define EOL_MARK            0x0002
#define TAB_SPECIAL         0x0004
#define CTRL_SPECIAL        0x0008
#define NO_BUFFERED_OUTPUT  0x0010
#define UNICODE_INPUT       0x0020
#define AUTO_UNICODE_DETECT 0x0040

struct InOutMode {
    BOOLEAN fUnicodeInput;
    BOOLEAN fMbcsOutput;
    BOOLEAN fNeedSwab;
    BOOLEAN fLineBuffer;
};

DWORD options = 0;

#define LARGE_BUFSIZE   (512)

void usage()
{
    static const char str[] =
        "cat [-aenotuvV] [filename ...]\n"
        "-a      same as -u if input begins with BOM\n"
        "-e      add '$' at the end of line\n"
        "-n      add line number\n"
        "-o      suppress buffering for output\n"
        "-t      show tab character as '^I'\n"
        "-u      unicode text processing\n"
        "-v      show control characters as '^' + alphabet, except tab and newline.\n"
        "-V      show version\n"
        "--      declare end of options\n";

    fputs(str, stderr);
    exit(EXIT_FAILURE);
}

template <class T>
inline void ntoa(T* p, int n, int width)
{
    p += width;
    *p-- = '\0';
    for (--width; width >= 0; --width) {
        *p-- = (n % 10) + '0';
        n /= 10;
    }
}

template <class T>
inline void swap(T& a, T& b)
{
    a ^= b ^= a ^= b;
}


/////////////////////////////////////////////////////////
// Complex cat UNICODE helpers
/////////////////////////////////////////////////////////

inline int getcaw(InOutMode mode, FILE* fp)
{
    if (mode.fUnicodeInput) {
        wchar_t c = fgetwc(fp);
        if (c == WEOF)
            return EOF;
        return c;
    }
    return fgetc(fp);
}

inline void ungetaw(InOutMode mode, int c, FILE* fp)
{
    if (mode.fUnicodeInput)
        ungetwc((wchar_t)c, fp);
    else
        ungetc(c, fp);
}

inline void putcharaw(InOutMode mode, int c)
{
    if (mode.fUnicodeInput) {
        // if output is dbcs (i.e. tty output), we need to
        // translate the unicode character
        if (mode.fMbcsOutput) {
            // prevent to print BOM
            if (c != 0xfeff) {
                // translate the output
                char buf[2];
                int n = wctomb(buf, (wchar_t)c);
                putchar(buf[0]);
                if (n == 2) {
                    putchar(buf[1]);
                }
            }
        }
        else {
            putwchar((wchar_t)c);
        }
    }
    else
        putchar(c);
}

inline void swab(int& c)
{
    c = ((c & 0xff00) >> 8) | ((unsigned char)c << 8);
}


/////////////////////////////////////////////////////////
// Complex cat
/////////////////////////////////////////////////////////

void complex_cat(const TCHAR* fname)
{
    FILE* fp;

    if (fname) {
        if ((fp = _tfopen(fname, _T("rb"))) == NULL) {
            _tperror(fname);
            exit(EXIT_FAILURE);
        }
        if (setvbuf(fp, NULL, _IOFBF, LARGE_BUFSIZE))
            perror("setvbuf");
    }
    else {
        // if fname == NULL, take input from stdin.
        fp = stdin;
    }

    static bool tol = true;     // Top Of Line
    static long lineno = 0;
    int c, c2;

    // Initialize In/Out mode
    InOutMode inOutMode = {
        !!(options & UNICODE_INPUT),
        false,
        false,
        // if buffered mode and stdout is tty, flush buffer at each EOL
        !(options & NO_BUFFERED_OUTPUT) && _isatty(_fileno(stdout)),
    };

    // UNICODE initialization
    if (inOutMode.fUnicodeInput) {
        // sample the first word for BOM detection
        c = fgetwc(fp);
init_unicode:
        _setmode(_fileno(fp), _O_BINARY);
        if (_isatty(_fileno(stdout))) {
            // if the output is tty,
            // need to convert UNICODE to MBCS on output
            inOutMode.fMbcsOutput = true;
        }

        // try to process the BOM
        if (c == 0xfeff) {
            putcharaw(inOutMode, c);
        }
        else if (c == 0xfffe) {
            inOutMode.fNeedSwab = true;
            swab(c);
            putcharaw(inOutMode, c);
        }
        else {
            ungetwc((wchar_t)c, fp);
        }
    }
    else if (options & AUTO_UNICODE_DETECT) {
        // sample and examine the first word to see if it's UNICODE BOM
        c = fgetwc(fp);
        if (c == 0xfffe || c == 0xfeff) {
            inOutMode.fUnicodeInput = true;
            goto init_unicode;
        }
        ungetwc((wchar_t)c, fp);
    }

#ifdef MEASURE_PERF
    DWORD start = ::GetTickCount();
#endif

    while ((c = getcaw(inOutMode, fp)) != EOF) {
        if (tol) {
            // process line number
            tol = false;
            if (options & LINENUMBER) {
                if (inOutMode.fUnicodeInput && !inOutMode.fMbcsOutput) {
                    wchar_t buf[5];
                    ntoa(buf, ++lineno, 4);
                    fputws(buf, stdout);
                    fputws(L": ", stdout);
                }
                else {
                    char buf[5];
                    ntoa(buf, ++lineno, 4);
                    fputs(buf, stdout);
                    fputs(": ", stdout);
                }
            }
        }

        if (inOutMode.fNeedSwab)
            swab(c);

        switch (c) {
        case '\r':
            c2 = getcaw(inOutMode, fp);
            if (c2 != '\n') {
                ungetaw(inOutMode, c2, fp);
                goto normal_input;
            }
            // fall through
        case '\n':
            if (options & EOL_MARK) {
                putcharaw(inOutMode, '$');
            }
            if (c != '\n') {
                putcharaw(inOutMode, c);
                c = c2;
            }
            putcharaw(inOutMode, c);
            if (inOutMode.fLineBuffer) {
                // if line buffer mode, flush it
                fflush(stdout);
            }
            tol = true;
            break;

        case '\t':
            if (options & TAB_SPECIAL) {
                fputs("^I", stdout);
            }
            else {
                putcharaw(inOutMode, c);
            }
            break;

        default:
normal_input:
            if (c < 0x20 && (options & CTRL_SPECIAL)) {
                putcharaw(inOutMode, '^');
                c += '@';
            }
            putcharaw(inOutMode, c);
            break;
        }
    }

    if (fname) {
        fclose(fp);
    }

#ifdef MEASURE_PERF
    DWORD end = ::GetTickCount();
    fprintf(stderr, "delta=%u\n", end - start);
#endif
}

void cat(const TCHAR* fname = NULL)
{
    static bool is1st = true;
    if (is1st) {
        is1st = false;
        if (options & NO_BUFFERED_OUTPUT) {
            // non buffered mode
            if (setvbuf(stdout, NULL, _IONBF, 0))
                perror("setvbuf");
        }
        else {
            if (setvbuf(stdout, NULL, _IOFBF, LARGE_BUFSIZE))
                perror("setvbuf");
        }
    }

    complex_cat(fname);
}


void parse_option(const TCHAR* s, bool& eoo)    // eoo: end of options
{
    extern char version[];

    while (*++s) {
        switch (*s) {
        case _T('-'):
            eoo = true;
            return;
        case _T('a'):
            options |= AUTO_UNICODE_DETECT;
            break;
        case _T('e'):
            options |= EOL_MARK;
            break;
        case _T('n'):
            options |= LINENUMBER;
            break;
        case _T('v'):
            options |= CTRL_SPECIAL;
            break;
        case _T('t'):
            options |= TAB_SPECIAL;
            break;
        case _T('o'):
            options |= NO_BUFFERED_OUTPUT;
            break;
        case _T('u'):
            options |= UNICODE_INPUT;
            break;
        case _T('V'):
            fputs(version, stderr);
            exit(EXIT_SUCCESS);
        default:
            usage();    // never returns
        }
    }
}

#ifdef UNICODE
#define main    wmain
#endif

extern "C"
int __cdecl main(int argc, TCHAR** argv)
{
    int n = 0;
    bool eoo = false;

    fnexpand(&argc, &argv);

    setlocale(LC_ALL, "");

    // set stdout binary mode
    _setmode(_fileno(stdout), _O_BINARY);

    while (--argc) {
        if (**++argv == _T('-') && !eoo) {
            parse_option(*argv, eoo);
        }
        else {
            ++n;
            eoo = true;
            cat(*argv);
        }
    }

    if (n == 0) {
        _setmode(_fileno(stdin), _O_BINARY);
        cat();
    }

    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cat\fnreg.h ===
// fnreg.h
//
// filename regular expression routine for WIN32
//
// Copyright (C) 1994-1998 by Hirofumi Yamamoto. All rights reserved.
//
// Redistribution and use in source and binary forms are permitted
// provided that
// the above copyright notice and this paragraph are duplicated in all such
// forms and that any documentation, advertising materials, and other
// materials related to such distribution and use acknowledge that the
// software was developed by Hirofumi Yamamoto may not be used to endorse or
// promote products derived from this software without specific prior written
// permission. THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
// OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
//


//////////////////////////////////////////////////////////////////////////
// BOOL fnexpand(int* argc, TCHAR*** argv);
//
// fnexpand takes &argc and &argv to expand wild cards in the arguments.
//
// Currently characters should be UNICODE. In other words,
// main routine should be wmain. See cat.cpp's main routine for the
// detail.
//////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C"
#endif
BOOL fnexpand(int* argc, TCHAR*** argv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cacls\t2.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        t2.cxx
//
// Contents:
//
// Classes:
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------
#include <t2.hxx>
#include <filesec.hxx>
#include <fileenum.hxx>
#include <dumpsec.hxx>
#include "caclsmsg.h"
#include <locale.h>
#include <string.h>
#include <winnlsp.h>
#include <tchar.h>
#if DBG
ULONG Debug;
#endif
//+----------------------------------------------------------------------------
//
// local prototypes
//
//+----------------------------------------------------------------------------
BOOLEAN OpenToken(PHANDLE ph);
void printfsid(SID *psid, ULONG *outputoffset);
void printface(ACE_HEADER *paceh, BOOL fdir, ULONG outputoffset);
void printfmask(ULONG mask, UCHAR acetype, BOOL fdir, ULONG outputoffset);
WCHAR *mbstowcs(char *aname );
BOOL GetUserAndAccess(TCHAR *arg, WCHAR **user, ULONG *access);
#if DBG
ULONG DebugEnumerate(TCHAR *filename, ULONG option);
#endif
ULONG DisplayAces(TCHAR *filename, ULONG option);
ULONG ModifyAces(TCHAR *filename,
                 MODE emode,
                 ULONG option,
                 TCHAR *argv[],
                 LONG astart[], LONG aend[] );

ULONG GetCmdLineArgs(INT argc, TCHAR *argv[],
                     ULONG *option,
                     LONG astart[], LONG aend[],
                     MODE *emode
#if DBG
                     ,ULONG *debug
#endif
                     );
ULONG
__cdecl
printmessage (FILE* fp, DWORD messageID, ...);



//+----------------------------------------------------------------------------
//
//  Function:   vfcprintf
//
//  Synopsis:   prints formatted text to [pOut].  This function will call the
//              defulat c printf functions if it can not call WriteConsole().
//              We are calling WriteConsole() because it will display extended
//              characters, were as fprintf, printf ..., functions do not display
//              multi linguel strings.
//
//  Arguments: [pOut]         - Must be stdout, stderr, otherwise the function will just
//                              call standard c functions.
//             [pszFormate]   - Format string
//             [argList]      - variable length argument list.
//
//----------------------------------------------------------------------------
void vfcprintf(FILE *pOut, LPCTSTR pszFormat, va_list argList)
{
   HANDLE handle;

   //
   // Get the standard handles for output.  This assumes that the callers is calling with
   // either stdout or stderr, if it's anything else then just use normal sprintf.
   //
   TCHAR szText[2048];
   if(pOut == stdout){
      handle = GetStdHandle(STD_OUTPUT_HANDLE);
   } else if(pOut == stderr ){
      handle = GetStdHandle(STD_ERROR_HANDLE);
   } else {
do_normal:
#if defined(_UNICODE) || defined(UNICODE)
      vswprintf( szText, pszFormat, argList );
      fwprintf(pOut, szText );
#else
      vsprintf( szText, pszFormat, argList );
      fprintf(pOut, szText );
#endif
      return;
   }

   //
   // If we can't get the output handle then just send it to standard fprintf functions
   //
   if(INVALID_HANDLE_VALUE == handle){
      goto do_normal;
   }

   //
   // Format the text using standard C functions.
   //
#if defined(_UNICODE) || defined(UNICODE)
   vswprintf( szText, pszFormat, argList );
#else
   vsprintf( szText, pszFormat, argList );
#endif

   DWORD cRead = 0;
   //
   // If we can't get the console mode from this handle, then it is being piped somewhere else
   // and we must use sprintf to write, because WriteConsole only works with a console
   // output handle.
   //
   if(!GetConsoleMode( handle, &cRead ))
   {
	    DWORD cchBuffer = lstrlen(szText);
        LPSTR  lpAnsiBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, (cchBuffer+1)*sizeof(WCHAR));

        if (lpAnsiBuffer != NULL)
        {
            cchBuffer = WideCharToMultiByte(CP_OEMCP,
                                            0,
                                            szText,
                                            cchBuffer + 1,
                                            lpAnsiBuffer,
                                            (cchBuffer +1) * sizeof(WCHAR),
                                            NULL,
                                            NULL);

            if (cchBuffer != 0)
            {
                fprintf(pOut,"%s",lpAnsiBuffer);
            }

            LocalFree(lpAnsiBuffer);
		}

   } else {
      WriteConsole( handle, szText, lstrlen(szText), &cRead, NULL);
   }

}


//+----------------------------------------------------------------------------
//
//  Function:   fcprintf
//
//  synopsis:   Same as fprintf, except this will call vfcprintf, which
//              prints to the console use WriteConsole.
//
//  Arguments: [pOut]         - FILE stream to output to.
//             [pszFormate]   - Format string
//             [...]          - variable length argument list.
//
//----------------------------------------------------------------------------
void
__cdecl
fcprintf( FILE *pOut, LPCTSTR pszFormat, ...)
{
   va_list marker;
   va_start(marker, pszFormat);
   vfcprintf( pOut, pszFormat, marker);
   va_end(marker);
}


//+----------------------------------------------------------------------------
//
//  Function:   fcprintf
//
//  synopsis:   Same as printf, except this will call vfcprintf, which
//              prints to the console use WriteConsole.
//
//  Arguments: [pszFormate]   - Format string
//             [...]          - variable length argument list.
//
//----------------------------------------------------------------------------
void
__cdecl
cprintf( LPCTSTR pszFormat, ...)
{
   va_list marker;
   va_start(marker, pszFormat);
   vfcprintf( stdout, pszFormat, marker);
   va_end(marker);
}

//+----------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   prints usage functionality
//
//  Arguments: none
//
//----------------------------------------------------------------------------
VOID usage()
{
    printmessage(stdout, MSG_CACLS_USAGE, NULL);

#if DBG
    if (Debug)
    {
        printf("\n   /B            deBug <[#]>\n");
        printf("                 default is display error returned\n");
        printf("                 in /B '#' is a mask: 1  display SIDS values\n");
        printf("                                      2  display access masks\n");
        printf("                                      4  display error returned\n");
        printf("                                      8  display error location\n");
        printf("                                   0x10  verbose\n");
        printf("                                   0x20  verboser\n");
        printf("                                   0x40  enumerate names\n");
        printf("                                   0x80  enumerate failures\n");
        printf("                                  0x100  enumerate starts and returns\n");
        printf("                                  0x200  enumerate extra data\n");
        printf("                                  0x400  size allocation data\n");
        printf("                                  0x800  display enumeration of files\n");
    }
#endif
}

BOOL
IsAclSupported(LPCWSTR lpszFileName)
{
	BOOL bReturn = TRUE;
	WCHAR szVolumePathName[MAX_PATH+1];
	if(GetVolumePathName(lpszFileName,
						 szVolumePathName,
						 MAX_PATH))
	{
		int nLen = wcslen(szVolumePathName);
		if((WCHAR)szVolumePathName[nLen -1] != L'\\')
		{
			szVolumePathName[nLen] = L'\\';
			szVolumePathName[nLen++] = L'\0';
		}
		DWORD dwFlags = 0;
		if(GetVolumeInformation(szVolumePathName,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &dwFlags,
                                 NULL,
                                 0))
        {
			if(!(FS_PERSISTENT_ACLS & dwFlags))
			{
				printmessage(stdout,MSG_CACLS_NOT_NTFS);
				return FALSE;
			}
        }
		
	}		
	return bReturn;
}
//+----------------------------------------------------------------------------
//
//  Function:     Main, Public
//
//  Synopsis:     main!!
//
//  Arguments:    IN [argc] - cmdline arguement count
//                IN [argv] - input cmdline arguements
//
//----------------------------------------------------------------------------
#if defined( __cplusplus )
extern "C" {
#endif
VOID _cdecl wmain(int argc, wchar_t *argvw[])
{
    char lBuf[6];

    //
    // Set the local to system OEM code page.
    //
    setlocale(LC_ALL, ".OCP" );
	SetThreadUILanguage(0);
	
    //
    // Convert the wide character set to string array.
    //
    LONG astart[MAX_OPTIONS], aend[MAX_OPTIONS];
    MODE emode;

    LONG ret = 0;
    ULONG option;

    if (ERROR_SUCCESS != (ret = GetCmdLineArgs(argc, argvw,
                                               &option,
                                               astart, aend,
                                               &emode
#if DBG
                                               ,&Debug
#endif
                                               )))
    {
        usage();
        exit(ret);
    }

	if(!IsAclSupported(argvw[1]))
		exit(1);
    switch (emode)
    {
        case MODE_DISPLAY:
            ret = DisplayAces(argvw[1], option);
            break;
        case MODE_REPLACE:
        case MODE_MODIFY:
            ret = ModifyAces(argvw[1], emode, option, argvw, astart, aend );
            break;
#if DBG
        case MODE_DEBUG_ENUMERATE:
            ret = DebugEnumerate(argvw[1], option);
            break;
#endif
        default:
        {
            usage();
            exit(1);
        }
    }
    if (ERROR_SUCCESS != ret)
    {
        LAST_ERROR((stderr, "Cacls failed, %ld\n",ret))
        if( ret == ERROR_BAD_ARGUMENTS )
            ret = MSG_CACLS_INVALID_ARGUMENT;
        printmessage(stderr, ret, NULL);

        if( ret == MSG_CACLS_INVALID_ARGUMENT )
            usage();
 }
    exit(ret);
}
#if defined( __cplusplus )
}
#endif

//---------------------------------------------------------------------------
//
//  Function:     GetCmdLineArgs
//
//  Synopsis:     gets and parses command line arguments into commands
//                recognized by this program
//
//  Arguments:    IN  [argc]   - cmdline arguement count
//                IN  [argv]   - input cmdline arguements
//                OUT [option] - requested option
//                OUT [astart] - start of arguments for each option
//                OUT [aend]   - end of arguments for each option
//                OUT [emode]  - mode of operation
//                OUT [debug]  - debug mask
//
//
//----------------------------------------------------------------------------
ULONG GetCmdLineArgs(INT argc, TCHAR *argv[],
                     ULONG *option,
                     LONG astart[], LONG aend[],
                     MODE *emode
#if DBG
                     ,ULONG *debug
#endif
                     )
{
    ARG_MODE_INDEX am = ARG_MODE_INDEX_NEED_OPTION;

#if DBG
    *debug = 0;
#endif
    *emode = MODE_DISPLAY;
    *option = 0;

    for (LONG j=0; j < MAX_OPTIONS ;j++ )
    {
        astart[j] = 0;
        aend[j] = 0;
    }

    if ( (argc < 2) || (argv[1][0] == '/') )
    {
#if DBG
        // do this so debug args are printed out

        if (argc >= 2)
        {
            if ( (CompareString(LOCALE_INVARIANT,NORM_IGNORECASE,
                                &argv[1][1], -1, TEXT("deBug"),-1) == CSTR_EQUAL) ||
                 (CompareString(LOCALE_INVARIANT,NORM_IGNORECASE,
                                &argv[1][1], -1, TEXT("b"),-1) == CSTR_EQUAL))

            {
                *debug = DEBUG_LAST_ERROR;
            }
        }
#endif
        return(ERROR_BAD_ARGUMENTS);
    }

    for (LONG k = 2; k < argc ; k++ )
    {
        if (argv[k][0] == '/')
        {
            switch (am)
            {
                case ARG_MODE_INDEX_NEED_OPTION:
#if DBG
                case ARG_MODE_INDEX_DEBUG:
#endif
                    break;

                case ARG_MODE_INDEX_DENY:
                case ARG_MODE_INDEX_REVOKE:
                case ARG_MODE_INDEX_GRANT:
                case ARG_MODE_INDEX_REPLACE:
                    if (astart[am] == k)
                        return(ERROR_BAD_ARGUMENTS);
                    break;

                default:
                    return(ERROR_BAD_ARGUMENTS);
            }

            if ( (0 == lstrcmpi(&argv[k][1], TEXT("Tree"))) ||
                 (0 == lstrcmpi(&argv[k][1], TEXT("t"))) )
            {
                if (*option & OPTION_TREE)
                    return(ERROR_BAD_ARGUMENTS);
                *option |= OPTION_TREE;
                am = ARG_MODE_INDEX_NEED_OPTION;
                continue;
            }

            if ( (0 == lstrcmpi(&argv[k][1], TEXT("Continue"))) ||
                 (0 == lstrcmpi(&argv[k][1], TEXT("c"))) )
            {
                if (*option & OPTION_CONTINUE_ON_ERROR)
                    return(ERROR_BAD_ARGUMENTS);
                *option |= OPTION_CONTINUE_ON_ERROR;
                am = ARG_MODE_INDEX_NEED_OPTION;
                continue;
            }

            if ( (0 == lstrcmpi(&argv[k][1], TEXT("Edit"))) ||
                 (0 == lstrcmpi(&argv[k][1], TEXT("E"))) )
            {
                if (*emode != MODE_DISPLAY)
                    return(ERROR_BAD_ARGUMENTS);
                *emode = MODE_MODIFY;
                am = ARG_MODE_INDEX_NEED_OPTION;
                continue;
            }

#if DBG
            if ( (0 == lstrcmpi(&argv[k][1], TEXT("deBug"))) ||
                 (0 == lstrcmpi(&argv[k][1], TEXT("b")))  )
            {
                if (*debug)
                    return(ERROR_BAD_ARGUMENTS);
                am = ARG_MODE_INDEX_DEBUG;
                *debug = DEBUG_LAST_ERROR;
                continue;
            }
#endif
            if ( (0 == lstrcmpi(&argv[k][1], TEXT("Deny"))) ||
                 (0 == lstrcmpi(&argv[k][1], TEXT("D"))) )
            {
                am = ARG_MODE_INDEX_DENY;
                *option |= OPTION_DENY;
            } else if ( (0 == lstrcmpi(&argv[k][1], TEXT("Revoke"))) ||
                        (0 == lstrcmpi(&argv[k][1], TEXT("R"))) )
            {
                am = ARG_MODE_INDEX_REVOKE;
                *option |= OPTION_REVOKE;
            } else if ( (0 == lstrcmpi(&argv[k][1], TEXT("Grant"))) ||
                        (0 == lstrcmpi(&argv[k][1], TEXT("G"))) )
            {
                am = ARG_MODE_INDEX_GRANT;
                *option |= OPTION_GRANT;
            } else if ( (0 == lstrcmpi(&argv[k][1], TEXT("rePlace"))) ||
                        (0 == lstrcmpi(&argv[k][1], TEXT("P"))) )
            {
                *option |= OPTION_REPLACE;
                am = ARG_MODE_INDEX_REPLACE;
            } else
                return(ERROR_BAD_ARGUMENTS);

            if (astart[am] != 0)
                return(ERROR_BAD_ARGUMENTS);
            astart[am] = k+1;
        } else
        {
            switch (am)
            {
                case ARG_MODE_INDEX_NEED_OPTION:
                    return(ERROR_BAD_ARGUMENTS);

#if DBG
                case ARG_MODE_INDEX_DEBUG:
                    *debug = _wtol(argv[k]);
                    if (*debug & DEBUG_ENUMERATE)
                        if (*emode == MODE_DISPLAY)
                            *emode = MODE_DEBUG_ENUMERATE;
                        else
                            return(ERROR_BAD_ARGUMENTS);

                    am = ARG_MODE_INDEX_NEED_OPTION;
                    break;
#endif
                case ARG_MODE_INDEX_DENY:
                case ARG_MODE_INDEX_REVOKE:
                case ARG_MODE_INDEX_GRANT:
                case ARG_MODE_INDEX_REPLACE:
                    aend[am] = k+1;
                    break;

                default:
                    return(ERROR_BAD_ARGUMENTS);
            }
        }
    }

    if ( ( (*option & OPTION_DENY) && (aend[ARG_MODE_INDEX_DENY] == 0) ) ||
         ( (*option & OPTION_REVOKE) && (aend[ARG_MODE_INDEX_REVOKE] == 0) ) ||
         ( (*option & OPTION_GRANT) && (aend[ARG_MODE_INDEX_GRANT] == 0) ) ||
         ( (*option & OPTION_REPLACE) && (aend[ARG_MODE_INDEX_REPLACE] == 0) ) )
    {
        return(ERROR_BAD_ARGUMENTS);
    } else if ( (*option & OPTION_DENY) ||
                (*option & OPTION_REVOKE) ||
                (*option & OPTION_GRANT) ||
                (*option & OPTION_REPLACE) )
    {
        if (*emode == MODE_DISPLAY)
        {
            if (*option & OPTION_REVOKE)
            {
                return(ERROR_BAD_ARGUMENTS);
            }
            *emode = MODE_REPLACE;
        }
    }
    return(ERROR_SUCCESS);
}

//---------------------------------------------------------------------------
//
//  Function:     DisplayAces
//
//  Synopsis:     displays ACL from specified file
//
//  Arguments:    IN [filename] - file name
//                IN [option]   - display option
//
//----------------------------------------------------------------------------
ULONG DisplayAces(TCHAR *filename, ULONG option)
{
    CFileEnumerate cfe(option & OPTION_TREE);
    WCHAR *pwfilename;
    BOOL fdir;
    ULONG ret;

    if (NO_ERROR == (ret = cfe.Init(filename, &pwfilename, &fdir)))
    {
        while ( (NO_ERROR == ret) ||
                ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) )&&
                  (option & OPTION_CONTINUE_ON_ERROR) ) )
        {
#if DBG
            if (fdir)
                DISPLAY((stderr, "processing file: "))
            else
                DISPLAY((stderr, "processing dir: "))
#endif
            cprintf( TEXT("%s"), pwfilename);
            if (ERROR_ACCESS_DENIED == ret)
            {
                printmessage(stdout,MSG_CACLS_ACCESS_DENIED, NULL);
            } else if (ERROR_SHARING_VIOLATION == ret)
            {
                printmessage(stdout,MSG_CACLS_SHARING_VIOLATION, NULL);
            } else
            {
                DISPLAY((stderr, "\n"))
                VERBOSE((stderr, "\n"))
                CDumpSecurity cds(pwfilename);

                if (NO_ERROR == (ret = cds.Init()))
                {
#if DBG
                    if (Debug & DEBUG_VERBOSE)
                    {
                        SID *psid;
                        ULONG oo;

                        if (NO_ERROR == (ret = cds.GetSDOwner(&psid)))
                        {
                            printf("  Owner = ");
                            printfsid(psid, &oo);
                            if (NO_ERROR == (ret = cds.GetSDGroup(&psid)))
                            {
                                printf("  Group = ");
                                printfsid(psid, &oo);
                            }
                            else
                                ERRORS((stderr, "GetSDGroup failed, %d\n",ret))
                        }
                        else
                            ERRORS((stderr, "GetSDOwner failed, %d\n",ret))
                    }
#endif
                    ACE_HEADER *paceh;

                    if(cds.IsDaclNull())
                    {
                        printmessage(stdout,MSG_NULL_DACL, NULL);
                    }
                    else
                    {


                        LONG retace;
                        if (NO_ERROR == ret)
                            for (retace = cds.GetNextAce(&paceh); retace >= 0; )
                            {
                                printface(paceh, fdir, wcslen(pwfilename));
                                retace = cds.GetNextAce(&paceh);
                                if (retace >= 0)
                                    printf("%*s",
                                           WideCharToMultiByte(CP_ACP, 0,
                                                   pwfilename, -1,
                                                   NULL, 0,
                                                   NULL, NULL)-1," ");
                            }
                    }
                }
#if DBG
                   else
                    ERRORS((stderr, "cds.init failed, %d\n",ret))
#endif
            }
            fprintf(stdout, "\n");

            if ( (NO_ERROR == ret) ||
                ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) )&&
                   (option & OPTION_CONTINUE_ON_ERROR) ) )
                ret = cfe.Next(&pwfilename, &fdir);
        }

        switch (ret)
        {
            case ERROR_NO_MORE_FILES:
                ret = ERROR_SUCCESS;
                break;
            case ERROR_ACCESS_DENIED:
            case ERROR_SHARING_VIOLATION:
                break;
            case ERROR_SUCCESS:
                break;
            default:
                break;
        }

    } else
    {
        ERRORS((stderr, "cfe.init failed, %d\n",ret))
    }
    return(ret);
}
//---------------------------------------------------------------------------
//
//  Function:     ModifyAces
//
//  Synopsis:     modifies the aces for the specified file(s)
//
//  Arguments:    IN [filename] - name of file(s) to modify the aces on
//                IN [emode]  - mode of operation
//                IN [option] - requested option
//                IN [astart] - start of arguments for each option
//                IN [aend]   - end of arguments for each option
//
//----------------------------------------------------------------------------
ULONG ModifyAces(TCHAR *filename,
                 MODE emode,
                 ULONG option,
                 TCHAR *argv[],
                 LONG astart[], LONG aend[])
{
    CDaclWrap cdw;
    CFileEnumerate cfe(option & OPTION_TREE);
    WCHAR *user = NULL;
    ULONG access;
    ULONG ret = ERROR_SUCCESS;
    WCHAR *pwfilename;
    ULONG curoption;

    VERBOSERW((stderr, TEXT("user:permission pairs\n") ))

    // first proces the command line args to build up the new ace

    for (ULONG j = 0, k = 1;j < MAX_OPTIONS ; k <<= 1, j++ )
    {
        curoption = k;
        if (option & k)
        {
            for (LONG q = astart[j];
                      q < aend[j] ; q++ )
            {
                VERBOSERW((stderr, TEXT("      %s\n"),argv[q] ))

                if ((k & OPTION_GRANT) || (k & OPTION_REPLACE))
                {
                    if (!GetUserAndAccess(argv[q], &user, &access))
                    {
#if !defined(UNICODE) || !defined(_UNICODE)
                        if (user)
                            LocalFree(user);
#endif
                        return(ERROR_BAD_ARGUMENTS);
                    }
                    if (GENERIC_NONE == access)
                    {
                        if (!(k & OPTION_REPLACE))
                        {
#if !defined(UNICODE) || !defined(_UNICODE)
                            if (user)
                                LocalFree(user);
#endif
                            return(ERROR_BAD_ARGUMENTS);
                        }
                    }
                } else
                {
#if !defined(UNICODE) || !defined(_UNICODE)
                    user = mbstowcs(argv[q]);
#else
                    user = argv[q];
#endif
                    access = GENERIC_NONE;
                }

                VERBOSERW((stderr, TEXT("OPTION = %d, USER = %ws, ACCESS = %lx\n"),
                       option,
                       user,
                       access))


                if (ERROR_SUCCESS != (ret = cdw.SetAccess(curoption,
                                                     user,
                                                     NULL,
                                                     access)))
                {
                    ERRORS((stderr, "SetAccess for %ws:%lx failed, %d\n",
                           user,
                           access,
                           ret))
#if !defined(UNICODE) || !defined(_UNICODE)
                    LocalFree(user);
#endif
                    return(ret);
                }
#if !defined(UNICODE) || !defined(_UNICODE)
                LocalFree(user);
#endif
                user = NULL;
            }
        }
    }

    BOOL fdir;

    if (emode == MODE_REPLACE)
    {
        CHAR well[MAX_PATH];
        CHAR msgbuf[MAX_PATH];
        printmessage(stdout,MSG_CACLS_ARE_YOU_SURE, NULL);
        FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE, NULL, MSG_CACLS_Y, 0,
                      msgbuf, MAX_PATH, NULL);
        if(!fgets(well,MAX_PATH,stdin))
		{
		    int err = 0;
			if((err  = ferror(stdin)))
			    return err;
			return ERROR_INVALID_PARAMETER;
		}


        // remove the trailing return
        if ('\n' == well[strlen(well) - sizeof(CHAR)])
            well[strlen(well) - sizeof(CHAR)] = '\0';

        if (0 != _stricmp(well, msgbuf))
        {
            FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE, NULL, MSG_CACLS_YES, 0,
                          msgbuf, MAX_PATH, NULL);
            if (0 != _stricmp(well, msgbuf))
                return(ERROR_SUCCESS);
        }
    }

    if (NO_ERROR == (ret = cfe.Init(filename, &pwfilename, &fdir)))
    {
        while ( (NO_ERROR == ret) ||
                ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) )&&
                  (option & OPTION_CONTINUE_ON_ERROR) ) )
        {
            CFileSecurity cfs(pwfilename);

            if (NO_ERROR == (ret = cfs.Init()))
            {
                if (NO_ERROR != (ret = cfs.SetFS(emode == MODE_REPLACE ? FALSE : TRUE, &cdw, fdir)))
                {
                    if (!(((ERROR_ACCESS_DENIED == ret) || (ERROR_SHARING_VIOLATION == ret)) &&
                          (option & OPTION_CONTINUE_ON_ERROR)))
                    {
                        ERRORS((stderr, "SetFS on %ws failed %ld\n",pwfilename, ret))
                        return(ret);
                    }
                }
            }
            else
            {
               //
               // If the error is access denied or sharing violation and we are to continue on error,
               // then keep going. Otherwise bail out here.
               //

               if (!(((ERROR_ACCESS_DENIED == ret) || (ERROR_SHARING_VIOLATION == ret)) &&
                   (option & OPTION_CONTINUE_ON_ERROR))) {

                  ERRORS((stderr, "init failed, %d\n",ret))
                  return(ret);
               }
            }

            if (NO_ERROR == ret)
            {

                if (fdir)
                {
                    printmessage(stdout, MSG_CACLS_PROCESSED_DIR, NULL);
                    cprintf(L"%s\n",  pwfilename);
                }
                else
                {
                    printmessage(stdout, MSG_CACLS_PROCESSED_FILE, NULL);
                    cprintf(L"%s\n",  pwfilename);
                }
            }
            else if (ERROR_ACCESS_DENIED == ret)
            {
                printmessage(stdout, MSG_CACLS_ACCESS_DENIED, NULL);
                cprintf(L"%s\n",  pwfilename);
            }
            else if (ret == ERROR_SHARING_VIOLATION)
            {
                printmessage(stdout, MSG_CACLS_SHARING_VIOLATION, NULL);
                cprintf(L"%s\n",  pwfilename);
            }

            if ( (NO_ERROR == ret) ||
                 ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) ) &&
                   (option & OPTION_CONTINUE_ON_ERROR) ) )
                ret = cfe.Next(&pwfilename, &fdir);
        }

        switch (ret)
        {
            case ERROR_NO_MORE_FILES:
                ret = ERROR_SUCCESS;
                break;
            case ERROR_ACCESS_DENIED:
            case ERROR_SHARING_VIOLATION:
                break;
            case ERROR_SUCCESS:
                break;
            default:
                DISPLAY((stderr, "%ws failed: %d\n", pwfilename, ret))
                break;
        }
    } else
        ERRORS((stderr, "file enumeration failed to initialize %ws, %ld\n",pwfilename, ret))

    if (ret == ERROR_NO_MORE_FILES)
    {
        ret = ERROR_SUCCESS;
    }

    if (ret != ERROR_SUCCESS)
    {
        ERRORS((stderr, "Enumeration failed, %d\n",ret))
    }

    return(ret);
}
#if DBG
//---------------------------------------------------------------------------
//
//  Function:     DebugEnumerate
//
//  Synopsis:     debug function
//
//  Arguments:    IN [filename] - file name
//                IN [option]   - option
//
//----------------------------------------------------------------------------
ULONG DebugEnumerate(TCHAR *filename, ULONG option)
{
    CFileEnumerate cfe(option & OPTION_TREE);
    WCHAR *pwfilename;
    BOOL fdir;
    ULONG ret;

    ret = cfe.Init(filename, &pwfilename, &fdir);
    while ( (ERROR_SUCCESS == ret) ||
            ( (ERROR_ACCESS_DENIED == ret ) &&
              (option & OPTION_CONTINUE_ON_ERROR) ) )
    {
        if (fdir)
            printf("dir  name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
        else
            printf("file name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
        ret = cfe.Next(&pwfilename, &fdir);
    }
    if (ret == ERROR_ACCESS_DENIED)
    {
        if (fdir)
            printf("dir  name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
        else
            printf("file name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
    }
    if (ret != ERROR_NO_MORE_FILES)
        printf("Enumeration failed, %d\n",ret);

    return(ret);
}
#endif
//---------------------------------------------------------------------------
//
//  Function:     GetUserAccess
//
//  Synopsis:     parses an input string for user:access
//
//  Arguments:    IN  [arg]    - input string to parse
//                OUT [user]   - user if found
//                OUT [access] - access if found
//
//----------------------------------------------------------------------------
BOOL GetUserAndAccess(TCHAR *arg, WCHAR **user, ULONG *access)
{
    TCHAR *saccess = wcschr(arg,':');
    if (saccess)
    {
        *saccess = NULL;
        saccess++;

        if (wcschr(saccess,':'))
            return(FALSE);
#if defined(UNICODE) || defined(_UNICODE)
        *user = arg;
#else
        *user = mbstowcs(arg);
#endif

        if (0 == lstrcmpi(saccess, TEXT("F") ))
        {
            *access = ( STANDARD_RIGHTS_ALL |
                        FILE_READ_DATA |
                        FILE_WRITE_DATA |
                        FILE_APPEND_DATA |
                        FILE_READ_EA |
                        FILE_WRITE_EA |
                        FILE_EXECUTE |
                        FILE_DELETE_CHILD |
                        FILE_READ_ATTRIBUTES |
                        FILE_WRITE_ATTRIBUTES );
        }
        else if (0 == lstrcmpi(saccess,TEXT("R") ))
        {
            *access = FILE_GENERIC_READ | FILE_EXECUTE;
        }
        else if (0 == lstrcmpi(saccess, TEXT("C") ))
        {
            *access = FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_EXECUTE | DELETE;
        }
        else if (0 == lstrcmpi(saccess, TEXT("N") ))
        {
            *access = GENERIC_NONE;
        }
        else if (0 == lstrcmpi(saccess, TEXT("W") ))
        {
            *access = FILE_GENERIC_WRITE | FILE_EXECUTE;
        }
        else
            return(FALSE);
        return(TRUE);
    }
    return(FALSE);
}
//---------------------------------------------------------------------------
//
//  Function:     mbstowcs
//
//  Synopsis:     converts char to wchar, allocates space for wchar
//
//  Arguments:    IN [aname] - char string
//
//----------------------------------------------------------------------------
WCHAR *mbstowcs(char *aname )
{
    if (aname)
    {
        WCHAR *pwname = NULL;
        pwname = (WCHAR *)LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * (strlen(aname)+1));
        if (NULL == pwname)
            return(NULL);
        WCHAR *prwname = pwname;
        if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                aname, -1,
                                prwname, sizeof(WCHAR)*(strlen(aname)+1)) == 0)
            return(NULL);
        return(pwname);
    } else
        return(NULL);
}
//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Arguments:
//
//----------------------------------------------------------------------------
BOOLEAN OpenToken(PHANDLE ph)
{
    HANDLE hprocess;

    hprocess = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
    if (hprocess == NULL)
        return(FALSE);

    if (OpenProcessToken(hprocess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, ph))
    {
        CloseHandle(hprocess);
        return(TRUE);
    }

    CloseHandle(hprocess);
    return(FALSE);
}
//----------------------------------------------------------------------------
//
//  Function:     printfsid
//
//  Synopsis:     prints a NT SID
//
//  Arguments:    IN [psid] - pointer to the sid to print
//
//----------------------------------------------------------------------------
void printfsid(SID *psid, ULONG *outputoffset)
{
#if DBG
    if ((Debug & DEBUG_VERBOSE) || (Debug & DEBUG_DISPLAY_SIDS))
    {
        printf("S-%lx",psid->Revision);

        if ( (psid->IdentifierAuthority.Value[0] != 0) ||
             (psid->IdentifierAuthority.Value[1] != 0) )
        {
            printf("0x%02hx%02hx%02hx%02hx%02hx%02hx",
                        (USHORT)psid->IdentifierAuthority.Value[0],
                        (USHORT)psid->IdentifierAuthority.Value[1],
                        (USHORT)psid->IdentifierAuthority.Value[2],
                        (USHORT)psid->IdentifierAuthority.Value[3],
                        (USHORT)psid->IdentifierAuthority.Value[4],
                        (USHORT)psid->IdentifierAuthority.Value[5] );
        } else
        {
            printf("-%lu",
                   (ULONG)psid->IdentifierAuthority.Value[5]          +
                   (ULONG)(psid->IdentifierAuthority.Value[4] <<  8)  +
                   (ULONG)(psid->IdentifierAuthority.Value[3] << 16)  +
                   (ULONG)(psid->IdentifierAuthority.Value[2] << 24) );
        }

        if ( 0 < psid->SubAuthorityCount )
        {
            for (int k = 0; k < psid->SubAuthorityCount; k++ )
            {
                printf("-%d",psid->SubAuthority[k]);
            }
        }
    }
#endif
    ULONG ret;

    CAccount ca(psid, NULL);

    WCHAR *domain = NULL;
    WCHAR *user;

    if (NO_ERROR == ( ret = ca.GetAccountDomain(&domain) ) )
    {
        if ( (NULL == domain) || (0 == wcslen(domain)) )
        {
            fprintf(stdout, " ");
            *outputoffset +=1;
        }
        else
        {
            fprintf(stdout, " ");
            wprintf(L"%s",  domain);
			fprintf(stdout, "\\");
            *outputoffset += 2 + wcslen( domain );;
        }

        if (NO_ERROR == ( ret = ca.GetAccountName(&user) ) )
        {
            wprintf(L"%s",  user);
			fprintf(stdout, ":");
            *outputoffset += 1 + wcslen(user);
        } else
        {
            *outputoffset += printmessage(stdout, MSG_CACLS_NAME_NOT_FOUND, NULL);

            ERRORS((stderr, "(%lx)",ret))
        }
    } else
    {
        *outputoffset+= printmessage(stdout, MSG_CACLS_DOMAIN_NOT_FOUND, NULL);
        ERRORS((stderr, "(%lx)",ret))
    }
    VERBOSE((stderr, "\n"))
}
//----------------------------------------------------------------------------
//
//  Function:     printface
//
//  Synopsis:     prints the specifed ace
//
//  Arguments:    IN [paceh] - input ace (header)
//                IN [fdir]  - TRUE = directory (different display options)
//
//----------------------------------------------------------------------------
void printface(ACE_HEADER *paceh, BOOL fdir, ULONG outputoffset)
{
    VERBOSE((stderr, "  "))
    VERBOSER((stderr, "\npaceh->AceType  = %x\n",paceh->AceType  ))
    VERBOSER((stderr, "paceh->AceFlags = %x\n",paceh->AceFlags ))
    VERBOSER((stderr, "paceh->AceSize  = %x\n",paceh->AceSize  ))
    ACCESS_ALLOWED_ACE *paaa = (ACCESS_ALLOWED_ACE *)paceh;
    printfsid((SID *)&(paaa->SidStart),&outputoffset);
    if (paceh->AceFlags & OBJECT_INHERIT_ACE      )
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_OBJECT_INHERIT, NULL);
    }
    if (paceh->AceFlags & CONTAINER_INHERIT_ACE   )
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_CONTAINER_INHERIT, NULL);
    }
    if (paceh->AceFlags & NO_PROPAGATE_INHERIT_ACE)
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_NO_PROPAGATE_INHERIT, NULL);
    }
    if (paceh->AceFlags & INHERIT_ONLY_ACE        )
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_INHERIT_ONLY, NULL);
    }

    if (paceh->AceType == ACCESS_DENIED_ACE_TYPE)
    {
            DISPLAY_MASK((stderr, "(DENIED)"))
            VERBOSE((stderr, "(DENIED)"))
    }

    printfmask(paaa->Mask, paceh->AceType, fdir, outputoffset);
    fprintf(stdout, "\n");
}
//----------------------------------------------------------------------------
//
//  Function:     printfmask
//
//  Synopsis:     prints the access mask
//
//  Arguments:    IN [mask]    - the access mask
//                IN [acetype] -  allowed/denied
//                IN [fdir]    - TRUE = directory
//
//----------------------------------------------------------------------------
CHAR  *aRightsStr[] = { "STANDARD_RIGHTS_ALL",
                        "DELETE",
                        "READ_CONTROL",
                        "WRITE_DAC",
                        "WRITE_OWNER",
                        "SYNCHRONIZE",
                        "STANDARD_RIGHTS_REQUIRED",
                        "SPECIFIC_RIGHTS_ALL",
                        "ACCESS_SYSTEM_SECURITY",
                        "MAXIMUM_ALLOWED",
                        "GENERIC_READ",
                        "GENERIC_WRITE",
                        "GENERIC_EXECUTE",
                        "GENERIC_ALL",
                        "FILE_GENERIC_READ",
                        "FILE_GENERIC_WRITE",
                        "FILE_GENERIC_EXECUTE",
                        "FILE_READ_DATA",
                        //FILE_LIST_DIRECTORY
                        "FILE_WRITE_DATA",
                        //FILE_ADD_FILE
                        "FILE_APPEND_DATA",
                        //FILE_ADD_SUBDIRECTORY
                        "FILE_READ_EA",
                        "FILE_WRITE_EA",
                        "FILE_EXECUTE",
                        //FILE_TRAVERSE
                        "FILE_DELETE_CHILD",
                        "FILE_READ_ATTRIBUTES",
                        "FILE_WRITE_ATTRIBUTES" };

#define NUMRIGHTS 26
ULONG aRights[NUMRIGHTS] = { STANDARD_RIGHTS_ALL  ,
                         DELETE                   ,
                         READ_CONTROL             ,
                         WRITE_DAC                ,
                         WRITE_OWNER              ,
                         SYNCHRONIZE              ,
                         STANDARD_RIGHTS_REQUIRED ,
                         SPECIFIC_RIGHTS_ALL      ,
                         ACCESS_SYSTEM_SECURITY   ,
                         MAXIMUM_ALLOWED          ,
                         GENERIC_READ             ,
                         GENERIC_WRITE            ,
                         GENERIC_EXECUTE          ,
                         GENERIC_ALL              ,
                         FILE_GENERIC_READ        ,
                         FILE_GENERIC_WRITE       ,
                         FILE_GENERIC_EXECUTE     ,
                         FILE_READ_DATA           ,
                         //FILE_LIST_DIRECTORY    ,
                         FILE_WRITE_DATA          ,
                         //FILE_ADD_FILE          ,
                         FILE_APPEND_DATA         ,
                         //FILE_ADD_SUBDIRECTORY  ,
                         FILE_READ_EA             ,
                         FILE_WRITE_EA            ,
                         FILE_EXECUTE             ,
                         //FILE_TRAVERSE          ,
                         FILE_DELETE_CHILD        ,
                         FILE_READ_ATTRIBUTES     ,
                         FILE_WRITE_ATTRIBUTES  };

void printfmask(ULONG mask, UCHAR acetype, BOOL fdir, ULONG outputoffset)
{
    ULONG savmask = mask;
    VERBOSER((stderr, "mask = %08lx ", mask))
    DISPLAY_MASK((stderr, "mask = %08lx\n", mask))

    VERBOSE((stderr, "    "))

#if DBG
    if (!(Debug & (DEBUG_VERBOSE | DEBUG_DISPLAY_MASK)))
    {
#endif
        if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask == (FILE_GENERIC_READ | FILE_EXECUTE)))
        {
            printmessage(stdout, MSG_CACLS_READ, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask == (FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_EXECUTE | DELETE)))
        {
            printmessage(stdout, MSG_CACLS_CHANGE, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask == (GENERIC_WRITE | GENERIC_READ | GENERIC_EXECUTE | DELETE)))
        {
            printmessage(stdout, MSG_CACLS_CHANGE, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask ==  ( STANDARD_RIGHTS_ALL |
                             FILE_READ_DATA |
                             FILE_WRITE_DATA |
                             FILE_APPEND_DATA |
                             FILE_READ_EA |
                             FILE_WRITE_EA |
                             FILE_EXECUTE |
                             FILE_DELETE_CHILD |
                             FILE_READ_ATTRIBUTES |
                             FILE_WRITE_ATTRIBUTES )) )
        {
            printmessage(stdout, MSG_CACLS_FULL_CONTROL, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask ==  GENERIC_ALL))
        {
            printmessage(stdout, MSG_CACLS_FULL_CONTROL, NULL);
        } else if ((acetype == ACCESS_DENIED_ACE_TYPE) &&
                   (mask == GENERIC_ALL))
        {
            printmessage(stdout, MSG_CACLS_NONE, NULL);
        } else if ((acetype == ACCESS_DENIED_ACE_TYPE) &&
                   (mask ==  ( STANDARD_RIGHTS_ALL |
                             FILE_READ_DATA |
                             FILE_WRITE_DATA |
                             FILE_APPEND_DATA |
                             FILE_READ_EA |
                             FILE_WRITE_EA |
                             FILE_EXECUTE |
                             FILE_DELETE_CHILD |
                             FILE_READ_ATTRIBUTES |
                             FILE_WRITE_ATTRIBUTES )) )
        {
            printmessage(stdout, MSG_CACLS_NONE, NULL);
        } else
        {
            if (acetype == ACCESS_DENIED_ACE_TYPE)
                printmessage(stdout, MSG_CACLS_DENY, NULL);

            printmessage(stdout, MSG_CACLS_SPECIAL_ACCESS, NULL);

            for (int k = 0; k<NUMRIGHTS ; k++ )
            {
                if ((mask & aRights[k]) == aRights[k])
                {
                    fprintf(stdout, "%*s%s\n",outputoffset, " ", aRightsStr[k]);
                }
                if (mask == 0)
                    break;
            }
        }
#if DBG
    } else
    {
        if (Debug & (DEBUG_DISPLAY_MASK | DEBUG_VERBOSE))
        {
            printf("\n");
            for (int k = 0; k<NUMRIGHTS ; k++ )
            {
                if ((mask & aRights[k]) == aRights[k])
                {
                    if (mask != savmask) printf(" |\n");
                    printf("    %s",aRightsStr[k]);
                    mask &= ~aRights[k];
                }
                if (mask == 0)
                break;
            }
        }
        VERBOSE((stderr, "=%x",mask))
        if (mask != 0)
            DISPLAY((stderr, "=%x/%x",mask,savmask))
    }
#endif
    fprintf(stdout, " ");
}
//----------------------------------------------------------------------------
//
//  Function:     printmessage
//
//  Synopsis:     prints a message, either from the local message file, or from the system
//
//  Arguments:    IN [fp]    - stderr, stdio, etc.
//                IN [messageID] - variable argument list
//
//  Returns:      length of the output buffer
//
//----------------------------------------------------------------------------
ULONG
__cdecl
printmessage (FILE* fp, DWORD messageID, ...)
{
    WCHAR  messagebuffer[4096];
    va_list ap;

    va_start(ap, messageID);

    if (!FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, messageID, 0,
                      messagebuffer, 4095, &ap))
       FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, messageID, 0,
                        messagebuffer, 4095, &ap);

    CHAR achOem[2048];
    WideCharToMultiByte(CP_OEMCP,
                        0,
                        messagebuffer,
                        -1,
                        achOem,
                        sizeof(achOem),
                        NULL,
                        NULL);

    fprintf(fp,  achOem);
    va_end(ap);

    return(wcslen(messagebuffer));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cat\fnreg.cpp ===
// fnreg.cpp
//
// filename regular expression routine for WIN32
//
// Copyright (C) 1994-1998 by Hirofumi Yamamoto. All rights reserved.
//
// Redistribution and use in source and binary forms are permitted
// provided that
// the above copyright notice and this paragraph are duplicated in all such
// forms and that any documentation, advertising materials, and other
// materials related to such distribution and use acknowledge that the
// software was developed by Hirofumi Yamamoto may not be used to endorse or
// promote products derived from this software without specific prior written
// permission. THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
// OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
//

#include "precomp.h"
#pragma hdrstop

#include "fnreg.h"

// Hide everything in a name space
namespace fnreg_implement {

#ifdef UNICODE

#define MAX USHRT_MAX
typedef TCHAR uchar;
#define iskanji(x) false

#else   /* !UNICODE */

#define MAX UCHAR_MAX
typedef unsigned char uchar;
#define iskanji(x) isleadbyte(x)

#endif  /* !UNICODE */


#define PATHDLM _T("\\/")

#define ANY     _T('?')
#define CH      _T('.')
#define WILD    _T('*')
#define EOR     _T('\x01')

#define WILDCARD    _T("?*")

static TCHAR* fnrecompWorker(TCHAR* s, TCHAR* re, int& min, int& max)
{
    TCHAR* t;

    switch (*s) {
    case _T('\0'):
        *re = EOR;
        re[1] = _T('\0');
        return s;
    case ANY:
        *re++ = *s++;
        break;
    case WILD:
        *re++ = *s++;
        t = fnrecompWorker(s, re + 2, min, max);
        *re = min + 1;
        re[1] = max > MAX ? MAX : max + 1;
        max = MAX;
        return t;
    default:
        *re++ = CH;
#ifdef UNICODE
        *re++ = _totlower(*s);
        ++s;
#else
#error MBCS handling needed here.
#endif
    }
    t = fnrecompWorker(s, re, min, max);
    min++;
    max++;
    return t;
}


static BOOL fnrecomp(TCHAR* s, TCHAR* re)
{
    int a = 0, b = 0;
    return fnrecompWorker(s, re, a, b) != NULL;
}

static BOOL match(TCHAR* re, TCHAR* s)
{
    int min, max;
    int i;
    TCHAR* p;

    switch (*re) {
    case CH:
        return (re[1] == _totlower(*s)) && match(re + 2, s + 1);
    case ANY:
        return *s && match(re + 1, s + 1);
    case WILD:
        min = (uchar)re[1];
        max = (uchar)re[2];
        re += 3;
        i = 1;
#if !defined(UNICODE)
#error MBCS handling needed here.
#endif
        for (p = s + _tcslen(s); p >= s && i <= max; --p, ++i) {
            if (i >= min && match(re, p))
                return TRUE;
        }
        return FALSE;
    case EOR:
        if (re[1] == _T('\0'))
            return *s == _T('\0');
    }
    return FALSE;

}

///////////////////////////////////////////////////////////////////
// FileString class
///////////////////////////////////////////////////////////////////

class FileString {
public:
    FileString(const TCHAR* p);
    ~FileString();
    operator const TCHAR*() const { return m_string; }

    int operator==(FileString& s) const
    {
        return !_tcscmp(m_string, s.m_string);
    }
    int operator-(const FileString& f)
    {
        return _tcscmp(m_string, f);
    }
protected:
    TCHAR* m_string;
    void normalize();
};

void FileString::normalize()
{
    for (TCHAR* p = m_string; *p; ++p) {
        if (iskanji(*p))
            ++p;
        else if (*p == '\\')
            *p = '/';
    }
}

FileString::FileString(const TCHAR* p)
{
    m_string = new TCHAR[_tcslen(p) + 1];
    if (m_string == NULL) {
        fputs("FileString:: not enough mem\n", stderr);
        exit(1);
    }
    _tcscpy(m_string, p);
    normalize();
}

FileString::~FileString()
{
    delete[] m_string;
}

///////////////////////////////////////////////////////////////////
// PtrArray class
///////////////////////////////////////////////////////////////////

template <class T>
class PtrArray {
public:
    PtrArray(bool doDeleteContents = true, int defsize = DEFSIZE)
        : m_size(defsize), m_max(0), m_doDelete(doDeleteContents)
    {
        m_table = (T**)malloc(sizeof(T*) * m_size);
        if (m_table == NULL) {
            perror("PtrArray");
            exit(1);
        }
    }
    virtual ~PtrArray()
    {
        if (m_doDelete) {
            for (int i = 0; i < m_max; ++i) {
                delete m_table[i];
            }
        }
        if (m_table)
            free(m_table);
    }
    void add(T*);
    int howmany() { return m_max; }
    T* operator[](int n)
    {
        assert(n >= 0 && n < m_max);
        return m_table[n];
    }
    void sortIt();
protected:
    int m_size;
    int m_max;
    bool m_doDelete;    // whether to delete the contents
    T** m_table;
    enum { DEFSIZE = 128, INCR = 128 };
    static int __cdecl compare(const void*, const void*);
};

template <class T>
int __cdecl PtrArray<T>::compare(const void* a, const void* b)
{
    const T** ta = (const T**)a;
    const T** tb = (const T**)b;
    return int(**ta - **tb);
}

template <class T>
void PtrArray<T>::sortIt()
{
    qsort(m_table, m_max, sizeof(T*), compare);
}

template <class T>
void PtrArray<T>::add(T* t)
{
    if (m_max >= m_size) {
        void *pv = realloc(m_table, (m_size += INCR) * sizeof(T*));
        if (pv) {
            m_table = (T**)pv;
        } else {
            perror("PtrArray:add\n");
            exit(1);
        }
    }
    m_table[m_max++] = t;
}


///////////////////////////////////////////////////////////////////
// PtrArrayIterator class
///////////////////////////////////////////////////////////////////

template <class T>
class PtrArrayIterator {
public:
    PtrArrayIterator(PtrArray<T>& s) : m_array(s), m_cur(0)
    {
    }

public:
    T* operator++(int);
    void restart() { m_cur = 0; }

protected:
    PtrArray<T>& m_array;
    int m_cur;
};

template <class T>
T* PtrArrayIterator<T>::operator++(int)
{
    T* t;
    if (m_cur < m_array.howmany()) {
        t = m_array[m_cur++];
    }
    else {
        t = NULL;
    }
    return t;
}



///////////////////////////////////////////////////////////////////
// FilenameTable class
///////////////////////////////////////////////////////////////////

class FilenameTable {
public:
    FilenameTable(TCHAR* = NULL, int _searchDir = TRUE);
    ~FilenameTable();

public:
    void search(TCHAR* p, int level = 0);
    int howmany() { return m_names.howmany(); }
    PtrArray<FileString>& getTable() { return m_names; }

protected:
    int m_searchDir;
    PtrArray<FileString> m_names;
};

FilenameTable::FilenameTable(TCHAR* nm, int _searchDir /*=TRUE*/)
    : m_searchDir(_searchDir)
{
    if (nm)
        search(nm);
}

FilenameTable::~FilenameTable()
{
}

inline bool chkCurrentOrParentDir(const TCHAR* s)
{
    return s[0] == _T('.') && (s[1] == _T('\0') || (s[1] == _T('.') && s[2] == _T('\0')));
}

void FilenameTable::search(TCHAR* p, int level)
{
    TCHAR* wild = _tcspbrk(p, WILDCARD);

    if (wild) {
        // has wildcards
        TCHAR* const morepath = _tcspbrk(wild, PATHDLM);      // more path ?
        TCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], file[_MAX_FNAME], ext[_MAX_EXT];
        TCHAR re[(_MAX_FNAME + _MAX_EXT) * 2] = {0};

        // split the path
        {
            // *hack*
            // to avoid strcpy, we'll touch argument p directly
            TCHAR bc;
            if (morepath) {
                // truncate the path so that we will work with
                // the lookup directory which contains the wild cards
                bc = *morepath;
                *morepath = _T('\0');
            }
            _tsplitpath(p, drive, dir, file, ext);
            if (morepath) {
                *morepath = bc;
            }
        }
        // build file+ext which contains the wild cards
        TCHAR fnext[_MAX_FNAME + _MAX_EXT - 1];
        _tcscpy(fnext, file);
        _tcscat(fnext, ext);

        // compile the regular expression
        if (!fnrecomp(fnext, re)) {
            fputs("Illegal regular expression in ", stderr);
            _fputts(fnext, stderr);
            fputs("\n", stderr);
            exit(1);
        }

        // make search string
        TCHAR path[_MAX_PATH];
        _tmakepath(path, drive, dir, _T("*"), _T(".*"));

        // listup all the files and directories in the current lookup directory
        // and pickup matched ones
        _tfinddata_t findinfo;
        intptr_t hFind = _tfindfirst(path, &findinfo);
        if (hFind != -1) {
            do {
                if (!chkCurrentOrParentDir(findinfo.name)) {
                    if (match(re, findinfo.name)) {
                        // searched file or directory matches the pattern
                        _tmakepath(path, drive, dir, findinfo.name, _T(""));
                        if (morepath) {
                            // there's more sub directories to search.
                            if (findinfo.attrib & _A_SUBDIR) {
                                // if directory, do recursive calls
                                _tcscat(path, morepath);    // morepath begins with '/'
                                search(path, level + 1);
                            }
                        }
                        else {
                            // this directory is the last element
                            if (m_searchDir || !(findinfo.attrib & _A_SUBDIR)) {
                                FileString* name = new FileString(path);
                                if (name == NULL) {
                                    fputs("FilenameTable::search(): not enough mem\n", stderr);
                                    exit(1);
                                }
                                m_names.add(name);
                            }
                        }
                    }
                }
            } while (!_tfindnext(hFind, &findinfo));
            _findclose(hFind);
        }
    }

    if ((level == 0 && m_names.howmany() == 0) || (!wild && !_taccess(p, 0))) {
        FileString* name = new FileString(p);
        if (name == NULL) {
            fputs("FilenameTable::search() not enough mem\n", stderr);
            exit(1);
        }
        m_names.add(name);
    }

    if (level == 0 && m_names.howmany() > 0) {
        m_names.sortIt();
    }
}

};  // end of namespace


using namespace ::fnreg_implement;

///////////////////////////////////////////////////////////////////
// Global object of FilenameTable class
///////////////////////////////////////////////////////////////////

static PtrArray<FilenameTable> fnarray;


///////////////////////////////////////////////////////////////////
// Interface routine to the world
///////////////////////////////////////////////////////////////////

extern "C"
BOOL fnexpand(int* pargc, TCHAR*** pargv)
{
    assert(pargc != NULL);
    assert(pargv != NULL);

    for (int i = 1; i < *pargc; ++i) {
        FilenameTable* fn = new FilenameTable((*pargv)[i]);
        fnarray.add(fn);
    }

    int cnt = 0;

    PtrArrayIterator<FilenameTable> fnItor(fnarray);

    // first count up the argc
    for (FilenameTable* ft; ft = fnItor++; ) {
        cnt += ft->howmany();
    }
    fnItor.restart();

    // setup argc and argv
    *pargc = cnt + 1;
    TCHAR** nargv = new TCHAR*[*pargc];
    if (!nargv)
        return FALSE;
    nargv[0] = (*pargv)[0];

    // set all arguments
    for (cnt = 1, i = 0; ft = fnItor++; ++i) {
        PtrArrayIterator<FileString> itor(ft->getTable());
        FileString* fs;
        for (; fs = itor++; ++cnt) {
            const TCHAR* p = *fs;
            nargv[cnt] = (TCHAR*)p;
        }
    }
    assert(*pargc == cnt);

    *pargv = nargv;

    return TRUE;
}

#if defined(TEST) || defined(TEST0)
void print(TCHAR* p)
{
    for (; *p; ++p) {
        _puttchar(_T('['));
        if (*p >= 0x20 && *p < 0x7f) {
            _puttchar(*p);
        }
        printf(":%d] ", *p);
    }
    _puttchar('\n');
}
#endif

#ifdef TEST

extern "C"
int wmain(int argc, TCHAR** argv)
{
    if (!fnexpand(argc, argv))
        return EXIT_FAILURE;

    while (--argc) {
        _putts(*++argv);
    }
    return EXIT_SUCCESS;
}

#endif

#ifdef TEST0

extern "C"
int wmain(int argc, TCHAR** argv)
{
    TCHAR re[256];
    if (!fnrecomp(argv[1], re)) {
        puts("error");
        return EXIT_FAILURE;
    }

    print(re);

    TCHAR buf[BUFSIZ];
    while (_getts(buf)) {
        if (match(re, buf))
            puts("match");
        else
            puts("does not match.");
    }
    return EXIT_SUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cat\precomp.h ===
// precomp.h

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <tchar.h>
#include <limits.h>
#include <io.h>
#include <fcntl.h>
#include <locale.h>
#include <assert.h>

#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cat\version.cpp ===
//
// cat - conCATenate STDIN to STDOUT
//
// version file
//
//   27-May 1998 hiroyama
//
//

#include "precomp.h"
#pragma hdrstop

char version[] = "cat version 1.0 -- concatinate files or stdin\n";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cddump\cddb.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cddb.c

Abstract:

    cddb support

Environment:

    User mode only

Revision History:

    05-26-98 : Created

--*/

#include "common.h"

ULONG
CDDB_ID(
    PCDROM_TOC toc
    )

{
    ULONG i,n,j;
    ULONG cddbSum;
    ULONG totalLength;
    ULONG totalTracks;
    ULONG finalDiscId;

    i = 0;
    n = 0;
    totalTracks = toc->LastTrack - toc->FirstTrack;

    totalTracks++;  // MCI difference

    while (i < totalTracks) {

        // cddb_sum
        cddbSum = 0;
        j = (toc->TrackData[i].Address[1] * 60) +
            (toc->TrackData[i].Address[2]);
        while (j > 0) {
            cddbSum += j % 10;
            j /= 10;
        }

        n += cddbSum;
        i++;

    }

    // compute total cd length in seconds
    totalLength =
        ((toc->TrackData[totalTracks].Address[1] * 60) +
         (toc->TrackData[totalTracks].Address[2])
         ) -
        ((toc->TrackData[0].Address[1] * 60) +
         (toc->TrackData[0].Address[2])
         );

    finalDiscId = (((n % 0xff) << 24) |
                   (totalLength << 8) |
                   (totalTracks)
                   );

    return finalDiscId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cddump\read.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    read.c

Abstract:

    dump cd tracks/sectors to wav files

Environment:

    User mode only

Revision History:

    05-26-98 : Created

--*/

#include "common.h"

#define LARGEST_SECTORS_PER_READ 27 // about 64k of data



ULONG32
CddumpDumpLba(
    HANDLE CdromHandle,
    HANDLE OutHandle,
    ULONG  StartAddress,
    ULONG  EndAddress
    )
{
    RAW_READ_INFO info;    // fill in for the read request
    PUCHAR sample;
    ULONG bytesReturned;
    ULONG currentLba;
    ULONG temp;
    ULONG sectorsPerRead;

    sample = NULL;
    currentLba = StartAddress;
    sectorsPerRead = LARGEST_SECTORS_PER_READ;

    TRY {

        sample = malloc(RAW_SECTOR_SIZE*LARGEST_SECTORS_PER_READ);
        if (sample == NULL) {
            printf("DumpLba => No memory for sample\n");
            LEAVE;
        }

        DebugPrint((3, "DumpLba => Largest Sectors Per Read: %d\n",
                    LARGEST_SECTORS_PER_READ));

        while (sectorsPerRead != 0) {

            while (currentLba + sectorsPerRead <= EndAddress) {

                //
                // do a read of sectorsPerRead sectors
                //

                info.DiskOffset.QuadPart = (ULONGLONG)(currentLba*(ULONGLONG)2048);
                info.SectorCount         = sectorsPerRead;
                info.TrackMode           = CDDA;

                DebugPrint((3, "DumpLba => (%d) read from %8d to %8d:",
                            sectorsPerRead, currentLba,
                            currentLba + sectorsPerRead - 1));

                if(!DeviceIoControl(CdromHandle,
                                    IOCTL_CDROM_RAW_READ,
                                    &info,                    // pointer to inputbuffer
                                    sizeof(RAW_READ_INFO),    // sizeof inputbuffer
                                    sample,                   // pointer to outputbuffer
                                    RAW_SECTOR_SIZE * sectorsPerRead, // sizeof outputbuffer
                                    &bytesReturned,           // pointer to number of bytes returned
                                    FALSE                     // ???
                                    )
                   ) {
                    DWORD error = GetLastError();

                    if (error == ERROR_INVALID_PARAMETER) {
                        printf("ERROR_INVALID_PARAMTER for read size %x, "
                               "trying smaller transfer\n", sectorsPerRead);
                        break; // out of inner while() loop
                    } else {
                        printf("Error %d sending IOCTL_CDROM_RAW_READ for sector %d\n",
                               GetLastError(), currentLba);
                        LEAVE;
                    }
                }

                if (bytesReturned != RAW_SECTOR_SIZE * sectorsPerRead) {

                    printf("Only returned %d of %d bytes for read %d\n",
                           bytesReturned,
                           RAW_SECTOR_SIZE * sectorsPerRead,
                           currentLba
                           );
                    LEAVE;
                }

                //
                // write that buffer out
                //
                DebugPrint((3, "DumpLba => (%d) write from %8d to %8d:",
                            sectorsPerRead, currentLba,
                            currentLba + sectorsPerRead - 1));

                if (!WriteFile(OutHandle,
                               sample,
                               RAW_SECTOR_SIZE * sectorsPerRead,
                               &temp,
                               NULL)) {

                    printf("Unable to write data for read %d\n", currentLba);
                    LEAVE;
                }

                //
                // increment currentLba
                //

                currentLba += sectorsPerRead;

            } // currentLba + sectorsPerRead <= EndAddress

            sectorsPerRead /= 2;

        } // sectorsPerRead != 0

    } FINALLY {

        if (sample) {
            free(sample);
        }

    }

    return 0;
}


PCDROM_TOC
CddumpGetToc(
    HANDLE device
    )
{
    PCDROM_TOC  toc;
    ULONG bytesReturned;
    ULONG errorValue;

    toc = (PCDROM_TOC)malloc( sizeof(CDROM_TOC) );
    if ( toc == NULL ) {
        printf( "Insufficient memory\n" );
        return NULL;
    }

    if( !DeviceIoControl( device,
                          IOCTL_CDROM_READ_TOC,
                          NULL,              // pointer to inputbuffer
                          0,                 // sizeof inputbuffer
                          toc,               // pointer to outputbuffer
                          sizeof(CDROM_TOC), // sizeof outputbuffer
                          &bytesReturned,    // pointer to number of bytes returned
                          FALSE              //
                          )
        ) {
        errorValue = GetLastError();
        printf( "Error %d sending IOCTL_CDROM_READ_TOC\n", errorValue );
        free( toc );
        return NULL;
    }
    return toc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cddump\common.h ===
#ifndef __CDDUMP_COMMON_H__
#define __CDDUMP_COMMON_H__

//
// these headers are order-dependent
//

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <windows.h>
#include <devioctl.h>
#include <ntddcdrm.h>
#include <strsafe.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define STATUS_SUCCESS     ( 0 )
#define RAW_SECTOR_SIZE    ( 2352 )
#define SAMPLES_PER_SECTOR ( RAW_SECTOR_SIZE / sizeof(SAMPLE) )
#define REDBOOK_INACCURACY ( 75 )
#define TRY
#define LEAVE              goto __label;
#define FINALLY            __label:

////////////////////////////////////////////////////////////////////////////////

#define MSF_TO_LBA(Minutes,Seconds,Frames) \
    (ULONG)((60 * 75 * (Minutes) ) + (75 * (Seconds)) + ((Frames) - 150))

////////////////////////////////////////////////////////////////////////////////

typedef struct _SAMPLE {
    union {
        UCHAR  Data[4];
        struct {
            SHORT Left;
            SHORT Right;
        };
    };
    ULONG32 AsUlong32;
} SAMPLE, *PSAMPLE;



////////////////////////////////////////////////////////////////////////////////


PCDROM_TOC
CddumpGetToc(
    HANDLE device
    );

ULONG
CDDB_ID(
    PCDROM_TOC toc
    );

ULONG32
CddumpDumpLba(
    HANDLE CdromHandle,
    HANDLE OutHandle,
    ULONG  StartAddress,
    ULONG  EndAddress
    );

ULONG32
DumpWavHeader(
    HANDLE  OutFile,
    ULONG32 Samples,
    ULONG32 SamplesPerSecond,
    USHORT  Channels,
    USHORT  BitsPerSample
    );

VOID
ReadWavHeader(
    HANDLE InFile
    );


#if DBG
extern LONG DebugLevel;

#define DebugPrint(x) CddumpDebugPrint x

VOID
__cdecl
CddumpDebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );
#else
#define DebugPrint
#endif

////////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __CDDUMP_COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cddump\cddump.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cddump.c

Abstract:

    parses commands and acts

Environment:

    User mode only

Revision History:

    05-26-98 : Created

--*/

#include "common.h"

#define VERSION_MAJOR 1
#define VERSION_MINOR 0
#define VERSION_STRING "1.00"


ULONG32
TestCommand(
    HANDLE device,
    int argc,
    char *argv[]
    );

ULONG32
ListCommand(
    HANDLE device,
    int argc,
    char *argv[]
    );

ULONG32
DumpTrackCommand(
    HANDLE device,
    int argc,
    char *argv[]
    );

ULONG32
VerifyHeaderCommand(
    HANDLE device,
    int argc,
    char *argv[]
    );

ULONG32
ReadTOCCommand(
    HANDLE device,
    int argc,
    char *argv[]
    );

ULONG32
DumpSectorCommand(
    HANDLE device,
    int argc,
    char *argv[]
    );

//
// Each structure instance can have a function pointer, name, and description
//

typedef struct {
    char *Name;
    char *Description;
    ULONG32 (*Function)(HANDLE device, int argc, char *argv[]);
} COMMAND;

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

COMMAND CommandArray[] = {
    {"test", NULL, TestCommand},
    {"help", "help for all commands", ListCommand},
    {"dump", "[track] dump an audio track", DumpTrackCommand},
    {"toc", "prints the table of contents", ReadTOCCommand},
    {"header", "[file] verifies the info in the wav header", VerifyHeaderCommand},
    {"sector", "dumps a given redbook sector", DumpSectorCommand},
    {NULL, NULL, NULL}
};


int __cdecl main(int argc, char *argv[])
/*++

Routine Description:

    Parses input, showing help or calling function requested appropriately

Return Value:

     0 - success
    -1 - insufficient arguments
    -2 - error opening device (DNE?)

--*/
{
    int     i = 0;
    int     buflen;
    char   *buffer;
    HANDLE  h;
    HRESULT hr;

    if ( argc < 3 ) {
        ListCommand( NULL, argc, argv );
        return -1;
    }

    buflen = ( strlen(argv[1]) + 5 ) * sizeof(char);

    buffer = (char *)malloc( buflen );
    if (buffer == NULL) {
        fprintf(stderr, "Insufficient memory\n");
        return -1;
    }

    hr = StringCbPrintf(buffer, buflen, "\\\\.\\%s", argv[1]);
    if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
        fprintf(stderr, "Unable to format device string (too long?)\n");
        free(buffer);
        return -9;
    } else if (!SUCCEEDED(hr)) {
        fprintf(stderr, "Unable to format device string\n");
        free(buffer);
        return -9;
    }
    
    
    DebugPrint((2, "Main => Sending command %s to drive %s\n", argv[2], buffer));

    h = CreateFile( buffer,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if ( h == INVALID_HANDLE_VALUE ) {
        fprintf(stderr, "Error %d opening device %s\n", GetLastError(), buffer);
        return -2;
    }

    //
    // Iterate through the command array and find the correct function to
    // call.
    //

    while ( CommandArray[i].Name != NULL ) {

        if(strcmp(argv[2], CommandArray[i].Name) == 0) {

            (CommandArray[i].Function)(h, (argc - 2), &(argv[2]));

            break;
        }

        i++;
    }

    if ( CommandArray[i].Name == NULL ) {
        fprintf(stderr, "Unknown command %s\n", argv[2]);
    }

    CloseHandle(h);

    return 0;
}

ULONG32
VerifyHeaderCommand(
    HANDLE device,
    int argc,
    char *argv[]
    )
/*++

Routine Description:

    opens the next argument and reads the wav header, printing to stdout

Arguments:

    device - unused
    argc - the number of additional arguments.
    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    HANDLE wavHandle;

    if (argv[1] == NULL) {
        fprintf(stderr, "Need filename to attempt to parse\n");
        return -1;
    }

    TRY {

        DebugPrint((2, "VerifyHeader => Opening %s\n", argv[1]));

        wavHandle = CreateFile(argv[1],
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if (wavHandle == INVALID_HANDLE_VALUE) {
            printf("Error openingfile %x\n", GetLastError());
            LEAVE;
        }

        ReadWavHeader(wavHandle);

        CloseHandle(wavHandle);

    } FINALLY {

    }

    return 0;

}


ULONG32 TestCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Tests the command "parsing"

Arguments:

    device - a file handle to send the ioctl to
    argc - the number of additional arguments.
    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{
    int i;
    printf("Test - %d additional arguments\n", argc);

    for(i = 0; i < argc; i++) {
        printf("arg %d: %s\n", i, argv[i]);
    }



    return STATUS_SUCCESS;
}

ULONG32 ListCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:

    device - unused
    argc - unused
    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i;

    printf("\nCdDump Version " VERSION_STRING "\n");
    printf("\tUsage: cddump <drive> <command> [parameters]\n");
    printf("\tpossible commands: \n");
    for (i = 0; CommandArray[i].Name != NULL; i++) {

        if(CommandArray[i].Description != NULL) {
            printf( "\t\t%s - %s\n",
                    CommandArray[i].Name,
                    CommandArray[i].Description
                    );
        }

    }
    printf( "\n" );

    return STATUS_SUCCESS;
}

ULONG32 ReadTOCCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Reads and prints out the cdrom's table of contents

Arguments:

    device - a file handle to send the ioctl to
    argc - the number of additional arguments.  should be zero
    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    PCDROM_TOC  toc;
    PTRACK_DATA track;
    ULONG       numberOfTracks;
    ULONG       i;

    DebugPrint((2, "ReadToc => Reading Table of Contents\n"));

    toc = CddumpGetToc( device );
    if (toc == NULL) {
        return -1;
    }

    printf("First Track Number: %d\n", toc->FirstTrack);
    printf("Last Track Number: %d\n", toc->LastTrack);
    printf("CDDB ID: %08x\n", CDDB_ID(toc));



    numberOfTracks = (toc->LastTrack - toc->FirstTrack) + 1;

    // parse and print the information

    track = (PTRACK_DATA) &(toc->TrackData[0]);

    printf("Number  ADR  Control    Start        End        Bytes\n");
    printf("------  ---  -------  ----------  ----------  ----------\n");

    for(i = 0; i < numberOfTracks; i++) {

        ULONG trackStart;
        ULONG trackEnd;
        ULONG trackBytes;

        trackStart = MSF_TO_LBA(track->Address[1],
                                track->Address[2],
                                track->Address[3]);
        trackEnd = MSF_TO_LBA((track+1)->Address[1],
                              (track+1)->Address[2],
                              (track+1)->Address[3]);
        trackEnd--;

        trackBytes = (trackEnd - trackStart) * RAW_SECTOR_SIZE;

        printf("  %2d    %2d     %2d     %10d  %10d  %8dk \n",
               track->TrackNumber,
               track->Adr,
               track->Control,
               trackStart,
               trackEnd,
               trackBytes / 1000
               );


        track++;
    }
    return STATUS_SUCCESS;
}



ULONG32 DumpTrackCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Reads a section of disc in raw read mode

Arguments:

    device - a file handle to send the ioctl to

    argc - the number of additional arguments.

    argv[1] - the starting LBA.  Starts at zero if this is not here
    argv[2] - the ending LBA.  if not specified, equal to start

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    PCDROM_TOC toc;
    HANDLE  outputFile = (HANDLE)-1;
    HRESULT hr;
    ULONG   track;
    ULONG   endingSector;
    ULONG   numberOfSectors;     // actually useful data
    ULONG   numberOfReads;
    ULONG   status;

    ULONG   startingSector;
    LONG   i;

    ULONG   cddbId = 0;

    UCHAR   fileName[1024]; // randomly chosen size.

    PSAMPLE sample;

    toc = NULL;
    sample = NULL;

    TRY {
        track = atoi(argv[1]);
        if (track==0) {
            printf( "Cannot read track 0.\n" );
            status = -1;
            LEAVE;
        }

        toc = CddumpGetToc( device );
        if (toc==NULL) {
            status = -1;
            LEAVE;
        }

        cddbId = CDDB_ID(toc);
        hr = StringCbPrintf(fileName,
                            sizeof(fileName),
                            "%08x - Track %02d.wav",
                            cddbId, track);
        if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
            fprintf(stderr, "Unable to format device string (too long?)\n");
            status = -1;
            LEAVE;
        } else if (!SUCCEEDED(hr)) {
            fprintf(stderr, "Unable to format device string\n");
            status = -1;
            LEAVE;
        }

        DebugPrint((2, "DumpTrack => output filename: %s\n", fileName));

        //
        // account for zero-index
        //

        startingSector = MSF_TO_LBA(toc->TrackData[track-1].Address[1],
                                    toc->TrackData[track-1].Address[2],
                                    toc->TrackData[track-1].Address[3]
                                    );
        endingSector   = MSF_TO_LBA(toc->TrackData[track].Address[1],
                                    toc->TrackData[track].Address[2],
                                    toc->TrackData[track].Address[3]
                                    );
        endingSector--; // no overlap

        numberOfSectors = endingSector - startingSector;

        DebugPrint((3, "DumpTrack => old sectors: start %8d  end %8d  count %d\n",
                    startingSector, endingSector, numberOfSectors));


        sample = (PSAMPLE)malloc( RAW_SECTOR_SIZE );
        if ( sample == NULL ) {
            printf("Insufficient resources (sample)\n");
            status = -1;
            LEAVE;
        }

        //
        // first find a fully zero'd sample -- that will be
        // the _real_ start address of the track after adjusting
        // for redbook inaccuracies.
        //

        for (i=REDBOOK_INACCURACY; i > -(REDBOOK_INACCURACY); i--) {

            RAW_READ_INFO info;
            ULONG bytesReturned;
            ULONG j;
            BOOLEAN foundZeroSector = FALSE;

            if ((LONG)startingSector + i > 0 ) {  // only read positive

                info.DiskOffset.QuadPart = (ULONGLONG)((startingSector + i)*(ULONGLONG)2048);
                info.SectorCount         = 1;
                info.TrackMode           = CDDA;

                if(DeviceIoControl(device,
                                   IOCTL_CDROM_RAW_READ,
                                   &info,                 // pointer to inputbuffer
                                   sizeof(RAW_READ_INFO), // sizeof inputbuffer
                                   sample,                // pointer to outputbuffer
                                   RAW_SECTOR_SIZE,       // sizeof outputbuffer
                                   &bytesReturned,        // pointer to number of bytes returned
                                   FALSE)) {

                    //
                    // read succeeded, see if all zero'd
                    //

                    assert(bytesReturned == RAW_SECTOR_SIZE);

                    foundZeroSector = TRUE;
                    for (j=0;j<SAMPLES_PER_SECTOR;j++) {
                        if (sample[j].AsUlong32 != 0) foundZeroSector = FALSE;
                    }

                }

                if (foundZeroSector) {
                    DebugPrint((1, "DumpTrack => New starting sector is "
                                "offset by %d\n", i));
                    startingSector += i; // change to real starting sector
                    break;               // stop looping.
                }
            } // end of positive check
        } // end of loop

        //
        // then find a fully zero'd sample at the end -- that will
        // be the _real_ end address of the track after adjusting
        // for redbook inaccuracies.
        //

        for (i=-(REDBOOK_INACCURACY); i < REDBOOK_INACCURACY; i++) {

            RAW_READ_INFO info;
            ULONG bytesReturned;
            ULONG j;
            BOOLEAN foundZeroSector = FALSE;

            if ((LONG)endingSector + i > 0 ) {  // only read positive

                info.DiskOffset.QuadPart = (ULONGLONG)((endingSector + i)*(ULONGLONG)2048);
                info.SectorCount         = 1;
                info.TrackMode           = CDDA;

                if(DeviceIoControl(device,
                                   IOCTL_CDROM_RAW_READ,
                                   &info,                 // pointer to inputbuffer
                                   sizeof(RAW_READ_INFO), // sizeof inputbuffer
                                   sample,                // pointer to outputbuffer
                                   RAW_SECTOR_SIZE,       // sizeof outputbuffer
                                   &bytesReturned,        // pointer to number of bytes returned
                                   FALSE)) {

                    //
                    // read succeeded, see if all zero'd
                    //

                    assert(bytesReturned == RAW_SECTOR_SIZE);

                    foundZeroSector = TRUE;
                    for (j=0;j<SAMPLES_PER_SECTOR;j++) {
                        if (sample[j].AsUlong32 != 0) foundZeroSector = FALSE;
                    }

                }

                if (foundZeroSector) {
                    DebugPrint((2, "DumpTrack => New starting sector is "
                                "offset by %d\n", i));
                    endingSector += i; // change to real starting sector
                    break;               // stop looping.
                }
            } // end of positive check
        } // end of loop

        numberOfSectors = endingSector - startingSector;

        DebugPrint((2, "DumpTrack => new sectors: start %8d  end %8d  count %d\n",
                    startingSector, endingSector, numberOfSectors));

        //
        // a bit of debugging info...
        //

        DebugPrint((2, "DumpTrack => Reading %d sectors starting at sector %d\n",
                    numberOfSectors, startingSector));

        //
        // create the file
        //
        outputFile = CreateFile(fileName,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                (HANDLE)NULL);

        if (outputFile == INVALID_HANDLE_VALUE) {
            printf( "Cannot open output file.\n" );
            status = -1;
            LEAVE;
        }

        //
        // dump the wav header info
        //
        DumpWavHeader(outputFile,
                      numberOfSectors * SAMPLES_PER_SECTOR,
                      44100,  // 44.1KHz sound
                      2,      // stereo sound
                      16      // 16-bit sound
                      );
        CddumpDumpLba(device,
                      outputFile,
                      startingSector,
                      endingSector
                      );

        DebugPrint((2, "DumpTrack => Done!\n"));

        CloseHandle(outputFile);

    } FINALLY {

        free(toc);
        free(sample);

    }

    return STATUS_SUCCESS;
}


ULONG32 DumpSectorCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Reads a section of disc in raw read mode

Arguments:

    device - a file handle to send the ioctl to

    argc - the number of additional arguments.

    argv[1] - the starting LBA.  Starts at zero if this is not here
    argv[2] - the ending LBA.  if not specified, equal to start

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    HRESULT hr;
    ULONG   sector;
    ULONG   status;    

    PSAMPLE sample;

    sample = NULL;

    TRY {
        sector = atoi(argv[1]);
        printf( "Reading sector %x.\n", sector );

        sample = (PSAMPLE)malloc( RAW_SECTOR_SIZE );
        if ( sample == NULL ) {
            printf("Insufficient resources (sample)\n");
            status = -1;
            LEAVE;
        }

        {
            RAW_READ_INFO info;
            ULONG bytesReturned;
            BOOLEAN foundZeroSector = FALSE;

            info.DiskOffset.QuadPart = (ULONGLONG)((sector)*(ULONGLONG)2048);
            info.SectorCount         = 1;
            info.TrackMode           = CDDA;

            if(DeviceIoControl(device,
                               IOCTL_CDROM_RAW_READ,
                               &info,                 // pointer to inputbuffer
                               sizeof(RAW_READ_INFO), // sizeof inputbuffer
                               sample,                // pointer to outputbuffer
                               RAW_SECTOR_SIZE,       // sizeof outputbuffer
                               &bytesReturned,        // pointer to number of bytes returned
                               FALSE)) {

                //
                // read succeeded, see if all zero'd
                //

                assert(bytesReturned == RAW_SECTOR_SIZE);

            }
            else
            {
                printf("Error: %x\n", GetLastError());

            }


        }

    } FINALLY {

        free(sample);

    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cddump\debug.c ===
/*++
Copyright (c) 1998  Microsoft Corporation

Module Name:

    debug.c

Abstract:

Author:

Environment:

Notes:

Revision History:

--*/

#include <stdio.h>     // vsprintf()
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <strsafe.h>

#define DBGHDR    "[cddump] "
#define DBGHDRLEN (strlen( DBGHDR ))



#if DBG
//
// Debug level global variable
//
//  0  = Extreme errors only
//  1  = errors, major events
//  2  = Standard debug level
//  3  = Major code branches
//  4+ = Step through code

LONG DebugLevel         = 0;

VOID
__cdecl
CddumpDebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for RedBook driver

Arguments:

    Debug print level between 0 and x, with x being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    //
    // allow negative numbers
    //

    if ((DebugPrintLevel < 0) || (DebugPrintLevel <= DebugLevel)) {
        HRESULT hr;
        char buffer[200]; // Potential overflow

        //
        // single print so won't swap, obscuring message
        //
        
        va_start( ap, DebugMessage );
        RtlCopyMemory( buffer, DBGHDR, DBGHDRLEN );
        
        hr = StringCbVPrintfA(buffer+DBGHDRLEN,
                              sizeof(buffer) - DBGHDRLEN,
                              DebugMessage,
                              ap);
        if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER || SUCCEEDED(hr)) {
            fprintf(stderr, buffer);            
        }
        va_end(ap);

    }
}


#else

// nothing

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cddump\wav.h ===
#ifndef __WAV_H__
#define __WAV_H__

#ifdef __cplusplus
extern "C" {
#endif


#define ChunkIdRiff   'FFIR'
#define ChunkIdFormat ' tmf'
#define ChunkIdData   'atad'

#define RiffTypeWav   'EVAW'

#define FormatTagUncompressed 1

typedef struct _WAV_FORMAT_CHUNK {
    ULONG32   ChunkId;
    ULONG32   ChunkSize;
    SHORT     FormatTag;
    USHORT    Channels;
    ULONG32   SamplesPerSec;
    ULONG32   AvgBytesPerSec;
    USHORT    BlockAlign;
    USHORT    BitsPerSample;
} WAV_FORMAT_CHUNK, *PWAV_FORMAT_CHUNK;

typedef struct _WAV_DATA_CHUNK {
    ULONG32   ChunkId;
    ULONG32   ChunkSize;
    // data is appended
} WAV_DATA_CHUNK, *PWAV_DATA_CHUNK;

typedef struct _WAV_HEADER_CHUNK {
    ULONG32          ChunkId;
    ULONG32          ChunkSize;
    ULONG32          RiffType;
    WAV_FORMAT_CHUNK Format;
    WAV_DATA_CHUNK   Data;
} WAV_HEADER_CHUNK, *PWAV_HEADER_CHUNK;

#ifdef __cplusplus
}
#endif


#endif // __WAV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\cddump\wav.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cddump.c

Abstract:

    dump cd tracks to wav files

Environment:

    User mode only

Revision History:

    05-26-98 : Created

--*/

#include <windows.h>
#include <stdio.h>
#include <strsafe.h>
#include "wav.h"

ULONG32
DumpWavHeader(
    HANDLE  OutFile,
    ULONG32 Samples,
    ULONG32 SamplesPerSecond,
    USHORT  Channels,
    USHORT  BitsPerSample
    )
{
    WAV_HEADER_CHUNK Header;
    ULONG32 temp;

    Header.ChunkId               = ChunkIdRiff;
    Header.RiffType              = RiffTypeWav;
    Header.Format.ChunkId        = ChunkIdFormat;
    Header.Format.ChunkSize      = sizeof(WAV_FORMAT_CHUNK) - (sizeof(ULONG)*2);
    Header.Format.FormatTag      = FormatTagUncompressed;

    Header.Format.BitsPerSample  = BitsPerSample;
    temp = (BitsPerSample+7)/8;  // temp = bytes per sample rounded up

    Header.Format.Channels       = Channels;

    temp *= Channels;            // temp = bytes for all channels

    if (temp > (USHORT)-1) {
        fprintf(stderr, "Bytes for all channels exceeds MAXUSHORT, not a valid "
                "option for WAV file\n");
        return -1;
    }

    Header.Format.BlockAlign     = (USHORT)temp;
    Header.Format.SamplesPerSec  = SamplesPerSecond;
    Header.Format.AvgBytesPerSec = temp * SamplesPerSecond;

    temp *= Samples;             // temp = number of total bytes
    temp *= 2;                   // unknown why this is needed.
    Header.Data.ChunkSize        = temp;
    Header.Data.ChunkId          = ChunkIdData;

    Header.ChunkSize = temp + sizeof(WAV_HEADER_CHUNK); // 54

    if (!WriteFile( OutFile, &Header, sizeof(Header), &temp, NULL ) ) {
        fprintf(stderr, "Unable to write header\n" );
        return -1;
    }
    return 0;

}

VOID
ReadWavHeader(
    HANDLE InFile
    )
{
    WAV_HEADER_CHUNK Header;
    ULONG temp;

    if (!ReadFile(InFile, &Header, sizeof(Header), &temp, NULL) ||
        temp != sizeof(Header)
        ) {

        fprintf(stderr, "Unable to read header %x\n", GetLastError());
        return;
    }

    if (Header.ChunkId != ChunkIdRiff) {
        printf("ChunkId is not RIFF (%x)\n", Header.ChunkId);
        return;
    }

    if (Header.RiffType != RiffTypeWav) {
        printf("RiffType is not RiffTypeWav (%x)\n", Header.RiffType);
        return;
    }

    if (Header.Format.ChunkId != ChunkIdFormat) {
        printf("Format.ChunkId is not ChunkIdFormat (%x)\n",
               Header.Format.ChunkId);
        return;
    }

    if (Header.Format.ChunkSize != sizeof(WAV_FORMAT_CHUNK) - (2*sizeof(ULONG))) {
        printf("Format.ChunkSize is not %x (%x)\n",
               sizeof(WAV_FORMAT_CHUNK) - (2*sizeof(ULONG)),
               Header.Format.ChunkSize);
        return;
    }

    if (Header.Format.FormatTag != FormatTagUncompressed) {
        printf("Format. is not Uncompressed (%x)\n", Header.Format.FormatTag);
        return;
    }


    if (Header.Data.ChunkId != ChunkIdData) {
        printf("Data.ChunkId is not ChunkIdData (%x)\n",
               Header.Data.ChunkId);
        return;
    }

    printf("Uncompressed RIFF/Wav File\n");
    printf("\t%2d bits per sample\n", Header.Format.BitsPerSample);
    printf("\t%2d channels\n", Header.Format.Channels);
    printf("\t%2d samples per second\n", Header.Format.SamplesPerSec);
    printf("\t%2d average bytes per second\n", Header.Format.AvgBytesPerSec);
    printf("Total data available to player: %d\n", Header.Data.ChunkSize);

    temp = Header.Data.ChunkSize / Header.Format.AvgBytesPerSec;

    printf("\t%d seconds of audio\n",
           temp
           );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checkrel\newcheck.c ===
#ifndef COMPILED_FORDOS
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#include <windows.h>
#include <dos.h>
#include <stdio.h>
#include <string.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <malloc.h>
#include <errno.h>
#include <ctype.h>
#include <signal.h>
#include <string.h>
#include <time.h>
#include <io.h>
#include <conio.h>
#include <sys\types.h>
#include <sys\stat.h>

#ifdef COMPILED_FORDOS
#define MAX_PATH 256
#endif

#define READ_BUFFER_SIZE (8192*sizeof(DWORD))
#define CHECK_NAME "\\chkfile.chk"
extern BOOL fUsage;
extern BOOL fGenerateCheck;
extern LPSTR RootOfTree;
char RootBuffer[MAX_PATH];
extern BOOL fVerbose;
LPSTR CheckFileName;
char OutputLine[512];
DWORD ReadBuffer[READ_BUFFER_SIZE/sizeof(DWORD)];

WORD
CheckSum(
    DWORD ParitialSum,
    LPWORD Source,
    DWORD Length
    );


typedef struct _FINDBUF {
    char reserved[21];
    char attrib;
    unsigned short wr_time;
    unsigned short wr_data;
    long size;
    char name[13];
} FINDBUF, *PFINDBUF;

DWORD
PortFindFirstFile(
    LPSTR FindPattern,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    );
BOOL
PortFindNextFile(
    DWORD FindHandle,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    );

VOID
PortFindClose(
    DWORD FindHandle
    );

VOID
GenerateCheckFile( VOID );

VOID
ValidateCheckFile( VOID );

BOOL
ProcessParameters(
    int argc,
    LPSTR argv[]
    );

FILE *GlobalCheckFile;

FILE *
OpenCheckFile( VOID );

BOOL
ComputeEntry(
    FILE *CheckFile,
    LPSTR FileName,
    DWORD FileLength
    );

DWORD
CheckSumFile(
    FILE *InputHandle,
    LPSTR PathName,
    DWORD FileLength,
    LPSTR FileName
    );

BOOL fGenerateCheck = FALSE;
LPSTR RootOfTree = "C:\\NT";
BOOL fVerbose = FALSE;
BOOL fUsage = FALSE;

#ifndef COMPILED_FORDOS
int ThreadCount;
HANDLE ThreadListMutex;
HANDLE ThreadListSemaphore;
LIST_ENTRY WorkList;

#define ITEM_TYPE_EXIT      1
#define ITEM_TYPE_VALIDATE  2
#define ITEM_TYPE_GENERATE  3

typedef struct _WORK_ITEM {
    LIST_ENTRY ItemLinks;
    DWORD ItemType;
    PVOID Base;
    DWORD FileLength;
    DWORD ActualSum;
    char FileName[MAX_PATH];
} WORK_ITEM, *PWORK_ITEM;


PHANDLE ThreadHandles;
CRITICAL_SECTION GenerateCrit;

VOID
WriteCheckSumEntry(
    FileName,
    Sum,
    FileLength
    )
{
    char lOutputLine[512];
    int LineLength;

    LineLength = sprintf(lOutputLine,"%s %x %x\n",FileName,Sum,FileLength);
    if ( fVerbose ) {
        fprintf(stdout,"Id %d %s",GetCurrentThreadId(),lOutputLine);
        }
    EnterCriticalSection(&GenerateCrit);
    fwrite(lOutputLine,1,LineLength,GlobalCheckFile);
    LeaveCriticalSection(&GenerateCrit);
}


DWORD
WorkerThread(
    LPVOID WhoCares
    )
{
    HANDLE Objects[2];
    PWORK_ITEM Item;
    PLIST_ENTRY Entry;
    int FilesProcessed = 0;

    Objects[0] = ThreadListMutex;
    Objects[1] = ThreadListSemaphore;

    SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_ABOVE_NORMAL);

    //
    // Wait for and entry on the list, and exclusive ownership of the listhead
    //

    while(TRUE) {
        WaitForMultipleObjects(2,Objects,TRUE,INFINITE);


        Entry = RemoveHeadList(&WorkList);
        Item = (PWORK_ITEM)(CONTAINING_RECORD(Entry,WORK_ITEM,ItemLinks));

        ReleaseMutex(ThreadListMutex);

        switch ( Item->ItemType ) {
            case ITEM_TYPE_VALIDATE :
                FilesProcessed++;
                break;

            case ITEM_TYPE_GENERATE :
                FilesProcessed++;
                    {
                        DWORD Sum;
                        Sum = (DWORD)CheckSum(0,Item->Base,(Item->FileLength+1) >> 1);
                        UnmapViewOfFile(Item->Base);
                        WriteCheckSumEntry(Item->FileName,Sum,Item->FileLength);
                        break;
                    }
                break;

            case ITEM_TYPE_EXIT :
            default:
                fprintf(stdout,"Id %d Processed %d Files\n",GetCurrentThreadId(),FilesProcessed);
                ExitThread(1);

            }
            LocalFree(Item);
        }
    return 0;
}




#endif

INT __cdecl
main( argc, argv )
int argc;
LPSTR argv[];
{

    if (!ProcessParameters( argc, argv )) {
        fUsage = TRUE;
        }

    if (fUsage) {
        fprintf( stderr, "usage: checkrel [-?] display this message\n" );
        fprintf( stderr, "                [-r pathname] supply release root\n" );
        fprintf( stderr, "                [-v] verbose output\n" );
        fprintf( stderr, "                [-g] generate check file\n" );
        fprintf( stderr, "                [-t n] use n threads to process the data\n" );
        }
    else {
        //
        // if we are generating a check file, then generate it,
        // otherwise just check the release
        //

        if ( fGenerateCheck ) {
            GenerateCheckFile();
#ifndef COMPILED_FORDOS
            if ( ThreadCount ) {
                int i;
                PWORK_ITEM Item;
                for(i=0;i<ThreadCount;i++){
                    Item = LocalAlloc(LMEM_ZEROINIT,sizeof(*Item));
                    Item->ItemType = ITEM_TYPE_EXIT;
                    WaitForSingleObject(ThreadListMutex,INFINITE);
                    InsertTailList(&WorkList,&Item->ItemLinks);
                    ReleaseSemaphore(ThreadListSemaphore,1,NULL);
                    ReleaseMutex(ThreadListMutex);
                    }
                WaitForMultipleObjects(ThreadCount,ThreadHandles,TRUE,INFINITE);
                }
#endif

            }
        else {
            ValidateCheckFile();
            }
        }
    return( 0 );
}


BOOL
ProcessParameters(
    int argc,
    LPSTR argv[]
    )
{
    char c, *p;
    BOOL Result;
    char *WhoCares;
    int i;

    Result = TRUE;
    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
                switch (toupper( c )) {
            case '?':
                fUsage = TRUE;
                break;

            case 'R': {

                argc--;
                argv++;

                RootOfTree = *argv;
                GetFullPathName(RootOfTree,sizeof(RootBuffer),RootBuffer,&WhoCares);
                RootOfTree = RootBuffer;
                break;
            }

            case 'G':
                fGenerateCheck = TRUE;
                break;

            case 'V':
                fVerbose = TRUE;
                break;

#ifndef COMPILED_FORDOS
            case 'T': {
                DWORD ThreadId;

                argc--;
                argv++;

                ThreadCount = atoi(*argv);
                InitializeListHead(&WorkList);
                ThreadListMutex = CreateMutex(NULL,FALSE,NULL);
                ThreadListSemaphore = CreateSemaphore(NULL,0,0x70000000,NULL);
                InitializeCriticalSection(&GenerateCrit);
                if ( ThreadListMutex && ThreadListSemaphore ) {
                    ThreadHandles = LocalAlloc(LMEM_ZEROINIT,sizeof(HANDLE)*ThreadCount);
                    if ( ThreadHandles ) {
                        for(i=0;i<ThreadCount;i++) {
                            ThreadHandles[i] = CreateThread(
                                                    NULL,
                                                    0,
                                                    WorkerThread,
                                                    NULL,
                                                    0,
                                                    &ThreadId
                                                    );
                            if ( !ThreadHandles[i] ) {
                                ThreadCount = 0;
                                break;
                                }
                            }
                        }
                    else {
                        ThreadCount = 0;
                        }
                    }
                else {
                    ThreadCount = 0;
                    }

                break;
            }
#endif

            default:
                fprintf( stderr, "checkrel: Invalid switch - /%c\n", c );
                Result = FALSE;
                break;
                }
            }
        }
    return( Result );
}

VOID
WalkTree(
    FILE *CheckFile,
    LPSTR SubDir
    )
{
    char NextSubDir[MAX_PATH];
    DWORD FindHandle;
    char FindPattern[MAX_PATH];
    char FindName[MAX_PATH];
    DWORD FindSize;
    BOOL b;
    BOOL IsDir;

    //
    // recursively walk the system searching all files
    //

    //
    // build the find pattern
    //

    strcpy(FindPattern,RootOfTree);
    if ( SubDir ) {
        strcat(FindPattern,"\\");
        strcat(FindPattern,SubDir);
        }
    strcat(FindPattern,"\\*.*");

    if ( fVerbose ) {
        fprintf(stdout,"WalkTree %s \n",FindPattern);
        }

    FindHandle = PortFindFirstFile(FindPattern,FindName,&IsDir,&FindSize);
    if ( FindHandle == -1 ) {
        fprintf(stderr,"checkrel: FindFirst(%s) failed %d\n",FindPattern,errno);
        return;
        }

    b = TRUE;
    while(b) {

        _strlwr(FindName);

        //
        // recurse if we are at a directory
        //

        if ( IsDir ) {

            //
            // if name is . or .., skip to findnext
            //

            if ( !strcmp(FindName,".") || !strcmp(FindName,"..") ) {
                goto findnext;
                }

            //
            // if name is w32x86 or w32mips, skip to findnext
            //

            if ( !strcmp(FindName,"w32mips") || !strcmp(FindName,"w32x86") ) {
                goto findnext;
                }


            NextSubDir[0] = '\0';
            if ( SubDir ) {
                strcat(NextSubDir,SubDir);
                strcat(NextSubDir,"\\");
                }
            strcat(NextSubDir,FindName);
            WalkTree(CheckFile,NextSubDir);
            }
        else {
            NextSubDir[0] = '\0';
            if ( SubDir ) {
                strcat(NextSubDir,SubDir);
                strcat(NextSubDir,"\\");
                }
            strcat(NextSubDir,FindName);
            b = ComputeEntry(CheckFile,NextSubDir,FindSize);
            }

        if ( !b ) {
            fprintf(stderr,"checkrel: ComputeEntry faild\n");
            return;
            }
findnext:
        b = PortFindNextFile(FindHandle,FindName,&IsDir,&FindSize);
        }
    PortFindClose(FindHandle);
}


VOID
GenerateCheckFile( VOID )
{
    FILE *CheckFile;

    CheckFile = OpenCheckFile();
    if ( !CheckFile ) {
        return;
        }

    WalkTree(CheckFile,NULL);
}

VOID
ValidateCheckFile( VOID )
{
    FILE *CheckFile;
    DWORD CheckSize, CheckSum;
    char CheckName[MAX_PATH];
    DWORD n;
    LPSTR PathName;
    FILE *FileHandle;
    DWORD ActualSize;
    DWORD ActualSum;

    CheckFile = OpenCheckFile();
    if ( !CheckFile ) {
        return;
        }


    PathName = malloc(strlen(RootOfTree)+MAX_PATH+1);

    if ( !PathName ) {
        fprintf(stderr,"checkrel: memory allocation for %d bytes failed\n",strlen(RootOfTree)+MAX_PATH+1);
        return;
        }

    n = fscanf(CheckFile,"%s %x %x",CheckName,&CheckSum,&CheckSize);
    while ( n != EOF ) {
        if ( n != 3 ) {
            fprintf(stderr,"checkrel: error in format\n");
            return;
            }

        //
        // Now form the file and do the checksum compare
        //

        strcpy(PathName,RootOfTree);
        strcat(PathName,"\\");
        strcat(PathName,CheckName);

        FileHandle = fopen(PathName,"rb");
        if ( !FileHandle ) {
            fprintf(stderr,"checkrel: failed to open file %s %d\n",PathName,errno);
            }
        else {
            ActualSize = _filelength(_fileno(FileHandle));

            if ( ActualSize == 0xffffffff ) {
                fprintf(stderr,"checkrel: unable to get file size for file %s %d\n",PathName,errno);
                fclose(FileHandle);
                }
            else {
                if ( ActualSize != CheckSize ) {
                    fprintf(stderr,"checkrel: FileSizes Differ for %s Actual %x vs. %x\n",PathName,ActualSize,CheckSize);
                    }
                ActualSum = CheckSumFile(FileHandle,PathName,ActualSize,NULL);
                if ( ActualSum ) {
                    if ( ActualSum != CheckSum ) {
                        fprintf(stderr,"checkrel: CheckSums Differ for %s Actual %x vs. %x\n",PathName,ActualSum,CheckSum);
                        }
                    }
                if ( fVerbose ) {
                    fprintf(stdout,"%s Sum(%x vs %x) Size(%x vs %x)\n",PathName,ActualSum,CheckSum,ActualSize,CheckSize);
                    }
                }
            }
        n = fscanf(CheckFile,"%s %x %x",CheckName,&CheckSum,&CheckSize);
        }
}

FILE *
OpenCheckFile()
{
    FILE *CheckFile;

    GlobalCheckFile = (FILE *)-1;
    CheckFileName = malloc(strlen(RootOfTree)+strlen(CHECK_NAME)+1);
    if ( !CheckFileName ) {
        return (FILE *)-1;
        }

    strcpy(CheckFileName,RootOfTree);
    strcat(CheckFileName,CHECK_NAME);

    if ( fVerbose ) {
        fprintf(stdout,"checkrel: check name %s\n",CheckFileName);
        }

    CheckFile = fopen(CheckFileName,fGenerateCheck ? "wt" : "rt");

    if ( !CheckFile ) {
        fprintf(stderr,"checkrel: open %s failed %d\n",CheckFileName,errno);
        }
    GlobalCheckFile = CheckFile;
    return CheckFile;
}


BOOL
ComputeEntry(
    FILE *CheckFile,
    LPSTR FileName,
    DWORD FileLength
    )
{
    char PathName[MAX_PATH];
    DWORD CheckSum;
    DWORD LineLength;

    strcpy(PathName,RootOfTree);
    strcat(PathName,"\\");
    strcat(PathName,FileName);

    CheckSum = CheckSumFile(NULL,PathName,FileLength,FileName);

    if ( CheckSum ) {
        LineLength = sprintf(OutputLine,"%s %x %x\n",FileName,CheckSum,FileLength);
        if ( fVerbose ) {
            fprintf(stdout,"%s",OutputLine);
            }
        fwrite(OutputLine,1,LineLength,CheckFile);
        }
    return TRUE;
}

DWORD
CheckSumFile(
    FILE *InputHandle,
    LPSTR PathName,
    DWORD FileLength,
    LPSTR FileName
    )

{

    FILE *FileHandle;
    DWORD Sum;
    signed char *pb;
    LPDWORD pul;
    PVOID Base;
    DWORD cbread, cbreadtotal;

    if ( InputHandle ){
        FileHandle = InputHandle;
        }
    else {
        FileHandle = fopen(PathName,"rb");
        if ( !FileHandle ) {
            fprintf(stderr,"checkrel: failed to open file %s %d\n",PathName,errno);
            return 0;
            }

#ifndef COMPILED_FORDOS
        if ( ThreadCount ) {
            PWORK_ITEM Item;
            HANDLE Win32FileHandle;
            HANDLE MappingHandle;

            //
            // Queue the generate request to a worker thread
            //

            Item = LocalAlloc(LMEM_ZEROINIT,sizeof(*Item));

            if (!Item) {
                goto bail;
                }
            Win32FileHandle = (HANDLE)_get_osfhandle(_fileno(FileHandle));
            MappingHandle = CreateFileMapping(
                                Win32FileHandle,
                                NULL,
                                PAGE_READONLY,
                                0,
                                0,
                                NULL
                                );
            if ( !MappingHandle ) {
                fprintf(stderr,"checkrel: failed to map file %s %d\n",PathName,GetLastError());
                fclose(FileHandle);
                return 0;
                }
            Base = MapViewOfFile(
                        MappingHandle,
                        FILE_MAP_READ,
                        0,
                        0,
                        0
                        );
            CloseHandle(MappingHandle);
            if ( !Base ) {
                fprintf(stderr,"checkrel: failed to map view of file %s %d\n",PathName,GetLastError());
                fclose(FileHandle);
                return 0;
                }
            fclose(FileHandle);


            Item->ItemType = ITEM_TYPE_GENERATE;
            Item->Base = Base;
            Item->FileLength = FileLength;
            strcpy(&Item->FileName[0],FileName);
            WaitForSingleObject(ThreadListMutex,INFINITE);
            InsertTailList(&WorkList,&Item->ItemLinks);
            ReleaseSemaphore(ThreadListSemaphore,1,NULL);
            ReleaseMutex(ThreadListMutex);
            return 0;
            }
bail:;
#endif
        }
#ifdef COMPILED_FORDOS
    Base = ReadBuffer;

    //
    // Read the file in large blocks and compute the checksum.
    //

    Sum = 0;
    cbreadtotal = 0;
    while (cbread = fread(ReadBuffer, 1, READ_BUFFER_SIZE, FileHandle)) {
        cbreadtotal += cbread;
        pb = Base;

        //
        // Make sure the last byte of the buffer is zero in case a
        // partial buffer was read with an odd number of bytes in the
        // buffer.
        //

        ((PBYTE)ReadBuffer)[cbread] = 0;

        //
        // Compute the checksum using the same algorithm used for
        // tcp/ip network packets. This is a word checksum with all
        // carries folded back into the sum.
        //

        Sum = (DWORD)CheckSum(Sum, (LPWORD)ReadBuffer, (cbread + 1) >> 1);
        }
#else
    {
        HANDLE Win32FileHandle;
        HANDLE MappingHandle;

        Win32FileHandle = (HANDLE)_get_osfhandle(_fileno(FileHandle));
        MappingHandle = CreateFileMapping(
                            Win32FileHandle,
                            NULL,
                            PAGE_READONLY,
                            0,
                            0,
                            NULL
                            );
        if ( !MappingHandle ) {
            fprintf(stderr,"checkrel: failed to map file %s %d\n",PathName,GetLastError());
            fclose(FileHandle);
            return 0;
            }
        Base = MapViewOfFile(
                    MappingHandle,
                    FILE_MAP_READ,
                    0,
                    0,
                    0
                    );
        CloseHandle(MappingHandle);
        if ( !Base ) {
            fprintf(stderr,"checkrel: failed to map view of file %s %d\n",PathName,GetLastError());
            fclose(FileHandle);
            return 0;
            }
        Sum = (DWORD)CheckSum(0,Base,(FileLength+1) >> 1);
        UnmapViewOfFile(Base);
    }
#endif
    fclose(FileHandle);

    if (Sum == 0) {
        Sum = FileLength;
        }

    return(Sum);
}



#ifndef COMPILED_FORDOS
DWORD
PortFindFirstFile(
    LPSTR FindPattern,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    )
{
    HANDLE FindHandle;
    WIN32_FIND_DATA FindFileData;

    FindHandle = FindFirstFile(FindPattern,&FindFileData);
    if ( FindHandle != INVALID_HANDLE_VALUE ) {
        strcpy(FindName,FindFileData.cFileName);
        *FindSize = FindFileData.nFileSizeLow;
        *IsDir = FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
        }
    return (DWORD)FindHandle;
}


BOOL
PortFindNextFile(
    DWORD FindHandle,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    )
{
    BOOL b;
    WIN32_FIND_DATA FindFileData;

    b = FindNextFile((HANDLE)FindHandle,&FindFileData);
    if ( b ) {
        strcpy(FindName,FindFileData.cFileName);
        *FindSize = FindFileData.nFileSizeLow;
        *IsDir = FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
        }
    return b;
}

VOID
PortFindClose(
    DWORD FindHandle
    )
{
    FindClose((HANDLE)FindHandle);
}
#else
DWORD
PortFindFirstFile(
    LPSTR FindPattern,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    )
{
    struct find_t *FindHandle;
    int error;

    FindHandle = malloc(sizeof(*FindHandle));

    error = _dos_findfirst(FindPattern,_A_RDONLY | _A_NORMAL | _A_DIR, FindHandle);
    if ( error ) {
    	free(FindHandle);
    	return -1;
    	}
    strcpy(FindName,FindHandle->name);
    *FindSize = FindHandle->size;
    *IsDir = FindHandle->attrib & 0x10;
    return (DWORD)FindHandle;
}


BOOL
PortFindNextFile(
    DWORD FindHandle,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    )
{
    BOOL b;
    int error;
    struct find_t *xxFindHandle;

    xxFindHandle = (struct find_t *)FindHandle;
    error = _dos_findnext( xxFindHandle );
    if ( error ) {
    	return FALSE;
    	}
    strcpy(FindName,xxFindHandle->name);
    *FindSize = xxFindHandle->size;
    *IsDir = FindHandle->attrib & 0x10;
    return TRUE;
}

VOID
PortFindClose(
    DWORD FindHandle
    )
{
    free((int *)FindHandle);
}

WORD
CheckSum(
    DWORD PartialSum,
    LPWORD Source,
    DWORD Length
    )

{

	register unsigned long t = PartialSum;
	register unsigned long r;

	while(Length--) {
		t += *Source++;
   }

	while (r = (t & 0xFFFF0000) {
		t &= 0x0000FFFF;
		t += (r >> 16);
	}

	return t;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\delayload.cpp ===
// DelayLoad.cpp: implementation of the CDelayLoad class.
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"

#include "DelayLoad.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDelayLoad::CDelayLoad()
{
	// PSAPI
	m_hPSAPI = NULL;
	m_fPSAPIInitialized = false;
	m_fPSAPIInitializedAttempted = false;
	m_lpfEnumProcesses = NULL;
	m_lpfEnumProcessModules = NULL;
	m_lpfGetModuleFileNameEx = NULL;
	m_lpfGetModuleInformation = NULL;
	m_lpfEnumDeviceDrivers = NULL;
	m_lpfGetDeviceDriverFileName = NULL;

	// TOOLHELP32
	m_hTOOLHELP32 = NULL;
	m_fTOOLHELP32Initialized = false;
	m_fTOOLHELP32InitializedAttempted = false;
	m_lpfCreateToolhelp32Snapshot = NULL;
	m_lpfProcess32First = NULL;
	m_lpfProcess32Next = NULL;
	m_lpfModule32First = NULL;
	m_lpfModule32Next = NULL;
}

CDelayLoad::~CDelayLoad()
{
	if (m_hPSAPI)
		FreeLibrary(m_hPSAPI);

	if (m_hTOOLHELP32)
		FreeLibrary(m_hTOOLHELP32);
}

// PSAPI.DLL - APIs
bool CDelayLoad::Initialize_PSAPI()
{
	m_fPSAPIInitialized = false;
	m_fPSAPIInitializedAttempted = true;

	// Load library on DBGHELP.DLL and get the procedures explicitly.
	m_hPSAPI = LoadLibrary( TEXT("PSAPI.DLL") );

	if( m_hPSAPI == NULL )
	{
		// This may/may not be fatal... we can always fall back to TOOLHELP32 for Win2000/Win98
		goto exit;
	} else
	{
		// Get procedure addresses.
		m_lpfEnumProcesses = (PfnEnumProcesses) GetProcAddress( m_hPSAPI, "EnumProcesses" ) ;
		m_lpfEnumProcessModules = (PfnEnumProcessModules) GetProcAddress( m_hPSAPI, "EnumProcessModules" );
		m_lpfGetModuleInformation = (PfnGetModuleInformation) GetProcAddress( m_hPSAPI, "GetModuleInformation" );
#ifdef UNICODE
		m_lpfGetModuleFileNameEx =(PfnGetModuleFileNameEx) GetProcAddress(m_hPSAPI, "GetModuleFileNameExW" );
		m_lpfGetDeviceDriverFileName = (PfnGetDeviceDriverFileName) GetProcAddress(m_hPSAPI, "GetDeviceDriverFileNameW");
#else
		m_lpfGetModuleFileNameEx =(PfnGetModuleFileNameEx) GetProcAddress(m_hPSAPI, "GetModuleFileNameExA" );
		m_lpfGetDeviceDriverFileName = (PfnGetDeviceDriverFileName) GetProcAddress(m_hPSAPI, "GetDeviceDriverFileNameA");
#endif
		m_lpfEnumDeviceDrivers = (PfnEnumDeviceDrivers) GetProcAddress(m_hPSAPI, "EnumDeviceDrivers" );

		if( m_lpfEnumProcesses == NULL || 
			m_lpfEnumProcessModules == NULL || 
			m_lpfGetModuleFileNameEx == NULL ||
			m_lpfEnumDeviceDrivers == NULL ||
			m_lpfGetDeviceDriverFileName == NULL
		  )
		{
			_tprintf(TEXT("The version of PSAPI.DLL being loaded doesn't have required functions!.\n"));
			FreeLibrary( m_hPSAPI ) ;
			m_hPSAPI = NULL;
			goto exit;
		}
	}
	m_fPSAPIInitialized = true;

exit:
	return m_fPSAPIInitialized; 
}


DWORD CDelayLoad::GetModuleFileNameEx(HANDLE hHandle, HMODULE hModule, LPTSTR lpFilename, DWORD nSize)
{
	// If we've never initialized PSAPI, do so now...
	if (!m_fPSAPIInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_PSAPI())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fPSAPIInitialized)
	{
		return FALSE;
	}

	if (!m_lpfGetModuleFileNameEx)
		return FALSE;

	return m_lpfGetModuleFileNameEx(hHandle, hModule, lpFilename, nSize);
}


DWORD CDelayLoad::GetModuleInformation(HANDLE hProcess, HMODULE hModule, LPMODULEINFO lpmodinfo, DWORD cb)
{
	// If we've never initialized PSAPI, do so now...
	if (!m_fPSAPIInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_PSAPI())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fPSAPIInitialized)
	{
		return FALSE;
	}

	if (!m_lpfGetModuleInformation)
		return FALSE;

	return m_lpfGetModuleInformation(hProcess, hModule, lpmodinfo, cb);
}


BOOL CDelayLoad::EnumProcessModules(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded)
{
	// If we've never initialized PSAPI, do so now...
	if (!m_fPSAPIInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_PSAPI())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fPSAPIInitialized)
	{
		return FALSE;
	}

	if (!m_lpfEnumProcessModules)
		return FALSE;

	return m_lpfEnumProcessModules(hProcess, lphModule, cb, lpcbNeeded);
}

BOOL CDelayLoad::EnumProcesses(DWORD *lpidProcess, DWORD cb, DWORD *cbNeeded)
{
	// If we've never initialized PSAPI, do so now...
	if (!m_fPSAPIInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_PSAPI())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fPSAPIInitialized)
	{
		return FALSE;
	}

	if (!m_lpfEnumProcesses)
		return FALSE;

	return m_lpfEnumProcesses(lpidProcess, cb, cbNeeded);
}

BOOL CDelayLoad::EnumDeviceDrivers(LPVOID *lpImageBase, DWORD cb, LPDWORD lpcbNeeded)
{
	// If we've never initialized PSAPI, do so now...
	if (!m_fPSAPIInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_PSAPI())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fPSAPIInitialized)
	{
		return FALSE;
	}

	if (!m_lpfEnumDeviceDrivers)
		return FALSE;

	return m_lpfEnumDeviceDrivers(lpImageBase, cb, lpcbNeeded);
}



DWORD CDelayLoad::GetDeviceDriverFileName(LPVOID ImageBase, LPTSTR lpFilename, DWORD nSize)
{
	// If we've never initialized PSAPI, do so now...
	if (!m_fPSAPIInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_PSAPI())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fPSAPIInitialized)
	{
		return FALSE;
	}

	if (!m_lpfGetDeviceDriverFileName)
		return FALSE;

	return m_lpfGetDeviceDriverFileName(ImageBase, lpFilename, nSize);
}

// TOOLHELP32.DLL - APIs

bool CDelayLoad::Initialize_TOOLHELP32()
{
	m_fTOOLHELP32Initialized = false;
	m_fTOOLHELP32InitializedAttempted = true;

	// Load library on DBGHELP.DLL and get the procedures explicitly.
	m_hTOOLHELP32 = LoadLibrary( TEXT("KERNEL32.DLL") );

	if( m_hTOOLHELP32 == NULL )
	{
		// This may/may not be fatal... we can always fall back to TOOLHELP32 for Win2000/Win98
		goto exit;
	} else
	{
		// Get procedure addresses based on UNICODE or ANSI
		m_lpfCreateToolhelp32Snapshot = (PfnCreateToolhelp32Snapshot) GetProcAddress( m_hTOOLHELP32, "CreateToolhelp32Snapshot" );
#ifdef UNICODE
		m_lpfProcess32First = (PfnProcess32First) GetProcAddress( m_hTOOLHELP32, "Process32FirstW" );
		m_lpfProcess32Next =  (PfnProcess32Next)  GetProcAddress( m_hTOOLHELP32, "Process32NextW" );
		m_lpfModule32First =  (PfnModule32First)  GetProcAddress( m_hTOOLHELP32, "Module32FirstW" );
		m_lpfModule32Next =	  (PfnModule32Next)   GetProcAddress( m_hTOOLHELP32, "Module32NextW" );
#else
		m_lpfProcess32First = (PfnProcess32First) GetProcAddress( m_hTOOLHELP32, "Process32First" );
		m_lpfProcess32Next =  (PfnProcess32Next)  GetProcAddress( m_hTOOLHELP32, "Process32Next" );
		m_lpfModule32First =  (PfnModule32First)  GetProcAddress( m_hTOOLHELP32, "Module32First" );
		m_lpfModule32Next =	  (PfnModule32Next)   GetProcAddress( m_hTOOLHELP32, "Module32Next" );
#endif
		if (!m_lpfCreateToolhelp32Snapshot ||
			!m_lpfProcess32First || 
			!m_lpfProcess32Next ||
			!m_lpfModule32First ||
			!m_lpfModule32Next)

		{
			// Free our handle to KERNEL32.DLL
			FreeLibrary(m_hTOOLHELP32);
			m_hTOOLHELP32 = NULL;
			goto exit;
		}

	}
	m_fTOOLHELP32Initialized = true;

exit:
	return m_fTOOLHELP32Initialized; 
}

HANDLE WINAPI CDelayLoad::CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID)
{
	// If we've never initialized TOOLHELP32, do so now...
	if (!m_fTOOLHELP32InitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_TOOLHELP32())
			return INVALID_HANDLE_VALUE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fTOOLHELP32Initialized)
	{
		return INVALID_HANDLE_VALUE;
	}

	if (!m_lpfCreateToolhelp32Snapshot)
		return INVALID_HANDLE_VALUE;

	return m_lpfCreateToolhelp32Snapshot(dwFlags, th32ProcessID);
}

BOOL WINAPI CDelayLoad::Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe)
{
	// If we've never initialized TOOLHELP32, do so now...
	if (!m_fTOOLHELP32InitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_TOOLHELP32())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fTOOLHELP32Initialized)
	{
		return FALSE;
	}

	if (!m_lpfProcess32First)
		return FALSE;

	return m_lpfProcess32First(hSnapshot, lppe);
}

BOOL WINAPI CDelayLoad::Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe)
{
	// If we've never initialized TOOLHELP32, do so now...
	if (!m_fTOOLHELP32InitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_TOOLHELP32())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fTOOLHELP32Initialized)
	{
		return FALSE;
	}

	if (!m_lpfProcess32Next)
		return FALSE;

	return m_lpfProcess32Next(hSnapshot, lppe);
}

BOOL WINAPI CDelayLoad::Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme)
{
	// If we've never initialized TOOLHELP32, do so now...
	if (!m_fTOOLHELP32InitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_TOOLHELP32())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fTOOLHELP32Initialized)
	{
		return FALSE;
	}

	if (!m_lpfModule32First)
		return FALSE;

	return m_lpfModule32First(hSnapshot, lpme);
}

BOOL WINAPI CDelayLoad::Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme)
{
	// If we've never initialized TOOLHELP32, do so now...
	if (!m_fTOOLHELP32InitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_TOOLHELP32())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fTOOLHELP32Initialized)
	{
		return FALSE;
	}

	if (!m_lpfModule32Next)
		return FALSE;

	return m_lpfModule32Next(hSnapshot, lpme);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checkrel\checkrel.c ===
#ifndef WIN32
#define RC_INVOKED
#endif

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <malloc.h>
#include <errno.h>
#include <ctype.h>
#include <signal.h>
#include <string.h>
#include <time.h>
#include <conio.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <imagehlp.h>

#define READ_BUFFER_SIZE (16 * 1024 * sizeof(DWORD)) // 64k blocks

#define CHECK_NAME "\\chkfile.chk"

LPSTR
atolx(
    LPSTR psz,
    LPDWORD pul);

DWORD
ParseCheckFile (
    VOID
    );

HANDLE
PortFindFirstFile(
    LPSTR FindPattern,
    BOOL fNormal,
    LPSTR FindName,
    LPDWORD FindSize);

BOOL
PortFindNextFile(
    HANDLE hFind,
    BOOL fNormal,
    LPSTR FindName,
    LPDWORD FindSize);

VOID
PortFindClose(
    HANDLE hFind
    );

UINT ProcessCheckFile(LPINT pcfiles);
VOID Usage(VOID);
VOID __cdecl crerror(LPSTR pszfmt, ...);
LPSTR *ProcessParameters(INT *pargc, LPSTR argv[]);
LPSTR ProcessArgBuf(LPSTR pszargs);
BOOL OpenCheckFile(VOID);
BOOL ProcessEntry(LPSTR pszFullPath, LPSTR pszRelPath);
BOOL FindEntry(LPSTR pszRelPath, PULONG pSum);
DWORD MissingEntries(VOID);
VOID ReadCheckHeader(FILE *pf);
VOID RecursiveCheckHeader(void);
VOID WriteCheckHeader(FILE *pf);
LPSTR iscomment(LPSTR psz);
LPSTR ismatch(LPSTR psz, LPSTR pszcompact);
LPSTR iscomment(LPSTR psz);
LPSTR AddDirectory(LPSTR psz);
BOOL AddEntry(LPSTR psz, BOOL frequired);
BOOL AddComponent(LPSTR pszdir, LPSTR pszpat, BOOL fdir, BOOL frequired);
LPSTR ReadDirectory(LPSTR pszdir);

#define CHECKSTRLEN(psz, cbmax)                                         \
        if (strlen(psz) > cbmax) {                                      \
            crerror("String overflow at line %u (%s)", __LINE__, psz);  \
            exit(4);                                                    \
        }

#define DEFAULTROOT "nt"

//
// Defined parsed check file entry structure and table storage.
//

typedef struct _CHECK_FILE_ENTRY {
    struct _CHECK_FILE_ENTRY *Next;
    DWORD Sum;
    WORD Length;
    CHAR *Name;
} CHECK_FILE_ENTRY, *PCHECK_FILE_ENTRY;

#define CHECK_ENTRY_TABLE_SIZE 4096

CHECK_FILE_ENTRY CheckEntryTable[CHECK_ENTRY_TABLE_SIZE];

//
// Define root of parsed check file list.
//

CHECK_FILE_ENTRY CheckEntryRoot;

struct component_s {
    struct component_s *pcmNext;        // next in linked list
    BOOL                fDir;           // TRUE if directory
    BOOL                fFound;         // TRUE if found
    BOOL                fRequired;      // TRUE if must exist
    CHAR                achPat[1];      // path component (subdir or pattern)
};

struct checkpath_s {
    struct checkpath_s *pcpNext;        // next in linked list
    struct component_s *pcmPat;         // subdirectories and file patterns
    CHAR                achDir[1];      // root relative directory path
};

struct checkpath_s *pcpPaths = NULL;


DWORD cbCheck;
LPSTR pszCheckFileName = NULL;  // input/output check file path
LPSTR pszLogFileName = NULL;    // error log file path
FILE *pfCheck = NULL;           // input/output check stdio file pointer
FILE *pfLog;                    // error log file pointer
LPSTR pszCheck = NULL;          // input check file contents
LPSTR RootOfTree = DEFAULTROOT;
BOOL fInProgress = FALSE;
UINT cbProgress = 0;

BOOL fAll = FALSE;
BOOL fCommand = FALSE;
BOOL fGenerateCheck = FALSE;
BOOL fNoArgs = FALSE;
BOOL fRecurse = FALSE;
BOOL fPrintMissing = TRUE;
BOOL fPrintExtra = TRUE;
DWORD fCdCheck;

CHAR OutputLine[512];
DWORD ReadBuffer[READ_BUFFER_SIZE / sizeof(DWORD) + 1];



//
// this table must be in alphabetical order !!!
//

LPSTR pszDefaultDir =
    "#directory start\n"
#if defined(i386)
    "*.\n"
    "*.com\n"
#endif
#if defined(MIPS) || defined(_ALPHA_)
    "*.dll\n"
    "*.exe\n"
#endif
#if defined(PPC)
    "*.exe\n"
#endif
    "?\\*.*\n"
    "?\\dump\\ optional\n"
    "?\\dump\\*.* optional\n"
    "?\\idw\\ optional\n"
    "?\\idw\\*.* optional\n"
    "?\\idw\\setup\\ optional\n"
    "?\\idw\\setup\\*.* optional\n"
    "?\\km\\ optional\n"
    "?\\km\\*.* optional\n"
    "?\\km\\symbols\\ optional\n"
    "?\\km\\symbols\\dll\\ optional\n"
    "?\\km\\symbols\\dll\\*.* optional\n"
    "?\\km\\symbols\\sys\\ optional\n"
    "?\\km\\symbols\\sys\\*.* optional\n"
    "?\\km\\system32\\ optional\n"
    "?\\km\\system32\\*.* optional\n"
    "?\\km\\system32\\drivers\\ optional\n"
    "?\\km\\system32\\drivers\\*.* optional\n"
    "?\\mstools\\ optional\n"
    "?\\mstools\\*.* optional\n"
    "?\\nws\\ optional\n"
    "?\\nws\\*.* optional\n"
    "?\\symbols\\*.* optional\n"
    "?\\symbols\\acm\\*.* optional\n"
    "?\\symbols\\com\\*.* optional\n"
    "?\\symbols\\cpl\\*.* optional\n"
    "?\\symbols\\dll\\*.* optional\n"
    "?\\symbols\\drv\\*.* optional\n"
    "?\\symbols\\exe\\*.* optional\n"
    "?\\symbols\\scr\\*.* optional\n"
    "?\\symbols\\sys\\*.* optional\n"
    "?\\system\\*.*\n"
    "?\\system32\\*.*\n"
    "?\\system32\\config\\*.*\n"
    "?\\system32\\dhcp\\*.* optional\n"
    "?\\system32\\drivers\\*.*\n"
    "?\\system32\\drivers\\etc\\*.*\n"
#ifdef i386
    "?\\system32\\os2\\ optional\n"
    "?\\system32\\os2\\dll\\ optional\n"
    "?\\system32\\os2\\dll\\*.* optional\n"
#endif
    "?\\system32\\ras\\*.* optional\n"
    "?\\system32\\spool\\ optional\n"
    "?\\system32\\spool\\drivers\\ optional\n"
    "?\\system32\\spool\\prtprocs\\ optional\n"
#ifdef MIPS
    "?\\system32\\spool\\prtprocs\\w32mips\\ optional\n"
    "?\\system32\\spool\\prtprocs\\w32mips\\*.dll optional\n"
#endif
#ifdef _ALPHA_
    "?\\system32\\spool\\prtprocs\\w32alpha\\ optional\n"
    "?\\system32\\spool\\prtprocs\\w32alpha\\*.dll optional\n"
#endif
#ifdef i386
    "?\\system32\\spool\\prtprocs\\w32x86\\ optional\n"
    "?\\system32\\spool\\prtprocs\\w32x86\\*.dll optional\n"
#endif
#ifdef PPC
    "?\\system32\\spool\\prtprocs\\w32ppc\\ optional\n"
    "?\\system32\\spool\\prtprocs\\w32ppc\\*.dll optional\n"
#endif
    "?\\system32\\wins\\*.* optional\n"
    "?\\ui\\ optional\n"
    "?\\ui\\*.* optional\n"
    "?\\ui\\dump\\ optional\n"
    "?\\ui\\dump\\*.* optional\n"
    "?\\ui\\symbols\\ optional\n"
    "?\\ui\\symbols\\cpl\\ optional\n"
    "?\\ui\\symbols\\cpl\\*.* optional\n"
    "?\\ui\\symbols\\dll\\ optional\n"
    "?\\ui\\symbols\\dll\\*.* optional\n"
    "?\\ui\\symbols\\exe\\ optional\n"
    "?\\ui\\symbols\\exe\\*.* optional\n"
    "?\\ui\\system32\\ optional\n"
    "?\\ui\\system32\\*.* optional\n"
#ifdef i386
    "?\\wdl\\ optional\n"
    "?\\wdl\\video\\ optional\n"
    "?\\wdl\\video\\avga\\ optional\n"
    "?\\wdl\\video\\avga\\*.* optional\n"
#endif
    "#directory end\n"
    "";

VOID
CdCheck()
{
#if 0

    LPSTR line=NULL;
    LPSTR psz;
    CHAR partialname[256];
    CHAR fullname[256];
    char flatname[256];
    DWORD ChkFileSum,ChkFileSize;
    LPSTR FilePart;
    DWORD ActualSize, ActualSum;
    FILE *pf = NULL;

    //
    // We are checking the CD. Read the entire checkfile
    // and cross check each entry against contents of the
    // CD
    //

    line = pszCheck;
    for ( line = pszCheck; line != NULL ; line = strchr(line, '\n')) {
        if (line >= pszCheck + cbCheck - 1) {
            line = pszCheck;
            }
        if (*line == '\n') {
            line++;
            }
        if (*line == '\0') {
            break;
            }
        if (*line == '\n') {
            continue;                   // skip used entries & empty lines
            }
        psz = line;
        while (*psz == ' ' || *psz == '\t') {
            psz++;                      // skip leading whitespace
            }
        if (*psz == '\n') {
            continue;                   // skip empty line
            }

        //
        // psz points to name sum size
        //

        sscanf(psz,"%s %x %x",partialname,&ChkFileSum,&ChkFileSize);
        GetFullPathName(partialname,sizeof(fullname),fullname,&FilePart);

        strcpy(flatname,RootOfTree);
        strcat(flatname,"\\");
        strcat(flatname,FilePart);

        pf = fopen(flatname, "rb");
        if (pf == NULL) {
            strcpy(flatname,RootOfTree);
            strcpy(flatname+2,"\\mstools\\bin");
            strcat(flatname,RootOfTree+2);
            strcat(flatname,"\\");
            strcat(flatname,FilePart);

            pf = fopen(flatname, "rb");
            if (pf == NULL) {
                if ( strstr(partialname,"idw\\") ) {
                    goto nextone;
                    }
                if ( strstr(partialname,"dump\\") ) {
                    goto nextone;
                    }
                crerror("Cannot open file(%d): %s", errno, FilePart);
                goto nextone;
                }
            }
        ActualSize = _filelength(_fileno(pf));
        if (ActualSize == 0xffffffff) {
            crerror("Cannot determine size of file: %s %d", FilePart, errno);
            fclose(pf);
            goto nextone;
            }
        if (ActualSize != ChkFileSize) {
            crerror("Size differs (actual %lx, expected %lx): %s",
                    ActualSize,
                    ChkFileSize,
                    FilePart);
            fclose(pf);
            goto nextone;
            }
//        ActualSum = CheckSumFile(pf, flatname, flatname, &ActualSize);

        if (ActualSum != ChkFileSum) {
            crerror("Sum differs (actual %lx, expected %lx): %s",
                    ActualSum,
                    ChkFileSum,
                    FilePart);
            }
nextone:;
        }
#endif /* 0 */
}

INT __cdecl
main(
    INT argc,
    LPSTR argv[]
    )

{

    UINT rc;

    pfLog = stderr;

    //
    // Initialize check file entry root list entry.
    //

    CheckEntryRoot.Next = NULL;
    argv = ProcessParameters(&argc, argv);
    if (fCommand) {
        pfCheck = stdout;
        rc = 0;
        while (argc > 1) {
            argc--;
            argv++;
            _strlwr(*argv);
            if (!ProcessEntry(*argv, *argv)) {
                rc++;
            }
        }

    } else {
        long l;
        time_t t = time(NULL);
        INT cfiles;

        // If we are generating a check file, then generate it.
        // Otherwise just check the release.

        rc = ProcessCheckFile(&cfiles);

        l = (long)(time(NULL) - t);
        printf("\n%3u files: %lu:%02lu\n", cfiles, l/60, l % 60);
    }

    exit(rc);
    return rc;
}


LPSTR pszUsage =
    "usage: checkrel [-?] display this message\n"
    "                [-a] process all files\n"
    "                [-c] command line contains file names to sum\n"
    "                [-f chkfile] input/output check file override\n"
    "                [-g] generate check file\n"
    "                [-l logfile] stderr log file\n"
    "                [-n] suppress check file arguments\n"
    "                [-r pathname] root path override\n"
    "                [-R] recursive file check\n"
    "                [-m] master cdrom check\n"
    "                [-i] don't warn about missing files\n"
    "                [-x] don't warn about extra files\n"
    "";

VOID
Usage(VOID)
{
    fprintf(stderr, pszUsage);
    exit(1);
}


VOID
__cdecl
crerror(
    LPSTR pszfmt,
    ...
    )

{

    va_list argptr;

    va_start(argptr, pszfmt);
    if (fInProgress && pfLog == stderr) {
        printf("\r%*s\r", cbProgress, "");              // clear line
        fflush(stdout);
        fInProgress = FALSE;
    }
    fprintf(pfLog, "CheckRel: ");
    vfprintf(pfLog, pszfmt, argptr);
    fprintf(pfLog, "\n");
}


LPSTR *
ProcessParameters(INT *pargc, LPSTR argv[])
{
    CHAR cswitch, c, *p;

    while (*pargc > 1) {
        --(*pargc);
        p = *++argv;
        if ((cswitch = *p) == '/' || cswitch == '-') {
            while (c = *++p) {
                switch (c) {
                case '?':
                    Usage();

                case 'm': fCdCheck++;            break;
                case 'a': fAll++;                break;
                case 'c': fCommand++;            break;
                case 'g': fGenerateCheck++;      break;
                case 'n': fNoArgs++;             break;
                case 'i': fPrintMissing = FALSE; break;
                case 'x': fPrintExtra   = FALSE; break;
                case 'R': fRecurse++;            break;

                case 'f':
                    if (p[1] == '\0' && --(*pargc)) {
                        ++argv;
                        if (pszCheckFileName == NULL) {
                            pszCheckFileName = *argv;
                            break;
                        }
                        crerror("Check file specified twice: -f %s -f %s",
                                pszCheckFileName,
                                *argv);
                        Usage();
                    }
                    Usage();

                case 'l':
                    if (p[1] == '\0' && --(*pargc)) {
                        ++argv;
                        if (pszLogFileName == NULL) {
                            pfLog = fopen(*argv, "wt");
                            if (pfLog == NULL) {
                                pfLog = stderr;
                                crerror("Cannot open %s (%d)", *argv, errno);
                                exit(2);
                            }
                            pszLogFileName = *argv;
                            break;
                        }
                        crerror("Log file specified twice: -l %s -l %s",
                                pszLogFileName,
                                *argv);
                        Usage();
                    }
                    Usage();

                case 'r':
                    if (p[1] == '\0' && --(*pargc)) {
                        ++argv;
                        RootOfTree = _strdup(*argv);
                        if (RootOfTree == NULL) {
                            crerror("Out of memory for tree root");
                            exit(2);
                        }
                        break;
                    }

                    Usage();

                default:
                    crerror("Invalid switch: -%c", c);
                    Usage();
                }
            }
        } else if (fCommand) {
            (*pargc)++;
            argv--;
            break;
        } else {
            crerror("Extra argument: %s", p);
            Usage();
        }
    }

    if (fCommand || fRecurse) {
        fGenerateCheck = TRUE;
        fAll = TRUE;
    }

    return(argv);
}


LPSTR
ProcessArgBuf(LPSTR pszargs)
{
    UINT i;
    INT argc;
    LPSTR pb;
    LPSTR psz;
    LPSTR *ppsz;
    LPSTR argv[20];
    CHAR achbuf[512];

    ppsz = argv;
    *ppsz++ = "Check File";
    psz = achbuf;
    if ((pb = strchr(pszargs, '\n')) != NULL) {
        pb++;
        while (*pszargs == ' ' || *pszargs == '\t') {
            pszargs++;                  // skip leading white space
        }
        if (*pszargs == '-') {
            for (;;) {
                i = strcspn(pszargs, " \t\n");
                *ppsz++ = psz;
                if (ppsz - argv + 1 >= sizeof(argv)/sizeof(argv[0])) {
                    crerror("Too many file args (%d)", ppsz - argv);
                    exit(2);
                }
                if (psz - achbuf + i + 2 >= sizeof(achbuf)) {
                    crerror("Too many file arg chars (%d)", sizeof(achbuf));
                    exit(2);
                }
                strncpy(psz, pszargs, i);
                psz += i;
                *psz++ = '\0';
                if (pszargs[i] == '\n') {
                    break;
                }
                pszargs += i + 1;
                while (*pszargs == ' ' || *pszargs == '\t') {
                    pszargs++;                  // skip leading white space
                }
            }
            *ppsz = NULL;
            argc = (INT)(ppsz - argv);
            if (!fNoArgs) {
                if (fGenerateCheck) {
                    printf("Check file arguments:");
                    for (ppsz = &argv[1]; *ppsz != NULL; ppsz++) {
                        printf(" %s", *ppsz);
                    }
                    printf("\n");
                }
                ProcessParameters(&argc, argv);
            }
        } else {
            pb = NULL;
        }
    }
    return(pb);
}


UINT
ProcessCheckFile(
    LPINT pcfiles
    )

{

    HANDLE hFind;
    DWORD FindSize;
    UINT cbFindPattern;
    LPSTR FindPattern;
    LPSTR pszRelPath;
    LPSTR pszFile;
    struct checkpath_s *pcp;
    struct component_s *pcm;
    CHAR FindName[MAX_PATH];
    INT i;

    *pcfiles = 0;
    if (!OpenCheckFile()) {
        return(1);
    }

    cbFindPattern = MAX_PATH + strlen(".") + 1;
    FindPattern = malloc(cbFindPattern + 1);
    if (FindPattern == NULL) {
        crerror("Process: memory allocation (%d bytes) failed",
                cbFindPattern + 1);
        return(1);
    }

    //
    // Set address of relative path.
    //

    pszRelPath = &FindPattern[strlen(".") + 1];
    i = 0;
    for (pcp = pcpPaths; pcp != NULL; pcp = pcp->pcpNext) {
        i = (i & ~31) + 32;

        //
        // Build the initial find pattern.
        //

        sprintf(FindPattern,
                "%s\\%s%s",
                ".",
                pcp->achDir,
                *pcp->achDir ? "\\" : "");

        CHECKSTRLEN(FindPattern, cbFindPattern);

        //
        // Point past directory in find pattern.
        //

        pszFile = &FindPattern[strlen(FindPattern)];
        for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
            i++;
            if (pcm->fDir) {
                continue;                       // process only file patterns
            }

            if (!fAll && *pcm->achPat == '\0') {
                continue;               // skip entry if no search pattern
            }

            // Complete FindPattern: "c:\nt\system32\*.exe"

            if (fAll)
                strcpy(pszFile, "*.*");

            else if (pcm->achPat)
                strcpy(pszFile, pcm->achPat);

            else
                *pcm->achPat = '\0';

            CHECKSTRLEN(FindPattern, cbFindPattern);

            hFind = PortFindFirstFile(FindPattern, TRUE, FindName, &FindSize);

            if (hFind == INVALID_HANDLE_VALUE) {
                if (pcm->fRequired) {
                    crerror("Missing files: %s", pszRelPath);
                }

            } else {
                do {

                    // append file name to FindPattern: "c:\nt\driver\foo.sys"

                    _strlwr(FindName);
                    strcpy(pszFile, FindName);
                    CHECKSTRLEN(FindPattern, cbFindPattern);
                    if (fAll && strcmp(FindPattern, pszCheckFileName) == 0) {
                        continue;
                    }

                    *pcfiles += 1;
                    if (!ProcessEntry(FindPattern,
                                      pszRelPath)) {
                        crerror("ProcessEntry failed");
                        return(1);
                    }
                } while (PortFindNextFile(hFind, TRUE, FindName, &FindSize));
                PortFindClose(hFind);
            }

            // if ignoring the supplied extensions, skip redundant patterns

            if (fAll) {
                break;
            }
        }

        strcpy(pszFile, "*.*");         // search for all directories

        CHECKSTRLEN(FindPattern, cbFindPattern);

        for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
            if (pcm->fDir) {                    // process only directories
                pcm->fFound = FALSE;
            }
        }

        hFind = PortFindFirstFile(FindPattern, FALSE, FindName, &FindSize);
        *pszFile = '\0';

        if (hFind != INVALID_HANDLE_VALUE) {
            do {
                if (strcmp(FindName, ".") == 0 ||
                    strcmp(FindName, "..") == 0) {
                    continue;
                }
                _strlwr(FindName);
                for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
                    if (pcm->fDir && strcmp(FindName, pcm->achPat) == 0) {
                        pcm->fFound = TRUE;
                        break;
                    }
                }

                if (pcm == NULL && fPrintExtra) {
                    crerror("Extra directory: %s%s", pszRelPath, FindName);
                }

            } while (PortFindNextFile(hFind, FALSE, FindName, &FindSize));
            PortFindClose(hFind);
        }

        for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
            if (pcm->fDir && !pcm->fFound && fPrintMissing) {
                crerror("Missing directory: %s%s", pszRelPath, pcm->achPat);
            }
        }
    }

    if (!fGenerateCheck && MissingEntries()) {
        return(1);
    }

    if (fInProgress) {
        printf("\n");
        fInProgress = FALSE;
    }

    return(0);
}


BOOL
OpenCheckFile(
    VOID
    )

{

    UINT cbCheckName;

    // If the check file name wasn't given, then construct it.

    if (pszCheckFileName == NULL) {
        cbCheckName = strlen(".") + 1 + strlen(CHECK_NAME);
        pszCheckFileName = malloc(cbCheckName + 1);
        if (pszCheckFileName == NULL) {
            crerror("Open: Out of memory (%d bytes)", cbCheckName + 1);
            exit(2);
        }
        sprintf(pszCheckFileName, "%s\\%s", ".", CHECK_NAME);
    }

    if (fRecurse) {
        RecursiveCheckHeader();

    } else if (fGenerateCheck) {
       ReadCheckHeader(NULL);
    }

    pfCheck = fopen(pszCheckFileName, fGenerateCheck||fRecurse? "wt" : "rt");

    if (pfCheck == NULL) {
        crerror("Cannot open %s (%d)", pszCheckFileName, errno);
        return(FALSE);
    }
    if (fGenerateCheck) {
        WriteCheckHeader(pfCheck);

    } else {
        ReadCheckHeader(pfCheck);
        if (fCdCheck) {
            CdCheck();
            return FALSE;
            }
    }

    return(TRUE);
}


VOID
ReadCheckHeader(
    FILE *pf
    )

{
    DWORD cb;
    UINT cbread, cbactual;
    LPSTR pb;

    if (pf == NULL) {
        cbCheck = strlen(pszDefaultDir) + 1;
        pszCheck = pszDefaultDir;

    } else {
        cbCheck = _filelength(_fileno(pfCheck)) + 1;
        if ((DWORD) (size_t) cbCheck != cbCheck) {
            crerror("Open: check file too large (%ld bytes)", cbCheck);
            exit(2);
        }

        pszCheck = malloc((size_t) cbCheck);
        if (pszCheck == NULL) {
            crerror("Open: memory allocation (%ld bytes) failed", cbCheck);
            exit(2);
        }

        pb = pszCheck;
        cb = cbCheck - 1;
        while (cb) {
            cbread = (cb >= READ_BUFFER_SIZE)? READ_BUFFER_SIZE : (UINT) cb;
            cbactual = fread(pb, 1, cbread, pfCheck);
            if (cbread > cbactual) {
                cb -= cbread - cbactual;
                cbCheck -= cbread - cbactual;
            }
            pb += cbactual;
            cb -= cbactual;
        }
        *pb = '\0';
    }

    while ((pb = iscomment(pszCheck)) != NULL ||
           (pb = ProcessArgBuf(pszCheck)) != NULL) {
        pszCheck = pb;                          // skip comment or parm line
    }

    if ((pb = ReadDirectory(pszCheck)) != NULL) {
        pszCheck = pb;                          // skip directory lines

    } else if (ReadDirectory(pszDefaultDir) == NULL) {
        crerror("Bad internal data structure directory format");
        exit(1);
    }

}


LPSTR
ReadDirectory(
    LPSTR pszdir
    )

{
    LPSTR pb;

    if ((pb = ismatch(pszdir, "#directorystart")) == NULL) {
        return(NULL);
    }

    pszdir = pb;                                // skip "start" line

    while ((pb = ismatch(pszdir, "#directoryend")) == NULL) {
        if ((pb = iscomment(pszdir)) == NULL &&
            (pb = AddDirectory(pszdir)) == NULL) {
            return(NULL);
        }

        pszdir = pb;
    }

    return(pb);
}


LPSTR
iscomment(
    LPSTR psz
    )

{

    while (*psz == ' ' || *psz == '\t') {
        psz++;
    }
    if (*psz == '\n' || *psz == '/' && psz[1] == '/') {
        psz += strcspn(psz, "\n");
        if (*psz == '\n') {
            psz++;
        }
        return(psz);                    // return start of next line
    }
    return(NULL);                       // not a comment
}


LPSTR
ismatch(
    LPSTR psz,
    LPSTR pszcompact
    )

{
    while (*psz) {
        if (*psz == ' ' || *psz == '\t') {
            psz++;
            continue;
        }
        if (*psz != *pszcompact) {
            break;
        }
        psz++;
        pszcompact++;
    }
    if (*psz != '\n' || *pszcompact != '\0') {
        return(NULL);
    }
    return(psz + 1);
}


LPSTR
AddDirectory(
    LPSTR psz
    )

{

    LPSTR pb;
    BOOL frequired;
    INT i, ch;

    if ((pb = strchr(psz, '\n')) == NULL) {
        crerror("Directory data error");
        return(NULL);
    }

    while (*psz == ' ' || *psz == '\t') {
        psz++;
    }

    frequired = TRUE;
    i = strcspn(psz, " \t\n");
    ch = psz[i];
    psz[i] = '\0';
    if (ch != '\n') {
        frequired = !ismatch(psz + i + 1, "optional");
    }

    if (!AddEntry(psz, frequired)) {
        psz[i] = (char)ch;
        return(NULL);
    }

    return(pb + 1);
}


BOOL
AddEntry(LPSTR psz,
         BOOL frequired
         )

{

    BOOL f, fdir, freq1;
    INT i;
    CHAR chsep;
    CHAR achdir[MAX_PATH];
    CHAR FullPath[MAX_PATH];

    //
    // If the leading character is ?, then prepend the name of the NT tree
    // to the directory name.
    //

    if (*psz == '?') {
        strcpy(&FullPath[0], RootOfTree);
        strcat(&FullPath[0], psz + 1);
        psz = &FullPath[0];
    }

    achdir[0] = '\0';
    do {
        i = strcspn(psz, "\\");
        chsep = psz[i];
        psz[i] = '\0';
        fdir = freq1 = TRUE;
        if (chsep == '\0' || psz[i + 1] == '\0') {
            if (chsep == '\0') {
                fdir = FALSE;                   // at end & no trailing pathsep
            }
            freq1 = frequired;                  // at end.
        }
        f = AddComponent(achdir, psz, fdir, freq1);
        if (achdir[0] != '\0') {
            strcat(achdir, "\\");
        }
        strcat(achdir, psz);
        psz[i] = chsep;
        if (!f) {
            return(FALSE);
        }
        psz += i + 1;
    } while(chsep != '\0' && *psz != '\0');
    return(TRUE);
}


//struct component_s {
//    struct component_s *pcmNext;      // next in linked list
//    BOOL              fDir;           // TRUE if directory
//    BOOL              fRequired;      // TRUE if must exist
//    CHAR              achPat[1];      // path component (subdir or pattern)
//};
//
//struct checkpath_s {
//    struct checkpath_s *pcpNext;      // next in linked list
//    struct component_s *pcmPat;       // subdirectories and file patterns
//    CHAR              achDir[1];      // root relative directory path
//};

BOOL
AddComponent(
    LPSTR pszdir,
    LPSTR pszpat,
    BOOL fdir,
    BOOL frequired
    )

{
    struct checkpath_s *pcp;
    struct checkpath_s *pcplast;
    struct component_s *pcm;
    struct component_s *pcmlast;
    INT r;
    INT t = 0;

    pcplast = NULL;
    for (pcp = pcpPaths; pcp != NULL; pcp = pcp->pcpNext) {
        pcplast = pcp;
        if ((r = strcmp(pszdir, pcp->achDir)) <= 0) {
            break;
        }
    }
    if (pcp == NULL || r) {
        pcp = malloc(sizeof(*pcp) + strlen(pszdir));
        if (pcp == NULL) {
            crerror("AddComponent: out of memory");
            exit(2);
        }
        if (pcplast == NULL) {
            t |= 1;
            pcp->pcpNext = NULL;
            pcpPaths = pcp;
        } else {
            t |= 2;
            pcp->pcpNext = pcplast->pcpNext;
            pcplast->pcpNext = pcp;
        }
        pcp->pcmPat = NULL;
        strcpy(pcp->achDir, pszdir);
    }

    pcmlast = NULL;
    if (pszpat != NULL) {
        for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
            pcmlast = pcm;
            if ((r = strcmp(pszpat, pcm->achPat)) <= 0) {
                break;
            }
        }
    }

    if (pcm == NULL || r) {
        if (pszpat != NULL)
            pcm = malloc(sizeof(*pcm) + strlen(pszpat));
        else
            pcm = malloc(sizeof(*pcm));
        if (pcm == NULL) {
            crerror("AddComponent: out of memory");
            exit(2);
        }
        if (pcmlast == NULL) {
            t |= 4;
            pcm->pcmNext = NULL;
            pcp->pcmPat = pcm;
        } else {
            t |= 8;
            pcm->pcmNext = pcmlast->pcmNext;
            pcmlast->pcmNext = pcm;
        }
        pcm->fDir = fdir;
        pcm->fFound = FALSE;
        pcm->fRequired = frequired;
        if (pszpat == NULL)
            *pcm->achPat = '\000';
        else
            strcpy(pcm->achPat, pszpat);
    }
    if (!frequired) {
        pcm->fRequired = frequired;
    }
    return(TRUE);
}


VOID
WriteCheckHeader(FILE *pf)
{
    struct checkpath_s *pcp;
    struct component_s *pcm;
    INT ccol;
    CHAR achpath[MAX_PATH];
    CHAR *psz;
    CHAR SavedChar;

    if (fAll) {
        fprintf(pf,
                "-%s\n\n",
                fAll?    "a" : "");
    }
    fprintf(pf, "#directory start\n");
    for (pcp = pcpPaths; pcp != NULL; pcp = pcp->pcpNext) {
        for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
            sprintf(achpath,
                    "%s%s%s%s",
                    pcp->achDir,
                    *pcp->achDir? "\\" : "",
                    pcm->achPat,
                    pcm->fDir? "\\" : "");

            psz = strchr(achpath, '\\');
            if (psz == NULL) {
                fprintf(pf, achpath);

            } else {
                psz -= 1;
                SavedChar = *psz;
                *psz = '?';
                fprintf(pf, psz);
                *psz = SavedChar;
            }

            if (!pcm->fRequired) {
                ccol = strlen(achpath);
                fprintf(pf, " optional");
            }
            fprintf(pf, "\n");
        }
    }
    fprintf(pf, "#directory end\n\n");
}


BOOL
ProcessEntry(
    LPSTR pszFullPath,
    LPSTR pszRelPath
    )

{

    ULONG CheckSum;
    ULONG HeaderSum;
    ULONG FileSum;
    FILE *pf = NULL;
    UINT cbLine;
    CHAR *psz;
    ULONG Status;

    if (!fGenerateCheck) {
        if (!FindEntry(pszRelPath, &FileSum)) {
            if (fPrintExtra) {
                crerror("Extra file: %s", pszRelPath);
            }
            return TRUE;
        }
    }

    //
    // Compute checksum of file.
    //

    Status = MapFileAndCheckSum(pszFullPath, &HeaderSum, &CheckSum);
    if (Status != CHECKSUM_SUCCESS) {
        crerror("Cannot open or map file %s", pszFullPath);
        return TRUE;
    }

    if (fGenerateCheck) {
        cbLine = sprintf(OutputLine,
                         "%s %lx\n",
                         pszRelPath,
                         CheckSum);

        CHECKSTRLEN(OutputLine, sizeof(OutputLine));

        psz = strchr(OutputLine, '\\');
        if (fCommand || psz == NULL) {
            fwrite(OutputLine, 1, cbLine, pfCheck);

        } else {
            psz -= 1;
            *psz = '?';
            fwrite(psz, 1, (size_t)(cbLine - (psz - OutputLine)), pfCheck);
        }
    }

    if (!fGenerateCheck) {
        if (CheckSum != FileSum) {
            crerror("Sum differs (actual %lx, expected %lx): %s",
                    CheckSum,
                    FileSum,
                    pszRelPath);
        }
    }
    return TRUE;
}


BOOL
FindEntry(
    LPSTR pszRelPath,
    PULONG FileSum
    )

{

    PCHECK_FILE_ENTRY LastEntry;
    WORD Length;
    PCHECK_FILE_ENTRY NextEntry;

    //
    // If this is the first trip through this code, then reset to the
    // beginning of the check file.
    //

    if (CheckEntryRoot.Next == NULL) {
        if (ParseCheckFile() == 0) {
            return FALSE;
        }
    }

    //
    // Compute the length of the specified file name and loop through
    // check file list for a matching entry.
    //

    Length = (WORD)strlen(pszRelPath);
    LastEntry = &CheckEntryRoot;
    NextEntry = LastEntry->Next;
    do {

        //
        // If the length and the file name match, then remove the entry from
        // the list and return the file size and check sum value.
        //

        if (NextEntry->Length == Length) {
            if (strncmp(pszRelPath, NextEntry->Name, Length) == 0) {
                LastEntry->Next = NextEntry->Next;
                *FileSum = NextEntry->Sum;
                return TRUE;
            }
        }

        LastEntry = NextEntry;
        NextEntry = NextEntry->Next;
    } while (NextEntry != NULL);

    //
    // The specified file is not in the check file.
    //

    return FALSE;
}

DWORD
MissingEntries(
    VOID
    )

{

    DWORD Count = 0;
    PCHECK_FILE_ENTRY NextEntry;

    //
    // Scan through the check file list and display an error message for
    // each missing file.
    //

    if (fPrintMissing) {
        NextEntry = CheckEntryRoot.Next;
        while (NextEntry != NULL) {
            crerror("Missing file: %s", NextEntry->Name);
            Count += 1;
            NextEntry = NextEntry->Next;
        }
    }

    return Count;
}


DWORD
ParseCheckFile(
    VOID
    )

{

    DWORD Count = 0;
    LPSTR pszline;
    LPSTR psz;
    PCHECK_FILE_ENTRY LastEntry;
    WORD Length;
    PCHECK_FILE_ENTRY NextEntry;
    WORD SizeOfRoot;
    DWORD Sum;

    //
    // If the check file contains no entries, then return.
    //

    if (*pszCheck != '\n') {
        return Count;
    }

    //
    // Scan through the check file and parse each file name, checksum, and
    // size field.
    //

    SizeOfRoot = (WORD)strlen(RootOfTree);
    LastEntry = &CheckEntryRoot;
    for (pszline = pszCheck; pszline != NULL; pszline = strchr(pszline, '\n')) {

        //
        // Skip over the new line and search for the blank separator between
        // the file name and the checksum.
        //

        pszline += 1;
        psz = strchr(pszline, ' ');

        //
        // If there is no blank separator, then the end of the check file has
        // been reached.
        //

        if (psz == NULL) {
            return Count;
        }

        //
        // Compute the length and checksum of the file entry.
        //

        Length = (short)(psz - pszline);
        psz = atolx(psz + 1, &Sum);

        //
        // Allocate a check file entry for the specified file and insert it
        // at the end of the check file entry list.
        //

        Count += 1;
        if (Count > CHECK_ENTRY_TABLE_SIZE) {
           crerror("Checkrel: Check Entry Table Overflow");
           return 0;
        }

        NextEntry = &CheckEntryTable[Count - 1];
        NextEntry->Next = NULL;
        NextEntry->Sum = Sum;

        //
        // Form the file name from the NT root name and the specified path.
        //

        pszline[Length] = '\0';
        if (*pszline == '?') {
            pszline += 1;
            NextEntry->Name = (CHAR *)malloc(SizeOfRoot + Length);
            if (NextEntry->Name == NULL) {
                crerror("Checkrel: failure to allocate check file entry");
                return Count;
            }

            strcpy(NextEntry->Name, RootOfTree);
            strcat(NextEntry->Name, pszline);
            Length += SizeOfRoot - 1;

        } else {
            NextEntry->Name = pszline;
        }

        NextEntry->Length = Length;
        LastEntry->Next = NextEntry;
        LastEntry = NextEntry;
        pszline = psz;
    }

    return Count;
}

LPSTR
atolx(
    LPSTR psz,
    LPDWORD pul)

{

    DWORD ul;
    char ch;

    ul = 0;
    while (isxdigit(*psz)) {
        ch = *psz++;
        if (isdigit(ch)) {
            ch += 0 - '0';

        } else if (islower(ch)) {
            ch += 10 - 'a';

        } else {
            ch += 10 - 'A';
        }

        ul = (ul << 4) + ch;
    }

    *pul = ul;
    return(psz);
}


VOID
RecursiveCheckHeader()
{
    HANDLE hFind;
    DWORD FindSize;
    UINT cbFindPattern;
    LPSTR FindPattern;
    LPSTR pszRelPath;
    LPSTR pszFile;
    struct checkpath_s *pcp;
    struct component_s *pcm;
    CHAR FindName[MAX_PATH];
    INT i;

    cbFindPattern = strlen(".") + MAX_PATH;
    FindPattern = malloc(cbFindPattern + 1);
    if (FindPattern == NULL) {
        crerror("Process: memory allocation (%d bytes) failed",
                cbFindPattern + 1);
        return;
    }

    // Set relative path pointer into FindPattern: "driver\elnkii.sys"

    pszRelPath = &FindPattern[strlen(RootOfTree) + 1];
    AddComponent(".", NULL, TRUE, TRUE);

    i = 0;
    for (pcp = pcpPaths; pcp != NULL; pcp = pcp->pcpNext) {
        i = (i & ~31) + 32;

        // Build Initial FindPattern directory path: "c:\nt\"

        sprintf(FindPattern,
                "%s\\%s%s",
                ".",
                pcp->achDir,
                *pcp->achDir? "\\" : "");

        CHECKSTRLEN(FindPattern, cbFindPattern);

        // point past directory in FindPattern: "c:\nt\system32\"

        pszFile = &FindPattern[strlen(FindPattern)];

        strcpy(pszFile, "*.*");         // search for all directories
        CHECKSTRLEN(FindPattern, cbFindPattern);
        hFind = PortFindFirstFile(FindPattern, FALSE, FindName, &FindSize);
        *pszFile = '\0';

        if (hFind != INVALID_HANDLE_VALUE) {
            do {
                if (strcmp(FindName, ".") == 0 ||
                    strcmp(FindName, "..") == 0) {
                    continue;
                }
                _strlwr(FindName);
                for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
                    if (pcm->fDir && strcmp(FindName, pcm->achPat) == 0) {
                        pcm->fFound = TRUE;
                        break;
                    }
                }
                if (pcm == NULL) {
                    AddComponent(FindName, NULL, TRUE, TRUE);
                }
            } while (PortFindNextFile(hFind, FALSE, FindName, &FindSize));
            PortFindClose(hFind);
        }
    }
    if (fInProgress) {
        printf("\n");
        fInProgress = FALSE;
    }
    return;
}


#define ATTRMATCH(fnormal, attr) \
    (!fNormal ^ ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))

HANDLE
PortFindFirstFile(LPSTR FindPattern,
                  BOOL fNormal,
                  LPSTR FindName,
                  LPDWORD FindSize)
{
    HANDLE hFind;
    WIN32_FIND_DATA wfd;

    hFind = FindFirstFile(FindPattern, &wfd);
    if (hFind != INVALID_HANDLE_VALUE) {
        if (!ATTRMATCH(fNormal, wfd.dwFileAttributes)) {
            if (!PortFindNextFile(hFind,
                                  fNormal,
                                  FindName,
                                  FindSize)) {
                FindClose(hFind);
                return(INVALID_HANDLE_VALUE);
            }
        } else {
            strcpy(FindName, wfd.cFileName);
            *FindSize = wfd.nFileSizeLow;
        }
    }
    return(hFind);
}


BOOL
PortFindNextFile(HANDLE hFind,
                 BOOL fNormal,
                 LPSTR FindName,
                 LPDWORD FindSize)
{
    BOOL b;
    WIN32_FIND_DATA wfd;

    do {
        b = FindNextFile(hFind, &wfd);
    } while (b && !ATTRMATCH(fNormal, wfd.dwFileAttributes));
    if (b) {
        strcpy(FindName, wfd.cFileName);
        *FindSize = wfd.nFileSizeLow;
    }
    return(b);
}


VOID
PortFindClose(HANDLE hFind)
{
    FindClose(hFind);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\dmpfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       dmpfile.cpp
//
//--------------------------------------------------------------------------

// DmpFile.cpp: implementation of the CDmpFile class.
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"

#include "DmpFile.h"
#include "ProcessInfo.h"
#include "Modules.h"
#include "FileData.h"
#include "ModuleInfoCache.h"
#include "ModuleInfo.h"

// Let's implement the DebugOutputCallback for the DBGENG... it'll be cool to have the debugger
// spit out info to us when it is running...
STDMETHODIMP
OutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
OutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
OutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
OutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    HRESULT Status = S_OK;

	// If the client has asked for any output... do so.
	if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode) && Mask)
	{
		printf(Text);
	}

    return Status;
}

OutputCallbacks g_OutputCb;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDmpFile::CDmpFile()
{
	m_szDmpFilePath = NULL;
	m_szSymbolPath = NULL;
	m_szExePath = NULL;
	m_fDmpInitialized = false;
	m_pIDebugClient = NULL;
	m_pIDebugControl = NULL;
	m_pIDebugSymbols2 = NULL;
	m_pIDebugDataSpaces = NULL;
	m_DumpClass = DEBUG_CLASS_UNINITIALIZED;
	m_DumpClassQualifier = 0;
}

CDmpFile::~CDmpFile()
{
	if (m_fDmpInitialized)
	{
	    // Let's ensure that our debug output is set to normal (at least)
		//m_pIDebugClient->GetOutputMask(&OutMask);
		//OutMask = ~DEBUG_OUTPUT_NORMAL;
		m_pIDebugClient->SetOutputMask(0);

		// Let's be as least intrusive as possible...
		m_pIDebugClient->EndSession(DEBUG_END_ACTIVE_DETACH);
	}

	if (m_szDmpFilePath)
		delete [] m_szDmpFilePath;

	if (m_szSymbolPath)
		delete [] m_szSymbolPath;

	if (m_szExePath)
		delete [] m_szExePath;
}

bool CDmpFile::Initialize(CFileData * lpOutputFile)
{
	HRESULT Hr = S_OK;
	ULONG g_ExecStatus = DEBUG_STATUS_NO_DEBUGGEE;
	LPTSTR tszExpandedString = NULL;
	bool fReturn = false;
    DWORD OutMask;

	// Let's save off big objects so we don't have to keep passing this to
	// our methods...
	m_lpOutputFile = lpOutputFile;

	// The DBGENG is somewhat ANSI oriented...
	m_szDmpFilePath = CUtilityFunctions::CopyTSTRStringToAnsi(g_lpProgramOptions->GetDmpFilePath(), m_szDmpFilePath, 0);

	// Create our interface pointer to do our Debug Work...
	if (FAILED(Hr = DebugCreate(IID_IDebugClient, (void **)&m_pIDebugClient)))
	{
		_tprintf(TEXT("ERROR: DBGENG - DebugCreate() failed!  hr=0x%x\n"), Hr);
		goto cleanup;
	}
	// Let's query for IDebugControl interface (we need it to determine debug type easily)...
	// Let's query for IDebugSymbols2 interface as we need it to receive module info...
	// Let's query for IDebugDataSpaces interface as we need it to read DMP memory...
	if (
		FAILED(Hr = m_pIDebugClient->QueryInterface(IID_IDebugControl,(void **)&m_pIDebugControl)) ||
		FAILED(Hr = m_pIDebugClient->QueryInterface(IID_IDebugSymbols2,(void **)&m_pIDebugSymbols2)) || 
		FAILED(Hr = m_pIDebugClient->QueryInterface(IID_IDebugDataSpaces,(void **)&m_pIDebugDataSpaces))
	   )
	{
		_tprintf(TEXT("ERROR: DBGENG Interfaces required were not found!\n"));
		_tprintf(TEXT("ERROR: DBGENG - Find Interface Required!  hr=0x%x\n"), Hr);
		goto cleanup;
	}

	// Set callbacks.
	if (FAILED(Hr = m_pIDebugClient->SetOutputCallbacks(&g_OutputCb)))
	{
		_tprintf(TEXT("ERROR: DBGENG - Unable to SetOutputCallbacks!  hr=0x%x\n"), Hr);
		goto cleanup;
	}

	// Let's ensure that our debug output is set to normal (at least)
	OutMask = m_pIDebugClient->GetOutputMask(&OutMask);
  
	m_pIDebugClient->SetOutputMask(OutMask);

	// Set our symbol path... this is required prior to a "reload" of modules... 

	// The DBGENG is somewhat ASCII oriented... we need an environment-expanded string converted
	// to an ASCII string...
	tszExpandedString = CUtilityFunctions::ExpandPath(g_lpProgramOptions->GetSymbolPath());

	if (!tszExpandedString)
		goto cleanup;

	m_szSymbolPath = CUtilityFunctions::CopyTSTRStringToAnsi( tszExpandedString, m_szSymbolPath, 0);

	// It's a bit premature to set this now... but it's required by DBGENG.DLL before a reload...
	if (FAILED(Hr = m_pIDebugSymbols2->SetSymbolPath(m_szSymbolPath)))
	{
		_tprintf(TEXT("ERROR: DBGENG - Unable to SetSymbolPath!  hr=0x%x\n"), Hr);
		goto cleanup;
	}

	// Now, let's deal with the EXEPATH, if they provided it... use it, otherwise using the Symbol Path
	if (g_lpProgramOptions->GetExePath())
	{
		if (tszExpandedString)
		{
			delete [] tszExpandedString;
			tszExpandedString = NULL;
		}
		
		tszExpandedString = CUtilityFunctions::ExpandPath(g_lpProgramOptions->GetExePath());
	}

	if (!tszExpandedString)
		goto cleanup;

	m_szExePath = CUtilityFunctions::CopyTSTRStringToAnsi( tszExpandedString, m_szExePath, 0);

	if (FAILED(Hr = m_pIDebugSymbols2->SetImagePath(m_szExePath)))
	{
		_tprintf(TEXT("ERROR: DBGENG - Unable to SetImagePath!  hr=0x%x\n"), Hr);
		goto cleanup;
	}
	
	// Let's open the dump...
	if (FAILED(Hr = m_pIDebugClient->OpenDumpFile(m_szDmpFilePath)))
	{
		_tprintf(TEXT("ERROR: DBGENG - Unable to OpenDumpFile!  hr=0x%x\n"), Hr);
		goto cleanup;
	}

	// Get Initial Execution state.
    if (FAILED(Hr = m_pIDebugControl->GetExecutionStatus(&g_ExecStatus)))
    {
		_tprintf(TEXT("ERROR: DBGENG - Unable to get execution status!  hr=0x%x\n"), Hr);
		goto cleanup;
    }

	if (g_ExecStatus != DEBUG_STATUS_NO_DEBUGGEE)
	{
		// I think we'll work just fine?
		_tprintf(TEXT("Debug Session is already active!\n"));
		// goto cleanup; 
	}

	// What type of dump did we get?
	if (FAILED(Hr = m_pIDebugControl->GetDebuggeeType(&m_DumpClass, &m_DumpClassQualifier)))
	{
		_tprintf(TEXT("ERROR: DBGENG - Unable to GetDebuggeeType!  hr=0x%x\n"), Hr);
		goto cleanup;
	}

    // m_pIDebugClient->SetOutputMask(0); // Temporarily suppress this stuff...

	OutMask |= DEBUG_OUTPUT_PROMPT_REGISTERS | DEBUG_OUTPUT_NORMAL | DEBUG_OUTPUT_ERROR;

	// Adding -NOISY makes us very chatty...
	if (g_lpProgramOptions->fDebugSearchPaths())
	{
		OutMask |= DEBUG_OUTPUT_WARNING; // | DEBUG_OUTPUT_VERBOSE
	}
	
	m_pIDebugClient->SetOutputMask(OutMask);	// Set output...
	m_pIDebugControl->SetLogMask(OutMask);		// Set log settings
	//
	// All the good stuff happens here... modules load, etc.. we could suppress all the output
	// but it's cool to watch...
	//
	if (FAILED(Hr = m_pIDebugControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE)))
	{
		_tprintf(TEXT("ERROR: DBGENG - WaitForEvent() failed!  hr=0x%x\n"), Hr);

		if ( (Hr == E_FAIL) && m_DumpClass == DEBUG_CLASS_KERNEL)
		{
			_tprintf(TEXT("ERROR: DBGENG - If you see a complaint above for \"KiProcessorBlock[0] could not be read\"\n"));
			_tprintf(TEXT("ERROR: DBGENG - ensure you have valid symbols for the NT kernel (NTOSKRNL.EXE).\n"));
		}

		if ((Hr == E_FAIL) && !g_lpProgramOptions->fDebugSearchPaths())
		{
			_tprintf(TEXT("ERROR: DBGENG - Consider adding -NOISY to produce more output.\n"));
		}

		goto cleanup;
	}
	
	// Adding -NOISY makes us very chatty...
	if (g_lpProgramOptions->fDebugSearchPaths())
	{
		if (FAILED(Hr = m_pIDebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "!sym noisy", DEBUG_EXECUTE_DEFAULT)))
		{
			_tprintf(TEXT("ERROR: DBGENG - Unable to enable noisy symbol loading Callstack (KB command failed)!  hr=0x%x\n"), Hr);
		}
	}
	
	//
	// Let's treat User.dmp files special... since there is no "Bugcheck Analysis" for these, yet...
	//
	if (m_DumpClass == DEBUG_CLASS_USER_WINDOWS)
	{
		_tprintf(TEXT("*******************************************************************************\n"));
        _tprintf(TEXT("*                                                                             *\n"));
        _tprintf(TEXT("*                        Userdump Analysis                                    *\n"));
        _tprintf(TEXT("*                                                                             *\n"));
        _tprintf(TEXT("*******************************************************************************\n"));
        _tprintf(TEXT("\n"));

		if (FAILED(Hr = m_pIDebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "kb", DEBUG_EXECUTE_DEFAULT)))
		{
			_tprintf(TEXT("ERROR: DBGENG - Unable to Dump Callstack (KB command failed)!  hr=0x%x\n"), Hr);
		}
        _tprintf(TEXT("\n"));
	}

	// We did not Fail the WaitForEvent()... go ahead and dump our current state...
	if (FAILED(Hr = m_pIDebugControl->OutputCurrentState(DEBUG_OUTCTL_ALL_CLIENTS, DEBUG_CURRENT_DEFAULT)))
	{
		_tprintf(TEXT("ERROR: DBGENG - Unable to OutputCurrentState!  hr=0x%x\n"), Hr);
	}

	/*
	// Adding -NOISY makes us very chatty...
	if (g_lpProgramOptions->fDebugSearchPaths())
	{	
		Hr = m_pIDebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "!dll -f", DEBUG_EXECUTE_DEFAULT);
	}
	*/

	// Yee haa... we got something...
	m_fDmpInitialized = true;

	fReturn = true;

cleanup:
	if (tszExpandedString)
		delete [] tszExpandedString;

	return fReturn;
}

bool CDmpFile::CollectData(CProcessInfo ** lplpProcessInfo, CModules ** lplpModules, CModuleInfoCache * lpModuleInfoCache)
{
	bool fReturn = false;
	// Okay... first order of business is to decide what we need to collect...

	// Collect information from the file based on it's type...
	if (IsUserDmpFile())
	{
		// Second, order of business is to prepare for collecting info about the
		// process in the USER.DMP file...
		(*lplpProcessInfo) = new CProcessInfo();

		if ((*lplpProcessInfo) == NULL)
			goto cleanup;

		if (!(*lplpProcessInfo)->Initialize(lpModuleInfoCache, NULL, m_lpOutputFile, this))
			goto cleanup;
	} else
	{
		(*lplpModules) = new CModules();

		if ((*lplpModules) == NULL)
			goto cleanup;

		if (!(*lplpModules)->Initialize(lpModuleInfoCache, NULL, m_lpOutputFile, this))
			goto cleanup;
	}

	if (!EumerateModulesFromDmp(lpModuleInfoCache, *lplpProcessInfo, *lplpModules))
		goto cleanup;

	fReturn = true;

cleanup:

	return fReturn;
}

//
// Combined DMP Enumeration Code
//
bool CDmpFile::EumerateModulesFromDmp(CModuleInfoCache * lpModuleInfoCache, CProcessInfo * lpProcessInfo, CModules * lpModules)
{
	//
	// Consult DumpModuleTable in Ntsym.cpp for ideas...
	//
	CModuleInfo * lpModuleInfo;
	HRESULT Hr;
	ULONG ulNumberOfLoadedModules;
	ULONG ulNumberOfUnloadedModules;
	ULONG64 dw64ModuleLoadAddress;
	char szImageNameBuffer[_MAX_PATH];
	TCHAR tszModulePath[_MAX_PATH];
	TCHAR tszModuleFileName[_MAX_FNAME];
	TCHAR tszModuleFileExtension[_MAX_EXT];
	bool fNew, fProcessNameFound = false;
	bool fUserDmp = IsUserDmpFile();

	// How many modules were found?
	if (FAILED(Hr = m_pIDebugSymbols2->GetNumberModules(&ulNumberOfLoadedModules, &ulNumberOfUnloadedModules)))
	{
		_tprintf(TEXT("Unable to enumerate any modules in the DMP file!\n"));
		return false;
	}

	// If we use a -MATCH option, we may not be matching against our EXE... in that case we'll fail to find
	// the process name... let's provide this default...
	if (lpProcessInfo)
		lpProcessInfo->SetProcessName(TEXT("UNKNOWN"));

	if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
	{
		_tprintf(TEXT("\n%-8s %-8s  %-30s %s\n"), TEXT("Start"),
												 TEXT("End"),
												 TEXT("Module Name"),
												 TEXT("Time/Date"));
	}

	//
	// Enumerate through the modules in the DMP file...
	//
	for (unsigned int i = 0; i < ulNumberOfLoadedModules; i++)
	{
		// First, we get the Base address by our index
		if (FAILED(Hr = m_pIDebugSymbols2->GetModuleByIndex(i, &dw64ModuleLoadAddress)))
		{
			_tprintf(TEXT("Failed getting base address of module number %d\n"), i);
			continue; // try the next?
		}

		// Second, we get the name from our base address
		ULONG ulImageNameSize;

		//
		// This can return both the ImageNameBuffer and a ModuleNameBuffer...
		// The ImageNameBuffer typically contains the entire module name like (MODULE.DLL),
		// whereas the ModuleNameBuffer is typically just the module name like (MODULE).
		//
		if (FAILED(Hr = m_pIDebugSymbols2->GetModuleNames(	DEBUG_ANY_ID,		// Use Base address
															dw64ModuleLoadAddress, 				// Base address from above
															szImageNameBuffer,
															_MAX_PATH, 
															&ulImageNameSize, 
															NULL,
															0,
															NULL,
															NULL,
															0,
															NULL)))
		{
			_tprintf(TEXT("Failed getting name of module at base 0x%x\n"), dw64ModuleLoadAddress);
			continue; // try the next?
		}

		// Convert the string to something we can use...
		CUtilityFunctions::CopyAnsiStringToTSTR(szImageNameBuffer, tszModulePath, _MAX_PATH);
		
		// Third, we can now get whatever we want from memory...

		if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszModulePath))
			continue;

		// Okay, let's go ahead and get a ModuleInfo Object from our cache...

		// If pfNew returns TRUE, then this object is new and we'll need
		// to populate it with data...
		lpModuleInfo = lpModuleInfoCache->AddNewModuleInfoObject(tszModulePath, &fNew);

		if (false == fNew)
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			if (fUserDmp )
			{
				lpProcessInfo->AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
			} else
			{
				lpModules->AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
			}
			
			continue;
		}

		// Not in the cache... so we need to init it, and get the module info...
		if (!lpModuleInfo->Initialize(NULL, m_lpOutputFile, this))
		{
			return false; // Hmmm... memory error?
		}

		//
		// Okay, get the module info from the DMP file...
		//
		if (lpModuleInfo->GetModuleInfo(tszModulePath, true, dw64ModuleLoadAddress) )
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			if (fUserDmp)
			{
				lpProcessInfo->AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
			} else
			{
				lpModules->AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
			}
		} else
		{
			// Continue back to try another module on error...
			continue;
		}

		// Try and patch up the original name of the module...

		// Save the current module path as the DBG stuff

		// We'll tack on .DBG to roll through our own code correctly...
		_tsplitpath(tszModulePath, NULL, NULL, tszModuleFileName, tszModuleFileExtension);

		if ( (lpModuleInfo->GetPESymbolInformation() == CModuleInfo::SYMBOLS_DBG) ||
			(lpModuleInfo->GetPESymbolInformation() == CModuleInfo::SYMBOLS_DBG_AND_PDB) )
		{
			// Append .DBG to our module name
			_tcscat(tszModuleFileName, TEXT(".DBG"));

			lpModuleInfo->SetDebugDirectoryDBGPath(tszModuleFileName);
	
		} else if (lpModuleInfo->GetPESymbolInformation() == CModuleInfo::SYMBOLS_PDB)
		{
			if (lpModuleInfo->GetDebugDirectoryPDBPath())
			{
			} else
			{
				//
				// Unfortunately, we can't find the PDB Imagepath in the DMP file... so we'll
				// just guess what it would be...
				//
				// Append .PDB to our module name
				_tcscat(tszModuleFileName, TEXT(".PDB"));

				lpModuleInfo->SetPEDebugDirectoryPDBPath(tszModuleFileName);
			}
		}

		// Now, let's remove the extra path bits...
		_tsplitpath(tszModulePath, NULL, NULL, tszModuleFileName, tszModuleFileExtension);

		_tcscpy(tszModulePath, tszModuleFileName);
		_tcscat(tszModulePath, tszModuleFileExtension);

		// Save the current module path as the DBG stuff
		lpModuleInfo->SetPEImageModulePath(tszModulePath);

		// Save the current module name as well...
		lpModuleInfo->SetPEImageModuleName(tszModulePath);

		// Hey... if this is not a DLL, then it's probably the EXE!!!
		if (fUserDmp && !fProcessNameFound)
		{
			if (!lpModuleInfo->IsDLL() )
			{
				lpProcessInfo->SetProcessName(tszModulePath);
				fProcessNameFound = true;
			}
		}

		// Filter out garbage.
		if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
		{
			time_t time = lpModuleInfo->GetPEImageTimeDateStamp();

			if (time)
			{
				_tprintf(TEXT("%08x %08x  %-30s %s"), (ULONG)dw64ModuleLoadAddress,
												 (ULONG)dw64ModuleLoadAddress+(ULONG)lpModuleInfo->GetPEImageSizeOfImage(),
												 tszModulePath,
												 _tctime(&time));


			} else
			{
				_tprintf(TEXT("%08x %08x  %-30s Unknown\n"), (ULONG)dw64ModuleLoadAddress,
												 (ULONG)dw64ModuleLoadAddress+(ULONG)lpModuleInfo->GetPEImageSizeOfImage(),
												 tszModulePath);

			}
		}


	}

	return (ulNumberOfLoadedModules != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\delayload.h ===
// DelayLoad.h: interface for the CDelayLoad class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DELAYLOAD_H__7DFF0A14_DD50_4E3A_AC8D_5B89BD2D5A3B__INCLUDED_)
#define AFX_DELAYLOAD_H__7DFF0A14_DD50_4E3A_AC8D_5B89BD2D5A3B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include <TLHELP32.H>
#include <PSAPI.H>

class CDelayLoad  
{
public:
	CDelayLoad();
	virtual ~CDelayLoad();

	// PSAPI Functions (Publicly accessible for ease of use)
	bool Initialize_PSAPI();
	BOOL  WINAPI EnumProcesses(DWORD * lpidProcess, DWORD cb, DWORD * cbNeeded);
	BOOL  WINAPI EnumProcessModules(HANDLE hProcess, HMODULE * lphModule, DWORD cb, LPDWORD lpcbNeeded);
	DWORD WINAPI GetModuleFileNameEx(HANDLE hHandle, HMODULE hModule, LPTSTR lpFilename, DWORD nSize);
	DWORD WINAPI GetModuleInformation(HANDLE hProcess, HMODULE hModule, LPMODULEINFO lpmodinfo, DWORD cb);
	
	BOOL  WINAPI EnumDeviceDrivers(LPVOID *lpImageBase, DWORD cb, LPDWORD lpcbNeeded);
	DWORD WINAPI GetDeviceDriverFileName(LPVOID ImageBase, LPTSTR lpFilename, DWORD nSize);

	// TOOLHELP32 Functions (Publicly accessible for ease of use)
	bool Initialize_TOOLHELP32();
	HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
	BOOL   WINAPI Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	BOOL   WINAPI Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	BOOL   WINAPI Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
	BOOL   WINAPI Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

private:

	// Windows NT 4.0/2000 Support for Querying Processes and Modules

	// PSAPI functions
	HINSTANCE m_hPSAPI;
	bool m_fPSAPIInitialized;
	bool m_fPSAPIInitializedAttempted;

	// PSAPI functions TypeDef'ed for simplicity
	typedef BOOL  (WINAPI *PfnEnumProcesses)(DWORD * lpidProcess, DWORD cb, DWORD * cbNeeded);
	typedef BOOL  (WINAPI *PfnEnumProcessModules)(HANDLE hProcess, HMODULE * lphModule, DWORD cb, LPDWORD lpcbNeeded);
	typedef DWORD (WINAPI *PfnGetModuleFileNameEx)(HANDLE hHandle, HMODULE hModule, LPTSTR lpFilename, DWORD nSize);
	typedef BOOL  (WINAPI *PfnGetModuleInformation)(HANDLE hProcess, HMODULE hModule, LPMODULEINFO lpmodinfo, DWORD cb);
	typedef	BOOL  (WINAPI *PfnEnumDeviceDrivers)(LPVOID *lpImageBase, DWORD cb, LPDWORD lpcbNeeded);
	typedef DWORD (WINAPI *PfnGetDeviceDriverFileName)(LPVOID ImageBase, LPTSTR lpFilename, DWORD nSize);
	
	// PSAPI Function Pointers
	BOOL  (WINAPI *m_lpfEnumProcesses)(DWORD * lpidProcess, DWORD cb, DWORD * cbNeeded);
	BOOL  (WINAPI *m_lpfEnumProcessModules)(HANDLE hProcess, HMODULE * lphModule, DWORD cb, LPDWORD lpcbNeeded);
	DWORD (WINAPI *m_lpfGetModuleFileNameEx)(HANDLE hHandle, HMODULE hModule, LPTSTR lpFilename, DWORD nSize);
	BOOL  (WINAPI *m_lpfGetModuleInformation)(HANDLE hProcess, HMODULE hModule, LPMODULEINFO lpmodinfo, DWORD cb);
	BOOL  (WINAPI *m_lpfEnumDeviceDrivers)(LPVOID *lpImageBase, DWORD cb, LPDWORD lpcbNeeded);
	DWORD (WINAPI *m_lpfGetDeviceDriverFileName)(LPVOID ImageBase, LPTSTR lpFilename, DWORD nSize);
	
	// Windows 95 / Windows 2000 Support for Querying Processes and Modules
	
	// TOOLHELP32 functions
	HINSTANCE m_hTOOLHELP32;
	bool m_fTOOLHELP32Initialized;
	bool m_fTOOLHELP32InitializedAttempted;

	// TOOLHELP32 functions TypeDef'ed for simplicity
	typedef HANDLE (WINAPI *PfnCreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID);
	typedef BOOL   (WINAPI *PfnProcess32First)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	typedef BOOL   (WINAPI *PfnProcess32Next)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	typedef BOOL   (WINAPI *PfnModule32First)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
	typedef BOOL   (WINAPI *PfnModule32Next)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

	// TOOLHELP32 Function Pointers
	HANDLE (WINAPI *m_lpfCreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID);
	BOOL   (WINAPI *m_lpfProcess32First)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	BOOL   (WINAPI *m_lpfProcess32Next)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	BOOL   (WINAPI *m_lpfModule32First)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
	BOOL   (WINAPI *m_lpfModule32Next)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
};

#endif // !defined(AFX_DELAYLOAD_H__7DFF0A14_DD50_4E3A_AC8D_5B89BD2D5A3B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\checksym\src\checksym\filedata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       filedata.cpp
//
//--------------------------------------------------------------------------

// FileData.cpp: implementation of the CFileData class.
//
//////////////////////////////////////////////////////////////////////

#include "pch.h"

#include "FileData.h"
#include "Version.h"
#include "Processes.h"
#include "ProcessInfo.h"
#include "Modules.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFileData::CFileData()
{
	m_dwGetLastError = 0;
	m_hFileHandle = INVALID_HANDLE_VALUE;
	m_tszFilePath = NULL;
	m_szLINEBUFFER[0] = 0;
	m_hFileMappingObject = NULL;
	m_lpBaseAddress = NULL;
	m_lpCurrentFilePointer = NULL;
	m_lpCurrentLocationInLINEBUFFER = NULL;
}

CFileData::~CFileData()
{
	if (m_tszFilePath)
		delete [] m_tszFilePath;

	if (m_lpBaseAddress)
		UnmapViewOfFile(m_lpBaseAddress);

	if (m_hFileMappingObject)
		CloseHandle(m_hFileMappingObject);
}

bool CFileData::SetFilePath(LPTSTR tszFilePath)
{
	// Did we get a proper string?
	if (!tszFilePath)
		return false;

	if (m_tszFilePath)
		delete [] m_tszFilePath;

	m_tszFilePath = new TCHAR[(_tcsclen(tszFilePath)+1)];

	if (!m_tszFilePath)
		return false;

	_tcscpy(m_tszFilePath, tszFilePath);
	return true;
}

LPTSTR CFileData::GetFilePath()
{
	return m_tszFilePath;
}

bool CFileData::VerifyFileDirectory()
{
	if (!m_tszFilePath)
		return false;

	TCHAR tszDrive[_MAX_DRIVE];
	TCHAR tszDirectory[_MAX_DIR];

	TCHAR tszDirectoryPath[_MAX_PATH];

	// Get just the directory...
	_tsplitpath(m_tszFilePath, tszDrive, tszDirectory, NULL, NULL);

	// Now, recompose this into a directory path...
	_tcscpy(tszDirectoryPath, tszDrive);
	_tcscat(tszDirectoryPath, tszDirectory);
	_tcscat(tszDirectoryPath, TEXT("*.*"));

	WIN32_FIND_DATA FindFileData;

	HANDLE hDirectoryHandle = FindFirstFile(tszDirectoryPath, &FindFileData);
	
	if (hDirectoryHandle == INVALID_HANDLE_VALUE)
	{
		// Failure to find the directory...
		SetLastError();
		return false;
	}

	// Close this now that we're done...
	FindClose(hDirectoryHandle);
	return true;
}

/*
DWORD CFileData::GetLastError()
{
	return m_dwGetLastError;
}
*/
bool CFileData::OpenFile(DWORD dwCreateOption, bool fReadOnlyMode)
{
	if (!m_tszFilePath)
	{
		return false;
	}

	// Open the file for read/write
	m_hFileHandle = CreateFile(m_tszFilePath, 
							  fReadOnlyMode ? ( GENERIC_READ )
										    : ( GENERIC_READ | GENERIC_WRITE ),
							  0,	// Not shareable
							  NULL, // Default security descriptor
							  dwCreateOption,
							  FILE_ATTRIBUTE_NORMAL,
							  NULL);

	if (m_hFileHandle == INVALID_HANDLE_VALUE)
	{
		SetLastError();
		return false;
	}

	return true;
}

bool CFileData::CloseFile()
{
	if (m_hFileHandle == INVALID_HANDLE_VALUE)
	{
		return false;
	}

	if (!CloseHandle(m_hFileHandle))
	{
		SetLastError();
		return false;
	}
	
	m_hFileHandle = INVALID_HANDLE_VALUE;
	return true;
}

bool CFileData::WriteString(LPTSTR tszString, bool fHandleQuotes /* = false */)
{
	DWORD dwByteCount = 0;
	DWORD dwBytesWritten;
	LPSTR szStringBuffer = NULL; // Pointer to the ANSI string (after conversion if necessary)
	bool fReturn = false;

	if (m_hFileHandle == INVALID_HANDLE_VALUE)
	{
		goto cleanup;
	}

	// We'll first convert the string if we need to...

	szStringBuffer = CUtilityFunctions::CopyTSTRStringToAnsi(tszString);

	if (!szStringBuffer)
		goto cleanup;

	dwByteCount = _tcsclen(tszString); // This is the number of characters (not bytes!)

	// See if we were asked to handle quotes, and if there exists a comma or quote in the string
	if ( fHandleQuotes == true && ((strchr(szStringBuffer, ',') || strchr(szStringBuffer, '"' ))) )
	{
		unsigned int iQuotedStringIndex = 0;
		unsigned int iStringBufferIndex = 0;
		
		// Special processing is required... this doesn't happen often, so this 
		// allocation which I'm about to make won't be done regularly...
		LPSTR szQuotedStringBuffer = new char[1024];

		// Did we successfully allocate storage?
		if (!szQuotedStringBuffer)
			goto cleanup;
			
		// Keep going until we're at the end of the string...

		// We start by adding a quote (since we know that we have a comma or quote somewhere...

		szQuotedStringBuffer[iQuotedStringIndex++] = '\"';

		// Keep going until the end of the string...
		while (szStringBuffer[iStringBufferIndex] != '\0')
		{
			// We found a quote
			if (szStringBuffer[iStringBufferIndex] == '"')
			{
				// We found a quote... I'll copy another quote in, and the quote already here
				// will ensure we have two quotes together "" which in a CSV file represents a
				// single quote...
				szQuotedStringBuffer[iQuotedStringIndex++] = '\"';
			}

			// Copy the source char to the dest...
			szQuotedStringBuffer[iQuotedStringIndex++] = szStringBuffer[iStringBufferIndex++];
		}

		// Append the final quote (and \0)...
		szQuotedStringBuffer[iQuotedStringIndex++] = '\"';
		szQuotedStringBuffer[iQuotedStringIndex++] = '\0';

		// Just write out the data the nice, fast way...
		if (!WriteFile(m_hFileHandle, szQuotedStringBuffer, strlen(szQuotedStringBuffer), &dwBytesWritten, NULL))
		{
			delete [] szQuotedStringBuffer;
			goto cleanup;
		}

		delete [] szQuotedStringBuffer;
	} else
	{
		// Just write out the data the nice, fast way...
		if (!WriteFile(m_hFileHandle, szStringBuffer, dwByteCount, &dwBytesWritten, NULL))
		{
			goto cleanup;
		}
	}

	fReturn = true;

cleanup:

	if (szStringBuffer)
		delete [] szStringBuffer;

	return fReturn;
}

bool CFileData::WriteDWORD(DWORD dwNumber)
{
	TCHAR tszBuffer[10+1]; // 0xFFFFFFFF == 4294967295 (10 characters) + 1 for the \0

	_stprintf(tszBuffer, TEXT("%u"), dwNumber);
	
	if (!WriteString(tszBuffer))
		return false;

	return true;
}

bool CFileData::WriteTimeDateString(time_t Time)
{
	enum {BUFFERSIZE = 128};

	TCHAR tszBuffer[BUFFERSIZE];
	struct tm * localTime = localtime(&Time);

	if (localTime)
	{
		// This top version seems to be better Y2K friendly as I spit out the full year...
		_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%B %d, %Y %H:%M:%S"), localTime);
		//_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%c"), localtime(&Time));

		if (!WriteString(tszBuffer, true))
			return false;
	} else
	{	// A bad TimeDate stamp was provided
		if (!WriteString(TEXT("<INVALID DATE>"), true))
			return false;
	}
	
	return true;
}

bool CFileData::WriteFileHeader()
{
	enum {BUFFERSIZE = 128};
	TCHAR tszBuffer[BUFFERSIZE];
	DWORD dwNum = BUFFERSIZE;

	// Write out separator...
	if (!WriteString(TEXT("sep=,\r\n")))
		return false;

	// Write the Checksym version info...
	_stprintf(tszBuffer, TEXT("CHECKSYM, (%d.%d:%d.%d)\r\n"), VERSION_FILEVERSION);

	if (!WriteString(tszBuffer))
		return false;

	// Write the current date/time info...

	if (!WriteString(TEXT("Created:,")))
		return false;

	time_t Time;
	time(&Time);

	if (!WriteTimeDateString(Time))
		return false;

	// Write the carriage-return line-feed combo... 
	if (!WriteString(TEXT("\r\n")))
		return false;

	// Spit out the computername
	if (!GetComputerName(tszBuffer, &dwNum))
		return false;

	if (!WriteString(TEXT("Computer:,")))
		return false;

	if (!WriteString(tszBuffer))
		return false;

	// Write the carriage-return line-feed combo... (a couple of times)...
	if (!WriteString(TEXT("\r\n")))
		return false;


	return true;
}

void CFileData::PrintLastError()
{
	CUtilityFunctions::PrintMessageString(GetLastError());
}

bool CFileData::CreateFileMapping()
{
	m_hFileMappingObject = ::CreateFileMapping(m_hFileHandle,
											   NULL,
											   PAGE_READONLY | SEC_COMMIT,
											   0,
											   0,
											   NULL);

	if (m_hFileMappingObject == NULL)
	{
		SetLastError();
		return false;
	}

	// Okay, we'll map the view as well...
	m_lpBaseAddress = MapViewOfFile(m_hFileMappingObject,
							   	    FILE_MAP_READ,
									0,
									0,
									0);

	if (m_lpBaseAddress == NULL)
	{
		SetLastError();
		return false;
	}

	m_lpCurrentFilePointer = (LPSTR) m_lpBaseAddress;

	return true;
}

bool CFileData::ReadFileHeader()
{
	// For starters, let's read a line...
	if (!ReadFileLine())
	     return false;

	enum { BUFFER_SIZE = 128};
	char szTemporaryBuffer[BUFFER_SIZE];
	DWORD cbBytesRead;

	// Skip the sep=, that is the first line of the file...
	cbBytesRead = ReadString(szTemporaryBuffer, BUFFER_SIZE);

	// We gotta read something?
	if (0 == cbBytesRead)
		return false;

	// Look for our "sep=" value which specifies the separator we used for this CSV file!
	if (_stricmp(szTemporaryBuffer, "sep=") != 0)
		goto MagicValue;

	// Now, read the next line...
	if (!ReadFileLine())
	     return false;
	
	// Only read again if the previous line was our separator (backwards compatibility)
	cbBytesRead = ReadString(szTemporaryBuffer, BUFFER_SIZE);

	// We gotta read something?
	if (0 == cbBytesRead)
		return false;

MagicValue:
	// Look for our "Magic" Value
	if (_stricmp(szTemporaryBuffer, "CHECKSYM"))
	{
		_tprintf(TEXT("Error: Input file has invalid header.  Missing CHECKSYM keyword!\n"));
		return false;
	}

	// Read version number
	// We'll do this later if needed...

	// Read Created Time
	if (!ReadFileLine())
	     return false;

	// Read Computer this was created on
	if (!ReadFileLine())
	     return false;

	return true;
}

bool CFileData::ReadFileLine()
{
	// We're ansi oriented (since this is a CSV file -- in case you were wondering)
	size_t pos;

	// Find the first \r or \n character (if we're point to \0, we'll figure that out)
	pos = strcspn(m_lpCurrentFilePointer, "\r\n");

	// Hmm... we don't read a line that starts on \r\n very well...
	if (pos == 0)
	{
		m_szLINEBUFFER[0] = '\0';
		ResetBufferPointerToStart();
		return false; 
	}

	// Read the line into our buffer
	strncpy(m_szLINEBUFFER, m_lpCurrentFilePointer, pos);

	// Null terminate for ease of use...
	m_szLINEBUFFER[pos] = '\0'; 

	ResetBufferPointerToStart();

	// Advance the current file pointer to just beyond the last character we read...
	// This should advance to the \r\n or \0
	m_lpCurrentFilePointer += pos;

	// We want this file pointer to advance beyond any \r \n chars we may have found...
	while (*m_lpCurrentFilePointer)
	{
		// Advance pointer to non- \r or \n
		if ( (*m_lpCurrentFilePointer == '\r') ||
			 (*m_lpCurrentFilePointer == '\n') )
		{
			 m_lpCurrentFilePointer++;
		}
		else
		{
			break; // Found either the \0 or something else...
		}
	}

	return true;
}

DWORD CFileData::ReadString(LPSTR szStringBuffer, DWORD iStringBufferSize)
{
	// If we give a buffer size, we have to give a buffer...
	if ( szStringBuffer == NULL && iStringBufferSize )
		return 0;

	// The ReadFileLine() call puts us at the start of a line (after
	// the \r \n combinations...  It's possible that we're at the
	// end...

	// If we're pointing to the end of the file, let's bail...
	if (*m_lpCurrentLocationInLINEBUFFER == '\0')
		return 0;

	DWORD iBytesCopied = 0;
	bool fFinished = false;
	bool fFoundSeparatorChars = false; // These might be '\r', '\n', or ','
	bool fQuoteMode = false;

	while (!fFinished)
	{
		switch (*m_lpCurrentLocationInLINEBUFFER)
		{
			case '"':
				// Okay, we found a quote... that's cool.. but are we quoting a quote,
				// or... are we in quote mode?

				// Probe ahead... is the next char a '"' also?
				if ( *(m_lpCurrentLocationInLINEBUFFER+1) == '"')
				{
					// Yes it is... so go ahead and copy the quote
					CopyCharIfRoom(iStringBufferSize, szStringBuffer, &iBytesCopied, &fFinished);
					if (!fFinished)
						m_lpCurrentLocationInLINEBUFFER++;	// Skip the quote
				}
				else
				{
					m_lpCurrentLocationInLINEBUFFER++;
					fQuoteMode = !fQuoteMode; // Toggle the quote mode...
					continue;
				}

			case '\0':
				fFinished = true;
				break;

			case ',':
				if (!fQuoteMode)
				{   // If we're not in quote mode, then this marks the end of a field...
					fFinished = true;
					fFoundSeparatorChars = true;
					m_lpCurrentLocationInLINEBUFFER++;
				}
				else
				{
					// Okay, this marks a new character that happens to be a comma...
					CopyCharIfRoom(iStringBufferSize, szStringBuffer, &iBytesCopied, &fFinished);
				}
				break;

			case '\r':
			case '\n':
				// We note that we found these, and simply advance the pointer...
				fFoundSeparatorChars = true;
				m_lpCurrentLocationInLINEBUFFER++;
				break;

			default:

				if (fFoundSeparatorChars)
				{
					// We were scanning... found a separator after some data... so we bail
					fFinished = true;
					break;
				}

				CopyCharIfRoom(iStringBufferSize, szStringBuffer, &iBytesCopied, &fFinished);
		}
	}

	if (iStringBufferSize) // We only NULL terminate a buffer if one was provided...
		szStringBuffer[iBytesCopied] = '\0'; // Null terminate this puppy...

	return iBytesCopied;
}

//
// This function is responsible for reading through the CSV file and creating any necessary
// objects and populating them with data...
//
bool CFileData::DispatchCollectionObject(CProcesses ** lplpProcesses, CProcessInfo ** lplpProcess, CModules ** lplpModules, CModules ** lplpKernelModeDrivers, CModuleInfoCache * lpModuleInfoCache, CFileData * lpOutputFile)
{
	enum { BUFFER_SIZE = 128};
	char szTemporaryBuffer[BUFFER_SIZE];
	TCHAR tszTemporaryBuffer[BUFFER_SIZE];